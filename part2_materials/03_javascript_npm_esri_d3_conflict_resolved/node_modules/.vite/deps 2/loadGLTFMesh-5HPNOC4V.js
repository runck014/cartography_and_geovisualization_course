import {
  e as e3,
  e2 as e4,
  f as f3,
  f2 as f4,
  l as l2,
  n2 as n3,
  o as o2,
  o2 as o3,
  o3 as o4
} from "./chunk-QUNX5MWD.js";
import {
  e as e2
} from "./chunk-URK2P56F.js";
import {
  l as l3
} from "./chunk-V63IGEOE.js";
import {
  r as r5
} from "./chunk-HLELEQS5.js";
import "./chunk-MA2KDKKH.js";
import {
  f
} from "./chunk-UHMJZXQV.js";
import "./chunk-2KYWMOKS.js";
import {
  p
} from "./chunk-FWIRGELF.js";
import {
  c,
  m,
  w
} from "./chunk-YJREYHES.js";
import {
  B
} from "./chunk-RMNZGRHI.js";
import {
  f as f2,
  o,
  u as u3
} from "./chunk-U5TYWISK.js";
import {
  n as n2,
  r as r4,
  t,
  u as u2
} from "./chunk-QYBCLVRN.js";
import "./chunk-U7ZFK3X2.js";
import "./chunk-VMQKPMJK.js";
import "./chunk-A7PB2PTS.js";
import {
  s as s2
} from "./chunk-7QP2TGTK.js";
import "./chunk-D67YPTQ2.js";
import {
  E,
  L,
  O,
  T,
  c as c2,
  i,
  u,
  x
} from "./chunk-RFXYK5PV.js";
import "./chunk-LTCEJX6G.js";
import "./chunk-L6HI4BLZ.js";
import "./chunk-5FROWG6B.js";
import {
  e
} from "./chunk-NW7VXBHZ.js";
import {
  D
} from "./chunk-KV3S4QI2.js";
import "./chunk-MM4IGEXG.js";
import {
  j,
  n
} from "./chunk-D6FJTDNK.js";
import "./chunk-LP6TMAPE.js";
import "./chunk-RENLZYKC.js";
import {
  r as r3
} from "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-XQH2QDB2.js";
import "./chunk-LPNAPHOF.js";
import {
  l
} from "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import {
  r as r2
} from "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import {
  A,
  M
} from "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import {
  r
} from "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/chunks/mat3.js
function e5(e7, t5, o7) {
  const r7 = e7.typedBuffer, f5 = e7.typedBufferStride, d = t5.typedBuffer, n4 = t5.typedBufferStride, c3 = o7 ? o7.count : t5.count;
  let u5 = ((o7 == null ? void 0 : o7.dstIndex) ?? 0) * f5, l4 = ((o7 == null ? void 0 : o7.srcIndex) ?? 0) * n4;
  for (let p2 = 0; p2 < c3; ++p2) {
    for (let e8 = 0; e8 < 9; ++e8) r7[u5 + e8] = d[l4 + e8];
    u5 += f5, l4 += n4;
  }
}
var t2 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e5 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/chunks/mat4.js
function e6(e7, t5, o7) {
  const r7 = e7.typedBuffer, f5 = e7.typedBufferStride, d = t5.typedBuffer, n4 = t5.typedBufferStride, c3 = o7 ? o7.count : t5.count;
  let u5 = ((o7 == null ? void 0 : o7.dstIndex) ?? 0) * f5, l4 = ((o7 == null ? void 0 : o7.srcIndex) ?? 0) * n4;
  for (let p2 = 0; p2 < c3; ++p2) {
    for (let e8 = 0; e8 < 16; ++e8) r7[u5 + e8] = d[l4 + e8];
    u5 += f5, l4 += n4;
  }
}
var t3 = Object.freeze(Object.defineProperty({ __proto__: null, copy: e6 }, Symbol.toStringTag, { value: "Module" }));

// node_modules/@arcgis/core/geometry/support/buffer/utils.js
function r6(s3, r7) {
  return new s3(new ArrayBuffer(r7 * s3.ElementCount * e2(s3.ElementType)));
}

// node_modules/@arcgis/core/geometry/support/meshUtils/loadGLTFMesh.js
async function K(e7, t5, o7) {
  const n4 = new n3(Q(o7)), s3 = (await l3(n4, t5, o7, true)).model, a = s3.lods.shift(), i2 = /* @__PURE__ */ new Map(), l4 = /* @__PURE__ */ new Map();
  s3.textures.forEach((e8, t6) => i2.set(t6, X(e8))), s3.materials.forEach((e8, t6) => l4.set(t6, Y(e8, i2)));
  const c3 = W(a);
  for (const r7 of c3.parts) Z(c3, r7, l4);
  const { position: u5, normal: f5, tangent: m2, color: p2, texCoord0: d } = c3.vertexAttributes, h = s2(e7, o7), T2 = e7.spatialReference.isGeographic ? s2(e7) : h, v = B({ vertexAttributes: { position: u5.typedBuffer, normal: f5 == null ? void 0 : f5.typedBuffer, tangent: m2 == null ? void 0 : m2.typedBuffer }, vertexSpace: T2, spatialReference: e7.spatialReference }, h, { allowBufferReuse: true, sourceUnit: (o7 == null ? void 0 : o7.unitConversionDisabled) ? void 0 : "meters" });
  if (!v) throw new s("load-gltf-mesh:vertex-space-projection", `Failed to load mesh from glTF because we could not convert the vertex space from ${T2.type} to ${h.type}`);
  return { transform: null, vertexSpace: h, components: c3.components, spatialReference: e7.spatialReference, vertexAttributes: new p({ ...v, color: p2 == null ? void 0 : p2.typedBuffer, uv: d == null ? void 0 : d.typedBuffer }) };
}
function Q(e7) {
  const r7 = e7 == null ? void 0 : e7.resolveFile;
  return r7 ? { busy: false, request: async (e8, o7, n4) => {
    const s3 = (r7 == null ? void 0 : r7(e8)) ?? e8, a = "image" === o7 ? "image" : "binary" === o7 || "image+type" === o7 ? "array-buffer" : "json";
    return (await U(s3, { responseType: a, signal: n4 == null ? void 0 : n4.signal, timeout: 0 })).data;
  } } : null;
}
function H(e7, t5) {
  if (null == e7) return "-";
  const r7 = e7.typedBuffer;
  return `${r(t5, r7.buffer, () => t5.size)}/${r7.byteOffset}/${r7.byteLength}`;
}
function J(e7) {
  return null != e7 ? e7.toString() : "-";
}
function W(e7) {
  let t5 = 0;
  const has = { color: false, tangent: false, normal: false, texCoord0: false }, r7 = /* @__PURE__ */ new Map(), n4 = /* @__PURE__ */ new Map(), s3 = [];
  for (const a of e7.parts) {
    const { attributes: { position: e8, normal: i2, color: l4, tangent: c3, texCoord0: u5 } } = a, f5 = `
      ${H(e8, r7)}/
      ${H(i2, r7)}/
      ${H(l4, r7)}/
      ${H(c3, r7)}/
      ${H(u5, r7)}/
      ${J(a.transform)}
    `;
    let m2 = false;
    const p2 = r(n4, f5, () => (m2 = true, { start: t5, length: e8.count }));
    m2 && (t5 += e8.count), i2 && (has.normal = true), l4 && (has.color = true), c3 && (has.tangent = true), u5 && (has.texCoord0 = true), s3.push({ gltf: a, writeVertices: m2, region: p2 });
  }
  return { vertexAttributes: { position: r6(T, t5), normal: has.normal ? r6(i, t5) : null, tangent: has.tangent ? r6(c2, t5) : null, color: has.color ? r6(x, t5) : null, texCoord0: has.texCoord0 ? r6(u, t5) : null }, parts: s3, components: [] };
}
function X(e7) {
  return new w({ data: (r5(e7.data), e7.data), wrap: re(e7.parameters.wrap) });
}
function Y(t5, r7) {
  const o7 = new l(se(t5.color, t5.opacity)), n4 = t5.emissiveFactor ? new l(ae(t5.emissiveFactor)) : null, a = (e7) => e7 ? new c({ scale: e7.scale ? [e7.scale[0], e7.scale[1]] : [1, 1], rotation: M(e7.rotation ?? 0), offset: e7.offset ? [e7.offset[0], e7.offset[1]] : [0, 0] }) : null;
  return new m({ color: o7, colorTexture: r7.get(t5.textureColor), normalTexture: r7.get(t5.textureNormal), emissiveColor: n4, emissiveTexture: r7.get(t5.textureEmissive), occlusionTexture: r7.get(t5.textureOcclusion), alphaMode: te(t5.alphaMode), alphaCutoff: t5.alphaCutoff, doubleSided: t5.doubleSided, metallic: t5.metallicFactor, roughness: t5.roughnessFactor, metallicRoughnessTexture: r7.get(t5.textureMetallicRoughness), colorTextureTransform: a(t5.colorTextureTransform), normalTextureTransform: a(t5.normalTextureTransform), occlusionTextureTransform: a(t5.occlusionTextureTransform), emissiveTextureTransform: a(t5.emissiveTextureTransform), metallicRoughnessTextureTransform: a(t5.metallicRoughnessTextureTransform) });
}
function Z(e7, t5, r7) {
  t5.writeVertices && ee(e7, t5);
  const { indices: o7, attributes: n4, primitiveType: s3, material: a } = t5.gltf;
  let i2 = o3(o7 || n4.position.count, s3);
  const l4 = t5.region.start;
  if (l4) {
    const e8 = new Uint32Array(i2);
    for (let t6 = 0; t6 < i2.length; t6++) e8[t6] += l4;
    i2 = e8;
  }
  e7.components.push(new f({ name: t5.gltf.name, faces: i2, material: r7.get(a), shading: n4.normal ? "source" : "flat", trustSourceNormals: true }));
}
function ee(e7, t5) {
  const { position: r7, normal: o7, tangent: s3, color: c3, texCoord0: u5 } = e7.vertexAttributes, f5 = t5.region.start, { attributes: m2, transform: p2 } = t5.gltf, d = m2.position.count;
  if (t(r7.slice(f5, d), m2.position, p2), null != m2.normal && null != o7) {
    const e8 = j(e(), p2), t6 = o7.slice(f5, d);
    r4(t6, m2.normal, e8), A(e8) && u2(t6, t6);
  } else null != o7 && f3(o7, 0, 0, 1, { dstIndex: f5, count: d });
  if (null != m2.tangent && null != s3) {
    const e8 = n(e(), p2), t6 = s3.slice(f5, d);
    f2(t6, m2.tangent, e8), A(e8) && o(t6, t6);
  } else null != s3 && f4(s3, 0, 0, 1, 1, { dstIndex: f5, count: d });
  if (null != m2.texCoord0 && null != u5 ? o2(u5.slice(f5, d), m2.texCoord0) : null != u5 && l2(u5, 0, 0, { dstIndex: f5, count: d }), null != m2.color && null != c3) {
    const e8 = m2.color, t6 = c3.slice(f5, d);
    if (4 === e8.elementCount) e8 instanceof c2 ? u3(t6, e8, 255) : e8 instanceof x ? e4(t6, e8) : e8 instanceof L && u3(t6, e8, 1 / 256);
    else {
      f4(t6, 255, 255, 255, 255);
      const r8 = O.fromTypedArray(t6.typedBuffer, t6.typedBufferStride);
      e8 instanceof i ? n2(r8, e8, 255) : e8 instanceof O ? e3(r8, e8) : e8 instanceof E && n2(r8, e8, 1 / 256);
    }
  } else null != c3 && f4(c3.slice(f5, d), 255, 255, 255, 255);
}
function te(e7) {
  switch (e7) {
    case "OPAQUE":
      return "opaque";
    case "MASK":
      return "mask";
    case "BLEND":
      return "blend";
  }
}
function re(e7) {
  return { horizontal: oe(e7.s), vertical: oe(e7.t) };
}
function oe(e7) {
  switch (e7) {
    case D.CLAMP_TO_EDGE:
      return "clamp";
    case D.MIRRORED_REPEAT:
      return "mirror";
    case D.REPEAT:
      return "repeat";
  }
}
function ne(e7) {
  return e7 ** (1 / o4) * 255;
}
function se(e7, t5) {
  return r3(ne(e7[0]), ne(e7[1]), ne(e7[2]), t5);
}
function ae(e7) {
  return r2(ne(e7[0]), ne(e7[1]), ne(e7[2]));
}
export {
  K as loadGLTFMesh
};
//# sourceMappingURL=loadGLTFMesh-5HPNOC4V.js.map
