import {
  m as m2,
  n as n3,
  p,
  v,
  y
} from "./chunk-R5BTSPWT.js";
import {
  a2 as a3
} from "./chunk-VNPGSD2C.js";
import {
  B
} from "./chunk-LEOFRCUR.js";
import {
  r as r3
} from "./chunk-UYSPJCCV.js";
import {
  h,
  i,
  w as w2
} from "./chunk-6D5XULXX.js";
import {
  o
} from "./chunk-HLF5XJSV.js";
import {
  r as r2
} from "./chunk-L6D73M4D.js";
import {
  s
} from "./chunk-H6RIEXAG.js";
import {
  n as n2
} from "./chunk-7O7KFKCG.js";
import {
  f
} from "./chunk-VU6O6TFT.js";
import {
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a2,
  u,
  w
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  n2 as n
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/renderers/support/ClassBreakInfo.js
var i2;
var l = i2 = class extends f {
  constructor(e) {
    super(e), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    var _a;
    return new i2({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: ((_a = this.symbol) == null ? void 0 : _a.clone()) ?? null });
  }
  getMeshHash() {
    const e = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${e}`;
  }
};
r([m({ type: String, json: { write: true } })], l.prototype, "description", void 0), r([m({ type: String, json: { write: true } })], l.prototype, "label", void 0), r([m({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], l.prototype, "minValue", void 0), r([m({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], l.prototype, "maxValue", void 0), r([m(m2)], l.prototype, "symbol", void 0), l = i2 = r([a2("esri.renderers.support.ClassBreakInfo")], l);
var a4 = l;

// node_modules/@arcgis/core/renderers/ClassBreaksRenderer.js
var v2;
var B2 = "log";
var F = "percent-of-total";
var S = "field";
var V = new n2({ esriNormalizeByLog: B2, esriNormalizeByPercentOfTotal: F, esriNormalizeByField: S });
var E = w(a4);
var j = v2 = class extends v(p) {
  constructor(e) {
    super(e), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = true, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e, s2, t) {
    if (!Array.isArray(e)) return;
    let o2 = s2.minValue;
    return e.map((e2) => {
      const s3 = new a4();
      return s3.read(e2, t), null == s3.minValue && (s3.minValue = o2), null == s3.maxValue && (s3.maxValue = s3.minValue), o2 = s3.maxValue, s3;
    });
  }
  writeClassBreakInfos(e, s2, t, o2) {
    const i3 = e.map((e2) => e2.write({}, o2));
    this._areClassBreaksConsecutive() && i3.forEach((e2) => delete e2.classMinValue), s2[t] = i3;
  }
  castField(e) {
    return null == e ? e : "function" == typeof e ? (n.getLogger(this).error(".field: field must be a string value"), null) : u(e);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e = this._get("normalizationType");
    const s2 = !!this.normalizationField, t = null != this.normalizationTotal;
    return s2 || t ? (e = s2 && S || t && F || null, s2 && t && n.getLogger(this).warn("warning: both normalizationField and normalizationTotal are set!")) : e !== S && e !== F || (e = null), e;
  }
  set normalizationType(e) {
    this._set("normalizationType", e);
  }
  addClassBreakInfo(e, t, i3) {
    let r4 = null;
    r4 = "number" == typeof e ? new a4({ minValue: e, maxValue: t, symbol: B(i3) }) : E(a(e)), this.classBreakInfos.push(r4), 1 === this.classBreakInfos.length && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e, s2) {
    const t = this.classBreakInfos.length;
    for (let o2 = 0; o2 < t; o2++) {
      const t2 = [this.classBreakInfos[o2].minValue, this.classBreakInfos[o2].maxValue];
      if (t2[0] === e && t2[1] === s2) {
        this.classBreakInfos.splice(o2, 1);
        break;
      }
    }
  }
  getBreakIndex(e, s2) {
    return this.valueExpression && null == (s2 == null ? void 0 : s2.arcade) && n.getLogger(this).warn(""), this.valueExpression ? this._getBreakIndexForExpression(e, s2) : this._getBreakIndexForField(e);
  }
  async getClassBreakInfo(e, s2) {
    let t = s2;
    this.valueExpression && null == (s2 == null ? void 0 : s2.arcade) && (t = { ...t, arcade: await i() });
    const o2 = this.getBreakIndex(e, t);
    return -1 !== o2 ? this.classBreakInfos[o2] : null;
  }
  getSymbol(e, s2) {
    if (this.valueExpression && null == (s2 == null ? void 0 : s2.arcade)) return void n.getLogger(this).error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const t = this.getBreakIndex(e, s2);
    return t > -1 ? this.classBreakInfos[t].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e, s2) {
    let t = s2;
    if (this.valueExpression && null == (s2 == null ? void 0 : s2.arcade)) {
      const e2 = await i(), { arcadeUtils: s3 } = e2;
      s3.hasGeometryOperations(this.valueExpression) && await s3.enableGeometryOperations(), t = { ...t, arcade: e2 };
    }
    const o2 = this.getBreakIndex(e, t);
    return o2 > -1 ? this.classBreakInfos[o2].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e = [];
    return this.classBreakInfos.forEach((s2) => {
      s2.symbol && e.push(s2.symbol);
    }), this.defaultSymbol && e.push(this.defaultSymbol), e;
  }
  getAttributeHash() {
    var _a;
    return ((_a = this.visualVariables) == null ? void 0 : _a.reduce((e, s2) => e + s2.getAttributeHash(), "")) ?? "";
  }
  getMeshHash() {
    const e = JSON.stringify(this.backgroundFillSymbol), s2 = JSON.stringify(this.defaultSymbol), t = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e}.${s2}.${this.classBreakInfos.reduce((e2, s3) => e2 + s3.getMeshHash(), "")}.${t}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    var _a, _b;
    return new v2({ field: this.field, backgroundFillSymbol: (_a = this.backgroundFillSymbol) == null ? void 0 : _a.clone(), defaultLabel: this.defaultLabel, defaultSymbol: (_b = this.defaultSymbol) == null ? void 0 : _b.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: a(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: a(this.visualVariables), legendOptions: a(this.legendOptions), authoringInfo: a(this.authoringInfo) });
  }
  async collectRequiredFields(e, s2) {
    const t = [this.collectVVRequiredFields(e, s2), this.collectSymbolFields(e, s2)];
    await Promise.all(t);
  }
  async collectSymbolFields(e, s2) {
    const t = [...this.getSymbols().map((t2) => t2.collectRequiredFields(e, s2)), h(e, s2, this.valueExpression)];
    w2(e, s2, this.field), w2(e, s2, this.normalizationField), await Promise.all(t);
  }
  _getBreakIndexForExpression(e, s2) {
    const { viewingMode: t, scale: o2, spatialReference: i3, arcade: r4, timeZone: a5 } = s2 ?? {}, { valueExpression: l2 } = this;
    let n4 = this._compiledValueExpression.valueExpression === l2 ? this._compiledValueExpression.compiledFunction : null;
    const u2 = r4.arcadeUtils;
    if (!n4) {
      const e2 = u2.createSyntaxTree(l2);
      n4 = u2.createFunction(e2), this._compiledValueExpression.compiledFunction = n4;
    }
    this._compiledValueExpression.valueExpression = l2;
    const c = u2.executeFunction(n4, u2.createExecContext(e, u2.getViewInfo({ viewingMode: t, scale: o2, spatialReference: i3 }), a5));
    return this._getBreakIndexfromInfos(c);
  }
  _getBreakIndexForField(e) {
    const s2 = this.field, t = e.attributes, o2 = this.normalizationType;
    let i3 = parseFloat(t[s2]);
    if (o2) {
      const e2 = this.normalizationTotal, s3 = parseFloat(this.normalizationField ? t[this.normalizationField] : void 0);
      if (o2 === B2) i3 = Math.log(i3) * Math.LOG10E;
      else if (o2 !== F || null == e2 || isNaN(e2)) {
        if (o2 === S && !isNaN(s3)) {
          if (isNaN(i3) || isNaN(s3)) return -1;
          i3 /= s3;
        }
      } else i3 = i3 / e2 * 100;
    }
    return this._getBreakIndexfromInfos(i3);
  }
  _getBreakIndexfromInfos(e) {
    const s2 = this.isMaxInclusive;
    if (null != e && "number" == typeof e && !isNaN(e)) for (let t = 0; t < this.classBreakInfos.length; t++) {
      const o2 = [this.classBreakInfos[t].minValue, this.classBreakInfos[t].maxValue];
      if (o2[0] <= e && (s2 ? e <= o2[1] : e < o2[1])) return t;
    }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e = this.classBreakInfos, s2 = e.length;
    for (let t = 1; t < s2; t++) if (e[t - 1].maxValue !== e[t].minValue) return false;
    return true;
  }
};
r([m(n3)], j.prototype, "backgroundFillSymbol", void 0), r([m({ type: [a4] })], j.prototype, "classBreakInfos", void 0), r([o("classBreakInfos")], j.prototype, "readClassBreakInfos", null), r([r2("classBreakInfos")], j.prototype, "writeClassBreakInfos", null), r([m({ type: String, json: { write: true } })], j.prototype, "defaultLabel", void 0), r([m(y)], j.prototype, "defaultSymbol", void 0), r([m({ type: String, json: { write: true } })], j.prototype, "field", void 0), r([s("field")], j.prototype, "castField", null), r([m({ type: Boolean })], j.prototype, "isMaxInclusive", void 0), r([m({ type: a3, json: { write: true } })], j.prototype, "legendOptions", void 0), r([m({ type: Number, readOnly: true, value: null, json: { read: false, write: { overridePolicy() {
  return 0 !== this.classBreakInfos.length && this._areClassBreaksConsecutive() ? { enabled: true } : { enabled: false };
} } } })], j.prototype, "minValue", null), r([m({ type: String, json: { write: true } })], j.prototype, "normalizationField", void 0), r([m({ type: Number, json: { write: true } })], j.prototype, "normalizationTotal", void 0), r([m({ type: V.apiValues, value: null, json: { type: V.jsonValues, read: V.read, write: V.write } })], j.prototype, "normalizationType", null), r([r3({ classBreaks: "class-breaks" })], j.prototype, "type", void 0), r([m({ type: String, json: { write: true } })], j.prototype, "valueExpression", void 0), r([m({ type: String, json: { write: true } })], j.prototype, "valueExpressionTitle", void 0), j = v2 = r([a2("esri.renderers.ClassBreaksRenderer")], j);
var z = j;

export {
  a4 as a,
  z
};
//# sourceMappingURL=chunk-JHXGQ3AW.js.map
