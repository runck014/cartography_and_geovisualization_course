import {
  d,
  s
} from "./chunk-VLKWWBLY.js";

// node_modules/@arcgis/core/symbols/cim/defaultCIMValues.js
var o = { color: [128, 128, 128, 1], outlinecolor: [0, 0, 0, 1], backgroundcolor: [128, 128, 128, 1], borderlinecolor: [0, 0, 0, 1], tintcolor: [255, 255, 255, 1] };
var i = { CIMVectorMarker: { scalesymbolsproportionally: false, respectframe: true, anchorpointunits: "Relative", offsetx: 0, offsety: 0, rotateclockwise: false, rotation: 0, size: 10, enable: true, colorlocked: false }, CIMPictureMarker: { scalex: 1, texturefilter: "Draft", anchorpointunits: "Relative", offsetx: 0, offsety: 0, rotateclockwise: false, rotation: 0, size: 10, enable: true, colorlocked: false }, CIMTextSymbol: { angle: 0, anglex: 0, angley: 0, halosize: 1, height: 10, horizontalalignment: "Left", kerning: true, letterspacing: 0, letterwidth: 100, ligatures: true, linegap: 0, offsetx: 0, offsety: 0, strikethrough: false, textcase: "Normal", textstring: "", underline: false, verticalalignment: "Bottom", enable: true, colorlocked: false }, CIMSolidStroke: { capstyle: "Round", joinstyle: "Round", miterlimit: 4, width: 4, enable: true, colorlocked: false }, CIMPictureStroke: { texturefilter: "Draft", capstyle: "Round", joinstyle: "Round", miterlimit: 4, width: 4, enable: true, colorlocked: false }, CIMGradientStroke: { capstyle: "Round", joinstyle: "Round", miterlimit: 4, width: 4, enable: true, colorlocked: false }, CIMSolidFill: { enable: true, colorlocked: false }, CIMPictureFill: { offsetx: 0, offsety: 0, rotation: 0, scalex: 1, height: 10, texturefilter: "Draft", enable: true, colorlocked: false }, CIMHatchFill: { offsetx: 0, offsety: 0, rotation: 0, separation: 4, enable: true, colorlocked: false }, CIMGeometricEffectAddControlPoints: { angletolerance: 120 }, CIMGeometricEffectArrow: { arrowtype: "OpenEnded", width: 5 }, CIMGeometricEffectBuffer: { size: 1 }, CIMGeometricEffectCut: { begincut: 1, endcut: 1, middlecut: 0, invert: false }, CIMGeometricEffectDashes: { customendingoffset: 0, linedashending: "NoConstraint", offsetalongline: 0 }, CIMGeometricEffectDonut: { method: "Mitered", option: "Accurate", width: 2 }, CIMGeometricEffectJog: { angle: 225, length: 20, position: 50 }, CIMGeometricEffectControlMeasureLine: { rule: "FullGeometry" }, CIMGeometricEffectMove: { offsetx: 1, offsety: -1 }, CIMGeometricEffectOffset: { method: "Square", offset: 1, option: "Fast" }, CIMGeometricEffectRotate: { angle: 15 }, CIMGeometricEffectScale: { xscalefactor: 1.15, yscalefactor: 1.15 }, CIMGeometricEffectWave: { amplitude: 2, period: 3, seed: 1, waveform: "Sinus" }, CIMMarkerPlacementAlongLine: { customendingoffset: 0, endings: "WithHalfGap", offsetalongline: 0, placeperpart: true, angletoline: true, offset: 0 }, CIMMarkerPlacementAtExtremities: { extremityplacement: "Both", offsetalongline: 0, angletoline: true, offset: 0 }, CIMMarkerPlacementAtRatioPositions: { beginposition: 0, endposition: 0, flipfirst: true, angletoline: true, offset: 0 }, CIMMarkerPlacementInsidePolygon: { gridangle: 0, gridtype: "Fixed", offsetx: 0, offsety: 0, randomness: 100, seed: 0, shiftoddrows: false, stepx: 16, stepy: 16, clipping: "ClipAtBoundary" }, CIMMarkerPlacementOnLine: { relativeto: "LineMiddle", startpointoffset: 0, angletoline: true, offset: 0 }, CIMMarkerPlacementOnVertices: { placeperpart: true, placeoncontrolpoints: true, placeonendpoints: true, placeonregularvertices: true, angletoline: true, offset: 0 }, CIMMarkerPlacementPolygonCenter: { method: "OnPolygon", offsetx: 0, offsety: 0, clipatboundary: false }, CIMAnimatedSymbolProperties: { playanimation: false, reverseanimation: false, randomizestarttime: false, randomizestartseed: 0, starttimeoffset: 0, duration: 3, endingduration: 3, useendingduration: false, repeattype: d.Loop, repeatdelay: 0, easing: s.Linear }, CIMSymbolAnimationSize: { tosize: 10 }, CIMSymbolAnimationScale: { scalefactor: 1 }, CIMSymbolAnimationColor: { tocolor: [255, 255, 255, 1] }, CIMSymbolAnimationTransparency: { totransparency: 0 }, CIMSymbolAnimationRotation: { torotation: 0 }, CIMSymbolAnimationOffset: { offsetx: 0, offsety: 0 } };

// node_modules/@arcgis/core/symbols/cim/utils.js
function o2(e) {
  return [e.r, e.g, e.b, e.a];
}
var l = " /-,\n";
function i2(e) {
  let t = e.length;
  for (; t--; ) if (!l.includes(e.charAt(t))) return false;
  return true;
}
function a(e, t) {
  const r = [];
  let n = 0, o3 = -1;
  do {
    if (o3 = e.indexOf("[", n), o3 >= n) {
      if (o3 > n) {
        const t2 = e.slice(n, o3);
        r.push([t2, null, i2(t2)]);
      }
      if (n = o3 + 1, o3 = e.indexOf("]", n), o3 >= n) {
        if (o3 > n) {
          const l2 = t[e.slice(n, o3)];
          l2 && r.push([null, l2, false]);
        }
        n = o3 + 1;
      }
    }
  } while (-1 !== o3);
  if (n < e.length) {
    const t2 = e.slice(n);
    r.push([t2, null, i2(t2)]);
  }
  return r;
}
function c(e, t, r, n) {
  let o3 = "", l2 = null;
  for (const i3 of t) {
    const [t2, n2, a2] = i3;
    if (t2) a2 ? l2 = t2 : (l2 && (o3 += l2, l2 = null), o3 += t2);
    else {
      let t3 = n2;
      null != r && (t3 = J(n2, r));
      const i4 = e.attributes[t3];
      i4 && (l2 && (o3 += l2, l2 = null), o3 += i4);
    }
  }
  return s2(o3, n);
}
function s2(e, t) {
  switch ("string" != typeof e && (e = String(e)), t) {
    case "LowerCase":
      return e.toLowerCase();
    case "Allcaps":
      return e.toUpperCase();
    default:
      return e;
  }
}
function u(e, t, r, n, o3, l2, i3 = true) {
  const a2 = t / o3, c2 = r / l2, s3 = Math.ceil(a2 / 2), u2 = Math.ceil(c2 / 2);
  for (let f2 = 0; f2 < l2; f2++) for (let r2 = 0; r2 < o3; r2++) {
    const y2 = 4 * (r2 + (i3 ? l2 - f2 - 1 : f2) * o3);
    let M2 = 0, m2 = 0, C2 = 0, I2 = 0, p2 = 0, h2 = 0, b2 = 0;
    const d3 = (f2 + 0.5) * c2;
    for (let n2 = Math.floor(f2 * c2); n2 < (f2 + 1) * c2; n2++) {
      const o4 = Math.abs(d3 - (n2 + 0.5)) / u2, l3 = (r2 + 0.5) * a2, i4 = o4 * o4;
      for (let c3 = Math.floor(r2 * a2); c3 < (r2 + 1) * a2; c3++) {
        let r3 = Math.abs(l3 - (c3 + 0.5)) / s3;
        const o5 = Math.sqrt(i4 + r3 * r3);
        o5 >= -1 && o5 <= 1 && (M2 = 2 * o5 * o5 * o5 - 3 * o5 * o5 + 1, M2 > 0 && (r3 = 4 * (c3 + n2 * t), b2 += M2 * e[r3 + 3], C2 += M2, e[r3 + 3] < 255 && (M2 = M2 * e[r3 + 3] / 250), I2 += M2 * e[r3], p2 += M2 * e[r3 + 1], h2 += M2 * e[r3 + 2], m2 += M2));
      }
    }
    n[y2] = I2 / m2, n[y2 + 1] = p2 / m2, n[y2 + 2] = h2 / m2, n[y2 + 3] = b2 / C2;
  }
}
function f(e) {
  return e ? [e[0], e[1], e[2], e[3] / 255] : [0, 0, 0, 0];
}
function y(e) {
  var _a;
  return ((_a = e.data) == null ? void 0 : _a.symbol) ?? null;
}
function M(e) {
  return "CIMVectorMarker" === e.type || "CIMPictureMarker" === e.type || "CIMBarChartMarker" === e.type || "CIMCharacterMarker" === e.type || "CIMPieChartMarker" === e.type || "CIMStackedBarChartMarker" === e.type;
}
function m(e) {
  return "CIMGradientStroke" === e.type || "CIMPictureStroke" === e.type || "CIMSolidStroke" === e.type;
}
function C(e) {
  return null != e && ("CIMGradientFill" === e.type || "CIMHatchFill" === e.type || "CIMPictureFill" === e.type || "CIMSolidFill" === e.type || "CIMWaterFill" === e.type);
}
function I(e) {
  return null != e && ("CIMMarkerPlacementAlongLineRandomSize" === e.type || "CIMMarkerPlacementAlongLineSameSize" === e.type || "CIMMarkerPlacementAlongLineVariableSize" === e.type || "CIMMarkerPlacementAtExtremities" === e.type || "CIMMarkerPlacementAtMeasuredUnits" === e.type || "CIMMarkerPlacementAtRatioPositions" === e.type || "CIMMarkerPlacementOnLine" === e.type || "CIMMarkerPlacementOnVertices" === e.type);
}
var p = (e, t = 0) => null == e || isNaN(e) ? t : e;
var h = (e, t) => null != e ? e : t;
var b = (e, t) => e ?? t;
var d2 = (e) => e.tintColor ? f(e.tintColor) : [255, 255, 255, 1];
var k = (e) => {
  if (!e) return false;
  for (const t of e) switch (t.type) {
    case "CIMGeometricEffectBuffer":
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectDonut":
      return true;
  }
  return false;
};
function S() {
  return import("./geometryEngineJSON-T2WTIVKL.js");
}
function g(e) {
  if (!e) return "normal";
  switch (e.toLowerCase()) {
    case "italic":
      return "italic";
    case "oblique":
      return "oblique";
    default:
      return "normal";
  }
}
function P(e) {
  if (!e) return "normal";
  switch (e.toLowerCase()) {
    case "bold":
      return "bold";
    case "bolder":
      return "bolder";
    case "lighter":
      return "lighter";
    default:
      return "normal";
  }
}
function w(e) {
  let t = "normal", r = "normal";
  if (e) {
    const n = e.toLowerCase();
    n.includes("italic") ? t = "italic" : n.includes("oblique") && (t = "oblique"), n.includes("bold") ? r = "bold" : n.includes("light") && (r = "lighter");
  }
  return { style: t, weight: r };
}
function L(e) {
  return e.underline ? "underline" : e.strikethrough ? "line-through" : "none";
}
function T(e) {
  if (!e) return null;
  switch (e.type) {
    case "CIMPolygonSymbol":
      if (e.symbolLayers) for (const t of e.symbolLayers) {
        const e2 = T(t);
        if (null != e2) return e2;
      }
      break;
    case "CIMTextSymbol":
      return T(e.symbol);
    case "CIMSolidFill":
      return e.color;
  }
  return null;
}
function A(e) {
  if (e) switch (e.type) {
    case "CIMPolygonSymbol":
    case "CIMLineSymbol": {
      const t = e.symbolLayers;
      if (t) for (const e2 of t) {
        const t2 = A(e2);
        if (null != t2) return t2;
      }
      break;
    }
    case "CIMTextSymbol":
      return A(e.symbol);
    case "CIMSolidStroke":
      return e.color;
  }
}
function N(e) {
  if (e) switch (e.type) {
    case "CIMPolygonSymbol":
    case "CIMLineSymbol":
      if (e.symbolLayers) for (const t of e.symbolLayers) {
        const e2 = N(t);
        if (void 0 !== e2) return e2;
      }
      break;
    case "CIMTextSymbol":
      return N(e.symbol);
    case "CIMSolidStroke":
    case "CIMGradientStroke":
    case "CIMPictureStroke":
      return e.width;
  }
}
function x(e) {
  switch (e) {
    case "Left":
    default:
      return "left";
    case "Right":
      return "right";
    case "Center":
    case "Justify":
      return "center";
  }
}
function F(e) {
  switch (e) {
    case "Top":
    default:
      return "top";
    case "Center":
      return "middle";
    case "Baseline":
      return "baseline";
    case "Bottom":
      return "bottom";
  }
}
function v(e) {
  return (e ? Object.keys(e) : []).map((t) => ({ name: t, alias: t, type: "string" == typeof e[t] ? "esriFieldTypeString" : "esriFieldTypeDouble" }));
}
var G = (e) => e.includes("data:image/svg+xml");
function V(e) {
  if (!e) return null;
  switch (e.type) {
    case "CIMPointSymbol":
    case "CIMTextSymbol":
      return "esriGeometryPoint";
    case "CIMLineSymbol":
      return "esriGeometryPolyline";
    case "CIMPolygonSymbol":
      return "esriGeometryPolygon";
    default:
      return null;
  }
}
function z(e) {
  return e ? e.charAt(0).toLowerCase() + e.slice(1) : e;
}
function E(e, t, r, n, o3, l2, i3 = true) {
  const { infos: a2 } = l2;
  let c2 = 1, s3 = 0, u2 = 0, f2 = 0, y2 = 1;
  for (const { absoluteAnchorPoint: C2, offsetX: I2, offsetY: p2, rotation: h2, size: b2, frameHeight: d3, rotateClockWise: k2, scaleSymbolsProportionally: S2 } of a2) {
    y2 = C2 ? 1 : c2;
    u2 = Y(I2, p2, s3, y2, u2), f2 = X(I2, p2, s3, y2, f2), d3 && (S2 || i3) && (c2 *= b2 / d3), s3 = $(h2, k2, s3);
  }
  const M2 = Y(n, o3, s3, y2, u2), m2 = X(n, o3, s3, y2, f2);
  return { size: e * c2, rotation: $(t, r, s3), offsetX: M2, offsetY: m2 };
}
function O(e) {
  if (null == e) return false;
  if (Array.isArray(e)) return e.every((e2) => O(e2));
  switch (typeof e) {
    case "string":
      return !!e;
    case "number":
      return !isNaN(e);
  }
}
function D(r, n) {
  if ("color" === n || "outlinecolor" === n || "backgroundcolor" === n || "borderlinecolor" === n || "tintcolor" === n) return [...o[n]];
  const o3 = i[r];
  if (!o3) throw new Error(`InternalError: default value for type ${r}.`);
  return o3[n];
}
function j(e) {
  return e.split(" ").map((e2) => Number(e2));
}
function q(e) {
  return "string" == typeof e ? j(e) : e;
}
function B(e) {
  return (e == null ? void 0 : e.dashTemplate) && (e.dashTemplate = q(e.dashTemplate)), e;
}
function R(e) {
  if (null == e) return "Normal";
  switch (e.type) {
    case "CIMTextSymbol":
      return e.textCase ?? "Normal";
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol":
      {
        const t = e.symbolLayers;
        if (!t) return "Normal";
        for (const e2 of t) if ("CIMVectorMarker" === e2.type) return R(e2);
      }
      break;
    case "CIMVectorMarker": {
      const t = e.markerGraphics;
      if (!t) return "Normal";
      for (const e2 of t) if (e2.symbol) return R(e2.symbol);
    }
  }
  return "Normal";
}
function H(e) {
  if (e) switch (e.type) {
    case "CIMTextSymbol":
      return e.height;
    case "CIMPointSymbol": {
      let r = 0;
      if (e.symbolLayers) {
        for (const n of e.symbolLayers) if (n) switch (n.type) {
          case "CIMCharacterMarker":
          case "CIMPictureMarker":
          case "CIMVectorMarker":
          case "CIMObjectMarker3D":
          case "CIMglTFMarker3D": {
            const e2 = n.size ?? i.CIMVectorMarker.size;
            e2 > r && (r = e2);
            break;
          }
        }
      }
      return r;
    }
    case "CIMLineSymbol":
    case "CIMPolygonSymbol": {
      let r = 0;
      if (e.symbolLayers) {
        for (const n of e.symbolLayers) if (n) switch (n.type) {
          case "CIMSolidStroke":
          case "CIMPictureStroke":
          case "CIMGradientStroke": {
            const e2 = n.width;
            null != e2 && e2 > r && (r = e2);
            break;
          }
          case "CIMCharacterMarker":
          case "CIMPictureMarker":
          case "CIMVectorMarker":
          case "CIMObjectMarker3D":
          case "CIMglTFMarker3D":
            if (n.markerPlacement && I(n.markerPlacement)) {
              const e2 = n.size ?? i.CIMVectorMarker.size;
              e2 > r && (r = e2);
            }
            break;
          case "CIMPictureFill": {
            const e2 = n.height;
            null != e2 && e2 > r && (r = e2);
          }
        }
      }
      return r;
    }
  }
}
function J(e, t) {
  if (null !== t) {
    const r = t.get(e);
    return r ? r.name : e;
  }
  return e;
}
function U(e) {
  return e.map((e2) => ({ ...e2, propertyName: z(e2.propertyName) }));
}
function W(e) {
  const t = {};
  for (const r in e) {
    const n = e[r];
    t[z(r)] = n;
  }
  return t;
}
function X(e, t, r, n, o3) {
  const l2 = r * Math.PI / 180;
  if (l2) {
    const r2 = Math.cos(l2);
    return (Math.sin(l2) * e + r2 * t) * n + o3;
  }
  return t * n + o3;
}
function Y(e, t, r, n, o3) {
  const l2 = r * Math.PI / 180;
  if (l2) {
    return (Math.cos(l2) * e - Math.sin(l2) * t) * n + o3;
  }
  return e * n + o3;
}
function $(e, t, r) {
  return t ? r - e : r + e;
}
function K(e, t, r) {
  const n = "Color" === r || "TintColor" === r || "ToColor" === r, o3 = "Rotation" === r || "Angle" === r || "ToRotation" === r;
  let l2 = t[z(r)];
  if (null != l2 && (n ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3] / 255] : o3 && (l2 *= Math.PI / 180)), null == l2 && (l2 = D(t.type, r.toLowerCase()), null != l2 && (n ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3]] : o3 && (l2 *= Math.PI / 180))), null != t.primitiveName) {
    const i3 = e[t.primitiveName];
    if (null != i3) {
      const e2 = i3[r];
      null == e2 || ("string" == typeof e2 || "number" == typeof e2 || Array.isArray(e2) ? (l2 = e2, null != l2 && (n ? l2 = [l2[0] / 255, l2[1] / 255, l2[2] / 255, l2[3] / 255] : o3 && (l2 *= Math.PI / 180))) : (l2 = { valueExpressionInfo: e2, defaultValue: l2 }, null != l2 && (n ? l2 = { type: "Process", op: "ArcadeColor", value: l2 } : o3 && (l2 = { type: "Process", op: "Divide", left: l2, right: 180 / Math.PI }))));
    }
  }
  if (null == l2) throw new Error(`Failed to derive a value or an expression for "${r}".`);
  return l2;
}

export {
  i,
  o2 as o,
  a,
  c,
  u,
  f,
  y,
  M,
  m,
  C,
  I,
  p,
  h,
  b,
  d2 as d,
  k,
  S,
  g,
  P,
  w,
  L,
  T,
  A,
  N,
  x,
  F,
  v,
  G,
  V,
  z,
  E,
  O,
  D,
  q,
  B,
  R,
  H,
  J,
  U,
  W,
  K
};
//# sourceMappingURL=chunk-MR727DXB.js.map
