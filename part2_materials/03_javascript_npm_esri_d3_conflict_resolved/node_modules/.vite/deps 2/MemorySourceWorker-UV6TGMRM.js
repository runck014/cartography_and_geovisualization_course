import {
  n,
  t
} from "./chunk-CWXFVMMT.js";
import {
  d,
  f,
  j as j2,
  p as p2,
  y
} from "./chunk-DBGQDDBK.js";
import "./chunk-5PXF5FL6.js";
import {
  m
} from "./chunk-3UBBIAM6.js";
import "./chunk-VS6HWAZD.js";
import {
  V
} from "./chunk-PQMYL64R.js";
import "./chunk-RSF7AFW5.js";
import "./chunk-VWXOSXKG.js";
import "./chunk-KVWJ4FJP.js";
import "./chunk-4WCKSWXU.js";
import "./chunk-P4TUSPKE.js";
import "./chunk-WI4GZYZR.js";
import "./chunk-M43YLXNM.js";
import {
  et,
  nt,
  tt
} from "./chunk-BLBULF2O.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import {
  a,
  l,
  u as u2
} from "./chunk-NCJB5REK.js";
import "./chunk-MSUBZ5BW.js";
import "./chunk-E6IUAXXM.js";
import {
  j,
  x
} from "./chunk-XJHQ5ZJ7.js";
import "./chunk-HACIIBEF.js";
import "./chunk-WCAEZENI.js";
import "./chunk-MBR7IVUG.js";
import "./chunk-WVLGRCY6.js";
import "./chunk-QEJMJI2R.js";
import "./chunk-MCZMPI2A.js";
import "./chunk-IJO7BOFI.js";
import "./chunk-NGQEHRBA.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import {
  Z
} from "./chunk-GGPPKSP2.js";
import "./chunk-WPERPIJF.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-6GD5IU2W.js";
import "./chunk-XQ3CVA7I.js";
import {
  i as i2
} from "./chunk-SUZN3TAH.js";
import "./chunk-LXJGKQ4D.js";
import "./chunk-IOKAACTA.js";
import "./chunk-D2JPDRZZ.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-B5NBTUMV.js";
import "./chunk-TCZ4QHYH.js";
import "./chunk-SMFCDOAJ.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-DIKY6MBW.js";
import "./chunk-YVSEBNS4.js";
import {
  H,
  K
} from "./chunk-6D5XULXX.js";
import "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import {
  p,
  u
} from "./chunk-F26LCWNQ.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import {
  i
} from "./chunk-JS7R723S.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-BMGF5ELJ.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import {
  U
} from "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/graphics/sources/support/MemorySourceWorker.js
var R = U;
var q = { xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: U };
var D = { hasAttachments: false, capabilities: "query, editing, create, delete, update", useStandardizedQueries: true, supportsCoordinatesQuantization: true, supportsReturningQueryGeometry: true, advancedQueryCapabilities: { supportsQueryAttachments: false, supportsStatistics: true, supportsPercentileStatistics: true, supportsReturningGeometryCentroid: true, supportsQueryWithDistance: true, supportsDistinct: true, supportsReturningQueryExtent: true, supportsReturningGeometryProperties: false, supportsHavingClause: true, supportsOrderBy: true, supportsPagination: true, supportsQueryWithResultType: true, supportsSqlExpression: true, supportsDisjointSpatialRel: true, supportsQueryWithCacheHint: true } };
function O(e) {
  return u(e) ? null != e.z : !!e.hasZ;
}
function w(e) {
  return u(e) ? null != e.m : !!e.hasM;
}
var S = class {
  constructor() {
    this._queryEngine = null, this._nextObjectId = null;
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = this._createDefaultAttributes = null;
  }
  async load(t2) {
    const i3 = [], { features: s2 } = t2, n2 = this._inferLayerProperties(s2, t2.fields), r = t2.fields || [], a2 = null != t2.hasM ? t2.hasM : !!n2.hasM, p3 = null != t2.hasZ ? t2.hasZ : !!n2.hasZ, h = !t2.spatialReference && !n2.spatialReference, g = h ? R : t2.spatialReference || n2.spatialReference, I = h ? q : null, F = t2.geometryType || n2.geometryType, b = !F;
    let O2 = t2.objectIdField || n2.objectIdField, w2 = t2.timeInfo;
    const S2 = new Z(r);
    if (!b && (h && i3.push({ name: "feature-layer:spatial-reference-not-found", message: "Spatial reference not provided or found in features. Defaults to WGS84" }), !F)) throw new s("feature-layer:missing-property", "geometryType not set and couldn't be inferred from the provided features");
    if (!O2) throw new s("feature-layer:missing-property", "objectIdField not set and couldn't be found in the provided fields");
    if (n2.objectIdField && O2 !== n2.objectIdField && (i3.push({ name: "feature-layer:duplicated-oid-field", message: `Provided objectIdField "${O2}" doesn't match the field name "${n2.objectIdField}", found in the provided fields` }), O2 = n2.objectIdField), O2 && !n2.objectIdField) {
      const e = S2.get(O2);
      e ? (O2 = e.name, e.type = "esriFieldTypeOID", e.editable = false, e.nullable = false) : r.unshift({ alias: O2, name: O2, type: "esriFieldTypeOID", editable: false, nullable: false });
    }
    for (const o of r) {
      if (null == o.name && (o.name = o.alias), null == o.alias && (o.alias = o.name), !o.name) throw new s("feature-layer:invalid-field-name", "field name is missing", { field: o });
      if (o.name === O2 && (o.type = "esriFieldTypeOID"), !i2.jsonValues.includes(o.type)) throw new s("feature-layer:invalid-field-type", `invalid type for field "${o.name}"`, { field: o });
      null == o.length && (o.length = K(o));
    }
    const v = {};
    for (const e of r) if ("esriFieldTypeOID" !== e.type && "esriFieldTypeGlobalID" !== e.type) {
      const t3 = H(e);
      void 0 !== t3 && (v[e.name] = t3);
    }
    if (w2) {
      if (w2.startTimeField) {
        const e = S2.get(w2.startTimeField);
        e ? (w2.startTimeField = e.name, e.type = "esriFieldTypeDate") : w2.startTimeField = null;
      }
      if (w2.endTimeField) {
        const e = S2.get(w2.endTimeField);
        e ? (w2.endTimeField = e.name, e.type = "esriFieldTypeDate") : w2.endTimeField = null;
      }
      if (w2.trackIdField) {
        const e = S2.get(w2.trackIdField);
        e ? w2.trackIdField = e.name : (w2.trackIdField = null, i3.push({ name: "feature-layer:invalid-timeInfo-trackIdField", message: "trackIdField is missing", details: { timeInfo: w2 } }));
      }
      w2.startTimeField || w2.endTimeField || (i3.push({ name: "feature-layer:invalid-timeInfo", message: "startTimeField and endTimeField are missing or invalid", details: { timeInfo: w2 } }), w2 = null);
    }
    const Q = S2.dateFields.length ? { timeZoneIANA: t2.dateFieldsTimeZone ?? i } : null;
    this._createDefaultAttributes = a(v, O2);
    const M = { warnings: i3, featureErrors: [], layerDefinition: { ...D, drawingInfo: u2(F), templates: l(v), extent: I, geometryType: F, objectIdField: O2, fields: r, hasZ: p3, hasM: a2, timeInfo: w2, dateFieldsTimeReference: Q }, assignedObjectIds: {} };
    if (this._queryEngine = new V({ fieldsIndex: Z.fromLayerJSON({ fields: r, timeInfo: w2, dateFieldsTimeReference: Q }), geometryType: F, hasM: a2, hasZ: p3, objectIdField: O2, spatialReference: g, featureStore: new m({ geometryType: F, hasM: a2, hasZ: p3 }), timeInfo: w2 }), !(s2 == null ? void 0 : s2.length)) return this._nextObjectId = t, M;
    const Z2 = n(O2, s2);
    return this._nextObjectId = Z2 + 1, await x(s2, g), this._loadInitialFeatures(M, s2);
  }
  async applyEdits(e) {
    const { spatialReference: t2, geometryType: i3 } = this._queryEngine;
    return await Promise.all([j2(t2, i3), x(e.adds, t2), x(e.updates, t2)]), this._applyEdits(e);
  }
  queryFeatures(e, t2 = {}) {
    return this._queryEngine.executeQuery(e, t2.signal);
  }
  queryFeatureCount(e, t2 = {}) {
    return this._queryEngine.executeQueryForCount(e, t2.signal);
  }
  queryObjectIds(e, t2 = {}) {
    return this._queryEngine.executeQueryForIds(e, t2.signal);
  }
  queryExtent(e, t2 = {}) {
    return this._queryEngine.executeQueryForExtent(e, t2.signal);
  }
  querySnapping(e, t2 = {}) {
    return this._queryEngine.executeQueryForSnapping(e, t2.signal);
  }
  _inferLayerProperties(e, i3) {
    let s2, n2, r = null, a2 = null, o = null;
    for (const l2 of e) {
      const e2 = l2.geometry;
      if (null != e2 && (r || (r = p(e2)), a2 || (a2 = e2.spatialReference), null == s2 && (s2 = O(e2)), null == n2 && (n2 = w(e2)), r && a2 && null != s2 && null != n2)) break;
    }
    if (i3 && i3.length) {
      let e2 = null;
      i3.some((t2) => {
        const i4 = "esriFieldTypeOID" === t2.type, s3 = !t2.type && t2.name && "objectid" === t2.name.toLowerCase();
        return e2 = t2, i4 || s3;
      }) && (o = e2.name);
    }
    return { geometryType: r, spatialReference: a2, objectIdField: o, hasM: n2, hasZ: s2 };
  }
  async _loadInitialFeatures(e, i3) {
    const { geometryType: s2, hasM: r, hasZ: a2, objectIdField: o, spatialReference: l2, featureStore: u3, fieldsIndex: d2 } = this._queryEngine, f2 = [];
    for (const n2 of i3) {
      if (null != n2.uid && (e.assignedObjectIds[n2.uid] = -1), n2.geometry && s2 !== p(n2.geometry)) {
        e.featureErrors.push(f("Incorrect geometry type."));
        continue;
      }
      const i4 = this._createDefaultAttributes(), r2 = p2(d2, i4, n2.attributes, true);
      r2 ? e.featureErrors.push(r2) : (this._assignObjectId(i4, n2.attributes, true), n2.attributes = i4, null != n2.uid && (e.assignedObjectIds[n2.uid] = n2.attributes[o]), null != n2.geometry && (n2.geometry = j(n2.geometry, n2.geometry.spatialReference, l2)), f2.push(n2));
    }
    u3.addMany(et([], f2, s2, a2, r, o));
    const { fullExtent: c, timeExtent: m2 } = await this._queryEngine.fetchRecomputedExtents();
    if (e.layerDefinition.extent = c, m2) {
      const { start: t2, end: i4 } = m2;
      e.layerDefinition.timeInfo.timeExtent = [t2, i4];
    }
    return e;
  }
  async _applyEdits(e) {
    const { adds: t2, updates: i3, deletes: s2 } = e, n2 = { addResults: [], deleteResults: [], updateResults: [], uidToObjectId: {} };
    if ((t2 == null ? void 0 : t2.length) && this._applyAddEdits(n2, t2), (i3 == null ? void 0 : i3.length) && this._applyUpdateEdits(n2, i3), s2 == null ? void 0 : s2.length) {
      for (const e2 of s2) n2.deleteResults.push(d(e2));
      this._queryEngine.featureStore.removeManyById(s2);
    }
    const { fullExtent: r, timeExtent: a2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: r, timeExtent: a2, featureEditResults: n2 };
  }
  _applyAddEdits(e, i3) {
    const { addResults: s2 } = e, { geometryType: r, hasM: a2, hasZ: o, objectIdField: l2, spatialReference: u3, featureStore: d2, fieldsIndex: f2 } = this._queryEngine, c = [];
    for (const n2 of i3) {
      if (n2.geometry && r !== p(n2.geometry)) {
        s2.push(f("Incorrect geometry type."));
        continue;
      }
      const i4 = this._createDefaultAttributes(), a3 = p2(f2, i4, n2.attributes);
      if (a3) s2.push(a3);
      else {
        if (this._assignObjectId(i4, n2.attributes), n2.attributes = i4, null != n2.uid) {
          const t2 = n2.attributes[l2];
          e.uidToObjectId[n2.uid] = t2;
        }
        if (null != n2.geometry) {
          const e2 = n2.geometry.spatialReference ?? u3;
          n2.geometry = j(y(n2.geometry, e2), e2, u3);
        }
        c.push(n2), s2.push(d(n2.attributes[l2]));
      }
    }
    d2.addMany(et([], c, r, o, a2, l2));
  }
  _applyUpdateEdits({ updateResults: e }, i3) {
    const { geometryType: s2, hasM: n2, hasZ: o, objectIdField: l2, spatialReference: u3, featureStore: d2, fieldsIndex: f2 } = this._queryEngine;
    for (const c of i3) {
      const { attributes: i4, geometry: m2 } = c, y2 = i4 == null ? void 0 : i4[l2];
      if (null == y2) {
        e.push(f(`Identifier field ${l2} missing`));
        continue;
      }
      if (!d2.has(y2)) {
        e.push(f(`Feature with object id ${y2} missing`));
        continue;
      }
      const h = nt(d2.getFeature(y2), s2, o, n2);
      if (null != m2) {
        if (s2 !== p(m2)) {
          e.push(f("Incorrect geometry type."));
          continue;
        }
        const i5 = m2.spatialReference ?? u3;
        h.geometry = j(y(m2, i5), i5, u3);
      }
      if (i4) {
        const t2 = p2(f2, h.attributes, i4);
        if (t2) {
          e.push(t2);
          continue;
        }
      }
      d2.add(tt(h, s2, o, n2, l2)), e.push(d(y2));
    }
  }
  _assignObjectId(e, t2, i3 = false) {
    const s2 = this._queryEngine.objectIdField;
    i3 && t2 && isFinite(t2[s2]) ? e[s2] = t2[s2] : e[s2] = this._nextObjectId++;
  }
};
export {
  S as default
};
//# sourceMappingURL=MemorySourceWorker-UV6TGMRM.js.map
