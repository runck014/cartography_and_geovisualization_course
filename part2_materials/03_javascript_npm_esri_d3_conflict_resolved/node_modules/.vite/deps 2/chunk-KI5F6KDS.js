// node_modules/@arcgis/core/layers/graphics/OptimizedGeometry.js
var t = 2;
var s = class _s {
  constructor(t2 = [], s2 = []) {
    this.lengths = t2 ?? [], this.coords = s2 ?? [];
  }
  static fromJSON(t2) {
    return new _s(t2.lengths, t2.coords);
  }
  static fromRect(t2) {
    const [e, r, h, o] = t2, n = h - e, l = o - r;
    return new _s([5], [e, r, n, 0, 0, l, -n, 0, 0, -l]);
  }
  get isPoint() {
    return 0 === this.lengths.length && this.coords.length >= 2;
  }
  get maxLength() {
    return Math.max(...this.lengths);
  }
  get size() {
    return this.lengths.reduce((t2, s2) => t2 + s2);
  }
  forEachVertex(s2) {
    let e = 0;
    this.lengths.length || s2(this.coords[0], this.coords[1]);
    for (let r = 0; r < this.lengths.length; r++) {
      const h = this.lengths[r];
      for (let r2 = 0; r2 < h; r2++) {
        s2(this.coords[t * (r2 + e)], this.coords[t * (r2 + e) + 1]);
      }
      e += h;
    }
  }
  deltaDecode() {
    const t2 = this.clone(), { coords: s2, lengths: e } = t2;
    let r = 0;
    for (const h of e) {
      for (let t3 = 1; t3 < h; t3++) s2[2 * (r + t3)] += s2[2 * (r + t3) - 2], s2[2 * (r + t3) + 1] += s2[2 * (r + t3) - 1];
      r += h;
    }
    return t2;
  }
  clone(e) {
    if (0 === this.lengths.length) return new _s([], [this.coords[0], this.coords[1]]);
    const r = (0 === this.lengths.length ? 1 : this.lengths.reduce((t2, s2) => t2 + s2)) * t, h = this.coords.slice(0, r);
    return e ? (e.set(h), new _s(this.lengths, e)) : new _s(Array.from(this.lengths), Array.from(h));
  }
};

export {
  s
};
//# sourceMappingURL=chunk-KI5F6KDS.js.map
