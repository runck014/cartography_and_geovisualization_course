import {
  e as e5
} from "./chunk-BXIXSFGX.js";
import {
  e as e6
} from "./chunk-K6ALWBKT.js";
import {
  M,
  O as O2,
  v as v3
} from "./chunk-I2OLSNCI.js";
import {
  h as h2,
  m as m4,
  o as o2
} from "./chunk-POHVYJFI.js";
import {
  N as N2,
  d as d2,
  j as j2,
  k,
  w as w2,
  z as z3
} from "./chunk-G5RWJWRO.js";
import {
  f as f3
} from "./chunk-UHMJZXQV.js";
import {
  t as t3
} from "./chunk-2KYWMOKS.js";
import {
  p as p2
} from "./chunk-FWIRGELF.js";
import {
  B,
  E as E2,
  F,
  G as G2,
  O as O3,
  R,
  g as g4,
  h as h3,
  k as k2,
  nt,
  w as w3
} from "./chunk-RMNZGRHI.js";
import {
  e as e7,
  i
} from "./chunk-QYBCLVRN.js";
import {
  c as c5
} from "./chunk-U7ZFK3X2.js";
import {
  a as a8
} from "./chunk-VMQKPMJK.js";
import {
  C
} from "./chunk-A7PB2PTS.js";
import {
  a as a7,
  g as g3,
  s as s5,
  u as u4
} from "./chunk-7QP2TGTK.js";
import {
  a as a5,
  a2 as a6
} from "./chunk-D67YPTQ2.js";
import {
  b
} from "./chunk-LTCEJX6G.js";
import {
  e as e4,
  r as r3
} from "./chunk-L6HI4BLZ.js";
import {
  e as e2
} from "./chunk-5FROWG6B.js";
import {
  e as e3
} from "./chunk-NW7VXBHZ.js";
import {
  n as n7
} from "./chunk-D6FJTDNK.js";
import {
  A,
  E,
  N,
  c as c4,
  g as g2,
  o,
  u as u3,
  z as z2
} from "./chunk-RENLZYKC.js";
import {
  L,
  a as a4,
  c as c2,
  e,
  f,
  m as m2,
  t as t2,
  u as u2
} from "./chunk-IOKAACTA.js";
import {
  l
} from "./chunk-M5RSIRGD.js";
import {
  D,
  I,
  O,
  c as c3,
  f as f2,
  p
} from "./chunk-GNWAZIVF.js";
import {
  J
} from "./chunk-H4N5QOMX.js";
import {
  _,
  n as n5,
  r as r2,
  s as s4
} from "./chunk-6Y2LNRVP.js";
import {
  v2
} from "./chunk-VNRDIGVF.js";
import {
  a as a3
} from "./chunk-QRJFHPMB.js";
import {
  n as n4
} from "./chunk-G6REFQRQ.js";
import {
  d,
  v
} from "./chunk-TKY5RBM3.js";
import {
  V
} from "./chunk-SIQNRYEG.js";
import {
  m as m3
} from "./chunk-CY5MS6DC.js";
import {
  n as n2
} from "./chunk-Q4Q32WYV.js";
import {
  j2 as j,
  n as n3,
  w
} from "./chunk-A3J7W53Y.js";
import {
  n as n6
} from "./chunk-Y6AYXNMP.js";
import {
  s as s3
} from "./chunk-6YWQXXBX.js";
import {
  W2 as W,
  z
} from "./chunk-DRBJFCLQ.js";
import {
  G,
  Rt
} from "./chunk-QS62R4CH.js";
import {
  a as a2,
  m,
  t
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  c2 as c,
  g,
  h,
  s as s2,
  u
} from "./chunk-GRW2QIBT.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/geometry/support/meshErrors.js
var t4 = "Mesh must be loaded before applying operations";
var e8 = "Provided component is not part of the list of components";
var n8 = "Expected polygon to be a Polygon instance";
var s6 = "Expected location to be a Point instance";
var i2 = class extends s {
  constructor() {
    super("invalid-input:location", s6);
  }
};

// node_modules/@arcgis/core/geometry/support/polygonUtils.js
function c6(t6, o3, s7) {
  const a11 = e9(f4, t6, o3, s7) ? O2(f4) : [0, 0, 1];
  return Math.abs(a11[2]) > Math.cos(s3(80)) ? n4.Z : Math.abs(a11[1]) > Math.abs(a11[0]) ? n4.Y : n4.X;
}
function e9(r4, i3, a11, n9) {
  const c9 = ((r5) => !Array.isArray(r5[0]))(i3) ? (r5, t6) => i3[3 * r5 + t6] : (r5, t6) => i3[r5][t6], e10 = n9 ? z(n9) / W(n9) : 1;
  return v3(r4, (r5, t6) => o(r5, c9(t6, 0) * e10, c9(t6, 1) * e10, c9(t6, 2)), a11);
}
var f4 = M();

// node_modules/@arcgis/core/geometry/support/triangulationUtils.js
function f5(t6) {
  const e10 = a9(t6.rings, t6.hasZ, p3.CCW_IS_HOLE, t6.spatialReference), s7 = new Array();
  let l3 = 0, f8 = 0;
  for (const r4 of e10.polygons) {
    const t7 = r4.count, c9 = r4.index, h8 = a4(e10.position, 3 * c9, 3 * t7), a11 = r4.holeIndices.map((n9) => n9 - c9), g10 = t3(e5(h8, a11, 3));
    s7.push({ position: h8, faces: g10 }), l3 += h8.length, f8 += g10.length;
  }
  const g9 = h4(s7, l3, f8), u10 = Array.isArray(g9.position) ? e6(g9.position, 3, { originalIndices: g9.faces }) : e6(g9.position.buffer, 6, { originalIndices: g9.faces });
  return g9.position = e(new Float64Array(u10.buffer)), g9.faces = u10.indices, g9;
}
function h4(n9, t6, e10) {
  if (1 === n9.length) return n9[0];
  const o3 = t2(t6), r4 = new Array(e10);
  let l3 = 0, c9 = 0, f8 = 0;
  for (const s7 of n9) {
    for (let n10 = 0; n10 < s7.position.length; n10++) o3[l3++] = s7.position[n10];
    for (const n10 of s7.faces) r4[c9++] = n10 + f8;
    f8 = l3 / 3;
  }
  return { position: o3, faces: t3(r4) };
}
function a9(n9, t6, e10, o3) {
  const r4 = n9.length, i3 = new Array(r4), l3 = new Array(r4), c9 = new Array(r4);
  let f8 = 0;
  for (let s7 = 0; s7 < r4; ++s7) f8 += n9[s7].length;
  let h8 = 0, a11 = 0, m7 = 0;
  const d5 = t2(3 * f8);
  let y3 = 0;
  for (let s7 = r4 - 1; s7 >= 0; s7--) {
    const f9 = n9[s7], A4 = e10 === p3.CCW_IS_HOLE && u5(f9, t6, o3);
    if (A4 && 1 !== r4) i3[h8++] = f9;
    else {
      let n10 = f9.length;
      for (let t7 = 0; t7 < h8; ++t7) n10 += i3[t7].length;
      const e11 = { index: y3, pathLengths: new Array(h8 + 1), count: n10, holeIndices: new Array(h8) };
      e11.pathLengths[0] = f9.length, f9.length > 0 && (c9[m7++] = { index: y3, count: f9.length }), y3 = A4 ? g5(f9, f9.length - 1, -1, d5, y3, f9.length, t6) : g5(f9, 0, 1, d5, y3, f9.length, t6);
      for (let o4 = 0; o4 < h8; ++o4) {
        const n11 = i3[o4];
        e11.holeIndices[o4] = y3, e11.pathLengths[o4 + 1] = n11.length, n11.length > 0 && (c9[m7++] = { index: y3, count: n11.length }), y3 = g5(n11, 0, 1, d5, y3, n11.length, t6);
      }
      h8 = 0, e11.count > 0 && (l3[a11++] = e11);
    }
  }
  for (let s7 = 0; s7 < h8; ++s7) {
    const n10 = i3[s7];
    n10.length > 0 && (c9[m7++] = { index: y3, count: n10.length }), y3 = g5(n10, 0, 1, d5, y3, n10.length, t6);
  }
  return l3.length = a11, c9.length = m7, { position: d5, polygons: l3, outlines: c9 };
}
function g5(n9, t6, e10, o3, r4, s7, i3) {
  r4 *= 3;
  for (let l3 = 0; l3 < s7; ++l3) {
    const s8 = n9[t6];
    o3[r4++] = s8[0], o3[r4++] = s8[1], o3[r4++] = i3 && s8[2] ? s8[2] : 0, t6 += e10;
  }
  return r4 / 3;
}
function u5(n9, o3, r4) {
  if (!o3) return !a3(n9);
  const s7 = n9.length - 1;
  switch (c6(n9, s7, r4)) {
    case n4.X:
      return !a3(n9, n4.Y, n4.Z);
    case n4.Y:
      return !a3(n9, n4.X, n4.Z);
    case n4.Z:
      return !a3(n9, n4.X, n4.Y);
  }
}
var p3;
!function(n9) {
  n9[n9.NONE = 0] = "NONE", n9[n9.CCW_IS_HOLE = 1] = "CCW_IS_HOLE";
}(p3 || (p3 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/geographicUtils.js
function t5(o3, t6, i3, a11) {
  if (void 0 !== a11) {
    a2(o3(), "option: geographic", { replacement: "Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.", version: "4.30", warnOnce: true });
    const c9 = "local" === t6.type;
    if (!a7(t6) || a11 === c9) return i3.isGeographic || i3.isWebMercator && a11;
    o3().warnOnce(`Specifying the 'geographic' parameter (${a11}) for a Mesh vertex space of type "${t6.type}" is not supported. This parameter will be ignored.`);
  }
  switch (t6.type) {
    case "georeferenced":
      return i3.isGeographic;
    case "local":
      return i3.isGeographic || i3.isWebMercator;
  }
}

// node_modules/@arcgis/core/geometry/support/meshUtils/centerAt.js
var g6 = () => n.getLogger("esri.geometry.support.meshUtils.centerAt");
function u6(e10, t6, r4) {
  var _a;
  if (!((_a = e10.vertexAttributes) == null ? void 0 : _a.position)) return;
  const { vertexSpace: i3 } = e10, o3 = (r4 == null ? void 0 : r4.origin) ?? e10.origin, n9 = t5(g6, i3, o3.spatialReference, r4 == null ? void 0 : r4.geographic);
  a7(i3) ? x(e10, t6, o3) : n9 ? v4(e10, t6, o3) : R2(e10, t6, o3);
}
function x(e10, o3, s7) {
  const { vertexSpace: c9 } = e10;
  if (!a7(c9)) return;
  const f8 = h5, m7 = b2;
  if (!c5(o3, m7, e10.spatialReference)) return void F(g6(), o3.spatialReference, e10.spatialReference, O3);
  if (!c5(s7, f8, e10.spatialReference)) {
    const t6 = e10.origin;
    return f8[0] = t6.x, f8[1] = t6.y, f8[2] = t6.z, void F(g6(), s7.spatialReference, e10.spatialReference, O3);
  }
  const u10 = c4(A2, m7, f8);
  c9.origin = u3(n5(), c9.origin, u10);
}
function v4(e10, t6, r4) {
  const i3 = r2(r4.x, r4.y, r4.z ?? 0), n9 = B(e10, new a6({ origin: i3 }));
  if (!n9) return;
  const a11 = r2(t6.x, t6.y, t6.z ?? 0), f8 = B({ vertexAttributes: n9, spatialReference: e10.spatialReference, vertexSpace: new a6({ origin: a11 }) }, a5.absolute);
  if (!f8) return;
  const { position: p6, normal: l3, tangent: g9 } = f8;
  e10.vertexAttributes.position = p6, e10.vertexAttributes.normal = l3, e10.vertexAttributes.tangent = g9, e10.vertexAttributesChanged();
}
function R2(e10, t6, r4) {
  const i3 = h5, o3 = b2;
  if (c5(t6, o3, e10.spatialReference)) {
    if (!c5(r4, i3, e10.spatialReference)) {
      const t7 = e10.origin;
      return i3[0] = t7.x, i3[1] = t7.y, i3[2] = t7.z, void F(g6(), r4.spatialReference, e10.spatialReference, O3);
    }
    j3(e10.vertexAttributes.position, o3, i3), e10.vertexAttributesChanged();
  } else F(g6(), t6.spatialReference, e10.spatialReference, O3);
}
function j3(e10, t6, r4) {
  if (e10) for (let i3 = 0; i3 < e10.length; i3 += 3) for (let o3 = 0; o3 < 3; o3++) e10[i3 + o3] += t6[o3] - r4[o3];
}
var b2 = n5();
var h5 = n5();
var A2 = n5();

// node_modules/@arcgis/core/geometry/support/meshUtils/extent.js
function l2(r4) {
  const { spatialReference: f8, vertexSpace: l3, untransformedBounds: d5 } = r4, g9 = f(d5, u7);
  if (a7(l3) && r4.transform && e7(g9, g9, r4.transform.localMatrix), "georeferenced" === l3.type) {
    const r5 = l3.origin;
    return r5 && i(g9, g9, r5), c2(m2(g9), f8);
  }
  const y3 = a8(f8), B3 = l3.origin;
  if (!J(y3, f8)) {
    const [r5, t6, e10] = B3;
    return new w({ xmin: r5, ymin: t6, zmin: e10, xmax: r5, ymax: t6, zmax: e10, spatialReference: f8 });
  }
  return C(f8, B3, x2, y3), e7(g9, g9, x2), n6(g9, y3, 0, g9, f8, 0), c2(m2(g9), f8);
}
var x2 = e2();
var u7 = t2(24);

// node_modules/@arcgis/core/geometry/support/meshUtils/loadExternal.js
async function c7(e10, n9, r4) {
  const { source: o3 } = n9, { loadGLTFMesh: i3 } = await h(import("./loadGLTFMesh-5HPNOC4V.js"), r4), l3 = await f6(o3, r4);
  s2(r4);
  const c9 = i3(new j({ x: 0, y: 0, z: 0, spatialReference: e10.spatialReference }), l3.url, { resolveFile: u8(l3), signal: r4 == null ? void 0 : r4.signal, expectedType: l3.type, unitConversionDisabled: n9.unitConversionDisabled });
  c9.then(() => l3.dispose(), () => l3.dispose());
  const { vertexAttributes: m7, components: p6 } = await c9;
  e10.vertexAttributes = m7, e10.components = p6;
}
function u8(e10) {
  const t6 = Rt(e10.url);
  return (s7) => {
    const n9 = G(s7, t6, t6), r4 = n9 ? n9.replace(/^ *\.\//, "") : null;
    return (r4 ? e10.files.get(r4) : null) ?? s7;
  };
}
async function f6(t6, s7) {
  if (Array.isArray(t6)) {
    if (!t6.length) throw new s("mesh-load-external:missing-assets", "There must be at least one file to load");
    return t6[0] instanceof File ? y(t6) : h6(t6, s7);
  }
  return p4(t6);
}
async function m5(e10, t6) {
  const { parts: n9, assetMimeType: r4, assetName: o3 } = e10;
  if (1 === n9.length) return new v5(n9[0].partUrl);
  const i3 = await e10.toBlob(t6);
  return s2(t6), v5.fromBlob(i3, x3(o3, r4));
}
function p4(e10) {
  return v5.fromBlob(e10, x3(e10.name, e10.type));
}
function y(e10) {
  return j4(e10.map((e11) => ({ name: e11.name, mimeType: e11.type, source: p4(e11) })));
}
async function h6(e10, t6) {
  const i3 = await g(e10.map(async (e11) => {
    const n9 = await m5(e11);
    return s2(t6), { name: e11.assetName, mimeType: e11.assetMimeType, source: n9 };
  }));
  if (c(t6)) throw i3.forEach((e11) => e11.source.dispose()), u();
  return j4(i3);
}
var d3 = /^model\/gltf\+json$/;
var g7 = /^model\/gltf-binary$/;
var w4 = /\.gltf$/i;
var b3 = /\.glb$/i;
function T({ mimeType: e10, source: t6, name: s7 }) {
  return d3.test(e10) || w4.test(s7) ? { url: t6.url, type: "gltf" } : g7.test(e10) || b3.test(s7) ? { url: t6.url, type: "glb" } : null;
}
function j4(t6) {
  const s7 = /* @__PURE__ */ new Map();
  let n9 = null, r4 = null;
  for (const e10 of t6) {
    const { source: t7, name: o4 } = e10;
    n9 ?? (n9 = T(e10)), "ESRI3DO_NORM.glb" === o4 && (r4 = T(e10)), s7.set(o4, t7.url), t7.files.forEach((e11, t8) => s7.set(t8, e11));
  }
  const o3 = r4 ?? n9;
  if (null == o3) throw new s("mesh-load-external:missing-files", "Missing files to load external mesh source");
  return new v5(o3.url, () => t6.forEach(({ source: e10 }) => e10.dispose()), s7, o3.type);
}
var v5 = class _v {
  constructor(e10, t6 = () => {
  }, s7 = /* @__PURE__ */ new Map(), n9) {
    this.url = e10, this.dispose = t6, this.files = s7, this.type = n9;
  }
  static fromBlob(e10, t6) {
    const s7 = URL.createObjectURL(e10);
    return new _v(s7, () => URL.revokeObjectURL(s7), void 0, t6);
  }
};
function x3(e10, t6) {
  return d3.test(t6) || w4.test(e10) ? "gltf" : g7.test(t6) || w4.test(e10) ? "glb" : void 0;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/Metadata.js
var a10 = class extends l {
  constructor(e10) {
    super(e10), this.externalSources = new V(), this._explicitDisplaySource = null, this.georeferenced = false, this.addHandles(v(() => this.externalSources, "after-remove", ({ item: e11 }) => {
      e11 === this._explicitDisplaySource && (this._explicitDisplaySource = null);
    }, { sync: true, onListenerRemove: () => this._explicitDisplaySource = null }));
  }
  get displaySource() {
    return this._explicitDisplaySource ?? this._implicitDisplaySource;
  }
  set displaySource(e10) {
    if (null != e10 && !o2(e10)) throw new Error("Cannot use this source for display: it is not in a supported format.");
    this._explicitDisplaySource = e10, e10 && this.externalSources.every((r4) => !h2(r4, e10)) && this.externalSources.add(e10);
  }
  clearSources() {
    this.externalSources.removeAll();
  }
  getExternalSourcesOnService(e10) {
    return this.externalSources.items.filter((r4) => m4(r4, e10));
  }
  get _implicitDisplaySource() {
    return this.externalSources.find(o2);
  }
};
r([m()], a10.prototype, "externalSources", void 0), r([m()], a10.prototype, "displaySource", null), r([m()], a10.prototype, "_implicitDisplaySource", null), r([m()], a10.prototype, "_explicitDisplaySource", void 0), r([m()], a10.prototype, "georeferenced", void 0), a10 = r([a("esri.geometry.support.meshUtils.Metadata")], a10);

// node_modules/@arcgis/core/geometry/support/meshUtils/primitives.js
function c8() {
  const { faceDescriptions: t6, faceVertexOffsets: e10, uvScales: r4 } = F2, n9 = 4 * t6.length, o3 = new Float64Array(3 * n9), s7 = new Float32Array(3 * n9), a11 = new Float32Array(2 * n9), i3 = new Uint32Array(2 * t6.length * 3);
  let l3 = 0, c9 = 0, f8 = 0, u10 = 0;
  for (let h8 = 0; h8 < t6.length; h8++) {
    const n10 = t6[h8], p6 = l3 / 3;
    for (const t7 of e10) i3[u10++] = p6 + t7;
    const m7 = n10.corners;
    for (let t7 = 0; t7 < 4; t7++) {
      const e11 = m7[t7];
      let i4 = 0;
      a11[f8++] = 0.25 * r4[t7][0] + n10.uvOrigin[0], a11[f8++] = n10.uvOrigin[1] - 0.25 * r4[t7][1];
      for (let t8 = 0; t8 < 3; t8++) 0 !== n10.axis[t8] ? (o3[l3++] = 0.5 * n10.axis[t8], s7[c9++] = n10.axis[t8]) : (o3[l3++] = 0.5 * e11[i4++], s7[c9++] = 0);
    }
  }
  return { position: o3, normal: s7, uv: a11, faces: i3 };
}
function f7(t6, e10) {
  const r4 = t6.components[0], n9 = r4.faces, s7 = b4[e10], a11 = 6 * s7, i3 = new Array(6), l3 = new Array(n9.length - 6);
  let c9 = 0, f8 = 0;
  for (let o3 = 0; o3 < n9.length; o3++) o3 >= a11 && o3 < a11 + 6 ? i3[c9++] = n9[o3] : l3[f8++] = n9[o3];
  if (null != t6.vertexAttributes.uv) {
    const e11 = new Float32Array(t6.vertexAttributes.uv), r5 = 4 * s7 * 2, n10 = [0, 1, 1, 1, 1, 0, 0, 0];
    for (let t7 = 0; t7 < n10.length; t7++) e11[r5 + t7] = n10[t7];
    t6.vertexAttributes.uv = e11;
  }
  return t6.components = [new f3({ faces: i3, material: r4.material }), new f3({ faces: l3 })], t6;
}
function u9(t6 = 0) {
  const e10 = Math.round(8 * 2 ** t6), r4 = 2 * e10, n9 = (e10 - 1) * (r4 + 1) + 2 * r4, o3 = new Float64Array(3 * n9), s7 = new Float32Array(3 * n9), a11 = new Float32Array(2 * n9), i3 = new Uint32Array(3 * ((e10 - 1) * r4 * 2));
  let l3 = 0, c9 = 0, f8 = 0, u10 = 0;
  for (let h8 = 0; h8 <= e10; h8++) {
    const t7 = h8 / e10 * Math.PI + 0.5 * Math.PI, n10 = Math.cos(t7), p6 = Math.sin(t7);
    O4[2] = p6;
    const m7 = 0 === h8 || h8 === e10, w6 = m7 ? r4 - 1 : r4;
    for (let v7 = 0; v7 <= w6; v7++) {
      const t8 = v7 / w6 * 2 * Math.PI;
      O4[0] = -Math.sin(t8) * n10, O4[1] = Math.cos(t8) * n10;
      for (let e11 = 0; e11 < 3; e11++) o3[l3] = 0.5 * O4[e11], s7[l3] = O4[e11], ++l3;
      a11[c9++] = (v7 + (m7 ? 0.5 : 0)) / r4, a11[c9++] = h8 / e10, 0 !== h8 && v7 !== r4 && (h8 !== e10 && (i3[f8++] = u10, i3[f8++] = u10 + 1, i3[f8++] = u10 - r4), 1 !== h8 && (i3[f8++] = u10, i3[f8++] = u10 - r4, i3[f8++] = u10 - r4 - 1)), u10++;
    }
  }
  return { position: o3, normal: s7, uv: a11, faces: i3 };
}
function h7(t6 = 0) {
  const e10 = 5, r4 = Math.round(16 * 2 ** t6), n9 = (e10 - 1) * (r4 + 1) + 2 * r4, o3 = new Float64Array(3 * n9), s7 = new Float32Array(3 * n9), a11 = new Float32Array(2 * n9), i3 = new Uint32Array(3 * (4 * r4));
  let l3 = 0, c9 = 0, f8 = 0, u10 = 0, h8 = 0;
  for (let p6 = 0; p6 <= e10; p6++) {
    const t7 = 0 === p6 || p6 === e10, n10 = p6 <= 1 || p6 >= e10 - 1, m7 = 2 === p6 || 4 === p6, w6 = t7 ? r4 - 1 : r4;
    for (let v7 = 0; v7 <= w6; v7++) {
      const g9 = v7 / w6 * 2 * Math.PI, A4 = t7 ? 0 : 0.5;
      O4[0] = A4 * Math.sin(g9), O4[1] = A4 * -Math.cos(g9), O4[2] = p6 <= 2 ? 0.5 : -0.5;
      for (let t8 = 0; t8 < 3; t8++) o3[l3++] = O4[t8], s7[c9++] = n10 ? 2 === t8 ? p6 <= 1 ? 1 : -1 : 0 : 2 === t8 ? 0 : O4[t8] / A4;
      a11[f8++] = (v7 + (t7 ? 0.5 : 0)) / r4, a11[f8++] = p6 <= 1 ? 1 * p6 / 3 : p6 <= 3 ? 1 * (p6 - 2) / 3 + 1 / 3 : 1 * (p6 - 4) / 3 + 2 / 3, m7 || 0 === p6 || v7 === r4 || (p6 !== e10 && (i3[u10++] = h8, i3[u10++] = h8 + 1, i3[u10++] = h8 - r4), 1 !== p6 && (i3[u10++] = h8, i3[u10++] = h8 - r4, i3[u10++] = h8 - r4 - 1)), h8++;
    }
  }
  return { position: o3, normal: s7, uv: a11, faces: i3 };
}
function p5(t6, e10) {
  const r4 = "number" == typeof e10 ? e10 : null != e10 ? e10.width : 1, n9 = "number" == typeof e10 ? e10 : null != e10 ? e10.height : 1;
  switch (t6) {
    case "up":
    case "down":
      return { width: r4, depth: n9 };
    case "north":
    case "south":
      return { width: r4, height: n9 };
    case "east":
    case "west":
      return { depth: r4, height: n9 };
  }
}
function m6(t6) {
  const e10 = A3.facingAxisOrderSwap[t6], r4 = A3.position, n9 = A3.normal, o3 = new Float64Array(r4.length), s7 = new Float32Array(n9.length);
  let a11 = 0;
  for (let i3 = 0; i3 < 4; i3++) {
    const t7 = a11;
    for (let i4 = 0; i4 < 3; i4++) {
      const l3 = e10[i4], c9 = Math.abs(l3) - 1, f8 = l3 >= 0 ? 1 : -1;
      o3[a11] = r4[t7 + c9] * f8, s7[a11] = n9[t7 + c9] * f8, a11++;
    }
  }
  return { position: o3, normal: s7, uv: new Float32Array(A3.uv), faces: new Uint32Array(A3.faces), isPlane: true };
}
var w5 = 1;
var v6 = 2;
var g8 = 3;
var A3 = { position: [-0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0, -0.5, 0.5, 0], normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], uv: [0, 1, 1, 1, 1, 0, 0, 0], faces: [0, 1, 2, 0, 2, 3], facingAxisOrderSwap: { east: [g8, w5, v6], west: [-g8, -w5, v6], north: [-w5, g8, v6], south: [w5, -g8, v6], up: [w5, v6, g8], down: [w5, -v6, -g8] } };
function x4(t6, e10, r4) {
  t6.isPlane || y2(t6), M2(t6, d4(r4 == null ? void 0 : r4.size, r4 == null ? void 0 : r4.unit, e10.spatialReference));
  const n9 = s5(e10, r4), l3 = e10.spatialReference.isGeographic ? s5(e10) : n9, c9 = B({ vertexAttributes: t6, vertexSpace: l3, spatialReference: e10.spatialReference }, n9, { allowBufferReuse: true });
  return { vertexAttributes: new p2({ ...c9, uv: t6.uv }), vertexSpace: n9, components: [new f3({ faces: t6.faces, material: (r4 == null ? void 0 : r4.material) || null })], spatialReference: e10.spatialReference };
}
function y2(t6) {
  for (let e10 = 0; e10 < t6.position.length; e10 += 3) t6.position[e10 + 2] += 0.5;
}
function d4(t6, e10, r4) {
  const n9 = nt(e10, r4);
  if (null == t6 && 1 === n9) return null;
  if (null == t6) return [n9, n9, n9];
  if ("number" == typeof t6) {
    const e11 = t6 * n9;
    return [e11, e11, e11];
  }
  return [null != t6.width ? t6.width * n9 : n9, null != t6.depth ? t6.depth * n9 : n9, null != t6.height ? t6.height * n9 : n9];
}
function M2(t6, n9) {
  if (null != n9) {
    S[0] = n9[0], S[4] = n9[1], S[8] = n9[2];
    for (let r4 = 0; r4 < t6.position.length; r4 += 3) {
      for (let e10 = 0; e10 < 3; e10++) O4[e10] = t6.position[r4 + e10];
      N(O4, O4, S);
      for (let e10 = 0; e10 < 3; e10++) t6.position[r4 + e10] = O4[e10];
    }
    if (n9[0] !== n9[1] || n9[1] !== n9[2]) {
      S[0] = 1 / n9[0], S[4] = 1 / n9[1], S[8] = 1 / n9[2];
      for (let n10 = 0; n10 < t6.normal.length; n10 += 3) {
        for (let e10 = 0; e10 < 3; e10++) O4[e10] = t6.normal[n10 + e10];
        N(O4, O4, S), A(O4, O4);
        for (let e10 = 0; e10 < 3; e10++) t6.normal[n10 + e10] = O4[e10];
      }
    }
  }
}
var F2 = { faceDescriptions: [{ axis: [0, -1, 0], uvOrigin: [0, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [1, 0, 0], uvOrigin: [0.25, 0.625], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 1, 0], uvOrigin: [0.5, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [-1, 0, 0], uvOrigin: [0.75, 0.625], corners: [[1, -1], [-1, -1], [-1, 1], [1, 1]] }, { axis: [0, 0, 1], uvOrigin: [0, 0.375], corners: [[-1, -1], [1, -1], [1, 1], [-1, 1]] }, { axis: [0, 0, -1], uvOrigin: [0, 0.875], corners: [[-1, 1], [1, 1], [1, -1], [-1, -1]] }], uvScales: [[0, 0], [1, 0], [1, 1], [0, 1]], faceVertexOffsets: [0, 1, 2, 0, 2, 3] };
var b4 = { south: 0, east: 1, north: 2, west: 3, up: 4, down: 5 };
var O4 = n5();
var S = e3();

// node_modules/@arcgis/core/geometry/support/meshUtils/rotate.js
var O5 = () => n.getLogger("esri.geometry.support.meshUtils.rotate");
function B2(t6, e10, r4) {
  var _a;
  if (!((_a = t6.vertexAttributes) == null ? void 0 : _a.position) || 0 === e10[3]) return;
  const { spatialReference: o3, vertexSpace: i3 } = t6, n9 = (r4 == null ? void 0 : r4.origin) ?? t6.origin, s7 = r4 == null ? void 0 : r4.geographic, a11 = t5(O5, i3, o3, s7);
  g3(t6) ? G3(t6, e10, n9) : a11 ? H(t6, e10, n9) : I2(t6, e10, n9);
}
function G3(t6, e10, r4) {
  t6.transform ?? (t6.transform = new N2());
  const { vertexSpace: l3, transform: c9, spatialReference: f8 } = t6, [g9, x5, h8] = l3.origin, R3 = new j({ x: g9, y: x5, z: h8, spatialReference: f8 }), d5 = K;
  if (R3.equals(r4)) o(d5, 0, 0, 0);
  else if (!k2(d5, r4, t6)) return void F(O5(), r4.spatialReference, f8, O3);
  b(Z, w2(e10), z3(e10));
  const y3 = D(N3, Z, _, s4, d5), { localMatrix: T3 } = c9, U = c3(N3, y3, T3);
  c9.scale = O(n5(), U), f2(U, U, z2(K, c9.scale));
  const z5 = c9.rotationAxis;
  c9.rotation = k(U), 0 === c9.rotationAngle && (c9.rotationAxis = z5), c9.translation = I(n5(), U);
}
function H(t6, r4, o3) {
  const i3 = t6.spatialReference, n9 = a8(i3), s7 = Y;
  if (!c5(o3, s7, n9) && (F(O5(), o3.spatialReference, n9, "Falling back to mesh origin"), !c5(t6.origin, s7, n9))) return void F(O5(), t6.origin.spatialReference, n9);
  const a11 = t6.vertexAttributes.position, l3 = t6.vertexAttributes.normal, c9 = t6.vertexAttributes.tangent, m7 = new Float64Array(a11.length), f8 = null != l3 ? new Float32Array(l3.length) : null, p6 = null != c9 ? new Float32Array(c9.length) : null;
  C(n9, s7, W2, n9), n7(X, W2);
  const u10 = Q;
  N(w2(Q), w2(r4), X), u10[3] = r4[3], g4(a11, i3, m7, n9) && (null == l3 || null == f8 || E2(l3, a11, i3, m7, n9, f8)) && (null == c9 || null == p6 || w3(c9, a11, i3, m7, n9, p6)) ? (J2(m7, u10, 3, s7), h3(m7, n9, a11, i3) && (null == l3 || null == f8 || (J2(f8, u10, 3), R(f8, a11, i3, m7, n9, l3))) && (null == c9 || null == p6 || (J2(p6, u10, 4), G2(p6, a11, i3, m7, n9, c9))) ? t6.vertexAttributesChanged() : F(O5(), n9, i3)) : F(O5(), i3, n9);
}
function I2(t6, e10, r4) {
  const o3 = Y;
  if (!c5(r4, o3, t6.spatialReference)) {
    const e11 = t6.origin;
    return o3[0] = e11.x, o3[1] = e11.y, o3[2] = e11.z, void F(O5(), r4.spatialReference, t6.spatialReference, O3);
  }
  J2(t6.vertexAttributes.position, e10, 3, o3), J2(t6.vertexAttributes.normal, e10, 3), J2(t6.vertexAttributes.tangent, e10, 4), t6.vertexAttributesChanged();
}
function J2(t6, e10, r4, o3 = _) {
  if (null != t6) {
    p(W2, z3(e10), w2(e10));
    for (let e11 = 0; e11 < t6.length; e11 += r4) {
      for (let r5 = 0; r5 < 3; r5++) K[r5] = t6[e11 + r5] - o3[r5];
      E(K, K, W2);
      for (let r5 = 0; r5 < 3; r5++) t6[e11 + r5] = K[r5] + o3[r5];
    }
  }
}
var K = n5();
var N3 = e2();
var Q = j2();
var W2 = e2();
var X = e3();
var Y = n5();
var Z = e4();

// node_modules/@arcgis/core/geometry/support/meshUtils/scale.js
var k3 = () => n.getLogger("esri.geometry.support.meshUtils.scale");
function q(e10, t6, r4) {
  var _a;
  if (!((_a = e10.vertexAttributes) == null ? void 0 : _a.position)) return;
  const { vertexSpace: o3, spatialReference: i3 } = e10, n9 = (r4 == null ? void 0 : r4.origin) ?? e10.origin, s7 = r4 == null ? void 0 : r4.geographic, a11 = t5(k3, o3, i3, s7);
  g3(e10) ? z4(e10, t6, n9) : a11 ? L2(e10, t6, n9) : M3(e10, t6, n9);
}
function z4(e10, s7, f8) {
  e10.transform ?? (e10.transform = new N2());
  const { vertexSpace: g9, transform: x5, spatialReference: h8 } = e10, [A4, d5, y3] = g9.origin, w6 = new j({ x: A4, y: d5, z: y3, spatialReference: h8 }), F3 = T2;
  if (w6.equals(f8)) o(F3, 0, 0, 0);
  else if (!k2(F3, f8, e10)) return void F(k3(), f8.spatialReference, h8, O3);
  const S2 = o(V2, s7, s7, s7), U = D(D2, r3, _, S2, F3), { localMatrix: q2 } = x5, z5 = c3(D2, U, q2);
  x5.scale = O(n5(), z5), f2(z5, z5, z2(T2, x5.scale));
  const L3 = x5.rotationAxis;
  x5.rotation = k(z5), 0 === x5.rotationAngle && (x5.rotationAxis = L3), x5.translation = I(n5(), z5);
}
function L2(e10, t6, r4) {
  const o3 = e10.spatialReference, i3 = a8(o3), n9 = E3;
  if (!c5(r4, n9, i3) && (F(k3(), r4.spatialReference, i3, "Falling back to mesh origin"), !c5(e10.origin, n9, i3))) return void F(k3(), e10.origin.spatialReference, i3);
  const s7 = e10.vertexAttributes.position, a11 = e10.vertexAttributes.normal, l3 = e10.vertexAttributes.tangent, c9 = new Float64Array(s7.length), f8 = null != a11 ? new Float32Array(a11.length) : null, m7 = null != l3 ? new Float32Array(l3.length) : null;
  g4(s7, o3, c9, i3) && (null == a11 || null == f8 || E2(a11, s7, o3, c9, i3, f8)) && (null == l3 || null == m7 || w3(l3, s7, o3, c9, i3, m7)) ? (P(c9, t6, n9), h3(c9, i3, s7, o3) && (null == a11 || null == f8 || R(f8, s7, o3, c9, i3, a11)) && (null == l3 || null == m7 || G2(m7, s7, o3, c9, i3, l3)) ? e10.vertexAttributesChanged() : F(k3(), i3, o3)) : F(k3(), o3, i3);
}
function M3(e10, t6, r4) {
  const o3 = E3;
  if (!c5(r4, o3, e10.spatialReference)) {
    const t7 = e10.origin;
    return o3[0] = t7.x, o3[1] = t7.y, o3[2] = t7.z, void F(k3(), r4.spatialReference, e10.spatialReference, O3);
  }
  P(e10.vertexAttributes.position, t6, o3), e10.vertexAttributesChanged();
}
function P(e10, t6, r4 = _) {
  if (e10) for (let o3 = 0; o3 < e10.length; o3 += 3) {
    for (let t7 = 0; t7 < 3; t7++) T2[t7] = e10[o3 + t7] - r4[t7];
    g2(T2, T2, t6);
    for (let t7 = 0; t7 < 3; t7++) e10[o3 + t7] = T2[t7] + r4[t7];
  }
}
var T2 = n5();
var V2 = n5();
var D2 = e2();
var E3 = n5();

// node_modules/@arcgis/core/geometry/Mesh.js
var H2;
var K2 = "esri.geometry.Mesh";
function J3() {
  return n.getLogger(K2);
}
var Q2 = { base: null, key: "type", defaultKeyValue: "georeferenced", typeMap: { georeferenced: a5, local: a6 } };
var X2 = H2 = class extends m3.LoadableMixin(n2(n3)) {
  constructor(e10) {
    super(e10), this.components = null, this.vertexSpace = new a5(), this.transform = null, this.metadata = new a10(), this.hasZ = true, this.hasM = false, this.vertexAttributes = new p2(), this.type = "mesh";
  }
  initialize() {
    (0 === this.metadata.externalSources.length || this.vertexAttributes.position.length) && (this.loadStatus = "loaded"), this.when(() => {
      this.addHandles(d(() => {
        var _a;
        return { vertexAttributes: this.vertexAttributes, components: (_a = this.components) == null ? void 0 : _a.map((e10) => e10.clone()) };
      }, () => this._clearSources(), { once: true, sync: true }));
    });
  }
  get hasExtent() {
    var _a;
    return this.loaded ? this.vertexAttributes.position.length > 0 && (!this.components || this.components.length > 0) : null != ((_a = this.metadata.displaySource) == null ? void 0 : _a.extent);
  }
  get _transformedExtent() {
    const { spatialReference: e10, vertexSpace: t6 } = this, r4 = this;
    return l2({ get transform() {
      return r4.transform;
    }, vertexSpace: t6, spatialReference: e10, untransformedBounds: this._untransformedBounds });
  }
  get _untransformedBounds() {
    const { vertexAttributes: { position: e10 }, components: t6 } = this;
    return 0 === e10.length || 0 === (t6 == null ? void 0 : t6.length) ? u2(L) : m2(e10);
  }
  get origin() {
    const e10 = u4(this.vertexSpace, this.spatialReference);
    if (null != e10) return e10;
    const { center: t6, zmin: r4 } = this._transformedExtent;
    return new j({ x: t6.x, y: t6.y, z: r4, spatialReference: this.spatialReference });
  }
  get extent() {
    var _a, _b;
    return this.loaded || null == ((_b = (_a = this.metadata) == null ? void 0 : _a.displaySource) == null ? void 0 : _b.extent) ? this._transformedExtent : this.metadata.displaySource.extent.clone();
  }
  addComponent(e10) {
    this._checkIfLoaded("addComponent()") && (this.components || (this.components = []), this.components.push(f3.from(e10)), this.notifyChange("components"));
  }
  removeComponent(e10) {
    if (this._checkIfLoaded("removeComponent()")) {
      if (this.components) {
        const t6 = this.components.indexOf(e10);
        if (-1 !== t6) return this.components.splice(t6, 1), void this.notifyChange("components");
      }
      J3().error("removeComponent()", e8);
    }
  }
  rotate(e10, t6, r4, o3) {
    return d2(e10, t6, r4, Y2), B2(this, Y2, o3), this;
  }
  offset(e10, t6, r4) {
    if (!this._checkIfLoaded("offset()")) return this;
    const { vertexSpace: o3, vertexAttributes: s7 } = this, n9 = s7 == null ? void 0 : s7.position;
    if (!n9) return this;
    if (a7(o3)) {
      const [s8, n10, i3] = o3.origin;
      o3.origin = r2(s8 + e10, n10 + t6, i3 + r4);
    } else {
      for (let o4 = 0; o4 < n9.length; o4 += 3) n9[o4] += e10, n9[o4 + 1] += t6, n9[o4 + 2] += r4;
      this.vertexAttributesChanged();
    }
    return this;
  }
  scale(e10, t6) {
    return this._checkIfLoaded("scale()") ? (q(this, e10, t6), this) : this;
  }
  centerAt(e10, t6) {
    return this._checkIfLoaded("centerAt()") ? (u6(this, e10, t6), this) : this;
  }
  load(e10) {
    const { metadata: { displaySource: t6 } } = this;
    return t6 && this.addResolvingPromise(c7(this, t6, e10)), Promise.resolve(this);
  }
  addExternalSources(e10) {
    this.metadata.externalSources.addMany(e10);
  }
  updateDisplaySource(e10) {
    this.metadata.displaySource = e10;
  }
  clone() {
    return this.cloneAndModifyVertexAttributes(this.vertexAttributes.clone(), this.vertexSpace.clone(), { preserveMetadata: true });
  }
  cloneAndModifyVertexAttributes(e10, t6, r4) {
    var _a;
    let o3 = null;
    if (this.components) {
      const e11 = /* @__PURE__ */ new Map(), t7 = /* @__PURE__ */ new Map();
      o3 = this.components.map((r5) => r5.cloneWithDeduplication(e11, t7));
    }
    const s7 = { components: o3, spatialReference: this.spatialReference, vertexAttributes: e10, vertexSpace: t6, transform: ((_a = this.transform) == null ? void 0 : _a.clone()) ?? null, metadata: (r4 == null ? void 0 : r4.preserveMetadata) ? this.metadata.clone() : new a10() };
    return new H2(s7);
  }
  cloneShallow() {
    return new H2({ components: this.components, spatialReference: this.spatialReference, vertexAttributes: this.vertexAttributes, vertexSpace: this.vertexSpace.clone(), transform: this.transform, metadata: this.metadata });
  }
  vertexAttributesChanged() {
    this.notifyChange("vertexAttributes");
  }
  async toBinaryGLTF(e10) {
    const [{ toBinaryGLTF: t6 }] = await Promise.all([import("./gltfexport-NXJ5S463.js"), this.load(e10)]);
    return s2(e10), await t6(this, e10);
  }
  get memoryUsage() {
    let e10 = 0;
    if (e10 += this.vertexAttributes.memoryUsage, null != this.components) for (const t6 of this.components) e10 += t6.memoryUsage;
    return e10;
  }
  _clearSources() {
    this.metadata.clearSources();
  }
  _checkIfLoaded(e10) {
    return !!this.loaded || (J3().error(e10, t4), false);
  }
  static createBox(e10, t6) {
    if (!(e10 instanceof j)) return J3().error(".createBox()", s6), null;
    const r4 = new H2(x4(c8(), e10, t6));
    return (t6 == null ? void 0 : t6.imageFace) && "all" !== t6.imageFace ? f7(r4, t6.imageFace) : r4;
  }
  static createSphere(e10, t6) {
    return e10 instanceof j ? new H2(x4(u9((t6 == null ? void 0 : t6.densificationFactor) || 0), e10, t6)) : (J3().error(".createSphere()", s6), null);
  }
  static createCylinder(e10, t6) {
    return e10 instanceof j ? new H2(x4(h7((t6 == null ? void 0 : t6.densificationFactor) || 0), e10, t6)) : (J3().error(".createCylinder()", s6), null);
  }
  static createPlane(e10, t6) {
    if (!(e10 instanceof j)) return J3().error(".createPlane()", s6), null;
    const r4 = (t6 == null ? void 0 : t6.facing) ?? "up", o3 = p5(r4, t6 == null ? void 0 : t6.size);
    return new H2(x4(m6(r4), e10, { ...t6, size: o3 }));
  }
  static createFromPolygon(e10, t6) {
    if (!(e10 instanceof v2)) return J3().error(".createFromPolygon()", n8), null;
    const r4 = f5(e10);
    return new H2({ vertexAttributes: new p2({ position: r4.position }), components: [new f3({ faces: r4.faces, shading: "flat", material: (t6 == null ? void 0 : t6.material) ?? null })], spatialReference: e10.spatialReference, vertexSpace: new a5() });
  }
  static async createFromGLTF(e10, t6, r4) {
    if (!(e10 instanceof j)) {
      const e11 = new i2();
      throw J3().error(".createfromGLTF()", e11.message), e11;
    }
    const { loadGLTFMesh: o3 } = await h(import("./loadGLTFMesh-5HPNOC4V.js"), r4);
    return new H2(await o3(e10, t6, r4));
  }
  static async createFromFiles(e10, o3, s7) {
    t(J3(), "`Mesh.createFromFiles` is deprecated in favor of 'SceneLayer.convertMesh'", { replacement: "SceneLayer.convertMesh", version: "4.29" });
    const n9 = (e11) => J3().error(".createFromFiles()", e11.message);
    if (!(e10 instanceof j)) {
      const e11 = new i2();
      throw n9(e11), e11;
    }
    if (!(s7 == null ? void 0 : s7.layer)) throw new s("invalid:no-layer", "SceneLayer required for file to mesh conversion.");
    return s7.layer.convertMesh(o3, { location: e10, ...s7 });
  }
  static createWithExternalSource(e10, t6, r4) {
    var _a;
    const o3 = (r4 == null ? void 0 : r4.extent) ?? null, { spatialReference: s7 } = e10, n9 = ((_a = r4 == null ? void 0 : r4.transform) == null ? void 0 : _a.clone()) ?? new N2(), i3 = s5(e10, r4), a11 = r4 == null ? void 0 : r4.unitConversionDisabled, c9 = { source: t6, extent: o3, unitConversionDisabled: a11 }, p6 = new a10();
    return p6.externalSources.push(c9), new H2({ metadata: p6, transform: n9, vertexSpace: i3, spatialReference: s7 });
  }
  static createIncomplete(e10, t6) {
    var _a;
    const { spatialReference: o3 } = e10, s7 = ((_a = t6 == null ? void 0 : t6.transform) == null ? void 0 : _a.clone()) ?? new N2(), n9 = s5(e10, t6), i3 = new H2({ transform: s7, vertexSpace: n9, spatialReference: o3 });
    return i3.addResolvingPromise(Promise.reject(new s("mesh-incomplete", "Mesh resources are not complete"))), i3;
  }
};
r([m({ type: [f3], json: { write: true } })], X2.prototype, "components", void 0), r([m({ nonNullable: true, types: Q2, constructOnly: true, json: { write: true } })], X2.prototype, "vertexSpace", void 0), r([m({ type: N2, json: { write: true } })], X2.prototype, "transform", void 0), r([m({ constructOnly: true })], X2.prototype, "metadata", void 0), r([m()], X2.prototype, "hasExtent", null), r([m()], X2.prototype, "_transformedExtent", null), r([m()], X2.prototype, "_untransformedBounds", null), r([m()], X2.prototype, "origin", null), r([m({ readOnly: true, json: { read: false } })], X2.prototype, "extent", null), r([m({ readOnly: true, json: { read: false, write: true, default: true } })], X2.prototype, "hasZ", void 0), r([m({ readOnly: true, json: { read: false, write: true, default: false } })], X2.prototype, "hasM", void 0), r([m({ type: p2, nonNullable: true, json: { write: true } })], X2.prototype, "vertexAttributes", void 0), X2 = H2 = r([a(K2)], X2);
var Y2 = j2();
var $ = X2;

export {
  $
};
//# sourceMappingURL=chunk-TDSOUSBJ.js.map
