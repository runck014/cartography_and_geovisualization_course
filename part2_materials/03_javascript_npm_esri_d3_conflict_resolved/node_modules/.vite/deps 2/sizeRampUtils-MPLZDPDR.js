import {
  c,
  i,
  l as l2,
  p,
  r as r2,
  u
} from "./chunk-NJHUUWCJ.js";
import "./chunk-KVWJ4FJP.js";
import {
  m,
  y2
} from "./chunk-IZK3LHO7.js";
import {
  I
} from "./chunk-MSYZU3PB.js";
import {
  r
} from "./chunk-J7T52XOR.js";
import "./chunk-3FXXSWHF.js";
import "./chunk-MR727DXB.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-WPERPIJF.js";
import "./chunk-Z2L6EED4.js";
import "./chunk-7Q4JSL7R.js";
import "./chunk-VBJTBJYL.js";
import "./chunk-6GD5IU2W.js";
import "./chunk-XQ3CVA7I.js";
import {
  x
} from "./chunk-LEOFRCUR.js";
import {
  d,
  y
} from "./chunk-CP4GPQHD.js";
import "./chunk-IZSNXKMJ.js";
import "./chunk-IOKAACTA.js";
import {
  l
} from "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-B5NBTUMV.js";
import "./chunk-TCZ4QHYH.js";
import "./chunk-SMFCDOAJ.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-DIKY6MBW.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-GGCWKF4X.js";
import "./chunk-6D5XULXX.js";
import "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-BMGF5ELJ.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  a
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/smartMapping/renderers/support/referenceSizeUtils.js
var o;
function s2(e) {
  switch (e) {
    case "circle":
      return { rings: [[[8.5, 0.2], [7.06, 0.33], [5.66, 0.7], [4.35, 1.31], [3.16, 2.14], [2.14, 3.16], [1.31, 4.35], [0.7, 5.66], [0.33, 7.06], [0.2, 8.5], [0.33, 9.94], [0.7, 11.34], [1.31, 12.65], [2.14, 13.84], [3.16, 14.86], [4.35, 15.69], [5.66, 16.3], [7.06, 16.67], [8.5, 16.8], [9.94, 16.67], [11.34, 16.3], [12.65, 15.69], [13.84, 14.86], [14.86, 13.84], [15.69, 12.65], [16.3, 11.34], [16.67, 9.94], [16.8, 8.5], [16.67, 7.06], [16.3, 5.66], [15.69, 4.35], [14.86, 3.16], [13.84, 2.14], [12.65, 1.31], [11.34, 0.7], [9.94, 0.33], [8.5, 0.2]]] };
    case "square":
      return { rings: [[[0.5, 0.5], [0.5, 16.5], [16.5, 16.5], [16.5, 0.5], [0.5, 0.5]]] };
    case "diamond":
      return { rings: [[[8.5, 0.5], [0.2, 8.5], [8.5, 16.5], [16.5, 8.5], [8.5, 0.5]]] };
    case "hexagon-pointy":
      return { rings: [[[15.86, 12.75], [15.86, 4.25], [8.5, 0], [1.14, 4.25], [1.14, 12.75], [8.5, 17], [15.86, 12.75]]] };
    case "hexagon-flat":
      return { rings: [[[12.75, 15.86], [17, 8.5], [12.75, 1.14], [4.25, 1.14], [0, 8.5], [4.25, 15.86], [12.75, 15.86]]] };
  }
}
function y3(e) {
  var _a;
  return "CIMVectorMarker" === (e == null ? void 0 : e.type) ? (_a = e.markerGraphics) == null ? void 0 : _a[0] : void 0;
}
function p2(e) {
  var _a, _b;
  return "CIMPolygonSymbol" === ((_a = e == null ? void 0 : e.symbol) == null ? void 0 : _a.type) ? (_b = e.symbol.symbolLayers) == null ? void 0 : _b[0] : void 0;
}
function f(e, r3) {
  "CIMVectorMarker" === (e == null ? void 0 : e.type) && null != r3 && (e.size = r3);
}
function v(e, r3) {
  const n = y3(e);
  n && null != r3 && (n.geometry = s2(r3));
}
function S(e, r3) {
  const n = p2(y3(e));
  n && null != r3 && (n.color = r3.toArray());
}
function z(e, r3, n) {
  const t = p2(y3(e));
  t && null != r3 && n && (t.colorLocked = r3);
}
function d3(e, n) {
  var _a;
  const { outerRingSize: t, innerDotSize: i2, type: a3, color: l3, colorLocked: s3, primitiveOverrides: m2 } = n, c2 = "CIMPolygonSymbol" === ((_a = e.data.symbol) == null ? void 0 : _a.type) ? e.data.symbol.symbolLayers : null;
  if (2 === (c2 == null ? void 0 : c2.length)) for (const r3 of c2) {
    const e2 = r3.primitiveName === o.OuterRing;
    f(r3, e2 ? t : i2), v(r3, a3), S(r3, l3), z(r3, s3, e2);
  }
  return null != t && null != i2 && (e.data.primitiveOverrides = null), void 0 !== m2 && (e.data.primitiveOverrides = a(m2)), e;
}
!function(e) {
  e.OuterRing = "reference-size-outer-ring", e.InnerDot = "reference-size-inner-dot";
}(o || (o = {}));

// node_modules/@arcgis/core/widgets/Legend/support/sizeRampUtils.js
var b = 30;
var h = 12;
var d4 = 24;
var w = [255, 255, 255];
var S2 = [200, 200, 200];
var g = [128, 128, 128];
var v2 = 20;
var z2 = 5;
function j(e) {
  return "esri.symbols.SimpleMarkerSymbol" === e.declaredClass;
}
function k(e) {
  return "esri.symbols.PictureMarkerSymbol" === e.declaredClass;
}
function V(e) {
  return "esri.symbols.SimpleLineSymbol" === e.declaredClass;
}
function x2(e) {
  return "esri.symbols.TextSymbol" === e.declaredClass;
}
function I2(e, l3) {
  const t = e.length - 1;
  return e.map((e2, n) => r2(e2, n, t, l3));
}
async function L(e, l3, n, o2, i2, s3, c2) {
  const m2 = l3.legendOptions, p3 = m2 == null ? void 0 : m2.customValues, f2 = c2 || await D(e, n), y4 = l3.stops, b2 = !!f2, h2 = !!p3, w2 = null != l3.minSize && null != l3.maxSize, S3 = y4 && y4.length > 1, g2 = !!l3.target;
  if (!b2 || !h2 && !(w2 || S3 && !g2)) return;
  const v3 = y2(f2);
  let z3 = false, j2 = null, k2 = null;
  j2 = v3 && !S3 ? u([l3.minDataValue, l3.maxDataValue]) : p3 ?? await T(l3, f2, o2, i2 == null ? void 0 : i2.type);
  const V2 = e == null ? void 0 : e.authoringInfo, x3 = "univariate-color-size" === (V2 == null ? void 0 : V2.type), L2 = x3 && "above-and-below" === (V2 == null ? void 0 : V2.univariateTheme), q2 = !!c(e);
  if (!j2 && S3 && (j2 = y4.map((e2) => e2.value), z3 = y4.some((e2) => !!e2.label), "flow" === e.type && (j2 = u(j2)), z3 && (k2 = y4.map((e2) => e2.label))), v3 && null != j2 && (j2 == null ? void 0 : j2.length) > 2 && !L2 && (j2 = [j2[0], j2[j2.length - 1]]), !j2) return null;
  x3 && 5 !== (j2 == null ? void 0 : j2.length) && (j2 = P({ minSize: j2[0], maxSize: j2[j2.length - 1] }));
  const B2 = v3 ? U(e, j2) : null, E2 = m(f2), R2 = z3 ? null : I2(j2, s3);
  return (await Promise.all(j2.map(async (t, s4) => {
    const r3 = v3 ? B2[s4] : await H(l3, f2, t, o2, i2 == null ? void 0 : i2.type);
    return { value: t, symbol: !q2 || "class-breaks" !== e.type && "unique-value" !== e.type ? O(L2 && "class-breaks" === e.type ? C(e, s4) : f2, r3) : M(e, r3, l3.maxSize, n) ?? f2, label: z3 ? k2[s4] : R2[s4], size: q2 ? d4 : r3, outlineSize: E2 };
  }))).reverse();
}
function U(e, l3) {
  const t = e == null ? void 0 : e.authoringInfo, n = "univariate-color-size" === (t == null ? void 0 : t.type);
  let o2 = [h, b];
  if (n) {
    const e2 = l3[0], t2 = l3[l3.length - 1], n2 = h, i2 = b;
    o2 = l3.map((l4) => n2 + (l4 - e2) / (t2 - e2) * (i2 - n2));
  }
  return n && "below" === (t == null ? void 0 : t.univariateTheme) && o2.reverse(), o2;
}
function M(l3, t, n, o2) {
  var _a, _b, _c, _d, _e, _f;
  const s3 = "class-breaks" === l3.type, r3 = s3 ? (_c = (_b = (_a = l3.classBreakInfos) == null ? void 0 : _a[0]) == null ? void 0 : _b.symbol) == null ? void 0 : _c.clone() : (_f = (_e = (_d = l3.uniqueValueInfos) == null ? void 0 : _d[0]) == null ? void 0 : _e.symbol) == null ? void 0 : _f.clone();
  return r3 && "type" in r3 && "cim" === r3.type ? (d3(r3, { color: o2 ?? (s3 ? null : new l(S2)), innerDotSize: t * (d4 / n) || 1, outerRingSize: d4 }), r3) : null;
}
function C(e, l3) {
  var _a;
  const t = e.classBreakInfos, n = t.length, o2 = n < 2 || !(l3 >= 2) ? t[0].symbol.clone() : t[n - 1].symbol.clone(), i2 = (_a = e.visualVariables) == null ? void 0 : _a.some((e2) => "color" === e2.type);
  return i2 && (o2.type.includes("3d") ? B(o2) : E(o2)), o2;
}
async function D(e, l3) {
  var _a, _b;
  if ("flow" === e.type) return p(e, l3);
  if ("pie-chart" === e.type) return new y({ color: null, outline: ((_a = e.outline) == null ? void 0 : _a.width) ? e.outline : new d() });
  let t = null, n = null;
  if ("simple" === e.type) t = e.symbol;
  else if ("class-breaks" === e.type) {
    const l4 = e.classBreakInfos;
    t = l4 && l4[0] && l4[0].symbol, n = l4.length > 1;
  } else if ("unique-value" === e.type) {
    const l4 = e.uniqueValueInfos;
    t = (_b = l4 == null ? void 0 : l4[0]) == null ? void 0 : _b.symbol, n = null != l4 && l4.length > 1;
  }
  return !t || q(t) ? null : (t = t.clone(), (l3 || n) && (t.type.includes("3d") ? B(t) : E(t)), t);
}
function q(e) {
  if (e) {
    if (x(e)) {
      return !!e.symbolLayers && e.symbolLayers.some((e2) => e2 && "fill" === e2.type);
    }
    return e.type.includes("fill");
  }
  return false;
}
function B(e) {
  "line-3d" === e.type ? e.symbolLayers.forEach((e2) => {
    e2.material = { color: g };
  }) : e.symbolLayers.forEach((e2) => {
    var _a;
    "icon" !== e2.type || ((_a = e2.resource) == null ? void 0 : _a.href) ? e2.material = { color: S2 } : (e2.material = { color: w }, e2.outline = { color: g, size: 1.5 });
  });
}
function E(l3) {
  var _a, _b;
  const t = r();
  if ("cim" === l3.type) I(l3, new l(S2));
  else if (l3.type.includes("line")) l3.color = g;
  else if (l3.color = t ? g : w, "simple-marker" === l3.type) if (l3.outline) {
    const e = (_b = (_a = l3.outline) == null ? void 0 : _a.color) == null ? void 0 : _b.toHex();
    "#ffffff" === e && (l3.outline.color = g);
  } else l3.outline = { color: g, width: 1.5 };
}
async function T(e, l3, n, o2) {
  const i2 = (await import("./visualVariableUtils-ERGCQWIK.js")).getSizeRangeAtScale(e, n, o2), s3 = i2 && P(i2);
  if (!i2 || !s3) return;
  let r3 = s3.map((l4) => R(l4, e, i2));
  r3 = u(r3);
  for (let t = 1; t < r3.length - 1; t++) {
    const i3 = await A(e, l3, r3[t], r3[t - 1], n, o2);
    i3 && (r3[t] = i3[0], s3[t] = i3[1]);
  }
  return r3;
}
function P(e) {
  const l3 = e.minSize, t = e.maxSize, n = z2, o2 = (t - l3) / (n - 1), i2 = [];
  for (let s3 = 0; s3 < n; s3++) i2.push(l3 + o2 * s3);
  return i2;
}
function R(e, l3, t) {
  const n = t.minSize, o2 = t.maxSize, i2 = l3.minDataValue, s3 = l3.maxDataValue;
  let r3;
  if (e <= n) r3 = i2;
  else if (e >= o2) r3 = s3;
  else {
    r3 = (e - n) / (o2 - n) * (s3 - i2) + i2;
  }
  return r3;
}
async function A(e, l3, i2, s3, r3, a3) {
  const u2 = await H(e, l3, i2, r3, a3), c2 = await H(e, l3, s3, r3, a3), m2 = i(i2), p3 = m2.fractional, f2 = v2;
  let y4 = m2.integer, b2 = null, h2 = null;
  i2 > 0 && i2 < 1 && (b2 = 10 ** p3, y4 = i(i2 *= b2).integer);
  for (let n = y4 - 1; n >= 0; n--) {
    const s4 = 10 ** n;
    let m3 = Math.floor(i2 / s4) * s4, p4 = Math.ceil(i2 / s4) * s4;
    null != b2 && (m3 /= b2, p4 /= b2);
    let y5 = (m3 + p4) / 2;
    [, y5] = u([m3, y5, p4], { indexes: [1] });
    const d5 = await H(e, l3, m3, r3, a3), w2 = await H(e, l3, p4, r3, a3), S3 = await H(e, l3, y5, r3, a3), g2 = l2(u2, d5, c2, null), v3 = l2(u2, w2, c2, null), z3 = l2(u2, S3, c2, null);
    let j2 = g2.previous <= f2, k2 = v3.previous <= f2;
    if (j2 && k2 && (g2.previous <= v3.previous ? (j2 = true, k2 = false) : (k2 = true, j2 = false)), j2 ? h2 = [m3, d5] : k2 ? h2 = [p4, w2] : z3.previous <= f2 && (h2 = [y5, S3]), h2) break;
  }
  return h2;
}
async function H(e, l3, t, n, o2) {
  const { getSize: i2 } = await import("./visualVariableUtils-ERGCQWIK.js");
  return i2(e, t, { scale: n, view: o2, shape: "simple-marker" === l3.type ? l3.style : null });
}
function O(e, t) {
  const n = e.clone();
  if (x(n)) y2(n) || n.symbolLayers.forEach((e2) => {
    "fill" !== e2.type && (e2.size = t);
  });
  else if (j(n)) n.size = t;
  else if (k(n)) {
    const e2 = n.width, l3 = n.height;
    n.height = t, n.width = t * (e2 / l3);
  } else V(n) ? n.width = t : x2(n) && n.font && (n.font.size = t);
  return n;
}
export {
  L as getRampStops,
  M as getReferenceSizeSymbol,
  b as realWorldMaxSize,
  h as realWorldMinSize
};
//# sourceMappingURL=sizeRampUtils-MPLZDPDR.js.map
