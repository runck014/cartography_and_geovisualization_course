import {
  e as e4,
  o as o4
} from "./chunk-3REIFLHQ.js";
import {
  N,
  P,
  T,
  _,
  _2,
  c as c2,
  c2 as c4,
  c3 as c5,
  f,
  g,
  h,
  h2,
  i as i2,
  l2 as l3,
  m,
  o as o3,
  s as s3,
  s2 as s5
} from "./chunk-UUYHVC5D.js";
import {
  s2 as s4
} from "./chunk-SZ3BUBIG.js";
import {
  c as c3,
  e as e2,
  f3 as f2,
  h5 as h3,
  o as o2
} from "./chunk-JI3JMSDL.js";
import {
  e as e3
} from "./chunk-J3GKRP7Y.js";
import {
  r2 as r,
  t2
} from "./chunk-Q3K5MAUZ.js";
import {
  a2,
  c
} from "./chunk-KJNFPIQW.js";
import {
  ht,
  rt
} from "./chunk-BLBULF2O.js";
import {
  s as s2
} from "./chunk-KI5F6KDS.js";
import {
  n as n3
} from "./chunk-73FHIZIF.js";
import {
  M,
  i
} from "./chunk-ICIPRMPO.js";
import {
  mi
} from "./chunk-CGJUTDVJ.js";
import {
  t
} from "./chunk-EHD5KM2T.js";
import {
  C
} from "./chunk-KV3S4QI2.js";
import {
  n as n2
} from "./chunk-ECMDQ4LS.js";
import {
  B,
  l as l2,
  o,
  u as u2,
  v
} from "./chunk-LP6TMAPE.js";
import {
  l
} from "./chunk-VFTH6C2E.js";
import {
  u
} from "./chunk-YVSEBNS4.js";
import {
  e
} from "./chunk-33ECLFFF.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMeshWriter.js
var o5 = class extends c2 {
};
function r2(e6) {
  const { sprite: o7, isMapAligned: r6, colorLocked: i6, scaleSymbolsProportionally: l5, isStroke: m2 } = e6;
  let n6 = 0;
  return r6 && (n6 |= f(o2.bitset.isMapAligned)), i6 && (n6 |= f(o2.bitset.colorLocked)), o7.sdf && (n6 |= f(o2.bitset.isSDF)), l5 && (n6 |= f(o2.bitset.scaleSymbolsProportionally)), m2 && (n6 |= f(o2.bitset.isStroke)), n6;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMarkerMeshWriter.js
var a3 = class extends o5 {
  get vertexSpec() {
    return { createComputedParams: (t3) => {
      let { pixelDimensions: i6, texelDimensions: r6, baseSize: s9, referenceSize: n6, strokeWidth: o7, sizeRatio: a6 } = t3;
      i6 || (i6 = t3.sprite.sdf ? [0, 0] : [t3.sprite.width, t3.sprite.height]), r6 || (r6 = t3.sprite.sdf ? [0, 0] : i6), s9 = u(s9), n6 = u(n6), o7 = u(o7);
      const c8 = (t3.sprite.sdfDecodeCoeff ?? 1) * a6;
      return { ...t3, pixelDimensions: i6, texelDimensions: r6, baseSize: s9, referenceSize: n6, strokeWidth: o7, sdfDecodeCoeff: c8 };
    }, optionalAttributes: { zoomRange: { type: C.SHORT, count: 2, packPrecisionFactor: mi, pack: ({ scaleInfo: e6 }, { tileInfo: t3 }) => m(e6, t3) } }, attributes: { id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: r2 }, pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 1 }, offset: { type: C.FLOAT, count: 2, packAlternating: { count: 4, pack: (e6) => {
      const t3 = e6.texelDimensions;
      return [[-0.5 * t3[0], -0.5 * t3[1]], [0.5 * t3[0], -0.5 * t3[1]], [-0.5 * t3[0], 0.5 * t3[1]], [0.5 * t3[0], 0.5 * t3[1]]];
    } } }, uv: { type: C.SHORT, count: 2, packPrecisionFactor: 1, packAlternating: { count: 4, packTessellation: ({ texXmax: e6, texXmin: t3, texYmax: i6, texYmin: r6 }) => [[t3, r6], [e6, r6], [t3, i6], [e6, i6]] } }, animationPointerAndBaseSizeAndReferenceSize: { type: C.UNSIGNED_SHORT, count: 4, packPrecisionFactor: 1, pack: ({ animations: e6, baseSize: t3, referenceSize: i6 }) => [e6.dataColumn, e6.dataRow, t3, i6] }, sizing: { type: C.UNSIGNED_SHORT, count: 4, packPrecisionFactor: 8, pack: ({ strokeWidth: e6, pixelDimensions: t3, baseSize: i6, sprite: r6, sizeRatio: s9 }) => {
      const n6 = Math.max(i6 * r6.width / r6.height, i6), o7 = r6.sdfDecodeCoeff * n6 * s9;
      return [t3[0], t3[1], e6, o7];
    } }, angle: { type: C.BYTE, count: 1, packTessellation: ({ angle: e6 }) => e6 } } };
  }
  _write(e6, t3) {
    const i6 = this.evaluatedMeshParams.sprite, { textureBinding: r6 } = i6;
    e6.recordStart(this.instanceId, this.attributeLayout, r6);
    const s9 = t3.getDisplayId();
    if ("esriGeometryPolygon" === t3.geometryType) {
      const i7 = t3.readCentroidForDisplay();
      if (!i7) return;
      const [r7, n6] = i7.coords;
      this._writeQuad(e6, s9, r7, n6);
    } else if ("esriGeometryPoint" === t3.geometryType) {
      const i7 = t3.readXForDisplay(), r7 = t3.readYForDisplay();
      this._writeQuad(e6, s9, i7, r7);
    } else {
      const i7 = t3.readGeometryForDisplay();
      if (i7) {
        const { angleToLine: t4 } = this.evaluatedMeshParams;
        if (t4) {
          let t5 = true, r7 = null, o7 = null;
          i7.forEachVertex((i8, a6) => {
            if (null != r7 && null != o7) {
              const c8 = Math.atan2(a6 - o7, i8 - r7) / c3;
              t5 && (this._writeQuad(e6, s9, r7, o7, c8), t5 = false), this._writeQuad(e6, s9, i8, a6, c8);
            }
            r7 = i8, o7 = a6;
          });
        } else i7.forEachVertex((t5, i8) => {
          this._writeQuad(e6, s9, t5, i8);
        });
      }
    }
    e6.recordEnd();
  }
  _writeQuad(e6, t3, i6, r6, s9 = 0) {
    const n6 = this.evaluatedMeshParams.sprite, { rect: o7 } = n6, a6 = o7.x + 2, c8 = o7.y + 2, d3 = o7.x + o7.width - 2, p2 = o7.y + o7.height - 2, l5 = e6.vertexCount();
    e6.recordBounds(i6, r6, 64, 64);
    const m2 = { texXmin: a6, texYmin: c8, texXmax: d3, texYmax: p2, angle: s9 };
    for (let u6 = 0; u6 < 4; u6++) this._writeVertex(e6, t3, i6, r6, m2);
    e6.indexEnsureSize(6), e6.indexWrite(l5), e6.indexWrite(l5 + 1), e6.indexWrite(l5 + 2), e6.indexWrite(l5 + 1), e6.indexWrite(l5 + 3), e6.indexWrite(l5 + 2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/segmentUtils.js
function e5(t3, e6, n6) {
  return t3[0] = e6[0] - n6[0], t3[1] = e6[1] - n6[1], t3;
}
function n4(t3, e6) {
  return Math.sqrt(t3 * t3 + e6 * e6);
}
function s6(t3) {
  const e6 = n4(t3[0], t3[1]);
  t3[0] /= e6, t3[1] /= e6;
}
function i3(t3, e6) {
  return n4(t3[0] - e6[0], t3[1] - e6[1]);
}
function r3(t3, e6) {
  return t3[e6 + 1];
}
function h4(t3) {
  return t3.length - 1;
}
function a4(t3) {
  let e6 = 0;
  for (let n6 = 0; n6 < h4(t3); n6++) e6 += c6(t3, n6);
  return e6;
}
function c6(t3, e6, n6 = 1) {
  let [s9, i6] = r3(t3, e6);
  return [s9, i6] = [Math.round(s9), Math.round(i6)], Math.sqrt(s9 * s9 + i6 * i6) * n6;
}
var u3 = class _u {
  constructor(t3, e6, n6, s9, i6) {
    this._segments = t3, this._index = e6, this._distance = n6, this._xStart = s9, this._yStart = i6, this._done = false;
  }
  static create(t3) {
    return new _u(t3, 0, 0, t3[0][0], t3[0][1]);
  }
  clone() {
    return new _u(this._segments, this._index, this._distance, this.xStart, this.yStart);
  }
  equals(t3) {
    return this._index === t3._index || t3._index === this._index - 1 && (0 === this._distance || 1 === t3._distance) || t3._index === this._index + 1 && (1 === this._distance || 0 === t3._distance);
  }
  leq(t3) {
    return this._index < t3._index || this._index === t3._index && this._distance <= t3._distance;
  }
  geq(t3) {
    return this._index > t3._index || this._index === t3._index && this._distance >= t3._distance;
  }
  get _segment() {
    return this._segments[this._index + 1];
  }
  get angle() {
    const t3 = this.dy, e6 = (0 * t3 + -1 * -this.dx) / (1 * this.length);
    let n6 = Math.acos(e6);
    return t3 > 0 && (n6 = 2 * Math.PI - n6), n6;
  }
  get xStart() {
    return this._xStart;
  }
  get yStart() {
    return this._yStart;
  }
  get x() {
    return this.xStart + this.distance * this.dx;
  }
  get y() {
    return this.yStart + this.distance * this.dy;
  }
  get dx() {
    return this._segment[0];
  }
  get dy() {
    return this._segment[1];
  }
  get xMidpoint() {
    return this.xStart + 0.5 * this.dx;
  }
  get yMidpoint() {
    return this.yStart + 0.5 * this.dy;
  }
  get xEnd() {
    return this.xStart + this.dx;
  }
  get yEnd() {
    return this.yStart + this.dy;
  }
  get length() {
    const { dx: t3, dy: e6 } = this;
    return Math.sqrt(t3 * t3 + e6 * e6);
  }
  get remainingLength() {
    return this.length * (1 - this._distance);
  }
  get backwardLength() {
    return this.length * this._distance;
  }
  get distance() {
    return this._distance;
  }
  get done() {
    return this._done;
  }
  hasPrev() {
    return this._index - 1 >= 0;
  }
  hasNext() {
    return this._index + 1 < h4(this._segments);
  }
  next() {
    return this.hasNext() ? (this._xStart += this.dx, this._yStart += this.dy, this._distance = 0, this._index += 1, this) : null;
  }
  prev() {
    return this.hasPrev() ? (this._index -= 1, this._xStart -= this.dx, this._yStart -= this.dy, this._distance = 1, this) : (this._done = true, null);
  }
  _seekBackwards(t3, e6) {
    const n6 = this.backwardLength;
    if (t3 <= n6) return this._distance = (n6 - t3) / this.length, this;
    let s9 = this.backwardLength;
    for (; this.prev(); ) {
      if (s9 + this.length > t3) return this._seekBackwards(t3 - s9);
      s9 += this.length;
    }
    return this._distance = 0, e6 ? this : null;
  }
  seek(t3, e6 = false) {
    if (t3 < 0) return this._seekBackwards(Math.abs(t3), e6);
    if (t3 <= this.remainingLength) return this._distance = (this.backwardLength + t3) / this.length, this;
    let n6 = this.remainingLength;
    for (; this.next(); ) {
      if (n6 + this.length > t3) return this.seek(t3 - n6, e6);
      n6 += this.length;
    }
    return this._distance = 1, e6 ? this : null;
  }
};
function d(e6, n6, s9, i6 = true) {
  const r6 = a4(e6), h6 = u3.create(e6), c8 = r6 / 2;
  if (!i6) return h6.seek(c8), void (Math.abs(h6.x) < e3 && Math.abs(h6.y) < e3 && s9(h6.clone(), 0, c8 + 0 * n6, r6));
  const d3 = Math.max((r6 - n6) / 2, 0), o7 = Math.floor(d3 / n6), _3 = c8 - o7 * n6;
  h6.seek(_3);
  for (let a6 = -o7; a6 <= o7; a6++) Math.abs(h6.x) < e3 && Math.abs(h6.y) < e3 && s9(h6.clone(), a6, c8 + a6 * n6, r6), h6.seek(n6);
}
function l4(t3, e6) {
  const n6 = e6;
  for (let s9 = 0; s9 < t3.length; s9++) {
    let e7 = t3[s9];
    g2(e7, n6);
    const i6 = [];
    i6.push(e7[0]);
    for (let t4 = 1; t4 < e7.length; t4++) {
      const [n7, s10] = e7[t4 - 1], [r6, h6] = e7[t4], a6 = r6 - n7, c8 = h6 - s10;
      i6.push([a6, c8]);
    }
    t3[s9] = i6, e7 = i6;
  }
  return t3;
}
function g2(t3, n6) {
  const r6 = 1e-6;
  if (n6 <= 0) return;
  const h6 = t3.length;
  if (h6 < 3) return;
  const a6 = [];
  let c8 = 0;
  a6.push(0);
  for (let e6 = 1; e6 < h6; e6++) c8 += i3(t3[e6], t3[e6 - 1]), a6.push(c8);
  n6 = Math.min(n6, 0.2 * c8);
  const u6 = [];
  u6.push(t3[0][0]), u6.push(t3[0][1]);
  const d3 = t3[h6 - 1][0], o7 = t3[h6 - 1][1], _3 = e5([0, 0], t3[0], t3[1]);
  s6(_3), t3[0][0] += n6 * _3[0], t3[0][1] += n6 * _3[1], e5(_3, t3[h6 - 1], t3[h6 - 2]), s6(_3), t3[h6 - 1][0] += n6 * _3[0], t3[h6 - 1][1] += n6 * _3[1];
  for (let e6 = 1; e6 < h6; e6++) a6[e6] += n6;
  a6[h6 - 1] += n6;
  const l5 = 0.5 * n6;
  for (let e6 = 1; e6 < h6 - 1; e6++) {
    let s9 = 0, i6 = 0, c9 = 0;
    for (let h7 = e6 - 1; h7 >= 0 && !(a6[h7 + 1] < a6[e6] - l5); h7--) {
      const u7 = l5 + a6[h7 + 1] - a6[e6], d4 = a6[h7 + 1] - a6[h7], o8 = a6[e6] - a6[h7] < l5 ? 1 : u7 / d4;
      if (Math.abs(o8) < r6) break;
      const _4 = o8 * o8, g3 = o8 * u7 - 0.5 * _4 * d4, x = o8 * d4 / n6, f4 = t3[h7 + 1], y2 = t3[h7][0] - f4[0], k = t3[h7][1] - f4[1];
      s9 += x / g3 * (f4[0] * o8 * u7 + 0.5 * _4 * (u7 * y2 - d4 * f4[0]) - _4 * o8 * d4 * y2 / 3), i6 += x / g3 * (f4[1] * o8 * u7 + 0.5 * _4 * (u7 * k - d4 * f4[1]) - _4 * o8 * d4 * k / 3), c9 += x;
    }
    for (let u7 = e6 + 1; u7 < h6 && !(a6[u7 - 1] > a6[e6] + l5); u7++) {
      const h7 = l5 - a6[u7 - 1] + a6[e6], d4 = a6[u7] - a6[u7 - 1], o8 = a6[u7] - a6[e6] < l5 ? 1 : h7 / d4;
      if (Math.abs(o8) < r6) break;
      const _4 = o8 * o8, g3 = o8 * h7 - 0.5 * _4 * d4, x = o8 * d4 / n6, f4 = t3[u7 - 1], y2 = t3[u7][0] - f4[0], k = t3[u7][1] - f4[1];
      s9 += x / g3 * (f4[0] * o8 * h7 + 0.5 * _4 * (h7 * y2 - d4 * f4[0]) - _4 * o8 * d4 * y2 / 3), i6 += x / g3 * (f4[1] * o8 * h7 + 0.5 * _4 * (h7 * k - d4 * f4[1]) - _4 * o8 * d4 * k / 3), c9 += x;
    }
    u6.push(s9 / c9), u6.push(i6 / c9);
  }
  u6.push(d3), u6.push(o7);
  for (let e6 = 0, s9 = 0; e6 < h6; e6++) t3[e6][0] = u6[s9++], t3[e6][1] = u6[s9++];
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/labels/LabelMeshWriter.js
var B2 = 1;
var S = 0;
var z = 128;
var A = e((e6) => {
  let t3 = 0;
  if (0 === e6) return 1 / 0;
  for (; !(e6 % 2); ) t3++, e6 /= 2;
  return t3;
});
var I = class extends N {
  constructor() {
    super(...arguments), this._zoomLevel = 0;
  }
  _write(e6, t3, i6, s9) {
    if (this._zoomLevel = s9 || 0, null != i6) throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");
    switch (t3.geometryType) {
      case "esriGeometryPoint": {
        const i7 = t3.readXForDisplay(), s10 = t3.readYForDisplay();
        this._writePoint(e6, i7, s10, t3);
        break;
      }
      case "esriGeometryEnvelope":
      case "esriGeometryPolygon":
      case "esriGeometryMultipoint": {
        const i7 = t3.readCentroidForDisplay();
        if (!i7) return;
        const [s10, r6] = i7.coords;
        this._writePoint(e6, s10, r6, t3);
        break;
      }
      case "esriGeometryPolyline":
        this._writeLines(e6, t3);
    }
  }
  _createLineLabelMetric(e6, t3, i6, s9) {
    var _a, _b;
    const r6 = f2(e6), o7 = "right" === this.evaluatedMeshParams.horizontalAlignment ? -1 : 1, n6 = "bottom" === this.evaluatedMeshParams.verticalAlignment ? -1 : 1, a6 = ((_a = this.evaluatedMeshParams.scaleInfo) == null ? void 0 : _a.maxScale) ?? 0, l5 = ((_b = this.evaluatedMeshParams.scaleInfo) == null ? void 0 : _b.minScale) ?? 0;
    return new r(r6, t3, i6, o7, n6, a6, l5, s9 ?? null);
  }
  _writePoint(e6, t3, i6, s9) {
    var _a, _b;
    const r6 = this._getShaping();
    if (!r6) return;
    const o7 = s9.getDisplayId(), n6 = a2(this.evaluatedMeshParams.horizontalAlignment), a6 = c(this.evaluatedMeshParams.verticalAlignment), l5 = ((_a = this.evaluatedMeshParams.scaleInfo) == null ? void 0 : _a.maxScale) ?? 0, h6 = ((_b = this.evaluatedMeshParams.scaleInfo) == null ? void 0 : _b.minScale) ?? 0, c8 = f2(s9.getDisplayId()), m2 = this._getPointReferenceBounds() || { offsetX: 0, offsetY: 0, size: 0 };
    e6.metricStart(new r(c8, t3, i6, n6, a6, l5, h6, m2)), this._writeGlyphs(e6, o7, t3, i6, r6, 0, m2), e6.metricBoxWrite(r6.boundsT), e6.metricEnd();
  }
  _getPointReferenceBounds() {
    if (!this._references) return null;
    for (const e6 of this._references) {
      const t3 = e6.getBoundsInfo();
      if (t3) return t3;
    }
    return null;
  }
  _writeLines(e6, t3) {
    const { scaleInfo: i6, verticalAlignment: s9 } = this.evaluatedMeshParams, r6 = this.evaluatedMeshParams.repeatLabelDistance || 128, o7 = this._getShaping("middle");
    if (!o7) return;
    const n6 = (e7, t4, i7, s10) => this._placeSubdivGlyphs(e7, t4, i7, s10), a6 = (o7.bounds.width + r6) / (1 << B2);
    this._current = { out: e6, id: t3.getDisplayId(), shaping: o7, zoomRange: m(i6, this.getTileInfo()), referenceBounds: this._getPointReferenceBounds() || { offsetX: 0, offsetY: 0, size: 0 }, offsetDirection: null }, this._verticalPlacement = "bottom" === s9 ? "above" : "top" === s9 ? "below" : null, this._verticalPlacement ? this._writeAboveAndBelowAlong(t3, n6, a6) : this._writeCenterAlong(t3, n6, a6);
  }
  _writeAboveAndBelowAlong(e6, t3, i6) {
    const { repeatLabel: s9 } = this.evaluatedMeshParams, { shaping: r6 } = this._current, o7 = r6.bounds.halfHeight, n6 = e6.readGeometryForDisplay();
    if (!n6) return;
    const a6 = new s2();
    ht(a6, n6, false, false, "esriGeometryPolyline", 1);
    const l5 = D(new s2(), a6, o7), h6 = D(new s2(), a6, -o7), c8 = rt(h6, "esriGeometryPolyline", false, false), m2 = rt(l5, "esriGeometryPolyline", false, false), g3 = l4(m2.paths, r6.bounds.width), p2 = l4(c8.paths, r6.bounds.width);
    this._current.offsetDirection = "above";
    for (const d3 of g3) d(d3, i6, t3, !!s9);
    this._current.offsetDirection = "below";
    for (const d3 of p2) d(d3, i6, t3, !!s9);
  }
  _writeCenterAlong(e6, t3, i6) {
    const { repeatLabel: s9 } = this.evaluatedMeshParams, { shaping: r6 } = this._current, o7 = l4(e6.readLegacyGeometryForDisplay().paths, r6.bounds.width);
    for (const n6 of o7) d(n6, i6, t3, !!s9);
  }
  _placeSubdivGlyphs(e6, t3, i6, s9) {
    const { allowOverrun: r6, labelPosition: o7, repeatLabelDistance: n6 } = this.evaluatedMeshParams, a6 = this._current.zoomRange[0], l5 = A(t3), h6 = this._current.shaping.bounds.width / (1 << B2), c8 = Math.sqrt(n6 || z) / (1 << B2), m2 = Math.min(i6, s9 - i6), d3 = this._current.shaping.isMultiline ? P : Math.log2(m2 / (c8 + h6 / 2)), u6 = 0 === t3 ? d3 : Math.min(l5, d3), f4 = Math.max(a6, this._zoomLevel + B2 - u6), g3 = this._zoomLevel - f4, p2 = this._current.shaping.bounds.width / 2 * 2 ** g3;
    this._current.shaping.isMultiline ? 0 === t3 && this._placeStraight(e6, f4) : r6 && g3 < 0 ? this._placeStraightAlong(e6, a6) : "parallel" === o7 ? this._placeStraightAlong(e6, f4) : "curved" === o7 && this._placeCurved(e6, f4, p2);
  }
  _placeStraight(e6, t3) {
    const { out: i6, id: s9, shaping: r6, referenceBounds: o7 } = this._current, { x: n6, y: a6 } = e6;
    i6.metricStart(this._createLineLabelMetric(s9, n6, a6)), i6.metricBoxWrite(r6.boundsT);
    const l5 = e6.angle * (180 / Math.PI) % 360, h6 = (e6.angle * (180 / Math.PI) + 180) % 360;
    this._writeGlyphs(i6, s9, n6, a6, r6, 0, o7, { clipAngle: l5, mapAligned: true, isLineLabel: true, minZoom: t3 }), this._writeGlyphs(i6, s9, n6, a6, r6, 0, o7, { clipAngle: h6, mapAligned: true, isLineLabel: true, minZoom: t3 }), i6.metricEnd();
  }
  _placeCurved(e6, t3, i6) {
    const { out: s9, id: r6 } = this._current;
    s9.metricStart(this._createLineLabelMetric(r6, e6.x, e6.y));
    const o7 = e6.clone(), n6 = e6.angle * (180 / Math.PI) % 360, a6 = (e6.angle * (180 / Math.PI) + 180) % 360;
    this._verticalPlacement && this._verticalPlacement !== this._current.offsetDirection || (this._placeFirst(o7, t3, 1, n6), this._placeBack(e6, o7, t3, i6, 1, n6), this._placeForward(e6, o7, t3, i6, 1, n6)), this._verticalPlacement && this._verticalPlacement === this._current.offsetDirection || (this._placeFirst(o7, t3, 0, a6), this._placeBack(e6, o7, t3, i6, 0, a6), this._placeForward(e6, o7, t3, i6, 0, a6)), s9.metricEnd();
  }
  _placeStraightAlong(e6, o7) {
    const { out: n6, id: a6, shaping: l5, zoomRange: h6, referenceBounds: m2 } = this._current, { boxBorderLineColor: d3, boxBackgroundColor: u6 } = this.evaluatedMeshParams, f4 = e6.clone(), g3 = e6.angle * (180 / Math.PI) % 360, p2 = (e6.angle * (180 / Math.PI) + 180) % 360, _3 = l5.glyphs.length > 0 && !(!d3 && !u6);
    if (n6.metricStart(this._createLineLabelMetric(a6, e6.x, e6.y)), _3) {
      const d4 = Math.max(o7, h6[0], 0), u7 = Math.min(P, h6[1]), f5 = M(n3(), -e6.angle), _4 = { minZoom: d4, maxZoom: u7, clipAngle: g3, mapAligned: true, isLineLabel: true }, x = u(this.evaluatedMeshParams.offsetX), M2 = u(this.evaluatedMeshParams.offsetY);
      if (!this._verticalPlacement || this._verticalPlacement === this._current.offsetDirection) {
        const t3 = t(x, -1 * M2), [i6, o8] = l5.shapeBackground(i(n3(), f5, t3));
        n6.recordStart(this.instanceId, this.attributeLayout, l5.glyphs[0].textureBinding);
        const h7 = 2 * Math.max(i6.width, i6.height);
        n6.recordBounds(e6.x + i6.x, e6.y + i6.y, h7, h7), this._writeTextBox(n6, a6, e6.x, e6.y, o8, m2, _4), n6.recordEnd();
      }
      if (!this._verticalPlacement || this._verticalPlacement !== this._current.offsetDirection) {
        const t3 = t(x, M2), [i6, o8] = l5.shapeBackground(i(n3(), f5, t3));
        _4.clipAngle = p2, n6.recordStart(this.instanceId, this.attributeLayout, l5.glyphs[0].textureBinding);
        const h7 = 2 * Math.max(i6.width, i6.height);
        n6.recordBounds(e6.x + i6.x, e6.y + i6.y, h7, h7), this._writeTextBox(n6, a6, e6.x, e6.y, o8, m2, _4), n6.recordEnd();
      }
    }
    this._verticalPlacement && this._verticalPlacement !== this._current.offsetDirection || this._placeFirst(f4, o7, 1, g3, true), this._verticalPlacement && this._verticalPlacement === this._current.offsetDirection || this._placeFirst(f4, o7, 0, p2, true), n6.metricEnd();
  }
  _placeBack(e6, t3, i6, s9, r6, o7) {
    const n6 = e6.clone();
    let a6 = e6.backwardLength + S;
    for (; n6.prev() && !(a6 >= s9); ) this._placeOnSegment(n6, t3, a6, i6, -1, r6, o7), a6 += n6.length + S;
  }
  _placeForward(e6, t3, i6, s9, r6, o7) {
    const n6 = e6.clone();
    let a6 = e6.remainingLength + S;
    for (; n6.next() && !(a6 >= s9); ) this._placeOnSegment(n6, t3, a6, i6, 1, r6, o7), a6 += n6.length + S;
  }
  _placeFirst(e6, t3, i6, s9, r6 = false) {
    const { out: o7, id: n6, shaping: a6, zoomRange: l5, referenceBounds: h6 } = this._current, c8 = a6.glyphs;
    for (const m2 of c8) {
      const c9 = m2.x > a6.bounds.x ? i6 : 1 - i6, d3 = c9 * e6.remainingLength + (1 - c9) * e6.backwardLength, u6 = Math.abs(m2.x + m2.width / 2 - a6.bounds.x), f4 = Math.max(0, this._zoomLevel + Math.log2(u6 / (d3 + S))), g3 = Math.max(t3, r6 ? 0 : f4);
      m2.maxZoom = Math.min(l5[1], P), m2.angle = e6.angle + (1 - i6) * Math.PI, m2.minZoom = Math.max(l5[0], g3), this._writeLineGlyph(o7, n6, e6.x, e6.y, a6.bounds, m2, s9, h6, true), (i6 || this._current.offsetDirection) && this._isVisible(m2.minZoom, m2.maxZoom) && o7.metricBoxWrite(m2.bounds);
    }
  }
  _placeOnSegment(e6, t3, i6, s9, r6, o7, n6) {
    const { out: a6, id: l5, shaping: h6, referenceBounds: c8 } = this._current, m2 = h6.glyphs, d3 = e6.dx / e6.length, u6 = e6.dy / e6.length, f4 = { x: e6.x + i6 * -r6 * d3, y: e6.y + i6 * -r6 * u6 };
    for (const g3 of m2) {
      const t4 = g3.x > h6.bounds.x ? o7 : 1 - o7;
      if (!(t4 && 1 === r6 || !t4 && -1 === r6)) continue;
      const m3 = Math.abs(g3.x + g3.width / 2 - h6.bounds.x), d4 = Math.max(0, this._zoomLevel + Math.log2(m3 / i6) - 0.1), u7 = Math.max(s9, this._zoomLevel + Math.log2(m3 / (i6 + e6.length + S)));
      0 !== d4 && (g3.angle = e6.angle + (1 - o7) * Math.PI, g3.minZoom = u7, g3.maxZoom = d4, this._writeLineGlyph(a6, l5, f4.x, f4.y, h6.bounds, g3, n6, c8, true), (o7 || this._current.offsetDirection) && this._isVisible(g3.minZoom, g3.maxZoom) && a6.metricBoxWrite(g3.bounds));
    }
  }
  _writeLineGlyph(e6, t3, i6, s9, r6, o7, n6, a6, l5) {
    const h6 = i6 + r6.x, c8 = s9 + r6.y, m2 = 2 * (this.evaluatedMeshParams.minPixelBuffer ? this.evaluatedMeshParams.minPixelBuffer / this._textMeshTransformProps.fontSize : 1), d3 = Math.max(r6.width, r6.height) * m2;
    e6.recordStart(this.instanceId, this.attributeLayout, o7.textureBinding), e6.recordBounds(h6, c8, d3, d3);
    const { texcoords: u6, offsets: f4 } = o7, { fontSize: g3, haloSize: p2, outlineSize: _3 } = this._textMeshTransformProps;
    this._writeQuad(e6, t3, i6, s9, { texcoords: u6, offsets: f4, fontSize: g3, haloSize: p2, outlineSize: _3, color: g(this.evaluatedMeshParams.color), isBackground: false, referenceBounds: a6, minZoom: Math.max(this._current.zoomRange[0], o7.minZoom), maxZoom: Math.min(this._current.zoomRange[1], o7.maxZoom), clipAngle: n6, mapAligned: l5, isLineLabel: true }), e6.recordEnd();
  }
  _isVisible(e6, t3) {
    const i6 = Math.floor(this._zoomLevel * mi) / mi;
    return e6 <= i6 && i6 <= t3;
  }
};
function D(e6, t3, i6) {
  const { coords: s9, lengths: r6 } = t3, c8 = n2(), d3 = n2(), u6 = n2(), f4 = n2(), g3 = n2(), p2 = n2(), _3 = 2;
  let x = 0;
  for (let m2 = 0; m2 < r6.length; m2++) {
    const t4 = r6[m2];
    for (let r7 = 0; r7 < t4; r7++) {
      const m3 = _3 * (r7 + x - 1), M2 = _3 * (r7 + x), y2 = _3 * (r7 + x + 1);
      r7 > 0 ? o(c8, s9[m3], s9[m3 + 1]) : o(c8, 0, 0), o(d3, s9[M2], s9[M2 + 1]), r7 < t4 - 1 ? o(u6, s9[y2], s9[y2 + 1]) : o(u6, 0, 0), 0 === r7 ? o(f4, 0, 0) : (B(f4, d3, c8), v(f4, f4), o(f4, f4[1], -f4[0])), r7 === t4 - 1 ? o(g3, 0, 0) : (B(g3, u6, d3), v(g3, g3), o(g3, g3[1], -g3[0])), u2(p2, f4, g3), v(p2, p2);
      const b = p2[0] * g3[0] + p2[1] * g3[1];
      0 !== b && l2(p2, p2, b), l2(p2, p2, i6), e6.coords.push(d3[0] + p2[0], d3[1] + p2[1]);
    }
    e6.lengths.push(t4), x += t4;
  }
  return e6;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/infos.js
function o6(t3) {
  return t3 instanceof n5 ? t3 : "object" == typeof t3 && "type" in t3 ? c7[t3.type].hydrate(t3) : new i4(t3);
}
var n5 = class {
  constructor(t3) {
    this.inputs = t3;
  }
  encode() {
    const t3 = [];
    for (const o7 of this.inputs) t3.push(...o7.encode());
    return t3.push(...this.instructions), t3;
  }
};
var i4 = class extends n5 {
  constructor(t3) {
    super([]), this.value = t3;
  }
  simplify() {
    return this;
  }
  get instructions() {
    if (Array.isArray(this.value)) {
      const [o7, n6, i6, s9] = this.value;
      return null != s9 ? h3.vector4.encode([o7, n6 || 0, i6 || 0, s9]) : h3.vector3.encode([o7, n6 || 0, i6 || 0]);
    }
    return h3.scalar.encode(this.value);
  }
};
var s7 = class _s extends n5 {
  constructor(t3, o7) {
    super([o7]), this._config = t3, this._parent = o7;
  }
  static hydrate(t3) {
    return new _s(t3, o6(t3.parent));
  }
  simplify() {
    if (this._config.relativeTranslation || this._config.absoluteScale) return this;
    const t3 = this._parent.simplify();
    if (!(t3 instanceof i4)) return this;
    const [o7, n6, r6, c8] = t3.value, e6 = this._config.translation.from[0], a6 = this._config.translation.from[1], f4 = this._config.rotation.from, h6 = this._config.scale.from;
    if (e6 === this._config.translation.to[0] && a6 === this._config.translation.to[1] && f4 === this._config.rotation.to && h6 === this._config.scale.to) {
      const t4 = r6 + f4, s9 = c8 * h6, u6 = Math.sin(r6), l5 = Math.cos(r6);
      return new i4([l5 * c8 * e6 - u6 * c8 * a6 + o7, u6 * c8 * e6 + l5 * c8 * a6 + n6, t4, s9]);
    }
    return new _s(this._config, t3);
  }
  get instructions() {
    return h3.animatedTransform.encode(this._config);
  }
};
var r4 = class _r extends n5 {
  constructor(t3, o7) {
    super([o7]), this._config = t3, this._parent = o7;
  }
  static hydrate(t3) {
    return new _r(t3, o6(t3.parent));
  }
  simplify() {
    const t3 = this._parent.simplify();
    if (!(t3 instanceof i4)) return this;
    const [o7, n6, s9, c8] = t3.value, e6 = this._config.color.from[0], a6 = this._config.color.from[1], f4 = this._config.color.from[2];
    let h6 = this._config.color.from[3];
    const u6 = this._config.opacity.from;
    return e6 === this._config.color.to[0] && a6 === this._config.color.to[1] && f4 === this._config.color.to[2] && h6 === this._config.color.to[3] && u6 === this._config.opacity.to ? (h6 *= u6, new i4([o7 * e6, n6 * a6, s9 * f4, c8 * h6])) : new _r(this._config, t3);
  }
  get instructions() {
    return h3.animatedColor.encode(this._config);
  }
};
var c7 = { AnimatedTransform: s7, AnimatedColor: r4 };

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/utils.js
function s8(e6) {
  return f3(e6.map((e7) => u4(e7)).map((e7) => o6(e7).simplify()));
}
function i5(e6) {
  const o7 = [];
  return o7.push(e6.transform), o7.push(e6.fromColor), o7.push(e6.toColor), o7.push(e6.colorMix), o7.push(e6.toOpacity), o7.push(e6.opacityMix), o7;
}
function f3(e6) {
  const o7 = [], t3 = [];
  let r6 = 0;
  for (const s9 of e6) {
    const i6 = [...s9.encode(), ...h3.ret.encode()];
    o7.push([r6 + e6.length, 0, 0, 0]), t3.push(...i6), r6 += i6.length;
  }
  return [...o7, ...t3];
}
async function a5(e6, o7) {
  const t3 = e6;
  let r6;
  if ("number" == typeof t3 || "string" == typeof t3 || "boolean" == typeof t3) r6 = t3;
  else if (Array.isArray(t3)) r6 = await Promise.all(t3.map((e7) => a5(e7, o7)));
  else if ("object" == typeof t3) if ("valueExpressionInfo" in t3) {
    const { valueExpressionInfo: e7 } = t3, { expression: n6 } = e7;
    r6 = { ...t3, computed: await o7.createComputedField({ expression: n6 }) };
  } else {
    r6 = {};
    for (const e7 in t3) r6[e7] = await a5(t3[e7], o7);
  }
  return r6;
}
function u4(r6, n6, s9) {
  function i6(o7) {
    if (!("computed" in o7)) return o7;
    let t3 = o7.computed.readWithDefault(n6, s9, [255 * o7.defaultValue[0], 255 * o7.defaultValue[1], 255 * o7.defaultValue[2], o7.defaultValue[3]]);
    if ("string" == typeof t3) {
      const o8 = l.fromString(t3);
      o8 && (t3 = [o8.r, o8.g, o8.b, o8.a]);
    }
    return t3;
  }
  const f4 = r6;
  let a6;
  if ("number" == typeof f4 || "string" == typeof f4 || "boolean" == typeof f4) a6 = f4;
  else if (Array.isArray(f4)) a6 = f4.map((e6) => u4(e6, n6, s9));
  else if ("object" == typeof f4) if ("type" in f4 && null != f4.type && "Process" === f4.type) switch (f4.op) {
    case "ArcadeColor":
      {
        const e6 = u4(f4.value, n6, s9);
        p(Array.isArray(e6) && 4 === e6.length);
        a6 = [e6[0] / 255, e6[1] / 255, e6[2] / 255, e6[3]];
      }
      break;
    case "Transparency":
      {
        const e6 = u4(f4.value, n6, s9);
        p("number" == typeof e6), a6 = 1 - e6 / 100;
      }
      break;
    case "Divide":
      {
        const e6 = u4(f4.left, n6, s9);
        p("number" == typeof e6);
        const o7 = u4(f4.right, n6, s9);
        p("number" == typeof o7), a6 = e6 / o7;
      }
      break;
    case "Random": {
      const e6 = u4(f4.seed, n6, s9), r7 = u4(f4.min, n6, s9), i7 = u4(f4.max, n6, s9), p2 = n6.getObjectId(), c8 = o4(p2 || 0);
      a6 = r7 + e4(c8, e6) * (i7 - r7);
    }
  }
  else if ("computed" in f4) a6 = i6(f4);
  else {
    a6 = {};
    for (const e6 in f4) a6[e6] = u4(f4[e6], n6, s9);
  }
  return a6;
}
function p(e6) {
  if (!e6) throw new Error("Assertion failed.");
}

// node_modules/@arcgis/core/views/2d/layers/features/support/DictionaryValue.js
var r5 = class extends s4 {
  constructor(e6) {
    super(), this._value = e6;
  }
  resize(e6) {
  }
  read(e6, r6) {
    return this._value;
  }
  readWithDefault(e6, r6, t3) {
    return this._value;
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterInputEvaluator.js
var u5 = () => n.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");
async function d2(e6, r6, t3 = false) {
  const { defaultValue: s9, valueExpressionInfo: a6, value: o7 } = r6;
  if (a6) {
    const { expression: o8 } = a6, i6 = await e6.createComputedField({ expression: o8 }, t3);
    return i6 ? { ...r6, computed: i6, defaultValue: s9 } : null;
  }
  return { ...r6, computed: new r5(o7), defaultValue: s9 };
}
async function h5(e6, r6) {
  const { valueExpressionInfo: t3 } = r6, { expression: s9 } = t3, a6 = await e6.createComputedField({ expression: s9 });
  return a6 ? { ...r6, computed: a6 } : null;
}
function y(e6) {
  return "object" == typeof e6 && null != e6 && (!(!("valueExpressionInfo" in e6) || !e6.valueExpressionInfo) || "type" in e6 && "Process" === e6.type && "op" in e6 && "Random" === e6.op);
}
function v2(e6) {
  if (Array.isArray(e6)) {
    for (const r6 of e6) if (v2(r6)) return true;
  }
  if ("object" == typeof e6) {
    if (y(e6)) return true;
    for (const r6 in e6) {
      if (v2(e6[r6])) return true;
    }
  }
  return false;
}
var P2 = class _P {
  static async create(r6, t3, s9) {
    const a6 = {}, o7 = /* @__PURE__ */ new Map(), m2 = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Map(), f4 = /* @__PURE__ */ new Map(), l5 = /* @__PURE__ */ new Map(), u6 = /* @__PURE__ */ new Map();
    for (const P3 in s9) {
      const I2 = s9[P3];
      if (null != I2 && "object" == typeof I2) if (Array.isArray(I2)) {
        if ("object" == typeof I2[0]) throw new Error(`InternalError: Cannot handle ${P3}. Nested array params are not supported`);
        a6[P3] = I2;
      } else if ("valueExpressionInfo" in I2) {
        if (I2.value) {
          a6[P3] = I2.value;
          continue;
        }
        const e6 = await h5(r6, I2);
        if (!e6) {
          a6[P3] = I2.defaultValue;
          continue;
        }
        o7.set(P3, e6), a6[P3] = null;
      } else switch (I2.type) {
        case "cim-effect-infos":
          if (I2.effectInfos.some((e6) => e6.overrides.length)) {
            m2.set(P3, { effects: await Promise.all(I2.effectInfos.map(async (t4) => {
              const s10 = t4.overrides.map((e6) => d2(r6, e6));
              return { effect: t4.effect, compiledOverrides: (await Promise.all(s10)).filter(F) };
            })) });
            break;
          }
          a6[P3] = I2.effectInfos.map((e6) => e6.effect);
          break;
        case "cim-marker-placement-param":
          I2.overrides.length && p2.set(P3, { placementInfo: I2, compiledOverrides: (await Promise.all(I2.overrides.map((e6) => d2(r6, e6)))).filter(F) }), a6[P3] = I2.placement;
          break;
        case "text-rasterization-param": {
          if (I2.overrides.length) {
            const t4 = I2.overrides.map((e6) => d2(r6, e6, I2.useLegacyLabelEvaluationRules));
            f4.set(P3, { compiledOverrides: (await Promise.all(t4)).filter(F), rasterizationParam: I2, objectIdToResourceId: /* @__PURE__ */ new Map() });
            continue;
          }
          const s10 = { type: "cim-rasterization-info", resource: I2.resource };
          a6[P3] = await t3.fetchResourceImmediate(s10) ?? null;
          break;
        }
        case "sprite-rasterization-param": {
          if (I2.overrides.length) {
            const t4 = I2.overrides.map((e6) => d2(r6, e6));
            f4.set(P3, { compiledOverrides: (await Promise.all(t4)).filter(F), rasterizationParam: I2, objectIdToResourceId: /* @__PURE__ */ new Map() });
            continue;
          }
          if ("animated" === I2.resource.type) {
            f4.set(P3, { compiledOverrides: [], rasterizationParam: I2, objectIdToResourceId: /* @__PURE__ */ new Map() });
            continue;
          }
          const s10 = { type: "cim-rasterization-info", resource: I2.resource };
          a6[P3] = await t3.fetchResourceImmediate(s10) ?? null;
          break;
        }
        case "cim-marker-transform-param": {
          const { params: e6 } = I2;
          if (v2(e6)) {
            const t4 = { compiledMarkerInfos: [] };
            await Promise.all(e6.map(async (e7) => {
              const s10 = { props: {} };
              for (const t5 in e7) if (y(e7[t5])) {
                const a7 = await h5(r6, e7[t5]);
                s10.compiledExpressionMap || (s10.compiledExpressionMap = /* @__PURE__ */ new Map());
                const o8 = s10.compiledExpressionMap;
                a7 && o8.set(t5, a7);
              } else s10.props[t5] = e7[t5];
              t4.compiledMarkerInfos.push(s10);
            })), l5.set(P3, t4);
          } else a6[P3] = { type: "cim-marker-transform-info", infos: e6 };
          break;
        }
        case "animation-params": {
          const { params: e6 } = I2, s10 = i5(e6);
          if (v2(s10)) {
            const e7 = await Promise.all(s10.map((e8) => a5(e8, r6)));
            u6.set(P3, { params: e7, propertyIdToResourceId: /* @__PURE__ */ new Map(), key: P3 });
          } else {
            const e7 = s8(s10), r7 = await t3.fetchResourceImmediate({ type: "animation-info", resource: e7 });
            null != r7 && "sprite" === r7.type && (a6[P3] = { dataRow: r7.rect.y, dataColumn: r7.rect.x });
          }
          break;
        }
        default:
          a6[P3] = I2;
      }
      else a6[P3] = I2;
    }
    return new _P(s9, a6, o7, m2, p2, f4, l5, u6);
  }
  constructor(e6, r6, t3, s9, a6, o7, i6, n6) {
    this.inputMeshParams = e6, this._resolvedMeshParams = r6, this._dynamicProperties = t3, this._dynamicEffectProperties = s9, this._dynamicPlacementProperties = a6, this._dynamicAsyncProperties = o7, this._dynamicTransformProperties = i6, this._dynamicAsyncAnimations = n6, this.evaluator = (e7) => e7;
  }
  get hasDynamicProperties() {
    return !!(this._dynamicProperties.size || this._dynamicAsyncProperties.size || this._dynamicEffectProperties.size || this._dynamicTransformProperties.size || this._dynamicPlacementProperties.size || this._dynamicAsyncAnimations.size);
  }
  get evaluatedMeshParams() {
    return this._evaluatedMeshParams || (this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams)), this._evaluatedMeshParams;
  }
  enqueueRequest(e6, s9, i6) {
    for (const o7 of this._dynamicAsyncProperties.values()) {
      const c8 = a(o7.rasterizationParam.resource);
      "animated" === o7.rasterizationParam.resource.type && o7.rasterizationParam.resource.randomizeStartTime && (c8.primitiveName = "__RESERVED__PRIMITIVE__NAME__", c8.startGroup = o4(s9.getObjectId() || 0));
      for (const { primitiveName: e7, propertyName: t3, computed: a6, defaultValue: p2, valueExpressionInfo: l5 } of o7.compiledOverrides) try {
        const r6 = "animated" === o7.rasterizationParam.resource.type ? c8.primitiveName : e7;
        t2(c8, r6, t3, a6, s9, i6, p2);
      } catch (n6) {
        u5().errorOnce(new s("invalid-arcade-expression", `Encountered an error when evaluating the arcade expression '${l5 == null ? void 0 : l5.expression}' (primitive: '${e7}', property: '${t3}')`, n6));
      }
      const m2 = e6.enqueueRequest({ type: "cim-rasterization-info", resource: c8 });
      o7.objectIdToResourceId.set(s9.getObjectId(), m2);
    }
    for (const r6 of this._dynamicAsyncAnimations.values()) {
      const t3 = r6.params.map((e7) => u4(e7, s9, i6)).map(o6).map((e7) => e7.simplify()), a6 = f3(t3), n6 = e6.enqueueRequest({ type: "animation-info", resource: a6 });
      r6.propertyIdToResourceId.set(s9.getObjectId() + "." + r6.key, n6);
    }
  }
  evaluateMeshParams(e6, r6, t3) {
    for (const [s9, a6] of this._dynamicProperties.entries()) this._resolvedMeshParams[s9] = a6.computed.readWithDefault(r6, t3, a6.defaultValue);
    for (const [s9, a6] of this._dynamicPlacementProperties.entries()) for (const { computed: e7, defaultValue: o7, propertyName: i6 } of a6.compiledOverrides) {
      const n6 = e7.readWithDefault(r6, t3, o7);
      a6.placementInfo.placement[i6] = n6, this._resolvedMeshParams[s9] = a6.placementInfo.placement;
    }
    for (const [s9, a6] of this._dynamicEffectProperties.entries()) for (const e7 of a6.effects) {
      for (const { computed: s10, defaultValue: a7, propertyName: o7 } of e7.compiledOverrides) {
        const i6 = s10.readWithDefault(r6, t3, a7);
        e7.effect[o7] = i6;
      }
      this._resolvedMeshParams[s9] = a6.effects.map((e8) => e8.effect);
    }
    for (const [s9, a6] of this._dynamicTransformProperties.entries()) {
      const e7 = { type: "cim-marker-transform-info", infos: [] };
      for (const s10 of a6.compiledMarkerInfos) {
        const a7 = { ...s10.props };
        if (s10.compiledExpressionMap) for (const [e8, o7] of s10.compiledExpressionMap) {
          const s11 = o7.computed.readWithDefault(r6, t3, o7.defaultValue);
          a7[e8] = "number" == typeof s11 || "boolean" == typeof s11 ? s11 : o7.defaultValue;
        }
        e7.infos.push(a7);
      }
      this._resolvedMeshParams[s9] = e7;
    }
    for (const [s9, a6] of this._dynamicAsyncProperties.entries()) {
      const t4 = a6.objectIdToResourceId.get(r6.getObjectId());
      if (null == t4) continue;
      const o7 = e6.getResource(t4);
      this._resolvedMeshParams[s9] = o7;
    }
    for (const [s9, a6] of this._dynamicAsyncAnimations.entries()) {
      const t4 = a6.propertyIdToResourceId.get(r6.getObjectId() + "." + s9);
      if (null == t4) continue;
      const o7 = e6.getResource(t4);
      this._resolvedMeshParams[s9] = { dataRow: o7.rect.y, dataColumn: o7.rect.x };
    }
    return this._evaluatedMeshParams = this.evaluator(this._resolvedMeshParams), this.evaluatedMeshParams;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry.js
var j = class {
  async createMeshWriter(e6, r6, t3, i6) {
    const s9 = this._getMeshWriter(i6.techniqueType), l5 = await P2.create(e6, r6, i6.inputParams), a6 = new s9(i6.id, l5, i6.optionalAttributes, t3);
    return await a6.loadDependencies(), a6;
  }
  _getMeshWriter(f4) {
    switch (f4) {
      case e2.Fill:
        return c4;
      case e2.DotDensity:
        return s3;
      case e2.ComplexFill:
        return h;
      case e2.PatternFill:
        return o3;
      case e2.OutlineFill:
        return h2;
      case e2.PatternOutlineFill:
        return c5;
      case e2.ComplexOutlineFill:
        return _;
      case e2.Marker:
        return _2;
      case e2.PieChart:
        return s5;
      case e2.Text:
        return N;
      case e2.Line:
        return T;
      case e2.TexturedLine:
        return l3;
      case e2.Heatmap:
        return i2;
      case e2.Label:
        return I;
      case e2.AnimatedMarker:
        return a3;
      default:
        throw new Error("Internal Error: Mesh writer not in the registry");
    }
  }
};

export {
  r5 as r,
  j
};
//# sourceMappingURL=chunk-ZITL2WW7.js.map
