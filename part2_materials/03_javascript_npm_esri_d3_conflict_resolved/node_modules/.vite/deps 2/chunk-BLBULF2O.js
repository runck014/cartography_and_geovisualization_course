import {
  e as e2
} from "./chunk-JPQIRBN6.js";
import {
  e
} from "./chunk-CH3XVKUV.js";
import {
  s as s3
} from "./chunk-KI5F6KDS.js";
import {
  D,
  k
} from "./chunk-IOKAACTA.js";
import {
  l,
  s as s2,
  u,
  y
} from "./chunk-F26LCWNQ.js";
import {
  a
} from "./chunk-Z2DWZ5IF.js";
import {
  n as n2
} from "./chunk-R2PAF6JT.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/layers/graphics/featureConversionUtils.js
function d(t, e3) {
  return t ? e3 ? 4 : 3 : e3 ? 3 : 2;
}
var m = () => n.getLogger("esri.layers.graphics.featureConversionUtils");
var g = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0, esriGeometryMultiPatch: 3, esriGeometryEnvelope: 0 };
var y2 = (t, e3, n3, o, r, s4) => {
  t[n3] = r, t[n3 + 1] = s4;
};
var p = (t, e3, n3, o, r, s4) => {
  t[n3] = r, t[n3 + 1] = s4, t[n3 + 2] = e3[o + 2];
};
var I = (t, e3, n3, o, r, s4) => {
  t[n3] = r, t[n3 + 1] = s4, t[n3 + 2] = e3[o + 3];
};
var b = (t, e3, n3, o, r, s4) => {
  t[n3] = r, t[n3 + 1] = s4, t[n3 + 2] = e3[o + 2], t[n3 + 3] = e3[o + 3];
};
function M(t, e3, n3, o) {
  if (t) {
    if (n3) return e3 && o ? b : p;
    if (e3 && o) return I;
  } else if (e3 && o) return p;
  return y2;
}
function N({ scale: t, translate: e3 }, n3) {
  return Math.round((n3 - e3[0]) / t[0]);
}
function w({ scale: t, translate: e3 }, n3) {
  return Math.round((e3[1] - n3) / t[1]);
}
function F({ scale: t, translate: e3 }, n3, o) {
  return n3 * t[o] + e3[o];
}
function P(t, e3, n3) {
  return t ? e3 ? n3 ? k2(t) : Z(t) : n3 ? v(t) : x(t) : null;
}
function x(t) {
  const e3 = t.coords;
  return { x: e3[0], y: e3[1] };
}
function j(t, e3) {
  return t.coords[0] = e3.x, t.coords[1] = e3.y, t;
}
function Z(t) {
  const e3 = t.coords;
  return { x: e3[0], y: e3[1], z: e3[2] };
}
function E(t, e3) {
  return t.coords[0] = e3.x, t.coords[1] = e3.y, t.coords[2] = e3.z, t;
}
function v(t) {
  const e3 = t.coords;
  return { x: e3[0], y: e3[1], m: e3[2] };
}
function z(t, e3) {
  return t.coords[0] = e3.x, t.coords[1] = e3.y, t.coords[2] = e3.m, t;
}
function k2(t) {
  const e3 = t.coords;
  return { x: e3[0], y: e3[1], z: e3[2], m: e3[3] };
}
function V(t, e3) {
  return t.coords[0] = e3.x, t.coords[1] = e3.y, t.coords[2] = e3.z, t.coords[3] = e3.m, t;
}
function Y(t, e3, n3, o) {
  let r = x;
  n3 && o ? r = k2 : n3 ? r = Z : o && (r = v);
  for (const s4 of e3) {
    const { geometry: e4, attributes: n4 } = s4, o2 = null != e4 ? r(e4) : null;
    t.push({ attributes: n4, geometry: o2 });
  }
  return t;
}
function _(t, e3) {
  return t && e3 ? V : t ? E : e3 ? z : j;
}
function L(t, e3, n3, o, r) {
  const s4 = _(n3, o);
  for (const { geometry: u2, attributes: l2 } of e3) {
    const e4 = null != u2 ? s4(new s3(), u2) : null;
    t.push(new e(e4, l2, null, r ? l2[r] : void 0));
  }
  return t;
}
function O(t, e3, n3 = _(null != e3.z, null != e3.m)) {
  return n3(t, e3);
}
function S(t, e3, n3, o) {
  for (const { geometry: r, attributes: s4 } of e3) t.push({ attributes: s4, geometry: null != r ? U(r, n3, o) : null });
  return t;
}
function U(t, e3, n3) {
  if (null == t) return null;
  const o = d(e3, n3), r = [];
  for (let s4 = 0; s4 < t.coords.length; s4 += o) {
    const e4 = [];
    for (let n4 = 0; n4 < o; n4++) e4.push(t.coords[s4 + n4]);
    r.push(e4);
  }
  return e3 ? n3 ? { points: r, hasZ: e3, hasM: n3 } : { points: r, hasZ: e3 } : n3 ? { points: r, hasM: n3 } : { points: r };
}
function q(t, e3, n3, o, r) {
  const s4 = d(n3, o);
  for (const { geometry: u2, attributes: l2 } of e3) {
    const e4 = null != u2 ? R(new s3(), u2, s4) : null;
    t.push(new e(e4, l2, null, r ? l2[r] : void 0));
  }
  return t;
}
function R(t, e3, n3 = d(e3.hasZ, e3.hasM)) {
  t.lengths[0] = e3.points.length;
  const o = t.coords;
  let r = 0;
  for (const s4 of e3.points) for (let t2 = 0; t2 < n3; t2++) o[r++] = s4[t2];
  return t;
}
function A(t, e3, n3, o) {
  for (const { geometry: r, attributes: s4 } of e3) t.push({ attributes: s4, geometry: null != r ? $(r, n3, o) : null });
  return t;
}
function $(t, e3, n3) {
  if (!t) return null;
  const o = d(e3, n3), { coords: r, lengths: s4 } = t, u2 = [];
  let l2 = 0;
  for (const c of s4) {
    const t2 = [];
    for (let e4 = 0; e4 < c; e4++) {
      const e5 = [];
      for (let t3 = 0; t3 < o; t3++) e5.push(r[l2++]);
      t2.push(e5);
    }
    u2.push(t2);
  }
  return e3 ? n3 ? { paths: u2, hasZ: e3, hasM: n3 } : { paths: u2, hasZ: e3 } : n3 ? { paths: u2, hasM: n3 } : { paths: u2 };
}
function B(t, e3, n3, o, r) {
  const s4 = d(n3, o);
  for (const { geometry: u2, attributes: l2, centroid: c } of e3) {
    const e4 = null != u2 ? C(new s3(), u2, s4) : null, n4 = null != c ? O(new s3(), c) : null;
    t.push(new e(e4, l2, n4, r ? l2[r] : void 0));
  }
  return t;
}
function C(t, e3, n3 = d(e3.hasZ, e3.hasM)) {
  const { lengths: o, coords: r } = t;
  let s4 = 0;
  for (const u2 of e3.paths) {
    for (const t2 of u2) for (let e4 = 0; e4 < n3; e4++) r[s4++] = t2[e4];
    o.push(u2.length);
  }
  return t;
}
function D2(t, e3, n3, o) {
  for (const { geometry: r, attributes: s4, centroid: u2 } of e3) {
    const e4 = null != r ? H(r, n3, o) : null;
    if (null != u2) {
      const n4 = x(u2);
      t.push({ attributes: s4, centroid: n4, geometry: e4 });
    } else t.push({ attributes: s4, geometry: e4 });
  }
  return t;
}
function H(t, e3, n3) {
  if (!t) return null;
  const o = d(e3, n3), { coords: r, lengths: s4 } = t, u2 = [];
  let l2 = 0;
  for (const c of s4) {
    const t2 = [];
    for (let e4 = 0; e4 < c; e4++) {
      const e5 = [];
      for (let t3 = 0; t3 < o; t3++) e5.push(r[l2++]);
      t2.push(e5);
    }
    u2.push(t2);
  }
  return e3 ? n3 ? { rings: u2, hasZ: e3, hasM: n3 } : { rings: u2, hasZ: e3 } : n3 ? { rings: u2, hasM: n3 } : { rings: u2 };
}
function J(t, e3, n3, o, r) {
  for (const { geometry: s4, centroid: u2, attributes: l2 } of e3) {
    const e4 = null != s4 ? K(new s3(), s4, n3, o) : null, c = r ? l2[r] : void 0;
    null != u2 ? t.push(new e(e4, l2, j(new s3(), u2), c)) : t.push(new e(e4, l2, null, c));
  }
  return t;
}
function K(t, e3, n3 = e3.hasZ, o = e3.hasM) {
  return Q(t, e3.rings, n3, o);
}
function Q(t, e3, n3, o) {
  const r = d(n3, o), { lengths: s4, coords: u2 } = t;
  let l2 = 0;
  wt(t);
  for (const c of e3) {
    for (const t2 of c) for (let e4 = 0; e4 < r; e4++) u2[l2++] = t2[e4];
    s4.push(c.length);
  }
  return t;
}
var W = [];
var X = [];
function tt(t, e3, n3, o, r) {
  W[0] = t;
  const [s4] = et(X, W, e3, n3, o, r);
  return Gt(W), Gt(X), s4;
}
function et(e3, n3, o, r, s4, u2) {
  if (Gt(e3), !o) {
    for (const t of n3) {
      const n4 = u2 ? t.attributes[u2] : void 0;
      e3.push(new e(null, t.attributes, null, n4));
    }
    return e3;
  }
  switch (o) {
    case "esriGeometryPoint":
      return L(e3, n3, r, s4, u2);
    case "esriGeometryMultipoint":
      return q(e3, n3, r, s4, u2);
    case "esriGeometryPolyline":
      return B(e3, n3, r, s4, u2);
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
      return J(e3, n3, r, s4, u2);
    default:
      m().error("convertToFeatureSet:unknown-geometry", new s(`Unable to parse unknown geometry type '${o}'`)), Gt(e3);
  }
  return e3;
}
function nt(t, e3, n3, o) {
  X[0] = t, ut(W, X, e3, n3, o);
  const r = W[0];
  return Gt(W), Gt(X), r;
}
function ot(e3, n3, o) {
  if (null == e3) return null;
  const r = new s3();
  if ("hasZ" in e3 && null == n3 && (n3 = e3.hasZ), "hasM" in e3 && null == o && (o = e3.hasM), u(e3)) {
    return _(null != n3 ? n3 : null != e3.z, null != o ? o : null != e3.m)(r, e3);
  }
  return y(e3) ? K(r, e3, n3, o) : s2(e3) ? C(r, e3, d(n3, o)) : l(e3) ? R(r, e3, d(n3, o)) : void m().error("convertFromGeometry:unknown-geometry", new s(`Unable to parse unknown geometry type '${e3}'`));
}
function rt(e3, n3, o, r) {
  const s4 = e3 && ("coords" in e3 ? e3 : e3.geometry);
  if (null == s4) return null;
  switch (n3) {
    case "esriGeometryPoint": {
      let t = x;
      return o && r ? t = k2 : o ? t = Z : r && (t = v), t(s4);
    }
    case "esriGeometryMultipoint":
      return U(s4, o, r);
    case "esriGeometryPolyline":
      return $(s4, o, r);
    case "esriGeometryPolygon":
      return H(s4, o, r);
    default:
      return m().error("convertToGeometry:unknown-geometry", new s(`Unable to parse unknown geometry type '${n3}'`)), null;
  }
}
function st(t, e3) {
  for (const n3 of e3) t.push({ attributes: n3.attributes });
  return t;
}
function ut(e3, n3, o, r, s4) {
  if (Gt(e3), null == o) return st(e3, n3);
  switch (o) {
    case "esriGeometryPoint":
      return Y(e3, n3, r, s4);
    case "esriGeometryMultipoint":
      return S(e3, n3, r, s4);
    case "esriGeometryPolyline":
      return A(e3, n3, r, s4);
    case "esriGeometryPolygon":
      return D2(e3, n3, r, s4);
    default:
      m().error("convertToFeatureSet:unknown-geometry", new s(`Unable to parse unknown geometry type '${o}'`));
  }
  return e3;
}
function lt(t) {
  const { objectIdFieldName: e3, spatialReference: n3, transform: o, fields: r, hasM: s4, hasZ: u2, features: l2, geometryType: c, exceededTransferLimit: i, uniqueIdField: f, queryGeometry: a2, queryGeometryType: h } = t, d2 = { features: ut([], l2, c, u2, s4), fields: r, geometryType: c, objectIdFieldName: e3, spatialReference: n3, uniqueIdField: f, queryGeometry: rt(a2, h, false, false) };
  return o && (d2.transform = o), i && (d2.exceededTransferLimit = i), s4 && (d2.hasM = s4), u2 && (d2.hasZ = u2), d2;
}
function ct(e3, n3) {
  const o = new e2(), { hasM: r, hasZ: s4, features: u2, objectIdFieldName: l2, spatialReference: c, geometryType: i, exceededTransferLimit: f, transform: h, fields: d2 } = e3;
  return d2 && (o.fields = d2), o.geometryType = i ?? null, o.objectIdFieldName = l2 ?? n3 ?? null, o.spatialReference = c ?? null, o.objectIdFieldName ? (u2 && et(o.features, u2, i, s4, r, o.objectIdFieldName), f && (o.exceededTransferLimit = f), r && (o.hasM = r), s4 && (o.hasZ = s4), h && (o.transform = h), o) : (m().error(new s("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), o);
}
function it(t) {
  const { transform: e3, features: n3, hasM: o, hasZ: r } = t;
  if (!e3) return t;
  for (const s4 of n3) null != s4.geometry && pt(s4.geometry, s4.geometry, o, r, e3), null != s4.centroid && pt(s4.centroid, s4.centroid, o, r, e3);
  return t.transform = null, t;
}
function ft(t, e3) {
  const { geometryType: n3, features: o, hasM: r, hasZ: s4 } = e3;
  if (!t) return e3;
  for (let u2 = 0; u2 < o.length; u2++) {
    const e4 = o[u2], l2 = e4.weakClone();
    l2.geometry = new s3(), at(l2.geometry, e4.geometry, r, s4, n3, t), e4.centroid && (l2.centroid = new s3(), at(l2.centroid, e4.centroid, r, s4, "esriGeometryPoint", t)), o[u2] = l2;
  }
  return e3.transform = t, e3;
}
function at(t, e3, n3, o, r, s4, u2 = n3, l2 = o) {
  if (wt(t), !(e3 == null ? void 0 : e3.coords.length)) return null;
  const c = g[r], { coords: i, lengths: f } = e3, a2 = d(n3, o), h = d(n3 && u2, o && l2), m2 = M(n3, o, u2, l2);
  if (!f.length) return m2(t.coords, i, 0, 0, N(s4, i[0]), w(s4, i[1])), wt(t, a2, 0), t;
  let y3, p2, I2, b2, G = 0, T = 0, F2 = T;
  for (const d2 of f) {
    if (d2 < c) continue;
    let e4 = 0;
    T = F2, I2 = y3 = N(s4, i[G]), b2 = p2 = w(s4, i[G + 1]), m2(t.coords, i, T, G, I2, b2), e4++, G += a2, T += h;
    for (let n4 = 1; n4 < d2; n4++, G += a2) I2 = N(s4, i[G]), b2 = w(s4, i[G + 1]), I2 === y3 && b2 === p2 || (m2(t.coords, i, T, G, I2 - y3, b2 - p2), T += h, e4++, y3 = I2, p2 = b2);
    e4 >= c && (t.lengths.push(e4), F2 = T);
  }
  return Gt(t.coords, F2), t.coords.length ? t : null;
}
function ht(t, e3, n3, o, r, s4, u2 = n3, l2 = o) {
  if (wt(t), !(e3 == null ? void 0 : e3.coords.length)) return null;
  const c = g[r], { coords: i, lengths: f } = e3, a2 = d(n3, o), h = d(n3 && u2, o && l2), m2 = M(n3, o, u2, l2);
  if (!f.length) return m2(t.coords, i, 0, 0, i[0], i[1]), wt(t, a2, 0), t;
  let y3 = 0;
  const p2 = s4 * s4;
  for (const d2 of f) {
    if (d2 < c) {
      y3 += d2 * a2;
      continue;
    }
    const e4 = t.coords.length / h, n4 = y3, o2 = y3 + (d2 - 1) * a2;
    m2(t.coords, i, t.coords.length, n4, i[n4], i[n4 + 1]), mt(t.coords, i, a2, p2, m2, n4, o2), m2(t.coords, i, t.coords.length, o2, i[o2], i[o2 + 1]);
    const r2 = t.coords.length / h - e4;
    r2 >= c ? t.lengths.push(r2) : Gt(t.coords, e4 * h), y3 += d2 * a2;
  }
  return t.coords.length ? t : null;
}
function dt(t, e3, n3, o) {
  const r = t[e3], s4 = t[e3 + 1], u2 = t[n3], l2 = t[n3 + 1], c = t[o], i = t[o + 1];
  let f = u2, a2 = l2, h = c - f, d2 = i - a2;
  if (0 !== h || 0 !== d2) {
    const t2 = ((r - f) * h + (s4 - a2) * d2) / (h * h + d2 * d2);
    t2 > 1 ? (f = c, a2 = i) : t2 > 0 && (f += h * t2, a2 += d2 * t2);
  }
  return h = r - f, d2 = s4 - a2, h * h + d2 * d2;
}
function mt(t, e3, n3, o, r, s4, u2) {
  let l2, c = o, i = 0;
  for (let f = s4 + n3; f < u2; f += n3) l2 = dt(e3, f, s4, u2), l2 > c && (i = f, c = l2);
  c > o && (i - s4 > n3 && mt(t, e3, n3, o, r, s4, i), r(t, e3, t.length, i, e3[i], e3[i + 1]), u2 - i > n3 && mt(t, e3, n3, o, r, i, u2));
}
function gt(t, e3, n3, u2) {
  var _a;
  if (!((_a = e3 == null ? void 0 : e3.coords) == null ? void 0 : _a.length)) return null;
  const l2 = d(n3, u2);
  let c = Number.POSITIVE_INFINITY, i = Number.POSITIVE_INFINITY, f = Number.NEGATIVE_INFINITY, a2 = Number.NEGATIVE_INFINITY;
  if (e3 && e3.coords) {
    const t2 = e3.coords;
    for (let e4 = 0; e4 < t2.length; e4 += l2) {
      const n4 = t2[e4], o = t2[e4 + 1];
      c = Math.min(c, n4), f = Math.max(f, n4), i = Math.min(i, o), a2 = Math.max(a2, o);
    }
  }
  return k(t) ? D(t, c, i, f, a2) : a(c, i, f, a2, t), t;
}
function pt(t, e3, o, r, s4) {
  const { coords: u2, lengths: l2 } = e3, c = d(o, r);
  if (!u2.length) return t !== e3 && wt(t), t;
  n2(s4);
  const { originPosition: i, scale: f, translate: a2 } = s4, h = Tt;
  h.originPosition = i;
  const m2 = h.scale;
  m2[0] = f[0] ?? 1, m2[1] = -(f[1] ?? 1), m2[2] = f[2] ?? 1, m2[3] = f[3] ?? 1;
  const g2 = h.translate;
  if (g2[0] = a2[0] ?? 0, g2[1] = a2[1] ?? 0, g2[2] = a2[2] ?? 0, g2[3] = a2[3] ?? 0, !l2.length) {
    for (let e4 = 0; e4 < c; ++e4) t.coords[e4] = F(h, u2[e4], e4);
    return t !== e3 && wt(t, c, 0), t;
  }
  let y3 = 0;
  for (let n3 = 0; n3 < l2.length; n3++) {
    const e4 = l2[n3];
    t.lengths[n3] = e4;
    for (let n4 = 0; n4 < c; ++n4) t.coords[y3 + n4] = F(h, u2[y3 + n4], n4);
    let o2 = t.coords[y3], r2 = t.coords[y3 + 1];
    y3 += c;
    for (let n4 = 1; n4 < e4; n4++, y3 += c) {
      o2 += u2[y3] * m2[0], r2 += u2[y3 + 1] * m2[1], t.coords[y3] = o2, t.coords[y3 + 1] = r2;
      for (let e5 = 2; e5 < c; ++e5) t.coords[y3 + e5] = F(h, u2[y3 + e5], e5);
    }
  }
  return t !== e3 && wt(t, u2.length, l2.length), t;
}
function It(t, e3, n3, o, r, s4) {
  if (wt(t), t.lengths.push(...e3.lengths), n3 === r && o === s4) for (let u2 = 0; u2 < e3.coords.length; u2++) t.coords.push(e3.coords[u2]);
  else {
    const u2 = d(n3, o), l2 = M(n3, o, r, s4), c = e3.coords;
    for (let e4 = 0; e4 < c.length; e4 += u2) l2(t.coords, c, t.coords.length, e4, c[e4], c[e4 + 1]);
  }
  return t;
}
function Mt(t, e3, n3, o) {
  let r = 0, s4 = t[o * e3], u2 = t[o * (e3 + 1)];
  for (let l2 = 1; l2 < n3; l2++) {
    const n4 = s4 + t[o * (e3 + l2)], c = u2 + t[o * (e3 + l2) + 1], i = (n4 - s4) * (c + u2);
    s4 = n4, u2 = c, r += i;
  }
  return 0.5 * r;
}
function Nt(t, e3) {
  const { coords: n3, lengths: o } = t;
  let r = 0, s4 = 0;
  for (let u2 = 0; u2 < o.length; u2++) {
    const t2 = o[u2];
    s4 += Mt(n3, r, t2, e3), r += t2;
  }
  return Math.abs(s4);
}
function wt(t, e3 = 0, n3 = 0) {
  Gt(t.lengths, n3), Gt(t.coords, e3);
}
function Gt(t, e3 = 0) {
  t.length !== e3 && (t.length = e3);
}
var Tt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };

export {
  N,
  w,
  P,
  O,
  U,
  $,
  H,
  K,
  Q,
  tt,
  et,
  nt,
  ot,
  rt,
  lt,
  ct,
  it,
  ft,
  at,
  ht,
  gt,
  pt,
  It,
  Nt
};
//# sourceMappingURL=chunk-BLBULF2O.js.map
