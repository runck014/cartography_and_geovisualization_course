import {
  A,
  B,
  C,
  D,
  G,
  L,
  M,
  P,
  U,
  V,
  c
} from "./chunk-KV3S4QI2.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/webgl/checkWebGLError.js
var o = () => n.getLogger("esri.views.webgl.checkWebGLError");
function t(e2, r2) {
  switch (r2) {
    case e2.INVALID_ENUM:
      return "Invalid Enum. An unacceptable value has been specified for an enumerated argument.";
    case e2.INVALID_VALUE:
      return "Invalid Value. A numeric argument is out of range.";
    case e2.INVALID_OPERATION:
      return "Invalid Operation. The specified command is not allowed for the current state.";
    case e2.INVALID_FRAMEBUFFER_OPERATION:
      return "Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";
    case e2.OUT_OF_MEMORY:
      return "Out of memory. Not enough memory is left to execute the command.";
    case e2.CONTEXT_LOST_WEBGL:
      return "WebGL context has been lost";
    default:
      return "Unknown error";
  }
}
var n2 = !!has("enable-feature:webgl-debug");
function a() {
  return n2;
}
function c2() {
  return n2;
}
function u(r2) {
  if (a()) {
    const n3 = r2.getError();
    if (n3) {
      const a3 = t(r2, n3), c4 = new Error().stack;
      o().error(new s("webgl-error", "WebGL error occurred", { message: a3, stack: c4 }));
    }
  }
}

// node_modules/@arcgis/core/views/webgl/GLObjectType.js
var e;
!function(e2) {
  e2[e2.Texture = 0] = "Texture", e2[e2.RenderBuffer = 1] = "RenderBuffer";
}(e || (e = {}));

// node_modules/@arcgis/core/views/webgl/getDataTypeBytes.js
function s2(s3) {
  switch (s3) {
    case C.BYTE:
    case C.UNSIGNED_BYTE:
      return 1;
    case C.SHORT:
    case C.UNSIGNED_SHORT:
    case C.HALF_FLOAT:
      return 2;
    case C.FLOAT:
    case C.INT:
    case C.UNSIGNED_INT:
      return 4;
  }
}

// node_modules/@arcgis/core/views/webgl/Util.js
function o2(e2) {
  const r2 = e2.gl;
  switch (r2.getError()) {
    case r2.NO_ERROR:
      return null;
    case r2.INVALID_ENUM:
      return "An unacceptable value has been specified for an enumerated argument";
    case r2.INVALID_VALUE:
      return "An unacceptable value has been specified for an argument";
    case r2.INVALID_OPERATION:
      return "The specified command is not allowed for the current state";
    case r2.INVALID_FRAMEBUFFER_OPERATION:
      return "The currently bound framebuffer is not framebuffer complete";
    case r2.OUT_OF_MEMORY:
      return "Not enough memory is left to execute the command";
    case r2.CONTEXT_LOST_WEBGL:
      return "WebGL context is lost";
  }
  return "Unknown error";
}
function E(r2, t2, s3, a3, c4 = 0) {
  var _a;
  const i = r2.gl;
  r2.bindBuffer(s3);
  for (const R2 of a3) {
    const s4 = t2.get(R2.name);
    if (null == s4) {
      console.warn(`There is no location for vertex attribute '${R2.name}' defined.`);
      continue;
    }
    const a4 = c4 * R2.stride;
    if (R2.count <= 4) i.vertexAttribPointer(s4, R2.count, R2.type, R2.normalized, R2.stride, R2.offset + a4), i.enableVertexAttribArray(s4), R2.divisor > 0 && r2.gl.vertexAttribDivisor(s4, R2.divisor);
    else if (9 === R2.count) for (let e2 = 0; e2 < 3; e2++) i.vertexAttribPointer(s4 + e2, 3, R2.type, R2.normalized, R2.stride, R2.offset + 12 * e2 + a4), i.enableVertexAttribArray(s4 + e2), R2.divisor > 0 && r2.gl.vertexAttribDivisor(s4 + e2, R2.divisor);
    else if (16 === R2.count) for (let e2 = 0; e2 < 4; e2++) i.vertexAttribPointer(s4 + e2, 4, R2.type, R2.normalized, R2.stride, R2.offset + 16 * e2 + a4), i.enableVertexAttribArray(s4 + e2), R2.divisor > 0 && ((_a = r2.gl) == null ? void 0 : _a.vertexAttribDivisor(s4 + e2, R2.divisor));
    else console.error("Unsupported vertex attribute element count: " + R2.count);
    if (a()) {
      const e2 = o2(r2), t3 = s2(R2.type), s5 = R2.offset, c5 = Math.round(t3 / s5) !== t3 / s5 ? `. Offset not a multiple of stride. DataType requires ${t3} bytes, but descriptor has an offset of ${s5}` : "";
      e2 && console.error(`Unable to bind vertex attribute "${R2.name}" with baseInstanceOffset ${a4}${c5}:`, e2, R2);
    }
  }
}
function _(e2, t2, s3, a3) {
  var _a, _b, _c;
  const c4 = e2.gl;
  e2.bindBuffer(s3);
  for (const r2 of a3) {
    const s4 = t2.get(r2.name);
    if (r2.count <= 4) c4.disableVertexAttribArray(s4), r2.divisor && r2.divisor > 0 && ((_a = e2.gl) == null ? void 0 : _a.vertexAttribDivisor(s4, 0));
    else if (9 === r2.count) for (let t3 = 0; t3 < 3; t3++) c4.disableVertexAttribArray(s4 + t3), r2.divisor && r2.divisor > 0 && ((_b = e2.gl) == null ? void 0 : _b.vertexAttribDivisor(s4 + t3, 0));
    else if (16 === r2.count) for (let t3 = 0; t3 < 4; t3++) c4.disableVertexAttribArray(s4 + t3), r2.divisor && r2.divisor > 0 && ((_c = e2.gl) == null ? void 0 : _c.vertexAttribDivisor(s4 + t3, 0));
    else console.error("Unsupported vertex attribute element count: " + r2.count);
  }
  e2.unbindBuffer(A.ARRAY_BUFFER);
}
function u2(e2) {
  switch (e2) {
    case G.ALPHA:
    case G.LUMINANCE:
    case G.RED:
    case G.RED_INTEGER:
    case P.R8:
    case P.R8I:
    case P.R8UI:
    case P.R8_SNORM:
    case B.STENCIL_INDEX8:
      return 1;
    case G.LUMINANCE_ALPHA:
    case G.RG:
    case G.RG_INTEGER:
    case P.RGBA4:
    case P.R16F:
    case P.R16I:
    case P.R16UI:
    case P.RG8:
    case P.RG8I:
    case P.RG8UI:
    case P.RG8_SNORM:
    case P.RGB565:
    case P.RGB5_A1:
    case B.DEPTH_COMPONENT16:
      return 2;
    case G.DEPTH_COMPONENT:
    case G.RGB:
    case G.RGB_INTEGER:
    case P.RGB8:
    case P.RGB8I:
    case P.RGB8UI:
    case P.RGB8_SNORM:
    case P.SRGB8:
    case B.DEPTH_COMPONENT24:
      return 3;
    case G.DEPTH_STENCIL:
    case G.DEPTH24_STENCIL8:
    case G.RGBA:
    case G.RGBA_INTEGER:
    case P.RGBA8:
    case P.R32F:
    case P.R11F_G11F_B10F:
    case P.RG16F:
    case P.R32I:
    case P.R32UI:
    case P.RG16I:
    case P.RG16UI:
    case P.RGBA8I:
    case P.RGBA8UI:
    case P.RGBA8_SNORM:
    case P.SRGB8_ALPHA8:
    case P.RGB9_E5:
    case P.RGB10_A2UI:
    case P.RGB10_A2:
    case B.DEPTH_STENCIL:
    case B.DEPTH_COMPONENT32F:
    case B.DEPTH24_STENCIL8:
      return 4;
    case B.DEPTH32F_STENCIL8:
      return 5;
    case P.RGB16F:
    case P.RGB16I:
    case P.RGB16UI:
      return 6;
    case P.RG32F:
    case P.RG32I:
    case P.RG32UI:
    case P.RGBA16F:
    case P.RGBA16I:
    case P.RGBA16UI:
      return 8;
    case P.RGB32F:
    case P.RGB32I:
    case P.RGB32UI:
      return 12;
    case P.RGBA32F:
    case P.RGBA32I:
    case P.RGBA32UI:
      return 16;
    case c.COMPRESSED_RGB_S3TC_DXT1_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT1_EXT:
      return 0.5;
    case c.COMPRESSED_RGBA_S3TC_DXT3_EXT:
    case c.COMPRESSED_RGBA_S3TC_DXT5_EXT:
      return 1;
    case c.COMPRESSED_R11_EAC:
    case c.COMPRESSED_SIGNED_R11_EAC:
    case c.COMPRESSED_RGB8_ETC2:
    case c.COMPRESSED_SRGB8_ETC2:
    case c.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
    case c.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
      return 0.5;
    case c.COMPRESSED_RG11_EAC:
    case c.COMPRESSED_SIGNED_RG11_EAC:
    case c.COMPRESSED_RGBA8_ETC2_EAC:
    case c.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
      return 1;
  }
  return 0;
}

// node_modules/@arcgis/core/views/webgl/TextureDescriptor.js
var p = class {
  constructor(e2 = 0, p2 = e2) {
    this.width = e2, this.height = p2, this.target = M.TEXTURE_2D, this.pixelFormat = G.RGBA, this.dataType = U.UNSIGNED_BYTE, this.samplingMode = L.LINEAR, this.wrapMode = D.REPEAT, this.maxAnisotropy = 1, this.flipped = false, this.hasMipmap = false, this.isOpaque = false, this.unpackAlignment = 4, this.preMultiplyAlpha = false, this.depth = 1, this.isImmutable = false;
  }
};
function r(i) {
  return i.width <= 0 || i.height <= 0 ? 0 : Math.round(i.width * i.height * (i.hasMipmap ? 4 / 3 : 1) * (null == i.internalFormat ? 4 : u2(i.internalFormat)) * (i.target === M.TEXTURE_CUBE_MAP ? 6 : 1));
}

// node_modules/@arcgis/core/views/webgl/ValidatedTextureDescriptor.js
var a2 = class _a extends p {
  constructor(t2, a3) {
    switch (super(), this.context = t2, Object.assign(this, a3), this.internalFormat) {
      case P.R16F:
      case P.R16I:
      case P.R16UI:
      case P.R32F:
      case P.R32I:
      case P.R32UI:
      case P.R8_SNORM:
      case P.R8:
      case P.R8I:
      case P.R8UI:
        this.pixelFormat = G.RED;
    }
  }
  static validate(s3, e2) {
    return new _a(s3, e2);
  }
};

// node_modules/@arcgis/core/views/webgl/Texture.js
var m = class l {
  constructor(e2, r2 = null, s3 = null) {
    if (this.type = e.Texture, this._glName = null, this._samplingModeDirty = false, this._wrapModeDirty = false, this._wasImmutablyAllocated = false, "context" in e2) this._descriptor = e2, s3 = r2;
    else {
      const i = a2.validate(e2, r2);
      if (!i) throw new s("Texture descriptor invalid");
      this._descriptor = i;
    }
    this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(s3) : this.setData(s3);
  }
  get glName() {
    return this._glName;
  }
  get descriptor() {
    return this._descriptor;
  }
  get usedMemory() {
    return r(this._descriptor);
  }
  get isDirty() {
    return this._samplingModeDirty || this._wrapModeDirty;
  }
  dispose() {
    this._glName && this._descriptor.context.instanceCounter.decrement(V.Texture, this), this._descriptor.context.gl && this._glName && (this._descriptor.context.unbindTexture(this), this._descriptor.context.gl.deleteTexture(this._glName), this._glName = null);
  }
  release() {
    this.dispose();
  }
  resize(e2, r2) {
    const s3 = this._descriptor;
    if (s3.width !== e2 || s3.height !== r2) {
      if (this._wasImmutablyAllocated) throw new s("Immutable textures can't be resized!");
      s3.width = e2, s3.height = r2, this._descriptor.target === M.TEXTURE_CUBE_MAP ? this._setDataCubeMap(null) : this.setData(null);
    }
  }
  _setDataCubeMap(t2 = null) {
    for (let e2 = M.TEXTURE_CUBE_MAP_POSITIVE_X; e2 <= M.TEXTURE_CUBE_MAP_NEGATIVE_Z; e2++) this._setData(t2, e2);
  }
  setData(t2) {
    this._setData(t2);
  }
  _setData(i, s3) {
    var _a;
    const o3 = (_a = this._descriptor.context) == null ? void 0 : _a.gl;
    if (!o3) return;
    u(o3), this._glName || (this._glName = o3.createTexture(), this._glName && this._descriptor.context.instanceCounter.increment(V.Texture, this));
    const a3 = this._descriptor, n3 = s3 ?? a3.target, h = f(n3), p2 = this._descriptor.context.bindTexture(this, l.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.setActiveTexture(l.TEXTURE_UNIT_FOR_UPDATES), c3(a3), this._configurePixelStorage(), u(o3);
    const d = this._deriveInternalFormat();
    if (I(i)) {
      let t2 = "width" in i ? i.width : i.codedWidth, r2 = "height" in i ? i.height : i.codedHeight;
      const s4 = 1;
      i instanceof HTMLVideoElement && (t2 = i.videoWidth, r2 = i.videoHeight), a3.width && a3.height, h && a3.depth, a3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(n3, d, a3.hasMipmap, t2, r2, s4), this._texImage(n3, 0, d, t2, r2, s4, i), u(o3), a3.hasMipmap && (this.generateMipmap(), u(o3)), a3.width || (a3.width = t2), a3.height || (a3.height = r2), h && !a3.depth && (a3.depth = s4);
    } else {
      const { width: r2, height: s4, depth: l2 } = a3;
      if (null == r2 || null == s4) throw new s("Width and height must be specified!");
      if (h && null == l2) throw new s("Depth must be specified!");
      if (a3.isImmutable && !this._wasImmutablyAllocated && this._texStorage(n3, d, a3.hasMipmap, r2, s4, l2), M2(i)) {
        const e2 = i.levels, h2 = R(n3, r2, s4, l2), p3 = Math.min(h2 - 1, e2.length - 1);
        o3.texParameteri(a3.target, this._descriptor.context.gl.TEXTURE_MAX_LEVEL, p3);
        const _2 = d;
        if (!x(_2)) throw new s("Attempting to use compressed data with an uncompressed format!");
        this._forEachMipmapLevel((t2, i2, r3, s5) => {
          const o4 = e2[Math.min(t2, e2.length - 1)];
          this._compressedTexImage(n3, t2, _2, i2, r3, s5, o4);
        }, p3);
      } else this._texImage(n3, 0, d, r2, s4, l2, i), u(o3), a3.hasMipmap && this.generateMipmap();
    }
    u3(o3, this._descriptor), T(o3, this._descriptor), E2(this._descriptor.context, this._descriptor), u(o3), this._descriptor.context.bindTexture(p2, l.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData(e2, i, r2, s3, o3, a3, n3 = 0) {
    a3 || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const h = this._descriptor, p2 = this._deriveInternalFormat(), { context: d, pixelFormat: _2, dataType: m2, target: c4, isImmutable: u4 } = h;
    if (u4 && !this._wasImmutablyAllocated) throw new s("Cannot update immutable texture before allocation!");
    const T2 = d.bindTexture(this, l.TEXTURE_UNIT_FOR_UPDATES, true);
    (i < 0 || r2 < 0 || i + s3 > h.width || r2 + o3 > h.height) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage();
    const { gl: E3 } = d;
    n3 && E3.pixelStorei(E3.UNPACK_SKIP_ROWS, n3), I(a3) ? E3.texSubImage2D(c4, e2, i, r2, s3, o3, _2, m2, a3) : M2(a3) ? E3.compressedTexSubImage2D(c4, e2, i, r2, s3, o3, p2, a3.levels[e2]) : E3.texSubImage2D(c4, e2, i, r2, s3, o3, _2, m2, a3), n3 && E3.pixelStorei(E3.UNPACK_SKIP_ROWS, 0), d.bindTexture(T2, l.TEXTURE_UNIT_FOR_UPDATES);
  }
  updateData3D(e2, i, r2, s3, o3, a3, n3, h) {
    h || console.error("An attempt to use uninitialized data!"), this._glName || console.error("An attempt to update uninitialized texture!");
    const p2 = this._descriptor, d = this._deriveInternalFormat(), { context: _2, pixelFormat: m2, dataType: c4, isImmutable: u4, target: T2 } = p2;
    if (u4 && !this._wasImmutablyAllocated) throw new s("Cannot update immutable texture before allocation!");
    f(T2) || console.warn("Attempting to set 3D texture data on a non-3D texture");
    const E3 = _2.bindTexture(this, l.TEXTURE_UNIT_FOR_UPDATES);
    _2.setActiveTexture(l.TEXTURE_UNIT_FOR_UPDATES), (i < 0 || r2 < 0 || s3 < 0 || i + o3 > p2.width || r2 + a3 > p2.height || s3 + n3 > p2.depth) && console.error("An attempt to update out of bounds of the texture!"), this._configurePixelStorage();
    const { gl: g2 } = _2;
    if (M2(h)) h = h.levels[e2], g2.compressedTexSubImage3D(T2, e2, i, r2, s3, o3, a3, n3, d, h);
    else {
      const t2 = h;
      g2.texSubImage3D(T2, e2, i, r2, s3, o3, a3, n3, m2, c4, t2);
    }
    _2.bindTexture(E3, l.TEXTURE_UNIT_FOR_UPDATES);
  }
  generateMipmap() {
    const e2 = this._descriptor;
    if (!e2.hasMipmap) {
      if (this._wasImmutablyAllocated) throw new s("Cannot add mipmaps to immutable texture after allocation");
      e2.hasMipmap = true, this._samplingModeDirty = true, c3(e2);
    }
    e2.samplingMode === L.LINEAR ? (this._samplingModeDirty = true, e2.samplingMode = L.LINEAR_MIPMAP_NEAREST) : e2.samplingMode === L.NEAREST && (this._samplingModeDirty = true, e2.samplingMode = L.NEAREST_MIPMAP_NEAREST);
    const i = this._descriptor.context.bindTexture(this, l.TEXTURE_UNIT_FOR_UPDATES);
    this._descriptor.context.setActiveTexture(l.TEXTURE_UNIT_FOR_UPDATES), this._descriptor.context.gl.generateMipmap(e2.target), this._descriptor.context.bindTexture(i, l.TEXTURE_UNIT_FOR_UPDATES);
  }
  clearMipmap() {
    const e2 = this._descriptor;
    if (e2.hasMipmap) {
      if (this._wasImmutablyAllocated) throw new s("Cannot delete mipmaps to immutable texture after allocation");
      e2.hasMipmap = false, this._samplingModeDirty = true, c3(e2);
    }
    e2.samplingMode === L.LINEAR_MIPMAP_NEAREST ? (this._samplingModeDirty = true, e2.samplingMode = L.LINEAR) : e2.samplingMode === L.NEAREST_MIPMAP_NEAREST && (this._samplingModeDirty = true, e2.samplingMode = L.NEAREST);
  }
  setSamplingMode(t2) {
    t2 !== this._descriptor.samplingMode && (this._descriptor.samplingMode = t2, this._samplingModeDirty = true);
  }
  setWrapMode(t2) {
    t2 !== this._descriptor.wrapMode && (this._descriptor.wrapMode = t2, c3(this._descriptor), this._wrapModeDirty = true);
  }
  applyChanges() {
    const t2 = this._descriptor, e2 = t2.context.gl;
    this._samplingModeDirty && (u3(e2, t2), this._samplingModeDirty = false), this._wrapModeDirty && (T(e2, t2), this._wrapModeDirty = false);
  }
  _deriveInternalFormat() {
    if (null != this._descriptor.internalFormat) return this._descriptor.internalFormat === G.DEPTH_STENCIL && (this._descriptor.internalFormat = G.DEPTH24_STENCIL8), this._descriptor.internalFormat;
    switch (this._descriptor.dataType) {
      case U.FLOAT:
        switch (this._descriptor.pixelFormat) {
          case G.RGBA:
            return this._descriptor.internalFormat = P.RGBA32F;
          case G.RGB:
            return this._descriptor.internalFormat = P.RGB32F;
          default:
            throw new s("Unable to derive format");
        }
      case U.UNSIGNED_BYTE:
        switch (this._descriptor.pixelFormat) {
          case G.RGBA:
            return this._descriptor.internalFormat = P.RGBA8;
          case G.RGB:
            return this._descriptor.internalFormat = P.RGB8;
        }
    }
    return this._descriptor.internalFormat = this._descriptor.pixelFormat === G.DEPTH_STENCIL ? G.DEPTH24_STENCIL8 : this._descriptor.pixelFormat;
  }
  _configurePixelStorage() {
    const t2 = this._descriptor.context.gl, { unpackAlignment: e2, flipped: i, preMultiplyAlpha: r2 } = this._descriptor;
    t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, i ? 1 : 0), t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r2 ? 1 : 0);
  }
  _texStorage(e2, i, r2, s3, o3, a3) {
    const { gl: n3 } = this._descriptor.context;
    if (!g(i)) throw new s("Immutable textures must have a sized internal format");
    if (!this._descriptor.isImmutable) return;
    const l2 = r2 ? R(e2, s3, o3, a3) : 1;
    if (f(e2)) {
      if (null == a3) throw new s("Missing depth dimension for 3D texture upload");
      n3.texStorage3D(e2, l2, i, s3, o3, a3);
    } else n3.texStorage2D(e2, l2, i, s3, o3);
    this._wasImmutablyAllocated = true;
  }
  _texImage(e2, i, r2, s3, o3, a3, n3) {
    const l2 = this._descriptor.context.gl, h = f(e2), { isImmutable: p2, pixelFormat: d, dataType: _2 } = this._descriptor;
    if (p2) {
      if (null != n3) {
        const r3 = n3;
        if (h) {
          if (null == a3) throw new s("Missing depth dimension for 3D texture upload");
          l2.texSubImage3D(e2, i, 0, 0, 0, s3, o3, a3, d, _2, r3);
        } else l2.texSubImage2D(e2, i, 0, 0, s3, o3, d, _2, r3);
      }
    } else {
      const p3 = n3;
      if (h) {
        if (null == a3) throw new s("Missing depth dimension for 3D texture upload");
        l2.texImage3D(e2, i, r2, s3, o3, a3, 0, d, _2, p3);
      } else l2.texImage2D(e2, i, r2, s3, o3, 0, d, _2, p3);
    }
  }
  _compressedTexImage(e2, i, r2, s3, o3, a3, n3) {
    const l2 = this._descriptor.context.gl, h = f(e2);
    if (this._descriptor.isImmutable) {
      if (null != n3) if (h) {
        if (null == a3) throw new s("Missing depth dimension for 3D texture upload");
        l2.compressedTexSubImage3D(e2, i, 0, 0, 0, s3, o3, a3, r2, n3);
      } else l2.compressedTexSubImage2D(e2, i, 0, 0, s3, o3, r2, n3);
    } else if (h) {
      if (null == a3) throw new s("Missing depth dimension for 3D texture upload");
      l2.compressedTexImage3D(e2, i, r2, s3, o3, a3, 0, n3);
    } else l2.compressedTexImage2D(e2, i, r2, s3, o3, 0, n3);
  }
  _forEachMipmapLevel(e2, r2 = 1 / 0) {
    let { width: s3, height: o3, depth: a3, hasMipmap: n3, target: l2 } = this._descriptor;
    const h = l2 === M.TEXTURE_3D;
    if (null == s3 || null == o3 || h && null == a3) throw new s("Missing texture dimensions for mipmap calculation");
    for (let t2 = 0; e2(t2, s3, o3, a3), n3 && (1 !== s3 || 1 !== o3 || h && 1 !== a3) && !(t2 >= r2); ++t2) s3 = Math.max(1, s3 >> 1), o3 = Math.max(1, o3 >> 1), h && (a3 = Math.max(1, a3 >> 1));
  }
};
function c3(t2) {
  (null != t2.width && t2.width < 0 || null != t2.height && t2.height < 0 || null != t2.depth && t2.depth < 0) && console.error("Negative dimension parameters are not allowed!");
}
function u3(t2, e2) {
  let i = e2.samplingMode, r2 = e2.samplingMode;
  i === L.LINEAR_MIPMAP_NEAREST || i === L.LINEAR_MIPMAP_LINEAR ? (i = L.LINEAR, e2.hasMipmap || (r2 = L.LINEAR)) : i !== L.NEAREST_MIPMAP_NEAREST && i !== L.NEAREST_MIPMAP_LINEAR || (i = L.NEAREST, e2.hasMipmap || (r2 = L.NEAREST)), t2.texParameteri(e2.target, t2.TEXTURE_MAG_FILTER, i), t2.texParameteri(e2.target, t2.TEXTURE_MIN_FILTER, r2);
}
function T(t2, e2) {
  "number" == typeof e2.wrapMode ? (t2.texParameteri(e2.target, t2.TEXTURE_WRAP_S, e2.wrapMode), t2.texParameteri(e2.target, t2.TEXTURE_WRAP_T, e2.wrapMode)) : (t2.texParameteri(e2.target, t2.TEXTURE_WRAP_S, e2.wrapMode.s), t2.texParameteri(e2.target, t2.TEXTURE_WRAP_T, e2.wrapMode.t));
}
function E2(t2, e2) {
  const i = t2.capabilities.textureFilterAnisotropic;
  if (!i) return;
  t2.gl.texParameterf(e2.target, i.TEXTURE_MAX_ANISOTROPY, e2.maxAnisotropy ?? 1);
}
function g(t2) {
  return t2 in P;
}
function x(t2) {
  return t2 in c;
}
function M2(t2) {
  return null != t2 && "type" in t2 && "compressed" === t2.type;
}
function A2(t2) {
  return null != t2 && "byteLength" in t2;
}
function I(t2) {
  return null != t2 && !M2(t2) && !A2(t2);
}
function f(t2) {
  return t2 === M.TEXTURE_3D || t2 === M.TEXTURE_2D_ARRAY;
}
function R(t2, e2, r2, s3 = 1) {
  let o3 = Math.max(e2, r2);
  return t2 === M.TEXTURE_3D && (o3 = Math.max(o3, s3)), Math.round(Math.log(o3) / Math.LN2) + 1;
}
m.TEXTURE_UNIT_FOR_UPDATES = 0;

export {
  a,
  c2 as c,
  u,
  e,
  s2 as s,
  o2 as o,
  E,
  _,
  u2,
  p,
  a2,
  m
};
//# sourceMappingURL=chunk-QJXYURT2.js.map
