import {
  a as a3,
  c as c2,
  i
} from "./chunk-QRJFHPMB.js";
import {
  u
} from "./chunk-Z2DWZ5IF.js";
import {
  M,
  f,
  j2 as j,
  n,
  p,
  w
} from "./chunk-A3J7W53Y.js";
import {
  g,
  r as r2
} from "./chunk-L6D73M4D.js";
import {
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a2
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a
} from "./chunk-PKLD5YJF.js";
import {
  c
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/geometry/support/zmUtils.js
function h(h6, a6, s4 = false) {
  let { hasM: t4, hasZ: e3 } = h6;
  Array.isArray(a6) ? 4 !== a6.length || t4 || e3 ? 3 === a6.length && s4 && !t4 ? (e3 = true, t4 = false) : 3 === a6.length && t4 && e3 && (t4 = false, e3 = false) : (t4 = true, e3 = true) : (e3 = !e3 && a6.hasZ && (!t4 || a6.hasM), t4 = !t4 && a6.hasM && (!e3 || a6.hasZ)), h6.hasZ = e3, h6.hasM = t4;
}

// node_modules/@arcgis/core/geometry/Multipoint.js
var h2;
function l(t4) {
  return (s4, e3) => null == s4 ? e3 : null == e3 ? s4 : t4(s4, e3);
}
function c3(t4) {
  return t4 && ("esri.geometry.SpatialReference" === t4.declaredClass || null != t4.wkid);
}
var m2 = h2 = class extends n {
  constructor(...t4) {
    super(...t4), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t4, s4) {
    var _a;
    if (!t4 && !s4) return {};
    const e3 = {};
    Array.isArray(t4) ? (e3.points = t4, e3.spatialReference = s4) : c3(t4) ? e3.spatialReference = t4 : (t4.points && (e3.points = t4.points), t4.spatialReference && (e3.spatialReference = t4.spatialReference), t4.hasZ && (e3.hasZ = t4.hasZ), t4.hasM && (e3.hasM = t4.hasM));
    const i4 = (_a = e3.points) == null ? void 0 : _a[0];
    return i4 && (void 0 === e3.hasZ && void 0 === e3.hasM ? (e3.hasZ = i4.length > 2, e3.hasM = false) : void 0 === e3.hasZ ? e3.hasZ = i4.length > 3 : void 0 === e3.hasM && (e3.hasM = i4.length > 3)), e3;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t4 = this.points;
    if (!t4.length) return null;
    const s4 = new w(), e3 = this.hasZ, i4 = this.hasM, r6 = e3 ? 3 : 2, n3 = t4[0], a6 = l(Math.min), p2 = l(Math.max);
    let h6, c8, m6, u7, [f6, y3] = n3, [d4, g3] = n3;
    for (let o4 = 0, l5 = t4.length; o4 < l5; o4++) {
      const s5 = t4[o4], [n4, l6] = s5;
      if (f6 = a6(f6, n4), y3 = a6(y3, l6), d4 = p2(d4, n4), g3 = p2(g3, l6), e3 && s5.length > 2) {
        const t5 = s5[2];
        h6 = a6(h6, t5), m6 = p2(m6, t5);
      }
      if (i4 && s5.length > r6) {
        const t5 = s5[r6];
        c8 = a6(c8, t5), u7 = p2(u7, t5);
      }
    }
    return s4.xmin = f6, s4.ymin = y3, s4.xmax = d4, s4.ymax = g3, s4.spatialReference = this.spatialReference, e3 ? (s4.zmin = h6, s4.zmax = m6) : (s4.zmin = void 0, s4.zmax = void 0), i4 ? (s4.mmin = c8, s4.mmax = u7) : (s4.mmin = void 0, s4.mmax = void 0), s4;
  }
  writePoints(t4, e3) {
    e3.points = a(this.points);
  }
  addPoint(t4) {
    return h(this, t4), Array.isArray(t4) ? this.points.push(t4) : this.points.push(t4.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t4 = { points: a(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t4.hasZ = true), this.hasM && (t4.hasM = true), new h2(t4);
  }
  getPoint(t4) {
    if (!this._validateInputs(t4)) return null;
    const s4 = this.points[t4], e3 = { x: s4[0], y: s4[1], spatialReference: this.spatialReference };
    let i4 = 2;
    return this.hasZ && (e3.z = s4[2], i4 = 3), this.hasM && (e3.m = s4[i4]), new j(e3);
  }
  removePoint(t4) {
    if (!this._validateInputs(t4)) return null;
    const s4 = new j(this.points.splice(t4, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s4;
  }
  setPoint(t4, s4) {
    return this._validateInputs(t4) ? (h(this, s4), Array.isArray(s4) || (s4 = s4.toArray()), this.points[t4] = s4, this.notifyChange("points"), this) : this;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
  _validateInputs(t4) {
    return null != t4 && t4 >= 0 && t4 < this.points.length;
  }
};
r([m({ readOnly: true })], m2.prototype, "cache", null), r([m()], m2.prototype, "extent", null), r([m({ type: [[Number]], json: { write: { isRequired: true } } })], m2.prototype, "points", void 0), r([r2("points")], m2.prototype, "writePoints", null), m2 = h2 = r([a2("esri.geometry.Multipoint")], m2), m2.prototype.toJSON.isDefaultToJSON = true;
var u2 = m2;

// node_modules/@arcgis/core/geometry/geometryCursorCollectUtils.js
function t(t4) {
  const n3 = [];
  for (t4.reset(); t4.nextPath(); ) {
    const e3 = [];
    for (; t4.nextPoint(); ) e3.push([t4.x, t4.y]);
    n3.push(e3);
  }
  return t4.reset(), n3;
}
function n2(t4) {
  const n3 = [];
  for (; t4.nextPoint(); ) n3.push([t4.x, t4.y]);
  return t4.seekPathStart(), n3;
}

// node_modules/@arcgis/core/geometry/support/centroid.js
function r3(t4) {
  return t4 ? t4.hasZ ? [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2, t4.zmax - t4.zmin / 2] : [t4.xmax - t4.xmin / 2, t4.ymax - t4.ymin / 2] : null;
}
function l2(t4) {
  return t4 ? o(t4.rings, t4.hasZ ?? false) : null;
}
function o(t4, n3) {
  if (!(t4 == null ? void 0 : t4.length)) return null;
  const e3 = [], r6 = [], l5 = n3 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o4 = 0, i4 = t4.length; o4 < i4; o4++) {
    const e4 = u3(t4[o4], n3, l5);
    e4 && r6.push(e4);
  }
  if (r6.sort((t5, e4) => {
    let r7 = t5[2] - e4[2];
    return 0 === r7 && n3 && (r7 = t5[4] - e4[4]), r7;
  }), r6.length && (e3[0] = r6[0][0], e3[1] = r6[0][1], n3 && (e3[2] = r6[0][3]), (e3[0] < l5[0] || e3[0] > l5[1] || e3[1] < l5[2] || e3[1] > l5[3] || n3 && (e3[2] < l5[4] || e3[2] > l5[5])) && (e3.length = 0)), !e3.length) {
    const r7 = t4[0] && t4[0].length ? s(t4[0], n3) : null;
    if (!r7) return null;
    e3[0] = r7[0], e3[1] = r7[1], n3 && r7.length > 2 && (e3[2] = r7[2]);
  }
  return e3;
}
function u3(t4, n3, e3) {
  let r6 = 0, l5 = 0, o4 = 0, u7 = 0, i4 = 0;
  const s4 = t4.length ? t4[0][0] : 0, I2 = t4.length ? t4[0][1] : 0, h6 = t4.length && n3 ? t4[0][2] : 0;
  for (let f6 = 0; f6 < t4.length; f6++) {
    const c9 = t4[f6], N2 = t4[(f6 + 1) % t4.length], [x5, g3, a6] = c9, m6 = x5 - s4, P = g3 - I2, [T, y3, E] = N2, S = T - s4, p2 = y3 - I2, z = m6 * p2 - S * P;
    if (u7 += z, r6 += (m6 + S) * z, l5 += (P + p2) * z, n3 && c9.length > 2 && N2.length > 2) {
      const t5 = a6 - h6, n4 = E - h6, e4 = m6 * n4 - S * t5;
      o4 += (t5 + n4) * e4, i4 += e4;
    }
    x5 < e3[0] && (e3[0] = x5), x5 > e3[1] && (e3[1] = x5), g3 < e3[2] && (e3[2] = g3), g3 > e3[3] && (e3[3] = g3), n3 && (a6 < e3[4] && (e3[4] = a6), a6 > e3[5] && (e3[5] = a6));
  }
  if (u7 > 0 && (u7 *= -1), i4 > 0 && (i4 *= -1), !u7) return null;
  u7 *= 0.5, i4 *= 0.5;
  const c8 = [r6 / (6 * u7) + s4, l5 / (6 * u7) + I2, u7];
  return n3 && (e3[4] === e3[5] || 0 === i4 ? (c8[3] = (e3[4] + e3[5]) / 2, c8[4] = 0) : (c8[3] = o4 / (6 * i4) + h6, c8[4] = i4)), c8;
}
function i2(t4, n3) {
  let e3 = 0, r6 = 0, l5 = 0;
  t4.nextPoint();
  const o4 = t4.pathSize ? t4.x : 0, u7 = t4.pathSize ? t4.y : 0;
  for (let i4 = 0; i4 < t4.pathSize; i4++) {
    t4.seekInPath(i4);
    const s4 = [t4.x, t4.y];
    t4.seekInPath((i4 + 1) % t4.pathSize);
    const I2 = [t4.x, t4.y], [h6, c8] = s4, f6 = h6 - o4, N2 = c8 - u7, [x5, g3] = I2, a6 = x5 - o4, m6 = g3 - u7, P = f6 * m6 - a6 * N2;
    l5 += P, e3 += (f6 + a6) * P, r6 += (N2 + m6) * P, h6 < n3[0] && (n3[0] = h6), h6 > n3[1] && (n3[1] = h6), c8 < n3[2] && (n3[2] = c8), c8 > n3[3] && (n3[3] = c8);
  }
  if (l5 > 0 && (l5 *= -1), !l5) return null;
  l5 *= 0.5;
  return [e3 / (6 * l5) + o4, r6 / (6 * l5) + u7, l5];
}
function s(t4, r6) {
  const l5 = r6 ? [0, 0, 0] : [0, 0], o4 = r6 ? [0, 0, 0] : [0, 0];
  let u7 = 0, i4 = 0, s4 = 0, I2 = 0;
  for (let h6 = 0, c8 = t4.length; h6 < c8 - 1; h6++) {
    const c9 = t4[h6], f6 = t4[h6 + 1];
    if (c9 && f6) {
      l5[0] = c9[0], l5[1] = c9[1], o4[0] = f6[0], o4[1] = f6[1], r6 && c9.length > 2 && f6.length > 2 && (l5[2] = c9[2], o4[2] = f6[2]);
      const t5 = i(l5, o4);
      if (t5) {
        u7 += t5;
        const n3 = c2(c9, f6);
        i4 += t5 * n3[0], s4 += t5 * n3[1], r6 && n3.length > 2 && (I2 += t5 * n3[2]);
      }
    }
  }
  return u7 > 0 ? r6 ? [i4 / u7, s4 / u7, I2 / u7] : [i4 / u7, s4 / u7] : t4.length ? t4[0] : null;
}
function I(n3) {
  const { hasZ: e3, totalSize: r6 } = n3;
  if (0 === r6) return null;
  const l5 = [], o4 = [], i4 = e3 ? [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY] : [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
  for (n3.reset(); n3.nextPath(); ) {
    const e4 = u3(n2(n3), n3.hasZ, i4);
    e4 && o4.push(e4);
  }
  if (o4.sort((t4, n4) => {
    let r7 = t4[2] - n4[2];
    return 0 === r7 && e3 && (r7 = t4[4] - n4[4]), r7;
  }), o4.length && (l5[0] = o4[0][0], l5[1] = o4[0][1], e3 && (l5[2] = o4[0][3]), (l5[0] < i4[0] || l5[0] > i4[1] || l5[1] < i4[2] || l5[1] > i4[3] || e3 && (l5[2] < i4[4] || l5[2] > i4[5])) && (l5.length = 0)), !l5.length) {
    n3.reset(), n3.nextPath();
    const t4 = n3.pathSize ? h3(n3) : null;
    if (!t4) return null;
    l5[0] = t4[0], l5[1] = t4[1], e3 && t4.length > 2 && (l5[2] = t4[2]);
  }
  return l5;
}
function h3(t4) {
  const { hasZ: r6 } = t4, l5 = r6 ? [0, 0, 0] : [0, 0], o4 = r6 ? [0, 0, 0] : [0, 0];
  let u7 = 0, i4 = 0, s4 = 0, I2 = 0;
  if (t4.nextPoint()) {
    let h6 = t4.x, c8 = t4.y, f6 = t4.z;
    for (; t4.nextPoint(); ) {
      const N2 = t4.x, x5 = t4.y, g3 = t4.z;
      l5[0] = h6, l5[1] = c8, o4[0] = N2, o4[1] = x5, r6 && (l5[2] = f6, o4[2] = g3);
      const a6 = i(l5, o4);
      if (a6) {
        u7 += a6;
        const t5 = c2(l5, o4);
        i4 += a6 * t5[0], s4 += a6 * t5[1], r6 && t5.length > 2 && (I2 += a6 * t5[2]);
      }
      h6 = N2, c8 = x5, f6 = g3;
    }
  }
  return u7 > 0 ? r6 ? [i4 / u7, s4 / u7, I2 / u7] : [i4 / u7, s4 / u7] : t4.pathSize ? (t4.seekPathStart(), t4.nextPoint(), [t4.x, t4.y]) : null;
}
var c4 = 1e-6;
function f2(t4) {
  let n3 = 0;
  for (t4.reset(); t4.nextPath(); ) n3 += t4.getCurrentRingArea();
  if (n3 < c4) {
    const n4 = I(t4);
    return n4 ? [n4[0], n4[1]] : null;
  }
  const e3 = [0, 0];
  if (t4.reset(), !t4.nextPath() || !t4.nextPoint()) return null;
  const r6 = [t4.x, t4.y];
  for (t4.reset(); t4.nextPath(); ) x(e3, r6, t4);
  return e3[0] *= 1 / n3, e3[1] *= 1 / n3, e3[0] += r6[0], e3[1] += r6[1], e3;
}
var N = 1 / 3;
function x(t4, n3, e3) {
  if (!t4 || !e3 || e3.pathSize < 3) return null;
  e3.nextPoint();
  const r6 = e3.x, l5 = e3.y;
  e3.nextPoint();
  let o4, u7 = e3.x - r6, i4 = e3.y - l5, s4 = 0, I2 = 0;
  for (; e3.nextPoint(); ) s4 = e3.x - r6, I2 = e3.y - l5, o4 = 0.5 * N * (s4 * i4 - I2 * u7), t4[0] += o4 * (u7 + s4), t4[1] += o4 * (i4 + I2), u7 = s4, i4 = I2;
  const h6 = e3.getCurrentRingArea(), c8 = [r6, l5];
  return c8[0] -= n3[0], c8[1] -= n3[1], c8[0] *= h6, c8[1] *= h6, t4[0] += c8[0], t4[1] += c8[1], t4;
}

// node_modules/@arcgis/core/geometry/support/boundsUtils.js
function t2(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function i3(n3) {
  return void 0 !== n3.points;
}
function o2(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function e(n3) {
  return void 0 !== n3.paths;
}
function r4(n3) {
  return void 0 !== n3.rings;
}
function u4(n3) {
  function t4(t5, i4) {
    return null == t5 ? i4 : null == i4 ? t5 : n3(t5, i4);
  }
  return t4;
}
var l3 = u4(Math.min);
var h4 = u4(Math.max);
function a4(n3, u7) {
  return e(u7) ? x2(n3, u7.paths, false, false) : r4(u7) ? x2(n3, u7.rings, false, false) : i3(u7) ? g2(n3, u7.points, false, false, false, false) : t2(u7) ? s2(n3, u7) : (o2(u7) && (n3[0] = u7.x, n3[1] = u7.y, n3[2] = u7.x, n3[3] = u7.y), n3);
}
function c5(t4) {
  let i4, o4, e3, r6;
  for (t4.reset(), i4 = e3 = 1 / 0, o4 = r6 = -1 / 0; t4.nextPath(); ) {
    const n3 = f3(t4);
    i4 = Math.min(n3[0], i4), e3 = Math.min(n3[1], e3), o4 = Math.max(n3[2], o4), r6 = Math.max(n3[3], r6);
  }
  return u([i4, e3, o4, r6]);
}
function f3(t4) {
  let i4, o4, e3, r6;
  for (i4 = e3 = 1 / 0, o4 = r6 = -1 / 0; t4.nextPoint(); ) i4 = Math.min(t4.x, i4), e3 = Math.min(t4.y, e3), o4 = Math.max(t4.x, o4), r6 = Math.max(t4.y, r6);
  return u([i4, e3, o4, r6]);
}
function m3(n3, u7) {
  return e(u7) ? x2(n3, u7.paths, true, false) : r4(u7) ? x2(n3, u7.rings, true, false) : i3(u7) ? g2(n3, u7.points, true, false, true, false) : t2(u7) ? s2(n3, u7, true, false, true, false) : (o2(u7) && (n3[0] = u7.x, n3[1] = u7.y, n3[2] = u7.z, n3[3] = u7.x, n3[4] = u7.y, n3[5] = u7.z), n3);
}
function x2(n3, t4, i4, o4) {
  const e3 = i4 ? 3 : 2;
  if (!t4.length || !t4[0].length) return null;
  let r6, u7, a6, c8, [f6, m6] = t4[0][0], [x5, s4] = t4[0][0];
  for (let g3 = 0; g3 < t4.length; g3++) {
    const n4 = t4[g3];
    for (let t5 = 0; t5 < n4.length; t5++) {
      const g4 = n4[t5], [y3, d4] = g4;
      if (f6 = l3(f6, y3), m6 = l3(m6, d4), x5 = h4(x5, y3), s4 = h4(s4, d4), i4 && g4.length > 2) {
        const n5 = g4[2];
        r6 = l3(r6, n5), u7 = h4(u7, n5);
      }
      if (o4 && g4.length > e3) {
        const n5 = g4[e3];
        a6 = l3(r6, n5), c8 = h4(u7, n5);
      }
    }
  }
  return i4 ? o4 ? (n3[0] = f6, n3[1] = m6, n3[2] = r6, n3[3] = a6, n3[4] = x5, n3[5] = s4, n3[6] = u7, n3[7] = c8, n3.length = 8, n3) : (n3[0] = f6, n3[1] = m6, n3[2] = r6, n3[3] = x5, n3[4] = s4, n3[5] = u7, n3.length = 6, n3) : o4 ? (n3[0] = f6, n3[1] = m6, n3[2] = a6, n3[3] = x5, n3[4] = s4, n3[5] = c8, n3.length = 6, n3) : (n3[0] = f6, n3[1] = m6, n3[2] = x5, n3[3] = s4, n3.length = 4, n3);
}
function s2(n3, t4, i4, o4, e3, r6) {
  const u7 = t4.xmin, l5 = t4.xmax, h6 = t4.ymin, a6 = t4.ymax;
  let c8 = t4.zmin, f6 = t4.zmax, m6 = t4.mmin, x5 = t4.mmax;
  return e3 ? (c8 = c8 || 0, f6 = f6 || 0, r6 ? (m6 = m6 || 0, x5 = x5 || 0, n3[0] = u7, n3[1] = h6, n3[2] = c8, n3[3] = m6, n3[4] = l5, n3[5] = a6, n3[6] = f6, n3[7] = x5, n3) : (n3[0] = u7, n3[1] = h6, n3[2] = c8, n3[3] = l5, n3[4] = a6, n3[5] = f6, n3)) : r6 ? (m6 = m6 || 0, x5 = x5 || 0, n3[0] = u7, n3[1] = h6, n3[2] = m6, n3[3] = l5, n3[4] = a6, n3[5] = x5, n3) : (n3[0] = u7, n3[1] = h6, n3[2] = l5, n3[3] = a6, n3);
}
function g2(n3, t4, i4, o4, e3, r6) {
  const u7 = i4 ? 3 : 2, a6 = o4 && r6, c8 = i4 && e3;
  if (!t4.length || !t4[0].length) return null;
  let f6, m6, x5, s4, [g3, y3] = t4[0], [d4, M2] = t4[0];
  for (let v3 = 0; v3 < t4.length; v3++) {
    const n4 = t4[v3], [i5, o5] = n4;
    if (g3 = l3(g3, i5), y3 = l3(y3, o5), d4 = h4(d4, i5), M2 = h4(M2, o5), c8 && n4.length > 2) {
      const t5 = n4[2];
      f6 = l3(f6, t5), m6 = h4(m6, t5);
    }
    if (a6 && n4.length > u7) {
      const t5 = n4[u7];
      x5 = l3(f6, t5), s4 = h4(m6, t5);
    }
  }
  return e3 ? (f6 = f6 || 0, m6 = m6 || 0, r6 ? (x5 = x5 || 0, s4 = s4 || 0, n3[0] = g3, n3[1] = y3, n3[2] = f6, n3[3] = x5, n3[4] = d4, n3[5] = M2, n3[6] = m6, n3[7] = s4, n3) : (n3[0] = g3, n3[1] = y3, n3[2] = f6, n3[3] = d4, n3[4] = M2, n3[5] = m6, n3)) : r6 ? (x5 = x5 || 0, s4 = s4 || 0, n3[0] = g3, n3[1] = y3, n3[2] = x5, n3[3] = d4, n3[4] = M2, n3[5] = s4, n3) : (n3[0] = g3, n3[1] = y3, n3[2] = d4, n3[3] = M2, n3);
}

// node_modules/@arcgis/core/geometry/support/extentUtils.js
function t3(n3) {
  return void 0 !== n3.xmin && void 0 !== n3.ymin && void 0 !== n3.xmax && void 0 !== n3.ymax;
}
function u5(n3) {
  return void 0 !== n3.points;
}
function m4(n3) {
  return void 0 !== n3.x && void 0 !== n3.y;
}
function o3(n3) {
  return void 0 !== n3.paths;
}
function r5(n3) {
  return void 0 !== n3.rings;
}
var x3 = [];
function a5(n3, i4, t4, u7) {
  return { xmin: n3, ymin: i4, xmax: t4, ymax: u7 };
}
function c6(n3, i4, t4, u7, m6, o4) {
  return { xmin: n3, ymin: i4, zmin: t4, xmax: u7, ymax: m6, zmax: o4 };
}
function s3(n3, i4, t4, u7, m6, o4) {
  return { xmin: n3, ymin: i4, mmin: t4, xmax: u7, ymax: m6, mmax: o4 };
}
function e2(n3, i4, t4, u7, m6, o4, r6, x5) {
  return { xmin: n3, ymin: i4, zmin: t4, mmin: u7, xmax: m6, ymax: o4, zmax: r6, mmax: x5 };
}
function f4(n3, i4 = false, t4 = false) {
  return i4 ? t4 ? e2(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5], n3[6], n3[7]) : c6(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : t4 ? s3(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]) : a5(n3[0], n3[1], n3[2], n3[3]);
}
function l4(n3) {
  return n3 ? t3(n3) ? n3 : m4(n3) ? d(n3) : r5(n3) ? v(n3) : o3(n3) ? h5(n3) : u5(n3) ? y(n3) : null : null;
}
function y(i4) {
  const { hasZ: t4, hasM: u7, points: m6 } = i4;
  return f4(g2(x3, m6, t4 ?? false, u7 ?? false), t4, u7);
}
function d(n3) {
  const { x: i4, y: t4, z: u7, m: m6 } = n3, o4 = null != m6;
  return null != u7 ? o4 ? e2(i4, t4, u7, m6, i4, t4, u7, m6) : c6(i4, t4, u7, i4, t4, u7) : o4 ? s3(i4, t4, m6, i4, t4, m6) : a5(i4, t4, i4, t4);
}
function v(n3) {
  const { hasZ: t4, hasM: u7, rings: m6 } = n3, o4 = x2(x3, m6, t4 ?? false, u7 ?? false);
  return o4 ? f4(o4, t4, u7) : null;
}
function h5(n3) {
  const { hasZ: t4, hasM: u7, paths: m6 } = n3, o4 = x2(x3, m6, t4 ?? false, u7 ?? false);
  return o4 ? f4(o4, t4, u7) : null;
}

// node_modules/@arcgis/core/geometry/Polygon.js
var d2;
function R(t4) {
  return !Array.isArray(t4[0]);
}
function x4(t4) {
  var _a;
  return "number" == typeof ((_a = t4[0]) == null ? void 0 : _a[0]);
}
function j2(t4) {
  var _a, _b;
  if (!t4) return;
  let { rings: r6, hasM: e3, hasZ: s4, spatialReference: i4 } = t4;
  switch (r6 ?? (r6 = []), x4(r6) && (r6 = [r6]), (_b = (_a = r6[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) {
    case 4:
      s4 ?? (s4 = true), e3 ?? (e3 = true);
      break;
    case 3:
      s4 ?? (s4 = true !== e3), e3 ?? (e3 = !s4);
      break;
    default:
      s4 ?? (s4 = false), e3 ?? (e3 = false);
  }
  return i4 ?? (i4 = g.WGS84), { ...t4, hasM: e3, hasZ: s4, rings: r6, spatialReference: i4 };
}
var w2 = d2 = class extends n {
  static fromExtent(t4) {
    const r6 = t4.clone().normalize(), { spatialReference: e3 } = t4;
    let s4 = false, i4 = false;
    for (const o4 of r6) o4.hasZ && (s4 = true), o4.hasM && (i4 = true);
    const n3 = { rings: r6.map((t5) => {
      const r7 = [[t5.xmin, t5.ymin], [t5.xmin, t5.ymax], [t5.xmax, t5.ymax], [t5.xmax, t5.ymin], [t5.xmin, t5.ymin]];
      if (s4 && t5.hasZ) {
        const e4 = t5.zmin + 0.5 * (t5.zmax - t5.zmin);
        for (let t6 = 0; t6 < r7.length; t6++) r7[t6].push(e4);
      }
      if (i4 && t5.hasM) {
        const e4 = t5.mmin + 0.5 * (t5.mmax - t5.mmin);
        for (let t6 = 0; t6 < r7.length; t6++) r7[t6].push(e4);
      }
      return r7;
    }), spatialReference: e3 };
    return s4 && (n3.hasZ = true), i4 && (n3.hasM = true), new d2(n3);
  }
  constructor(t4) {
    super(j2(t4)), this.rings = [], this.type = "polygon";
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t4 = l2(this);
    if (!t4 || isNaN(t4[0]) || isNaN(t4[1]) || this.hasZ && isNaN(t4[2])) return null;
    const r6 = new j();
    return r6.x = t4[0], r6.y = t4[1], r6.spatialReference = this.spatialReference, this.hasZ && (r6.z = t4[2]), r6;
  }
  get extent() {
    const { spatialReference: t4 } = this, r6 = v(this);
    if (!r6) return null;
    const e3 = new w(r6);
    return e3.spatialReference = t4, e3;
  }
  get isSelfIntersecting() {
    return p(this.rings);
  }
  writeRings(t4, r6) {
    r6.rings = a(this.rings);
  }
  addRing(t4) {
    if (!t4) return;
    const r6 = this.rings, e3 = r6.length;
    if (R(t4)) {
      const s4 = [];
      for (let r7 = 0, e4 = t4.length; r7 < e4; r7++) s4[r7] = t4[r7].toArray();
      r6[e3] = s4;
    } else r6[e3] = t4.slice();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t4 = new d2();
    return t4.spatialReference = this.spatialReference, t4.rings = a(this.rings), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  equals(t4) {
    if (this === t4) return true;
    if (null == t4) return false;
    const e3 = this.spatialReference, s4 = t4.spatialReference;
    if (null != e3 != (null != s4)) return false;
    if (null != e3 && null != s4 && !e3.equals(s4)) return false;
    if (this.rings.length !== t4.rings.length) return false;
    const i4 = ([t5, r6, e4, s5], [i5, n3, o4, a6]) => t5 === i5 && r6 === n3 && (null == e4 && null == o4 || e4 === o4) && (null == s5 && null == a6 || s5 === a6);
    for (let n3 = 0; n3 < this.rings.length; n3++) {
      const e4 = this.rings[n3], s5 = t4.rings[n3];
      if (!c(e4, s5, i4)) return false;
    }
    return true;
  }
  contains(t4) {
    if (!t4) return false;
    const r6 = M(t4, this.spatialReference);
    return f(this, null != r6 ? r6 : t4);
  }
  isClockwise(t4) {
    const r6 = R(t4) ? t4.map((t5) => this.hasZ ? this.hasM ? [t5.x, t5.y, t5.z, t5.m] : [t5.x, t5.y, t5.z] : [t5.x, t5.y]) : t4;
    return a3(r6);
  }
  getPoint(t4, r6) {
    if (!this._validateInputs(t4, r6)) return null;
    const e3 = this.rings[t4][r6], s4 = this.hasZ, i4 = this.hasM;
    return s4 && !i4 ? new j(e3[0], e3[1], e3[2], void 0, this.spatialReference) : i4 && !s4 ? new j(e3[0], e3[1], void 0, e3[2], this.spatialReference) : s4 && i4 ? new j(e3[0], e3[1], e3[2], e3[3], this.spatialReference) : new j(e3[0], e3[1], this.spatialReference);
  }
  insertPoint(t4, r6, e3) {
    return this._validateInputs(t4, r6, true) ? (h(this, e3), Array.isArray(e3) || (e3 = e3.toArray()), this.rings[t4].splice(r6, 0, e3), this.notifyChange("rings"), this) : this;
  }
  removePoint(t4, r6) {
    if (!this._validateInputs(t4, r6)) return null;
    const e3 = new j(this.rings[t4].splice(r6, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e3;
  }
  removeRing(t4) {
    if (!this._validateInputs(t4, null)) return null;
    const r6 = this.rings.splice(t4, 1)[0], e3 = this.spatialReference, s4 = r6.map((t5) => new j(t5, e3));
    return this.notifyChange("rings"), s4;
  }
  setPoint(t4, r6, e3) {
    return this._validateInputs(t4, r6) ? (h(this, e3), Array.isArray(e3) || (e3 = e3.toArray()), this.rings[t4][r6] = e3, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t4, r6, e3 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.rings.length) return false;
    if (null != r6) {
      const s4 = this.rings[t4];
      if (e3 && (r6 < 0 || r6 > s4.length)) return false;
      if (!e3 && (r6 < 0 || r6 >= s4.length)) return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
r([m({ readOnly: true })], w2.prototype, "cache", null), r([m({ readOnly: true })], w2.prototype, "centroid", null), r([m({ readOnly: true })], w2.prototype, "extent", null), r([m({ readOnly: true })], w2.prototype, "isSelfIntersecting", null), r([m({ type: [[[Number]]], json: { write: { isRequired: true } } })], w2.prototype, "rings", void 0), r([r2("rings")], w2.prototype, "writeRings", null), w2 = d2 = r([a2("esri.geometry.Polygon")], w2);
var v2 = w2;
w2.prototype.toJSON.isDefaultToJSON = true;

// node_modules/@arcgis/core/geometry/Polyline.js
var c7;
function u6(t4) {
  return !Array.isArray(t4[0]);
}
function f5(t4) {
  var _a;
  return "number" == typeof ((_a = t4[0]) == null ? void 0 : _a[0]);
}
function m5(t4) {
  var _a, _b;
  if (!t4) return;
  let { paths: e3, hasM: s4, hasZ: r6, spatialReference: i4 } = t4;
  switch (e3 ?? (e3 = []), f5(e3) && (e3 = [e3]), (_b = (_a = e3[0]) == null ? void 0 : _a[0]) == null ? void 0 : _b.length) {
    case 4:
      r6 ?? (r6 = true), s4 ?? (s4 = true);
      break;
    case 3:
      r6 ?? (r6 = true !== s4), s4 ?? (s4 = !r6);
      break;
    default:
      r6 ?? (r6 = false), s4 ?? (s4 = false);
  }
  return i4 ?? (i4 = g.WGS84), { ...t4, hasM: s4, hasZ: r6, paths: e3, spatialReference: i4 };
}
var y2 = c7 = class extends n {
  constructor(t4) {
    super(m5(t4)), this.paths = [], this.type = "polyline";
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t4 } = this, e3 = h5(this);
    if (!e3) return null;
    const s4 = new w(e3);
    return s4.spatialReference = t4, s4;
  }
  writePaths(t4, s4) {
    s4.paths = a(this.paths);
  }
  addPath(t4) {
    if (!t4) return;
    const e3 = this.paths, s4 = e3.length;
    if (u6(t4)) {
      const r6 = [];
      for (let e4 = 0, s5 = t4.length; e4 < s5; e4++) r6[e4] = t4[e4].toArray();
      e3[s4] = r6;
    } else e3[s4] = t4.slice();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t4 = new c7();
    return t4.spatialReference = this.spatialReference, t4.paths = a(this.paths), t4.hasZ = this.hasZ, t4.hasM = this.hasM, t4;
  }
  getPoint(t4, e3) {
    if (!this._validateInputs(t4, e3)) return null;
    const s4 = this.paths[t4][e3], r6 = this.hasZ, i4 = this.hasM;
    return r6 && !i4 ? new j(s4[0], s4[1], s4[2], void 0, this.spatialReference) : i4 && !r6 ? new j(s4[0], s4[1], void 0, s4[2], this.spatialReference) : r6 && i4 ? new j(s4[0], s4[1], s4[2], s4[3], this.spatialReference) : new j(s4[0], s4[1], this.spatialReference);
  }
  insertPoint(t4, e3, s4) {
    return this._validateInputs(t4, e3, true) ? (h(this, s4), Array.isArray(s4) || (s4 = s4.toArray()), this.paths[t4].splice(e3, 0, s4), this.notifyChange("paths"), this) : this;
  }
  removePath(t4) {
    if (!this._validateInputs(t4, null)) return null;
    const e3 = this.paths.splice(t4, 1)[0], s4 = this.spatialReference, r6 = e3.map((t5) => new j(t5, s4));
    return this.notifyChange("paths"), r6;
  }
  removePoint(t4, e3) {
    if (!this._validateInputs(t4, e3)) return null;
    const s4 = new j(this.paths[t4].splice(e3, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s4;
  }
  setPoint(t4, e3, s4) {
    return this._validateInputs(t4, e3) ? (h(this, s4), Array.isArray(s4) || (s4 = s4.toArray()), this.paths[t4][e3] = s4, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t4, e3, s4 = false) {
    if (null == t4 || t4 < 0 || t4 >= this.paths.length) return false;
    if (null != e3) {
      const r6 = this.paths[t4];
      if (s4 && (e3 < 0 || e3 > r6.length)) return false;
      if (!s4 && (e3 < 0 || e3 >= r6.length)) return false;
    }
    return true;
  }
  toJSON(t4) {
    return this.write({}, t4);
  }
};
r([m({ readOnly: true })], y2.prototype, "cache", null), r([m({ readOnly: true })], y2.prototype, "extent", null), r([m({ type: [[[Number]]], json: { write: { isRequired: true } } })], y2.prototype, "paths", void 0), r([r2("paths")], y2.prototype, "writePaths", null), y2 = c7 = r([a2("esri.geometry.Polyline")], y2);
var d3 = y2;
y2.prototype.toJSON.isDefaultToJSON = true;

export {
  u2 as u,
  t,
  n2 as n,
  r3 as r,
  l2 as l,
  o,
  i2 as i,
  f2 as f,
  a4 as a,
  c5 as c,
  f3 as f2,
  m3 as m,
  l4 as l2,
  v,
  v2,
  d3 as d
};
//# sourceMappingURL=chunk-VNRDIGVF.js.map
