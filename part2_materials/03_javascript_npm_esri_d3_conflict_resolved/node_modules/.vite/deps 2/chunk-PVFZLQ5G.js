import {
  s as s2
} from "./chunk-C2RS46RL.js";
import {
  a as a2
} from "./chunk-JQJITHTO.js";
import {
  o as o2
} from "./chunk-6LGJYARD.js";
import {
  a
} from "./chunk-N42IF4WX.js";
import {
  n as n2
} from "./chunk-ECMDQ4LS.js";
import {
  o
} from "./chunk-LP6TMAPE.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js
var s3 = class extends a2 {
  constructor(r, s5) {
    super(r, "sampler2D", a.Pass, (e2, o4, t) => e2.bindTexture(r, s5(o4, t)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Float2PassUniform.js
var e = class extends a2 {
  constructor(r, e2) {
    super(r, "vec2", a.Pass, (s5, o4, t) => s5.setUniform2fv(r, e2(o4, t)));
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/ReadDepth.glsl.js
function a3(e2) {
  e2.uniforms.add(new e("zProjectionMap", (e3, t) => c(t.camera))), e2.code.add(o2`float linearizeDepth(float depth) {
float depthNdc = depth * 2.0 - 1.0;
float c1 = zProjectionMap[0];
float c2 = zProjectionMap[1];
return -(c1 / (depthNdc + c2 + 1e-7));
}`), e2.code.add(o2`float depthFromTexture(sampler2D depthTexture, vec2 uv) {
ivec2 iuv = ivec2(uv * vec2(textureSize(depthTexture, 0)));
float depth = texelFetch(depthTexture, iuv, 0).r;
return depth;
}`), e2.code.add(o2`float linearDepthFromTexture(sampler2D depthTexture, vec2 uv) {
return linearizeDepth(depthFromTexture(depthTexture, uv));
}`);
}
function c(t) {
  const r = t.projectionMatrix;
  return o(d, r[14], r[10]);
}
var d = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js
var s4 = () => n.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");
var i = class {
  constructor() {
    this._includedModules = /* @__PURE__ */ new Map();
  }
  include(e2, t) {
    this._includedModules.has(e2) ? this._includedModules.get(e2) : (this._includedModules.set(e2, t), e2(this.builder, t));
  }
};
var o3 = class extends i {
  constructor() {
    super(...arguments), this.vertex = new h(), this.fragment = new h(), this.attributes = new m(), this.varyings = new _(), this.extensions = new d2(), this.outputs = new l();
  }
  get fragmentUniforms() {
    return this.fragment.uniforms.entries;
  }
  get builder() {
    return this;
  }
  generate(e2) {
    const t = this.extensions.generateSource(e2), r = this.attributes.generateSource(e2), n3 = this.varyings.generateSource(e2), s5 = "vertex" === e2 ? this.vertex : this.fragment, i2 = s5.uniforms.generateSource(), o4 = s5.code.generateSource(), a5 = s5.main.generateSource(), u2 = "vertex" === e2 ? S : f, c3 = s5.constants.generateSource(), h2 = this.outputs.generateSource(e2);
    return `#version 300 es
${t.join("\n")}

${u2}

${c3.join("\n")}

${i2.join("\n")}

${r.join("\n")}

${n3.join("\n")}

${h2.join("\n")}

${o4.join("\n")}

${a5.join("\n")}`;
  }
  generateBindPass(e2) {
    const t = /* @__PURE__ */ new Map();
    this.vertex.uniforms.entries.forEach((e3) => {
      const n4 = e3.bind[a.Pass];
      n4 && t.set(e3.name, n4);
    }), this.fragment.uniforms.entries.forEach((e3) => {
      const n4 = e3.bind[a.Pass];
      n4 && t.set(e3.name, n4);
    });
    const n3 = Array.from(t.values()), s5 = n3.length;
    return (t2, r) => {
      for (let i2 = 0; i2 < s5; ++i2) n3[i2](e2, t2, r);
    };
  }
  generateBindDraw(e2) {
    const t = /* @__PURE__ */ new Map();
    this.vertex.uniforms.entries.forEach((e3) => {
      const n4 = e3.bind[a.Draw];
      n4 && t.set(e3.name, n4);
    }), this.fragment.uniforms.entries.forEach((e3) => {
      const n4 = e3.bind[a.Draw];
      n4 && t.set(e3.name, n4);
    });
    const n3 = Array.from(t.values()), s5 = n3.length;
    return (t2, r, i2) => {
      for (let o4 = 0; o4 < s5; ++o4) n3[o4](e2, i2, t2, r);
    };
  }
};
var a4 = class {
  constructor(e2) {
    this._stage = e2, this._entries = /* @__PURE__ */ new Map();
  }
  add(...e2) {
    for (const t of e2) this._add(t);
    return this._stage;
  }
  get(e2) {
    return this._entries.get(e2);
  }
  _add(t) {
    if (null != t) {
      if (this._entries.has(t.name) && !this._entries.get(t.name).equals(t)) throw new s(`Duplicate uniform name ${t.name} for different uniform type`);
      this._entries.set(t.name, t);
    } else s4().error(`Trying to add null Uniform from ${new Error().stack}.`);
  }
  generateSource() {
    return Array.from(this._entries.values()).map((e2) => null != e2.arraySize ? `uniform ${e2.type} ${e2.name}[${e2.arraySize}];` : `uniform ${e2.type} ${e2.name};`);
  }
  get entries() {
    return Array.from(this._entries.values());
  }
};
var u = class {
  constructor(e2) {
    this._stage = e2, this._bodies = new Array();
  }
  add(e2) {
    return this._bodies.push(e2), this._stage;
  }
  generateSource() {
    if (this._bodies.length > 0) return [`void main() {
 ${this._bodies.join("\n") || ""} 
}`];
    throw new s("Shader does not contain main function body.");
  }
};
var c2 = class {
  constructor(e2) {
    this._stage = e2, this._entries = new Array();
  }
  add(e2) {
    return this._entries.push(e2), this._stage;
  }
  generateSource() {
    return this._entries;
  }
};
var h = class extends i {
  constructor() {
    super(...arguments), this.uniforms = new a4(this), this.main = new u(this), this.code = new c2(this), this.constants = new g(this);
  }
  get builder() {
    return this;
  }
};
var m = class {
  constructor() {
    this._entries = new Array();
  }
  add(e2, t) {
    this._entries.push([e2, t]);
  }
  generateSource(e2) {
    return "fragment" === e2 ? [] : this._entries.map((e3) => `in ${e3[1]} ${e3[0]};`);
  }
};
var _ = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(e2, t) {
    this._entries.has(e2) && s2(this._entries.get(e2) === t), this._entries.set(e2, t);
  }
  generateSource(e2) {
    const t = new Array();
    return this._entries.forEach((r, n3) => t.push("vertex" === e2 ? `out ${r} ${n3};` : `in ${r} ${n3};`)), t;
  }
};
var d2 = class _d {
  constructor() {
    this._entries = /* @__PURE__ */ new Set();
  }
  add(e2) {
    this._entries.add(e2);
  }
  generateSource(e2) {
    const t = "vertex" === e2 ? _d.ALLOWLIST_VERTEX : _d.ALLOWLIST_FRAGMENT;
    return Array.from(this._entries).filter((e3) => t.includes(e3)).map((e3) => `#extension ${e3} : enable`);
  }
};
d2.ALLOWLIST_FRAGMENT = ["GL_EXT_shader_texture_lod", "GL_OES_standard_derivatives"], d2.ALLOWLIST_VERTEX = [];
var l = class _l {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  add(e2, t, r = 0) {
    const s5 = this._entries.get(r);
    s5 ? s2(s5.name === e2 && s5.type === t, `Fragment shader output location ${r} occupied`) : this._entries.set(r, { name: e2, type: t });
  }
  generateSource(e2) {
    if ("vertex" === e2) return [];
    0 === this._entries.size && this._entries.set(0, { name: _l.DEFAULT_NAME, type: _l.DEFAULT_TYPE });
    const t = new Array();
    return this._entries.forEach((e3, r) => t.push(`layout(location = ${r}) out ${e3.type} ${e3.name};`)), t;
  }
};
l.DEFAULT_TYPE = "vec4", l.DEFAULT_NAME = "fragColor";
var g = class _g {
  constructor(e2) {
    this._stage = e2, this._entries = /* @__PURE__ */ new Set();
  }
  add(e2, t, r) {
    let n3 = "ERROR_CONSTRUCTOR_STRING";
    switch (t) {
      case "float":
        n3 = _g._numberToFloatStr(r);
        break;
      case "int":
        n3 = _g._numberToIntStr(r);
        break;
      case "bool":
        n3 = r.toString();
        break;
      case "vec2":
        n3 = `vec2(${_g._numberToFloatStr(r[0])},                            ${_g._numberToFloatStr(r[1])})`;
        break;
      case "vec3":
        n3 = `vec3(${_g._numberToFloatStr(r[0])},                            ${_g._numberToFloatStr(r[1])},                            ${_g._numberToFloatStr(r[2])})`;
        break;
      case "vec4":
        n3 = `vec4(${_g._numberToFloatStr(r[0])},                            ${_g._numberToFloatStr(r[1])},                            ${_g._numberToFloatStr(r[2])},                            ${_g._numberToFloatStr(r[3])})`;
        break;
      case "ivec2":
        n3 = `ivec2(${_g._numberToIntStr(r[0])},                             ${_g._numberToIntStr(r[1])})`;
        break;
      case "ivec3":
        n3 = `ivec3(${_g._numberToIntStr(r[0])},                             ${_g._numberToIntStr(r[1])},                             ${_g._numberToIntStr(r[2])})`;
        break;
      case "ivec4":
        n3 = `ivec4(${_g._numberToIntStr(r[0])},                             ${_g._numberToIntStr(r[1])},                             ${_g._numberToIntStr(r[2])},                             ${_g._numberToIntStr(r[3])})`;
        break;
      case "mat2":
      case "mat3":
      case "mat4":
        n3 = `${t}(${Array.prototype.map.call(r, (e3) => _g._numberToFloatStr(e3)).join(", ")})`;
    }
    return this._entries.add(`const ${t} ${e2} = ${n3};`), this._stage;
  }
  static _numberToIntStr(e2) {
    return e2.toFixed(0);
  }
  static _numberToFloatStr(e2) {
    return Number.isInteger(e2) ? e2.toFixed(1) : e2.toString();
  }
  generateSource() {
    return Array.from(this._entries);
  }
};
var f = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump sampler2D;\n#endif";
var S = "precision highp float;\nprecision highp sampler2D;";

export {
  s3 as s,
  e,
  a3 as a,
  o3 as o
};
//# sourceMappingURL=chunk-PVFZLQ5G.js.map
