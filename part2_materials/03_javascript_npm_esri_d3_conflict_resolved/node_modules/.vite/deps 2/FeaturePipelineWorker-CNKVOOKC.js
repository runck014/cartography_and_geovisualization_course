import {
  j as j2,
  r as r4
} from "./chunk-ZITL2WW7.js";
import "./chunk-3REIFLHQ.js";
import "./chunk-UUYHVC5D.js";
import {
  M as M2,
  a as a3,
  b as b4,
  i as i4,
  n as n6,
  n2 as n7,
  p as p2,
  p2 as p3,
  s as s7,
  t2 as t5
} from "./chunk-SZ3BUBIG.js";
import {
  t as t6
} from "./chunk-7TPUFUXO.js";
import {
  d2 as d5
} from "./chunk-JI3JMSDL.js";
import "./chunk-J3GKRP7Y.js";
import "./chunk-Q3K5MAUZ.js";
import "./chunk-KJNFPIQW.js";
import "./chunk-2XVRGGEF.js";
import "./chunk-DPVSO6BH.js";
import "./chunk-6TRZLPPJ.js";
import "./chunk-U6IFI7EK.js";
import "./chunk-C7P44RVS.js";
import "./chunk-MCHNAU6L.js";
import "./chunk-MYNRH67A.js";
import "./chunk-HCAIFU2M.js";
import "./chunk-AHZHHHCW.js";
import {
  r as r3
} from "./chunk-JUCPPEWL.js";
import {
  $
} from "./chunk-MOOCAZHA.js";
import "./chunk-DBGQDDBK.js";
import "./chunk-XDJWRN6T.js";
import "./chunk-5PXF5FL6.js";
import {
  o as o3
} from "./chunk-VS6HWAZD.js";
import {
  V
} from "./chunk-PQMYL64R.js";
import "./chunk-RSF7AFW5.js";
import "./chunk-VWXOSXKG.js";
import "./chunk-KVWJ4FJP.js";
import "./chunk-C2RS46RL.js";
import "./chunk-N42IF4WX.js";
import "./chunk-WI4GZYZR.js";
import "./chunk-M43YLXNM.js";
import {
  K,
  N,
  Nt,
  O,
  at,
  ct,
  et,
  ft,
  gt,
  nt,
  pt,
  rt,
  w as w2
} from "./chunk-BLBULF2O.js";
import {
  S,
  c as c2,
  d as d4
} from "./chunk-AZOBASR2.js";
import {
  b as b3,
  h
} from "./chunk-TILB77UC.js";
import {
  n as n5
} from "./chunk-YX36GZBB.js";
import "./chunk-JPQIRBN6.js";
import {
  e,
  s as s5
} from "./chunk-CH3XVKUV.js";
import {
  s as s4
} from "./chunk-KI5F6KDS.js";
import "./chunk-NCJB5REK.js";
import "./chunk-MSUBZ5BW.js";
import "./chunk-E6IUAXXM.js";
import {
  j,
  x
} from "./chunk-XJHQ5ZJ7.js";
import "./chunk-BXIXSFGX.js";
import "./chunk-A3GASGJZ.js";
import "./chunk-HACIIBEF.js";
import "./chunk-WCAEZENI.js";
import "./chunk-MBR7IVUG.js";
import {
  n as n8
} from "./chunk-SIBTVC2K.js";
import {
  i as i3
} from "./chunk-KDUYQUT4.js";
import "./chunk-QQRGQ74V.js";
import {
  h as h2
} from "./chunk-O67P2KE3.js";
import "./chunk-73FHIZIF.js";
import "./chunk-ICIPRMPO.js";
import "./chunk-NEDBRPQY.js";
import {
  e as e2
} from "./chunk-QLRZN73K.js";
import {
  a as a2
} from "./chunk-CGJUTDVJ.js";
import "./chunk-WVLGRCY6.js";
import "./chunk-QEJMJI2R.js";
import "./chunk-EHD5KM2T.js";
import {
  _
} from "./chunk-AEKV7TWM.js";
import "./chunk-QJXYURT2.js";
import "./chunk-JUN5XSQC.js";
import "./chunk-MCZMPI2A.js";
import "./chunk-KV3S4QI2.js";
import "./chunk-ECMDQ4LS.js";
import "./chunk-LP6TMAPE.js";
import {
  z as z2
} from "./chunk-5PCP47ZJ.js";
import "./chunk-IYJHGZBJ.js";
import "./chunk-IJO7BOFI.js";
import "./chunk-NGQEHRBA.js";
import "./chunk-QYSQ6XPQ.js";
import "./chunk-XKMN3LJN.js";
import {
  s as s3
} from "./chunk-2U5JYYSG.js";
import {
  Z
} from "./chunk-GGPPKSP2.js";
import "./chunk-MR727DXB.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-WPERPIJF.js";
import {
  d as d3,
  s as s6,
  y as y2
} from "./chunk-43W2AR4R.js";
import "./chunk-PJALR7VA.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-A66MNK5C.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-6GD5IU2W.js";
import "./chunk-XQ3CVA7I.js";
import {
  O as O2,
  c as c3
} from "./chunk-E54MA7AH.js";
import "./chunk-6TU4HBID.js";
import {
  b as b2
} from "./chunk-WGIZLWW7.js";
import "./chunk-PUOCGOJB.js";
import "./chunk-DBQLTBDH.js";
import "./chunk-AMH7OVBF.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-LXJGKQ4D.js";
import "./chunk-CP4GPQHD.js";
import {
  u as u4
} from "./chunk-IOKAACTA.js";
import "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-D2JPDRZZ.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-B5NBTUMV.js";
import "./chunk-TCZ4QHYH.js";
import "./chunk-SMFCDOAJ.js";
import {
  p
} from "./chunk-5A4G4OVM.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-DIKY6MBW.js";
import {
  u as u3
} from "./chunk-YVSEBNS4.js";
import "./chunk-6D5XULXX.js";
import {
  n as n4
} from "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import {
  v2 as v
} from "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import {
  g as g2
} from "./chunk-TDZ623HP.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import {
  d as d2
} from "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-SIQNRYEG.js";
import {
  o
} from "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-BMGF5ELJ.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import {
  w,
  y
} from "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import {
  g
} from "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import {
  M,
  r as r2
} from "./chunk-6YWQXXBX.js";
import {
  o2,
  t as t4,
  z
} from "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import {
  n as n3
} from "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import {
  b2 as b,
  i2,
  m,
  u3 as u2
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a,
  t2 as t3
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  L,
  c2 as c,
  d,
  f,
  m as m2,
  s as s2,
  t as t2
} from "./chunk-GRW2QIBT.js";
import {
  n as n2,
  u
} from "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  i,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has,
  t
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/views/2d/layers/features/PipelineConnectionHandlers.js
var t7 = class {
  constructor(e11) {
    this._client = e11, this.layerView = this._client.createInvokeProxy(""), this.container = this._client.createInvokeProxy("container"), this._eventLog = this._client.createInvokeProxy("eventLog");
  }
  onEvent(t19) {
    O2(this._eventLog.onEvent(t19));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MultiTileMeshData.js
var i5 = 1;
var r5 = 2;
var n9 = 4;
var h3 = 8;
var o4 = 16;
var c4 = 32;
var a4 = 64;
var l = 128;
function f2(e11) {
  switch (e11) {
    case i5:
    case h3:
    case c4:
      return -1;
    case r5:
    case a4:
      return 0;
    case n9:
    case o4:
    case l:
      return 1;
  }
}
function u5(e11) {
  switch (e11) {
    case i5:
    case r5:
    case n9:
      return -1;
    case h3:
    case o4:
      return 0;
    case c4:
    case a4:
    case l:
      return 1;
  }
}
var d6 = i5 | h3 | c4;
var _2 = n9 | o4 | l;
var m3 = i5 | r5 | n9;
var p4 = c4 | a4 | l;
var g3 = class {
  constructor(e11, s20, i14, r14, n19 = 0) {
    this.tileKey = e11, this._bufferingEnabled = s20, this._sizeHint = n19, this._meshes = { self: new n6(this.id, this._sizeHint), neighbors: new Array() }, this._currentRecordOverlaps = 0, this._currentEntityOverlaps = 0;
    const h7 = r14 ? 1 : 0;
    this._copyBufferedDataIntoSelf = i14 && this._bufferingEnabled && e11.level === h7;
  }
  get id() {
    return this.tileKey.id;
  }
  vertexCount() {
    return this._meshes.self.vertexCount();
  }
  indexCount() {
    return this._meshes.self.indexCount();
  }
  indexEnsureSize(e11) {
    this._meshes.self.indexEnsureSize(e11);
  }
  entityStart(e11, s20 = e11) {
    this._currentEntityOverlaps = 0, this._meshes.self.entityStart(e11, s20);
  }
  entityRecordCount() {
    return this._meshes.self.entityRecordCount();
  }
  entityEnd() {
    if (this._meshes.self.entityEnd(), this._bufferingEnabled) {
      if (this._copyBufferedDataIntoSelf) return;
      for (let e11 = 0; e11 < 8; e11++) {
        const s20 = 1 << e11;
        !!(this._currentEntityOverlaps & s20) && this._meshes.neighbors[e11].entityEnd();
      }
    }
  }
  recordStart(e11, s20, t19) {
    this._currentRecordOverlaps = 0, this._meshes.self.recordStart(e11, s20, t19);
  }
  recordEnd(e11 = 0) {
    const s20 = this._meshes.self.recordEnd(this._currentRecordOverlaps);
    return s20 && 0 !== this._currentRecordOverlaps ? (this._copyIntoNeighbors(), this._currentEntityOverlaps |= this._currentRecordOverlaps, true) : s20;
  }
  recordBounds(e11, s20, t19, i14) {
    this._bufferingEnabled && this._addOverlap(e11, s20, t19, i14);
  }
  recordCount() {
    return this._meshes.self.recordCount();
  }
  metricStart(e11) {
    this._meshes.self.metricStart(e11);
  }
  metricBoxWrite(e11) {
    this._meshes.self.metricBoxWrite(e11);
  }
  metricEnd() {
    this._meshes.self.metricEnd();
  }
  vertexWrite(e11) {
    this._meshes.self.vertexWrite(e11);
  }
  vertexWriteF32(e11) {
    this._meshes.self.vertexWriteF32(e11);
  }
  vertexWriteRegion(e11) {
    this._meshes.self.vertexWriteRegion(e11);
  }
  indexWrite(e11) {
    this._meshes.self.indexWrite(e11);
  }
  serialize(s20) {
    const t19 = { message: [], transferList: [] }, i14 = this._meshes.self.serialize();
    return t19.message.push({ tileId: this.tileKey.id, ...i14.message }), t19.transferList.push(...i14.transferList), this._meshes.neighbors.forEach((i15, r14) => {
      const n19 = i15.serialize(), h7 = 1 << r14, o15 = f2(h7), c10 = u5(h7), a13 = new e2(this.tileKey).getNormalizedNeighbor(o15, c10, s20);
      t19.message.push({ tileId: a13.id, ...n19.message }), t19.transferList.push(...n19.transferList);
    }), t19;
  }
  _addOverlap(e11, t19, i14, r14) {
    const n19 = Math.min(a2 / 2, i14), h7 = Math.min(a2 / 2, r14), o15 = 255 ^ ((e11 < 0 + n19 ? _2 : e11 >= a2 - n19 ? d6 : _2 | d6) | (t19 < 0 + h7 ? p4 : t19 >= a2 - h7 ? m3 : p4 | m3));
    this._currentRecordOverlaps |= o15;
  }
  _copyIntoNeighbors() {
    for (let e11 = 0; e11 < 8; e11++) {
      const i14 = 1 << e11;
      if (!!(this._currentRecordOverlaps & i14)) {
        if (this._copyBufferedDataIntoSelf) {
          const e12 = -f2(i14) * a2, t19 = -u5(i14) * a2;
          if (0 !== t19) continue;
          this._meshes.self.copyLast(e12, t19);
          continue;
        }
        if (!this._meshes.neighbors[e11]) {
          const s20 = Math.floor(this._sizeHint / 16);
          this._meshes.neighbors[e11] = new n6(i14, s20);
        }
        const r14 = this._meshes.neighbors[e11], n19 = -f2(i14) * a2, h7 = -u5(i14) * a2;
        r14.copyLastFrom(this._meshes.self, n19, h7);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/MeshFactory.js
var s8 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Matcher.js
var t8 = class _t {
  constructor() {
    this._defaultResult = null, this._backgroundFillResult = null;
  }
  static async from(e11, s20) {
    const l10 = new _t();
    return l10.setDefault(await e11.createMeshWriters(s20.meshes)), l10;
  }
  size() {
    return 1;
  }
  getDefault() {
    return this._defaultResult;
  }
  setDefault(t19) {
    this._defaultResult = t19;
  }
  getBackgroundFill() {
    return this._backgroundFillResult;
  }
  setBackgroundFill(t19) {
    this._backgroundFillResult = t19;
  }
  match(t19, e11) {
    const s20 = this.doMatch(t19, e11) || this.getDefault();
    if (s20 && s20.length > 0) {
      const t20 = this.getBackgroundFill();
      if (t20) return [...t20, ...s20];
    }
    return s20;
  }
  getSortKey(t19, e11) {
    return 0;
  }
  doMatch(t19, e11) {
    return null;
  }
  async fetchResources(t19, e11) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/DictionaryMatcher.js
var e3 = class _e extends t8 {
  static async fromDictionaryRenderer(t19, s20) {
    return new _e(t19, s20);
  }
  constructor(t19, e11) {
    super(), this._context = t19, this._schema = e11, this._hashToGroup = /* @__PURE__ */ new Map();
  }
  get fieldMap() {
    return this._schema.fieldMap;
  }
  async fetchResources(t19, e11) {
    const s20 = e11.getCursor(), r14 = [];
    for (; s20.next(); ) r14.push(this._updateMeshWriterGroup(t19, s20));
    await Promise.all(r14);
  }
  match(t19, e11) {
    const s20 = t19.getAttributeHash();
    return this._hashToGroup.get(s20);
  }
  async _updateMeshWriterGroup(t19, e11) {
    const s20 = e11.readLegacyFeatureForDisplay(), r14 = e11.getAttributeHash();
    if (this._hashToGroup.has(r14)) return;
    this._hashToGroup.set(r14, null);
    const a13 = await t19.fetchDictionaryResourceImmediate({ type: "dictionary-request", feature: s20 });
    if (!a13) return;
    const h7 = await this._context.createMeshWriters(a13.meshes);
    this._hashToGroup.set(r14, h7);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/IntervalMatcher.js
var e4 = class _e extends t8 {
  constructor(t19, e11) {
    super(), this._intervals = [], this._isMaxInclusive = e11, this._field = t19;
  }
  static async fromIntervalSchema(t19, s20) {
    const i14 = await t19.storage.createComputedField(s20), r14 = new _e(i14, s20.isMaxInclusive);
    await Promise.all(s20.intervals.map(async (e11) => {
      const s21 = await t19.createMeshWriters(e11.meshes);
      r14.add(e11, s21);
    }));
    const a13 = await t19.createMeshWriters(s20.defaultSymbol);
    r14.setDefault(a13);
    const n19 = await t19.createMeshWriters(s20.backgroundFill);
    return r14.setBackgroundFill(n19), r14;
  }
  add(t19, e11) {
    this._intervals.push({ interval: t19, result: e11 }), this._intervals.sort((t20, e12) => t20.interval.min - e12.interval.min);
  }
  size() {
    return super.size() + this._intervals.length;
  }
  doMatch(t19, e11) {
    var _a;
    const s20 = (_a = this._field) == null ? void 0 : _a.read(t19, e11);
    if (null == s20 || isNaN(s20) || s20 === 1 / 0 || s20 === -1 / 0) return null;
    for (let i14 = 0; i14 < this._intervals.length; i14++) {
      const { interval: t20, result: e12 } = this._intervals[i14], r14 = s20 >= t20.min, a13 = this._isMaxInclusive ? s20 <= t20.max : s20 < t20.max;
      if (r14 && a13) return e12;
    }
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/LabelMatcher.js
var a5 = class _a extends t8 {
  static async fromLabelSchema(e11, s20) {
    const r14 = s20.classes.map(async (a13) => {
      const s21 = await e11.createMeshWriters(a13.meshes);
      return { minScale: a13.minScale, maxScale: a13.maxScale, meshes: s21, expression: null, where: await e11.storage.createWhereClause(a13.where) };
    }), t19 = await Promise.all(r14);
    return new _a(t19);
  }
  constructor(e11) {
    super(), this._labels = e11;
  }
  match(e11, a13) {
    if (!this._labels.length) return null;
    const s20 = this._getLabels(a13.$view.scale), r14 = [];
    for (const t19 of s20) t19.where && !t19.where(e11) || r14.push(...t19.meshes);
    return r14;
  }
  _getLabels(e11) {
    return this._labels.filter((a13) => this._validForTileScale(a13, e11));
  }
  _validForTileScale(e11, a13) {
    const s20 = a13 - a13 / 4, r14 = a13 + a13 / 2;
    return (!e11.minScale || e11.minScale >= s20) && (!e11.maxScale || e11.maxScale <= r14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MapMatcher.js
var t9 = class _t extends t8 {
  constructor(e11, t19) {
    super(), this._defaultSymbolSortKey = 0, this._nullResult = null, this._resultsMap = /* @__PURE__ */ new Map(), this._fields = [], this._fields = e11, this._separator = t19 || "";
  }
  static async fromMatcherSchema(e11, l10) {
    const s20 = l10.expression ? [e11.storage.createComputedField({ expression: l10.expression })] : [l10.field ? e11.storage.createComputedField({ field: l10.field }) : null, l10.field2 ? e11.storage.createComputedField({ field: l10.field2 }) : null, l10.field3 ? e11.storage.createComputedField({ field: l10.field3 }) : null], r14 = (await Promise.all(s20)).filter((e12) => !!e12), i14 = new _t(r14, l10.fieldDelimiter), a13 = await e11.createMeshWriters(l10.defaultSymbol);
    i14.setDefault(a13);
    const u10 = await e11.createMeshWriters(l10.backgroundFill);
    return i14.setBackgroundFill(u10), await Promise.all(l10.map.map(async (t19, l11) => {
      const s21 = await e11.createMeshWriters(t19.symbol);
      "<Null>" === t19.value ? i14.setNullResult(s21) : i14.add(t19.value, s21, l11 + 1);
    })), i14;
  }
  setNullResult(e11) {
    this._nullResult = e11;
  }
  getSortKey(e11, t19) {
    const l10 = this._getValueFromFields(e11, t19);
    if (null == l10 || "" === l10 || "<Null>" === l10) return 0;
    const s20 = this._resultsMap.get(l10.toString());
    return s20 ? s20.sortKey : this._defaultSymbolSortKey;
  }
  add(e11, t19, l10) {
    this._resultsMap.set(e11.toString(), { meshWriters: t19, sortKey: l10 }), this._defaultSymbolSortKey = Math.max(this._defaultSymbolSortKey, l10 + 1);
  }
  size() {
    return super.size() + this._resultsMap.size;
  }
  doMatch(e11, t19) {
    var _a;
    const l10 = this._getValueFromFields(e11, t19);
    if (null !== this._nullResult && (null == l10 || "" === l10 || "<Null>" === l10)) return this._nullResult;
    if (null == l10) return null;
    const s20 = l10.toString();
    return (_a = this._resultsMap.get(s20)) == null ? void 0 : _a.meshWriters;
  }
  _getValueFromFields(e11, t19) {
    const l10 = [];
    for (const s20 of this._fields) {
      const r14 = s20.read(e11, t19);
      null == r14 || "" === r14 ? l10.push("<Null>") : l10.push(r14);
    }
    return l10.join(this._separator);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/createMatcher.js
async function c5(c10, u10) {
  switch (u10.type) {
    case "simple":
    case "heatmap":
    case "dot-density":
    case "pie-chart":
      return t8.from(c10, u10);
    case "interval":
      return e4.fromIntervalSchema(c10, u10);
    case "dictionary":
      return e3.fromDictionaryRenderer(c10, u10);
    case "label":
      return a5.fromLabelSchema(c10, u10);
    case "map":
      return t9.fromMatcherSchema(c10, u10);
    case "subtype":
      return n10.fromSubtypes(c10, u10);
    case "cluster":
      return o5.fromClusterSchema(c10, u10);
    default:
      throw new Error("Impl");
  }
}
var n10 = class _n extends t8 {
  constructor(e11, t19) {
    super(), this._subMatchers = e11, this._subtypeField = t19;
  }
  static async fromSubtypes(e11, t19) {
    const r14 = /* @__PURE__ */ new Map(), s20 = [];
    for (const a13 in t19.renderers) {
      const n19 = parseInt(a13, 10), o15 = c5(e11, t19.renderers[a13]).then((e12) => r14.set(n19, e12));
      s20.push(o15);
    }
    return await Promise.all(s20), new _n(r14, t19.subtypeField);
  }
  match(e11, t19) {
    const r14 = e11.readAttribute(this._subtypeField), s20 = this._subMatchers.get(r14);
    return s20 ? s20.match(e11, t19) : null;
  }
};
var o5 = class _o extends t8 {
  static async fromClusterSchema(e11, t19) {
    const [r14, s20] = await Promise.all([c5(e11, t19.feature), c5(e11, t19.cluster)]);
    return new _o(r14, s20);
  }
  constructor(e11, t19) {
    super(), this._featureMatcher = e11, this._clusterMatcher = t19;
  }
  match(e11, t19) {
    return 1 === e11.readAttribute("cluster_count") ? this._featureMatcher.match(e11, t19) : this._clusterMatcher.match(e11, t19);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/FeatureMeshFactory.js
var s9 = class _s extends s8 {
  static async create(e11, o15) {
    const r14 = await c5(e11, o15.symbology), c10 = o15.labels ? await c5(e11, o15.labels) : null;
    return new _s(r14, c10);
  }
  constructor(e11, t19) {
    super(), this._symbology = e11, this._labels = t19;
  }
  destroy() {
  }
  async enqueueMatcherRequests(e11, t19) {
    var _a;
    await Promise.all([this._symbology.fetchResources(e11, t19), (_a = this._labels) == null ? void 0 : _a.fetchResources(e11, t19)]);
  }
  enqueueWriterRequests(e11, t19, s20) {
    const o15 = this._symbology.match(t19, s20);
    if (o15) {
      for (const r14 of o15) r14.enqueueRequest(e11, t19, s20);
      if (this._labels) {
        const o16 = this._labels.match(t19, s20);
        if (!o16) return;
        for (const r14 of o16) r14.enqueueRequest(e11, t19, s20);
      }
    }
  }
  write(e11, t19, s20, o15, r14) {
    const c10 = this._symbology.match(s20, o15);
    if (!c10) return;
    for (const i14 of c10) i14.write(e11, t19, s20, o15, r14);
    if (e11.entityRecordCount() >= 1 && this._labels) {
      const i14 = this._labels.match(s20, o15);
      if (!i14) return;
      for (const a13 of i14) a13.setReferences(c10), a13.write(e11, t19, s20, o15, r14);
    }
  }
  getSortKey(e11, t19) {
    return this._symbology.getSortKey(e11, t19);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/MatcherContext.js
var s10 = class {
  constructor(s20, r14, t19, e11) {
    this.storage = s20, this.proxy = r14, this.viewParams = t19, this.registry = e11;
  }
  async createMeshWriters(s20) {
    const r14 = s20.map((s21) => this.registry.createMeshWriter(this.storage, this.proxy, this.viewParams, s21));
    return Promise.all(r14);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/ProcessorTileMessageQueue.js
var e5 = class {
  constructor(e11) {
    this._outstandingMessages = [], this._queue = new _({ concurrency: e11.concurrency, process: (s20) => e11.process(s20) });
  }
  async push(s20) {
    if (s20.end) return await Promise.all(this._outstandingMessages), await this._queue.push(s20), void (this._outstandingMessages = []);
    const e11 = this._queue.push(s20);
    return this._outstandingMessages.push(e11), e11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/ComputedAggregateField.js
var s11 = class _s {
  static async create(i14, e11) {
    var _a;
    if ("count" === e11.statisticType) {
      const i15 = new r4(1);
      return new _s(e11.name, e11.alias, e11.type, e11.statisticType, i15);
    }
    const a13 = await i14.createComputedField({ expression: (_a = e11.onStatisticExpression) == null ? void 0 : _a.expression, field: e11.onStatisticField });
    return new _s(e11.name, e11.alias, e11.type, e11.statisticType, a13);
  }
  constructor(t19, s20, i14, e11, a13) {
    this.name = t19, this.alias = s20, this.type = i14, this.statisticType = e11, this.computed = a13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AProcessorStrategy.js
var t10 = class {
  constructor(t19) {
    this.subscription = t19, this.handledChunks = /* @__PURE__ */ new Set();
  }
  destroy() {
  }
};
var e6 = class {
  constructor(t19, e11) {
    this._source = t19, this._attributeStore = e11, this._sendStates = /* @__PURE__ */ new Map();
  }
  destroy() {
  }
  get enablePixelBuffering() {
    return true;
  }
  onSubscribe(t19) {
    const e11 = this.createState(t19);
    this._sendStates.set(t19.key.id, e11), this.updateChunks();
  }
  onUnsubscribe(t19) {
    var _a;
    (_a = this._sendStates.get(t19.key.id)) == null ? void 0 : _a.destroy(), this._sendStates.delete(t19.key.id);
  }
  invalidate() {
    const t19 = Array.from(this._sendStates.values());
    this._sendStates.clear();
    for (const e11 of t19) e11.destroy(), this.onSubscribe(e11.subscription);
  }
  invalidateAttributeData() {
  }
  getFeatureObjectIdsForAggregate(t19) {
    throw new Error("InternalError: AggregateId lookup not supported");
  }
  getDisplayIds(t19) {
    return this.displayMap(t19, (t20) => t20, (t20) => t20);
  }
  getDisplayAndObjectIds(t19) {
    return this.displayMap(t19, (t20) => t20, (t20, e11, s20) => [t20, s20]);
  }
  beforeUpdateChunks() {
  }
  afterUpdateChunks() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/AAggregateStrategy.js
var i6 = class extends e6 {
  constructor(t19, r14, s20, o15) {
    super(t19, r14), this.spatialReference = s20, this.aggregateFields = o15, this.events = new o(), this.featureAdapter = o3;
  }
  get aggregateQueryEngine() {
    return this._aggregateQueryEngine || (this._aggregateQueryEngine = new V({ featureStore: this, fieldsIndex: this._metadata.fieldsIndex, geometryType: this._metadata.geometryType, objectIdField: this._metadata.objectIdField, spatialReference: this.spatialReference })), this._aggregateQueryEngine;
  }
  removeChunks(e11) {
  }
  forEach(e11) {
    return this.forEachAggregateWorldSpace(e11);
  }
  forEachInBounds(e11, t19) {
  }
  forEachBounds(e11, a13) {
    const s20 = u4();
    for (const t19 of e11) {
      const e12 = gt(s20, t19.geometry, false, false);
      e12 && a13(e12);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceMessage.js
var e7 = class {
  constructor(e11, i14, t19, s20, r14) {
    this.subscription = e11, this.reader = i14, this.clear = t19, this.end = s20, this.debugInfo = r14, this.type = "append";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e11, i14, t19) {
    return { type: "append", clear: this.clear, id: this.id, append: e11, end: this.end, debugInfo: this.debugInfo, subscriptionVesrion: this.subscription.version, version: i14, attributeEpoch: t19 };
  }
};
var i7 = class {
  constructor(e11, i14, t19, s20, r14) {
    this.subscription = e11, this.reader = i14, this.remove = t19, this.end = s20, this.debugInfo = r14, this.type = "update";
  }
  get id() {
    return this.subscription.tile.id;
  }
  createMessage(e11, i14, t19) {
    return { type: "update", id: this.id, modify: e11, debugInfo: this.debugInfo, remove: this.remove, version: i14, subscriptionVesrion: this.subscription.version, end: this.end, attributeEpoch: t19 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSpatialIndex.js
var t11 = class _t {
  static fromReader(o15) {
    const e11 = [], r14 = o15.copy(), a13 = u4();
    for (; r14.next(); ) {
      r14.getBounds(a13) && e11.push(r14.getIndex());
    }
    const i14 = i3(9, (n19) => (r14.setIndex(n19), { minX: r14.getBoundsXMin(), minY: r14.getBoundsYMin(), maxX: r14.getBoundsXMax(), maxY: r14.getBoundsYMax() }));
    return i14.load(e11), new _t(i14);
  }
  constructor(n19) {
    this._index = n19;
  }
  search(n19) {
    const s20 = { minX: n19[0], minY: n19[1], maxX: n19[2], maxY: n19[3] };
    return this._index.search(s20);
  }
};

// node_modules/@arcgis/core/geohash/geohashUtils.js
var m4 = new Float64Array(2);
var p5 = new Float64Array(2);
var j3 = 64;
function S2(t19, e11, f6, l10) {
  const a13 = [t19.xmin, t19.ymin, t19.xmax, t19.ymax], u10 = v.fromExtent(w.fromBounds(a13, l10)), h7 = j(u10, l10, g.WGS84, { densificationStep: e11 * j3 });
  if (!h7) return null;
  const m10 = K(new s4(), h7, false, false), p9 = m10.coords.filter((t20, o15) => !(o15 % 2)), g6 = m10.coords.filter((t20, o15) => o15 % 2), y9 = Math.min(...p9), d11 = Math.min(...g6), x4 = Math.max(...p9), M4 = Math.max(...g6), S5 = A(y9, d11, f6, g.WGS84), G2 = A(x4, M4, f6, g.WGS84);
  return S5 && G2 ? { bounds: a13, geohashBounds: { xLL: S5[0], yLL: S5[1], xTR: G2[0], yTR: G2[1] }, level: f6 } : null;
}
function A(o15, r14, s20, c10) {
  if (c10.isWebMercator) {
    const n19 = M(o15 / t4.radius), c11 = n19 - 360 * Math.floor((n19 + 180) / 360), i14 = [0, 0];
    return Y(i14, 0, M(Math.PI / 2 - 2 * Math.atan(Math.exp(-r14 / t4.radius))), c11, s20), i14;
  }
  const f6 = j({ x: o15, y: r14 }, c10, g.WGS84);
  if (!f6) return null;
  const l10 = [0, 0];
  return Y(l10, 0, f6.y, f6.x, s20), l10;
}
function R(t19, o15) {
  let r14 = -90, n19 = 90, e11 = -180, s20 = 180;
  for (let c10 = 0; c10 < o15; c10++) {
    const o16 = Math.ceil((c10 + 1) / 2), i14 = Math.floor((c10 + 1) / 2), f6 = 1 - c10 % 2, l10 = 30 - (3 * o16 + 2 * i14), a13 = 30 - (2 * o16 + 3 * i14), u10 = 3 * f6 + 2 * (1 - f6), h7 = 2 * f6 + 3 * (1 - f6), m10 = 3 * f6 + 7 * (1 - f6) << a13, p9 = (7 * f6 + 3 * (1 - f6) << l10 & t19.geohashX) >> l10, g6 = (m10 & t19.geohashY) >> a13;
    for (let t20 = u10 - 1; t20 >= 0; t20--) {
      const o17 = (e11 + s20) / 2, r15 = p9 & 1 << t20 ? 1 : 0;
      e11 = (1 - r15) * e11 + r15 * o17, s20 = (1 - r15) * o17 + r15 * s20;
    }
    for (let t20 = h7 - 1; t20 >= 0; t20--) {
      const o17 = (r14 + n19) / 2, e12 = g6 & 1 << t20 ? 1 : 0;
      r14 = (1 - e12) * r14 + e12 * o17, n19 = (1 - e12) * o17 + e12 * n19;
    }
  }
  return [e11, r14, s20, n19];
}
function Y(t19, o15, r14, n19, e11) {
  e11 % 2 && (e11 += 1);
  let s20 = 0, c10 = 0, i14 = -90, f6 = 90, l10 = -180, a13 = 180;
  for (let u10 = 0; u10 < e11 / 2; u10++) {
    for (let t20 = 0; t20 < 5; t20++) {
      const o16 = (l10 + a13) / 2, r15 = n19 > o16 ? 1 : 0;
      s20 |= r15 << 29 - (t20 + 5 * u10), l10 = (1 - r15) * l10 + r15 * o16, a13 = (1 - r15) * o16 + r15 * a13;
    }
    for (let t20 = 0; t20 < 5; t20++) {
      const o16 = (i14 + f6) / 2, n20 = r14 > o16 ? 1 : 0;
      c10 |= n20 << 29 - (t20 + 5 * u10), i14 = (1 - n20) * i14 + n20 * o16, f6 = (1 - n20) * o16 + n20 * f6;
    }
  }
  t19[2 * o15] = s20, t19[2 * o15 + 1] = c10;
}

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateCell.js
var t12 = class {
  constructor(t19) {
    this._statistics = t19;
  }
  get statistics() {
    return this._statistics;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AccumulatedStatistics.js
var e8 = Math.PI / 180;
var s12 = class _s {
  static create(t19) {
    return new _s(t19.map((t20) => i8(t20)));
  }
  constructor(t19) {
    this._statistics = t19;
  }
  values() {
    return this._statistics.values();
  }
  insert(t19, e11) {
    for (const s20 of this._statistics) s20.insert(t19, e11);
  }
  merge(t19) {
    for (let e11 = 0; e11 < this._statistics.length; e11++) {
      const s20 = this._statistics[e11], i14 = t19._statistics[e11];
      if (s20.field.name !== i14.field.name) throw new Error("InternalError: Tried to merge incompatible statistics");
      s20.merge(i14);
    }
  }
  clone() {
    return new _s(this._statistics.map((t19) => t19.clone()));
  }
};
function i8(t19) {
  switch (t19.statisticType) {
    case "min":
      return new r6(t19);
    case "max":
      return new u6(t19);
    case "avg":
      return new c6(t19);
    case "avg_angle":
      return new h4(t19);
    case "sum":
    case "count":
      return new a6(t19);
    case "mode":
      return new o6(t19);
  }
}
var n11 = class {
  constructor(t19) {
    this.field = t19;
  }
  insert(e11, s20) {
    if (!this.field.computed) return;
    const i14 = this.field.computed.read(e11, s20);
    n7(i14) || this._insertValue(i14);
  }
};
var r6 = class _r extends n11 {
  constructor() {
    super(...arguments), this.type = "min", this.value = Number.MAX_VALUE;
  }
  _insertValue(t19) {
    this.value = Math.min(this.value, t19);
  }
  merge(t19) {
    this.value = Math.min(this.value, t19.value);
  }
  clone() {
    const t19 = new _r(this.field);
    return t19.value = this.value, t19;
  }
};
var u6 = class _u extends n11 {
  constructor() {
    super(...arguments), this.type = "max", this.value = Number.MIN_VALUE;
  }
  _insertValue(t19) {
    this.value = Math.max(this.value, t19);
  }
  merge(t19) {
    this.value = Math.max(this.value, t19.value);
  }
  clone() {
    const t19 = new _u(this.field);
    return t19.value = this.value, t19;
  }
};
var a6 = class _a extends n11 {
  constructor() {
    super(...arguments), this.type = "sum", this.value = 0;
  }
  _insertValue(t19) {
    this.value += t19;
  }
  merge(t19) {
    this.value += t19.value;
  }
  clone() {
    const t19 = new _a(this.field);
    return t19.value = this.value, t19;
  }
};
var c6 = class _c extends n11 {
  constructor() {
    super(...arguments), this.type = "avg", this._total = 0, this._count = 0;
  }
  get value() {
    return this._total / this._count;
  }
  _insertValue(t19) {
    this._total += t19, this._count += 1;
  }
  merge(t19) {
    this._total += t19._total, this._count += t19._count;
  }
  clone() {
    const t19 = new _c(this.field);
    return t19._total = this._total, t19._count = this._count, t19;
  }
};
var h4 = class _h extends n11 {
  constructor() {
    super(...arguments), this.type = "avg_angle", this._x = 0, this._y = 0, this._count = 0;
  }
  get value() {
    const t19 = this._x / this._count, e11 = this._y / this._count, s20 = 180 / Math.PI;
    return Math.atan2(e11, t19) * s20;
  }
  _insertValue(t19) {
    this._x = this._x + Math.cos(t19 * e8), this._y = this._y + Math.sin(t19 * e8), this._count += 1;
  }
  merge(t19) {
    this._x += t19._x, this._y += t19._y, this._count += t19._count;
  }
  clone() {
    const t19 = new _h(this.field);
    return t19._x = this._x, t19._y = this._y, t19._count = this._count, t19;
  }
};
var o6 = class _o extends n11 {
  constructor() {
    super(...arguments), this._frequencies = /* @__PURE__ */ new Map();
  }
  get value() {
    let t19, e11 = 0;
    for (const [s20, i14] of this._frequencies.entries()) i14 > e11 && (e11 = i14, t19 = s20);
    return t19;
  }
  _insertValue(t19) {
    const e11 = this._frequencies.get(t19);
    null != e11 ? this._frequencies.set(t19, e11 + 1) : this._frequencies.set(t19, 1);
  }
  merge(t19) {
    for (const [e11, s20] of t19._frequencies.entries()) {
      const t20 = this._frequencies.get(e11);
      null != t20 ? this._frequencies.set(e11, t20 + s20) : this._frequencies.set(e11, s20);
    }
  }
  clone() {
    const t19 = new _o(this.field);
    return t19._frequencies = new Map(this._frequencies), t19;
  }
};

// node_modules/@arcgis/core/geohash/GeohashCell.js
var l2 = class _l extends t12 {
  static create(t19, e11, o15, s20) {
    const r14 = s12.create(t19), i14 = new Array(32);
    for (let h7 = 0; h7 < i14.length; h7++) i14[h7] = null;
    return new _l(r14, e11, o15, s20, i14);
  }
  constructor(t19, e11, o15, s20, r14) {
    super(t19), this.xNode = e11, this.yNode = o15, this.depth = s20, this.children = r14, this._objectIds = /* @__PURE__ */ new Set(), this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._xGeohashTotal = 0, this._yGeohashTotal = 0, this.next = null;
  }
  get id() {
    return `${this.xNode}.${this.yNode}`;
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  clone() {
    const t19 = new _l(this._statistics.clone(), this.xNode, this.yNode, this.depth, this.children);
    return t19._count = this._count, t19._xWorldTotal = this._xWorldTotal, t19._yWorldTotal = this._yWorldTotal, t19._xGeohashTotal = this._xGeohashTotal, t19._yGeohashTotal = this._yGeohashTotal, t19.next = this.next, t19._objectIds = new Set(this._objectIds), t19;
  }
  insert(t19, e11, o15, s20, r14, i14) {
    this._count += 1, this._xWorldTotal += e11, this._yWorldTotal += o15, this._xGeohashTotal += s20, this._yGeohashTotal += r14, this._statistics.insert(t19, i14), this._objectIds.add(t19.getObjectId());
  }
  merge(t19) {
    if (0 !== t19._count) {
      this._count += t19._count, this._xWorldTotal += t19._xWorldTotal, this._yWorldTotal += t19._yWorldTotal, this._xGeohashTotal += t19._xWorldTotal, this._yGeohashTotal += t19._yWorldTotal, this._statistics.merge(t19._statistics);
      for (const e11 of t19._objectIds.values()) this._objectIds.add(e11);
    }
  }
  getCentroid(t19) {
    throw new Error("getCentroid not supported for GeohashNode");
  }
  getGeometry(t19, r14) {
    const a13 = this._getLngLatBounds(), [n19, l10, d11, c10] = a13, _5 = j({ rings: [[[n19, l10], [n19, c10], [d11, c10], [d11, l10], [n19, l10]]] }, g.WGS84, t19), u10 = K(new s4(), _5, false, false);
    if (null != r14) {
      return at(new s4(), u10, false, false, "esriGeometryPolygon", r14, false, false);
    }
    return u10;
  }
  getGeometricCentroid(t19, o15) {
    const a13 = this._getLngLatBounds(), [n19, l10, d11, c10] = a13, _5 = j({ x: (n19 + d11) / 2, y: (l10 + c10) / 2 }, g.WGS84, t19), u10 = O(new s4(), _5);
    if (null != o15) {
      return at(new s4(), u10, false, false, "esriGeometryPoint", o15, false, false);
    }
    return u10;
  }
  getAttributes() {
    const t19 = { aggregateId: this.id };
    for (const e11 of this._statistics.values()) t19[e11.field.name] = e11.value;
    return t19.aggregateCount = this._count, t19;
  }
  find(t19, e11, o15, s20, r14, i14) {
    if (s20 >= o15) return this;
    const h7 = 1 - s20 % 2, a13 = 3 * h7 + 2 * (1 - h7), n19 = 2 * h7 + 3 * (1 - h7), l10 = 30 - r14 - a13, d11 = 30 - i14 - n19, c10 = ((t19 & 7 * h7 + 3 * (1 - h7) << l10) >> l10) + ((e11 & 3 * h7 + 7 * (1 - h7) << d11) >> d11) * (8 * h7 + 4 * (1 - h7)), _5 = this.children[c10];
    return null == _5 ? null : _5.find(t19, e11, o15, s20 + 1, r14 + a13, i14 + n19);
  }
  _getLngLatBounds() {
    const e11 = this.depth, o15 = Math.ceil(e11 / 2), s20 = Math.floor(e11 / 2), r14 = 30 - (3 * o15 + 2 * s20), i14 = 30 - (2 * o15 + 3 * s20), h7 = this.xNode << r14, a13 = this.yNode << i14;
    return R({ geohashX: h7, geohashY: a13 }, this.depth);
  }
};

// node_modules/@arcgis/core/geohash/GeohashTree.js
var e9 = class {
  constructor(e11) {
    this._fields = e11, this._size = 0, this._depth = 0, this._root = l2.create(this._fields, 0, 0, 0);
  }
  destroy() {
  }
  get size() {
    return this._size;
  }
  get depth() {
    return this._depth;
  }
  find(t19, e11, s20) {
    return this._root.find(t19, e11, s20, 0, 0, 0);
  }
  insert(e11, s20, i14, n19, o15, h7, r14) {
    let l10 = this._root, d11 = 0, c10 = 0, a13 = 0;
    for (; null !== l10; ) {
      if (l10.insert(e11, s20, i14, n19, o15, r14), d11 >= h7) return;
      const f6 = Math.ceil((d11 + 1) / 2), u10 = Math.floor((d11 + 1) / 2), x4 = 1 - d11 % 2, _5 = 30 - (3 * f6 + 2 * u10), p9 = 30 - (2 * f6 + 3 * u10), M4 = (n19 & 7 * x4 + 3 * (1 - x4) << _5) >> _5, m10 = (o15 & 3 * x4 + 7 * (1 - x4) << p9) >> p9, g6 = M4 + m10 * (8 * x4 + 4 * (1 - x4));
      c10 = c10 << 3 * x4 + 2 * (1 - x4) | M4, a13 = a13 << 2 * x4 + 3 * (1 - x4) | m10, null == l10.children[g6] && (l10.children[g6] = l2.create(this._fields, c10, a13, d11 + 1), this._depth = Math.max(this._depth, d11 + 1), this._size += 1), d11 += 1, l10 = l10.children[g6];
    }
  }
  putBins(t19, e11) {
    for (const s20 of this.getNodes(e11)) {
      const e12 = t19.get(s20.id);
      e12 ? e12.merge(s20) : t19.set(s20.id, s20.clone());
    }
  }
  getNodes(t19) {
    const e11 = [], { geohashBounds: s20, level: i14 } = t19;
    let n19 = this._root;
    for (; null !== n19; ) {
      const t20 = n19.depth, o15 = n19.xNode, h7 = n19.yNode;
      if (t20 >= i14) {
        e11.push(n19), n19 = n19.next;
        continue;
      }
      const r14 = Math.ceil((t20 + 1) / 2), l10 = Math.floor((t20 + 1) / 2), d11 = 1 - t20 % 2, c10 = 30 - (3 * r14 + 2 * l10), a13 = 30 - (2 * r14 + 3 * l10), f6 = ~((1 << c10) - 1), u10 = ~((1 << a13) - 1), x4 = (s20.xLL & f6) >> c10, _5 = (s20.yLL & u10) >> a13, p9 = (s20.xTR & f6) >> c10, M4 = (s20.yTR & u10) >> a13, m10 = o15 << 3 * d11 + 2 * (1 - d11), g6 = h7 << 2 * d11 + 3 * (1 - d11), y9 = m10 + 8 * d11 + 4 * (1 - d11), z4 = g6 + 4 * d11 + 8 * (1 - d11), L3 = Math.max(m10, x4), N3 = Math.max(g6, _5), B2 = Math.min(y9, p9), R3 = Math.min(z4, M4);
      let T2 = null, j5 = null;
      for (let e12 = N3; e12 <= R3; e12++) for (let t21 = L3; t21 <= B2; t21++) {
        const s21 = t21 - m10 + (e12 - g6) * (8 * d11 + 4 * (1 - d11)), i15 = n19.children[s21];
        i15 && (T2 || (T2 = i15, T2.next = n19.next), j5 && (j5.next = i15), j5 = i15, i15.next = n19.next);
      }
      n19 = T2 || n19.next;
    }
    return e11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/AAggregateSpatialIndex.js
var t13 = class {
  constructor(e11) {
    this._options = e11;
  }
  insert(e11, t19) {
    const r14 = e11.getCursor(), o15 = { $view: { scale: this._options.scale, timeZone: this._options.timeZone } };
    for (; r14.next(); ) this._insertFeature(r14, o15, t19);
  }
  _insertFeature(t19, r14, o15) {
    const { featureFilter: i14 } = this._options;
    if (null !== i14 && !i14.check(t19)) return;
    let s20 = 0, n19 = 0;
    if ("esriGeometryPoint" === t19.geometryType) s20 = t19.readXWorldSpace(), n19 = t19.readYWorldSpace();
    else {
      if (o15) {
        const r16 = t19.readCentroidForDisplay();
        if (null == r16) return;
        const [o16, i15] = r16.coords;
        if (o16 < 0 || o16 > a2 || i15 < 0 || i15 > a2) return;
      }
      const r15 = t19.readCentroidWorldSpace();
      if (null == r15) return;
      s20 = r15.coords[0], n19 = r15.coords[1];
    }
    this._insert(t19, s20, n19, r14);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GeohashSpatialIndex.js
var r7 = class extends t13 {
  constructor(t19) {
    super(t19), this._tree = new e9(this._options.fields);
  }
  put(e11) {
    throw new Error("Geohash tree does not support put");
  }
  putBounded(e11, s20, o15) {
    const { geohashLevel: r14, spatialReference: h7 } = this._options, i14 = S2(s20, o15, r14, h7);
    null != i14 && this._tree.putBins(e11, i14);
  }
  _insert(e11, t19, o15, r14) {
    const { geohashLevel: h7, spatialReference: i14 } = this._options, n19 = A(t19, o15, h7, i14);
    n19 && this._tree.insert(e11, t19, o15, n19[0], n19[1], h7, r14);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridCell.js
var l3 = class _l extends t12 {
  static createId(t19, e11) {
    return `${t19}.${e11}`;
  }
  static create(t19, e11, r14, i14) {
    return new _l(t19, e11, s12.create(r14), i14);
  }
  constructor(t19, e11, r14, i14) {
    super(r14), this.gridX = t19, this.gridY = e11, this._worldUnitsPerCell = i14, this._count = 0, this._xWorldTotal = 0, this._yWorldTotal = 0, this._objectIds = /* @__PURE__ */ new Set();
  }
  get id() {
    return _l.createId(this.gridX, this.gridY);
  }
  get containedObjectIds() {
    return this._objectIds;
  }
  get count() {
    return this._count;
  }
  get firstObjectId() {
    return this._objectIds.values().next().value;
  }
  get centroidXWorld() {
    return this._xWorldTotal / this._count;
  }
  get centroidYWorld() {
    return this._yWorldTotal / this._count;
  }
  clone() {
    const t19 = new _l(this.gridX, this.gridY, this._statistics.clone(), this._worldUnitsPerCell);
    return t19._count = this._count, t19._xWorldTotal = this._xWorldTotal, t19._yWorldTotal = this._yWorldTotal, t19._firstFeatureAttributes = this._firstFeatureAttributes, t19._objectIds = new Set(this._objectIds), t19;
  }
  insert(t19, e11, r14, i14) {
    0 === this._count ? this._firstFeatureAttributes = t19.readAttributes() : this._firstFeatureAttributes = null, this._count += 1, this._xWorldTotal += r14, this._yWorldTotal += i14, this._statistics.insert(t19, e11), this._objectIds.add(t19.getObjectId());
  }
  merge(t19) {
    if (0 !== t19._count) {
      this._count += t19._count, this._firstFeatureAttributes = t19._firstFeatureAttributes, this._xWorldTotal += t19._xWorldTotal, this._yWorldTotal += t19._yWorldTotal, this._statistics.merge(t19._statistics);
      for (const e11 of t19._objectIds.values()) this._objectIds.add(e11);
    }
  }
  getCentroidX(e11) {
    return null == e11 ? this.centroidXWorld : N(e11, this.centroidXWorld);
  }
  getCentroidY(t19) {
    return null == t19 ? this.centroidYWorld : w2(t19, this.centroidYWorld);
  }
  getGeometry(t19, e11) {
    const s20 = this.gridX * this._worldUnitsPerCell, o15 = this.gridY * this._worldUnitsPerCell, l10 = new s4([4], [s20, o15, s20 + this._worldUnitsPerCell, o15, s20 + this._worldUnitsPerCell, o15 + this._worldUnitsPerCell, s20, o15 + this._worldUnitsPerCell]);
    if (null != e11) {
      const t20 = new s4();
      return at(t20, l10, false, false, "esriGeometryPolygon", e11);
    }
    return l10;
  }
  getCentroid(t19) {
    const e11 = new s4([], [this.centroidXWorld, this.centroidYWorld]);
    if (null != t19) {
      const s20 = new s4();
      return at(s20, e11, false, false, "esriGeometryPoint", t19);
    }
    return e11;
  }
  getGeometricCentroid(t19, e11) {
    const s20 = this.gridX * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, o15 = this.gridY * this._worldUnitsPerCell + 0.5 * this._worldUnitsPerCell, l10 = new s4([], [s20, o15]);
    if (null != e11) {
      const t20 = new s4();
      return at(t20, l10, false, false, "esriGeometryPoint", e11);
    }
    return l10;
  }
  getAttributes() {
    const t19 = { aggregateId: this.id };
    for (const e11 of this._statistics.values()) t19[e11.field.name] = e11.value;
    return null != this._firstFeatureAttributes ? { ...t19, ...this._firstFeatureAttributes } : t19;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/aggregation/GridSpatialIndex.js
var l4 = 96;
function o7(i14, s20) {
  return z(i14) * o2 * l4 / s20;
}
var n12 = class extends t13 {
  constructor(t19) {
    super(t19), this._cells = /* @__PURE__ */ new Map(), this._pixelsPerMapUnit = o7(t19.spatialReference, t19.scale);
  }
  put(t19) {
    for (const e11 of this._cells.values()) {
      const i14 = t19.get(e11.id);
      i14 ? i14.merge(e11) : t19.set(e11.id, e11.clone());
    }
  }
  putBounded(t19, e11, i14) {
    const s20 = [e11.xmin, e11.ymin, e11.xmax, e11.ymax], [l10, o15, n19, r14] = s20, c10 = Math.floor(l10 * this._pixelsPerMapUnit / this._options.cellSize), p9 = Math.floor(o15 * this._pixelsPerMapUnit / this._options.cellSize), a13 = Math.ceil(n19 * this._pixelsPerMapUnit / this._options.cellSize), h7 = Math.ceil(r14 * this._pixelsPerMapUnit / this._options.cellSize);
    for (let _5 = p9; _5 <= h7; _5++) for (let e12 = c10; e12 <= a13; e12++) {
      const i15 = `${e12}.${_5}`, s21 = this._cells.get(i15);
      if (!s21) continue;
      const l11 = t19.get(s21.id);
      l11 ? s21 && !t19.has(s21.id) && l11.merge(s21) : t19.set(s21.id, s21.clone());
    }
  }
  _insert(t19, e11, i14, s20) {
    const l10 = e11 * this._pixelsPerMapUnit, o15 = i14 * this._pixelsPerMapUnit, n19 = Math.floor(l10 / this._options.cellSize), r14 = Math.floor(o15 / this._options.cellSize);
    this._getCellOrCreate(n19, r14).insert(t19, s20, e11, i14);
  }
  _getCellOrCreate(t19, e11) {
    const i14 = l3.createId(t19, e11);
    let l10 = this._cells.get(i14);
    if (!l10) {
      const o15 = 1 * this._options.cellSize / this._pixelsPerMapUnit;
      l10 = l3.create(t19, e11, this._options.fields, o15), this._cells.set(i14, l10);
    }
    return l10;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderIndirect.js
var a7 = class _a extends M2 {
  static from(e11, r14) {
    return new _a(e11.copy(), r14);
  }
  constructor(e11, r14) {
    super(e11.metadata), this._currentIndex = -1, this._displayTranslationX = 0, this._displayTranslationY = 0, this._displayScaleX = 1, this._displayScaleY = 1, this._reader = e11, this._indices = r14, this._isPoint = "esriGeometryPoint" === e11.geometryType;
  }
  setTransformForDisplay(e11) {
    const r14 = this._reader.getInTransform();
    if (null == r14) {
      const [r15, t20] = e11.scale, [s21, a14] = e11.translate;
      return this._displayTranslationX = -s21 / r15, this._displayScaleX = 1 / r15, this._displayTranslationY = a14 / t20, this._displayScaleY = 1 / -t20, void (this._displayTransform = e11);
    }
    const [t19, s20] = r14.scale, [a13, i14] = r14.translate, [d11, n19] = e11.scale, [o15, l10] = e11.translate;
    if (this._displayScaleX = t19 / d11, this._displayTranslationX = (a13 - o15) / d11, this._displayScaleY = s20 / n19, this._displayTranslationY = (-i14 + l10) / n19, !this._isPoint && r14) throw new Error("InternalError: Relative transformations not supported for non-point features");
    this._displayTransform = e11;
  }
  getInTransform() {
    return this._reader.getInTransform();
  }
  get fields() {
    return this._reader.fields;
  }
  get hasNext() {
    return this._currentIndex + 1 < this._indices.length;
  }
  getSize() {
    return this._indices.length;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const e11 = new _a(this._reader.copy(), this._indices);
    return e11._currentIndex = this._currentIndex, e11._displayTransform = this._displayTransform, e11._displayTranslationX = this._displayTranslationX, e11._displayTranslationY = this._displayTranslationY, e11._displayScaleX = this._displayScaleX, e11._displayScaleY = this._displayScaleY, e11;
  }
  get contextTimeZone() {
    return this._reader.contextTimeZone;
  }
  set contextTimeZone(e11) {
    this._reader.contextTimeZone = e11;
  }
  _nextIndex() {
    return ++this._currentIndex < this._indices.length && (this._reader.setIndex(this._indices[this._currentIndex]), true);
  }
  next() {
    for (; this._nextIndex() && !this._reader._getExists(); ) ;
    return this._currentIndex < this._indices.length;
  }
  readXForDisplay() {
    return this._reader.readXForDisplay() * this._displayScaleX + this._displayTranslationX;
  }
  readYForDisplay() {
    return this._reader.readYForDisplay() * this._displayScaleY + this._displayTranslationY;
  }
  readGeometryForDisplay() {
    const r14 = this._reader.readGeometryForDisplay();
    if (!this._displayTransform) return r14;
    const s20 = new s4();
    return at(s20, r14, this.hasZ, this.hasM, this.geometryType, this._displayTransform), s20.deltaDecode();
  }
  readCentroidForDisplay() {
    var _a2;
    const e11 = (_a2 = this._reader.readCentroidForDisplay()) == null ? void 0 : _a2.clone();
    if (e11) {
      const [r14, t19] = e11.coords;
      e11.coords[0] = r14 * this._displayScaleX + this._displayTranslationX, e11.coords[1] = t19 * this._displayScaleY + this._displayTranslationY;
    }
    return e11;
  }
  get geometryType() {
    return this._reader.geometryType;
  }
  get hasFeatures() {
    return this._reader.hasFeatures;
  }
  get exceededTransferLimit() {
    return this._reader.exceededTransferLimit;
  }
  get hasZ() {
    return this._reader.hasZ;
  }
  get hasM() {
    return this._reader.hasM;
  }
  readAttribute(e11, r14 = false) {
    return this._reader.readAttribute(e11, r14);
  }
  readAttributes() {
    return this._reader.readAttributes();
  }
  joinAttributes(e11) {
    return this._reader.joinAttributes(e11);
  }
  getBounds(e11) {
    return this._reader.getBounds(e11);
  }
  getAttributeHash() {
    return this._reader.getAttributeHash();
  }
  getObjectId() {
    return this._reader.getObjectId();
  }
  getDisplayId() {
    return this._reader.getDisplayId();
  }
  setDisplayId(e11) {
    return this._reader.setDisplayId(e11);
  }
  setIndex(e11) {
    return this._reader.setIndex(e11);
  }
  getIndex() {
    return this._reader.getIndex();
  }
  readXWorldSpace() {
    return this._reader.readXWorldSpace();
  }
  readYWorldSpace() {
    return this._reader.readYWorldSpace();
  }
  _readX() {
    return this._reader.readXForDisplay();
  }
  _readY() {
    return this._reader.readYForDisplay();
  }
  _readServerCentroid() {
    return this._reader._readServerCentroid();
  }
  readLegacyFeatureForDisplay() {
    const e11 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e11 && { x: e11.coords[0], y: e11.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e11 = this.readGeometryForDisplay();
    return rt(e11, this.geometryType, false, false);
  }
  readGeometryArea() {
    return this._reader.readGeometryArea();
  }
  readGeometryWorldSpace() {
    return this._reader.readGeometryWorldSpace();
  }
  _readGeometry() {
    return this._reader._readGeometry();
  }
  _readAttribute(e11, r14) {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  _readAttributes() {
    throw new Error("Error: Should not be called. Underlying _reader should be used instead");
  }
  readArcadeFeature() {
    return this._reader.readArcadeFeature();
  }
  geometry() {
    return this._reader.geometry();
  }
  field(e11) {
    return this._reader.field(e11);
  }
  hasField(e11) {
    return this._reader.hasField(e11);
  }
  setField(e11, r14) {
    return this._reader.setField(e11, r14);
  }
  keys() {
    return this._reader.keys();
  }
  castToText(e11 = false) {
    return this._reader.castToText(e11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/ASourceChunk.js
var i9 = class {
  size() {
    return this.reader.getSize();
  }
  get fields() {
    return this.reader.fields;
  }
  invalidate() {
    this._aggregateIndex = null, this._aggregateIndexHash = null, this._spatialIndex = null;
  }
  queryFeaturesInBounds(e11) {
    const t19 = this._getSpatialIndex().search(e11);
    return a7.from(this.reader, t19);
  }
  getAggregateIndex(e11) {
    const r14 = JSON.stringify(e11);
    if (r14 !== this._aggregateIndexHash) {
      switch (this._aggregateIndexHash = r14, e11.type) {
        case "grid":
          this._aggregateIndex = new n12(e11);
          break;
        case "geohash":
          this._aggregateIndex = new r7(e11);
      }
      this._aggregateIndex.insert(this.reader, this.isTiled);
    }
    return this._aggregateIndex;
  }
  _getSpatialIndex() {
    return this._spatialIndex || (this._spatialIndex = t11.fromReader(this.reader)), this._spatialIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderJSON.js
var u7 = class _u extends M2 {
  static fromFeatures(t19, r14) {
    const { objectIdField: s20, geometryType: i14 } = r14, n19 = et([], t19, i14, false, false, s20);
    for (let e11 = 0; e11 < n19.length; e11++) n19[e11].displayId = t19[e11].displayId;
    return _u.fromOptimizedFeatures(n19, r14);
  }
  static fromFeatureSet(e11, r14) {
    const s20 = ct(e11, r14.objectIdField);
    return _u.fromOptimizedFeatureSet(s20, r14);
  }
  static fromOptimizedFeatureSet(e11, t19) {
    const r14 = _u.fromOptimizedFeatures(e11.features, t19);
    return r14._exceededTransferLimit = e11.exceededTransferLimit, r14._transform = e11.transform, r14._fieldsIndex = new Z(e11.fields), r14;
  }
  static fromOptimizedFeatures(e11, t19, r14) {
    const s20 = new _u(e11, t19);
    return s20._fieldsIndex = t19.fieldsIndex, s20._transform = r14, s20;
  }
  static empty(e11) {
    return new _u([], e11);
  }
  constructor(e11, t19) {
    super(t19), this._exceededTransferLimit = false, this._featureIndex = -1, this._fieldsIndex = null, this._geometryType = t19.geometryType, this._features = e11;
  }
  get fields() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasFeatures() {
    return !!this._features.length;
  }
  get hasNext() {
    return this._featureIndex + 1 < this._features.length;
  }
  get exceededTransferLimit() {
    return this._exceededTransferLimit;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get _current() {
    return this._features[this._featureIndex];
  }
  removeIds(e11) {
    const t19 = new Set(e11);
    this._features = this._features.filter((e12) => !(null != e12.objectId && t19.has(e12.objectId)));
  }
  getSize() {
    return this._features.length;
  }
  getCursor() {
    return this.copy();
  }
  getInTransform() {
    return this._transform;
  }
  getAttributeHash() {
    let e11 = "";
    for (const t19 in this._current.attributes) e11 += this._current.attributes[t19];
    return e11;
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e11) {
    this._featureIndex = e11;
  }
  getObjectId() {
    var _a;
    return (_a = this._current) == null ? void 0 : _a.objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(e11) {
    this._current.displayId = e11;
  }
  copy() {
    const e11 = new _u(this._features, this.metadata);
    return this.copyInto(e11), e11;
  }
  next() {
    for (; ++this._featureIndex < this._features.length && !this._getExists(); ) ;
    return this._featureIndex < this._features.length;
  }
  readGeometryArea() {
    return s5(this._current) ? Nt(this._current.geometry, 2) : 0;
  }
  _readX() {
    return s5(this._current) ? this._current.geometry.coords[0] : 0;
  }
  _readY() {
    return s5(this._current) ? this._current.geometry.coords[1] : 0;
  }
  _readGeometry() {
    return s5(this._current) ? this._current.geometry ?? null : null;
  }
  _readServerCentroid() {
    return this._current.centroid;
  }
  _readAttribute(e11, t19) {
    if (!this._fieldsIndex) {
      const t20 = this._current.attributes[e11];
      if (void 0 !== t20) return t20;
      const r15 = e11.toLowerCase();
      for (const e12 in this._current.attributes) if (e12.toLowerCase() === r15) return this._current.attributes[e12];
      return;
    }
    const r14 = this._fieldsIndex.get(e11);
    if (!r14) return;
    const s20 = this._current.attributes[r14.name];
    return null == s20 ? s20 : t19 && this.fields.isDateField(e11) ? new Date(s20) : s20;
  }
  _readAttributes() {
    return this._current.attributes;
  }
  copyInto(e11) {
    super.copyInto(e11), e11._featureIndex = this._featureIndex, e11._transform = this._transform, e11._fieldsIndex = this._fieldsIndex;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/OverrideChunk.js
function r8(e11) {
  return "localEdit" === e11.chunkId;
}
var s13 = class extends i9 {
  constructor(e11, t19) {
    super(), this.metadata = e11, this.removed = /* @__PURE__ */ new Set(), this.overriddenIds = /* @__PURE__ */ new Set(), this._features = [], this.chunkId = t19, this.normalizedChunkId = t19;
  }
  get reader() {
    return u7.fromOptimizedFeatures(this._features, this.metadata);
  }
  get queryInfo() {
    return {};
  }
  get first() {
    return false;
  }
  get end() {
    return false;
  }
  get isTiled() {
    return false;
  }
  get lastLocalEditDropped() {
    return this._lastLocalEditDropped;
  }
  applyOverrides(e11) {
    this._onChange();
    const { reader: t19, removed: r14 } = e11, s20 = [], d11 = /* @__PURE__ */ new Set(), o15 = t19.getCursor(), n19 = new Set(r14);
    for (this.overriddenIds.clear(); o15.next(); ) {
      const e12 = o15.readOptimizedFeatureWorldSpace(), t20 = e12.objectId;
      s20.push(e12), d11.add(t20), this.overriddenIds.add(t20), this.removed.delete(t20);
    }
    for (const i14 of this._features) {
      const e12 = i14.objectId;
      n19.has(e12) || d11.has(e12) || (s20.push(i14), this.overriddenIds.add(e12));
    }
    this._features = s20;
    for (const i14 of d11.values()) this.removed.delete(i14);
    for (const i14 of r14) this.removed.add(i14), this.overriddenIds.add(i14);
  }
  removeOverrides(e11) {
    this._lastLocalEditDropped = performance.now(), this._onChange();
    const t19 = e11.reader.getCursor(), r14 = /* @__PURE__ */ new Set();
    for (; t19.next(); ) {
      const e12 = t19.getObjectId();
      this.overriddenIds.has(e12) && (r14.add(e12), this.overriddenIds.delete(e12));
    }
    this._features = this._features.filter((e12) => !r14.has(e12.objectId));
  }
  getTileReader(e11) {
    if (!this._features.length) return null;
    const t19 = this.queryFeaturesInBounds(e11.bounds);
    return t19.setTransformForDisplay(e11.transform), t19;
  }
  _onChange() {
    this.invalidate();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/BinningStrategy.js
var y3 = class extends t10 {
  constructor(e11, t19) {
    super(e11), this.bins = /* @__PURE__ */ new Map(), this.featureCache = /* @__PURE__ */ new Map(), this.done = false, this._store = t19;
  }
  reset() {
    this.destroy(), this.done = false;
  }
  invaldateForLocalEditDropped() {
    this.handledChunks.clear(), this.bins.clear();
  }
  destroy() {
    const e11 = this.subscription.tile.key.level;
    for (const t19 of this.featureCache.keys()) this._store.releaseDisplayIdForObjectId(`${t19}.${e11}`);
    this.bins.clear(), this.featureCache.clear(), this.handledChunks.clear();
  }
  get tile() {
    return this.subscription.tile;
  }
  *featuresWorldSpace() {
    for (const t19 of this.featureCache.values()) {
      const s20 = t19.clone();
      s20.geometry && pt(s20.geometry, s20.geometry, false, false, this.subscription.tile.transform), yield s20;
    }
  }
};
var I = class _I extends i6 {
  static async create(e11, t19, s20, a13, o15) {
    const n19 = new p2({ spatialReference: t19 }), l10 = await Promise.all(e11.fields.map(async (e12) => s11.create(n19, e12))), d11 = e11.featureFilter ? await p3.create({ geometryType: s20.metadata.geometryType, hasM: false, hasZ: false, timeInfo: s20.metadata.timeInfo, fieldsIndex: s20.metadata.fieldsIndex, spatialReference: t19, filterJSON: e11.featureFilter }) : null;
    return "geohash" === e11.index.type && await x(t19, g.WGS84), new _I(e11, d11, o15, l10, t19, s20, a13);
  }
  constructor(e11, t19, s20, r14, i14, o15, n19) {
    super(o15, n19, i14, r14), this._schema = e11, this._featureFilter = t19, this._timeZone = s20, this._metadata = i4.createFeature({ geometryType: "esriGeometryPolygon", objectIdField: "aggregateId", fieldsIndex: new Z(e11.fields).toJSON(), globalIdField: null, spatialReference: o15.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  createState(e11) {
    return new y3(e11, this._attributeStore);
  }
  async *applyLocalEdit(e11) {
    for (const t19 of this._sendStates.values()) {
      t19.reset();
      const e12 = new e7(t19.subscription, u7.empty(this._source.metadata), true, false, {});
      yield e12;
    }
  }
  displayMap(e11, t19, s20) {
    const r14 = new Map(e11.map((e12) => [t19(e12), e12])), a13 = [];
    for (const i14 of this._sendStates.values()) for (const e12 of i14.featuresWorldSpace()) {
      const { objectId: t20, displayId: i15 } = e12, o15 = r14.get(t20);
      if (null != o15) {
        const e13 = s20(i15, o15, t20);
        a13.push(e13), r14.delete(t20);
      }
    }
    return a13;
  }
  getDisplayFeatures(e11) {
    const s20 = new Set(e11), r14 = /* @__PURE__ */ new Set(), a13 = [];
    for (const i14 of this._sendStates.values()) for (const e12 of i14.featuresWorldSpace()) s20.has(e12.displayId) && !r14.has(e12.objectId) && (e12.geometry && a13.push({ ...nt(e12, this._metadata.geometryType, false, false), displayId: e12.displayId }), r14.add(e12.objectId));
    return { features: [], aggregates: a13 };
  }
  getFeatureObjectIdsForAggregate(e11) {
    for (const t19 of this._sendStates.values()) for (const s20 of t19.bins.values()) if (s20.id === e11) return Array.from(s20.containedObjectIds);
    return [];
  }
  beforeUpdateChunks() {
    const e11 = this._source.chunks();
    if (!e11.length) return;
    let t19 = false;
    for (const s20 of e11) r8(s20) && s20.lastLocalEditDropped !== this._lastHandledLocalEdit && (this._lastHandledLocalEdit = s20.lastLocalEditDropped, t19 = true);
    if (t19) for (const s20 of this._sendStates.values()) s20.invaldateForLocalEditDropped();
  }
  async *updateChunks() {
    for (const e11 of this._sendStates.values()) yield* this._update(e11, this._source);
  }
  forEachAggregateWorldSpace(e11) {
    const t19 = /* @__PURE__ */ new Set();
    for (const s20 of this._sendStates.values()) for (const r14 of s20.featuresWorldSpace()) t19.has(r14.objectId) || (e11(r14), t19.add(r14.objectId));
  }
  _createIndexOptions(e11) {
    switch (this._schema.index.type) {
      case "geohash":
        return { type: "geohash", fields: this.aggregateFields, featureFilter: this._featureFilter, geohashLevel: this._schema.index.fixBinLevel, spatialReference: this.spatialReference, timeZone: this._timeZone, scale: e11.scale };
      case "grid": {
        const t19 = this._schema.index.fixedBinLevel, s20 = null != t19 ? e11.tileInfoView.getLODInfoAt(t19).scale : e11.scale;
        return { type: "grid", fields: this.aggregateFields, cellSize: this._schema.index.size, featureFilter: this._featureFilter, spatialReference: this.spatialReference, timeZone: this._timeZone, scale: s20 };
      }
    }
  }
  async *_update(e11, t19) {
    const { handledChunks: r14, subscription: a13, bins: i14, featureCache: o15 } = e11, n19 = a13.tile;
    if (e11.done) return;
    for (const s20 of t19.chunks()) {
      if (r14.has(s20.chunkId)) continue;
      r14.add(s20.chunkId);
      const t20 = s20.queryInfo;
      if ("tileId" in t20) {
        const e12 = new e2(t20.tileId);
        if (e12.level !== n19.level || e12.world !== n19.key.world) continue;
      }
      s20.getAggregateIndex(this._createIndexOptions(e11.tile)).putBounded(i14, e11.tile.extent, e11.tile.resolution);
    }
    const l10 = [], c10 = a13.tile.transform, u10 = a13.tile.key.level;
    for (const d11 of i14.values()) {
      let e12 = o15.get(d11.id);
      if (e12) e12.attributes = d11.getAttributes();
      else {
        const t20 = d11.getGeometry(this.spatialReference, c10);
        e12 = new e(t20, d11.getAttributes(), null), t20 || (e12.centroid = d11.getGeometricCentroid(this.spatialReference, c10)), e12.objectId = d11.id, e12.displayId = this._attributeStore.createDisplayIdForObjectId(`${e12.objectId}.${u10}`), o15.set(d11.id, e12);
      }
      l10.push(e12);
    }
    this.events.emit("changed"), e11.done = !t19.updateTracking.updating;
    const p9 = u7.fromOptimizedFeatures(l10, this._metadata, c10), f6 = p9.getCursor(), g6 = e11.subscription.tile.createArcadeEvaluationOptions(this._timeZone);
    for (; f6.next(); ) this._attributeStore.setAttributeData(f6.getDisplayId(), f6, g6);
    const y9 = new i7(e11.subscription, p9, [], e11.done, {});
    yield y9;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/support/WithDisplayId.js
var s14 = class {
  constructor(s20, t19) {
    this.inner = s20, this.displayId = t19;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/ClusterStrategy.js
var y4 = 128;
var S3 = class extends t10 {
  constructor(e11) {
    super(e11), this.didSend = false, this.done = false;
  }
};
var I2 = class {
  constructor(e11, t19, s20, i14, r14) {
    this._level = e11, this._scale = t19, this._indexOptions = s20, this._clusterRadius = i14, this._store = r14, this._cells = /* @__PURE__ */ new Map(), this._handledChunks = /* @__PURE__ */ new Set(), this._statistics = /* @__PURE__ */ new Map(), this._clusters = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._clearClusters();
  }
  _clearClusters() {
    for (const e11 of this._clusters.values()) this._store.releaseDisplayIdForObjectId(e11.inner.id);
    this._clusters.clear();
  }
  *aggregatesWorldSpace() {
    for (const e11 of this._clusters.values()) {
      const s20 = e11.inner.getCentroid(null), i14 = new e(s20, e11.inner.getAttributes(), null);
      i14.objectId = e11.inner.id, i14.displayId = e11.displayId, yield i14;
    }
  }
  clusters() {
    return this._clusters.values();
  }
  updateChunks(e11, t19) {
    let s20 = false;
    for (const a13 of e11) {
      const e12 = a13.queryInfo;
      if ("tileId" in e12) {
        if (new e2(e12.tileId).level !== this._level) continue;
      }
      if (!this._handledChunks.has(a13.normalizedChunkId)) {
        this._handledChunks.add(a13.normalizedChunkId), s20 = true;
        a13.getAggregateIndex({ ...this._indexOptions, scale: this._scale }).put(this._cells);
      }
    }
    const i14 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 }, r14 = o7(this._indexOptions.spatialReference, this._scale), n19 = this._indexOptions.cellSize;
    for (const { subscription: a13 } of t19) {
      const e12 = a13.tile.bounds, t20 = Math.floor(e12[0] * r14 / n19), s21 = Math.floor(e12[1] * r14 / n19), l10 = Math.ceil(e12[2] * r14 / n19), o15 = Math.ceil(e12[3] * r14 / n19);
      i14.xMin = Math.min(i14.xMin, t20), i14.yMin = Math.min(i14.yMin, s21), i14.xMax = Math.max(i14.xMax, l10), i14.yMax = Math.max(i14.yMax, o15);
    }
    return null != this._lastCellBounds && i14.xMin === this._lastCellBounds.xMin && i14.yMin === this._lastCellBounds.yMin && i14.yMin === this._lastCellBounds.yMin && i14.yMax === this._lastCellBounds.yMax || (s20 = true, this._lastCellBounds = i14), s20 && this._clusterCells(i14), s20;
  }
  async updateStatistics(e11) {
    let t19 = false;
    for (const s20 of this._clusters.values()) s20.inner.count > 1 && (t19 = this._updateAggregateStatistics(this._statistics, s20.inner) || t19);
    if (t19) {
      const t20 = Array.from(this._statistics.entries()).map(([e12, t21]) => ({ fieldName: e12, minValue: t21.minValue, maxValue: t21.maxValue }));
      await e11.container.updateStatistics(this._level, t20);
    }
  }
  createAggregateFeatures(e11, i14) {
    const n19 = e11.subscription, a13 = [], l10 = n19.tile.transform;
    for (const o15 of this._clusters.values()) {
      let e12 = o15.inner.getCentroidX(l10);
      const i15 = o15.inner.getCentroidY(l10), d11 = n19.tile.lod, c10 = d11.wrap ? d11.worldSize[0] : null, u10 = 1 === o15.inner.count ? o15.inner.firstObjectId : o15.inner.id, h7 = o15.displayId;
      if (null != c10) if (1 === c10) {
        const n20 = new s4([], [e12, i15]), l11 = new e(n20, o15.inner.getAttributes(), null);
        l11.geometry.coords[0] -= a2, l11.objectId = u10, l11.displayId = h7, a13.push(l11);
        const d12 = new s4([], [e12, i15]), c11 = new e(d12, o15.inner.getAttributes(), null);
        c11.geometry.coords[0] += a2, c11.objectId = u10, c11.displayId = h7, a13.push(c11);
      } else e12 > a2 + a2 / 2 ? e12 -= c10 * a2 : e12 < -a2 / 2 && (e12 += c10 * a2);
      if (e12 < a2 + y4 && e12 >= -y4 && i15 < a2 + y4 && i15 >= -y4) {
        const r14 = new s4([], [e12, i15]), n20 = new e(r14, o15.inner.getAttributes(), null);
        n20.objectId = u10, n20.displayId = h7, a13.push(n20);
      }
    }
    return u7.fromOptimizedFeatures(a13, i14, n19.tile.transform);
  }
  _clusterCells(e11) {
    let t19 = Array.from(this._cells.values());
    t19 = t19.sort((e12, t20) => t20.count - e12.count);
    const s20 = [];
    for (const a13 of this._clusters.values()) s20.push(a13.inner.id);
    this._clusters.clear();
    const i14 = this._clusterRadius * (1 / o7(this._indexOptions.spatialReference, this._scale)), r14 = 1 + this._clusterRadius / this._indexOptions.cellSize, n19 = /* @__PURE__ */ new Set();
    for (const l10 of t19) {
      if (n19.has(l10.id)) continue;
      if (l10.gridX < e11.xMin || l10.gridX > e11.xMax || l10.gridY < e11.yMin || l10.gridY > e11.yMax) continue;
      const t20 = this._store.createDisplayIdForObjectId(l10.id), s21 = new s14(l10.clone(), t20);
      n19.add(l10.id), this._clusters.set(l10.id, s21);
      const o15 = l10.centroidXWorld, d11 = l10.centroidYWorld;
      for (let e12 = l10.gridY - r14; e12 <= l10.gridY + r14; e12++) for (let t21 = l10.gridX - r14; t21 <= l10.gridX + r14; t21++) {
        if (e12 === l10.gridY && t21 === l10.gridX) continue;
        const r15 = this._cells.get(l3.createId(t21, e12));
        if (!r15 || n19.has(r15.id)) continue;
        const c10 = Math.abs(r15.centroidXWorld - o15), u10 = Math.abs(r15.centroidYWorld - d11);
        c10 < i14 && u10 < i14 && (s21.inner.merge(r15), n19.add(r15.id));
      }
    }
    for (const a13 of s20) this._store.releaseDisplayIdForObjectId(a13);
  }
  _updateAggregateStatistics(e11, t19) {
    let s20 = false;
    for (const i14 of t19.statistics.values()) {
      if ("esriFieldTypeString" === i14.field.type) continue;
      const t20 = i14.value, r14 = i14.field, n19 = e11.get(r14.name);
      if (n19) {
        const { minValue: e12, maxValue: i15 } = n19, r15 = Math.min(n19.minValue, t20), a13 = Math.max(n19.maxValue, t20);
        e12 === r15 && i15 === a13 || (n19.minValue = r15, n19.maxValue = a13, s20 = true);
      } else e11.set(r14.name, { minValue: t20, maxValue: t20 }), s20 = true;
    }
    return s20;
  }
};
var x2 = class _x extends i6 {
  static async create(e11, t19, s20, i14, r14, a13) {
    const l10 = new p2({ spatialReference: s20 }), o15 = { type: "grid", fields: await Promise.all(t19.fields.map(async (e12) => s11.create(l10, e12))), spatialReference: s20, featureFilter: t19.featureFilter ? await p3.create({ geometryType: i14.metadata.geometryType, hasM: false, hasZ: false, timeInfo: i14.metadata.timeInfo, fieldsIndex: i14.metadata.fieldsIndex, spatialReference: s20, filterJSON: t19.featureFilter }) : null, cellSize: t19.clusterRadius / 4, timeZone: a13 };
    return new _x(e11, t19.clusterRadius, o15, t19.fields, i14, r14);
  }
  constructor(e11, t19, s20, r14, n19, a13) {
    super(n19, a13, s20.spatialReference, s20.fields), this._connection = e11, this._clusterRadius = t19, this._indexOptions = s20, this._cellsPerScale = /* @__PURE__ */ new Map(), this._metadata = i4.createFeature({ geometryType: "esriGeometryPoint", objectIdField: "aggregateId", fieldsIndex: new Z([...r14, ...this._source.metadata.fieldsIndex.fields, { name: "aggregateId", alias: "aggregateId", type: "esriFieldTypeOID" }]).toJSON(), globalIdField: null, spatialReference: n19.metadata.spatialReference, subtypeField: null, subtypes: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null, types: null });
  }
  get enablePixelBuffering() {
    return false;
  }
  invalidate() {
    super.invalidate();
    for (const e11 of this._cellsPerScale.values()) e11.destroy();
    this._cellsPerScale.clear();
  }
  onSubscribe(e11) {
    super.onSubscribe(e11), this._requiredLevel = e11.tile.level, this._requiredScale = e11.tile.scale;
  }
  createState(e11) {
    return new S3(e11);
  }
  async *applyLocalEdit(e11) {
    for (const t19 of this._cellsPerScale.values()) t19.destroy();
    this._cellsPerScale.clear();
    for (const t19 of this._sendStates.values()) t19.done = false;
  }
  displayMap(e11, t19, s20) {
    const i14 = new Map(e11.map((e12) => [t19(e12), e12])), r14 = [], n19 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const a13 of n19.clusters()) {
      const e12 = i14.get(a13.inner.id);
      if (null == e12) {
        if (1 === a13.inner.count) {
          const e13 = i14.get(a13.inner.firstObjectId);
          if (null != e13) {
            const t20 = s20(a13.displayId, e13, a13.inner.firstObjectId);
            r14.push(t20), i14.delete(a13.inner.firstObjectId);
          }
        }
      } else {
        const t20 = s20(a13.displayId, e12, a13.inner.id);
        r14.push(t20), i14.delete(a13.inner.id);
      }
    }
    return r14;
  }
  getDisplayFeatures(t19) {
    const s20 = new Set(t19), i14 = /* @__PURE__ */ new Set(), r14 = [], n19 = [], a13 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const l10 of a13.aggregatesWorldSpace()) if (s20.has(l10.displayId) && !i14.has(l10.displayId)) {
      const t20 = nt(l10, this._metadata.geometryType, false, false);
      if (i14.add(l10.displayId), 1 === t20.attributes.cluster_count) {
        r14.push({ ...t20, displayId: l10.displayId });
        continue;
      }
      n19.push({ ...t20, displayId: l10.displayId });
    }
    return { features: r14, aggregates: n19 };
  }
  getFeatureObjectIdsForAggregate(e11) {
    const t19 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s20 of t19.clusters()) if (s20.inner.id === e11) return Array.from(s20.inner.containedObjectIds);
    return [];
  }
  async *updateChunks() {
    const e11 = this._source.chunks();
    if (!e11.length) return;
    for (const n19 of e11) r8(n19) && n19.lastLocalEditDropped !== this._lastHandledLocalEdit && (this.invalidate(), this._lastHandledLocalEdit = n19.lastLocalEditDropped);
    const t19 = this._getClusterState(this._requiredLevel, this._requiredScale), s20 = Array.from(this._sendStates.values()).filter((e12) => e12.subscription.tile.level === this._requiredLevel);
    if (t19.updateChunks(e11, s20) || !this._source.updateTracking.updating) for (const n19 of s20) n19.subscription.tile.level === this._requiredLevel && (n19.didSend = false, n19.done = false);
    const i14 = Array.from(this._sendStates.values()).filter((e12) => e12.done).map((e12) => e12.subscription.tile.key), r14 = new Set(i14);
    for (const n19 of this._sendStates.values()) {
      if (this._source.updateTracking.updating) {
        if (i14.some((e12) => e12.containsChild(n19.subscription.tile.key))) continue;
        if (n19.subscription.tile.key.getChildKeys().every((e12) => r14.has(e12))) continue;
      }
      n19.didSend || n19.subscription.tile.level !== this._requiredLevel || (n19.didSend = true, yield* this._update(n19, t19, this._source));
    }
    await t19.updateStatistics(this._connection);
  }
  forEachAggregateWorldSpace(e11) {
    if (null == this._requiredLevel || null == this._requiredScale) return;
    const t19 = this._getClusterState(this._requiredLevel, this._requiredScale);
    for (const s20 of t19.aggregatesWorldSpace()) e11(s20);
  }
  _getClusterState(e11, t19) {
    if (null == e11 || null == t19) throw new Error("InternalError: Level and scale must be defined");
    let s20 = this._cellsPerScale.get(t19);
    return s20 || (s20 = new I2(e11, t19, this._indexOptions, this._clusterRadius, this._attributeStore), this._cellsPerScale.set(t19, s20)), s20;
  }
  async *_update(e11, t19, s20) {
    if (e11.done) return;
    const i14 = t19.createAggregateFeatures(e11, this._metadata);
    this.events.emit("changed"), e11.done = !s20.updateTracking.updating;
    const r14 = i14.getCursor(), n19 = e11.subscription.tile.createArcadeEvaluationOptions(this._indexOptions.timeZone);
    for (; r14.next(); ) this._attributeStore.setAttributeData(r14.getDisplayId(), r14, n19);
    const a13 = new e7(e11.subscription, i14, true, e11.done, {});
    yield a13;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/processor/FeatureUpdateStrategy.js
var o8 = class extends t10 {
};
var n13 = class extends e6 {
  constructor(e11, t19, s20) {
    super(e11, t19), this._timeZone = s20, this.handledChunks = /* @__PURE__ */ new Set(), this.handledChunksForIdCreation = /* @__PURE__ */ new Set(), this.handledChunksForAttributeData = /* @__PURE__ */ new Set(), this._streamLayerDeferredObjectIdsToRemove = [];
  }
  destroy() {
    super.destroy();
    for (const e11 of this._source.chunks()) this._cleanupChunkIds(e11);
  }
  invalidateAttributeData() {
    this.handledChunksForAttributeData.clear();
  }
  onSubscribe(e11) {
    super.onSubscribe(e11), this._evalOptions = e11.tile.createArcadeEvaluationOptions(this._timeZone);
  }
  createState(e11) {
    return new o8(e11);
  }
  get aggregateQueryEngine() {
    return null;
  }
  displayMap(e11, t19, s20) {
    const r14 = new Map(e11.map((e12) => [t19(e12), e12])), a13 = [];
    for (const o15 of this._source.chunks()) {
      const e12 = o15.reader.getCursor();
      for (; e12.next(); ) {
        const t20 = e12.getObjectId(), o16 = e12.getDisplayId(), n19 = r14.get(t20);
        if (null != n19) {
          const e13 = s20(o16, n19, t20);
          a13.push(e13), r14.delete(t20);
        }
      }
    }
    return a13;
  }
  getDisplayFeatures(e11) {
    const t19 = new Set(e11), s20 = /* @__PURE__ */ new Set(), r14 = [];
    for (const a13 of this._source.chunks()) {
      const e12 = a13.reader.getCursor();
      for (; e12.next(); ) {
        const a14 = e12.getObjectId(), o15 = e12.getDisplayId();
        t19.has(o15) && !s20.has(a14) && (r14.push({ ...e12.readLegacyFeatureWorldSpace(), displayId: o15 }), s20.add(a14));
      }
    }
    return { features: r14, aggregates: [] };
  }
  async *applyLocalEdit(e11) {
    const t19 = [], r14 = e11.reader.getCursor();
    for (; r14.next(); ) {
      const e12 = r14.getObjectId(), s20 = this._attributeStore.createDisplayIdForObjectId(e12);
      r14.setDisplayId(s20), this._attributeStore.setAttributeData(s20, r14, this._evalOptions), t19.push(s20);
    }
    const o15 = [];
    for (const s20 of e11.removed) {
      const e12 = this._attributeStore.getDisplayIdForObjectId(s20);
      null != e12 && o15.push(e12);
    }
    has("esri-2d-update-debug") && console.debug("FeatureUpdateStrategy.applyLocalEdit", { message: e11, modifiedDisplayIds: t19, removedDisplayIds: o15 });
    const n19 = new s13(this._source.metadata, "localEdit");
    n19.applyOverrides(e11), this.handledChunks.add(n19.chunkId), this.handledChunksForAttributeData.add(n19.chunkId), this.handledChunksForIdCreation.add(n19.chunkId);
    for (const a13 of this._sendStates.values()) a13.handledChunks.add(n19.chunkId), yield new i7(a13.subscription, null, t19, false, n19.queryInfo);
    for (const a13 of this._sendStates.values()) {
      const e12 = n19.getTileReader(a13.subscription.tile);
      yield new i7(a13.subscription, e12, o15, false, n19.queryInfo);
    }
    for (const s20 of e11.removed) this._attributeStore.releaseDisplayIdForObjectId(s20);
  }
  async *updateChunks() {
    if (this._source.chunks().length) {
      await this._updateAttributeData();
      for (const e11 of this._sendStates.values()) yield* this._update(e11);
    }
  }
  removeChunks(e11) {
    for (const t19 of e11) this.handledChunks.delete(t19.chunkId), this.handledChunksForAttributeData.delete(t19.chunkId), this._cleanupChunkIds(t19);
  }
  afterUpdateChunks() {
    for (const e11 of this._streamLayerDeferredObjectIdsToRemove) this._attributeStore.releaseDisplayIdForObjectId(e11);
    this._streamLayerDeferredObjectIdsToRemove = [];
  }
  _cleanupChunkIds(e11) {
    if (this.handledChunksForIdCreation.has(e11.chunkId)) {
      const t19 = e11.reader.getCursor();
      for (; t19.next(); ) {
        const e12 = t19.getObjectId();
        this._source.isStream ? this._streamLayerDeferredObjectIdsToRemove.push(e12) : this._attributeStore.releaseDisplayIdForObjectId(e12);
      }
      this.handledChunksForIdCreation.delete(e11.chunkId);
    }
  }
  async _updateAttributeData() {
    for (const e11 of this._source.chunks()) {
      const { chunkId: t19, reader: s20 } = e11;
      if (!this.handledChunksForIdCreation.has(t19)) {
        this.handledChunksForIdCreation.add(t19);
        const e12 = s20.getCursor();
        for (; e12.next(); ) {
          const t20 = this._attributeStore.createDisplayIdForObjectId(e12.getObjectId());
          e12.setDisplayId(t20);
        }
      }
    }
    for (const e11 of this._source.chunks()) if (!this.handledChunksForAttributeData.has(e11.chunkId)) {
      this.handledChunksForAttributeData.add(e11.chunkId);
      const t19 = e11.reader.getCursor();
      for (; t19.next(); ) {
        const e12 = t19.getDisplayId();
        this._attributeStore.setAttributeData(e12, t19, this._evalOptions);
      }
    }
  }
  *_update(e11) {
    const { subscription: t19, handledChunks: s20 } = e11;
    for (const a13 of this._source.chunks()) {
      const { chunkId: o15 } = a13;
      if (s20.has(o15)) continue;
      s20.add(o15);
      const n19 = a13.getTileReader(t19.tile);
      n19 && (yield new e7(e11.subscription, n19, false, a13.end, a13.queryInfo));
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/Processor.js
var m5 = class {
  constructor(e11, t19) {
    this._connection = e11, this._source = t19, this._version = 1, this._registry = new j2(), this._proxy = new s7({ fetch: (e12, t20) => this._connection.layerView.fetch(e12, t20), fetchDictionary: (e12, t20) => this._connection.layerView.fetchDictionary(e12, t20) }), this._attributeStore = new b4({ isLocal: false, update: (e12) => O2(this._connection.container.updateAttributeView(e12)) });
  }
  destroy() {
    var _a;
    this._proxy.destroy(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._attributeStore.destroy();
  }
  get aggregateQueryEngine() {
    var _a;
    return (_a = this._strategy) == null ? void 0 : _a.aggregateQueryEngine;
  }
  getDisplayFeatures(e11) {
    return this._strategy ? this._strategy.getDisplayFeatures(e11) : { features: [], aggregates: [] };
  }
  getDisplayIds(e11) {
    const t19 = {};
    return this._strategy ? (this._strategy.displayMap(e11, (e12) => e12, (e12, s20, r14) => {
      t19[r14] = e12;
    }), t19) : t19;
  }
  getFeatureObjectIdsForAggregate(e11) {
    return this._strategy ? this._strategy.getFeatureObjectIdsForAggregate(e11) : [];
  }
  onSubscribe(e11) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onSubscribe(e11);
  }
  onUnsubscribe(e11) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.onUnsubscribe(e11);
  }
  async update(e11, s20, r14, a13, n19) {
    var _a, _b, _c, _d, _e;
    const h7 = e11.processor, u10 = i((_a = this._schema) == null ? void 0 : _a.storage, h7.storage), p9 = i((_b = this._schema) == null ? void 0 : _b.mesh.properties, h7.mesh.properties), d11 = i((_c = this._schema) == null ? void 0 : _c.mesh.factory, h7.mesh.factory), y9 = i((_d = this._schema) == null ? void 0 : _d.mesh.strategy, h7.mesh.strategy), _5 = p9 || d11 || y9;
    if (!(u10 || _5) && !a13) return;
    has("esri-2d-update-debug") && console.debug(`Version[${this._version}] SymbolProcessor.update`, { changes: d3(this._schema, h7), schema: h7 }), this._schema = h7;
    const l10 = g.fromJSON(this._source.service.outSpatialReference), m10 = new p2({ fields: this._source.metadata.fieldsIndex, spatialReference: l10 });
    if (await this._attributeStore.update(h7.storage, m10, this._source.metadata, l10, s20), (_e = this._strategy) == null ? void 0 : _e.invalidateAttributeData(), !a13 && !_5) return;
    (y9 || p9) && await this._updateStrategy(h7.mesh.strategy, l10, n19, h7.mesh.properties.timeZone), this._updateSortKey(m10, "sortKey" in h7.mesh.properties ? h7.mesh.properties.sortKey : null);
    const b7 = new s10(m10, this._proxy, r14, this._registry);
    return (d11 || "dictionary" === h7.mesh.factory.symbology.type) && (this._factory = await s9.create(b7, h7.mesh.factory)), this._invalidate(), this._version = s20, this._connection.container.updateRenderState(this._version);
  }
  async applyLocalEdit(e11) {
    if (!this._strategy) return;
    const t19 = this._strategy.applyLocalEdit(e11);
    for await (const r14 of t19) try {
      await this._process(r14);
    } catch (s20) {
    }
  }
  async updateChunks() {
    var _a, _b;
    (_a = this._strategy) == null ? void 0 : _a.beforeUpdateChunks(), await this._doUpdateChunks(), (_b = this._strategy) == null ? void 0 : _b.afterUpdateChunks();
  }
  async removeChunks(e11) {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.removeChunks(e11), this._attributeStore.incrementDisplayIdGeneration();
  }
  updateHighlight({ highlights: e11 }) {
    if (!this._strategy) return void this._attributeStore.setHighlight(e11.map(({ objectId: e12, highlightFlags: t20 }) => ({ objectId: e12, highlightFlags: t20, displayId: -1 })), e11);
    const t19 = this._strategy.displayMap(e11, ({ objectId: e12 }) => e12, (e12, { highlightFlags: t20 }, s20) => ({ objectId: s20, displayId: e12, highlightFlags: t20 }));
    this._attributeStore.setHighlight(t19, e11);
  }
  async _doUpdateChunks() {
    if (!this._strategy) return;
    const e11 = this._strategy.updateChunks(), t19 = [], r14 = /* @__PURE__ */ new Map();
    for await (const a13 of e11) {
      let e12 = r14.get(a13.id);
      null == e12 && (e12 = new e5({ concurrency: 16, process: (e13) => this._process(e13) }), r14.set(a13.id, e12));
      const i14 = e12.push(a13).catch((e13) => f(e13));
      t19.push(i14);
    }
    try {
      await Promise.all(t19);
    } catch (i14) {
    }
    has("esri-2d-update-debug") && console.log("SendUpdates"), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.log("SendUpdates.await");
  }
  async _updateStrategy(e11, t19, s20, r14) {
    var _a;
    switch ((_a = this._strategy) == null ? void 0 : _a.destroy(), e11.type) {
      case "feature":
        this._strategy = new n13(this._source, this._attributeStore, r14);
        break;
      case "binning":
        this._strategy = await I.create(e11, t19, this._source, this._attributeStore, r14);
        break;
      case "cluster":
        this._strategy = await x2.create(this._connection, e11, t19, this._source, this._attributeStore, r14);
    }
    for (const i14 of s20) this._strategy.onSubscribe(i14);
  }
  async _updateSortKey(t19, s20) {
    var _a;
    if (this._sortInfo = u((_a = this._sortInfo) == null ? void 0 : _a.computed), null != s20) {
      const e11 = s20.byRenderer ? null : await t19.createComputedField(s20);
      this._sortInfo = { ...s20, computed: e11 };
    }
  }
  _invalidate() {
    this._strategy && this._strategy.invalidate();
  }
  async _process(e11) {
    var _a, _b, _c;
    const t19 = e11.subscription;
    if (has("esri-2d-update-debug")) {
      const s21 = t19.tile;
      console.debug(`Version[${this._version}] Tile[${s21.key.id}, end=${e11.end}] Processor._process`);
    }
    await this._fetchResources(e11), s2(t19.signal);
    const s20 = await this._write(e11, t19.tile.createArcadeEvaluationOptions((_a = this._schema) == null ? void 0 : _a.mesh.properties.timeZone)), i14 = t19.tile.tileInfoView.getLODInfoAt(t19.tile.key), { message: a13, transferList: o15 } = s20.serialize(i14), n19 = { objectIdMap: null, inner: e11.createMessage(a13, this._version, this._attributeStore.epoch) };
    if ((_b = this._schema) == null ? void 0 : _b.mesh.properties.returnMeshObjectId) {
      n19.objectIdMap = {};
      const t20 = (_c = e11.reader) == null ? void 0 : _c.getCursor();
      if (t20) for (; t20.next(); ) n19.objectIdMap[t20.getDisplayId()] = t20.getObjectId();
    }
    if (s2(t19.signal), await this._connection.container.onMessage(n19, { signal: t19.signal, transferList: o15 }), this._attributeStore.sendUpdates(), has("esri-2d-update-debug")) {
      const s21 = t19.tile;
      console.debug(`Version[${this._version}] Tile[${s21.key.id}, end=${e11.end}] Processor._process.await`);
    }
  }
  async _fetchResources(e11) {
    await this._fetchMatcherResources(e11), await this._fetchWriterResources(e11);
  }
  async _fetchMatcherResources(e11) {
    if (e11.reader) return this._factory.enqueueMatcherRequests(this._proxy, e11.reader);
  }
  async _fetchWriterResources(e11) {
    if (!e11.reader) return;
    const t19 = e11.reader.getCursor(), s20 = e11.subscription.tile.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
    for (; t19.next(); ) this._factory.enqueueWriterRequests(this._proxy, t19, s20);
    await this._proxy.fetchEnqueuedResources();
  }
  async _write(e11, t19) {
    var _a;
    const s20 = e11.subscription.tile, r14 = (_a = e11.reader) == null ? void 0 : _a.getCursor(), i14 = (r14 == null ? void 0 : r14.getSize()) ?? 0, a13 = s20.tileInfoView.tileInfo.isWrappable, o15 = s20.tileInfoView.tileInfo.spatialReference.isWGS84, c10 = new g3(s20.key, this._strategy.enablePixelBuffering, a13, o15, i14);
    if (!r14) return c10;
    const h7 = s20.createArcadeEvaluationOptions(this._schema.mesh.properties.timeZone);
    for (; r14.next(); ) {
      const e12 = this._getSortKeyValue(r14, t19);
      c10.entityStart(r14.getDisplayId(), e12), this._factory.write(c10, this._proxy, r14, h7, s20.level), c10.entityEnd();
    }
    return c10;
  }
  _getSortKeyValue(e11, t19) {
    if (!this._sortInfo) return 0;
    const { computed: s20, order: r14, byRenderer: i14 } = this._sortInfo, a13 = i14 ? this._factory.getSortKey(e11, t19) : s20 == null ? void 0 : s20.read(e11, t19);
    return null == a13 || isNaN(a13) ? 0 : a13 * ("asc" === r14 ? -1 : 1);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreStatistics.js
var t14 = class _t {
  static from(e11) {
    let n19 = 0, r14 = 0, o15 = 0;
    return e11.forEach((t19) => {
      const e12 = t19._readGeometry();
      e12 && (r14 += e12.isPoint ? 1 : e12.lengths.reduce((t20, e13) => t20 + e13, 0), o15 += e12.isPoint ? 1 : e12.lengths.length, n19 += 1);
    }), new _t(n19, r14, o15);
  }
  constructor(t19, e11, n19) {
    this.featureCount = t19, this.vertexCount = e11, this.ringCount = n19;
  }
  toJSON() {
    return { featureCount: this.featureCount, ringCount: this.featureCount, vertexCount: this.featureCount };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSourceQueryInfo.js
var o9 = 4;
function s15(e11, a13, o15) {
  const s20 = e11.orderByFields ?? o15.objectIdField + " ASC", n19 = e11.source, u10 = { returnCentroid: !(null !== n19 && "object" == typeof n19 && "path" in n19 && g2(n19.path)) && "esriGeometryPolygon" === o15.serviceGeometryType, returnGeometry: true, timeReferenceUnknownClient: o15.timeReferenceUnknownClient ?? void 0, outSpatialReference: g.fromJSON(e11.outSpatialReference), orderByFields: "memory" === e11.type ? [] : [s20], where: a13.mutable.dataFilter.definitionExpression ?? "1=1", outFields: a13.mutable.availableFields, multipatchOption: "esriGeometryMultiPatch" === o15.serviceGeometryType ? "xyFootprint" : null };
  if ("feature" === a13.type) {
    const { gdbVersion: e12, historicMoment: t19, timeExtent: r14 } = a13.mutable.dataFilter;
    return { ...u10, gdbVersion: e12, historicMoment: t19 ? new Date(t19) : null, timeExtent: r14 ? p.fromJSON(r14) : null, outFields: a13.mutable.availableFields };
  }
  return u10;
}
var n14 = class _n {
  static fromSchema(e11, t19, r14) {
    const a13 = "feature" === t19.type ? t19.mutable.dataFilter.queryScaleRanges : [];
    return new _n(s15(e11, t19, r14), a13, r14.subtypeField, t19.mutable.dataFilter.customParameters, r14.geometryType, e11.queryMetadata);
  }
  constructor(e11, t19, r14, a13, i14, o15) {
    this._queryParams = e11, this._queryScaleRanges = t19, this._subtypeField = r14, this._customParameters = a13, this._geometryType = i14, this._queryMetadata = o15;
  }
  get pageSize() {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support paged queries");
    const e11 = this._queryMetadata.supportsMaxRecordCountFactor ? o9 : null, t19 = (this._queryMetadata.maxRecordCount ?? 8e3) * (e11 ?? 1);
    return Math.min(8e3, t19);
  }
  updateHistoricMoment(e11) {
    this._queryParams.historicMoment = e11;
  }
  updateFields(e11) {
    this._queryParams.outFields = e11;
  }
  createPatchFieldsQuery(e11, t19) {
    if (!t19.getSize()) return null;
    const r14 = e11.clone();
    if ("*" === this._queryParams.outFields[0]) {
      if ("*" === (r14.outFields ?? [])[0]) return null;
      r14.outFields = this._queryParams.outFields;
    } else {
      const e12 = new Set(this._queryParams.outFields), a13 = [];
      for (const r15 of e12) t19.hasField(r15) || a13.push(r15);
      if (0 === a13.length) return null;
      r14.outFields = a13;
    }
    return r14.returnGeometry = false, r14.returnCentroid = false, r14.quantizationParameters = null, r14.cacheHint = true, { inner: r14, customParameters: this._customParameters };
  }
  createQuery(e11 = {}) {
    if (!this._queryParams) throw new Error("InternalError: queryInfo should be defined");
    return { inner: new b2({ ...this._queryParams, ...e11 }), customParameters: this._customParameters };
  }
  createTileQuery(t19, r14) {
    if (null == this._queryMetadata) throw new Error("InternalError: Service does not support tile queries");
    const a13 = this.createQuery(r14), i14 = a13.inner;
    if (this._queryScaleRanges.length) {
      const r15 = this._queryScaleRanges.filter((e11) => (!e11.minScale || e11.minScale >= t19.maxScale) && (!e11.maxScale || e11.maxScale <= t19.minScale)).map((e11) => e11.subtypeCode);
      if (r15.length) {
        const t20 = `${this._subtypeField} IN (${r15})`;
        i14.where = n4(i14.where, t20);
      }
    }
    if (i14.quantizationParameters = r14.quantizationParameters ?? t19.getQuantizationParameters(), i14.resultType = "tile", i14.geometry = t19.extent, this._queryMetadata.supportsQuantization ? "esriGeometryPolyline" === this._geometryType && (i14.maxAllowableOffset = t19.resolution * has("feature-polyline-generalization-factor")) : "esriGeometryPolyline" !== this._geometryType && "esriGeometryPolygon" !== this._geometryType || (i14.maxAllowableOffset = t19.resolution, "esriGeometryPolyline" === this._geometryType && (i14.maxAllowableOffset *= has("feature-polyline-generalization-factor"))), i14.defaultSpatialReferenceEnabled = this._queryMetadata.supportsDefaultSpatialReference, i14.compactGeometryEnabled = this._queryMetadata.supportsCompactGeometry, this._queryMetadata.supportsMaxRecordCountFactor && (i14.maxRecordCountFactor = o9), has("esri-tiles-debug")) {
      const e11 = t19.id.replaceAll("/", ".");
      a13.customParameters = a13.customParameters ? { ...a13.customParameters, tileId: e11 } : { tileId: e11 };
    }
    return a13;
  }
  createPagedTileQuery(e11, t19) {
    const r14 = this.pageSize;
    return this.createTileQuery(e11, { start: r14 * t19, num: r14, returnExceededLimitFeatures: true });
  }
  createPagedQuery(e11) {
    const t19 = this.pageSize;
    return this.createQuery({ start: t19 * e11, num: t19, returnExceededLimitFeatures: true, maxRecordCountFactor: o9 });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamMessenger.js
var a8 = 2500;
var o10 = class extends b {
  constructor(e11) {
    super(), this._connection = e11, this._enabledEventTypes = /* @__PURE__ */ new Set(), this._updateInfo = { websocket: 0, client: 0 }, this._lastTime = performance.now(), this._queuedCommands = [], this.addHandles([d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.connectionStatus) ?? "disconnected";
    }, (e12) => {
      this._layerView.setProperty({ propertyName: "pipelineConnectionStatus", value: e12 });
    }, { initial: true }), d2(() => {
      var _a;
      return ((_a = this._strategy) == null ? void 0 : _a.errorString) || null;
    }, (e12) => this._layerView.setProperty({ propertyName: "pipelineErrorString", value: e12 }), { initial: true })]);
  }
  destroy() {
    this._strategy = null, this.removeAllHandles();
  }
  get _layerView() {
    return this._connection.layerView;
  }
  set strategy(e11) {
    null == this._strategy && this._resetUpdateInfo(performance.now());
    const t19 = "event-handles";
    this.removeHandles(t19), null != e11 && (this.addHandles([e11.events.on("data-received", (e12) => this._onFeature(e12)), e11.events.on("message-received", (e12) => this._onWebSocketMessage(e12)), e11.events.on("features-updated", (e12) => this._onUpdate(e12)), e11.events.on("tick", () => this._onTick())], t19), this._queuedCommands.forEach((t20) => t20(e11)), this._queuedCommands = []), this._strategy = e11;
  }
  updateCustomParameters(e11) {
    null != e11 && this._callOrEnqueue((t19) => t19.updateCustomParameters(e11));
  }
  sendMessageToSocket(e11) {
    this._callOrEnqueue((t19) => t19.sendMessageToSocket(e11));
  }
  sendMessageToClient(e11) {
    this._callOrEnqueue((t19) => t19.sendMessageToClient(e11));
  }
  enableEvent(e11, t19) {
    t19 ? this._enabledEventTypes.add(e11) : this._enabledEventTypes.delete(e11);
  }
  disconnect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.disconnect();
  }
  connect() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.connect();
  }
  clear() {
    var _a;
    (_a = this._strategy) == null ? void 0 : _a.clear();
  }
  _onWebSocketMessage(e11) {
    this._enabledEventTypes.has("message-received") && this._layerView.emitEvent({ name: "message-received", event: e11 });
  }
  _onFeature(e11) {
    this._updateInfo.websocket++, this._enabledEventTypes.has("data-received") && this._layerView.emitEvent({ name: "data-received", event: { attributes: e11.attributes, centroid: e11.centroid, geometry: e11.geometry } });
  }
  _onUpdate(e11) {
    this._updateInfo.client += e11;
  }
  _onTick() {
    const e11 = performance.now(), t19 = e11 - this._lastTime;
    if (t19 > a8) {
      const s20 = Math.round(this._updateInfo.client / (t19 / 1e3)), n19 = Math.round(this._updateInfo.websocket / (t19 / 1e3));
      this._resetUpdateInfo(e11), this._layerView.emitEvent({ name: "update-rate", event: { client: s20, websocket: n19 } });
    }
  }
  _resetUpdateInfo(e11) {
    this._lastTime = e11, this._updateInfo.client = 0, this._updateInfo.websocket = 0;
  }
  _callOrEnqueue(e11) {
    null != this._strategy ? e11(this._strategy) : this._queuedCommands.push(e11);
  }
};
r([m()], o10.prototype, "_strategy", void 0), o10 = r([a("esri.views.2d.layers.features.sources.StreamMessenger")], o10);

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ALoadStrategy.js
var r9 = class {
  constructor(r14) {
    this._store = r14, this._controller = new AbortController();
  }
  destroy() {
    this._controller.abort();
  }
  get _options() {
    return { signal: this._controller.signal };
  }
  unsafeSetQueryHistoricMoment(r14) {
    throw new Error("InternalError: LoadStrategy does not support query info");
  }
  async queryOverride(r14) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  async queryByObjectId(r14) {
    throw new Error("InternalError: LoadStrategy does not support fetching");
  }
  async addParquetFile(r14) {
    throw new Error("InternalError: LoadStrategy does not support loading blobs");
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBFHeader.js
var n15 = 268435455;
var o11 = class {
  constructor() {
    this.hasFeatures = false, this.exceededTransferLimit = false, this.fieldCount = 0, this.featureCount = 0, this.objectIdFieldIndex = 0, this.vertexCount = 0, this.offsets = { attributes: new Array(), geometry: new Array() }, this.centroid = new Array();
  }
};
function a9(a13, i14, c10 = false) {
  var _a;
  const f6 = 1, d11 = 3, u10 = 9, g6 = 12, l10 = 13, p9 = 15, h7 = a13.asUnsafe(), b7 = h7.pos(), w4 = new o11();
  let m10 = 0, y9 = 0;
  const k2 = 1, x4 = 2, I5 = 4, L3 = 3;
  let A3 = null, F2 = null, C2 = null, S5 = false;
  const j5 = [];
  for (; h7.next(); ) switch (h7.tag()) {
    case f6:
      A3 = h7.getString();
      break;
    case d11:
      F2 = h7.getString();
      break;
    case g6:
      C2 = h7.processMessage(h);
      break;
    case u10:
      if (w4.exceededTransferLimit = h7.getBool(), w4.exceededTransferLimit) {
        w4.offsets.geometry = c10 ? new Float64Array(8e3) : new Int32Array(8e3), w4.centroid = c10 ? new Float64Array(16e3) : new Int32Array(16e3);
        for (let e11 = 0; e11 < w4.centroid.length; e11++) w4.centroid[e11] = n15;
      }
      break;
    case l10: {
      const e11 = h7.processMessage(b3);
      e11.index = m10++, j5.push(e11);
      break;
    }
    case p9: {
      const e11 = h7.getLength(), t19 = h7.pos() + e11;
      if (!w4.exceededTransferLimit) {
        const e12 = w4.offsets.geometry, t20 = w4.centroid;
        e12.push(0), t20.push(n15), t20.push(n15);
      }
      !S5 && w4.exceededTransferLimit && (S5 = true, w4.offsets.attributes = c10 ? new Float64Array(8e3 * m10) : new Uint32Array(8e3 * m10));
      let s20 = y9 * m10;
      for (; h7.pos() < t19 && h7.next(); ) switch (h7.tag()) {
        case k2: {
          if (S5) w4.offsets.attributes[s20++] = h7.pos();
          else {
            w4.offsets.attributes.push(h7.pos());
          }
          const e12 = h7.getLength();
          h7.skipLen(e12);
          break;
        }
        case x4:
          if (i14) {
            const e12 = h7.getLength(), t20 = h7.pos() + e12;
            for (; h7.pos() < t20 && h7.next(); ) switch (h7.tag()) {
              case L3: {
                h7.getUInt32();
                const e13 = h7.getSInt64(), t21 = h7.getSInt64();
                w4.centroid[2 * y9] = e13, w4.centroid[2 * y9 + 1] = t21;
                break;
              }
              default:
                h7.skip();
            }
          } else {
            w4.offsets.geometry[y9] = h7.pos();
            const e12 = h7.getLength();
            w4.vertexCount += e12, h7.skipLen(e12);
          }
          break;
        case I5: {
          const e12 = h7.getLength(), t20 = h7.pos() + e12;
          for (; h7.pos() < t20 && h7.next(); ) switch (h7.tag()) {
            case L3: {
              h7.getUInt32();
              const e13 = h7.getSInt64(), t21 = h7.getSInt64();
              w4.centroid[2 * y9] = e13, w4.centroid[2 * y9 + 1] = t21;
              break;
            }
            default:
              h7.skip();
          }
          break;
        }
        default:
          h7.skip();
      }
      y9++, w4.hasFeatures = true;
      break;
    }
    default:
      h7.skip();
  }
  const U3 = A3 || F2;
  if (!U3) throw new s("FeatureSet has no objectId or globalId field name");
  return w4.fields = new Z(j5), w4.featureCount = y9, w4.fieldCount = m10, w4.objectIdFieldIndex = (_a = w4.fields.get(U3)) == null ? void 0 : _a.index, w4.transform = C2, w4.displayIds = new Uint32Array(w4.featureCount), w4.groupIds = new Uint16Array(w4.featureCount), h7.move(b7), w4;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderPBF.js
var o12 = true;
var u8 = 268435455;
var d7 = 128;
var c7 = 128e3;
var g4 = { small: { delta: new Int32Array(d7), decoded: new Int32Array(d7) }, large: { delta: new Int32Array(c7), decoded: new Int32Array(c7) } };
function _3(e11) {
  return e11 <= g4.small.delta.length ? g4.small : (e11 <= g4.large.delta.length || (g4.large.delta = new Int32Array(Math.round(1.25 * e11)), g4.large.decoded = new Int32Array(Math.round(1.25 * e11))), g4.large);
}
function l5(r14) {
  try {
    const e11 = 2, t19 = new n5(new Uint8Array(r14), new DataView(r14));
    for (; t19.next(); ) {
      if (t19.tag() === e11) return f3(t19.getMessage());
      t19.skip();
    }
  } catch (n19) {
    const r15 = new s("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: n19 });
    n.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF").error(r15);
  }
  return null;
}
function f3(e11) {
  const t19 = 1;
  for (; e11.next(); ) {
    if (e11.tag() === t19) return e11.getMessage();
    e11.skip();
  }
  return null;
}
function I3(e11) {
  const t19 = 1, r14 = 2, s20 = 3, n19 = 4, a13 = 5, i14 = 6, h7 = 7, o15 = 8, u10 = 9, d11 = e11.getLength(), c10 = e11.pos() + d11;
  for (; e11.pos() < c10 && e11.next(); ) switch (e11.tag()) {
    case t19:
      return e11.getString();
    case r14:
      return e11.getFloat();
    case s20:
      return e11.getDouble();
    case n19:
      return e11.getSInt32();
    case a13:
      return e11.getUInt32();
    case i14:
      return e11.getInt64();
    case h7:
      return e11.getUInt64();
    case o15:
      return e11.getSInt64();
    case u10:
      return e11.getBool();
    default:
      return e11.skip(), null;
  }
  return null;
}
function p6(e11, t19, r14, s20, n19, a13) {
  return 0.5 * Math.abs(e11 * s20 + r14 * a13 + n19 * t19 - e11 * a13 - r14 * t19 - n19 * s20);
}
function y5(e11, t19, r14, s20, n19) {
  if (!e11) return false;
  return 0 === t19 * n19 - s20 * r14 && t19 * s20 + r14 * n19 > 0;
}
var m6 = class _m extends M2 {
  static fromBuffer(e11, t19, r14 = false) {
    const s20 = t19.geometryType, n19 = l5(e11), a13 = a9(n19, "esriGeometryPoint" === s20, r14);
    return new _m(n19, a13, t19);
  }
  constructor(e11, t19, r14) {
    super(r14), this._hasNext = false, this._isPoints = false, this._featureIndex = -1, this._featureOffset = 0, this._cache = { area: 0, unquantGeometry: void 0, geometry: void 0, centroid: void 0, legacyFeature: void 0, optFeature: void 0 }, this._parseCaches = new Array(), this._geometryType = r14.geometryType, this._reader = e11, this._header = t19, this._hasNext = t19.hasFeatures, this._isPoints = "esriGeometryPoint" === r14.geometryType;
  }
  get _size() {
    return this._header.featureCount;
  }
  get fields() {
    return this._header.fields;
  }
  get geometryType() {
    return this._geometryType;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  get hasFeatures() {
    return this._header.hasFeatures;
  }
  get hasNext() {
    return this._hasNext;
  }
  get exceededTransferLimit() {
    return this._header.exceededTransferLimit;
  }
  getSize() {
    return this._size;
  }
  getInTransform() {
    return this._header.transform;
  }
  getCursor() {
    return this.copy();
  }
  getIndex() {
    return this._featureIndex;
  }
  setIndex(e11) {
    this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0, this._featureIndex = e11;
  }
  getAttributeHash() {
    let e11 = "";
    for (const t19 of this._header.fields.fields) e11 += this._readAttributeAtIndex(t19.index) + ".";
    return e11;
  }
  getObjectId() {
    return this._readAttributeAtIndex(this._header.objectIdFieldIndex);
  }
  getDisplayId() {
    return this._header.displayIds[this._featureIndex];
  }
  setDisplayId(e11) {
    this._header.displayIds[this._featureIndex] = e11;
  }
  readGeometryArea() {
    return this._cache.area || this._readGeometry(true), this._cache.area;
  }
  copy() {
    const e11 = this._reader.clone(), t19 = new _m(e11, this._header, this.metadata);
    return this.copyInto(t19), t19;
  }
  next() {
    for (this._cache.area = 0, this._cache.unquantGeometry = void 0, this._cache.geometry = void 0, this._cache.centroid = void 0, this._cache.legacyFeature = void 0, this._cache.optFeature = void 0; ++this._featureIndex < this._size && !this._getExists(); ) ;
    return this._featureIndex < this._size;
  }
  _readX() {
    return this._header.centroid[2 * this._featureIndex];
  }
  _readY() {
    return this._header.centroid[2 * this._featureIndex + 1];
  }
  _readServerCentroid() {
    const e11 = this._header.centroid[2 * this._featureIndex], t19 = this._header.centroid[2 * this._featureIndex + 1];
    return e11 === u8 ? null : new s4([], [e11, t19]);
  }
  _readGeometry(e11 = false) {
    if (void 0 === this._cache.geometry) {
      let r14 = null;
      if (this._isPoints) {
        if (this._header.centroid[2 * this._featureIndex] === u8) return null;
        const e12 = this._header.centroid[2 * this._featureIndex], t19 = this._header.centroid[2 * this._featureIndex + 1];
        r14 = new s4([], [e12, t19]);
      } else {
        const s20 = this._header.offsets.geometry[this._featureIndex], n19 = this._reader;
        if (0 === s20) return null;
        n19.move(s20);
        try {
          r14 = e11 ? this._parseGeometryForDisplay(n19) : this._parseGeometry(n19);
        } catch (t19) {
          return null;
        }
      }
      return 0 === (r14 == null ? void 0 : r14.coords.length) && (r14 = null), this._cache.geometry = r14, r14;
    }
    return this._cache.geometry;
  }
  _readAttribute(e11, t19) {
    const r14 = this._header.fields.get(e11);
    if (null == r14) return;
    const s20 = this._readAttributeAtIndex(r14.index), n19 = this._header.fields.isDateField(r14.name);
    return t19 ? null == s20 ? s20 : n19 ? new Date(s20) : s20 : s20;
  }
  _readAttributes() {
    const e11 = {};
    for (const t19 of this._header.fields.fields) e11[t19.name] = this._readAttributeAtIndex(t19.index);
    return e11;
  }
  copyInto(e11) {
    super.copyInto(e11), e11._featureIndex = this._featureIndex, e11._featureOffset = this._featureOffset, e11._hasNext = this._hasNext, e11._parseCaches = this._parseCaches;
  }
  _readAttributeAtIndex(e11) {
    let t19 = this._parseCaches[e11];
    if (t19 || (t19 = new a3(this.getSize()), this._parseCaches[e11] = t19), t19.has(this._featureIndex)) return t19.get(this._featureIndex);
    const r14 = this._header.offsets.attributes[this._featureIndex * this._header.fieldCount + e11], s20 = this._reader;
    s20.move(r14);
    const n19 = I3(s20);
    return t19.set(this._featureIndex, n19), n19;
  }
  _readGeometryDeltaDecoded(e11 = false) {
    if (void 0 === this._cache.unquantGeometry) {
      const t19 = this._readGeometry(e11);
      if (!t19) return this._cache.unquantGeometry = void 0, null;
      if (!this.getInTransform()) return this._cache.unquantGeometry = t19, t19;
      const r14 = _3(t19.coords.length).decoded, s20 = t19.clone(r14), n19 = s20.coords;
      let a13 = 0;
      for (const e12 of s20.lengths) {
        for (let t20 = 1; t20 < e12; t20++) {
          const e13 = 2 * (a13 + t20), r15 = 2 * (a13 + t20 - 1);
          n19[e13] += n19[r15], n19[e13 + 1] += n19[r15 + 1];
        }
        a13 += e12;
      }
      return this._cache.unquantGeometry = s20, s20;
    }
    return this._cache.unquantGeometry;
  }
  _parseGeometry(e11) {
    const t19 = 2, r14 = 3, s20 = e11.asUnsafe(), a13 = s20.getLength(), i14 = s20.pos() + a13, h7 = [], o15 = [];
    for (; s20.pos() < i14 && s20.next(); ) switch (s20.tag()) {
      case t19: {
        const e12 = s20.getUInt32(), t20 = s20.pos() + e12;
        for (; s20.pos() < t20; ) o15.push(s20.getUInt32());
        break;
      }
      case r14: {
        const e12 = s20.getUInt32(), t20 = s20.pos() + e12;
        for (h7.push(s20.getSInt64()), h7.push(s20.getSInt64()), this.hasZ && s20.getSInt64(), this.hasM && s20.getSInt64(); s20.pos() < t20; ) h7.push(s20.getSInt64()), h7.push(s20.getSInt64()), this.hasZ && s20.getSInt64(), this.hasM && s20.getSInt64();
        break;
      }
      default:
        s20.skip();
    }
    return new s4(o15, h7);
  }
  _parseGeometryForDisplay(e11) {
    const t19 = 2, s20 = 3, a13 = e11.asUnsafe(), i14 = a13.getLength(), h7 = a13.pos() + i14, u10 = [], d11 = [];
    let c10 = 0, g6 = 0, l10 = null, f6 = 0;
    const I5 = "esriGeometryPolygon" === this.geometryType, m10 = "esriGeometryPolyline" === this.geometryType, x4 = I5 || m10;
    for (; a13.pos() < h7 && a13.next(); ) switch (a13.tag()) {
      case t19: {
        const e12 = a13.getUInt32(), t20 = a13.pos() + e12;
        for (; a13.pos() < t20; ) {
          const e13 = a13.getUInt32();
          u10.push(e13), c10 += e13;
        }
        l10 = _3(2 * c10).delta;
        break;
      }
      case s20: {
        a13.getUInt32();
        const e12 = 2 + (this.hasZ ? 1 : 0) + (this.hasM ? 1 : 0);
        n2(l10);
        for (const t20 of u10) if (g6 + e12 * t20 > l10.length) for (let e13 = 0; e13 < t20; e13++) a13.getSInt32(), a13.getSInt32(), this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32();
        else if (I5 && o12) {
          const e13 = this.getAreaSimplificationThreshold(t20, this._header.vertexCount);
          let r14 = 2, s21 = 1;
          const n19 = false;
          let i15 = a13.getSInt32(), h8 = a13.getSInt32();
          l10[g6++] = i15, l10[g6++] = h8, this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32();
          let o15 = a13.getSInt32(), u11 = a13.getSInt32();
          for (this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32(); r14 < t20; ) {
            let t21 = a13.getSInt32(), n20 = a13.getSInt32();
            this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32();
            const d12 = i15 + o15, c11 = h8 + u11;
            p6(i15, h8, d12, c11, d12 + t21, c11 + n20) >= e13 ? (f6 += -0.5 * (d12 - i15) * (c11 + h8), s21 > 1 && y5(x4, l10[g6 - 2], l10[g6 - 1], o15, u11) ? (l10[g6 - 2] += o15, l10[g6 - 1] += u11) : (l10[g6++] = o15, l10[g6++] = u11, s21++), i15 = d12, h8 = c11) : (t21 += o15, n20 += u11), o15 = t21, u11 = n20, r14++;
          }
          s21 < 3 || n19 ? g6 -= 2 * s21 : (f6 += -0.5 * (i15 + o15 - i15) * (h8 + u11 + h8), y5(x4, l10[g6 - 2], l10[g6 - 1], o15, u11) ? (l10[g6 - 2] += o15, l10[g6 - 1] += u11, d11.push(s21)) : (l10[g6++] = o15, l10[g6++] = u11, d11.push(++s21)));
        } else {
          let e13 = 0, r14 = a13.getSInt32(), s21 = a13.getSInt32();
          this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32(), l10[g6++] = r14, l10[g6++] = s21, e13 += 1;
          for (let n19 = 1; n19 < t20; n19++) {
            const t21 = a13.getSInt32(), i15 = a13.getSInt32(), h8 = r14 + t21, o15 = s21 + i15;
            f6 += -0.5 * (h8 - r14) * (o15 + s21), this.hasZ && a13.getSInt32(), this.hasM && a13.getSInt32(), n19 > 2 && y5(x4, l10[g6 - 2], l10[g6 - 1], t21, i15) ? (l10[g6 - 2] += t21, l10[g6 - 1] += i15) : (l10[g6++] = t21, l10[g6++] = i15, e13 += 1), r14 = h8, s21 = o15;
          }
          d11.push(e13);
        }
        break;
      }
      default:
        a13.skip();
    }
    return this._cache.area = f6, d11.length ? new s4(d11, l10) : null != l10 ? this._createQuantizedExtrudedGeometry(l10[0], l10[1]) : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/support/queryAdapters.js
var c8 = class {
  constructor(t19, e11) {
    this.service = t19, this._metadata = e11;
  }
  destroy() {
  }
};
function m7(t19, e11) {
  switch (t19.type) {
    case "memory":
      return new l6(t19, e11);
    case "ogc":
      return new y6(t19, e11);
    case "feature-service":
      return t19.queryMetadata.supportsFormatPBF && has("featurelayer-pbf") ? new d8(t19, e11) : new f4(t19, e11);
  }
}
async function p7(e11) {
  const r14 = new c3();
  return await r14.open(e11, {}), r14;
}
var l6 = class extends c8 {
  constructor(t19, e11) {
    super(t19, e11), this._portsOpen = p7(t19.source).then((t20) => this.client = t20);
  }
  destroy() {
    this.client.close(), this.client = null;
  }
  async executeQuery(t19, e11) {
    await this._portsOpen;
    const r14 = await this.client.invoke("queryFeatures", t19.toJSON(), e11);
    return u7.fromFeatureSet(r14, this._metadata);
  }
};
var d8 = class extends c8 {
  async executeQuery(t19, e11) {
    const { data: r14 } = await d4(this.service.source, t19, e11), a13 = !t19.quantizationParameters;
    return m6.fromBuffer(r14, this._metadata, a13);
  }
};
var f4 = class extends c8 {
  async executeQuery(t19, s20) {
    var _a;
    const { source: i14, queryMetadata: u10 } = this.service;
    if (null != t19.quantizationParameters && !u10.supportsQuantization) {
      const u11 = t19.clone(), c11 = s3(u11.quantizationParameters);
      u11.quantizationParameters = null;
      const { data: m10 } = await c2(i14, u11, this._metadata.spatialReference, s20), p9 = ct(m10, this._metadata.objectIdField);
      return ft(c11, p9), u7.fromOptimizedFeatureSet(p9, this._metadata);
    }
    const { data: c10 } = await c2(i14, t19, this._metadata.spatialReference, s20);
    return "esriGeometryPoint" === this._metadata.geometryType && (c10.features = (_a = c10.features) == null ? void 0 : _a.filter((t20) => {
      if (null != t20.geometry) {
        const e11 = t20.geometry;
        return Number.isFinite(e11.x) && Number.isFinite(e11.y);
      }
      return true;
    })), u7.fromFeatureSet(c10, this._metadata);
  }
};
var y6 = class extends c8 {
  async executeQuery(t19, r14) {
    if (t19.quantizationParameters && !this.service.queryMetadata.supportsQuantization) {
      const i15 = t19.clone(), o15 = s3(i15.quantizationParameters);
      i15.quantizationParameters = null;
      const u10 = await $(this.service.source, t19, r14);
      return ft(o15, u10), u7.fromOptimizedFeatureSet(u10, this._metadata);
    }
    const i14 = await $(this.service.source, t19, r14);
    return u7.fromOptimizedFeatureSet(i14, this._metadata);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/AFetchLoadStrategy.js
var i10 = class extends r9 {
  constructor(e11, t19, r14, n19, i14) {
    super(r14), this._serviceInfo = e11, this._queryInfo = t19, this._metadata = n19, this._connection = i14, this._queue = new _({ concurrency: 16, process: async (e12) => {
      var _a;
      const t20 = { signal: (_a = e12.options) == null ? void 0 : _a.signal, query: e12.query.customParameters };
      return this._adapter.executeQuery(e12.query.inner, t20);
    } }), this._adapter = m7(e11, n19);
  }
  unsafeSetQueryHistoricMoment(e11) {
    this._queryInfo.updateHistoricMoment(e11);
  }
  async updateFields(r14) {
    this._queryInfo.updateFields(r14);
    const s20 = Array.from(this._store.chunks()).map(async (e11) => {
      const r15 = b2.fromJSON(e11.queryInfo.queryJSON);
      if (r15) try {
        return await this._tryUpdateFields(e11.reader, r15), null;
      } catch (s21) {
        return s21;
      }
    }), n19 = (await Promise.all(s20)).filter((e11) => e11);
    if (n19.length) throw new s("featurelayer-query", "Encountered errors when downloading fields", { errors: n19 });
  }
  async queryByObjectId(e11) {
    if (0 === e11.length) return u7.empty(this._metadata);
    const t19 = this._queryInfo.createQuery({ objectIds: e11 });
    return this._fetch(t19);
  }
  async _fetch(e11, t19) {
    const r14 = await this._enqueue(e11, t19);
    return await this._tryUpdateFields(r14, e11.inner), r14;
  }
  async _tryUpdateFields(e11, t19) {
    const r14 = this._queryInfo.createPatchFieldsQuery(t19, e11);
    if (!r14) return;
    const s20 = await this._enqueue(r14, this._options);
    e11.joinAttributes(s20);
  }
  async _enqueue(e11, t19) {
    return this._connection.onEvent({ type: "fetchStart" }), this._queue.push({ query: e11, options: t19 }).finally(() => {
      this._connection.onEvent({ type: "fetchEnd", done: 0 === this._queue.length });
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ATileLoadStrategy.js
var s16 = class extends i10 {
  constructor() {
    super(...arguments), this._chunksById = /* @__PURE__ */ new Map();
  }
  unload(e11) {
    this._removeChunks(e11.tile);
  }
  _addChunk(e11) {
    const s20 = e11.tile.id;
    this._chunksById.has(s20) || this._chunksById.set(s20, []);
    const t19 = e11.size();
    (t19 || e11.first || e11.end) && (has("esri-2d-update-debug") && console.debug(`Chunk[${e11.chunkId}] ATileLoadStrategy.addChunk [count=${t19}]`), this._chunksById.get(s20).push(e11), this._store.insert(e11));
  }
  _removeChunks(e11) {
    const s20 = this._chunksById.get(e11.key.id) ?? [];
    for (const t19 of s20) has("esri-2d-update-debug") && console.debug(`Tile[${e11.key.id}] Chunk[${t19.chunkId}] ATileLoadStrategy.removeChunk`), this._store.remove(t19);
    this._chunksById.delete(e11.key.id);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/DrillDownTileSourceChunk.js
var i11 = class extends i9 {
  constructor(e11, i14, t19, r14, s20, h7) {
    var _a, _b;
    super(), this._reader = e11, this._queryJSON = i14, this._tile = t19, this._sourceTile = r14, this._sourceTileDepth = s20, this._end = h7, this.chunkId = `${this._tile.key.id}.${(_a = this._sourceTile) == null ? void 0 : _a.key.id}${this._end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${(_b = this._sourceTile) == null ? void 0 : _b.key.normalizedId}${this._end ? "e" : ""}`;
  }
  get queryInfo() {
    var _a;
    return { type: "drill-down-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, sourceTileDepth: this._sourceTileDepth, sourceTileId: (_a = this._sourceTile) == null ? void 0 : _a.key.id, size: this.size(), end: this.end };
  }
  get first() {
    return 0 === this._sourceTileDepth;
  }
  get reader() {
    return this._reader;
  }
  get end() {
    return this._end;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e11) {
    return this._tile.key.id === e11.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/DrillDownTileLoadStrategy.js
var l7 = class {
  constructor(e11, o15) {
    this.subscription = e11, this._tileIdToResult = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._handles = t2([m2(e11.signal, () => this._controller.abort()), m2(o15, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get(t19) {
    return this._tileIdToResult.get(t19);
  }
  set(t19, e11) {
    this._tileIdToResult.set(t19, e11);
  }
  get options() {
    return { signal: this._controller.signal };
  }
};
var a10 = class extends s16 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t19 of this._loadStates.values()) t19.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t19) {
    this._loadStates.has(t19.key.id) || this._loadStates.set(t19.key.id, new l7(t19, this._options));
    const s20 = this._loadStates.get(t19.key.id);
    let o15;
    try {
      for await (const o16 of this._fetchChunkInfos(s20, t19.tile, 0)) {
        const { queryJSON: t20, reader: i14, sourceTile: l10, sourceTileDepth: a14, tile: n19 } = o16, h7 = new i11(i14, t20, n19, l10, a14, false);
        s2(s20.options), this._addChunk(h7);
      }
    } catch (n19) {
      o15 = n19;
    }
    const a13 = new i11(u7.empty(this._metadata), null, t19.tile, null, -1, true);
    if (this._addChunk(a13), o15) throw o15;
  }
  unload(t19) {
    var _a2;
    super.unload(t19), (_a2 = this._loadStates.get(t19.key.id)) == null ? void 0 : _a2.destroy(), this._loadStates.delete(t19.key.id);
  }
  async *_fetchChunkInfos(t19, e11, s20) {
    let o15 = t19.get(e11.id);
    const r14 = !!o15;
    if (o15 || (o15 = await this._fetchChunkInfo(t19, e11, s20), t19.set(e11.id, o15)), o15.reader.exceededTransferLimit && s20 < has("featurelayer-query-max-depth")) for (const i14 of e11.createChildTiles()) yield* this._fetchChunkInfos(t19, i14, s20 + 1);
    else r14 || (yield o15);
  }
  async _fetchChunkInfo(t19, e11, s20) {
    const o15 = t19.subscription.tile.getQuantizationParameters(), r14 = this._queryInfo.createTileQuery(e11, { returnExceededLimitFeatures: false, quantizationParameters: o15 });
    return { reader: await this._fetch(r14, t19.options), queryJSON: r14.inner.toJSON(), tile: t19.subscription.tile, sourceTile: e11, sourceTileDepth: s20 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/PagedTileSourceChunk.js
var t15 = class extends i9 {
  constructor(e11, t19, i14, r14, s20) {
    super(), this._reader = e11, this._queryJSON = t19, this._tile = i14, this._page = r14, this._end = s20, this.chunkId = `${this._tile.key.id}.${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = `${this._tile.key.normalizedId}.${this._page}${this.end ? "e" : ""}`;
  }
  get queryInfo() {
    return { type: "paged-tile", chunkId: this.chunkId, tileId: this._tile.key.id, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get page() {
    return this._page;
  }
  get tile() {
    return this._tile;
  }
  get isTiled() {
    return true;
  }
  getTileReader(e11) {
    return this._tile.key.id === e11.key.id ? this.reader : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/PagedTileLoadStrategy.js
var n16 = class {
  constructor(e11, s20) {
    this.subscription = e11, this._pages = /* @__PURE__ */ new Set(), this._controller = new AbortController(), this._done = false, this._handles = t2([m2(e11.signal, () => this._controller.abort()), m2(s20, () => this._controller.abort())]);
  }
  destroy() {
    this._controller.abort(), this._handles.remove();
  }
  get pageStart() {
    let t19 = -1;
    for (const e11 of this._pages.values()) t19 = Math.max(t19, e11);
    return t19 + 1;
  }
  get done() {
    return this._done;
  }
  get options() {
    return { signal: this._controller.signal };
  }
  add(t19, e11) {
    this._pages.add(t19), this._done = this._done || e11;
  }
};
var l8 = class extends s16 {
  constructor() {
    super(...arguments), this._loadStates = /* @__PURE__ */ new Map();
  }
  destroy() {
    super.destroy();
    for (const t19 of this._loadStates.values()) t19.destroy();
    this._loadStates.clear();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  async load(t19) {
    this._loadStates.has(t19.key.id) || this._loadStates.set(t19.key.id, new n16(t19, this._options));
    const s20 = this._loadStates.get(t19.key.id);
    let o15;
    try {
      await this._fetchPages(s20);
    } catch (l10) {
      o15 = l10;
    }
    const r14 = new t15(u7.empty(this._metadata), null, t19.tile, -1, true);
    if (c(s20.options) || this._addChunk(r14), o15) throw o15;
  }
  unload(t19) {
    var _a;
    super.unload(t19), (_a = this._loadStates.get(t19.key.id)) == null ? void 0 : _a.destroy(), this._loadStates.delete(t19.key.id);
  }
  async _fetchPages(t19) {
    const e11 = 4, o15 = 20;
    let r14 = 0, a13 = t19.pageStart, i14 = 1;
    for (; r14 < o15 && !t19.done; ) {
      const o16 = [];
      for (let e12 = 0; e12 < i14; e12++) o16.push(this._fetchChunk(t19, a13++));
      const n19 = await Promise.all(o16);
      for (const e12 of n19) (0 !== e12.size() || e12.first) && (t19.add(e12.page, !e12.reader.exceededTransferLimit), s2(t19.options), this._addChunk(e12));
      r14++, i14 = Math.min(i14 + 1, e11);
    }
  }
  async _fetchChunk(t19, e11) {
    const s20 = t19.subscription.tile, o15 = this._queryInfo.createPagedTileQuery(s20, e11), r14 = await this._fetch(o15, t19.options);
    return new t15(r14, o15.inner.toJSON(), s20, e11, false);
  }
};

// node_modules/@arcgis/core/libs/parquet/parquet.js
var n17;
var r10 = new Array(128).fill(void 0);
function _4(e11) {
  return r10[e11];
}
r10.push(void 0, null, true, false);
var i12 = r10.length;
function a11(e11) {
  e11 < 132 || (r10[e11] = i12, i12 = e11);
}
function o13(e11) {
  const t19 = _4(e11);
  return a11(e11), t19;
}
function s17(e11) {
  i12 === r10.length && r10.push(r10.length + 1);
  const t19 = i12;
  return i12 = r10[t19], r10[t19] = e11, t19;
}
var u9 = "undefined" != typeof TextDecoder ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
"undefined" != typeof TextDecoder && u9.decode();
var c9 = null;
function d9() {
  return null !== c9 && 0 !== c9.byteLength || (c9 = new Uint8Array(n17.memory.buffer)), c9;
}
function g5(e11, t19) {
  return e11 >>>= 0, u9.decode(d9().subarray(e11, e11 + t19));
}
var l9 = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => {
  n17.__wbindgen_export_0.get(e11.dtor)(e11.a, e11.b);
});
function b5(e11, t19, r14, _5) {
  const i14 = { a: e11, b: t19, cnt: 1, dtor: r14 }, a13 = (...e12) => {
    i14.cnt++;
    const t20 = i14.a;
    i14.a = 0;
    try {
      return _5(t20, i14.b, ...e12);
    } finally {
      0 == --i14.cnt ? (n17.__wbindgen_export_0.get(i14.dtor)(t20, i14.b), l9.unregister(i14)) : i14.a = t20;
    }
  };
  return a13.original = i14, l9.register(a13, i14, i14), a13;
}
function w3(e11, t19, r14) {
  n17._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h7be72b1871260ae2(e11, t19, s17(r14));
}
function f5() {
  n17.enableTracing();
}
var p8 = 0;
var y7 = "undefined" != typeof TextEncoder ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var h5 = "function" == typeof y7.encodeInto ? function(e11, t19) {
  return y7.encodeInto(e11, t19);
} : function(e11, t19) {
  const n19 = y7.encode(e11);
  return t19.set(n19), { read: e11.length, written: n19.length };
};
function m8(e11, t19, n19) {
  if (void 0 === n19) {
    const n20 = y7.encode(e11), r15 = t19(n20.length, 1) >>> 0;
    return d9().subarray(r15, r15 + n20.length).set(n20), p8 = n20.length, r15;
  }
  let r14 = e11.length, _5 = t19(r14, 1) >>> 0;
  const i14 = d9();
  let a13 = 0;
  for (; a13 < r14; a13++) {
    const t20 = e11.charCodeAt(a13);
    if (t20 > 127) break;
    i14[_5 + a13] = t20;
  }
  if (a13 !== r14) {
    0 !== a13 && (e11 = e11.slice(a13)), _5 = n19(_5, r14, r14 = a13 + 3 * e11.length, 1) >>> 0;
    const t20 = d9().subarray(_5 + a13, _5 + r14);
    a13 += h5(e11, t20).written, _5 = n19(_5, r14, a13, 1) >>> 0;
  }
  return p8 = a13, _5;
}
var F = null;
function I4() {
  return (null === F || true === F.buffer.detached || void 0 === F.buffer.detached && F.buffer !== n17.memory.buffer) && (F = new DataView(n17.memory.buffer)), F;
}
function x3(e11, t19) {
  try {
    return e11.apply(this, t19);
  } catch (r14) {
    n17.__wbindgen_exn_store(s17(r14));
  }
}
function v2(e11, t19, r14, _5) {
  n17.wasm_bindgen__convert__closures__invoke2_mut__h35729c14da098d24(e11, t19, s17(r14), s17(_5));
}
var k = null;
function T() {
  return null !== k && 0 !== k.byteLength || (k = new Uint16Array(n17.memory.buffer)), k;
}
function q(e11, t19) {
  const n19 = t19(2 * e11.length, 2) >>> 0;
  return T().set(e11, n19 / 2), p8 = e11.length, n19;
}
function R2(e11, t19, r14) {
  const _5 = m8(e11, n17.__wbindgen_malloc, n17.__wbindgen_realloc), i14 = p8;
  return o13(n17.readMetadata(_5, i14, s17(t19), s17(r14)));
}
function O3(e11, t19) {
  if (!(e11 instanceof t19)) throw new Error(`expected instance of ${t19.name}`);
  return e11.ptr;
}
function M3(e11, t19, r14, _5, i14) {
  const a13 = m8(e11, n17.__wbindgen_malloc, n17.__wbindgen_realloc), u10 = p8;
  O3(_5, S4);
  var c10 = _5.__destroy_into_raw();
  O3(i14, D);
  var d11 = i14.__destroy_into_raw();
  return o13(n17.readFile(a13, u10, s17(t19), s17(r14), c10, d11));
}
function j4(e11) {
  return null == e11;
}
var A2 = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_fieldmetadata_free(e11 >>> 0, 1));
var z3 = class _z {
  static __wrap(e11) {
    e11 >>>= 0;
    const t19 = Object.create(_z.prototype);
    return t19.__wbg_ptr = e11, A2.register(t19, t19.__wbg_ptr, t19), t19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, A2.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_fieldmetadata_free(e11, 0);
  }
  get name() {
    let e11, t19;
    try {
      const i14 = n17.__wbindgen_add_to_stack_pointer(-16);
      n17.fieldmetadata_name(i14, this.__wbg_ptr);
      var r14 = I4().getInt32(i14 + 0, true), _5 = I4().getInt32(i14 + 4, true);
      return e11 = r14, t19 = _5, g5(r14, _5);
    } finally {
      n17.__wbindgen_add_to_stack_pointer(16), n17.__wbindgen_free(e11, t19, 1);
    }
  }
  get index() {
    return n17.fieldmetadata_index(this.__wbg_ptr);
  }
  get type() {
    return ["esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeBigInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"][n17.fieldmetadata_esri_type(this.__wbg_ptr)];
  }
};
var C = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_filemetadata_free(e11 >>> 0, 1));
var S4 = class _S {
  static __wrap(e11) {
    e11 >>>= 0;
    const t19 = Object.create(_S.prototype);
    return t19.__wbg_ptr = e11, C.register(t19, t19.__wbg_ptr, t19), t19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, C.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_filemetadata_free(e11, 0);
  }
  version() {
    return n17.filemetadata_version(this.__wbg_ptr);
  }
  numRows() {
    return n17.filemetadata_numRows(this.__wbg_ptr) >>> 0;
  }
  numFields() {
    return n17.filemetadata_numFields(this.__wbg_ptr) >>> 0;
  }
  keyValueMetadata(e11) {
    try {
      const _5 = n17.__wbindgen_add_to_stack_pointer(-16), i14 = m8(e11, n17.__wbindgen_malloc, n17.__wbindgen_realloc), a13 = p8;
      n17.filemetadata_keyValueMetadata(_5, this.__wbg_ptr, i14, a13);
      var t19 = I4().getInt32(_5 + 0, true), r14 = I4().getInt32(_5 + 4, true);
      let o15;
      return 0 !== t19 && (o15 = g5(t19, r14).slice(), n17.__wbindgen_free(t19, 1 * r14, 1)), o15;
    } finally {
      n17.__wbindgen_add_to_stack_pointer(16);
    }
  }
  getFieldIndex(e11) {
    const t19 = m8(e11, n17.__wbindgen_malloc, n17.__wbindgen_realloc), r14 = p8, _5 = n17.filemetadata_getFieldIndex(this.__wbg_ptr, t19, r14);
    return 16777215 === _5 ? void 0 : _5;
  }
  getFieldByIndex(e11) {
    const t19 = n17.filemetadata_getFieldByIndex(this.__wbg_ptr, e11);
    return 0 === t19 ? void 0 : z3.__wrap(t19);
  }
};
var W = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_geometryinfodescriptor_free(e11 >>> 0, 1));
var D = class _D {
  static __wrap(e11) {
    e11 >>>= 0;
    const t19 = Object.create(_D.prototype);
    return t19.__wbg_ptr = e11, W.register(t19, t19.__wbg_ptr, t19), t19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, W.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_geometryinfodescriptor_free(e11, 0);
  }
  get wkbIndex() {
    const e11 = n17.__wbg_get_geometryinfodescriptor_wkbIndex(this.__wbg_ptr);
    return 16777215 === e11 ? void 0 : e11;
  }
  set wkbIndex(e11) {
    n17.__wbg_set_geometryinfodescriptor_wkbIndex(this.__wbg_ptr, j4(e11) ? 16777215 : e11);
  }
  get lngIndex() {
    const e11 = n17.__wbg_get_geometryinfodescriptor_lngIndex(this.__wbg_ptr);
    return 16777215 === e11 ? void 0 : e11;
  }
  set lngIndex(e11) {
    n17.__wbg_set_geometryinfodescriptor_lngIndex(this.__wbg_ptr, j4(e11) ? 16777215 : e11);
  }
  get latIndex() {
    const e11 = n17.__wbg_get_geometryinfodescriptor_latIndex(this.__wbg_ptr);
    return 16777215 === e11 ? void 0 : e11;
  }
  set latIndex(e11) {
    n17.__wbg_set_geometryinfodescriptor_latIndex(this.__wbg_ptr, j4(e11) ? 16777215 : e11);
  }
  static new() {
    const e11 = n17.geometryinfodescriptor_new();
    return _D.__wrap(e11);
  }
};
var P = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_parquetchunk_free(e11 >>> 0, 1));
var E = class _E {
  static __wrap(e11) {
    e11 >>>= 0;
    const t19 = Object.create(_E.prototype);
    return t19.__wbg_ptr = e11, P.register(t19, t19.__wbg_ptr, t19), t19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, P.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_parquetchunk_free(e11, 0);
  }
  size() {
    return n17.parquetchunk_size(this.__wbg_ptr) >>> 0;
  }
  hasField(e11) {
    return 0 !== n17.parquetchunk_hasField(this.__wbg_ptr, e11);
  }
  readX(e11) {
    return n17.parquetchunk_readX(this.__wbg_ptr, e11);
  }
  readY(e11) {
    return n17.parquetchunk_readY(this.__wbg_ptr, e11);
  }
  readAttributes(e11) {
    return o13(n17.parquetchunk_readAttributes(this.__wbg_ptr, e11));
  }
  readAttribute(e11, t19) {
    return o13(n17.parquetchunk_readAttribute(this.__wbg_ptr, e11, t19));
  }
};
var B = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_parquetfile_free(e11 >>> 0, 1));
var L2 = class e10 {
  static __wrap(t19) {
    t19 >>>= 0;
    const n19 = Object.create(e10.prototype);
    return n19.__wbg_ptr = t19, B.register(n19, n19.__wbg_ptr, n19), n19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, B.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_parquetfile_free(e11, 0);
  }
  metadata() {
    const e11 = n17.parquetfile_metadata(this.__wbg_ptr);
    return S4.__wrap(e11);
  }
  readChunksWithCallback(e11, t19) {
    const r14 = q(e11, n17.__wbindgen_malloc), _5 = p8;
    return o13(n17.parquetfile_readChunksWithCallback(this.__wbg_ptr, r14, _5, s17(t19)));
  }
  updateChunks(e11) {
    const t19 = q(e11, n17.__wbindgen_malloc), r14 = p8;
    return o13(n17.parquetfile_updateChunks(this.__wbg_ptr, t19, r14));
  }
};
var U2 = "undefined" == typeof FinalizationRegistry ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((e11) => n17.__wbg_rangeproviderjs_free(e11 >>> 0, 1));
var G = class _G {
  static __wrap(e11) {
    e11 >>>= 0;
    const t19 = Object.create(_G.prototype);
    return t19.__wbg_ptr = e11, U2.register(t19, t19.__wbg_ptr, t19), t19;
  }
  __destroy_into_raw() {
    const e11 = this.__wbg_ptr;
    return this.__wbg_ptr = 0, U2.unregister(this), e11;
  }
  free() {
    const e11 = this.__destroy_into_raw();
    n17.__wbg_rangeproviderjs_free(e11, 0);
  }
  static new(e11, t19) {
    const r14 = n17.rangeproviderjs_new(s17(e11), s17(t19));
    return _G.__wrap(r14);
  }
  static withFetch() {
    const e11 = n17.rangeproviderjs_withFetch();
    return _G.__wrap(e11);
  }
};
async function N2(e11, t19) {
  if ("function" == typeof Response && e11 instanceof Response) {
    if ("function" == typeof WebAssembly.instantiateStreaming) try {
      return await WebAssembly.instantiateStreaming(e11, t19);
    } catch (n19) {
      if ("application/wasm" == e11.headers.get("Content-Type")) throw n19;
      console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", n19);
    }
    const r14 = await e11.arrayBuffer();
    return await WebAssembly.instantiate(r14, t19);
  }
  {
    const n19 = await WebAssembly.instantiate(e11, t19);
    return n19 instanceof WebAssembly.Instance ? { instance: n19, module: e11 } : n19;
  }
}
function V2() {
  const e11 = { wbg: {} };
  return e11.wbg.__wbg_new_abda76e883ba8a5f = function() {
    return s17(new Error());
  }, e11.wbg.__wbg_stack_658279fe44541cf6 = function(e12, t19) {
    const r14 = m8(_4(t19).stack, n17.__wbindgen_malloc, n17.__wbindgen_realloc), i14 = p8;
    I4().setInt32(e12 + 4, i14, true), I4().setInt32(e12 + 0, r14, true);
  }, e11.wbg.__wbg_error_f851667af71bcfc6 = function(e12, t19) {
    let r14, _5;
    try {
      r14 = e12, _5 = t19, console.error(g5(e12, t19));
    } finally {
      n17.__wbindgen_free(r14, _5, 1);
    }
  }, e11.wbg.__wbindgen_object_drop_ref = function(e12) {
    o13(e12);
  }, e11.wbg.__wbindgen_is_function = function(e12) {
    return "function" == typeof _4(e12);
  }, e11.wbg.__wbg_self_3093d5d1f7bcb682 = function() {
    return x3(function() {
      return s17(self.self);
    }, arguments);
  }, e11.wbg.__wbg_window_3bcfc4d31bc012f8 = function() {
    return x3(function() {
      return s17(window.window);
    }, arguments);
  }, e11.wbg.__wbg_globalThis_86b222e13bdf32ed = function() {
    return x3(function() {
      return s17(globalThis.globalThis);
    }, arguments);
  }, e11.wbg.__wbg_global_e5a3fe56f8be9485 = function() {
    return x3(function() {
      return s17(global.global);
    }, arguments);
  }, e11.wbg.__wbindgen_is_undefined = function(e12) {
    return void 0 === _4(e12);
  }, e11.wbg.__wbg_newnoargs_76313bd6ff35d0f2 = function(e12, t19) {
    return s17(new Function(g5(e12, t19)));
  }, e11.wbg.__wbindgen_object_clone_ref = function(e12) {
    return s17(_4(e12));
  }, e11.wbg.__wbindgen_number_new = function(e12) {
    return s17(e12);
  }, e11.wbg.__wbg_new_525245e2b9901204 = function() {
    return s17(new Object());
  }, e11.wbg.__wbindgen_string_new = function(e12, t19) {
    return s17(g5(e12, t19));
  }, e11.wbg.__wbg_call_1084a111329e68ce = function() {
    return x3(function(e12, t19) {
      return s17(_4(e12).call(_4(t19)));
    }, arguments);
  }, e11.wbg.__wbg_call_89af060b4e1523f2 = function() {
    return x3(function(e12, t19, n19) {
      return s17(_4(e12).call(_4(t19), _4(n19)));
    }, arguments);
  }, e11.wbg.__wbg_call_7de908392845a9a5 = function() {
    return x3(function(e12, t19, n19, r14, i14) {
      return s17(_4(e12).call(_4(t19), _4(n19), _4(r14), _4(i14)));
    }, arguments);
  }, e11.wbg.__wbg_valueOf_563b3487b1b116aa = function(e12) {
    return _4(e12).valueOf();
  }, e11.wbg.__wbg_set_eacc7d73fefaafdf = function() {
    return x3(function(e12, t19, n19) {
      return Reflect.set(_4(e12), _4(t19), _4(n19));
    }, arguments);
  }, e11.wbg.__wbg_buffer_b7b08af79b0b0974 = function(e12) {
    return s17(_4(e12).buffer);
  }, e11.wbg.__wbg_new_b85e72ed1bfd57f9 = function(e12, t19) {
    try {
      var n19 = { a: e12, b: t19 }, r14 = (e13, t20) => {
        const r15 = n19.a;
        n19.a = 0;
        try {
          return v2(r15, n19.b, e13, t20);
        } finally {
          n19.a = r15;
        }
      };
      return s17(new Promise(r14));
    } finally {
      n19.a = n19.b = 0;
    }
  }, e11.wbg.__wbg_resolve_570458cb99d56a43 = function(e12) {
    return s17(Promise.resolve(_4(e12)));
  }, e11.wbg.__wbg_then_95e6edc0f89b73b1 = function(e12, t19) {
    return s17(_4(e12).then(_4(t19)));
  }, e11.wbg.__wbg_then_876bb3c633745cc6 = function(e12, t19, n19) {
    return s17(_4(e12).then(_4(t19), _4(n19)));
  }, e11.wbg.__wbg_new_ea1883e1e5e86686 = function(e12) {
    return s17(new Uint8Array(_4(e12)));
  }, e11.wbg.__wbg_length_8339fcf5d8ecd12e = function(e12) {
    return _4(e12).length;
  }, e11.wbg.__wbg_set_d1e79e2388520f18 = function(e12, t19, n19) {
    _4(e12).set(_4(t19), n19 >>> 0);
  }, e11.wbg.__wbindgen_throw = function(e12, t19) {
    throw new Error(g5(e12, t19));
  }, e11.wbg.__wbindgen_memory = function() {
    return s17(n17.memory);
  }, e11.wbg.__wbg_queueMicrotask_48421b3cc9052b68 = function(e12) {
    return s17(_4(e12).queueMicrotask);
  }, e11.wbg.__wbindgen_cb_drop = function(e12) {
    const t19 = o13(e12).original;
    if (1 == t19.cnt--) return t19.a = 0, true;
    return false;
  }, e11.wbg.__wbg_queueMicrotask_12a30234db4045d3 = function(e12) {
    queueMicrotask(_4(e12));
  }, e11.wbg.__wbg_parquetchunk_new = function(e12) {
    return s17(E.__wrap(e12));
  }, e11.wbg.__wbindgen_bigint_from_i64 = function(e12) {
    return s17(e12);
  }, e11.wbg.__wbg_parquetfile_new = function(e12) {
    return s17(L2.__wrap(e12));
  }, e11.wbg.__wbg_filemetadata_new = function(e12) {
    return s17(S4.__wrap(e12));
  }, e11.wbg.__wbindgen_closure_wrapper1401 = function(e12, t19, n19) {
    return s17(b5(e12, t19, 74, w3));
  }, e11;
}
function X(e11, t19) {
  return n17 = e11.exports, J.__wbindgen_wasm_module = t19, F = null, k = null, c9 = null, n17;
}
function $2(e11) {
  if (void 0 !== n17) return n17;
  void 0 !== e11 && Object.getPrototypeOf(e11) === Object.prototype ? { module: e11 } = e11 : console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
  const t19 = V2();
  e11 instanceof WebAssembly.Module || (e11 = new WebAssembly.Module(e11));
  return X(new WebAssembly.Instance(e11, t19), e11);
}
async function J(e11) {
  if (void 0 !== n17) return n17;
  void 0 !== e11 && Object.getPrototypeOf(e11) === Object.prototype ? { module_or_path: e11 } = e11 : console.warn("using deprecated parameters for the initialization function; pass a single object instead");
  const t19 = V2();
  ("string" == typeof e11 || "function" == typeof Request && e11 instanceof Request || "function" == typeof URL && e11 instanceof URL) && (e11 = fetch(e11));
  const { instance: r14, module: _5 } = await N2(await e11, t19);
  return X(r14, _5);
}
var Y2 = Object.freeze(Object.defineProperty({ __proto__: null, FieldMetadata: z3, FileMetadata: S4, GeometryInfoDescriptor: D, ParquetChunk: E, ParquetFile: L2, RangeProviderJs: G, default: J, enableTracing: f5, initSync: $2, readFile: M3, readMetadata: R2 }, Symbol.toStringTag, { value: "Module" }));
var H = null;
async function K2() {
  return H || (H = Q()), H;
}
async function Q() {
  const t19 = await Promise.resolve().then(() => Y2);
  return await t19.default({ module_or_path: n3("esri/libs/parquet/pkg/arcgis_parquet_bg.wasm") }), t19.enableTracing(), t19;
}
var Z2 = (e11) => async function(n19, r14, _5) {
  const i14 = e11(), { data: a13 } = await U(n19, { responseType: "array-buffer", query: i14, headers: { range: `bytes=${r14}-${_5}` } });
  return a13;
};
var ee = (e11) => async function(n19) {
  const r14 = e11(), { data: _5 } = await U(n19, { responseType: "native", method: "head", query: r14 }), i14 = _5.headers.get("Content-Length");
  if (null == i14) throw new Error("Unable to parse content length");
  return parseInt(i14, 10);
};
var te = class _te {
  static async create(e11, t19) {
    const n19 = await K2(), r14 = await n19.readMetadata(e11, Z2(t19), ee(t19));
    return _te.fromFileMetadata(r14);
  }
  static fromFileMetadata(e11) {
    const t19 = [];
    for (let n19 = 0; n19 < e11.numFields(); n19++) {
      const r14 = e11.getFieldByIndex(n19);
      t19.push({ name: r14.name, type: r14.type, alias: r14.name, index: r14.index }), r14.free();
    }
    return new _te(e11, t19);
  }
  constructor(e11, t19) {
    this._inner = e11, this.fields = t19;
  }
  destroy() {
    this._inner.free();
  }
  [Symbol.dispose]() {
    this.destroy();
  }
  get size() {
    return this._inner.numRows();
  }
  getFieldIndex(e11) {
    return this._inner.getFieldIndex(e11);
  }
  tryReadGeoMetadata() {
    const e11 = this._inner.keyValueMetadata("geo");
    return null == e11 ? null : JSON.parse(e11);
  }
};
var ne = class _ne {
  static async create(e11, t19) {
    const n19 = await K2(), r14 = Z2(t19.getCustomParameters), _5 = ee(t19.getCustomParameters), i14 = await R2(e11, r14, _5), { geometryInfo: a13 } = t19, o15 = D.new();
    "location" === a13.type ? (o15.latIndex = i14.getFieldIndex(a13.latitudeFieldName), o15.lngIndex = i14.getFieldIndex(a13.longitudeFieldName)) : o15.wkbIndex = i14.getFieldIndex(a13.primaryFieldName);
    const s20 = await n19.readFile(e11, r14, _5, i14, o15);
    return new _ne(s20, te.fromFileMetadata(s20.metadata()));
  }
  constructor(e11, t19) {
    this.inner = e11, this.metadata = t19;
  }
  destroy() {
    this.inner.free(), this.metadata.destroy();
  }
  [Symbol.dispose]() {
    this.destroy();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/FeatureSnapshotSourceChunk.js
var t16 = class extends i9 {
  constructor(e11, t19, r14, s20) {
    super(), this._reader = e11, this._queryJSON = t19, this._page = r14, this._end = s20, this.chunkId = `${this._page}${this.end ? "e" : ""}`, this.normalizedChunkId = this.chunkId;
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return 0 === this._page;
  }
  get end() {
    return this._end;
  }
  get queryInfo() {
    return { type: "snapshot", chunkId: this.chunkId, queryJSON: this._queryJSON, page: this._page, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e11) {
    const t19 = this.queryFeaturesInBounds(e11.bounds);
    return t19.setTransformForDisplay(e11.transform), t19;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReaderParquet.js
var r11 = class _r extends M2 {
  constructor(e11, t19, i14, r14, s20, n19 = new Uint32Array(r14.size())) {
    var _a, _b;
    super(e11), this._fields = t19, this._geometryInfo = i14, this._inner = r14, this._chunkId = s20, this._displayIds = n19, this._index = -1, this._size = this._inner.size(), "geometry" === this._geometryInfo.type && (this._primaryGeometryIndex = (_a = this._fields.get(this._geometryInfo.primaryFieldName)) == null ? void 0 : _a.index), null != e11.objectIdField && (this._objectIdFieldIndex = (_b = this._fields.get(e11.objectIdField)) == null ? void 0 : _b.index), this._chunkId > 65535 && console.error("Exceeded max allowed parquet reader size");
  }
  destroy() {
    super.destroy(), this._inner.free();
  }
  get fields() {
    return this._fields;
  }
  get geometryType() {
    return "esriGeometryPoint";
  }
  get hasFeatures() {
    return true;
  }
  get hasNext() {
    throw new Error("Method not implemented.");
  }
  get exceededTransferLimit() {
    return false;
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return null;
  }
  getSize() {
    return this._size;
  }
  getCursor() {
    return this.copy();
  }
  getAttributeHash() {
    let e11 = "";
    for (const t19 of this.fields.fields) e11 += this._readAttribute(t19.name, false) + ".";
    return e11;
  }
  getObjectId() {
    return null != this._objectIdFieldIndex ? this._inner.readAttribute(this._index, this._objectIdFieldIndex) : this._index << 16 | this._chunkId;
  }
  getDisplayId() {
    return this._displayIds[this._index];
  }
  setDisplayId(e11) {
    this._displayIds[this._index] = e11;
  }
  setIndex(e11) {
    this._index = e11;
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (; ++this._index < this._size && !this._getExists(); ) ;
    return this._index < this._size;
  }
  readGeometryArea() {
    throw new Error("Method not implemented.");
  }
  copy() {
    const e11 = new _r(this.metadata, this._fields, this._geometryInfo, this._inner, this._chunkId, this._displayIds);
    return this.copyInto(e11), e11;
  }
  copyInto(e11) {
    super.copyInto(e11), e11._index = this._index;
  }
  _readGeometry(i14) {
    const r14 = y(this._inner.readX(this._index), this._inner.readY(this._index));
    return new s4([], r14);
  }
  _readX() {
    var _a;
    return (_a = this._readGeometry()) == null ? void 0 : _a.coords[0];
  }
  _readY() {
    var _a;
    return (_a = this._readGeometry()) == null ? void 0 : _a.coords[1];
  }
  _readServerCentroid() {
    return null;
  }
  _readAttribute(e11, t19) {
    const i14 = this.fields.get(e11);
    if (!i14) return;
    const r14 = this._inner.readAttribute(this._index, i14.index);
    if (null == r14) return r14;
    const s20 = this.fields.isDateField(i14.name);
    return t19 ? null == r14 ? r14 : s20 ? new Date(r14) : r14 : r14;
  }
  _readAttributes() {
    const e11 = {};
    for (const t19 of this._fields.fields) this._inner.hasField(t19.index) && t19.index !== this._primaryGeometryIndex && (e11[t19.name] = this._readAttribute(t19.name, false));
    return null == this._objectIdFieldIndex && (e11.__OBJECTID = this.getObjectId()), e11;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/ParquetLoadStrategy.js
var d10 = class extends r9 {
  constructor(e11, t19, s20, a13) {
    super(a13), this._service = e11, this._metadata = t19, this._schema = s20, this._chunkId = 0, this._files = [], this._availableFields = new Set(s20.mutable.availableFields);
    const { geometryInfo: i14 } = this._service;
    "location" === i14.type ? (this._availableFields.add(i14.latitudeFieldName), this._availableFields.add(i14.longitudeFieldName)) : this._availableFields.add(i14.primaryFieldName);
  }
  destroy() {
    for (const e11 of this._files) e11.destroy();
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  async updateFields(e11) {
    await this._promise;
    const a13 = new Set(e11), i14 = i2(a13, this._availableFields);
    this._availableFields = u2(i14, this._availableFields), await Promise.all(this._files.map((e12) => {
      const t19 = Array.from(i14).map((t20) => e12.metadata.getFieldIndex(t20));
      return e12.inner.updateChunks(new Uint16Array(t19));
    }));
  }
  async load(e11) {
    return null == this._promise && (this._promise = this._download()), this._promise;
  }
  unload(e11) {
  }
  async addParquetFile(e11) {
    this._insert(e11);
  }
  async _insert(t19) {
    const s20 = await ne.create(t19, { geometryInfo: this._service.geometryInfo, outSpatialReference: this._service.outSpatialReference, getCustomParameters: () => this._schema.mutable.dataFilter.customParameters }), { geometryInfo: r14 } = this._service;
    s2(this._options);
    const { fields: o15, timeZoneByFieldName: d11 } = this._service.metadata.fieldsIndex, m10 = o15.map((e11) => ({ ...e11, index: s20.metadata.getFieldIndex(e11.name) })), h7 = Z.fromJSON({ fields: m10, timeZoneByFieldName: d11 }), u10 = new Uint16Array(Array.from(this._availableFields.values()).map((e11) => {
      var _a;
      return (_a = h7.get(e11)) == null ? void 0 : _a.index;
    }));
    await s20.inner.readChunksWithCallback(u10, (e11) => {
      const t20 = this._chunkId++, s21 = new r11(this._metadata, h7, r14, e11, t20), a13 = new t16(s21, null, t20, false);
      this._store.insert(a13);
    }), this._files.push(s20);
  }
  async _download() {
    try {
      await Promise.all(this._service.source.urls.map((e12) => this._insert(e12)));
      const e11 = new t16(u7.empty(this._metadata), null, -1, true);
      this._store.insert(e11);
    } catch (e11) {
      throw console.error(e11), e11;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/SnapshotLoadStrategy.js
var a12 = class extends i10 {
  constructor(t19, e11, o15, s20, n19, a13) {
    super(t19, e11, o15, n19, a13), this._random = new t(1e3), this._featureCount = s20;
  }
  get about() {
    return { willQueryAllFeatures: true, willQueryFullResolutionGeometry: true };
  }
  load(t19) {
    return null == this._promise && (this._promise = this._downloadPages(this._featureCount)), this._promise;
  }
  unload(t19) {
  }
  async _downloadPages(e11) {
    const r14 = Math.ceil(e11 / this._queryInfo.pageSize), o15 = Array.from({ length: r14 }, (t19, e12) => e12).sort((t19, e12) => this._random.getInt() - this._random.getInt()), a13 = await Promise.all(o15.map((t19) => this._downloadPage(t19))), i14 = new t16(u7.empty(this._metadata), null, -1, true);
    this._store.insert(i14);
    const u10 = a13.filter((t19) => t19);
    if (u10.length) throw new s("featurelayer-query", "Encountered errors when downloading data", { errors: u10 });
  }
  async _downloadPage(t19) {
    try {
      const r14 = this._queryInfo.createPagedQuery(t19), o15 = await this._fetch(r14, this._options), n19 = new t16(o15, r14.inner.toJSON(), t19, false);
      return s2(this._options), this._store.insert(n19), null;
    } catch (r14) {
      return r14;
    }
  }
};

// node_modules/@arcgis/core/layers/graphics/data/StreamFeatureManager.js
var s18 = "__esri_stream_id__";
var i13 = "__esri_timestamp__";
var r12 = 1e3;
var o14 = class {
  constructor(t19, e11, i14, r14, o15 = 128) {
    this._trackIdToObservations = /* @__PURE__ */ new Map(), this._idCounter = 0, this._lastPurge = performance.now(), this._addOrUpdated = /* @__PURE__ */ new Map(), this._removed = [], this._maxAge = 0, this._timeInfo = i14, this._purgeOptions = r14, this.store = t19, this.objectIdField = e11, this.purgeInterval = o15, this._useGeneratedIds = this.objectIdField === s18;
  }
  removeById(t19) {
    this._removed.push(t19);
  }
  removeByTrackId(t19) {
    const e11 = this._trackIdToObservations.get(t19);
    if (e11) for (const s20 of e11.entries) this._removed.push(s20);
  }
  add(s20) {
    var _a;
    if (this._useGeneratedIds) {
      const t19 = this._nextId();
      s20.attributes[this.objectIdField] = t19, s20.objectId = t19;
    } else s20.objectId = s20.attributes[this.objectIdField];
    const i14 = s20.objectId;
    if (this._addOrUpdated.set(i14, s20), this._maxAge = Math.max(this._maxAge, s20.attributes[this._timeInfo.startTimeField]), !this._timeInfo.trackIdField) return null == this._trackIdLessObservations && (this._trackIdLessObservations = new t6(1e5)), void this._trackIdLessObservations.enqueue(i14);
    const o15 = s20.attributes[this._timeInfo.trackIdField];
    if (!this._trackIdToObservations.has(o15)) {
      const s21 = null != ((_a = this._purgeOptions) == null ? void 0 : _a.maxObservations) ? this._purgeOptions.maxObservations : r12, i15 = r2(s21, 0, r12);
      this._trackIdToObservations.set(o15, new t6(i15));
    }
    const d11 = this._trackIdToObservations.get(o15), a13 = d11 == null ? void 0 : d11.enqueue(i14);
    null != a13 && (this._addOrUpdated.has(a13) ? this._addOrUpdated.delete(a13) : this._removed.push(a13));
  }
  checkForUpdates() {
    const t19 = this._getToAdd(), e11 = this._getToRemove(), s20 = performance.now();
    s20 - this._lastPurge >= this.purgeInterval && (this._purge(s20), this._lastPurge = s20);
    const r14 = [];
    if (null != e11) for (const i14 of e11) {
      const t20 = this.store.removeById(i14);
      null != t20 && r14.push(t20);
    }
    const o15 = [];
    if (null != t19) {
      const r15 = new Set(e11 ?? []);
      for (const e12 of t19) r15.has(e12.objectId) || (e12.attributes[i13] = s20, this.store.add(e12), o15.push(e12));
    }
    return !(!o15.length && !(r14 == null ? void 0 : r14.length)) && (this.store.update(o15, r14), true);
  }
  _getToAdd() {
    if (!this._addOrUpdated.size) return null;
    const t19 = new Array(this._addOrUpdated.size);
    let e11 = 0;
    return this._addOrUpdated.forEach((s20) => t19[e11++] = s20), this._addOrUpdated.clear(), t19;
  }
  _getToRemove() {
    const t19 = this._removed;
    return this._removed.length ? (this._removed = [], t19) : null;
  }
  _nextId() {
    const t19 = this._idCounter;
    return this._idCounter = (this._idCounter + 1) % 4294967294 + 1, t19;
  }
  _purge(t19) {
    const e11 = this._purgeOptions;
    null != e11 && (this._purgeSomeByDisplayCount(e11), this._purgeByAge(e11), this._purgeByAgeReceived(t19, e11), this._purgeTracks());
  }
  _purgeSomeByDisplayCount(t19) {
    if (!t19.displayCount) return;
    let e11 = this.store.size;
    if (e11 > t19.displayCount) {
      if (this._timeInfo.trackIdField) {
        for (const s20 of this._trackIdToObservations.values()) if (e11 > t19.displayCount && s20.size) {
          const t20 = s20.dequeue();
          this._removed.push(t20), e11--;
        }
      }
      if (null != this._trackIdLessObservations) {
        let s20 = e11 - t19.displayCount;
        for (; s20-- > 0; ) {
          const t20 = this._trackIdLessObservations.dequeue();
          null != t20 && this._removed.push(t20);
        }
      }
    }
  }
  _purgeByAge(t19) {
    var _a;
    const e11 = (_a = this._timeInfo) == null ? void 0 : _a.startTimeField;
    if (!t19.age || !e11) return;
    const s20 = 60 * t19.age * 1e3, i14 = this._maxAge - s20;
    this.store.forEach((t20) => {
      t20.attributes[e11] < i14 && this._removed.push(t20.objectId);
    });
  }
  _purgeByAgeReceived(t19, e11) {
    if (!e11.ageReceived) return;
    const s20 = t19 - 60 * e11.ageReceived * 1e3;
    this.store.forEach((t20) => {
      t20.attributes[i13] < s20 && this._removed.push(t20.objectId);
    });
  }
  _purgeTracks() {
    this._trackIdToObservations.forEach((t19, e11) => {
      0 === t19.size && this._trackIdToObservations.delete(e11);
    });
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamConnectionState.js
var s19 = class extends b {
  constructor(r14) {
    super(r14);
  }
  get connectionStatus() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this.connection) == null ? void 0 : _a.errorString;
  }
};
r([m()], s19.prototype, "connection", void 0), r([m()], s19.prototype, "connectionStatus", null), r([m()], s19.prototype, "errorString", null), s19 = r([a("esri.views.2d.layers.features.sources.StreamConnectionState")], s19);

// node_modules/@arcgis/core/views/2d/layers/features/sources/StreamFeatureStore.js
var t17 = class {
  constructor(e11, t19) {
    this._metadata = e11, this._onUpdate = t19, this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._objectIdToFeature.size;
  }
  get reader() {
    return u7.fromFeatures([...this._objectIdToFeature.values()], this._metadata);
  }
  add(e11) {
    this._objectIdToFeature.set(e11.objectId, e11);
  }
  forEach(e11) {
    this._objectIdToFeature.forEach(e11);
  }
  removeById(e11) {
    const t19 = this._objectIdToFeature.get(e11);
    return t19 ? (this._objectIdToFeature.delete(e11), t19) : null;
  }
  clear() {
    this._objectIdToFeature = /* @__PURE__ */ new Map();
  }
  update(e11, t19) {
    this._onUpdate((e11 == null ? void 0 : e11.length) ?? 0);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/StreamSourceChunk.js
var r13 = class extends i9 {
  constructor(e11) {
    super(), this._reader = e11, this.chunkId = "stream-chunk", this.normalizedChunkId = "stream-chunk";
  }
  get reader() {
    return this._reader;
  }
  get first() {
    return true;
  }
  get end() {
    return true;
  }
  get queryInfo() {
    return { type: "stream", chunkId: this.chunkId, size: this.size(), end: this.end };
  }
  get isTiled() {
    return false;
  }
  getTileReader(e11) {
    const r14 = this.queryFeaturesInBounds(e11.bounds);
    return r14.setTransformForDisplay(e11.transform), r14;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/StreamLoadStrategy.js
var h6 = class extends r9 {
  constructor(t19, s20, o15, a13, c10) {
    super(o15), this._service = t19, this._dataFilter = s20, this._streamOptions = a13, this._metadata = c10, this._connectionState = new s19(), this._forceRefresh = false, this.events = new o();
    const { objectIdField: h7, timeInfo: m10 } = this._metadata, { purgeOptions: d11 } = s20;
    this._stagingStore = new t17(this._metadata, (e11) => this.events.emit("features-updated", e11)), this._manager = new o14(this._stagingStore, h7, m10, d11), this.connect();
  }
  destroy() {
    super.destroy(), this.disconnect();
  }
  get about() {
    return { willQueryAllFeatures: false, willQueryFullResolutionGeometry: false };
  }
  get connectionStatus() {
    return this._connectionState.connectionStatus;
  }
  get errorString() {
    var _a;
    return (_a = this._connectionState) == null ? void 0 : _a.errorString;
  }
  async refresh() {
    const e11 = null != this._chunk;
    this._manager.checkForUpdates() || !e11 || this._forceRefresh ? (this._chunk && this._store.remove(this._chunk), this._forceRefresh = false, this._chunk = new r13(this._stagingStore.reader), this._store.insert(this._chunk), this.events.emit("tick")) : this.events.emit("tick");
  }
  async updateFields(e11) {
    throw new Error("Updating available fields not supported for StreamLayer");
  }
  async load(e11) {
  }
  unload(e11) {
  }
  disconnect() {
    var _a;
    this._connection = u(this._connection), this._connectionState.connection = null, (_a = this._handlesGroup) == null ? void 0 : _a.remove();
  }
  connect() {
    if (null != this._connection) return;
    const { geometryType: e11, spatialReference: s20 } = this._metadata, { maxReconnectionAttempts: n19, maxReconnectionInterval: i14, geometryDefinition: r14, definitionExpression: a13, customParameters: c10 } = this._dataFilter;
    this._connection = r3(this._service.source, s20, this._streamOptions.outSR, e11, a13, r14, n19, i14, c10), this._handlesGroup = t2([this._connection.on("data-received", (e12) => this._onFeature(e12)), this._connection.on("message-received", (e12) => this._onWebSocketMessage(e12))]), this._connectionState.connection = this._connection;
  }
  clear() {
    this._manager.checkForUpdates(), this._stagingStore.clear(), this._forceRefresh = true;
  }
  updateCustomParameters(e11) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.updateCustomParameters(e11);
  }
  sendMessageToSocket(e11) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToSocket(e11);
  }
  sendMessageToClient(e11) {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.sendMessageToClient(e11);
  }
  _onWebSocketMessage(e11) {
    if ("type" in e11) switch (e11.type) {
      case "delete":
        if (e11.objectIds) for (const t19 of e11.objectIds) this._manager.removeById(t19);
        if (e11.trackIds) for (const t19 of e11.trackIds) this._manager.removeByTrackId(t19);
        break;
      case "clear":
        this.clear();
    }
    this.events.emit("message-received", e11);
  }
  _onFeature(e11) {
    try {
      this._manager.add(e11), this.events.emit("data-received", e11);
    } catch (t19) {
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/strategies/chunks/SourceChunkStore.js
var n18 = class {
  constructor(s20) {
    this._onChange = s20, this._chunks = /* @__PURE__ */ new Map(), this._chunksToRemove = [], this.events = new o(), this.featureAdapter = new t5();
  }
  destroy() {
    this.clear();
  }
  clear() {
    for (const e11 of this._chunks.values()) this._chunksToRemove.push(e11);
    this._chunks.clear(), null != this._localEditChunk && this._chunksToRemove.push(this._localEditChunk), this._localEditChunk = null;
  }
  *chunks() {
    this._localEditChunk && (yield this._localEditChunk), this._localOverridesChunk && (yield this._localOverridesChunk), yield* this._chunks.values();
  }
  dataChunks() {
    return this._chunks.values();
  }
  insert(e11) {
    var _a, _b;
    has("esri-2d-update-debug") && console.debug(`Chunk[${e11.chunkId}] SourceChunkStore.insert`), ((_a = this._localOverridesChunk) == null ? void 0 : _a.overriddenIds.size) && (e11.reader.removeIds(this._localOverridesChunk.overriddenIds), e11.invalidate()), ((_b = this._localEditChunk) == null ? void 0 : _b.overriddenIds.size) && this._localEditChunk.removeOverrides(e11), this._chunks.set(e11.chunkId, e11), this.events.emit("changed"), this._onChange();
  }
  remove(e11) {
    has("esri-2d-update-debug") && console.debug(`Chunk[${e11.chunkId}] SourceChunkStore.remove`), this._chunks.delete(e11.chunkId), this._chunksToRemove.push(e11);
  }
  cleanupRemovedChunks() {
    const e11 = this._chunksToRemove;
    return this._chunksToRemove = [], e11;
  }
  applyLocalOverrides(e11, s20) {
    null == this._localOverridesChunk && (this._localOverridesChunk = new s13(s20, "localOverride")), this._localOverridesChunk.applyOverrides(e11);
    for (const t19 of this._chunks.values()) t19.reader.removeIds(this._localOverridesChunk.overriddenIds), t19.invalidate();
    this.events.emit("changed");
  }
  applyLocalEdit(e11, s20) {
    null == this._localEditChunk && (this._localEditChunk = new s13(s20, "localEdit")), this._localEditChunk.applyOverrides(e11);
    for (const t19 of this._chunks.values()) t19.reader.removeIds(this._localEditChunk.overriddenIds), t19.invalidate();
    this.events.emit("changed");
  }
  forEach(e11) {
    const s20 = /* @__PURE__ */ new Set();
    for (const t19 of this.chunks()) {
      const o15 = t19.reader.getCursor();
      for (; o15.next(); ) {
        const t20 = o15.getObjectId();
        s20.has(t20) || (e11(o15.copy()), s20.add(t20));
      }
    }
  }
  forEachUnsafe(e11) {
    const s20 = /* @__PURE__ */ new Set();
    for (const t19 of this.chunks()) {
      const o15 = t19.reader.getCursor();
      for (; o15.next(); ) {
        const t20 = o15.getObjectId();
        s20.has(t20) || (e11(o15), s20.add(t20));
      }
    }
  }
  forEachInBounds(e11, s20) {
    const t19 = /* @__PURE__ */ new Set();
    for (const o15 of this.chunks()) {
      const n19 = o15.queryFeaturesInBounds(e11);
      for (; n19.next(); ) {
        const e12 = n19.getObjectId();
        t19.has(e12) || (s20(n19.copy()), t19.add(e12));
      }
    }
  }
  forEachBounds(e11, t19) {
    const o15 = u4();
    for (const s20 of e11) {
      s20.getBounds(o15) && t19(o15);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureSource.js
var b6 = class {
  constructor(t19, e11, s20, r14, a13) {
    this.service = t19, this._aggregateAdapter = e11, this._subscriptions = s20, this._onChange = r14, this._connection = a13, this._updateTracking = new d5({ debugName: "FeatureSource" }), this._didInvalidateData = false, this._store = new n18(this._onChange), this._metadata = i4.createFeature(t19.metadata);
  }
  destroy() {
    var _a, _b2;
    (_a = this._strategy) == null ? void 0 : _a.destroy(), this._store.destroy(), (_b2 = this._streamMessenger) == null ? void 0 : _b2.destroy(), "memory" === this.service.type && this.service.source.map((t19) => t19.close());
  }
  get metadata() {
    if (!this._metadata) throw new Error("InternalError: Metadata not defined. Was update called?");
    return this._metadata;
  }
  get store() {
    return this._store;
  }
  get streamMessenger() {
    return null == this._streamMessenger && this._initStreamMessenger(), this._streamMessenger;
  }
  get statistics() {
    return t14.from(this._store);
  }
  get updateTracking() {
    return this._updateTracking;
  }
  get queryEngine() {
    if (!this._queryEngine) {
      if (!this._schema) return null;
      const { dataFilter: t19 } = this._schema.mutable, e11 = this._schema.mutable.availableFields, s20 = this._metadata;
      this._queryEngine = new V({ featureStore: this._store, fieldsIndex: s20.fieldsIndex, geometryType: s20.geometryType, objectIdField: s20.objectIdField, hasM: false, hasZ: false, spatialReference: this.service.outSpatialReference, aggregateAdapter: this._aggregateAdapter, timeInfo: s20.timeInfo, definitionExpression: t19.definitionExpression, availableFields: e11 });
    }
    return this._queryEngine;
  }
  get isStream() {
    return "stream" === this._schema.type;
  }
  chunks() {
    return Array.from(this._store.chunks());
  }
  cleanupRemovedChunks() {
    return this._store.cleanupRemovedChunks();
  }
  onSubscribe(t19) {
    var _a;
    this._connection.onEvent({ type: "subscribe", tile: t19.tile.id });
    const e11 = (_a = this._strategy) == null ? void 0 : _a.load(t19);
    e11 && (e11.then(() => this._connection.onEvent({ type: "loaded", tile: t19.tile.id })).catch((e12) => this._connection.onEvent({ type: "error", tile: t19.tile.id, error: e12 })), this._updateTracking.addPromise(e11));
  }
  onResume(t19) {
    var _a;
    this._updateTracking.addPromise(d((_a = this._strategy) == null ? void 0 : _a.load(t19)));
  }
  onUnsubscribe(t19) {
    var _a;
    this._connection.onEvent({ type: "unsubscribe", tile: t19.tile.id }), (_a = this._strategy) == null ? void 0 : _a.unload(t19);
  }
  getLocalEdit(t19) {
    return this._updateTracking.addPromise(this._getGetLocalEdit(t19));
  }
  applyLocalEdit(t19) {
    this._didInvalidateData = true, this._store.applyLocalEdit(t19, this.metadata);
  }
  async update(t19, e11) {
    var _a, _b2, _c;
    const s20 = t19.source, o15 = d3((_a = this._schema) == null ? void 0 : _a.mutable, s20.mutable);
    if (!o15) return false;
    if (has("esri-2d-update-debug") && console.debug(`Version[${e11}] FeatureSource.update`, { changes: o15 }), this._schema = s20, (_b2 = this._queryEngine) == null ? void 0 : _b2.destroy(), this._queryEngine = null, "feature-service" === this.service.type && null != this.service.queryMetadata.lastEditDate && (this._lastEditDate = this.service.queryMetadata.lastEditDate), null == this._streamMessenger && "stream" === this._schema.type && this._initStreamMessenger(), y2(o15, "sourceRefreshVersion") && ((_c = this._strategy) == null ? void 0 : _c.refresh)) return await this._strategy.refresh(), true;
    if (("feature" === s20.type || "parquet" === s20.type) && y2(o15, "availableFields")) {
      if (await this._queryLastEditDateChanged() || this._didInvalidateData) this._didInvalidateData = false, await this._updateStrategy(e11);
      else {
        this._connection.onEvent({ type: "updateFieldsStart" });
        try {
          await this._strategy.updateFields(s20.mutable.availableFields), this._connection.onEvent({ type: "updateFieldsEnd" });
        } catch (n19) {
          this._connection.onEvent({ type: "updateFieldsError", error: n19 });
        }
      }
      return false;
    }
    return !(!s6(o15, "dataFilter") && !s6(o15, "sourceRefreshVersion")) && (await this._updateStrategy(e11), true);
  }
  async addParquetFile(t19) {
    this._strategy.addParquetFile(t19);
  }
  _initStreamMessenger() {
    null == this._streamMessenger && (this._streamMessenger = new o10(this._connection));
  }
  async _getGetLocalEdit(t19) {
    if (t19.historicMoment && "feature" === this._schema.type && (this._schema.mutable.dataFilter.historicMoment = t19.historicMoment, this._strategy.unsafeSetQueryHistoricMoment(new Date(t19.historicMoment))), "edit-by-feature" === t19.type) {
      const e12 = [...t19.added, ...t19.updated].map((t20) => e.fromJSON(t20, this.metadata.objectIdField));
      return { reader: u7.fromOptimizedFeatures(e12, this.metadata), removed: this._resolveIdentifiers(t19.removed) };
    }
    const e11 = this._resolveIdentifiers(t19.removed);
    if (!t19.updated.length && !t19.added.length) return { reader: u7.empty(this.metadata), removed: e11 };
    const s20 = this._resolveIdentifiers([...t19.added, ...t19.updated]);
    return { reader: await this._strategy.queryByObjectId(s20), removed: e11 };
  }
  _resolveIdentifiers(t19) {
    const e11 = [], s20 = [];
    for (const r14 of t19) null != r14.objectId && -1 !== r14.objectId ? s20.push(r14.objectId) : e11.push(r14.globalId);
    if (e11.length) {
      const t20 = new Set(e11), r14 = this.metadata.globalIdField;
      if (null == r14) throw new Error("InternalError: Recieved an edit with globalIds, but not supported by the service");
      this._store.forEachUnsafe((e12) => {
        const a13 = e12.readAttribute(r14);
        t20.has(a13) && s20.push(e12.getObjectId());
      });
    }
    return s20;
  }
  async _queryLastEditDateChanged() {
    if (null == this._lastEditDate) return false;
    const e11 = this.service.source, s20 = { ...e11.query, f: "json" }, r14 = (await U(e11.path, { query: s20, responseType: "json" })).data.editingInfo.lastEditDate;
    return r14 !== this._lastEditDate && (this._lastEditDate = r14, true);
  }
  async _createStrategy() {
    const t19 = "isSourceHosted" in this.service && this.service.isSourceHosted, e11 = Array.isArray(this.service.source), s20 = this.service.source && "collection" in this.service.source, r14 = t19 || e11 || s20;
    if ("stream" === this._schema.type) {
      const t20 = new h6(this.service, this._schema.mutable.dataFilter, this._store, { outSR: this.service.outSpatialReference }, this.metadata);
      return this._streamMessenger.strategy = t20, t20;
    }
    if ("parquet" === this._schema.type) {
      const t20 = this.service;
      return new d10(t20, this._metadata, this._schema, this._store);
    }
    const a13 = this.service, i14 = n14.fromSchema(a13, this._schema, this._metadata), o15 = await this._supportSnapshotMode(a13, i14);
    return o15 ? new a12(a13, i14, this._store, o15.featureCount, this.metadata, this._connection) : r14 ? new l8(a13, i14, this._store, this.metadata, this._connection) : new a10(a13, i14, this._store, this.metadata, this._connection);
  }
  async _updateStrategy(t19) {
    var _a;
    const e11 = await this._createStrategy();
    this._connection.onEvent({ type: "updateStrategyStart", about: e11.about });
    const r14 = !!this._strategy;
    this._store.clear(), (_a = this._strategy) == null ? void 0 : _a.destroy(), this._strategy = e11, has("esri-2d-update-debug") && console.debug(`Version[${t19}] FeatureSource.updateStrategy`, { strategy: e11 });
    const a13 = Array.from(this._subscriptions.values());
    if (!a13.length) return void this._connection.onEvent({ type: "updateStrategyEnd" });
    const i14 = Promise.all(a13.map((t20) => this._strategy.load(t20).then(() => this._connection.onEvent({ type: "loaded", tile: t20.tile.id })).catch((e12) => this._connection.onEvent({ type: "error", tile: t20.tile.id, error: e12 }))));
    this._updateTracking.addPromise(i14);
    try {
      r14 && await i14;
    } catch (o15) {
      f(o15);
    }
    this._connection.onEvent({ type: "updateStrategyEnd" }), has("esri-2d-update-debug") && console.debug(`Version[${t19}] FeatureSource.updateStrategyEnd`, { strategy: e11 });
  }
  async _supportSnapshotMode(t19, e11) {
    const { queryMetadata: s20 } = t19, r14 = s20.snapshotInfo;
    if (!r14 || !r14.supportsSnapshotMinThreshold || !r14.snapshotCountThresholds) return null;
    const a13 = t19.source, i14 = e11.createQuery();
    i14.inner.orderByFields = [], i14.inner.returnGeometry = false;
    const o15 = (await S(a13, i14.inner, { query: i14.customParameters })).data.count, { min: n19, max: h7 } = r14.snapshotCountThresholds;
    return o15 <= n19 || r14.supportsSnapshotMaxThreshold && o15 < h7 ? { featureCount: o15 } : null;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/sources/FeatureTileSubscription.js
var t18 = class {
  constructor(t19, r14) {
    this.tile = t19, this.version = r14, this._abortController = new AbortController();
  }
  get key() {
    return this.tile.key;
  }
  get signal() {
    return this._abortController.signal;
  }
  abort() {
    this._abortController.abort();
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorker.js
var m9 = class {
  constructor(e11) {
    this.inner = e11, this.resolver = L();
  }
};
var y8 = class {
  constructor() {
    this._aggregateAdapter = { getFeatureObjectIds: (e11) => this._processor.getFeatureObjectIdsForAggregate(e11) }, this._subscriptions = /* @__PURE__ */ new Map(), this._updateRequested = false, this._updateSubscriptionRequests = [], this._updateHighlightRequests = [];
  }
  destroy() {
    var _a, _b, _c;
    this._subscriptions.clear(), (_a = this._processor) == null ? void 0 : _a.destroy(), (_b = this._source) == null ? void 0 : _b.destroy(), (_c = this._handles) == null ? void 0 : _c.remove(), this._updateLocalEditsRequest = null, this._tileInfoView = null;
  }
  onAttach(e11) {
    has("esri-2d-update-debug") && console.debug("Pipeline.onAttach");
    const s20 = this._connection, i14 = z2.fromJSON(e11.tileInfoJSON);
    this._tileInfoView = new h2(i14), this._source = new b6(e11.service, this._aggregateAdapter, this._subscriptions, () => this._requestUpdate(), s20), this._processor = new m5(s20, this._source), this._handles = t2([d2(() => this._source.updateTracking.updating, () => {
      this._requestUpdate(), d(this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true }));
    })]);
  }
  onDetach() {
    has("esri-2d-update-debug") && console.debug("Pipeline.onDetach"), this.destroy();
  }
  set remoteClient(e11) {
    this._connection = new t7(e11);
  }
  get features() {
    var _a;
    const t19 = (_a = this._source) == null ? void 0 : _a.queryEngine;
    if (!t19) throw new s("no-queryEngine", "No query engine defined");
    return t19;
  }
  get aggregates() {
    var _a;
    const t19 = (_a = this._processor) == null ? void 0 : _a.aggregateQueryEngine;
    if (!t19) throw new s("no-queryEngine", "No aggregate query engine defined");
    return t19;
  }
  get processor() {
    return this._processor;
  }
  get streamMessenger() {
    return this._source.streamMessenger;
  }
  getDisplayFeatures(e11) {
    return this._processor.getDisplayFeatures(e11);
  }
  getDisplayIds(e11) {
    return this._processor.getDisplayIds(e11);
  }
  async updateSchema(e11, t19) {
    return has("esri-2d-update-debug") && this._updateSchemaRequest && console.error("InternalError: Schema already updating"), this._updateSchemaRequest = new m9({ schema: e11, version: t19 }), this._requestUpdate(), this._updateSchemaRequest.resolver.promise;
  }
  updateSubscriptions(e11) {
    const t19 = new m9(e11);
    return this._updateSubscriptionRequests.push(t19), this._requestUpdate(), t19.resolver.promise;
  }
  updateHighlight(e11) {
    const t19 = new m9(e11);
    return this._updateHighlightRequests.push(t19), this._requestUpdate(), t19.resolver.promise;
  }
  async addParquetFile(e11) {
    return this._source.addParquetFile(e11);
  }
  async onEdits(t19) {
    if (null != this._updateLocalEditsRequest) throw new s("InternalError - Already processing an edit");
    this._updateLocalEditsRequest = new m9(t19);
    const s20 = this._updateLocalEditsRequest.resolver.promise;
    return this._requestUpdate(), s20;
  }
  queryStatistics() {
    return this._source.statistics.toJSON();
  }
  async queryVisibleFeatures(e11, t19) {
    return this.features.executeQuery(e11, t19);
  }
  async queryHeatmapStatistics(e11) {
    const t19 = Math.round(u3(e11.radius));
    let s20 = Number.POSITIVE_INFINITY, i14 = Number.NEGATIVE_INFINITY;
    const r14 = "string" == typeof e11.fieldOffset, o15 = e11.fieldOffset ?? 0, n19 = Array.from(this._subscriptions.values()), u10 = this._source.chunks(), d11 = t19 ** 2, c10 = 3 / (Math.PI * d11), p9 = 2 * t19, h7 = Math.ceil(a2 / p9);
    for (const a13 of n19) {
      const t20 = a13.tile, n20 = new Float64Array(h7 * h7);
      for (const s21 of u10) {
        const i15 = s21.getTileReader(t20);
        if (!i15) continue;
        const u11 = i15.getCursor();
        for (; u11.next(); ) {
          let t21 = 1;
          if (null != e11.field) {
            const s23 = u11.readAttribute(e11.field);
            t21 = r14 ? -1 * +s23 : +s23 + o15;
          }
          const s22 = u11.readXForDisplay() / p9, i16 = u11.readYForDisplay() / p9, a14 = Math.floor(s22), l10 = Math.floor(i16);
          if (a14 < 0 || l10 < 0 || a14 >= h7 || l10 >= h7) continue;
          const g6 = ((0.5 + a14 - s22) * p9) ** 2 + ((0.5 + l10 - i16) * p9) ** 2;
          if (g6 > d11) continue;
          const _5 = t21 * (c10 * (1 - g6 / d11) ** 2);
          n20[l10 + a14 * h7] += _5;
        }
      }
      for (let e12 = 0; e12 < n20.length; e12++) s20 = Math.min(s20, n20[e12]), i14 = Math.max(i14, n20[e12]);
    }
    return { max: i14, min: s20 };
  }
  async getSampleFeatures(e11) {
    const t19 = this._source.chunks();
    if (t19.reduce((e12, t20) => e12 + t20.size(), 0) <= e11.minFeatureCount) {
      if (!this._source.updateTracking.updating) {
        const e12 = [];
        return this._source.store.forEachUnsafe((t20) => e12.push(t20.readLegacyFeatureWorldSpace())), e12;
      }
      return null;
    }
    const s20 = /* @__PURE__ */ new Set(), i14 = [], r14 = t19.map((e12) => e12.reader.getCursor()), o15 = new t(), u10 = 3 * e11.sampleSize;
    for (let n19 = 0; n19 < u10 && i14.length < e11.sampleSize; n19++) {
      const e12 = r14[o15.getIntRange(0, t19.length - 1)];
      if (0 === e12.getSize()) continue;
      const n20 = o15.getIntRange(0, e12.getSize() - 1);
      e12.setIndex(n20);
      const u11 = e12.getObjectId();
      s20.has(u11) || (s20.add(u11), i14.push(e12.readLegacyFeatureWorldSpace()));
    }
    return i14.length >= e11.sampleSize ? i14 : null;
  }
  _requestUpdate() {
    this._updateRequested || (this._updateRequested = true, t3(() => this._scheduleNextUpdate()));
  }
  _scheduleNextUpdate() {
    this._updateRequested && (this._ongoingUpdate || (this._ongoingUpdate = O2(this._doUpdate()).finally(() => {
      this._ongoingUpdate = null, this._scheduleNextUpdate();
    }), this._updateRequested = false));
  }
  _subscribe(e11) {
    const t19 = e11.tileId;
    if (this._subscriptions.has(t19)) return;
    has("esri-2d-update-debug") && console.debug(`Tile[${t19}] Pipeline.subscribe`);
    const s20 = new n8(this._tileInfoView, t19), i14 = new t18(s20, e11.version);
    this._subscriptions.set(t19, i14), this._source.onSubscribe(i14), this._processor.onSubscribe(i14);
  }
  _unsubscribe(e11) {
    const t19 = this._subscriptions.get(e11);
    t19 && (has("esri-2d-update-debug") && console.debug(`Tile[${e11}] Pipeline.unsubscribe`), t19.abort(), this._source.onUnsubscribe(t19), this._processor.onUnsubscribe(t19), this._subscriptions.delete(t19.key.id));
  }
  async _doUpdate() {
    if (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateStart"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true }), this._updateSubscriptionRequests.length) {
      const e12 = this._updateSubscriptionRequests;
      this._updateSubscriptionRequests = [];
      for (const t20 of e12) this._doUpdateSubscriptions(t20.inner), t20.resolver.resolve();
    }
    const e11 = this._updateSchemaRequest;
    if (this._updateSchemaRequest = null, null != e11) {
      const { schema: t20, version: s21 } = e11.inner;
      await this._doUpdateSchema(t20, s21);
    }
    const t19 = this._updateLocalEditsRequest;
    if (this._updateLocalEditsRequest = null, null != t19) {
      has("esri-2d-update-debug") && console.debug("Pipeline.applyEditOverride", t19.inner);
      const e12 = await this._source.getLocalEdit(t19.inner);
      await this._processor.applyLocalEdit(e12), this._source.applyLocalEdit(e12), has("esri-2d-update-debug") && console.debug("Pipeline.endEditOverride", t19.inner);
    }
    if (this._updateHighlightRequests.length) {
      const e12 = this._updateHighlightRequests;
      this._updateHighlightRequests = [];
      for (const t20 of e12) this._processor.updateHighlight(t20.inner), t20.resolver.resolve();
    }
    const s20 = this._source.cleanupRemovedChunks();
    this._processor.removeChunks(s20);
    try {
      this._subscriptions.size && (has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksStart"), await this._processor.updateChunks(), has("esri-2d-update-debug") && console.debug("Pipeline.updateChunksEnd"));
    } catch (r14) {
      f(r14);
    }
    null != t19 && t19.resolver.resolve(), null != e11 && e11.resolver.resolve(), this._updateRequested ? (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=true]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: true })) : (has("esri-2d-update-debug") && console.debug("Pipeline._doUpdateEnd [updateRequested=false, After flush]"), await this._connection.layerView.setUpdating({ data: this._source.updateTracking.updating, pipeline: this._updateRequested }));
  }
  async _doUpdateSchema(e11, t19) {
    var _a;
    has("esri-2d-update-debug") && console.debug(`Version[${t19}] Pipeline.updateStart`, { schema: e11 });
    const s20 = { tileInfo: (_a = this._tileInfoView) == null ? void 0 : _a.tileInfo }, i14 = await this._source.update(e11, t19), r14 = Array.from(this._subscriptions.values());
    await this._processor.update(e11, t19, s20, i14, r14), has("esri-2d-update-debug") && console.debug(`Version[${t19}] Pipeline.updateEnd`);
  }
  _doUpdateSubscriptions(e11) {
    has("esri-2d-update-debug") && console.debug("Pipeline.updateSubscriptions", e11);
    for (const t19 of e11.subscribe) this._subscribe(t19);
    for (const t19 of e11.unsubscribe) this._unsubscribe(t19);
  }
};
export {
  y8 as default
};
//# sourceMappingURL=FeaturePipelineWorker-CNKVOOKC.js.map
