import {
  l as l3
} from "./chunk-2RV3Y5DT.js";
import {
  i as i2
} from "./chunk-2JZHLJXP.js";
import {
  i as i3
} from "./chunk-Y4I3KFRX.js";
import {
  r as r7
} from "./chunk-CGJR3XCF.js";
import {
  j as j2,
  y as y2
} from "./chunk-KVO35ODJ.js";
import "./chunk-O2HBAYVG.js";
import "./chunk-FKL5AVF4.js";
import {
  o as o2
} from "./chunk-CKPBZSTT.js";
import {
  e as e5,
  s as s3
} from "./chunk-7E3GBXLL.js";
import {
  c,
  e as e4,
  t as t2
} from "./chunk-3T3LUDWR.js";
import "./chunk-J3GKRP7Y.js";
import "./chunk-Q3K5MAUZ.js";
import "./chunk-2XVRGGEF.js";
import "./chunk-DPVSO6BH.js";
import {
  E as E3
} from "./chunk-U6IFI7EK.js";
import {
  t
} from "./chunk-MYNRH67A.js";
import "./chunk-JMY2H33H.js";
import {
  L,
  l as l2
} from "./chunk-IMODYMGW.js";
import {
  E as E2,
  I as I2
} from "./chunk-CQZSH27Y.js";
import {
  a as a5,
  i,
  l,
  n as n3,
  r as r5
} from "./chunk-VBS2Y7KE.js";
import {
  d as d3,
  w
} from "./chunk-HCAIFU2M.js";
import "./chunk-AHZHHHCW.js";
import {
  h as h2
} from "./chunk-P4TUSPKE.js";
import "./chunk-HB2JTNV2.js";
import "./chunk-DLJHW32W.js";
import "./chunk-BLBULF2O.js";
import {
  n as n2
} from "./chunk-YX36GZBB.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import "./chunk-BXIXSFGX.js";
import "./chunk-TRMW5XQP.js";
import "./chunk-HBU7EMDX.js";
import {
  E as E4,
  e as e6,
  r as r6
} from "./chunk-JRUJALSE.js";
import {
  p as p3
} from "./chunk-QQRGQ74V.js";
import {
  h as h3,
  s as s2
} from "./chunk-O67P2KE3.js";
import "./chunk-73FHIZIF.js";
import "./chunk-ICIPRMPO.js";
import "./chunk-NEDBRPQY.js";
import "./chunk-H2FDONTV.js";
import {
  e as e3
} from "./chunk-QLRZN73K.js";
import "./chunk-CGJUTDVJ.js";
import {
  g
} from "./chunk-WVLGRCY6.js";
import "./chunk-QEJMJI2R.js";
import "./chunk-EHD5KM2T.js";
import "./chunk-AEKV7TWM.js";
import {
  m as m2,
  p as p2
} from "./chunk-QJXYURT2.js";
import "./chunk-JUN5XSQC.js";
import {
  r as r4
} from "./chunk-MCZMPI2A.js";
import {
  D,
  F,
  G,
  I,
  O,
  R
} from "./chunk-KV3S4QI2.js";
import "./chunk-ECMDQ4LS.js";
import {
  M,
  f as f2,
  h,
  o
} from "./chunk-D6FJTDNK.js";
import "./chunk-LP6TMAPE.js";
import "./chunk-RENLZYKC.js";
import {
  z
} from "./chunk-5PCP47ZJ.js";
import "./chunk-IYJHGZBJ.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-GNY4KZ34.js";
import {
  e as e2
} from "./chunk-WPERPIJF.js";
import {
  d as d2,
  p
} from "./chunk-43W2AR4R.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-VBJTBJYL.js";
import {
  p as p4
} from "./chunk-SW3IBIJ7.js";
import "./chunk-E54MA7AH.js";
import "./chunk-6TU4HBID.js";
import {
  d
} from "./chunk-VILGTHTP.js";
import "./chunk-ATEWWVHG.js";
import "./chunk-LEOFRCUR.js";
import "./chunk-CP4GPQHD.js";
import "./chunk-IZSNXKMJ.js";
import "./chunk-IOKAACTA.js";
import "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-SMFCDOAJ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-44C2A72D.js";
import "./chunk-DIKY6MBW.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-GGCWKF4X.js";
import "./chunk-6D5XULXX.js";
import "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import {
  E,
  a as a4,
  u as u2
} from "./chunk-Z2DWZ5IF.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import {
  j2 as j
} from "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-6YWQXXBX.js";
import {
  s3 as s
} from "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import {
  Et
} from "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import {
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a2,
  r as r2
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  a as a3,
  b,
  f,
  y
} from "./chunk-GRW2QIBT.js";
import {
  e,
  r as r3,
  u
} from "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  a,
  n2 as n
} from "./chunk-PKLD5YJF.js";
import {
  A2 as A
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RectangleBinPack.js
var e7 = class {
  constructor(e9, t8) {
    this._width = 0, this._height = 0, this._free = [], this._width = e9, this._height = t8, this._free.push(new t(0, 0, e9, t8));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(e9, t8) {
    if (e9 > this._width || t8 > this._height) return new t();
    let i8 = null, s6 = -1;
    for (let h8 = 0; h8 < this._free.length; ++h8) {
      const w2 = this._free[h8];
      e9 <= w2.width && t8 <= w2.height && (null === i8 || w2.y <= i8.y && w2.x <= i8.x) && (i8 = w2, s6 = h8);
    }
    return null === i8 ? new t() : (this._free.splice(s6, 1), i8.width < i8.height ? (i8.width > e9 && this._free.push(new t(i8.x + e9, i8.y, i8.width - e9, t8)), i8.height > t8 && this._free.push(new t(i8.x, i8.y + t8, i8.width, i8.height - t8))) : (i8.width > e9 && this._free.push(new t(i8.x + e9, i8.y, i8.width - e9, i8.height)), i8.height > t8 && this._free.push(new t(i8.x, i8.y + t8, e9, i8.height - t8))), new t(i8.x, i8.y, e9, t8));
  }
  release(h8) {
    for (let e9 = 0; e9 < this._free.length; ++e9) {
      const t8 = this._free[e9];
      if (t8.y === h8.y && t8.height === h8.height && t8.x + t8.width === h8.x) t8.width += h8.width;
      else if (t8.x === h8.x && t8.width === h8.width && t8.y + t8.height === h8.y) t8.height += h8.height;
      else if (h8.y === t8.y && h8.height === t8.height && h8.x + h8.width === t8.x) t8.x = h8.x, t8.width += h8.width;
      else {
        if (h8.x !== t8.x || h8.width !== t8.width || h8.y + h8.height !== t8.y) continue;
        t8.y = h8.y, t8.height += h8.height;
      }
      this._free.splice(e9, 1), this.release(h8);
    }
    this._free.push(h8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphMosaic.js
var n4 = class {
  constructor(e9, s6, i8) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphIndex = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this.width = e9, this.height = s6, this._glyphSource = i8, this._binPack = new e7(e9 - 4, s6 - 4), this._glyphData.push(new Uint8Array(e9 * s6)), this._dirties.push(true), this._textures.push(void 0);
  }
  getGlyphItems(s6, i8) {
    const h8 = [], r13 = this._glyphSource, n9 = /* @__PURE__ */ new Set(), o6 = 1 / 256;
    for (const t8 of i8) {
      const e9 = Math.floor(t8 * o6);
      n9.add(e9);
    }
    const a8 = [];
    return n9.forEach((t8) => {
      const e9 = s6 + t8;
      if (this._rangePromises.has(e9)) a8.push(this._rangePromises.get(e9));
      else {
        const i9 = r13.getRange(s6, t8).then(() => {
          this._rangePromises.delete(e9);
        }, () => {
          this._rangePromises.delete(e9);
        });
        this._rangePromises.set(e9, i9), a8.push(i9);
      }
    }), Promise.all(a8).then(() => {
      let n10 = this._glyphIndex[s6];
      n10 || (n10 = {}, this._glyphIndex[s6] = n10);
      for (const o7 of i8) {
        const i9 = n10[o7];
        if (i9) {
          h8[o7] = { sdf: true, rect: i9.rect, metrics: i9.metrics, page: i9.page, code: o7 };
          continue;
        }
        const a9 = r13.getGlyph(s6, o7);
        if (!(a9 == null ? void 0 : a9.metrics)) continue;
        const l7 = a9.metrics;
        let c7;
        if (0 === l7.width) c7 = new t(0, 0, 0, 0);
        else {
          const e9 = 3, s7 = l7.width + 2 * e9, i10 = l7.height + 2 * e9;
          let h9 = s7 % 4 ? 4 - s7 % 4 : 4, r14 = i10 % 4 ? 4 - i10 % 4 : 4;
          1 === h9 && (h9 = 5), 1 === r14 && (r14 = 5), c7 = this._binPack.allocate(s7 + h9, i10 + r14), c7.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(void 0), this._binPack = new e7(this.width - 4, this.height - 4), c7 = this._binPack.allocate(s7 + h9, i10 + r14));
          const n11 = this._glyphData[this._currentPage], o8 = a9.bitmap;
          let g2, _3;
          if (o8) for (let t8 = 0; t8 < i10; t8++) {
            g2 = s7 * t8, _3 = this.width * (c7.y + t8 + 1) + c7.x;
            for (let t9 = 0; t9 < s7; t9++) n11[_3 + t9 + 1] = o8.at(g2 + t9);
          }
        }
        n10[o7] = { rect: c7, metrics: l7, tileIDs: null, page: this._currentPage }, h8[o7] = { sdf: true, rect: c7, metrics: l7, page: this._currentPage, code: o7 }, this._dirties[this._currentPage] = true;
      }
      return h8;
    });
  }
  removeGlyphs(t8) {
    for (const e9 in this._glyphIndex) {
      const s6 = this._glyphIndex[e9];
      if (!s6) continue;
      let i8;
      for (const e10 in s6) if (i8 = s6[e10], i8.tileIDs.delete(t8), 0 === i8.tileIDs.size) {
        const t9 = this._glyphData[i8.page], h8 = i8.rect;
        let r13, n9;
        for (let e11 = 0; e11 < h8.height; e11++) for (r13 = this.width * (h8.y + e11) + h8.x, n9 = 0; n9 < h8.width; n9++) t9[r13 + n9] = 0;
        delete s6[e10], this._dirties[i8.page] = true;
      }
    }
  }
  bind(t8, e9, n9, o6 = 0) {
    if (!this._textures[n9]) {
      const e10 = new p2();
      e10.pixelFormat = G.ALPHA, e10.wrapMode = D.CLAMP_TO_EDGE, e10.width = this.width, e10.height = this.height, this._textures[n9] = new m2(t8, e10, new Uint8Array(this.width * this.height));
    }
    const a8 = this._textures[n9];
    a8.setSamplingMode(e9), this._dirties[n9] && a8.setData(this._glyphData[n9]), t8.bindTexture(a8, o6), this._dirties[n9] = false;
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._glyphData.length = 0, this._binPack = null;
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/GlyphSource.js
var s4 = class {
  constructor(t8) {
    if (this._metrics = [], !t8) return void (this._allBitmaps = null);
    const e9 = /* @__PURE__ */ new Map();
    let s6 = 0;
    for (; t8.next(); ) switch (t8.tag()) {
      case 1: {
        const a9 = t8.getMessage();
        for (; a9.next(); ) switch (a9.tag()) {
          case 3: {
            const t9 = a9.getMessage();
            let r14, n9, i8, c7, o6, g2, h8;
            for (; t9.next(); ) switch (t9.tag()) {
              case 1:
                r14 = t9.getUInt32();
                break;
              case 2:
                n9 = t9.getBytes();
                break;
              case 3:
                i8 = t9.getUInt32();
                break;
              case 4:
                c7 = t9.getUInt32();
                break;
              case 5:
                o6 = t9.getSInt32();
                break;
              case 6:
                g2 = t9.getSInt32();
                break;
              case 7:
                h8 = t9.getUInt32();
                break;
              default:
                t9.skip();
            }
            if (t9.release(), r14) {
              const t10 = (n9 == null ? void 0 : n9.length) ?? 0;
              this._metrics[r14] = { width: i8, height: c7, left: o6, top: g2, advance: h8, startOffset: s6, length: t10 }, e9.set(r14, n9), s6 += t10;
            }
            break;
          }
          default:
            a9.skip();
        }
        a9.release();
        break;
      }
      default:
        t8.skip();
    }
    const a8 = new Uint8Array(s6), r13 = this._metrics;
    for (const [n9, i8] of e9) {
      const { startOffset: t9, length: e10 } = r13[n9];
      if (i8) for (let s7 = 0; s7 < e10; ++s7) a8[t9 + s7] = i8[s7];
    }
    this._allBitmaps = a8;
  }
  getMetrics(t8) {
    return this._metrics[t8];
  }
  getBitmap(t8) {
    if (!this._allBitmaps) return;
    const e9 = this._metrics[t8];
    if (void 0 === e9) return;
    const { startOffset: s6, length: a8 } = e9;
    return 0 !== a8 ? new n5(this._allBitmaps, s6, a8) : void 0;
  }
};
var a6 = class {
  constructor() {
    this._ranges = [];
  }
  get ranges() {
    return this._ranges;
  }
  getRange(t8) {
    return this._ranges[t8];
  }
  addRange(t8, e9) {
    this._ranges[t8] = e9;
  }
};
var r8 = class {
  constructor(t8) {
    this._glyphInfo = {}, this._baseURL = t8;
  }
  getRange(a8, r13) {
    const n9 = this._getFontStack(a8);
    if (n9.getRange(r13)) return Promise.resolve();
    const i8 = 256 * r13, c7 = i8 + 255;
    if (this._baseURL) {
      const o6 = this._baseURL.replace("{fontstack}", a8).replace("{range}", i8 + "-" + c7);
      return U(o6, { responseType: "array-buffer" }).then((t8) => {
        n9.addRange(r13, new s4(new n2(new Uint8Array(t8.data), new DataView(t8.data))));
      }).catch(() => {
        n9.addRange(r13, new s4());
      });
    }
    return n9.addRange(r13, new s4()), Promise.resolve();
  }
  getGlyph(t8, e9) {
    const s6 = this._getFontStack(t8);
    if (!s6) return;
    const a8 = Math.floor(e9 / 256), r13 = s6.getRange(a8);
    return r13 ? { metrics: r13.getMetrics(e9), bitmap: r13.getBitmap(e9) } : void 0;
  }
  _getFontStack(t8) {
    let e9 = this._glyphInfo[t8];
    return e9 || (e9 = this._glyphInfo[t8] = new a6()), e9;
  }
};
var n5 = class {
  constructor(t8, e9, s6) {
    this._array = t8, this._start = e9, this.length = s6;
  }
  at(t8) {
    return 0 <= t8 && t8 < this.length ? this._array[this._start + t8] : void 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/SpriteMosaic.js
var r9 = "dasharray-";
var o3 = class _o {
  constructor(t8, s6, e9 = 0) {
    this._size = [], this._mosaicsData = [], this._textures = [], this._dirties = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = {}, this.pixelRatio = 1, s6 <= 0 && console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"), this._pageWidth = t8, this._pageHeight = s6, e9 > 0 && (this._maxItemSize = e9), this._binPack = new e7(t8 - 4, s6 - 4);
  }
  destroy() {
    this.dispose();
  }
  dispose() {
    this._binPack = null, this._mosaicsData.length = 0, this._mosaicRects = {};
    for (const t8 of this._textures) t8 && t8.dispose();
    this._textures.length = 0;
  }
  getWidth(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][0];
  }
  getHeight(t8) {
    return t8 >= this._size.length ? -1 : this._size[t8][1];
  }
  getPageSize(t8) {
    return t8 >= this._size.length ? null : this._size[t8];
  }
  setSpriteSource(t8) {
    if (this.dispose(), this.pixelRatio = t8.devicePixelRatio, 0 === this._mosaicsData.length) {
      this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4);
      const t9 = Math.floor(this._pageWidth), s6 = Math.floor(this._pageHeight), e9 = new Uint32Array(t9 * s6);
      this._mosaicsData[0] = e9, this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0);
    }
    this._sprites = t8;
  }
  getSpriteItem(t8, i8 = false) {
    let s6, e9, h8 = this._mosaicRects[t8];
    if (h8) return h8;
    if (!this._sprites || "loaded" !== this._sprites.loadStatus) return null;
    if (t8 && t8.startsWith(r9) ? ([s6, e9] = this._rasterizeDash(t8), i8 = true) : s6 = this._sprites.getSpriteInfo(t8), !(s6 == null ? void 0 : s6.width) || !s6.height || s6.width < 0 || s6.height < 0) return null;
    const a8 = s6.width, o6 = s6.height, [n9, _3, g2] = this._allocateImage(a8, o6);
    return n9.width <= 0 ? null : (this._copy(n9, s6, _3, g2, i8, e9), h8 = { type: "sprite", rect: n9, width: a8, height: o6, sdf: s6.sdf, simplePattern: false, rasterizationScale: s6.pixelRatio, page: _3 }, this._mosaicRects[t8] = h8, h8);
  }
  getSpriteItems(t8) {
    const i8 = {};
    for (const s6 of t8) i8[s6.name] = this.getSpriteItem(s6.name, s6.repeat);
    return i8;
  }
  getMosaicItemPosition(t8, i8) {
    const s6 = this.getSpriteItem(t8, i8), e9 = s6 == null ? void 0 : s6.rect;
    if (!e9) return null;
    e9.width = s6.width, e9.height = s6.height;
    const h8 = s6.width, a8 = s6.height, r13 = 2;
    return { tl: [e9.x + r13, e9.y + r13], br: [e9.x + r13 + h8, e9.y + r13 + a8], page: s6.page };
  }
  bind(t8, i8, s6 = 0, r13 = 0) {
    if (s6 >= this._size.length || s6 >= this._mosaicsData.length) return;
    if (!this._textures[s6]) {
      const i9 = new p2();
      i9.wrapMode = D.CLAMP_TO_EDGE, i9.width = this._size[s6][0], i9.height = this._size[s6][1], this._textures[s6] = new m2(t8, i9, new Uint8Array(this._mosaicsData[s6].buffer));
    }
    const o6 = this._textures[s6];
    o6.setSamplingMode(i8), this._dirties[s6] && o6.setData(new Uint8Array(this._mosaicsData[s6].buffer)), t8.bindTexture(o6, r13), this._dirties[s6] = false;
  }
  static _copyBits(t8, i8, s6, e9, h8, a8, r13, o6, n9, _3, g2) {
    let c7 = e9 * i8 + s6, p7 = o6 * a8 + r13;
    if (g2) {
      p7 -= a8;
      for (let r14 = -1; r14 <= _3; r14++, c7 = ((r14 + _3) % _3 + e9) * i8 + s6, p7 += a8) for (let i9 = -1; i9 <= n9; i9++) h8[p7 + i9] = t8[c7 + (i9 + n9) % n9];
    } else for (let l7 = 0; l7 < _3; l7++) {
      for (let i9 = 0; i9 < n9; i9++) h8[p7 + i9] = t8[c7 + i9];
      c7 += i8, p7 += a8;
    }
  }
  _copy(t8, i8, s6, e9, h8, a8) {
    if (!this._sprites || "loaded" !== this._sprites.loadStatus || s6 >= this._mosaicsData.length) return;
    const r13 = new Uint32Array(a8 ? a8.buffer : this._sprites.image.buffer), n9 = this._mosaicsData[s6], _3 = 2, g2 = a8 ? i8.width : this._sprites.width;
    _o._copyBits(r13, g2, i8.x, i8.y, n9, e9[0], t8.x + _3, t8.y + _3, i8.width, i8.height, h8), this._dirties[s6] = true;
  }
  _allocateImage(t8, e9) {
    t8 += 2, e9 += 2;
    const h8 = Math.max(t8, e9);
    if (this._maxItemSize && this._maxItemSize < h8) {
      const i8 = new t(0, 0, t8, e9);
      return this._mosaicsData.push(new Uint32Array(t8 * e9)), this._dirties.push(true), this._size.push([t8, e9]), this._textures.push(void 0), [i8, this._mosaicsData.length - 1, [t8, e9]];
    }
    let a8 = t8 % 4 ? 4 - t8 % 4 : 4, r13 = e9 % 4 ? 4 - e9 % 4 : 4;
    1 === a8 && (a8 = 5), 1 === r13 && (r13 = 5);
    const o6 = this._binPack.allocate(t8 + a8, e9 + r13);
    return o6.width <= 0 ? (this._dirties[this._currentPage] || (this._mosaicsData[this._currentPage] = null), this._currentPage = this._mosaicsData.length, this._mosaicsData.push(new Uint32Array(this._pageWidth * this._pageHeight)), this._dirties.push(true), this._size.push([this._pageWidth, this._pageHeight]), this._textures.push(void 0), this._binPack = new e7(this._pageWidth - 4, this._pageHeight - 4), this._allocateImage(t8, e9)) : [o6, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _rasterizeDash(i8) {
    const s6 = /\[(.*?)\]/, e9 = i8.match(s6);
    if (!e9) return null;
    const h8 = e9[1].split(",").map(Number), a8 = i8.slice(i8.lastIndexOf("-") + 1), [r13, o6, n9] = l3(h8, a8);
    return [{ x: 0, y: 0, width: o6, height: n9, sdf: true, pixelRatio: 1 }, new Uint8Array(r13.buffer)];
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileHandler.js
var p5 = class {
  constructor(t8, e9, s6, r13) {
    this._layer = t8, this._styleRepository = e9, this.devicePixelRatio = s6, this._sourceDataMaxLOD = r13, this._spriteMosaic = null, this._glyphMosaic = null, this._connection = null, this._spriteSourceAbortController = null, this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null, this._styleRepository = null, this._layer = null, (_b = this._spriteMosaic) == null ? void 0 : _b.destroy(), this._spriteMosaic = null, this._glyphMosaic = null, this._spriteSourceAbortController = e(this._spriteSourceAbortController), this._spriteSourcePromise = null, this._inputSignalEventListener && ((_c = this._startOptionsInputSignal) == null ? void 0 : _c.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, this._inputSignalEventListener = null;
  }
  get spriteMosaic() {
    return this._spriteSourcePromise.then(() => this._spriteMosaic);
  }
  get glyphMosaic() {
    return this._glyphMosaic;
  }
  async start(t8) {
    this._requestSprite(t8);
    const s6 = this._layer.currentStyleInfo.glyphsUrl, r13 = new r8(s6 ? Et(s6, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    this._glyphMosaic = new n4(1024, 1024, r13), this._broadcastPromise = p4("WorkerTileHandler", { client: this, schedule: t8.schedule, signal: t8.signal }).then((s7) => {
      var _a;
      if (this._layer && ((_a = this._connection) == null ? void 0 : _a.close(), this._connection = s7, this._layer && !this._connection.closed)) {
        const r14 = s7.broadcast("setStyle", { style: this._layer.currentStyleInfo.style, sourceDataMaxLOD: this._sourceDataMaxLOD }, t8);
        Promise.all(r14).catch((t9) => f(t9));
      }
    });
  }
  _requestSprite(t8) {
    var _a, _b;
    (_a = this._spriteSourceAbortController) == null ? void 0 : _a.abort();
    const e9 = new AbortController();
    this._spriteSourceAbortController = e9;
    const r13 = t8 == null ? void 0 : t8.signal;
    this._inputSignalEventListener && ((_b = this._startOptionsInputSignal) == null ? void 0 : _b.removeEventListener("abort", this._inputSignalEventListener)), this._startOptionsInputSignal = null, r13 && (this._inputSignalEventListener = _(e9), r13.addEventListener("abort", this._inputSignalEventListener, { once: true }));
    const { signal: i8 } = e9, o6 = { ...t8, signal: i8 };
    this._spriteSourcePromise = this._layer.loadSpriteSource(this.devicePixelRatio, o6), this._spriteSourcePromise.then((t9) => {
      a3(i8), this._spriteMosaic = new o3(1024, 1024, 250), this._spriteMosaic.setSpriteSource(t9);
    });
  }
  async updateStyle(t8) {
    const e9 = [];
    for (const s6 of t8) s6.type === I2.SPRITES_CHANGED ? e9.push({ type: I2.SPRITES_CHANGED, data: { spriteSource: null } }) : e9.push(s6);
    return await this._broadcastPromise, this._broadcastPromise = Promise.all(this._connection.broadcast("updateStyle", e9)), this._broadcastPromise;
  }
  setSpriteSource(t8) {
    const e9 = new o3(1024, 1024, 250);
    return e9.setSpriteSource(t8), this._spriteMosaic = e9, this._spriteSourcePromise = Promise.resolve(t8), this._spriteSourceAbortController = null, e9;
  }
  async setStyle(t8, e9, s6) {
    await this._broadcastPromise, this._styleRepository = t8, this._sourceDataMaxLOD = s6, this._requestSprite();
    const r13 = new r8(this._layer.currentStyleInfo.glyphsUrl ? Et(this._layer.currentStyleInfo.glyphsUrl, { ...this._layer.customParameters, token: this._layer.apiKey }) : null);
    return this._glyphMosaic = new n4(1024, 1024, r13), this._broadcastPromise = Promise.all(this._connection.broadcast("setStyle", { style: e9, sourceDataMaxLOD: this._sourceDataMaxLOD })), this._broadcastPromise;
  }
  async fetchTileData(t8, e9) {
    const s6 = await this._getRefKeys(t8, e9);
    return this._getSourcesData(Object.keys(this._layer.sourceNameToSource), s6, e9);
  }
  async fetchTilePBFs(t8) {
    const e9 = Object.keys(this._layer.sourceNameToSource), s6 = {}, r13 = await this._getRefKeys(t8, s6), i8 = [], o6 = [];
    for (let n9 = 0; n9 < r13.length; n9++) if (null == r13[n9].value || null == e9[n9]) o6.push(null);
    else {
      const t9 = r13[n9].value, a8 = this._getTilePayload(t9, e9[n9], s6);
      a8.then((e10) => {
        i8.push({ ...e10, key: t9 });
      }), o6.push(a8);
    }
    return Promise.all(o6).then(() => i8);
  }
  async parseTileData(t8, e9) {
    const s6 = t8 && t8.data;
    if (!s6) return null;
    const { sourceName2DataAndRefKey: r13, transferList: i8 } = s6;
    return 0 === Object.keys(r13).length ? null : this._broadcastPromise.then(() => this._connection.invoke("createTileAndParse", { key: t8.key.id, sourceName2DataAndRefKey: r13, styleLayerUIDs: t8.styleLayerUIDs }, { ...e9, transferList: i8 }));
  }
  async getSprites(t8) {
    return await this._spriteSourcePromise, this._spriteMosaic.getSpriteItems(t8);
  }
  getGlyphs(t8) {
    return this._glyphMosaic.getGlyphItems(t8.font, t8.codePoints);
  }
  async _getTilePayload(t8, e9, s6) {
    const i8 = e3.pool.acquire(t8.id), o6 = this._layer.sourceNameToSource[e9], { level: n9, row: a8, col: l7 } = i8;
    e3.pool.release(i8);
    try {
      return { protobuff: await o6.requestTile(n9, a8, l7, s6), sourceName: e9 };
    } catch (c7) {
      if (b(c7)) throw c7;
      return { protobuff: null, sourceName: e9 };
    }
  }
  async _getRefKeys(t8, e9) {
    const s6 = this._layer.sourceNameToSource, r13 = new Array();
    for (const i8 in s6) {
      const o6 = s6[i8].getRefKey(t8, e9);
      r13.push(o6);
    }
    return y(r13);
  }
  _getSourcesData(t8, e9, s6) {
    const r13 = [];
    for (let i8 = 0; i8 < e9.length; i8++) if (null == e9[i8].value || null == t8[i8]) r13.push(null);
    else {
      const o6 = e9[i8].value, n9 = this._getTilePayload(o6, t8[i8], s6);
      r13.push(n9);
    }
    return y(r13).then((t9) => {
      const s7 = {}, r14 = [];
      for (let i8 = 0; i8 < t9.length; i8++) {
        const o6 = t9[i8].value;
        if (o6 && (o6.protobuff && o6.protobuff.byteLength > 0)) {
          const t10 = e9[i8].value.id;
          s7[o6.sourceName] = { refKey: t10, protobuff: o6.protobuff }, r14.push(o6.protobuff);
        }
      }
      return { sourceName2DataAndRefKey: s7, transferList: r14 };
    });
  }
};
function _(t8) {
  return () => t8.abort();
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/TileManager.js
var r10 = 512;
var n6 = 1e-6;
var a7 = (e9, i8) => e9 + 1 / (1 << 2 * i8);
var h4 = class {
  constructor(i8, t8) {
    this._tiles = /* @__PURE__ */ new Map(), this._tileCache = new e2(40, (e9) => e9.dispose()), this._viewSize = [0, 0], this._visibleTiles = /* @__PURE__ */ new Map(), this.acquireTile = i8.acquireTile, this.releaseTile = i8.releaseTile, this.tileInfoView = i8.tileInfoView, this._container = t8;
  }
  destroy() {
    for (const e9 of this._tiles.values()) e9.dispose();
    this._tiles = null, this._tileCache.clear(), this._tileCache = null;
  }
  update(e9) {
    this._updateCacheSize(e9);
    const i8 = this.tileInfoView, t8 = i8.getTileCoverage(e9.state, 0, true, "smallest");
    if (!t8) return true;
    const { spans: l7, lodInfo: r13 } = t8, { level: n9 } = r13, a8 = this._tiles, h8 = /* @__PURE__ */ new Set(), c7 = /* @__PURE__ */ new Set();
    for (const { row: s6, colFrom: _3, colTo: f4 } of l7) for (let e10 = _3; e10 <= f4; e10++) {
      const i9 = e3.getId(n9, s6, r13.normalizeCol(e10), r13.getWorldForColumn(e10)), t9 = this._getOrAcquireTile(i9);
      h8.add(i9), t9.processed() ? this._addToContainer(t9) : c7.add(new e3(i9));
    }
    for (const [s6, o6] of a8) o6.isCoverage = h8.has(s6);
    for (const s6 of c7) this._findPlaceholdersForMissingTiles(s6, h8);
    let d6 = false;
    for (const [s6, o6] of a8) o6.neededForCoverage = h8.has(s6), o6.neededForCoverage || o6.isHoldingForFade && i8.intersects(t8, o6.key) && h8.add(s6), o6.isFading && (d6 = true);
    for (const s6 of this._tiles.keys()) h8.has(s6) || this._releaseTile(s6);
    return s2.pool.release(t8), !d6;
  }
  clear() {
    this._tiles.clear(), this._tileCache.clear(), this._visibleTiles.clear();
  }
  clearCache() {
    this._tileCache.clear();
  }
  getIntersectingTiles(e9, s6, o6, r13, n9) {
    const a8 = [0, 0], h8 = [0, 0];
    r13.toMap(a8, e9 - o6, s6 + o6), r13.toMap(h8, e9 + o6, s6 - o6);
    const c7 = Math.min(a8[0], h8[0]), d6 = Math.min(a8[1], h8[1]), _3 = Math.max(a8[0], h8[0]), f4 = Math.max(a8[1], h8[1]), T = a4(c7, d6, _3, f4), u5 = u2(), p7 = [];
    for (const i8 of this._visibleTiles.values()) this.tileInfoView.getTileBounds(u5, i8.key), E(T, u5) && p7.push(i8);
    if (null != n9 && n9.length > 0) {
      const e10 = new Set(p7.map((e11) => e11.id)), i8 = n9.filter((i9) => !e10.has(i9.tileKey.id)).map((e11) => this._visibleTiles.get(e11.tileKey.id)).filter((e11) => void 0 !== e11);
      p7.push(...i8);
    }
    return p7;
  }
  _findPlaceholdersForMissingTiles(e9, i8) {
    const t8 = [];
    for (const s6 of this._tiles.values()) this._addPlaceholderChild(t8, s6, e9, i8);
    const l7 = t8.reduce(a7, 0);
    Math.abs(1 - l7) < n6 || this._addPlaceholderParent(e9.id, i8);
  }
  _addPlaceholderChild(e9, i8, t8, l7) {
    i8.key.level <= t8.level || !i8.hasData() || d4(t8, i8.key) && (this._addToContainer(i8), l7.add(i8.id), e9.push(i8.key.level - t8.level));
  }
  _addPlaceholderParent(e9, i8) {
    const t8 = this._tiles;
    let l7 = e9;
    for (; ; ) {
      if (l7 = c2(l7), !l7 || i8.has(l7)) return;
      const e10 = t8.get(l7);
      if (e10 == null ? void 0 : e10.hasData()) return this._addToContainer(e10), void i8.add(e10.id);
    }
  }
  _getOrAcquireTile(e9) {
    let i8 = this._tiles.get(e9);
    return i8 || (i8 = this._tileCache.pop(e9), i8 || (i8 = this.acquireTile(new e3(e9))), this._tiles.set(e9, i8), i8);
  }
  _releaseTile(e9) {
    const i8 = this._tiles.get(e9);
    this.releaseTile(i8), this._removeFromContainer(i8), this._tiles.delete(e9), i8.hasData() ? this._tileCache.put(e9, i8, 1) : i8.dispose();
  }
  _addToContainer(e9) {
    let i8;
    const t8 = [], l7 = this._container;
    if (l7.contains(e9)) return;
    const s6 = this._visibleTiles;
    for (const o6 of s6.values()) this._canConnectDirectly(e9, o6) && t8.push(o6), null == i8 && this._canConnectDirectly(o6, e9) && (i8 = o6);
    if (null != i8) {
      for (const l8 of t8) i8.childrenTiles.delete(l8), e9.childrenTiles.add(l8), l8.parentTile = e9;
      i8.childrenTiles.add(e9), e9.parentTile = i8;
    } else for (const o6 of t8) e9.childrenTiles.add(o6), o6.parentTile = e9;
    s6.set(e9.id, e9), l7.addChild(e9);
  }
  _removeFromContainer(e9) {
    if (this._visibleTiles.delete(e9.id), this._container.removeChild(e9), null != e9.parentTile) {
      e9.parentTile.childrenTiles.delete(e9);
      for (const i8 of e9.childrenTiles) null != e9.parentTile && e9.parentTile.childrenTiles.add(i8);
    }
    for (const i8 of e9.childrenTiles) i8.parentTile = e9.parentTile;
    e9.parentTile = null, e9.childrenTiles.clear();
  }
  _canConnectDirectly(e9, i8) {
    const t8 = e9.key;
    let { level: l7, row: s6, col: o6, world: r13 } = i8.key;
    const n9 = this._visibleTiles;
    for (; l7 > 0; ) {
      if (l7--, s6 >>= 1, o6 >>= 1, t8.level === l7 && t8.row === s6 && t8.col === o6 && t8.world === r13) return true;
      if (n9.has(`${l7}/${s6}/${o6}/${r13}`)) return false;
    }
    return false;
  }
  _updateCacheSize(e9) {
    const i8 = e9.state.size;
    if (i8[0] === this._viewSize[0] && i8[1] === this._viewSize[1]) return;
    const t8 = Math.ceil(i8[0] / r10) + 1, l7 = Math.ceil(i8[1] / r10) + 1;
    this._viewSize[0] = i8[0], this._viewSize[1] = i8[1], this._tileCache.maxSize = 5 * t8 * l7;
  }
};
function c2(e9) {
  const [i8, t8, l7, s6] = e9.split("/"), o6 = parseInt(i8, 10);
  return 0 === o6 ? null : `${o6 - 1}/${parseInt(t8, 10) >> 1}/${parseInt(l7, 10) >> 1}/${parseInt(s6, 10)}`;
}
function d4(e9, i8) {
  const t8 = i8.level - e9.level;
  return e9.row === i8.row >> t8 && e9.col === i8.col >> t8 && e9.world === i8.world;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/core.js
var t3 = class {
  constructor(t8, s6) {
    this.sourceTile = s6, this.xTile = 0, this.yTile = 0, this.hash = 0, this.priority = 1, this.featureIndex = 0, this.colliders = [], this.textVertexRanges = [], this.iconVertexRanges = [], this.tile = t8;
  }
};
var s5 = class {
  constructor() {
    this.tileSymbols = [], this.parts = [{ startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }, { startTime: 0, startOpacity: 0, targetOpacity: 0, show: false }], this.show = false;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/util.js
function o4(t8, e9, s6, o6, i8, l7) {
  const r13 = s6 - i8;
  if (r13 >= 0) return (e9 >> r13) + (o6 - (l7 << r13)) * (t8 >> r13);
  const n9 = -r13;
  return e9 - (l7 - (o6 << n9)) * (t8 >> n9) << n9;
}
var i4 = class {
  constructor(t8, e9, s6) {
    this._rows = Math.ceil(e9 / s6), this._columns = Math.ceil(t8 / s6), this._cellSize = s6, this.cells = new Array(this._rows);
    for (let o6 = 0; o6 < this._rows; o6++) {
      this.cells[o6] = new Array(this._columns);
      for (let t9 = 0; t9 < this._columns; t9++) this.cells[o6][t9] = [];
    }
  }
  getCell(t8, e9) {
    const s6 = Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this._rows - 1), o6 = Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this._columns - 1);
    return this.cells[s6] && this.cells[s6][o6] || null;
  }
  getCellSpan(t8, e9, s6, o6) {
    return [Math.min(Math.max(Math.floor(t8 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(e9 / this._cellSize), 0), this.rows - 1), Math.min(Math.max(Math.floor(s6 / this._cellSize), 0), this.columns - 1), Math.min(Math.max(Math.floor(o6 / this._cellSize), 0), this.rows - 1)];
  }
  get cellSize() {
    return this._cellSize;
  }
  get columns() {
    return this._columns;
  }
  get rows() {
    return this._rows;
  }
};
function l4(t8, e9, o6, i8, l7, r13, n9) {
  const c7 = e9[i8++];
  for (let a8 = 0; a8 < c7; a8++) {
    const c8 = new t3(r13, n9);
    c8.xTile = e9[i8++], c8.yTile = e9[i8++], c8.hash = e9[i8++], c8.priority = e9[i8++], c8.featureIndex = e9[i8++];
    const a9 = e9[i8++];
    for (let t9 = 0; t9 < a9; t9++) {
      const t10 = e9[i8++], s6 = e9[i8++], l8 = e9[i8++], r14 = e9[i8++], n10 = !!e9[i8++], a10 = e9[i8++], h9 = o6[i8++], u6 = o6[i8++], f4 = e9[i8++], m5 = e9[i8++];
      c8.colliders.push({ xTile: t10, yTile: s6, dxPixels: l8, dyPixels: r14, hard: n10, partIndex: a10, width: f4, height: m5, minLod: h9, maxLod: u6 });
    }
    const h8 = t8[i8++];
    for (let e10 = 0; e10 < h8; e10++) c8.textVertexRanges.push([t8[i8++], t8[i8++]]);
    const u5 = t8[i8++];
    for (let e10 = 0; e10 < u5; e10++) c8.iconVertexRanges.push([t8[i8++], t8[i8++]]);
    l7.push(c8);
  }
  return i8;
}
function r11(t8, e9, s6) {
  for (const [o6, i8] of t8.symbols) n7(t8, e9, s6, i8, o6);
}
function n7(e9, s6, o6, i8, l7) {
  const r13 = e9.layerData.get(l7);
  if (r13.type === E2.SYMBOL) {
    for (const t8 of i8) {
      const s7 = t8.unique;
      let i9;
      if (t8.selectedForRendering) {
        const t9 = s7.parts[0], l8 = t9.startOpacity, r14 = t9.targetOpacity;
        e9.allSymbolsFadingOut = e9.allSymbolsFadingOut && 0 === r14;
        const n9 = o6 ? Math.floor(127 * l8) | r14 << 7 : r14 ? 255 : 0;
        i9 = n9 << 24 | n9 << 16 | n9 << 8 | n9;
      } else i9 = 0;
      for (const [e10, o7] of t8.iconVertexRanges) for (let t9 = e10; t9 < e10 + o7; t9 += 4) r13.iconOpacity[t9 / 4] = i9;
      if (t8.selectedForRendering) {
        const t9 = s7.parts[1], l8 = t9.startOpacity, r14 = t9.targetOpacity;
        e9.allSymbolsFadingOut = e9.allSymbolsFadingOut && 0 === r14;
        const n9 = o6 ? Math.floor(127 * l8) | r14 << 7 : r14 ? 255 : 0;
        i9 = n9 << 24 | n9 << 16 | n9 << 8 | n9;
      } else i9 = 0;
      for (const [e10, o7] of t8.textVertexRanges) for (let t9 = e10; t9 < e10 + o7; t9 += 4) r13.textOpacity[t9 / 4] = i9;
    }
    r13.lastOpacityUpdate = s6, r13.opacityChanged = true;
  }
}
function c3(t8, s6, o6, i8) {
  const l7 = t8.colliders;
  let r13, n9, c7, a8;
  for (const h8 of l7) {
    if (t8.unique.show && t8.unique.parts[h8.partIndex].show && (r13 = h8.xScreen - i8[0] + h8.dxScreen, n9 = h8.yScreen - i8[1] + h8.dyScreen, c7 = r13 + h8.width, a8 = n9 + h8.height, w(o6, s6.x, s6.y, r13, n9, c7, a8))) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/RenderBucket.js
var h5 = class {
  constructor(t8, e9) {
    this.layerUIDs = [], this.isDestroyed = false, this._data = t8;
    let r13 = 1;
    const n9 = new Uint32Array(t8);
    this.layerUIDs = [];
    const s6 = n9[r13++];
    for (let i8 = 0; i8 < s6; i8++) this.layerUIDs[i8] = n9[r13++];
    this.bufferDataOffset = r13, e9 && (this.layer = e9.getStyleLayerByUID(this.layerUIDs[0]));
  }
  get isPreparedForRendering() {
    return null == this._data;
  }
  get offset() {
    return this.bufferDataOffset;
  }
  get data() {
    return this._data;
  }
  destroy() {
    this.isDestroyed || (this.doDestroy(), this._data = null, this.isDestroyed = true);
  }
  prepareForRendering(t8) {
    null != this._data && (this.doPrepareForRendering(t8, this._data, this.bufferDataOffset), this._data = null);
  }
};
var l5 = class extends h5 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E2.LINE, this.lineIndexStart = 0, this.lineIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let s6 = this.bufferDataOffset;
    this.lineIndexStart = r13[s6++], this.lineIndexCount = r13[s6++];
    const i8 = r13[s6++];
    if (i8 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i8; t9++) {
        const t10 = r13[s6++], e10 = r13[s6++], n9 = r13[s6++];
        this.patternMap.set(t10, [e10, n9]);
      }
    }
    this.bufferDataOffset = s6;
  }
  get usedMemory() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.lineIndexCount > 0;
  }
  triangleCount() {
    return this.lineIndexCount / 3;
  }
  doDestroy() {
    this.vao = r3(this.vao);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n9 = new Uint32Array(e9), s6 = new Int32Array(n9.buffer), h8 = n9[r13++], l7 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, h8));
    r13 += h8;
    const f4 = n9[r13++], u5 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, f4));
    r13 += f4;
    const c7 = this.layer.lineMaterial;
    this.vao = new o2(t8, c7.getAttributeLocations(), c7.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", l7]]), u5);
  }
};
var f3 = class extends h5 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E2.FILL, this.fillIndexStart = 0, this.fillIndexCount = 0, this.outlineIndexStart = 0, this.outlineIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let s6 = this.bufferDataOffset;
    this.fillIndexStart = r13[s6++], this.fillIndexCount = r13[s6++], this.outlineIndexStart = r13[s6++], this.outlineIndexCount = r13[s6++];
    const i8 = r13[s6++];
    if (i8 > 0) {
      this.patternMap = /* @__PURE__ */ new Map();
      for (let t9 = 0; t9 < i8; t9++) {
        const t10 = r13[s6++], e10 = r13[s6++], n9 = r13[s6++];
        this.patternMap.set(t10, [e10, n9]);
      }
    }
    this.bufferDataOffset = s6;
  }
  get usedMemory() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.fillVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c = this.outlineVAO) == null ? void 0 : _c.usedMemory) ?? 0);
  }
  hasData() {
    return this.fillIndexCount > 0 || this.outlineIndexCount > 0;
  }
  triangleCount() {
    return (this.fillIndexCount + this.outlineIndexCount) / 3;
  }
  doDestroy() {
    this.fillVAO = r3(this.fillVAO), this.outlineVAO = r3(this.outlineVAO);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n9 = new Uint32Array(e9), s6 = new Int32Array(n9.buffer), h8 = n9[r13++], l7 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, h8));
    r13 += h8;
    const f4 = n9[r13++], u5 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, f4));
    r13 += f4;
    const c7 = n9[r13++], y6 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, c7));
    r13 += c7;
    const d6 = n9[r13++], A3 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, d6));
    r13 += d6;
    const p7 = this.layer, I3 = p7.fillMaterial, g2 = p7.outlineMaterial;
    this.fillVAO = new o2(t8, I3.getAttributeLocations(), I3.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", l7]]), u5), this.outlineVAO = new o2(t8, g2.getAttributeLocations(), g2.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", y6]]), A3);
  }
};
var u3 = class extends h5 {
  constructor(t8, e9, i8) {
    super(t8, e9), this.type = E2.SYMBOL, this.iconPerPageElementsMap = /* @__PURE__ */ new Map(), this.glyphPerPageElementsMap = /* @__PURE__ */ new Map(), this.symbolInstances = [], this.isIconSDF = false, this.opacityChanged = false, this.lastOpacityUpdate = 0, this.symbols = [];
    const a8 = new Uint32Array(t8), o6 = new Int32Array(t8), h8 = new Float32Array(t8);
    let l7 = this.bufferDataOffset;
    this.isIconSDF = !!a8[l7++];
    const f4 = a8[l7++], u5 = a8[l7++], c7 = a8[l7++], y6 = new e3(f4, u5, c7, 0), d6 = a8[l7++];
    for (let r13 = 0; r13 < d6; r13++) {
      const t9 = a8[l7++], e10 = a8[l7++], r14 = a8[l7++];
      this.iconPerPageElementsMap.set(t9, [e10, r14]);
    }
    const A3 = a8[l7++];
    for (let r13 = 0; r13 < A3; r13++) {
      const t9 = a8[l7++], e10 = a8[l7++], r14 = a8[l7++];
      this.glyphPerPageElementsMap.set(t9, [e10, r14]);
    }
    const p7 = a8[l7++], I3 = a8[l7++];
    this.iconOpacity = new Int32Array(p7), this.textOpacity = new Int32Array(I3), l7 = l4(a8, o6, h8, l7, this.symbols, i8, y6), this.bufferDataOffset = l7;
  }
  get usedMemory() {
    var _a, _b, _c;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.iconVAO) == null ? void 0 : _b.usedMemory) ?? 0) + (((_c = this.textVAO) == null ? void 0 : _c.usedMemory) ?? 0) + A(this.iconOpacity) + A(this.textOpacity);
  }
  hasData() {
    return this.iconPerPageElementsMap.size > 0 || this.glyphPerPageElementsMap.size > 0;
  }
  triangleCount() {
    let t8 = 0;
    for (const e9 of this.iconPerPageElementsMap.values()) t8 += e9[1];
    for (const e9 of this.glyphPerPageElementsMap.values()) t8 += e9[1];
    return t8 / 3;
  }
  doDestroy() {
    this.iconVAO = r3(this.iconVAO), this.textVAO = r3(this.textVAO);
  }
  updateOpacityInfo() {
    if (!this.opacityChanged) return;
    this.opacityChanged = false;
    const t8 = this.iconOpacity, e9 = this.iconVAO.vertexBuffers.get("opacity");
    t8.length > 0 && t8.byteLength === e9.usedMemory && e9.setSubData(t8, 0, 0, t8.length);
    const r13 = this.textOpacity, n9 = this.textVAO.vertexBuffers.get("opacity");
    r13.length > 0 && r13.byteLength === n9.usedMemory && n9.setSubData(r13, 0, 0, r13.length);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n9 = new Uint32Array(e9), s6 = new Int32Array(n9.buffer), h8 = n9[r13++], l7 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, h8));
    r13 += h8;
    const f4 = n9[r13++], u5 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, f4));
    r13 += f4;
    const c7 = n9[r13++], y6 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, c7));
    r13 += c7;
    const d6 = n9[r13++], A3 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, d6));
    r13 += d6;
    const p7 = E3.createVertex(t8, F.STATIC_DRAW, this.iconOpacity.buffer), I3 = E3.createVertex(t8, F.STATIC_DRAW, this.textOpacity.buffer), g2 = this.layer, x = g2.iconMaterial, b2 = g2.textMaterial;
    this.iconVAO = new o2(t8, x.getAttributeLocations(), x.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", l7], ["opacity", p7]]), u5), this.textVAO = new o2(t8, b2.getAttributeLocations(), b2.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", y6], ["opacity", I3]]), A3);
  }
};
var c4 = class extends h5 {
  constructor(t8, e9) {
    super(t8, e9), this.type = E2.CIRCLE, this.circleIndexStart = 0, this.circleIndexCount = 0;
    const r13 = new Uint32Array(t8);
    let s6 = this.bufferDataOffset;
    this.circleIndexStart = r13[s6++], this.circleIndexCount = r13[s6++], this.bufferDataOffset = s6;
  }
  get usedMemory() {
    var _a, _b;
    return (((_a = this.data) == null ? void 0 : _a.byteLength) ?? 0) + (((_b = this.vao) == null ? void 0 : _b.usedMemory) ?? 0);
  }
  hasData() {
    return this.circleIndexCount > 0;
  }
  triangleCount() {
    return this.circleIndexCount / 3;
  }
  doDestroy() {
    this.vao = r3(this.vao);
  }
  doPrepareForRendering(t8, e9, r13) {
    const n9 = new Uint32Array(e9), s6 = new Int32Array(n9.buffer), h8 = n9[r13++], l7 = E3.createVertex(t8, F.STATIC_DRAW, new Int32Array(s6.buffer, 4 * r13, h8));
    r13 += h8;
    const f4 = n9[r13++], u5 = E3.createIndex(t8, F.STATIC_DRAW, new Uint32Array(n9.buffer, 4 * r13, f4));
    r13 += f4;
    const c7 = this.layer.circleMaterial;
    this.vao = new o2(t8, c7.getAttributeLocations(), c7.getLayoutInfo(), /* @__PURE__ */ new Map([["geometry", l7]]), u5);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTile.js
var y3 = class _y extends r7 {
  constructor(e9, t8, s6, r13, a8, i8, o6, h8 = null) {
    super(e9, t8, s6, r13, a8, i8, 4096, 4096), this.styleRepository = o6, this._memCache = h8, this.type = "vector-tile", this._referenced = 1, this._hasSymbolBuckets = false, this._usedMemory = 256, this.layerData = /* @__PURE__ */ new Map(), this.status = "loading", this.allSymbolsFadingOut = false, this.lastOpacityUpdate = 0, this.symbols = /* @__PURE__ */ new Map(), this.isCoverage = false, this.neededForCoverage = false, this.decluttered = false, this.parentTile = null, this.childrenTiles = /* @__PURE__ */ new Set(), this.featureIndex = null, this.triangleCount = 0, this._processed = false, this.id = e9.id;
  }
  get hasSymbolBuckets() {
    return this._hasSymbolBuckets;
  }
  get isFading() {
    return this._hasSymbolBuckets && performance.now() - this.lastOpacityUpdate < e4;
  }
  get isHoldingForFade() {
    return this._hasSymbolBuckets && (!this.allSymbolsFadingOut || performance.now() - this.lastOpacityUpdate < e4);
  }
  get wasRequested() {
    return "errored" === this.status || "loaded" === this.status || "reloading" === this.status;
  }
  setData(e9) {
    this.changeDataImpl(e9), this.requestRender(), this.ready(), this._processed = true;
  }
  deleteLayerData(e9) {
    var _a, _b;
    let t8 = false;
    for (const s6 of e9) {
      const e10 = this.layerData.get(s6);
      e10 && (this._usedMemory -= e10.usedMemory, e10.type === E2.SYMBOL && this.symbols.delete(s6) && (t8 = true), e10.destroy(), this.layerData.delete(s6));
    }
    (_a = this._memCache) == null ? void 0 : _a.updateSize(this.key.id, this, this._usedMemory), t8 && ((_b = this.featureIndex) == null ? void 0 : _b.clear(), this.emit("symbols-changed")), this.requestRender();
  }
  processed() {
    return this._processed;
  }
  hasData() {
    return this.layerData.size > 0;
  }
  hasFeatures() {
    const e9 = this.layerData.values();
    for (const t8 of e9) if (t8.hasData()) return true;
    return false;
  }
  dispose() {
    "unloaded" !== this.status && (_y._destroyRenderBuckets(this.layerData), this.layerData.clear(), this.featureIndex = null, this._usedMemory = 0, this.destroy(), this.status = "unloaded");
  }
  release() {
    0 == --this._referenced && (this.dispose(), this.stage = null);
  }
  retain() {
    ++this._referenced;
  }
  get usedMemory() {
    return this._usedMemory;
  }
  get usedMemoryPerReference() {
    return this._usedMemory / (this._referenced || 1);
  }
  changeDataImpl(e9) {
    var _a, _b;
    (_a = this.featureIndex) == null ? void 0 : _a.clear();
    let t8 = false;
    if (e9) {
      const { bucketsWithData: s6, emptyBuckets: r13 } = e9, a8 = this._createRenderBuckets(s6);
      if (r13 && r13.byteLength > 0) {
        const e10 = new Uint32Array(r13);
        for (const t9 of e10) this._deleteLayerData(t9);
      }
      for (const [e10, o6] of a8) this._deleteLayerData(e10), o6.type === E2.SYMBOL && (this.symbols.set(e10, o6.symbols), t8 = true), this._usedMemory += o6.usedMemory, this.layerData.set(e10, o6);
      (_b = this._memCache) == null ? void 0 : _b.updateSize(this.key.id, this, this.usedMemory);
    }
    this._hasSymbolBuckets = false;
    for (const s6 of this.layerData.values()) s6.type === E2.SYMBOL && (this._hasSymbolBuckets = true);
    t8 && this.emit("symbols-changed");
  }
  attachWithContext(e9) {
    this.stage = { context: e9, trashDisplayObject(e10) {
      e10.processDetach();
    }, untrashDisplayObject: () => false };
  }
  setTransform(a8) {
    super.setTransform(a8);
    const i8 = this.resolution / (a8.resolution * a8.pixelRatio), o6 = this.width / this.rangeX * i8, h8 = this.height / this.rangeY * i8, n9 = [0, 0];
    a8.toScreen(n9, [this.x, this.y]);
    const l7 = this.transforms.tileUnitsToPixels;
    o(l7), M(l7, l7, n9), h(l7, l7, Math.PI * a8.rotation / 180), f2(l7, l7, [o6, h8, 1]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6(), tileMat3: e6(), tileUnitsToPixels: e6() };
  }
  static _destroyRenderBuckets(e9) {
    if (!e9) return;
    const t8 = /* @__PURE__ */ new Set();
    for (const s6 of e9.values()) t8.has(s6) || (s6.destroy(), t8.add(s6));
    e9.clear();
  }
  _createRenderBuckets(e9) {
    const t8 = /* @__PURE__ */ new Map(), s6 = /* @__PURE__ */ new Map();
    for (const r13 of e9) {
      const e10 = this._deserializeBucket(r13, s6);
      for (const s7 of e10.layerUIDs) t8.set(s7, e10);
    }
    return t8;
  }
  _deserializeBucket(e9, t8) {
    let s6 = t8.get(e9);
    if (s6) return s6;
    switch (new Uint32Array(e9)[0]) {
      case E2.FILL:
        s6 = new f3(e9, this.styleRepository);
        break;
      case E2.LINE:
        s6 = new l5(e9, this.styleRepository);
        break;
      case E2.SYMBOL:
        s6 = new u3(e9, this.styleRepository, this);
        break;
      case E2.CIRCLE:
        s6 = new c4(e9, this.styleRepository);
    }
    return t8.set(e9, s6), s6;
  }
  _deleteLayerData(e9) {
    if (!this.layerData.has(e9)) return;
    const t8 = this.layerData.get(e9);
    this._usedMemory -= t8.usedMemory, t8.destroy(), this.layerData.delete(e9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/jobs.js
function i5(e9, t8, n9, o6, i8, l7) {
  const { iconRotationAlignment: a8, textRotationAlignment: c7, iconTranslate: h8, iconTranslateAnchor: u5, textTranslate: d6, textTranslateAnchor: y6 } = o6;
  let x = 0;
  for (const g2 of e9.colliders) {
    const [e10, o7] = 0 === g2.partIndex ? h8 : d6, m5 = 0 === g2.partIndex ? u5 : y6, f4 = g2.minLod <= l7 && l7 <= g2.maxLod;
    x += f4 ? 0 : 1, g2.enabled = f4, g2.xScreen = g2.xTile * i8[0] + g2.yTile * i8[3] + i8[6], g2.yScreen = g2.xTile * i8[1] + g2.yTile * i8[4] + i8[7], m5 === r5.MAP ? (g2.xScreen += n9 * e10 - t8 * o7, g2.yScreen += t8 * e10 + n9 * o7) : (g2.xScreen += e10, g2.yScreen += o7), l.VIEWPORT === (0 === g2.partIndex ? a8 : c7) ? (g2.dxScreen = g2.dxPixels, g2.dyScreen = g2.dyPixels) : (g2.dxScreen = n9 * (g2.dxPixels + g2.width / 2) - t8 * (g2.dyPixels + g2.height / 2) - g2.width / 2, g2.dyScreen = t8 * (g2.dxPixels + g2.width / 2) + n9 * (g2.dyPixels + g2.height / 2) - g2.height / 2);
  }
  e9.colliders.length > 0 && x === e9.colliders.length && (e9.unique.show = false);
}
var l6 = class {
  constructor(o6, r13, s6, i8, l7, a8) {
    this._symbols = o6, this._styleRepository = i8, this._zoom = l7, this._currentLayerCursor = 0, this._currentSymbolCursor = 0, this._styleProps = /* @__PURE__ */ new Map(), this._allNeededMatrices = /* @__PURE__ */ new Map(), this._gridIndex = new i4(r13, s6, t2), this._si = Math.sin(Math.PI * a8 / 180), this._co = Math.cos(Math.PI * a8 / 180);
    for (const t8 of o6) for (const n9 of t8.symbols) this._allNeededMatrices.has(n9.tile) || this._allNeededMatrices.set(n9.tile, r6(n9.tile.transforms.tileUnitsToPixels));
  }
  work(e9) {
    const t8 = this._gridIndex;
    function n9(e10) {
      const n10 = e10.xScreen + e10.dxScreen, o7 = e10.yScreen + e10.dyScreen, r13 = n10 + e10.width, s6 = o7 + e10.height, [i8, l7, a8, c7] = t8.getCellSpan(n10, o7, r13, s6);
      for (let h8 = l7; h8 <= c7; h8++) for (let e11 = i8; e11 <= a8; e11++) {
        const i9 = t8.cells[h8][e11];
        for (const e12 of i9) {
          const t9 = e12.xScreen + e12.dxScreen, i10 = e12.yScreen + e12.dyScreen, l8 = t9 + e12.width, a9 = i10 + e12.height;
          if (!(r13 < t9 || n10 > l8 || s6 < i10 || o7 > a9)) return true;
        }
      }
      return false;
    }
    const o6 = performance.now();
    for (; this._currentLayerCursor < this._symbols.length; this._currentLayerCursor++, this._currentSymbolCursor = 0) {
      const t9 = this._symbols[this._currentLayerCursor], r13 = this._getProperties(t9.styleLayerUID);
      for (; this._currentSymbolCursor < t9.symbols.length; this._currentSymbolCursor++) {
        if (this._currentSymbolCursor % 100 == 99 && performance.now() - o6 > e9) return false;
        const s6 = t9.symbols[this._currentSymbolCursor];
        if (!s6.unique.show) continue;
        i5(s6, this._si, this._co, r13, this._allNeededMatrices.get(s6.tile), this._zoom);
        const l7 = s6.unique;
        if (!l7.show) continue;
        const { iconAllowOverlap: a8, iconIgnorePlacement: c7, textAllowOverlap: h8, textIgnorePlacement: u5 } = r13;
        for (const e10 of s6.colliders) {
          if (!e10.enabled) continue;
          const t10 = l7.parts[e10.partIndex];
          if (!t10.show) continue;
          !(e10.partIndex ? h8 : a8) && n9(e10) && (e10.hard ? l7.show = false : t10.show = false);
        }
        if (l7.show) for (const e10 of s6.colliders) {
          if (!e10.enabled) continue;
          if (e10.partIndex ? u5 : c7) continue;
          if (!l7.parts[e10.partIndex].show) continue;
          const t10 = e10.xScreen + e10.dxScreen, n10 = e10.yScreen + e10.dyScreen, o7 = t10 + e10.width, r14 = n10 + e10.height, [s7, i8, a9, h9] = this._gridIndex.getCellSpan(t10, n10, o7, r14);
          for (let l8 = i8; l8 <= h9; l8++) for (let t11 = s7; t11 <= a9; t11++) {
            this._gridIndex.cells[l8][t11].push(e10);
          }
        }
      }
    }
    return true;
  }
  _getProperties(e9) {
    const t8 = this._styleProps.get(e9);
    if (t8) return t8;
    const n9 = this._zoom, s6 = this._styleRepository.getStyleLayerByUID(e9), i8 = s6.getLayoutValue("symbol-placement", n9) !== n3.POINT;
    let l7 = s6.getLayoutValue("icon-rotation-alignment", n9);
    l7 === l.AUTO && (l7 = i8 ? l.MAP : l.VIEWPORT);
    let a8 = s6.getLayoutValue("text-rotation-alignment", n9);
    a8 === l.AUTO && (a8 = i8 ? l.MAP : l.VIEWPORT);
    const c7 = s6.getPaintValue("icon-translate", n9), h8 = s6.getPaintValue("icon-translate-anchor", n9), u5 = s6.getPaintValue("text-translate", n9), d6 = s6.getPaintValue("text-translate-anchor", n9), y6 = { iconAllowOverlap: s6.getLayoutValue("icon-allow-overlap", n9), iconIgnorePlacement: s6.getLayoutValue("icon-ignore-placement", n9), textAllowOverlap: s6.getLayoutValue("text-allow-overlap", n9), textIgnorePlacement: s6.getLayoutValue("text-ignore-placement", n9), iconRotationAlignment: l7, textRotationAlignment: a8, iconTranslateAnchor: h8, iconTranslate: c7, textTranslateAnchor: d6, textTranslate: u5 };
    return this._styleProps.set(e9, y6), y6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolDeclutterer.js
function e8(o6, e9) {
  if (o6.priority - e9.priority) return o6.priority - e9.priority;
  const t8 = o6.tile.key, i8 = e9.tile.key;
  return t8.world - i8.world ? t8.world - i8.world : t8.level - i8.level ? t8.level - i8.level : t8.row - i8.row ? t8.row - i8.row : t8.col - i8.col ? t8.col - i8.col : o6.xTile - e9.xTile ? o6.xTile - e9.xTile : o6.yTile - e9.yTile;
}
var t4 = class {
  get running() {
    return this._running;
  }
  constructor(o6, e9, t8, i8, s6, n9) {
    this._visibleTiles = o6, this._symbolRepository = e9, this._createCollisionJob = t8, this._assignTileSymbolsOpacity = i8, this._symbolLayerSorter = s6, this._isLayerVisible = n9, this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  setScreenSize(o6, e9) {
    this._screenWidth === o6 && this._screenHeight === e9 || this.restart(), this._screenWidth = o6, this._screenHeight = e9;
  }
  restart() {
    this._selectionJob = null, this._selectionJobCompleted = false, this._collisionJob = null, this._collisionJobCompleted = false, this._opacityJob = null, this._opacityJobCompleted = false, this._running = true;
  }
  continue(o6) {
    if (this._selectionJob || (this._selectionJob = this._createSelectionJob()), !this._selectionJobCompleted) {
      const e9 = performance.now();
      if (!this._selectionJob.work(o6)) return false;
      if (this._selectionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    if (this._collisionJob || (this._collisionJob = this._createCollisionJob(this._selectionJob.sortedSymbols, this._screenWidth, this._screenHeight)), !this._collisionJobCompleted) {
      const e9 = performance.now();
      if (!this._collisionJob.work(o6)) return false;
      if (this._collisionJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    if (this._opacityJob || (this._opacityJob = this._createOpacityJob()), !this._opacityJobCompleted) {
      const e9 = performance.now();
      if (!this._opacityJob.work(o6)) return false;
      if (this._opacityJobCompleted = true, 0 === (o6 = Math.max(0, o6 - (performance.now() - e9)))) return false;
    }
    return this._running = false, true;
  }
  _createSelectionJob() {
    const o6 = this._symbolRepository.uniqueSymbols;
    for (let e9 = 0; e9 < o6.length; e9++) {
      const t9 = o6[e9];
      for (let o7 = 0; o7 < t9.uniqueSymbols.length; o7++) {
        const e10 = t9.uniqueSymbols[o7];
        for (const o8 of e10.tileSymbols) o8.selectedForRendering = false;
      }
    }
    const t8 = [];
    let i8 = 0, s6 = 0;
    const n9 = this._isLayerVisible;
    function r13(r14) {
      let l8;
      const c7 = performance.now();
      for (; s6 < o6.length; s6++, i8 = 0) {
        const e9 = o6[s6], h8 = e9.styleLayerUID;
        if (!n9(h8)) {
          t8[s6] || (t8[s6] = { styleLayerUID: h8, symbols: [] });
          continue;
        }
        t8[s6] = t8[s6] || { styleLayerUID: h8, symbols: [] };
        const a8 = t8[s6];
        for (; i8 < e9.uniqueSymbols.length; i8++) {
          if (l8 = e9.uniqueSymbols[i8], i8 % 100 == 99 && performance.now() - c7 > r14) return false;
          let o7 = null, t9 = false, s7 = false;
          for (const e10 of l8.tileSymbols) if (!s7 || !t9) {
            const i9 = e10.tile;
            (!o7 || i9.isCoverage || i9.neededForCoverage && !t9) && (o7 = e10, (i9.neededForCoverage || i9.isCoverage) && (s7 = true), i9.isCoverage && (t9 = true));
          }
          if (o7.selectedForRendering = true, s7) {
            a8.symbols.push(o7), l8.show = true;
            for (const o8 of l8.parts) o8.show = true;
          } else l8.show = false;
        }
      }
      for (const o7 of t8) o7.symbols.sort(e8);
      return true;
    }
    const l7 = this._symbolLayerSorter;
    return { work: r13, get sortedSymbols() {
      return t8.sort(l7);
    } };
  }
  _createOpacityJob() {
    const o6 = this._assignTileSymbolsOpacity, e9 = this._visibleTiles;
    let t8 = 0;
    function s6(e10, t9) {
      for (const o7 of e10.symbols.values()) i6(o7, t9);
      o6(e10, t9);
      for (const o7 of e10.childrenTiles) s6(o7, t9);
    }
    return { work(o7) {
      const i8 = performance.now();
      for (; t8 < e9.length; t8++) {
        if (performance.now() - i8 > o7) return false;
        const n9 = e9[t8];
        if (null != n9.parentTile) continue;
        s6(n9, performance.now());
      }
      return true;
    } };
  }
};
function i6(e9, t8) {
  for (const i8 of e9) {
    const e10 = i8.unique;
    for (const i9 of e10.parts) {
      const s6 = i9.targetOpacity > 0.5 ? 1 : -1;
      i9.startOpacity += s6 * ((t8 - i9.startTime) / e4), i9.startOpacity = Math.min(Math.max(i9.startOpacity, 0), 1), i9.startTime = t8, i9.targetOpacity = e10.show && i9.show ? 1 : 0;
    }
  }
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolRepository.js
var o5 = 32;
var t5 = 8;
var i7 = 64;
var n8 = 20;
var r12 = class {
  constructor(e9, s6, l7) {
    this.tileCoordRange = e9, this._visibleTiles = s6, this._createUnique = l7, this._tiles = /* @__PURE__ */ new Map(), this._uniqueSymbolsReferences = /* @__PURE__ */ new Map();
  }
  get uniqueSymbols() {
    return null == this._uniqueSymbolLayerArray && (this._uniqueSymbolLayerArray = this._createUniqueSymbolLayerArray()), this._uniqueSymbolLayerArray;
  }
  get uniqueSymbolsReferences() {
    return this._uniqueSymbolsReferences;
  }
  add(s6, l7) {
    this._uniqueSymbolLayerArray = null;
    let n9 = this._tiles.get(s6.id);
    n9 || (n9 = { symbols: /* @__PURE__ */ new Map() }, this._tiles.set(s6.id, n9));
    const r13 = /* @__PURE__ */ new Map();
    if (l7) for (const e9 of l7) n9.symbols.has(e9) && (r13.set(e9, n9.symbols.get(e9)), n9.symbols.delete(e9));
    else for (const [e9, o6] of s6.layerData) n9.symbols.has(e9) && (r13.set(e9, n9.symbols.get(e9)), n9.symbols.delete(e9));
    this._removeSymbols(r13);
    const y6 = s6.symbols, a8 = /* @__PURE__ */ new Map();
    for (const [f4, u5] of y6) {
      let s7 = u5.length;
      if (s7 >= o5) {
        let l8 = this.tileCoordRange;
        do {
          l8 /= 2, s7 /= 4;
        } while (s7 > t5 && l8 > i7);
        const o6 = new i4(this.tileCoordRange, this.tileCoordRange, l8);
        a8.set(f4, { flat: u5, index: o6 }), n9.symbols.set(f4, { flat: u5, index: o6 });
        for (const e9 of u5) o6.getCell(e9.xTile, e9.yTile).push(e9);
      } else a8.set(f4, { flat: u5 }), n9.symbols.set(f4, { flat: u5 });
    }
    this._addSymbols(s6.key, y6);
  }
  deleteStyleLayers(e9) {
    this._uniqueSymbolLayerArray = null;
    for (const [s6, l7] of this._tiles) {
      const o6 = /* @__PURE__ */ new Map();
      for (const s7 of e9) l7.symbols.has(s7) && (o6.set(s7, l7.symbols.get(s7)), l7.symbols.delete(s7));
      this._removeSymbols(o6), 0 === l7.symbols.size && this._tiles.delete(s6);
    }
  }
  removeTile(e9) {
    this._uniqueSymbolLayerArray = null;
    const s6 = this._tiles.get(e9.id);
    if (!s6) return;
    const l7 = /* @__PURE__ */ new Map();
    for (const [o6, t8] of e9.symbols) s6.symbols.has(o6) && (l7.set(o6, s6.symbols.get(o6)), s6.symbols.delete(o6));
    this._removeSymbols(l7), 0 === s6.symbols.size && this._tiles.delete(e9.id);
  }
  querySymbols(e9, l7, o6, t8) {
    const i8 = [], n9 = this.uniqueSymbols;
    for (const r13 of n9) {
      const t9 = r13.styleLayerUID, n10 = r13.uniqueSymbols;
      for (const r14 of n10) {
        const n11 = r14.tileSymbols.find((e10) => e10.selectedForRendering);
        n11 && c3(n11, e9, l7 * (window.devicePixelRatio || 1), o6) && i8.push({ vtlSymbol: n11, styleLayerUID: t9, tileKey: n11.tile.key });
      }
    }
    return i8;
  }
  _removeSymbols(e9) {
    for (const [s6, { flat: l7 }] of e9) for (const e10 of l7) {
      const l8 = e10.unique, o6 = l8.tileSymbols, t8 = o6.length - 1;
      for (let s7 = 0; s7 < t8; s7++) if (o6[s7] === e10) {
        o6[s7] = o6[t8];
        break;
      }
      if (o6.length = t8, 0 === t8) {
        const e11 = this._uniqueSymbolsReferences.get(s6);
        e11.delete(l8), 0 === e11.size && this._uniqueSymbolsReferences.delete(s6);
      }
      e10.unique = null;
    }
  }
  _addSymbols(e9, s6) {
    if (0 === s6.size) return;
    const l7 = this._visibleTiles;
    for (const o6 of l7) o6.parentTile || o6.key.world !== e9.world || o6.key.level === e9.level && !o6.key.equals(e9) || this._matchSymbols(o6, e9, s6);
    for (const [o6, t8] of s6) for (const e10 of t8) if (null == e10.unique) {
      const s7 = this._createUnique();
      e10.unique = s7, s7.tileSymbols.push(e10);
      let l8 = this._uniqueSymbolsReferences.get(o6);
      l8 || (l8 = /* @__PURE__ */ new Set(), this._uniqueSymbolsReferences.set(o6, l8)), l8.add(s7);
    }
  }
  _matchSymbols(e9, s6, o6) {
    if (e9.key.level > s6.level) {
      const l7 = e9.key.level - s6.level;
      if (e9.key.row >> l7 !== s6.row || e9.key.col >> l7 !== s6.col) return;
    }
    if (s6.level > e9.key.level) {
      const l7 = s6.level - e9.key.level;
      if (s6.row >> l7 !== e9.key.row || s6.col >> l7 !== e9.key.col) return;
    }
    if (s6.equals(e9.key)) {
      for (const l7 of e9.childrenTiles) this._matchSymbols(l7, s6, o6);
      return;
    }
    const t8 = /* @__PURE__ */ new Map();
    for (const [i8, r13] of o6) {
      const o7 = [];
      for (const t9 of r13) {
        const i9 = o4(this.tileCoordRange, t9.xTile, s6.level, s6.col, e9.key.level, e9.key.col), n9 = o4(this.tileCoordRange, t9.yTile, s6.level, s6.row, e9.key.level, e9.key.row);
        i9 >= 0 && i9 < this.tileCoordRange && n9 >= 0 && n9 < this.tileCoordRange && o7.push({ symbol: t9, xTransformed: i9, yTransformed: n9 });
      }
      const y6 = [], a8 = (e9.key.level < s6.level ? 1 : 1 << e9.key.level - s6.level) + n8, f4 = this._tiles.get(e9.id).symbols.get(i8);
      if (f4) {
        const e10 = f4.flat;
        for (const s7 of o7) {
          let l7, o8 = false;
          const t9 = s7.xTransformed, i9 = s7.yTransformed;
          l7 = null != f4.index ? f4.index.getCell(t9, i9) : e10;
          const n9 = s7.symbol, r14 = n9.hash;
          for (const e11 of l7) if (r14 === e11.hash && Math.abs(t9 - e11.xTile) <= a8 && Math.abs(i9 - e11.yTile) <= a8) {
            const s8 = e11.unique;
            n9.unique = s8, s8.tileSymbols.push(n9), o8 = true;
            break;
          }
          o8 || y6.push(n9);
        }
      }
      y6.length > 0 && t8.set(i8, y6);
    }
    for (const l7 of e9.childrenTiles) this._matchSymbols(l7, s6, t8);
  }
  _createUniqueSymbolLayerArray() {
    const e9 = this._uniqueSymbolsReferences, s6 = new Array(e9.size);
    let l7, o6 = 0;
    for (const [t8, i8] of e9) {
      const e10 = new Array(i8.size);
      l7 = 0;
      for (const s7 of i8) e10[l7++] = s7;
      s6[o6] = { styleLayerUID: t8, uniqueSymbols: e10 }, o6++;
    }
    return s6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/decluttering/SymbolFader.js
var c5 = 0.5;
var h6 = 1e-6;
var _2 = class {
  constructor(e9, i8) {
    this.styleRepository = e9, this._tileToHandle = /* @__PURE__ */ new Map(), this._viewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._declutterViewState = { scale: 0, rotation: 0, center: [0, 0], size: [0, 0] }, this._offsetFromScreenCenter = [0, 0], this._completed = false, this._fading = r4(false), this._symbolRepository = new r12(4096, i8, () => new s5()), this._symbolDeclutterer = new t4(i8, this._symbolRepository, (t8, e10, i9) => this._createCollisionJob(t8, e10, i9), (t8, e10) => {
      t8.allSymbolsFadingOut = true, t8.lastOpacityUpdate = e10, r11(t8, e10, true), t8.decluttered = true, t8.requestRender();
    }, (t8, e10) => this.styleRepository.getStyleLayerByUID(t8.styleLayerUID).z - this.styleRepository.getStyleLayerByUID(e10.styleLayerUID).z, (t8) => {
      const e10 = this.styleRepository.getStyleLayerByUID(t8);
      if (this._zoom + h6 < e10.minzoom || this._zoom - h6 >= e10.maxzoom) return false;
      const i9 = e10.getLayoutProperty("visibility");
      return !i9 || i9.getValue() !== i.NONE;
    });
  }
  get symbolRepository() {
    return this._symbolRepository;
  }
  _createCollisionJob(t8, e9, i8) {
    return this.updateDecluttererViewState(), new l6(t8, e9, i8, this.styleRepository, this._zoom, this._viewState.rotation);
  }
  get fading() {
    return this._fading.value;
  }
  get decluttererOffset() {
    return this._offsetFromScreenCenter;
  }
  addTile(t8) {
    t8.decluttered = false, this._tileToHandle.set(t8, t8.on("symbols-changed", () => {
      this._symbolRepository.add(t8), this.restartDeclutter();
    })), this._symbolRepository.add(t8), this.restartDeclutter();
  }
  removeTile(t8) {
    const e9 = this._tileToHandle.get(t8);
    e9 && (this._symbolRepository.removeTile(t8), this.restartDeclutter(), e9.remove(), this._tileToHandle.delete(t8));
  }
  update(t8, e9) {
    this._zoom = t8, this._viewState = { scale: e9.scale, rotation: e9.rotation, center: [e9.center[0], e9.center[1]], size: [e9.size[0], e9.size[1]] };
    const i8 = [0, 0];
    e9.toScreen(i8, e9.center);
    const s6 = [0, 0];
    return e9.toScreen(s6, this._declutterViewState.center), this._offsetFromScreenCenter[0] = i8[0] - s6[0], this._offsetFromScreenCenter[1] = i8[1] - s6[1], this._continueDeclutter(), this._completed;
  }
  restartDeclutter() {
    this._completed = false, this._symbolDeclutterer.restart(), this._notifyUnstable();
  }
  clear() {
    this._completed = false, this._symbolRepository = null, this._symbolDeclutterer.restart(), this._tileToHandle.forEach((t8) => t8.remove()), this._tileToHandle.clear();
  }
  get stale() {
    return this._zoom !== this._declutterZoom || this._viewState.size[0] !== this._declutterViewState.size[0] || this._viewState.size[1] !== this._declutterViewState.size[1] || this._viewState.scale !== this._declutterViewState.scale || this._viewState.rotation !== this._declutterViewState.rotation;
  }
  deleteStyleLayers(t8) {
    this._symbolRepository.deleteStyleLayers(t8);
  }
  _continueDeclutter() {
    this._completed && !this.stale || (this._symbolDeclutterer.running || (this.updateDecluttererViewState(), this._symbolDeclutterer.restart()), this._symbolDeclutterer.setScreenSize(this._viewState.size[0], this._viewState.size[1]), this._completed = this._symbolDeclutterer.continue(c), this._completed && this._scheduleNotifyStable());
  }
  _scheduleNotifyStable() {
    null != this._stableNotificationHandle && clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = setTimeout(() => {
      this._stableNotificationHandle = null, this._fading.value = false;
    }, (1 + c5) * e4);
  }
  _notifyUnstable() {
    null != this._stableNotificationHandle && (clearTimeout(this._stableNotificationHandle), this._stableNotificationHandle = null), this._fading.value = true;
  }
  updateDecluttererViewState() {
    this._declutterZoom = this._zoom, this._declutterViewState.center[0] = this._viewState.center[0], this._declutterViewState.center[1] = this._viewState.center[1], this._declutterViewState.rotation = this._viewState.rotation, this._declutterViewState.scale = this._viewState.scale, this._declutterViewState.size[0] = this._viewState.size[0], this._declutterViewState.size[1] = this._viewState.size[1], this._offsetFromScreenCenter[0] = 0, this._offsetFromScreenCenter[1] = 0;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/RenderableTile.js
var t6 = class extends r7 {
  _createTransforms() {
    return { displayViewScreenMat3: e6(), tileMat3: e6() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileContainer.js
var y4 = 1e-6;
function p6(e9, t8) {
  if (e9) {
    const s6 = e9.getLayoutProperty("visibility");
    if (!s6 || s6.getValue() !== i.NONE && (void 0 === e9.minzoom || e9.minzoom < t8 + y4) && (void 0 === e9.maxzoom || e9.maxzoom >= t8 - y4)) return true;
  }
  return false;
}
var m3 = class extends i2 {
  constructor(e9) {
    super(e9), this._backgroundTiles = [], this._computeDisplayInfoView(e9);
  }
  destroy() {
    var _a, _b;
    this.removeAllChildren(), (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = null, (_b = this._glyphMosaic) == null ? void 0 : _b.dispose(), this._glyphMosaic = null, null != this._symbolFader && (this._symbolFader.clear(), this._symbolFader = null), this._styleRepository = null, this._backgroundTiles = [];
  }
  get fading() {
    var _a;
    return ((_a = this._symbolFader) == null ? void 0 : _a.fading) ?? false;
  }
  get symbolFader() {
    return this._symbolFader;
  }
  get symbolRepository() {
    var _a;
    return (_a = this._symbolFader) == null ? void 0 : _a.symbolRepository;
  }
  setStyleResources(e9, t8, r13, i8) {
    this._spriteMosaic = e9, this._glyphMosaic = t8, this._styleRepository = r13, this.tileInfoView = i8, this._computeDisplayInfoView(i8), null == this._symbolFader && (this._symbolFader = new _2(this._styleRepository, this.children)), this._symbolFader.styleRepository = r13;
  }
  setSpriteMosaic(e9) {
    var _a;
    (_a = this._spriteMosaic) == null ? void 0 : _a.dispose(), this._spriteMosaic = e9;
  }
  deleteStyleLayers(e9) {
    null != this._symbolFader && this._symbolFader.deleteStyleLayers(e9);
  }
  createRenderParams(e9) {
    return { ...super.createRenderParams(e9), renderPass: null, styleLayer: null, styleLayerUID: -1, glyphMosaic: this._glyphMosaic, spriteMosaic: this._spriteMosaic, hasClipping: !!this._clippingInfos };
  }
  doRender(e9) {
    !this.visible || e9.drawPhase !== E4.MAP && e9.drawPhase !== E4.DEBUG || void 0 === this._spriteMosaic || super.doRender(e9);
  }
  addChild(e9) {
    return super.addChild(e9), null != this._symbolFader ? this._symbolFader.addTile(e9) : e9.decluttered = true, this.requestRender(), e9;
  }
  removeChild(e9) {
    return null != this._symbolFader && this._symbolFader.removeTile(e9), this.requestRender(), super.removeChild(e9);
  }
  renderChildren(e9) {
    const { drawPhase: t8 } = e9;
    t8 !== E4.DEBUG ? this._doRender(e9) : super.renderChildren(e9);
  }
  removeAllChildren() {
    for (let e9 = 0; e9 < this.children.length; e9++) {
      const t8 = this.children[e9];
      null != this._symbolFader && this._symbolFader.removeTile(t8), t8.dispose();
    }
    super.removeAllChildren();
  }
  getStencilTarget() {
    return this.children.filter((e9) => e9.neededForCoverage && e9.hasData());
  }
  restartDeclutter() {
    null != this._symbolFader && this._symbolFader.restartDeclutter();
  }
  _doRender(e9) {
    const { context: t8, state: s6 } = e9, r13 = this._styleRepository;
    if (!r13) return;
    const i8 = r13.layers, o6 = this._displayInfo.scaleToZoom(s6.scale);
    r13.backgroundBucketIds.length > 0 && (e9.renderPass = "background", this._renderBackgroundLayers(e9, r13.backgroundBucketIds, o6)), super.renderChildren(e9), e9.drawPhase === E4.MAP && this._fade(o6, s6);
    const n9 = this.children.filter((e10) => e10.visible && e10.hasData());
    if (!n9 || 0 === n9.length) return t8.bindVAO(), t8.setStencilTestEnabled(true), void t8.setBlendingEnabled(true);
    for (const l7 of n9) l7.triangleCount = 0;
    t8.setStencilWriteMask(0), t8.setColorMask(true, true, true, true), t8.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(false), t8.setDepthTestEnabled(true), t8.setDepthWriteEnabled(true), t8.setDepthFunction(O.LEQUAL), t8.setClearDepth(1), t8.clear(t8.gl.DEPTH_BUFFER_BIT), e9.renderPass = "opaque";
    for (let l7 = i8.length - 1; l7 >= 0; l7--) this._renderStyleLayer(i8[l7], e9, n9);
    t8.setDepthWriteEnabled(false), t8.setBlendingEnabled(true), t8.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e9.renderPass = "translucent";
    for (let l7 = 0; l7 < i8.length; l7++) this._renderStyleLayer(i8[l7], e9, n9);
    t8.bindVAO(), t8.setStencilTestEnabled(true), t8.setBlendingEnabled(true);
    for (const l7 of n9) l7.debugInfo.display.triangleCount = l7.triangleCount;
  }
  _fade(e9, t8) {
    null != this._symbolFader && (this._symbolFader.update(e9, t8) || this.requestRender());
  }
  _renderStyleLayer(e9, t8, s6) {
    const { displayLevel: l7, painter: o6, renderPass: n9 } = t8;
    if (void 0 === e9) return;
    const a8 = e9.getLayoutProperty("visibility");
    if (a8 && a8.getValue() === i.NONE) return;
    let d6;
    switch (e9.type) {
      case a5.BACKGROUND:
        return;
      case a5.FILL:
        if ("opaque" !== n9 && "translucent" !== t8.renderPass) return;
        d6 = "vtlFill";
        break;
      case a5.LINE:
        if ("translucent" !== n9) return;
        d6 = "vtlLine";
        break;
      case a5.CIRCLE:
        if ("translucent" !== n9) return;
        d6 = "vtlCircle";
        break;
      case a5.SYMBOL:
        if ("translucent" !== n9) return;
        d6 = "vtlSymbol";
    }
    if (s6 = e9.type === a5.SYMBOL ? s6.filter((e10) => e10.decluttered) : s6.filter((e10) => e10.neededForCoverage), "vtlSymbol" !== d6 && (0 === s6.length || void 0 !== e9.minzoom && e9.minzoom >= l7 + y4 || void 0 !== e9.maxzoom && e9.maxzoom < l7 - y4)) return;
    const h8 = e9.uid;
    t8.styleLayerUID = h8, t8.styleLayer = e9;
    for (const r13 of s6) if (r13.layerData.has(h8)) {
      o6.renderObjects(t8, s6, d6);
      break;
    }
  }
  _renderBackgroundLayers(t8, s6, r13) {
    const { context: l7, painter: n9, state: u5 } = t8, y6 = this._styleRepository;
    let m5 = false;
    for (const e9 of s6) {
      if (y6.getLayerById(e9).type === a5.BACKGROUND && p6(y6.getLayerById(e9), r13)) {
        m5 = true;
        break;
      }
    }
    if (!m5) return;
    const f4 = this.tileInfoView, g2 = f4.getTileCoverage(t8.state, 0, true, "smallest"), { spans: _3, lodInfo: b2 } = g2, { level: E6 } = b2, C = u2(), F2 = [];
    if (this._renderPasses) {
      const e9 = this._renderPasses[0];
      null != this._clippingInfos && (e9.brushes[0].prepareState(t8), e9.brushes[0].drawMany(t8, this._clippingInfos));
    }
    const L2 = this._backgroundTiles;
    let R2, v = 0;
    for (const { row: i8, colFrom: a8, colTo: h8 } of _3) for (let t9 = a8; t9 <= h8; t9++) {
      if (v < L2.length) R2 = L2[v], R2.key.set(E6, i8, b2.normalizeCol(t9), b2.getWorldForColumn(t9)), f4.getTileBounds(C, R2.key, false), R2.x = C[0], R2.y = C[3], R2.resolution = f4.getTileResolution(E6);
      else {
        const s7 = new e3(E6, i8, b2.normalizeCol(t9), b2.getWorldForColumn(t9)), r14 = f4.getTileBounds(u2(), s7), l8 = f4.getTileResolution(E6);
        R2 = new t6(s7, l8, r14[0], r14[3], 512, 512, 4096, 4096), L2.push(R2);
      }
      R2.setTransform(u5), F2.push(R2), v++;
    }
    l7.setStencilWriteMask(0), l7.setColorMask(true, true, true, true), l7.setStencilOp(I.KEEP, I.KEEP, I.REPLACE), l7.setStencilFunction(O.EQUAL, 0, 255), l7.setStencilTestEnabled(true);
    for (const e9 of s6) {
      const s7 = y6.getLayerById(e9);
      s7.type === a5.BACKGROUND && p6(s7, r13) && (t8.styleLayerUID = s7.uid, t8.styleLayer = s7, n9.renderObjects(t8, F2, "vtlBackground"));
    }
    s2.pool.release(g2);
  }
  _computeDisplayInfoView(e9) {
    let s6 = e9.tileInfo.lods[0].scale;
    const r13 = Math.max(25, e9.tileInfo.lods.length), i8 = [];
    for (let t8 = 0; t8 <= r13; t8++) i8.push(s6), s6 /= 2;
    this._displayInfo = z.create({ scales: i8, size: 512, spatialReference: e9.spatialReference, numLODs: r13 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/VectorTileFeatureIndex.js
var y5 = 8;
var c6 = 512;
var u4 = 4096;
var h7 = (e9, t8) => {
  const s6 = e9.vtlSymbol.sourceTile, r13 = t8.vtlSymbol.sourceTile;
  return s6.level !== r13.level ? s6.level - r13.level : s6.row !== r13.row ? s6.row - r13.row : s6.col !== r13.col ? s6.col - r13.col : e9.styleLayerUID - t8.styleLayerUID;
};
var d5 = class _d {
  constructor(e9, t8, s6, r13, i8) {
    this.tileKey = e9, this._tileLayerData = t8, this._styleRepository = s6, this._tileHandler = r13, this._parentLayer = i8, this._index = null, this._tileKeyToPBF = /* @__PURE__ */ new Map();
  }
  static create(e9, t8, s6, r13, i8) {
    return new _d(e9, t8, s6, r13, i8);
  }
  clear() {
    var _a;
    (_a = this._index) == null ? void 0 : _a.clear(), this._tileKeyToPBF.clear();
  }
  async queryAttributes(e9, t8, s6, i8, o6) {
    if (0 === this._tileLayerData.size || !this._styleRepository || !this._tileHandler) return [];
    null === this._index && (this._index = new h2(100, m4), await this._indexLayers());
    const l7 = [];
    return this._queryIndex(l7, e9, t8, s6, this.tileKey.level, i8), o6 && (o6 == null ? void 0 : o6.length) > 0 && await this._getSymbolsAttributes(l7, o6), l7;
  }
  async _indexLayers() {
    const e9 = this.tileKey, t8 = this._styleRepository.layers, s6 = await this._getTilePayload(e9);
    for (const [r13, o6] of this._tileLayerData) {
      const l7 = t8[r13], n9 = s6.find((e10) => e10.sourceName === l7.source);
      if (!n9) continue;
      const { protobuff: a8, key: y6 } = n9;
      if (o6.type !== E2.SYMBOL) {
        const t9 = 1 << e9.level - y6.level, s7 = e9.row - y6.row * t9, r14 = e9.col - y6.col * t9;
        this._indexLayer(l7, a8, e9.level, t9, s7, r14);
      }
    }
  }
  _indexLayer(e9, t8, r13, i8, y6, h8) {
    const d6 = e9.sourceLayer, m5 = e9.getFeatureFilter(), f4 = r13, _3 = r13 + 1, p7 = d3(f4), g2 = new n2(new Uint8Array(t8), new DataView(t8));
    for (; g2.next(); ) switch (g2.tag()) {
      case 3: {
        const t9 = g2.getMessage(), s6 = new e5(t9);
        if (t9.release(), s6.name !== d6) continue;
        const l7 = s6.getData(), w2 = s6.extent / i8, x = w2 * h8 - p7, b2 = w2 * y6 - p7, I3 = x + w2 + 2 * p7, L2 = b2 + w2 + 2 * p7, v = w2 / c6, D3 = u4 / w2, T = w2 * h8, S2 = w2 * y6;
        for (; l7.nextTag(2); ) {
          const t10 = l7.getMessage(), i9 = new s3(t10, s6);
          if (t10.release(), m5 && !m5.filter(i9, r13)) continue;
          const n9 = i9.values || {}, y7 = n9._minzoom, c7 = n9._maxzoom;
          if (y7 && y7 >= 10 * _3 || c7 && c7 <= 10 * f4) continue;
          const u5 = e9.getFeatureInflatedBounds(i9, f4, s6.extent, v);
          null == u5 || u5[0] > I3 || u5[1] > L2 || u5[2] < x || u5[3] < b2 || (u5[0] = (u5[0] - T) * D3, u5[1] = (u5[1] - S2) * D3, u5[2] = (u5[2] - T) * D3, u5[3] = (u5[3] - S2) * D3, this._index.insert(new L(e9, i9, u5, D3, T, S2)));
        }
        break;
      }
      default:
        g2.skip();
    }
  }
  async _getSymbolsAttributes(e9, t8) {
    if (!t8 || 0 === t8.length) return e9;
    const s6 = [];
    t8.sort(h7);
    let r13 = t8[0].styleLayerUID, i8 = 0;
    for (let a8 = 0; a8 < t8.length; a8++) r13 !== t8[a8].styleLayerUID && (s6.push({ from: i8, to: a8, styleLayerUID: r13, sourceTileKey: t8[a8].vtlSymbol.sourceTile }), i8 = a8, r13 = t8[a8].styleLayerUID);
    s6.push({ from: i8, to: t8.length, styleLayerUID: r13, sourceTileKey: t8[t8.length - 1].vtlSymbol.sourceTile });
    const o6 = this._styleRepository.layers;
    let l7, n9 = null;
    for (const a8 of s6) {
      const s7 = await this._getTilePayload(a8.sourceTileKey);
      l7 = o6[a8.styleLayerUID], n9 = !!l7 && s7.find((e10) => e10.sourceName === l7.source), n9 && this._addSymbolsAttributes(e9, t8.slice(a8.from, a8.to).map((e10) => e10.vtlSymbol), r13, n9);
    }
    return e9;
  }
  _addSymbolsAttributes(t8, s6, r13, i8) {
    const o6 = this._styleRepository.layers, l7 = i8.key, n9 = this.tileKey, a8 = 1 << n9.level - l7.level, y6 = n9.row - l7.row * a8, c7 = n9.col - l7.col * a8;
    this._getSymbolAttributes(i8.protobuff, s6, r13, a8, y6, c7).forEach((s7) => {
      const { attributes: i9, tilePoint: l8 } = s7;
      t8.push({ layerId: o6[r13].id, layerIndex: r13, graphic: new d({ attributes: i9, origin: { type: "vector-tile", layerId: o6[r13].id, layerIndex: r13, layer: this._parentLayer } }), tilePoint: l8 });
    });
  }
  _getSymbolAttributes(e9, t8, r13, i8, l7, a8) {
    const y6 = [], c7 = this._styleRepository.layers;
    let h8 = 0;
    t8.sort((e10, t9) => e10.featureIndex - t9.featureIndex);
    const d6 = new n2(new Uint8Array(e9), new DataView(e9));
    for (; d6.next(); ) switch (d6.tag()) {
      case 3: {
        const e10 = d6.getMessage(), s6 = new e5(e10);
        if (e10.release(), s6.name !== c7[r13].sourceLayer) continue;
        const m5 = s6.getData(), f4 = s6.extent / i8, _3 = u4 / f4, p7 = f4 * a8, g2 = f4 * l7;
        let w2 = 0;
        for (; m5.nextTag(2); ) {
          const e11 = m5.getMessage();
          if (w2++ === t8[h8].featureIndex) {
            const t9 = new s3(e11, s6), r14 = t9.values, i9 = t9.getGeometry(), l8 = null != i9 ? [_3 * (i9[0][0].x - p7), _3 * (i9[0][0].y - g2)] : null;
            y6.push({ attributes: r14, tilePoint: l8 }), h8++;
          }
          if (e11.release(), h8 === t8.length) return y6;
        }
        break;
      }
      default:
        d6.skip();
    }
    return y6;
  }
  _queryIndex(t8, s6, r13, i8, o6, l7) {
    var _a;
    const n9 = y5 * i8 * (window.devicePixelRatio || 1);
    return (_a = this._index) == null ? void 0 : _a.search({ minX: s6 - n9, minY: r13 - n9, maxX: s6 + n9, maxY: r13 + n9 }, (n10) => {
      const { layer: a8, feature: y6 } = n10;
      a8.isIntersectingFeature(s6, r13, i8, y6, o6, l7, n10) && t8.push({ layerId: a8.id, layerIndex: a8.uid, tilePoint: null, graphic: new d({ attributes: y6.values, origin: { type: "vector-tile", layerId: n10.layer.id, layerIndex: n10.layer.uid, layer: this._parentLayer } }) });
    }), t8;
  }
  async _getTilePayload(e9) {
    return r2(this._tileKeyToPBF, e9.id, () => this._tileHandler.fetchTilePBFs(e9)).then((e10) => e10);
  }
};
var m4 = (e9) => ({ minX: e9.bounds[0], minY: e9.bounds[1], maxX: e9.bounds[2], maxY: e9.bounds[3] });

// node_modules/@arcgis/core/views/2d/tiling/TileInfoViewPOT.js
var t7 = class extends h3 {
  constructor() {
    super(...arguments), this._fullCacheLodInfos = null, this._levelByScale = {};
  }
  getTileParentId(e9) {
    const l7 = e3.pool.acquire(e9), t8 = 0 === l7.level ? null : e3.getId(l7.level - 1, l7.row >> 1, l7.col >> 1, l7.world);
    return e3.pool.release(l7), t8;
  }
  getTileCoverage(e9, l7, s6 = true, t8) {
    const o6 = super.getTileCoverage(e9, l7, s6, t8);
    if (!o6) return o6;
    const i8 = 1 << o6.lodInfo.level;
    return o6.spans = o6.spans.filter((e10) => e10.row >= 0 && e10.row < i8), o6;
  }
  scaleToLevel(e9) {
    if (this._fullCacheLodInfos || this._initializeFullCacheLODs(this._lodInfos), this._levelByScale[e9]) return this._levelByScale[e9];
    {
      const l7 = this._fullCacheLodInfos;
      if (e9 > l7[0].scale) return l7[0].level;
      let s6, t8;
      for (let o6 = 0; o6 < l7.length - 1; o6++) if (t8 = l7[o6 + 1], e9 > t8.scale) return s6 = l7[o6], s6.level + (s6.scale - e9) / (s6.scale - t8.scale);
      return l7[l7.length - 1].level;
    }
  }
  _initializeFullCacheLODs(l7) {
    let s6;
    if (0 === l7[0].level) s6 = l7.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    else {
      const l8 = this.tileInfo.size[0], t8 = this.tileInfo.spatialReference;
      s6 = z.create({ size: l8, spatialReference: t8 }).lods.map((e9) => ({ level: e9.level, resolution: e9.resolution, scale: e9.scale }));
    }
    for (let e9 = 0; e9 < s6.length; e9++) this._levelByScale[s6[e9].scale] = s6[e9].level;
    this._fullCacheLodInfos = s6;
  }
};

// node_modules/@arcgis/core/views/2d/layers/VectorTileLayerView2D.js
var S = 2;
var D2 = 8;
var P = 512;
var Q = class extends i3(j2(y2)) {
  constructor() {
    super(...arguments), this._styleChanges = [], this._fetchQueue = null, this._parseQueue = null, this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._styeChanged = false, this._spriteSourceChanged = false;
  }
  get fading() {
    var _a;
    return ((_a = this._vectorTileContainer) == null ? void 0 : _a.fading) ?? false;
  }
  get hasVisibleFeatures() {
    const e9 = this._vectorTileContainer.children;
    for (const t8 of e9) if (t8.hasFeatures()) return true;
    return false;
  }
  get spriteSourceChanged() {
    return this._spriteSourceChanged;
  }
  get styleChanged() {
    return this._styeChanged;
  }
  async hitTest(e9, t8) {
    var _a, _b;
    const i8 = this._tileHandlerPromise, s6 = (_a = this._vectorTileContainer) == null ? void 0 : _a.symbolFader;
    if (!i8 || !this._isTileHandlerReady || !s6) return;
    await i8;
    let r13 = null;
    const a8 = (_b = this._vectorTileContainer) == null ? void 0 : _b.symbolRepository;
    a8 && (r13 = a8.querySymbols(t8, S, s6.decluttererOffset, {}));
    const l7 = this.view.state, n9 = this._tileManager.getIntersectingTiles(t8.x, t8.y, S, l7, r13);
    if ((!n9 || 0 === n9.length) && 0 === (r13 == null ? void 0 : r13.length)) return null;
    e9 = e9.clone().normalize();
    const o6 = [], h8 = [];
    for (const u5 of n9) o6.push(this._queryTile(h8, e9, S, this.view.state.rotation, u5, r13 == null ? void 0 : r13.filter((e10) => e10.tileKey.id === u5.id)));
    return await Promise.all(o6), h8;
  }
  update(e9) {
    if (this._tileHandlerPromise && this._isTileHandlerReady) return e9.pixelRatio !== this._tileHandler.devicePixelRatio ? (this._start(), void (this._tileHandler.devicePixelRatio = e9.pixelRatio)) : void (this._styleChanges.length > 0 ? this._tileHandlerPromise = this._applyStyleChanges() : (this._pauseQueues(), this._fetchQueue.state = e9.state, this._parseQueue.state = e9.state, this._tileManager.update(e9) || this.requestUpdate(), this._resumeQueues()));
  }
  attach() {
    const { style: e9 } = this.layer.currentStyleInfo;
    this._styleRepository = new l2(e9), this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), this._vectorTileContainer = new m3(this._tileInfoView), this._tileHandler = new p5(this.layer, this._styleRepository, window.devicePixelRatio || 1, this.layer.tileInfo.lods.length - 1), this.container.addChild(this._vectorTileContainer), this._start(), this.addAttachHandles([this.layer.on("paint-change", (e10) => {
      var _a, _b;
      if (this._styeChanged = true, e10.isDataDriven) this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: e10 }), this.requestUpdate();
      else {
        const t8 = this._styleRepository, i8 = t8.getLayerById(e10.layer);
        if (!i8) return;
        const s6 = i8.type === a5.SYMBOL;
        t8.setPaintProperties(e10.layer, e10.paint), s6 && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender();
      }
    }), this.layer.on("layout-change", (e10) => {
      var _a, _b;
      const t8 = this._styleRepository, i8 = t8.getLayerById(e10.layer);
      if (!i8) return;
      this._styeChanged = true;
      const s6 = d2(i8.layout, e10.layout);
      if (null != s6) {
        if (p(s6, "visibility") && 1 === E5(s6)) return t8.setLayoutProperties(e10.layer, e10.layout), i8.type === a5.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), void ((_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
        this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: e10 }), this.requestUpdate();
      }
    }), this.layer.on("style-layer-visibility-change", (e10) => {
      var _a, _b;
      const t8 = this._styleRepository, i8 = t8.getLayerById(e10.layer);
      i8 && (this._styeChanged = true, t8.setStyleLayerVisibility(e10.layer, e10.visibility), i8.type === a5.SYMBOL && ((_a = this._vectorTileContainer) == null ? void 0 : _a.restartDeclutter()), (_b = this._vectorTileContainer) == null ? void 0 : _b.requestRender());
    }), this.layer.on("style-layer-change", (e10) => {
      this._styleChanges.push({ type: I2.LAYER_CHANGED, data: e10 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("delete-style-layer", (e10) => {
      this._styleChanges.push({ type: I2.LAYER_REMOVED, data: e10 }), this._styeChanged = true, this.requestUpdate();
    }), this.layer.on("load-style", () => this._loadStyle()), this.layer.on("spriteSource-change", (e10) => {
      this._spriteSourceChanged = true, this._styleChanges.push({ type: I2.SPRITES_CHANGED, data: e10 });
      const t8 = this._styleRepository.layers;
      for (const i8 of t8) switch (i8.type) {
        case a5.SYMBOL:
          i8.getLayoutProperty("icon-image") && this._styleChanges.push({ type: I2.LAYOUT_CHANGED, data: { layer: i8.id, layout: i8.layout } });
          break;
        case a5.LINE:
          i8.getPaintProperty("line-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i8.id, paint: i8.paint, isDataDriven: i8.isPainterDataDriven() } });
          break;
        case a5.FILL:
          i8.getLayoutProperty("fill-pattern") && this._styleChanges.push({ type: I2.PAINTER_CHANGED, data: { layer: i8.id, paint: i8.paint, isDataDriven: i8.isPainterDataDriven() } });
      }
      this.requestUpdate();
    })]);
  }
  detach() {
    this._stop(), this.container.removeAllChildren(), this._vectorTileContainer = u(this._vectorTileContainer), this._tileHandler = u(this._tileHandler);
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  supportsSpatialReference(e9) {
    var _a;
    return s((_a = this.layer.tileInfo) == null ? void 0 : _a.spatialReference, e9);
  }
  canResume() {
    let e9 = super.canResume();
    const { currentStyleInfo: t8 } = this.layer;
    if (e9 && (t8 == null ? void 0 : t8.layerDefinition)) {
      const i8 = this.view.scale, { minScale: s6, maxScale: r13 } = t8.layerDefinition;
      (t8 == null ? void 0 : t8.layerDefinition) && (s6 && s6 < i8 && (e9 = false), r13 && r13 > i8 && (e9 = false));
    }
    return e9;
  }
  isUpdating() {
    return this.fading;
  }
  acquireTile(e9) {
    const t8 = this._createVectorTile(e9);
    return this._updatingHandles.addPromise(this._fetchQueue.push(t8.key).then((e10) => this._parseQueue.push({ key: t8.key, data: e10 })).then((e10) => {
      t8.once("attach", () => this.requestUpdate()), t8.setData(e10), this.requestUpdate();
    }).catch((e10) => {
      b(e10) || n.getLogger(this).error(e10);
    })), t8;
  }
  releaseTile(e9) {
    const t8 = e9.key.id;
    this._fetchQueue.abort(t8), this._parseQueue.abort(t8), this.requestUpdate();
  }
  async doRefresh() {
    if (!this.attached) return;
    if (this.suspended) return this._tileManager.clear(), void this.requestUpdate();
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache(), this._resumeQueues();
    const e9 = this._vectorTileContainer.children, t8 = [];
    try {
      for (const i8 of e9) {
        const e10 = this._updatingHandles.addPromise(this._fetchQueue.push(i8.key).then((e11) => this._parseQueue.push({ key: i8.key, data: e11 })).then((e11) => i8.setData(e11)).finally(() => i8.featureIndex = null));
        t8.push(e10);
      }
      await Promise.all(t8);
    } catch (s6) {
      n.getLogger(this).error("error refreshing vector-tiles layer-view", s6), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    this._isTileHandlerReady = true, this.requestUpdate();
  }
  _start() {
    if (this._stop(), this._tileManager = new h4({ acquireTile: (e10) => this.acquireTile(e10), releaseTile: (e10) => this.releaseTile(e10), tileInfoView: this._tileInfoView }, this._vectorTileContainer), !this.layer.currentStyleInfo) return;
    const e9 = new AbortController(), t8 = this._tileHandler.start({ signal: e9.signal }).then(() => {
      this._fetchQueue = new p3({ tileInfoView: this._tileInfoView, process: (e10, t9) => this._getTileData(e10, t9), concurrency: 15, scheduler: this.scheduler, priority: g.MAPVIEW_FETCH_QUEUE }), this._parseQueue = new p3({ tileInfoView: this._tileInfoView, process: (e10, t9) => this._parseTileData(e10, t9), concurrency: 8, scheduler: this.scheduler, priority: g.MAPVIEW_VECTOR_TILE_PARSING_QUEUE }), this.requestUpdate(), this._isTileHandlerReady = true;
    });
    this._tileHandler.spriteMosaic.then((e10) => {
      this._vectorTileContainer.setStyleResources(e10, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this.requestUpdate();
    }), this._tileHandlerAbortController = e9, this._tileHandlerPromise = t8;
  }
  _stop() {
    if (!this._tileHandlerAbortController || !this._vectorTileContainer) return;
    const e9 = this._tileHandlerAbortController;
    e9 && e9.abort(), this._tileHandlerPromise = null, this._isTileHandlerReady = false, this._fetchQueue = u(this._fetchQueue), this._parseQueue = u(this._parseQueue), this._tileManager = u(this._tileManager), this._vectorTileContainer.removeAllChildren();
  }
  async _getTileData(e9, t8) {
    return this._tileHandler.fetchTileData(e9, t8);
  }
  async _parseTileData(e9, t8) {
    return this._tileHandler.parseTileData(e9, t8);
  }
  async _applyStyleChanges() {
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._tileManager.clearCache();
    const e9 = this._styleChanges;
    try {
      await this._tileHandler.updateStyle(e9);
    } catch (l7) {
      n.getLogger(this).error("error applying vector-tiles style update", l7.message), this._resumeQueues(), this._isTileHandlerReady = true;
    }
    const t8 = this._styleRepository, s6 = /* @__PURE__ */ new Set();
    e9.forEach((e10) => {
      if (e10.type !== I2.LAYER_REMOVED) return;
      const i8 = e10.data, r14 = t8.getLayerById(i8.layer);
      r14 && s6.add(r14.uid);
    });
    const r13 = /* @__PURE__ */ new Set();
    e9.forEach((e10) => {
      let i8;
      switch (e10.type) {
        case I2.PAINTER_CHANGED:
          t8.setPaintProperties(e10.data.layer, e10.data.paint), i8 = e10.data.layer;
          break;
        case I2.LAYOUT_CHANGED:
          t8.setLayoutProperties(e10.data.layer, e10.data.layout), i8 = e10.data.layer;
          break;
        case I2.LAYER_REMOVED:
          return void t8.deleteStyleLayer(e10.data.layer);
        case I2.LAYER_CHANGED:
          t8.setStyleLayer(e10.data.layer, e10.data.index), i8 = e10.data.layer.id;
          break;
        case I2.SPRITES_CHANGED:
          this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(e10.data.spriteSource));
      }
      if (i8) {
        const e11 = t8.getLayerById(i8);
        e11 && r13.add(e11.uid);
      }
    });
    const a8 = this._vectorTileContainer.children;
    if (s6.size > 0) {
      const e10 = Array.from(s6);
      this._vectorTileContainer.deleteStyleLayers(e10);
      for (const t9 of a8) t9.deleteLayerData(e10);
    }
    if (this._resumeQueues(), r13.size > 0) {
      const e10 = Array.from(r13), t9 = [];
      for (const i8 of a8) {
        const s7 = this._updatingHandles.addPromise(this._fetchQueue.push(i8.key).then((t10) => this._parseQueue.push({ key: i8.key, data: t10, styleLayerUIDs: e10 })).then((e11) => i8.setData(e11)).finally(() => i8.featureIndex = null));
        t9.push(s7);
      }
      await Promise.all(t9);
    }
    this._styleChanges = [], this._isTileHandlerReady = true, this.requestUpdate();
  }
  async _loadStyle() {
    const { style: e9 } = this.layer.currentStyleInfo, i8 = a(e9);
    this._isTileHandlerReady = false, this._pauseQueues(), this._clearQueues(), this._styleRepository = new l2(i8), this._vectorTileContainer.destroy(), this._tileManager.clear(), this._tileHandlerAbortController.abort(), this._tileHandlerAbortController = new AbortController();
    const { signal: s6 } = this._tileHandlerAbortController;
    try {
      this._tileHandlerPromise = this._tileHandler.setStyle(this._styleRepository, i8, this.layer.tileInfo.lods.length - 1), await this._tileHandlerPromise;
    } catch (n9) {
      if (!b(n9)) throw n9;
    }
    if (s6.aborted) return this._resumeQueues(), this._isTileHandlerReady = true, this._styeChanged = false, this._spriteSourceChanged = false, void this.requestUpdate();
    const a8 = await this._tileHandler.spriteMosaic, l7 = this._vectorTileContainer;
    this._tileInfoView = new t7(this.layer.tileInfo, this.layer.fullExtent), l7.setStyleResources(a8, this._tileHandler.glyphMosaic, this._styleRepository, this._tileInfoView), this._tileManager = new h4({ acquireTile: (e10) => this.acquireTile(e10), releaseTile: (e10) => this.releaseTile(e10), tileInfoView: this._tileInfoView }, this._vectorTileContainer), this._resumeQueues(), this._isTileHandlerReady = true, this.requestUpdate(), this._styeChanged = false, this._spriteSourceChanged = false;
  }
  _createVectorTile(e9) {
    const t8 = this._tileInfoView.getTileBounds(u2(), e9), i8 = this._tileInfoView.getTileResolution(e9.level);
    return new y3(e9, i8, t8[0], t8[3], 512, 512, this._styleRepository);
  }
  async _queryTile(e9, t8, i8, s6, r13, a8) {
    if (0 === r13.layerData.size) return;
    const l7 = this._ensureTileIndex(r13), n9 = this._tileInfoView.getTileBounds(u2(), r13.key, true), o6 = D2 * P * ((t8.x - n9[0]) / (n9[2] - n9[0])), h8 = D2 * P * (1 - (t8.y - n9[1]) / (n9[3] - n9[1])), y6 = await l7.queryAttributes(o6, h8, i8, s6, a8);
    for (const u5 of y6) u5.graphic.geometry = this._tileToMapPoint(u5.tilePoint, r13.transforms.tileUnitsToPixels), e9.push({ type: "graphic", layer: this.layer, graphic: u5.graphic, mapPoint: t8.clone() });
    e9.sort((e10, t9) => t9.graphic.origin.layerIndex - e10.graphic.origin.layerIndex);
  }
  _tileToMapPoint(e9, t8) {
    if (!e9) return null;
    const i8 = e9[0] * t8[0] + e9[1] * t8[3] + t8[6], s6 = e9[0] * t8[1] + e9[1] * t8[4] + t8[7], r13 = this.view.state, a8 = [0, 0];
    return r13.toMap(a8, [i8, s6]), new j({ x: a8[0], y: a8[1], spatialReference: r13.spatialReference });
  }
  _ensureTileIndex(e9) {
    let t8 = e9.featureIndex;
    return t8 || (t8 = d5.create(e9.key, e9.layerData, this._styleRepository, this._tileHandler, this.layer), e9.featureIndex = t8), t8;
  }
  _pauseQueues() {
    this._fetchQueue.pause(), this._parseQueue.pause();
  }
  _resumeQueues() {
    this._fetchQueue.resume(), this._parseQueue.resume();
  }
  _clearQueues() {
    this._fetchQueue.clear(), this._parseQueue.clear();
  }
};
function E5(e9) {
  if (null == e9) return 0;
  switch (e9.type) {
    case "partial":
      return Object.keys(e9.diff).length;
    case "complete":
      return Math.max(Object.keys(e9.oldValue).length, Object.keys(e9.newValue).length);
    case "collection":
      return Object.keys(e9.added).length + Object.keys(e9.changed).length + Object.keys(e9.removed).length;
  }
}
r([m()], Q.prototype, "_isTileHandlerReady", void 0), Q = r([a2("esri.views.2d.layers.VectorTileLayerView2D")], Q);
var A2 = Q;
export {
  A2 as default
};
//# sourceMappingURL=VectorTileLayerView2D-5P55B3VG.js.map
