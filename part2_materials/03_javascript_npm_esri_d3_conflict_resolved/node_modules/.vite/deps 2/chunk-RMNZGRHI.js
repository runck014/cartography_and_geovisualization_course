import {
  n as n6
} from "./chunk-U5TYWISK.js";
import {
  e as e3,
  f as f2,
  i as i2,
  l
} from "./chunk-QYBCLVRN.js";
import {
  c as c4
} from "./chunk-U7ZFK3X2.js";
import {
  a as a2,
  w as w2
} from "./chunk-VMQKPMJK.js";
import {
  C
} from "./chunk-A7PB2PTS.js";
import {
  a,
  m
} from "./chunk-7QP2TGTK.js";
import {
  T,
  i
} from "./chunk-RFXYK5PV.js";
import {
  e,
  o
} from "./chunk-5FROWG6B.js";
import {
  e as e2
} from "./chunk-NW7VXBHZ.js";
import {
  j,
  n as n5
} from "./chunk-D6FJTDNK.js";
import {
  A as A3,
  E,
  N,
  c as c3,
  y
} from "./chunk-RENLZYKC.js";
import {
  B,
  c as c2,
  f,
  h,
  n as n4
} from "./chunk-GNWAZIVF.js";
import {
  n as n2
} from "./chunk-6Y2LNRVP.js";
import {
  c
} from "./chunk-A3J7W53Y.js";
import {
  n as n3
} from "./chunk-Y6AYXNMP.js";
import {
  A as A2,
  x
} from "./chunk-6YWQXXBX.js";
import {
  A,
  D,
  I2 as I,
  V,
  W,
  w
} from "./chunk-DRBJFCLQ.js";
import {
  n2 as n
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/projection.js
var O = "Projection may be possible after calling projection.load().";
function F(r, t2, o2, e4) {
  r.error(`Failed to project from (wkid:${t2.wkid}) to (wkid:${o2.wkid}).${e4 ? " " : ""}${e4}`);
}
function E2(r, t2, o2, e4, n7, i3) {
  return B2(x2.TO_PCPF, i.fromTypedArray(r), V2.NORMAL, T.fromTypedArray(t2), o2, T.fromTypedArray(e4), n7, i.fromTypedArray(i3)) ? i3 : null;
}
function R(r, t2, o2, e4, n7, i3) {
  return B2(x2.FROM_PCPF, i.fromTypedArray(r), V2.NORMAL, T.fromTypedArray(t2), o2, T.fromTypedArray(e4), n7, i.fromTypedArray(i3)) ? i3 : null;
}
function g(r, t2, o2, e4) {
  return n3(r, t2, 0, o2, e4, 0) ? o2 : null;
}
function h2(r, t2, o2, e4) {
  return n3(r, t2, 0, o2, e4, 0) ? o2 : null;
}
function _(t2, e4, n7) {
  return j(Y, n7), f2(e4, t2, Y), A2(Y) && l(e4, e4), e4;
}
function C2(t2, o2, n7) {
  return n5(Y, n7), n6(o2, t2, Y), A2(Y) && l(o2, o2, 4), o2;
}
function w3(r, t2, o2, e4, n7, i3) {
  if (!B2(x2.TO_PCPF, i.fromTypedArray(r, 4 * Float32Array.BYTES_PER_ELEMENT), V2.TANGENT, T.fromTypedArray(t2), o2, T.fromTypedArray(e4), n7, i.fromTypedArray(i3, 4 * Float32Array.BYTES_PER_ELEMENT))) return null;
  for (let f3 = 3; f3 < r.length; f3 += 4) i3[f3] = r[f3];
  return i3;
}
function G(r, t2, o2, e4, n7, i3) {
  if (!B2(x2.FROM_PCPF, i.fromTypedArray(r, 16), V2.TANGENT, T.fromTypedArray(t2), o2, T.fromTypedArray(e4), n7, i.fromTypedArray(i3, 16))) return null;
  for (let f3 = 3; f3 < r.length; f3 += 4) i3[f3] = r[f3];
  return i3;
}
var V2;
var x2;
function v(r, t2, n7, f3, c5) {
  switch (C(f3, n7, q, f3), r === x2.FROM_PCPF && h(q, q), t2) {
    case V2.NORMAL:
      return j(c5, q);
    case V2.TANGENT:
      return n5(c5, q);
  }
}
function B2(r, t2, o2, e4, n7, i3, f3, s2) {
  if (!t2) return;
  const m2 = e4.count;
  if ($(n7)) for (let a3 = 0; a3 < m2; a3++) i3.getVec(a3, S), t2.getVec(a3, U), N(U, U, v(r, o2, S, f3, Y)), s2.setVec(a3, U);
  else for (let u = 0; u < m2; u++) {
    i3.getVec(u, S), t2.getVec(u, U);
    const n8 = c(e4.get(u, 1));
    let m3 = Math.cos(n8);
    o2 === V2.TANGENT != (r === x2.TO_PCPF) && (m3 = 1 / m3), v(r, o2, S, f3, Y), r === x2.TO_PCPF ? (Y[0] *= m3, Y[1] *= m3, Y[2] *= m3, Y[3] *= m3, Y[4] *= m3, Y[5] *= m3) : (Y[0] *= m3, Y[3] *= m3, Y[6] *= m3, Y[1] *= m3, Y[4] *= m3, Y[7] *= m3), N(U, U, Y), A3(U, U), s2.setVec(u, U);
  }
  return s2;
}
function $(r) {
  return r.isWGS84 || w(r) || D(r) || W(r);
}
!function(r) {
  r[r.NORMAL = 0] = "NORMAL", r[r.TANGENT = 1] = "TANGENT";
}(V2 || (V2 = {})), function(r) {
  r[r.TO_PCPF = 0] = "TO_PCPF", r[r.FROM_PCPF = 1] = "FROM_PCPF";
}(x2 || (x2 = {}));
var S = n2();
var U = n2();
var q = e();
var Y = e2();

// node_modules/@arcgis/core/geometry/support/meshUtils/vertexSpaceConversion.js
var M = () => n.getLogger("esri.geometry.support.meshUtils.vertexSpaceConversion");
function k(t2, n7, { vertexSpace: r, spatialReference: e4 }) {
  if ("georeferenced" === r.type) {
    const o3 = t2;
    if (!c4(n7, o3, e4)) return false;
    const { origin: i4 } = r;
    return c3(t2, o3, i4), true;
  }
  const o2 = a2(e4), i3 = t2;
  if (!c4(n7, i3, o2)) return false;
  const { origin: a3 } = r, s2 = lt;
  if (!C(e4, a3, s2, o2)) return false;
  const c5 = h(lt, s2);
  return null != c5 && (E(t2, i3, c5), true);
}
function B3(t2, n7, r) {
  const { vertexSpace: e4, transform: o2, vertexAttributes: i3 } = t2, l2 = a(e4) ? o2 : null, s2 = X(t2.spatialReference, r, at.SOURCE_AND_TARGET);
  if (m(e4, n7) && (!l2 || B(l2.localMatrix, o)) && Y2(s2)) {
    const { position: t3, normal: n8, tangent: e5 } = i3, o3 = r == null ? void 0 : r.allowBufferReuse;
    return { position: o3 ? t3 : t3.slice(), normal: o3 ? n8 : n8 == null ? void 0 : n8.slice(), tangent: o3 ? e5 : e5 == null ? void 0 : e5.slice() };
  }
  switch (t2.vertexSpace.type) {
    case "local":
      return "local" === n7.type ? H(t2, t2.vertexSpace, n7.origin, r) : P(t2, t2.vertexSpace, n7.origin, r);
    case "georeferenced":
      return "local" === n7.type ? q2(t2, t2.vertexSpace, n7.origin, r) : L(t2, t2.vertexSpace, n7.origin, r);
  }
}
function L({ vertexAttributes: t2, transform: n7, spatialReference: r }, { origin: e4 }, o2, i3) {
  const l2 = X(r, i3, at.SOURCE_AND_TARGET), a3 = e4 || !Y2(l2) ? n4(rt, (n7 == null ? void 0 : n7.localMatrix) ?? o) : null;
  a3 && W2(a3, r, i3, at.SOURCE_AND_TARGET);
  const { position: c5, normal: u, tangent: m2 } = a3 ? I2(t2, a3) : t2, p = i3 == null ? void 0 : i3.allowBufferReuse, g2 = p ? c5 : new Float64Array(c5.length);
  let R2 = c5;
  if (e4 && (R2 = i2(g2, R2, e4)), o2) {
    const t3 = y(it, o2);
    R2 = i2(g2, R2, t3);
  }
  return { position: R2 !== t2.position || p ? R2 : R2.slice(), normal: u !== t2.normal || p ? u : u == null ? void 0 : u.slice(), tangent: m2 !== t2.tangent || p ? m2 : m2 == null ? void 0 : m2.slice() };
}
function V3(t2, n7) {
  return (n7 == null ? void 0 : n7.useEllipsoid) && A(t2) ? w2 : a2(t2);
}
function P({ spatialReference: t2, vertexAttributes: n7, transform: r }, { origin: e4 }, o2, i3) {
  const l2 = V3(t2, i3);
  if (!C(t2, e4, rt, l2)) return F(M(), t2, l2), null;
  r && c2(rt, rt, r.localMatrix), W2(rt, t2, i3, at.SOURCE);
  const a3 = new Float64Array(n7.position.length), s2 = J(n7.position, rt, t2, a3, l2);
  if (!s2) return null;
  const u = K(s2, t2, a3, l2, n7.normal, rt);
  if (n7.normal && !u) return null;
  const f3 = Q(s2, t2, a3, l2, n7.tangent, rt);
  if (n7.tangent && !f3) return null;
  if (o2) {
    const t3 = y(it, o2);
    i2(s2, s2, t3);
  }
  return { position: s2, normal: u, tangent: f3 };
}
function q2({ vertexAttributes: t2, spatialReference: n7, transform: r }, { origin: e4 }, i3, a3) {
  const s2 = V3(n7, a3);
  if (!C(n7, i3, rt, s2)) return F(M(), n7, s2), null;
  const c5 = 1 / X(n7, a3, at.TARGET);
  f(rt, rt, [c5, c5, c5]);
  const f3 = h(et, rt), { position: m2, normal: p, tangent: g2 } = z(t2, e4, r), A4 = new Float64Array(m2.length), R2 = Z(m2, n7, f3, A4, s2);
  if (!R2) return null;
  const x3 = j(ot, f3), E3 = $2(p, m2, n7, A4, s2, x3, p !== t2.normal ? p : void 0);
  if (!E3 && p) return null;
  const T2 = tt(g2, m2, n7, A4, s2, x3, g2 !== t2.tangent ? g2 : void 0);
  return !T2 && g2 ? null : { position: R2, normal: E3, tangent: T2 };
}
function z(t2, n7, r) {
  if (!n7) return t2;
  if (!r) {
    const { position: r2, normal: e5, tangent: o2 } = t2;
    return { position: i2(new Float64Array(r2.length), r2, n7), tangent: o2, normal: e5 };
  }
  const e4 = I2(t2, r.localMatrix);
  return i2(e4.position, e4.position, n7), e4;
}
function H({ vertexAttributes: t2, spatialReference: n7, transform: r }, { origin: e4 }, o2, i3) {
  const a3 = V3(n7, i3);
  if (!C(n7, e4, rt, a3)) return F(M(), n7, a3), null;
  if (r && c2(rt, rt, r.localMatrix), !C(n7, o2, et, a3)) return F(M(), a3, n7), null;
  h(et, et);
  const s2 = c2(rt, et, rt);
  return W2(s2, n7, i3, at.SOURCE_AND_TARGET), I2(t2, s2);
}
function I2(t2, n7) {
  const r = new Float64Array(t2.position.length);
  e3(r, t2.position, n7);
  const e4 = t2.normal ? new Float32Array(t2.normal.length) : null, o2 = t2.tangent ? new Float32Array(t2.tangent.length) : null;
  return e4 && t2.normal && _(t2.normal, e4, n7), o2 && t2.tangent && C2(t2.tangent, o2, n7), { position: r, normal: e4, tangent: o2 };
}
function J(t2, n7, r, e4, o2) {
  e3(e4, t2, n7);
  const i3 = new Float64Array(t2.length);
  return h2(e4, o2, i3, r) ? i3 : (F(M(), o2, r), null);
}
function K(t2, n7, r, e4, o2, i3) {
  if (null == o2) return null;
  const l2 = new Float32Array(o2.length);
  return _(o2, l2, i3), R(l2, t2, n7, r, e4, l2) ? l2 : (F(M(), e4, n7), null);
}
function Q(t2, n7, r, e4, o2, i3) {
  if (null == o2) return null;
  const l2 = new Float32Array(o2.length);
  return C2(o2, l2, i3), G(l2, t2, n7, r, e4, l2) ? l2 : (F(M(), e4, n7), null);
}
function W2(t2, n7, r, e4) {
  const o2 = X(n7, r, e4);
  Y2(o2) || f(t2, t2, [o2, o2, o2]);
}
function X(t2, n7, r) {
  const e4 = !!(r & at.SOURCE), o2 = !!(r & at.TARGET), i3 = n7 == null ? void 0 : n7.sourceUnit, l2 = n7 == null ? void 0 : n7.targetUnit;
  if (!i3 && !l2) return 1;
  let a3 = nt(i3, t2);
  e4 || !i3 || Y2(a3) || (M().warn("source unit conversion not supported"), a3 = 1);
  let s2 = 1 / nt(l2, t2);
  return o2 || !l2 || Y2(s2) || (M().warn("target unit conversion not supported"), s2 = 1), a3 * s2;
}
function Y2(t2) {
  return x(t2, 1);
}
function Z(t2, n7, r, e4, o2) {
  const i3 = g(t2, n7, e4, o2);
  if (!i3) return F(M(), n7, o2), null;
  const l2 = new Float64Array(i3.length);
  return e3(l2, i3, r), l2;
}
function $2(t2, n7, r, e4, o2, i3, l2) {
  if (null == t2) return null;
  const a3 = l2 ?? new Float32Array(t2.length);
  return E2(t2, n7, r, e4, o2, a3) ? (f2(a3, a3, i3), a3) : (F(M(), r, o2), null);
}
function tt(t2, n7, r, e4, o2, i3, l2) {
  if (null == t2) return null;
  const a3 = l2 ?? new Float32Array(t2.length);
  return w3(t2, n7, r, e4, o2, a3) ? (f2(a3, a3, i3, 4), a3) : (F(M(), r, o2), null);
}
function nt(t2, n7) {
  if (null == t2) return 1;
  const o2 = V(n7);
  return 1 / I(o2, "meters", t2);
}
var rt = e();
var et = e();
var ot = e2();
var it = n2();
var lt = e();
var at;
!function(t2) {
  t2[t2.NONE = 0] = "NONE", t2[t2.SOURCE = 1] = "SOURCE", t2[t2.TARGET = 2] = "TARGET", t2[t2.SOURCE_AND_TARGET = 3] = "SOURCE_AND_TARGET";
}(at || (at = {}));

export {
  O,
  F,
  E2 as E,
  R,
  g,
  h2 as h,
  w3 as w,
  G,
  k,
  B3 as B,
  nt
};
//# sourceMappingURL=chunk-RMNZGRHI.js.map
