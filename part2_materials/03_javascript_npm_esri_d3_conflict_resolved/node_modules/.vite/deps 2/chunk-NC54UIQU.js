import {
  M,
  a as a4,
  c,
  d,
  d3,
  e as e5,
  e2 as e6,
  h2 as h,
  h3 as h2,
  i,
  i2,
  m,
  m2,
  n2,
  n5 as n3,
  n6 as n4,
  o as o5,
  o3 as o6,
  o4 as o7,
  p,
  t3 as t2,
  t4 as t3,
  u as u2,
  u3,
  x
} from "./chunk-DQ6HUSR7.js";
import {
  P,
  a as a3,
  a2 as a5,
  d2,
  f,
  l as l2
} from "./chunk-PFCCTBQ6.js";
import {
  e as e7
} from "./chunk-JW4HK5OB.js";
import {
  e as e4,
  o as o8,
  s as s2
} from "./chunk-PVFZLQ5G.js";
import {
  a as a2,
  t
} from "./chunk-W3O5CFJ6.js";
import {
  e as e2,
  e2 as e3,
  u
} from "./chunk-HRP7POO2.js";
import {
  s
} from "./chunk-X2UYZD2B.js";
import {
  o as o4
} from "./chunk-JQJITHTO.js";
import {
  o as o3,
  r
} from "./chunk-6LGJYARD.js";
import {
  a
} from "./chunk-N42IF4WX.js";
import {
  e
} from "./chunk-L7OHH2HW.js";
import {
  o as o2
} from "./chunk-NW7VXBHZ.js";
import {
  l
} from "./chunk-ECMDQ4LS.js";
import {
  o
} from "./chunk-CTU2XDPA.js";
import {
  n
} from "./chunk-LPNAPHOF.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js
function e8(e9, o9) {
  const n6 = e9.fragment;
  switch (n6.code.add(o3`struct ShadingNormalParameters {
vec3 normalView;
vec3 viewDirection;
} shadingParams;`), o9.doubleSidedMode) {
    case i3.None:
      n6.code.add(o3`vec3 shadingNormal(ShadingNormalParameters params) {
return normalize(params.normalView);
}`);
      break;
    case i3.View:
      n6.code.add(o3`vec3 shadingNormal(ShadingNormalParameters params) {
return dot(params.normalView, params.viewDirection) > 0.0 ? normalize(-params.normalView) : normalize(params.normalView);
}`);
      break;
    case i3.WindingOrder:
      n6.code.add(o3`vec3 shadingNormal(ShadingNormalParameters params) {
return gl_FrontFacing ? normalize(params.normalView) : normalize(-params.normalView);
}`);
      break;
    default:
      n(o9.doubleSidedMode);
    case i3.COUNT:
  }
}
var i3;
!function(a6) {
  a6[a6.None = 0] = "None", a6[a6.View = 1] = "View", a6[a6.WindingOrder = 2] = "WindingOrder", a6[a6.COUNT = 3] = "COUNT";
}(i3 || (i3 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js
function T(T2, u4) {
  const x2 = T2.fragment;
  u4.hasVertexTangents ? (T2.attributes.add(e.TANGENT, "vec4"), T2.varyings.add("vTangent", "vec4"), u4.doubleSidedMode === i3.WindingOrder ? x2.code.add(o3`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = gl_FrontFacing ? vTangent.w : -vTangent.w;
vec3 tangent = normalize(gl_FrontFacing ? vTangent.xyz : -vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`) : x2.code.add(o3`mat3 computeTangentSpace(vec3 normal) {
float tangentHeadedness = vTangent.w;
vec3 tangent = normalize(vTangent.xyz);
vec3 bitangent = cross(normal, tangent) * tangentHeadedness;
return mat3(tangent, bitangent, normal);
}`)) : x2.code.add(o3`mat3 computeTangentSpace(vec3 normal, vec3 pos, vec2 st) {
vec3 Q1 = dFdx(pos);
vec3 Q2 = dFdy(pos);
vec2 stx = dFdx(st);
vec2 sty = dFdy(st);
float det = stx.t * sty.s - sty.t * stx.s;
vec3 T = stx.t * Q2 - sty.t * Q1;
T = T - normal * dot(normal, T);
T *= inversesqrt(max(dot(T,T), 1.e-10));
vec3 B = sign(det) * cross(normal, T);
return mat3(T, B, normal);
}`), u4.textureCoordinateType !== d.None && (T2.include(u2, u4), x2.uniforms.add(u4.bindType === a.Pass ? new s2("normalTexture", (e9) => e9.textureNormal) : new s("normalTexture", (e9) => e9.textureNormal)), u4.hasNormalTextureTransform && (x2.uniforms.add(new e4("scale", (e9) => e9.scale ?? l)), x2.uniforms.add(new e3("normalTextureTransformMatrix", (t5) => t5.normalTextureTransformMatrix ?? o2))), x2.code.add(o3`vec3 computeTextureNormal(mat3 tangentSpace, vec2 uv) {
vec3 rawNormal = textureLookup(normalTexture, uv).rgb * 2.0 - 1.0;`), u4.hasNormalTextureTransform && x2.code.add(o3`mat3 normalTextureRotation = mat3(normalTextureTransformMatrix[0][0]/scale[0], normalTextureTransformMatrix[0][1]/scale[1], 0.0,
normalTextureTransformMatrix[1][0]/scale[0], normalTextureTransformMatrix[1][1]/scale[1], 0.0,
0.0, 0.0, 0.0 );
rawNormal.xy = (normalTextureRotation * vec3(rawNormal.x, rawNormal.y, 1.0)).xy;`), x2.code.add(o3`return tangentSpace * rawNormal;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/TextureTransformUV.glsl.js
function s3(e9, s4) {
  s4.hasColorTextureTransform ? (e9.varyings.add("colorUV", "vec2"), e9.vertex.uniforms.add(new e3("colorTextureTransformMatrix", (e10) => e10.colorTextureTransformMatrix ?? o2)).code.add(o3`void forwardColorUV(){
colorUV = (colorTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : e9.vertex.code.add(o3`void forwardColorUV(){}`);
}
function i4(s4, i5) {
  i5.hasNormalTextureTransform && i5.textureCoordinateType !== d.None ? (s4.varyings.add("normalUV", "vec2"), s4.vertex.uniforms.add(new e3("normalTextureTransformMatrix", (e9) => e9.normalTextureTransformMatrix ?? o2)).code.add(o3`void forwardNormalUV(){
normalUV = (normalTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : s4.vertex.code.add(o3`void forwardNormalUV(){}`);
}
function t4(s4, i5) {
  i5.hasEmissionTextureTransform && i5.textureCoordinateType !== d.None ? (s4.varyings.add("emissiveUV", "vec2"), s4.vertex.uniforms.add(new e3("emissiveTextureTransformMatrix", (e9) => e9.emissiveTextureTransformMatrix ?? o2)).code.add(o3`void forwardEmissiveUV(){
emissiveUV = (emissiveTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : s4.vertex.code.add(o3`void forwardEmissiveUV(){}`);
}
function d4(s4, i5) {
  i5.hasOcclusionTextureTransform && i5.textureCoordinateType !== d.None ? (s4.varyings.add("occlusionUV", "vec2"), s4.vertex.uniforms.add(new e3("occlusionTextureTransformMatrix", (e9) => e9.occlusionTextureTransformMatrix ?? o2)).code.add(o3`void forwardOcclusionUV(){
occlusionUV = (occlusionTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : s4.vertex.code.add(o3`void forwardOcclusionUV(){}`);
}
function n5(s4, i5) {
  i5.hasMetallicRoughnessTextureTransform && i5.textureCoordinateType !== d.None ? (s4.varyings.add("metallicRoughnessUV", "vec2"), s4.vertex.uniforms.add(new e3("metallicRoughnessTextureTransformMatrix", (e9) => e9.metallicRoughnessTextureTransformMatrix ?? o2)).code.add(o3`void forwardMetallicRoughnessUV(){
metallicRoughnessUV = (metallicRoughnessTextureTransformMatrix * vec3(vuv0, 1.0)).xy;
}`)) : s4.vertex.code.add(o3`void forwardMetallicRoughnessUV(){}`);
}

// node_modules/@arcgis/core/chunks/DefaultMaterial.glsl.js
function J(J2) {
  const K2 = new o8(), { vertex: Q, fragment: X, varyings: Y } = K2, { output: Z, normalType: ee, offsetBackfaces: re, instancedColor: oe, spherical: ie, receiveShadows: ae, snowCover: le, pbrMode: se, textureAlphaPremultiplied: te, instancedDoublePrecision: ne, hasVertexColors: de, hasVertexTangents: ce, hasColorTexture: me, hasNormalTexture: ge, hasNormalTextureTransform: ve, hasColorTextureTransform: ue } = J2;
  if (d2(Q, J2), K2.include(o6), Y.add("vpos", "vec3"), K2.include(l2, J2), K2.include(M, J2), K2.include(a3, J2), K2.include(s3, J2), !u(Z)) return K2.include(h, J2), K2;
  K2.include(i4, J2), K2.include(t4, J2), K2.include(d4, J2), K2.include(n5, J2), f(Q, J2), K2.include(t, J2), K2.include(o7, J2);
  const be = ee === a2.Attribute || ee === a2.Compressed;
  return be && re && K2.include(e5), K2.include(T, J2), K2.include(c, J2), oe && K2.attributes.add(e.INSTANCECOLOR, "vec4"), Y.add("vPositionLocal", "vec3"), K2.include(o5, J2), K2.include(n3, J2), K2.include(i, J2), K2.include(e6, J2), Q.uniforms.add(new e7("externalColor", (e9) => e9.externalColor)), Y.add("vcolorExt", "vec4"), J2.terrainDepthTest && Y.add("depth", "float"), Q.main.add(o3`
    forwardNormalizedVertexColor();
    vcolorExt = externalColor;
    ${r(oe, "vcolorExt *= instanceColor * 0.003921568627451;")}
    vcolorExt *= vvColor();
    vcolorExt *= getSymbolColor();
    forwardColorMixMode();

    if (vcolorExt.a < ${o3.float(o)}) {
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
    } else {
      vpos = getVertexInLocalOriginSpace();
      vPositionLocal = vpos - view[3].xyz;
      vpos = subtractOrigin(vpos);
      ${r(be, "vNormalWorld = dpNormal(vvLocalNormal(normalModel()));")}
      vpos = addVerticalOffset(vpos, localOrigin);
      ${r(ce, "vTangent = dpTransformVertexTangent(tangent);")}
      gl_Position = transformPosition(proj, view, vpos);
      ${r(be && re, "gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}
    }

    ${r(J2.terrainDepthTest, "depth = (view * vec4(vpos, 1.0)).z;")}
    forwardLinearDepth();
    forwardTextureCoordinates();
    forwardColorUV();
    forwardNormalUV();
    forwardEmissiveUV();
    forwardOcclusionUV();
    forwardMetallicRoughnessUV();
  `), K2.include(p, J2), K2.include(t3, J2), K2.include(t2, J2), K2.include(ne ? m2 : x, J2), K2.include(a5, J2), K2.include(P, J2), K2.include(d3, J2), f(X, J2), X.uniforms.add(Q.uniforms.get("localOrigin"), new e2("ambient", (e9) => e9.ambient), new e2("diffuse", (e9) => e9.diffuse), new o4("opacity", (e9) => e9.opacity), new o4("layerOpacity", (e9) => e9.layerOpacity)), me && X.uniforms.add(new s2("tex", (e9) => e9.texture)), K2.include(m, J2), K2.include(n4, J2), X.include(i2), K2.include(e8, J2), h2(X), u3(X), a4(X), X.main.add(o3`
      discardBySlice(vpos);
      ${r(J2.terrainDepthTest, "terrainDepthTest(depth);")}
      ${me ? o3`
              vec4 texColor = texture(tex, ${ue ? "colorUV" : "vuv0"});
              ${r(te, "texColor.rgb /= texColor.a;")}
              discardOrAdjustAlpha(texColor);` : o3`vec4 texColor = vec4(1.0);`}
      shadingParams.viewDirection = normalize(vpos - cameraPosition);
      ${ee === a2.ScreenDerivative ? o3`vec3 normal = screenDerivativeNormal(vPositionLocal);` : o3`shadingParams.normalView = vNormalWorld;
                 vec3 normal = shadingNormal(shadingParams);`}
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse() * getBakedOcclusion();

      vec3 posWorld = vpos + localOrigin;

      float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
      float shadow = ${ae ? "max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))" : r(ie, "lightingGlobalFactor * (1.0 - additionalAmbientScale)", "0.0")};

      vec3 matColor = max(ambient, diffuse);
      vec3 albedo = mixExternalColor(${r(de, "vColor.rgb *")} matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
      float opacity_ = layerOpacity * mixExternalOpacity(${r(de, "vColor.a * ")} opacity, texColor.a, vcolorExt.a, int(colorMixMode));
      ${ge ? `mat3 tangentSpace = computeTangentSpace(${ce ? "normal" : "normal, vpos, vuv0"});
             vec3 shadingNormal = computeTextureNormal(tangentSpace, ${ve ? "normalUV" : "vuv0"});` : "vec3 shadingNormal = normal;"}
      vec3 normalGround = ${ie ? "normalize(posWorld);" : "vec3(0.0, 0.0, 1.0);"}

      ${r(le, o3`
            float snow = smoothstep(0.5, 0.55, dot(normal, normalGround));
            albedo = mix(albedo, vec3(1), snow);
            shadingNormal = mix(shadingNormal, normal, snow);
            ssao = mix(ssao, 1.0, snow);`)}

      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;

      ${se === n2.Normal || se === n2.Schematic ? o3`
              float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
              ${r(le, o3`mrr = mix(mrr, vec3(0.0, 1.0, 0.04), snow);`)}
              vec4 emission = ${le ? "mix(getEmissions(), vec4(0.0), snow)" : "getEmissions()"};
              vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);` : o3`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos);
  `), K2;
}
var K = Object.freeze(Object.defineProperty({ __proto__: null, build: J }, Symbol.toStringTag, { value: "Module" }));

export {
  i3 as i,
  J,
  K
};
//# sourceMappingURL=chunk-NC54UIQU.js.map
