import {
  Fe,
  Ie,
  ge
} from "./chunk-6D5XULXX.js";
import {
  E,
  I,
  j,
  k,
  x
} from "./chunk-NHJGPXZH.js";
import {
  i,
  p
} from "./chunk-JS7R723S.js";

// node_modules/@arcgis/core/smartMapping/support/utils.js
var h2 = { years: 365, months: 30, days: 1, hours: 1 / 24, minutes: 1 / 1440, seconds: 1 / 86400, milliseconds: 1 / 864e5 };
function $(t) {
  return ge(t) || Fe(t) || Ie(t);
}
function j2(s, o) {
  const { format: a, timeZoneOptions: c, fieldType: l } = o ?? {};
  let m, u;
  if (c && ({ timeZone: m, timeZoneName: u } = p(c.layerTimeZone, c.datesInUnknownTimezone, c.viewTimeZone, E(a || "short-date-short-time"), l)), "string" == typeof s && isNaN(Date.parse("time-only" === l ? `1970-01-01T${s}Z` : s))) return s;
  switch (l) {
    case "date-only": {
      const r = E(a || "short-date");
      return "string" == typeof s ? k(s, { ...r }) : j(s, { ...r, timeZone: i });
    }
    case "time-only": {
      const r = E(a || "short-time");
      return "string" == typeof s ? I(s, r) : j(s, { ...r, timeZone: i });
    }
    case "timestamp-offset": {
      if (!m && "string" == typeof s && new Date(s).toISOString() !== s) return s;
      const i3 = a || c ? E(a || "short-date-short-time") : void 0, n = i3 ? { ...i3, timeZone: m, timeZoneName: u } : void 0;
      return "string" == typeof s ? x(s, n) : j(s, n);
    }
    default: {
      const r = a || c ? E(a || "short-date-short-time") : void 0;
      return j("string" == typeof s ? new Date(s) : s, r ? { ...r, timeZone: m, timeZoneName: u } : void 0);
    }
  }
}

export {
  $,
  j2 as j
};
//# sourceMappingURL=chunk-KVWJ4FJP.js.map
