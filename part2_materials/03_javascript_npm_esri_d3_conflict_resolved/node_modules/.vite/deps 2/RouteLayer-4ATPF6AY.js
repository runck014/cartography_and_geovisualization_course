import {
  C,
  D as D2,
  M,
  P,
  R as R2,
  S as S4,
  T,
  U as U3,
  a as a2,
  b as b3,
  c,
  c2,
  c3,
  j as j3,
  j2 as j4,
  l as l2,
  m as m2,
  n as n4,
  o as o4,
  o2 as o5,
  q as q2,
  r as r4,
  w as w2,
  w2 as w3,
  y as y3
} from "./chunk-2OJYEYNU.js";
import {
  i as i2
} from "./chunk-JEA2CH67.js";
import "./chunk-FDS5NNQY.js";
import {
  R
} from "./chunk-IJO7BOFI.js";
import "./chunk-NGQEHRBA.js";
import {
  o as o3
} from "./chunk-YYZ2CTYE.js";
import "./chunk-HZRXUNDJ.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-GGPPKSP2.js";
import "./chunk-JHXGQ3AW.js";
import "./chunk-MR727DXB.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-GNY4KZ34.js";
import "./chunk-WPERPIJF.js";
import "./chunk-QKS6PIY6.js";
import "./chunk-R5BTSPWT.js";
import "./chunk-Z2L6EED4.js";
import "./chunk-43W2AR4R.js";
import "./chunk-X5EOLPIE.js";
import "./chunk-VNPGSD2C.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import {
  d as d4
} from "./chunk-CE7WVJQV.js";
import "./chunk-GJTB7YCT.js";
import "./chunk-LQEYS467.js";
import "./chunk-A66MNK5C.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-RCGJPJRB.js";
import "./chunk-5CRXWQ3Y.js";
import {
  j as j2
} from "./chunk-F3W2DG3D.js";
import {
  l
} from "./chunk-YMJZWW2N.js";
import "./chunk-7Q4JSL7R.js";
import "./chunk-VBJTBJYL.js";
import {
  t as t2
} from "./chunk-ES2OYM5K.js";
import {
  b as b2
} from "./chunk-JXPOROPE.js";
import "./chunk-OPBXQTOC.js";
import "./chunk-DKMSVKV3.js";
import "./chunk-YIIXBP6I.js";
import {
  S as S2
} from "./chunk-LN6VH2LB.js";
import "./chunk-GZFJKWTS.js";
import {
  f as f3
} from "./chunk-2DHZIDQK.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-XQH2QDB2.js";
import "./chunk-LPNAPHOF.js";
import "./chunk-AMH7OVBF.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-LXJGKQ4D.js";
import {
  d as d3
} from "./chunk-VILGTHTP.js";
import {
  q
} from "./chunk-ATEWWVHG.js";
import {
  D,
  L,
  k2 as k
} from "./chunk-LEOFRCUR.js";
import {
  S as S3,
  d as d2,
  y as y2
} from "./chunk-CP4GPQHD.js";
import "./chunk-IZSNXKMJ.js";
import "./chunk-IOKAACTA.js";
import "./chunk-VFTH6C2E.js";
import {
  i
} from "./chunk-M5RSIRGD.js";
import {
  f as f5,
  i as i3
} from "./chunk-D2JPDRZZ.js";
import {
  r as r3
} from "./chunk-UYSPJCCV.js";
import "./chunk-SMFCDOAJ.js";
import {
  f as f4
} from "./chunk-2HEBE37N.js";
import "./chunk-5A4G4OVM.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-44C2A72D.js";
import "./chunk-DIKY6MBW.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-GGCWKF4X.js";
import "./chunk-6D5XULXX.js";
import "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import {
  n as n3
} from "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import {
  f as f2
} from "./chunk-F26LCWNQ.js";
import {
  K,
  N
} from "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import {
  d,
  u
} from "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import {
  y
} from "./chunk-TDZ623HP.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import {
  v
} from "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import {
  V
} from "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import {
  S
} from "./chunk-BMGF5ELJ.js";
import {
  b as b4
} from "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import {
  j2 as j,
  w
} from "./chunk-A3J7W53Y.js";
import {
  o as o2
} from "./chunk-HLF5XJSV.js";
import {
  g,
  r as r2
} from "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import {
  I2,
  U as U2
} from "./chunk-DRBJFCLQ.js";
import {
  n as n2
} from "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import {
  I,
  jt
} from "./chunk-QS62R4CH.js";
import {
  f
} from "./chunk-VU6O6TFT.js";
import {
  m,
  o
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a,
  h
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  b
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  e,
  n2 as n,
  s,
  s2,
  t
} from "./chunk-PKLD5YJF.js";
import {
  F
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/RouteStopSymbols.js
var p = class extends f {
  constructor(o6) {
    super(o6), this.break = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.first = new y2({ color: [0, 255, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.unlocated = new y2({ color: [255, 0, 0], size: 12, outline: { color: [255, 255, 255], width: 3 } }), this.last = new y2({ color: [255, 0, 0], size: 20, outline: { color: [255, 255, 255], width: 4 } }), this.middle = new y2({ color: [51, 51, 51], size: 12, outline: { color: [0, 122, 194], width: 3 } }), this.waypoint = new y2({ color: [255, 255, 255], size: 12, outline: { color: [0, 122, 194], width: 3 } });
  }
};
r([m({ types: D })], p.prototype, "break", void 0), r([m({ types: D })], p.prototype, "first", void 0), r([m({ types: D })], p.prototype, "unlocated", void 0), r([m({ types: D })], p.prototype, "last", void 0), r([m({ types: D })], p.prototype, "middle", void 0), r([m({ types: D })], p.prototype, "waypoint", void 0), p = r([a("esri.layers.support.RouteStopSymbols")], p);
var l3 = p;

// node_modules/@arcgis/core/layers/support/RouteSymbols.js
var y4 = class extends f {
  constructor(o6) {
    super(o6), this.directionLines = new d2({ color: [0, 122, 194], width: 6 }), this.directionPoints = new y2({ color: [255, 255, 255], size: 6, outline: { color: [0, 122, 194], width: 2 } }), this.pointBarriers = new y2({ style: "x", size: 10, outline: { color: [255, 0, 0], width: 3 } }), this.polygonBarriers = new S3({ color: [255, 170, 0, 0.6], outline: { width: 7.5, color: [255, 0, 0, 0.6] } }), this.polylineBarriers = new d2({ width: 7.5, color: [255, 85, 0, 0.7] }), this.routeInfo = new d2({ width: 8, color: [20, 89, 127] }), this.stops = new l3();
  }
};
r([m({ types: L })], y4.prototype, "directionLines", void 0), r([m({ types: D })], y4.prototype, "directionPoints", void 0), r([m({ types: D })], y4.prototype, "pointBarriers", void 0), r([m({ types: k })], y4.prototype, "polygonBarriers", void 0), r([m({ types: L })], y4.prototype, "polylineBarriers", void 0), r([m({ types: L })], y4.prototype, "routeInfo", void 0), r([m({ type: l3 })], y4.prototype, "stops", void 0), y4 = r([a("esri.layers.support.RouteSymbols")], y4);
var d5 = y4;

// node_modules/@arcgis/core/rest/support/NetworkAttribute.js
var m3 = class extends f {
  constructor(t4) {
    super(t4), this.dataType = null, this.name = null, this.parameterNames = null, this.restrictionUsageParameterName = null, this.timeNeutralAttributeName = null, this.trafficSupport = null, this.units = null, this.usageType = null;
  }
};
r([m({ type: String })], m3.prototype, "dataType", void 0), r([r3(w2, { ignoreUnknown: false })], m3.prototype, "name", void 0), r([m({ type: [String] })], m3.prototype, "parameterNames", void 0), r([m({ type: String })], m3.prototype, "restrictionUsageParameterName", void 0), r([r3(D2, { ignoreUnknown: false })], m3.prototype, "timeNeutralAttributeName", void 0), r([m({ type: String })], m3.prototype, "trafficSupport", void 0), r([r3(o4)], m3.prototype, "units", void 0), r([r3(q2)], m3.prototype, "usageType", void 0), m3 = r([a("esri.rest.support.NetworkAttribute")], m3);
var u2 = m3;

// node_modules/@arcgis/core/rest/support/NetworkDataset.js
var p2 = class extends f {
  constructor(t4) {
    super(t4), this.buildTime = null, this.name = null, this.networkAttributes = null, this.networkSources = null, this.state = null;
  }
};
r([m({ type: Number })], p2.prototype, "buildTime", void 0), r([m({ type: String })], p2.prototype, "name", void 0), r([m({ type: [u2] })], p2.prototype, "networkAttributes", void 0), r([m()], p2.prototype, "networkSources", void 0), r([m({ type: String })], p2.prototype, "state", void 0), p2 = r([a("esri.rest.support.NetworkDataset")], p2);
var i4 = p2;

// node_modules/@arcgis/core/rest/support/NetworkServiceDescription.js
var c4 = class extends f {
  constructor(t4) {
    super(t4), this.accumulateAttributeNames = null, this.attributeParameterValues = null, this.currentVersion = null, this.defaultTravelMode = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsSupportedLanguages = null, this.directionsTimeAttribute = null, this.hasZ = null, this.impedance = null, this.networkDataset = null, this.supportedTravelModes = null;
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w2.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => w2.toJSON(t5)));
  }
  get capabilities() {
    return { supportsNow: (this.currentVersion ?? 10) >= 10.81 };
  }
  readDefaultTravelMode(t4, e2) {
    var _a, _b;
    const r5 = ((_a = e2.supportedTravelModes) == null ? void 0 : _a.find(({ id: t5 }) => t5 === e2.defaultTravelMode)) ?? ((_b = e2.supportedTravelModes) == null ? void 0 : _b.find(({ itemId: t5 }) => t5 === e2.defaultTravelMode));
    return r5 ? j3.fromJSON(r5) : null;
  }
};
r([m()], c4.prototype, "accumulateAttributeNames", void 0), r([o2("accumulateAttributeNames")], c4.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributeNames")], c4.prototype, "writeAccumulateAttributes", null), r([m()], c4.prototype, "attributeParameterValues", void 0), r([m()], c4.prototype, "capabilities", null), r([m()], c4.prototype, "currentVersion", void 0), r([m()], c4.prototype, "defaultTravelMode", void 0), r([o2("defaultTravelMode", ["defaultTravelMode", "supportedTravelModes"])], c4.prototype, "readDefaultTravelMode", null), r([m()], c4.prototype, "directionsLanguage", void 0), r([r3(a2)], c4.prototype, "directionsLengthUnits", void 0), r([m()], c4.prototype, "directionsSupportedLanguages", void 0), r([r3(D2, { ignoreUnknown: false })], c4.prototype, "directionsTimeAttribute", void 0), r([m()], c4.prototype, "hasZ", void 0), r([r3(w2, { ignoreUnknown: false })], c4.prototype, "impedance", void 0), r([m({ type: i4 })], c4.prototype, "networkDataset", void 0), r([m({ type: [j3] })], c4.prototype, "supportedTravelModes", void 0), c4 = r([a("esri.rest.support.NetworkServiceDescription")], c4);
var m4 = c4;

// node_modules/@arcgis/core/rest/networkService.js
var l4 = () => n.getLogger("esri.rest.networkService");
function u3(e2, r5, t4, o6) {
  o6[t4] = [r5.length, r5.length + e2.length], e2.forEach((e3) => {
    r5.push(e3.geometry);
  });
}
function f6(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o6 = e2[r5[t4]];
    if (o6 && o6.length) for (const e3 of o6) e3.z = void 0;
  }
  l4().warnOnce("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.");
}
function c5(e2, r5) {
  for (let t4 = 0; t4 < r5.length; t4++) {
    const o6 = e2[r5[t4]];
    if (o6 && o6.length) {
      for (const e3 of o6) if (null != e3 && e3.hasZ) return true;
    }
  }
  return false;
}
async function d6(t4, o6, s4) {
  if (!t4) throw new s2("network-service:missing-url", "Url to Network service is missing");
  const n6 = i3({ f: "json", token: o6 }, s4), { data: l7 } = await U(t4, n6), u7 = l7.currentVersion >= 10.4 ? p3(t4, o6, s4) : v2(t4, s4), { defaultTravelMode: f7, supportedTravelModes: c15 } = await u7;
  return l7.defaultTravelMode = f7, l7.supportedTravelModes = c15, m4.fromJSON(l7);
}
async function v2(r5, t4) {
  var _a, _b, _c;
  const i8 = i3({ f: "json" }, t4), { data: l7 } = await U(r5.replace(/\/rest\/.*$/i, "/info"), i8);
  if (!(l7 == null ? void 0 : l7.owningSystemUrl)) return { supportedTravelModes: [], defaultTravelMode: null };
  const { owningSystemUrl: u7 } = l7, f7 = jt(u7) + "/sharing/rest/portals/self", { data: c15 } = await U(f7, i8), d7 = t("helperServices.routingUtilities.url", c15);
  if (!d7) return { supportedTravelModes: [], defaultTravelMode: null };
  const v3 = f5(u7), p8 = /\/solve$/i.test(v3.path) ? "Route" : /\/solveclosestfacility$/i.test(v3.path) ? "ClosestFacility" : "ServiceAreas", m9 = i3({ f: "json", serviceName: p8 }, t4), h2 = jt(d7) + "/GetTravelModes/execute", g2 = await U(h2, m9), w4 = [];
  let T2 = null;
  if ((_b = (_a = g2 == null ? void 0 : g2.data) == null ? void 0 : _a.results) == null ? void 0 : _b.length) {
    const e2 = g2.data.results;
    for (const r6 of e2) if ("supportedTravelModes" === r6.paramName) {
      if ((_c = r6.value) == null ? void 0 : _c.features) {
        for (const { attributes: e3 } of r6.value.features) if (e3) {
          const r7 = JSON.parse(e3.TravelMode);
          w4.push(r7);
        }
      }
    } else "defaultTravelMode" === r6.paramName && (T2 = r6.value);
  }
  return { supportedTravelModes: w4, defaultTravelMode: T2 };
}
async function p3(t4, o6, n6) {
  try {
    const r5 = i3({ f: "json", token: o6 }, n6), i8 = jt(t4) + "/retrieveTravelModes", { data: { supportedTravelModes: l7, defaultTravelMode: u7 } } = await U(i8, r5);
    return { supportedTravelModes: l7, defaultTravelMode: u7 };
  } catch (i8) {
    throw new s2("network-service:retrieveTravelModes", "Could not get to the NAServer's retrieveTravelModes.", { error: i8 });
  }
}

// node_modules/@arcgis/core/rest/support/GPMessage.js
var p4 = new n2({ esriJobMessageTypeInformative: "informative", esriJobMessageTypeProcessDefinition: "process-definition", esriJobMessageTypeProcessStart: "process-start", esriJobMessageTypeProcessStop: "process-stop", esriJobMessageTypeWarning: "warning", esriJobMessageTypeError: "error", esriJobMessageTypeEmpty: "empty", esriJobMessageTypeAbort: "abort" });
var i5 = class extends f {
  constructor(e2) {
    super(e2), this.description = null, this.type = null;
  }
};
r([m({ type: String, json: { write: true } })], i5.prototype, "description", void 0), r([m({ type: String, json: { read: p4.read, write: p4.write } })], i5.prototype, "type", void 0), i5 = r([a("esri.rest.support.GPMessage")], i5);
var a3 = i5;

// node_modules/@arcgis/core/rest/support/NAMessage.js
var p5 = new n2({ 0: "informative", 1: "process-definition", 2: "process-start", 3: "process-stop", 50: "warning", 100: "error", 101: "empty", 200: "abort" });
var c6 = class extends a3 {
  constructor(r5) {
    super(r5), this.type = null;
  }
};
r([m({ type: String, json: { read: p5.read, write: p5.write } })], c6.prototype, "type", void 0), c6 = r([a("esri.rest.support.NAMessage")], c6);
var i6 = c6;

// node_modules/@arcgis/core/rest/support/DirectionsString.js
var c7 = class extends f {
  constructor(r5) {
    super(r5);
  }
};
r([m({ json: { read: { source: "string" } } })], c7.prototype, "text", void 0), r([r3(P, { name: "stringType" })], c7.prototype, "type", void 0), c7 = r([a("esri.rest.support.DirectionsString")], c7);
var i7 = c7;

// node_modules/@arcgis/core/rest/support/DirectionsEvent.js
var a4 = class extends f {
  constructor(r5) {
    super(r5), this.arriveTime = null, this.arriveTimeOffset = null, this.geometry = null, this.strings = null;
  }
  readArriveTimeOffset(r5, e2) {
    return n4(e2.ETA, e2.arriveTimeUTC);
  }
  readGeometry(r5, e2) {
    return j.fromJSON(e2.point);
  }
};
r([m({ type: Date, json: { read: { source: "arriveTimeUTC" } } })], a4.prototype, "arriveTime", void 0), r([m()], a4.prototype, "arriveTimeOffset", void 0), r([o2("arriveTimeOffset", ["arriveTimeUTC", "ETA"])], a4.prototype, "readArriveTimeOffset", null), r([m({ type: j })], a4.prototype, "geometry", void 0), r([o2("geometry", ["point"])], a4.prototype, "readGeometry", null), r([m({ type: [i7] })], a4.prototype, "strings", void 0), a4 = r([a("esri.rest.support.DirectionsEvent")], a4);
var c8 = a4;

// node_modules/@arcgis/core/rest/support/DirectionsFeature.js
function m5(r5) {
  if (null == r5 || "" === r5) return null;
  let e2 = 0, t4 = 0, o6 = 0, s4 = 0;
  const p8 = [];
  let n6, i8, m9, c15, a6, l7, u7, y6, d7 = 0, f7 = 0, h2 = 0;
  if (a6 = r5.match(/((\+|-)[^+\-|]+|\|)/g), a6 || (a6 = []), 0 === parseInt(a6[d7], 32)) {
    d7 = 2;
    const r6 = parseInt(a6[d7], 32);
    d7++, l7 = parseInt(a6[d7], 32), d7++, 1 & r6 && (f7 = a6.indexOf("|") + 1, u7 = parseInt(a6[f7], 32), f7++), 2 & r6 && (h2 = a6.indexOf("|", f7) + 1, y6 = parseInt(a6[h2], 32), h2++);
  } else l7 = parseInt(a6[d7], 32), d7++;
  for (; d7 < a6.length && "|" !== a6[d7]; ) {
    n6 = parseInt(a6[d7], 32) + e2, d7++, e2 = n6, i8 = parseInt(a6[d7], 32) + t4, d7++, t4 = i8;
    const r6 = [n6 / l7, i8 / l7];
    f7 && (c15 = parseInt(a6[f7], 32) + o6, f7++, o6 = c15, r6.push(c15 / u7)), h2 && (m9 = parseInt(a6[h2], 32) + s4, h2++, s4 = m9, r6.push(m9 / y6)), p8.push(r6);
  }
  return { paths: [p8], hasZ: f7 > 0, hasM: h2 > 0 };
}
var c9 = class extends d3 {
  constructor(r5) {
    super(r5), this.events = null, this.geometry = null, this.strings = null;
  }
  readGeometry(r5, e2) {
    const t4 = m5(e2.compressedGeometry);
    return null != t4 ? d.fromJSON(t4) : null;
  }
};
r([m({ type: [c8] })], c9.prototype, "events", void 0), r([m({ type: d })], c9.prototype, "geometry", void 0), r([o2("geometry", ["compressedGeometry"])], c9.prototype, "readGeometry", null), r([m({ type: [i7] })], c9.prototype, "strings", void 0), c9 = r([a("esri.rest.support.DirectionsFeature")], c9);
var a5 = c9;

// node_modules/@arcgis/core/rest/support/DirectionsFeatureSet.js
function m6(e2, t4) {
  if (0 === e2.length) return new d({ spatialReference: t4 });
  const r5 = [];
  for (const n6 of e2) for (const e3 of n6.paths) r5.push(...e3);
  const o6 = [];
  r5.forEach((e3, t5) => {
    0 !== t5 && e3[0] === r5[t5 - 1][0] && e3[1] === r5[t5 - 1][1] || o6.push(e3);
  });
  const { hasM: s4, hasZ: a6 } = e2[0];
  return new d({ hasM: s4, hasZ: a6, paths: [o6], spatialReference: t4 });
}
var u4 = class extends d4 {
  constructor(e2) {
    super(e2), this.extent = null, this.features = [], this.geometryType = "polyline", this.routeId = null, this.routeName = null, this.totalDriveTime = null, this.totalLength = null, this.totalTime = null;
  }
  readFeatures(e2, t4) {
    if (!e2) return [];
    const r5 = t4.summary.envelope.spatialReference ?? t4.spatialReference, o6 = r5 && g.fromJSON(r5);
    return e2.map((e3) => {
      const t5 = a5.fromJSON(e3);
      if (null != t5.geometry && (t5.geometry.spatialReference = o6), null != t5.events) for (const r6 of t5.events) null != r6.geometry && (r6.geometry.spatialReference = o6);
      return t5;
    });
  }
  get mergedGeometry() {
    if (!this.features) return null;
    return m6(this.features.map(({ geometry: e2 }) => e2), this.extent.spatialReference);
  }
  get strings() {
    return this.features.flatMap(({ strings: e2 }) => e2).filter(F);
  }
};
r([m({ type: w, json: { read: { source: "summary.envelope" } } })], u4.prototype, "extent", void 0), r([m({ nonNullable: true })], u4.prototype, "features", void 0), r([o2("features")], u4.prototype, "readFeatures", null), r([m()], u4.prototype, "geometryType", void 0), r([m({ readOnly: true })], u4.prototype, "mergedGeometry", null), r([m()], u4.prototype, "routeId", void 0), r([m()], u4.prototype, "routeName", void 0), r([m({ value: null, readOnly: true })], u4.prototype, "strings", null), r([m({ json: { read: { source: "summary.totalDriveTime" } } })], u4.prototype, "totalDriveTime", void 0), r([m({ json: { read: { source: "summary.totalLength" } } })], u4.prototype, "totalLength", void 0), r([m({ json: { read: { source: "summary.totalTime" } } })], u4.prototype, "totalTime", void 0), u4 = r([a("esri.rest.support.DirectionsFeatureSet")], u4);
var c10 = u4;

// node_modules/@arcgis/core/rest/support/RouteResult.js
var n5 = class extends f {
  constructor(t4) {
    super(t4), this.directionLines = null, this.directionPoints = null, this.directions = null, this.route = null, this.routeName = null, this.stops = null, this.traversedEdges = null, this.traversedJunctions = null, this.traversedTurns = null;
  }
};
r([m({ type: d4, json: { write: true } })], n5.prototype, "directionLines", void 0), r([m({ type: d4, json: { write: true } })], n5.prototype, "directionPoints", void 0), r([m({ type: c10, json: { write: true } })], n5.prototype, "directions", void 0), r([m({ type: d3, json: { write: true } })], n5.prototype, "route", void 0), r([m({ type: String, json: { write: true } })], n5.prototype, "routeName", void 0), r([m({ type: [d3], json: { write: true } })], n5.prototype, "stops", void 0), r([m({ type: d4, json: { write: true } })], n5.prototype, "traversedEdges", void 0), r([m({ type: d4, json: { write: true } })], n5.prototype, "traversedJunctions", void 0), r([m({ type: d4, json: { write: true } })], n5.prototype, "traversedTurns", void 0), n5 = r([a("esri.rest.support.RouteResult")], n5);
var u5 = n5;

// node_modules/@arcgis/core/rest/support/RouteSolveResult.js
function u6(r5) {
  return r5 ? d4.fromJSON(r5).features.filter(F) : [];
}
var m7 = class extends f {
  constructor(r5) {
    super(r5), this.messages = null, this.pointBarriers = null, this.polylineBarriers = null, this.polygonBarriers = null, this.routeResults = null;
  }
  readPointBarriers(r5, o6) {
    return u6(o6.barriers);
  }
  readPolylineBarriers(r5) {
    return u6(r5);
  }
  readPolygonBarriers(r5) {
    return u6(r5);
  }
};
r([m({ type: [i6] })], m7.prototype, "messages", void 0), r([m({ type: [d3] })], m7.prototype, "pointBarriers", void 0), r([o2("pointBarriers", ["barriers"])], m7.prototype, "readPointBarriers", null), r([m({ type: [d3] })], m7.prototype, "polylineBarriers", void 0), r([o2("polylineBarriers")], m7.prototype, "readPolylineBarriers", null), r([m({ type: [d3] })], m7.prototype, "polygonBarriers", void 0), r([o2("polygonBarriers")], m7.prototype, "readPolygonBarriers", null), r([m({ type: [u5] })], m7.prototype, "routeResults", void 0), m7 = r([a("esri.rest.support.RouteSolveResult")], m7);
var y5 = m7;

// node_modules/@arcgis/core/rest/route.js
function c11(e2) {
  return e2 instanceof d4;
}
async function l5(f7, p8, l7) {
  const y6 = [], d7 = [], g2 = {}, h2 = {}, R4 = f5(f7), { path: v3 } = R4;
  c11(p8.stops) && u3(p8.stops.features, d7, "stops.features", g2), c11(p8.pointBarriers) && u3(p8.pointBarriers.features, d7, "pointBarriers.features", g2), c11(p8.polylineBarriers) && u3(p8.polylineBarriers.features, d7, "polylineBarriers.features", g2), c11(p8.polygonBarriers) && u3(p8.polygonBarriers.features, d7, "polygonBarriers.features", g2);
  const B = await R(d7);
  for (const e2 in g2) {
    const r5 = g2[e2];
    y6.push(e2), h2[e2] = B.slice(r5[0], r5[1]);
  }
  if (c5(h2, y6)) {
    let e2 = null;
    try {
      e2 = await d6(v3, p8.apiKey, l7);
    } catch {
    }
    e2 && !e2.hasZ && f6(h2, y6);
  }
  for (const e2 in h2) h2[e2].forEach((t4, s4) => {
    o(p8, e2)[s4].geometry = t4;
  });
  const E = { ...l7, query: { ...R4.query, ...o5(p8), f: "json" } }, T2 = v3.endsWith("/solve") ? v3 : `${v3}/solve`, { data: b5 } = await U(T2, E);
  return m8(b5);
}
function m8(e2) {
  const { barriers: r5, directionLines: t4, directionPoints: s4, directions: o6, messages: a6, polygonBarriers: i8, polylineBarriers: n6, routes: u7, stops: f7, traversedEdges: c15, traversedJunctions: l7, traversedTurns: m9 } = e2, y6 = (e3) => {
    const r6 = g2.find((r7) => r7.routeName === e3);
    if (null != r6) return r6;
    const t5 = { routeId: g2.length + 1, routeName: e3 };
    return g2.push(t5), t5;
  }, d7 = (e3) => {
    const r6 = g2.find((r7) => r7.routeId === e3);
    if (null != r6) return r6;
    const t5 = { routeId: e3, routeName: null };
    return g2.push(t5), t5;
  }, g2 = [];
  u7 == null ? void 0 : u7.features.forEach((e3, r6) => {
    e3.geometry.spatialReference = u7.spatialReference ?? void 0;
    const t5 = e3.attributes.Name, s5 = r6 + 1;
    g2.push({ routeId: s5, routeName: t5, route: e3 });
  }), o6 == null ? void 0 : o6.forEach((e3) => {
    const { routeName: r6 } = e3;
    y6(r6).directions = e3;
  });
  const h2 = ((f7 == null ? void 0 : f7.features.every((e3) => null == e3.attributes.RouteName)) ?? false) && g2.length > 0 ? g2[0].routeName : null;
  return f7 == null ? void 0 : f7.features.forEach((e3) => {
    var _a;
    e3.geometry && ((_a = e3.geometry).spatialReference ?? (_a.spatialReference = f7.spatialReference ?? void 0));
    const r6 = h2 ?? e3.attributes.RouteName, t5 = y6(r6);
    t5.stops ?? (t5.stops = []), t5.stops.push(e3);
  }), t4 == null ? void 0 : t4.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, s5 = d7(r6), { geometryType: o7, spatialReference: a7 } = t4;
    s5.directionLines ?? (s5.directionLines = { features: [], geometryType: o7, spatialReference: a7 }), s5.directionLines.features.push(e3);
  }), s4 == null ? void 0 : s4.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = d7(r6), { geometryType: o7, spatialReference: a7 } = s4;
    t5.directionPoints ?? (t5.directionPoints = { features: [], geometryType: o7, spatialReference: a7 }), t5.directionPoints.features.push(e3);
  }), c15 == null ? void 0 : c15.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = d7(r6), { geometryType: s5, spatialReference: o7 } = c15;
    t5.traversedEdges ?? (t5.traversedEdges = { features: [], geometryType: s5, spatialReference: o7 }), t5.traversedEdges.features.push(e3);
  }), l7 == null ? void 0 : l7.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = d7(r6), { geometryType: s5, spatialReference: o7 } = l7;
    t5.traversedJunctions ?? (t5.traversedJunctions = { features: [], geometryType: s5, spatialReference: o7 }), t5.traversedJunctions.features.push(e3);
  }), m9 == null ? void 0 : m9.features.forEach((e3) => {
    const r6 = e3.attributes.RouteID, t5 = d7(r6);
    t5.traversedTurns ?? (t5.traversedTurns = { features: [] }), t5.traversedTurns.features.push(e3);
  }), y5.fromJSON({ routeResults: g2, barriers: r5, polygonBarriers: i8, polylineBarriers: n6, messages: a6 });
}

// node_modules/@arcgis/core/rest/support/commonProperties.js
var t3 = { type: String, json: { read: { source: "token" }, write: { target: "token" } } };

// node_modules/@arcgis/core/rest/support/DataLayer.js
var l6 = class extends i(f) {
  constructor(o6) {
    super(o6), this.doNotLocateOnRestrictedElements = null, this.geometry = null, this.geometryType = null, this.name = null, this.spatialRelationship = null, this.type = "layer", this.where = null;
  }
};
r([m({ type: Boolean, json: { write: true } })], l6.prototype, "doNotLocateOnRestrictedElements", void 0), r([m({ types: n3, json: { read: f2, write: true } })], l6.prototype, "geometry", void 0), r([r3(b3)], l6.prototype, "geometryType", void 0), r([m({ type: String, json: { name: "layerName", write: true } })], l6.prototype, "name", void 0), r([r3(R2, { name: "spatialRel" })], l6.prototype, "spatialRelationship", void 0), r([m({ type: String, json: { write: true } })], l6.prototype, "type", void 0), r([m({ type: String, json: { write: true } })], l6.prototype, "where", void 0), l6 = r([a("esri.rest.support.DataLayer")], l6);
var c12 = l6;

// node_modules/@arcgis/core/rest/support/NetworkFeatureSet.js
var s3;
var c13 = s3 = class extends d4 {
  constructor(e2) {
    super(e2), this.doNotLocateOnRestrictedElements = null;
  }
  clone() {
    return new s3({ doNotLocateOnRestrictedElements: this.doNotLocateOnRestrictedElements, ...this.cloneProperties() });
  }
};
r([m({ type: Boolean, json: { write: true } })], c13.prototype, "doNotLocateOnRestrictedElements", void 0), c13 = s3 = r([a("esri.rest.support.NetworkFeatureSet")], c13);
var p6 = c13;

// node_modules/@arcgis/core/rest/support/NetworkUrl.js
var p7 = class extends i(f) {
  constructor(o6) {
    super(o6), this.doNotLocateOnRestrictedElements = null, this.url = null;
  }
};
r([m({ type: Boolean, json: { write: true } })], p7.prototype, "doNotLocateOnRestrictedElements", void 0), r([m({ type: String, json: { write: true } })], p7.prototype, "url", void 0), p7 = r([a("esri.rest.support.NetworkUrl")], p7);
var c14 = p7;

// node_modules/@arcgis/core/rest/support/RouteParameters.js
var N2;
var P2 = N2 = class extends i(f) {
  constructor(t4) {
    super(t4), this.accumulateAttributes = null, this.apiKey = null, this.attributeParameterValues = null, this.directionsLanguage = null, this.directionsLengthUnits = null, this.directionsOutputType = null, this.directionsStyleName = null, this.directionsTimeAttribute = null, this.findBestSequence = null, this.geometryPrecision = null, this.geometryPrecisionM = null, this.geometryPrecisionZ = null, this.ignoreInvalidLocations = null, this.impedanceAttribute = null, this.outputGeometryPrecision = null, this.outputGeometryPrecisionUnits = null, this.outputLines = "true-shape", this.outSpatialReference = null, this.overrides = null, this.pointBarriers = null, this.polygonBarriers = null, this.polylineBarriers = null, this.preserveFirstStop = null, this.preserveLastStop = null, this.preserveObjectID = null, this.restrictionAttributes = null, this.restrictUTurns = null, this.returnBarriers = false, this.returnDirections = false, this.returnPolygonBarriers = false, this.returnPolylineBarriers = false, this.returnRoutes = true, this.returnStops = false, this.returnTraversedEdges = null, this.returnTraversedJunctions = null, this.returnTraversedTurns = null, this.returnZ = true, this.startTime = null, this.startTimeIsUTC = true, this.stops = null, this.timeWindowsAreUTC = null, this.travelMode = null, this.useHierarchy = null, this.useTimeWindows = null;
  }
  static from(t4) {
    return h(N2, t4);
  }
  readAccumulateAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => w2.fromJSON(t5));
  }
  writeAccumulateAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => w2.toJSON(t5)));
  }
  writePointBarriers(t4, e2, r5) {
    k2(t4, e2, r5);
  }
  writePolygonBarrier(t4, e2, r5) {
    k2(t4, e2, r5);
  }
  writePolylineBarrier(t4, e2, r5) {
    k2(t4, e2, r5);
  }
  readRestrictionAttributes(t4) {
    return null == t4 ? null : t4.map((t5) => M.fromJSON(t5));
  }
  writeRestrictionAttributes(t4, e2, r5) {
    (t4 == null ? void 0 : t4.length) && (e2[r5] = t4.map((t5) => M.toJSON(t5)));
  }
  readStartTime(t4, e2) {
    const { startTime: r5 } = e2;
    return null == r5 ? null : "now" === r5 ? "now" : new Date(r5);
  }
  writeStartTime(t4, e2) {
    null != t4 && (e2.startTime = "now" === t4 ? "now" : t4.getTime());
  }
  readStops(t4, e2) {
    return C2(e2.stops);
  }
  writeStops(t4, e2, r5) {
    k2(t4, e2, r5);
  }
};
r([m({ type: [String], json: { name: "accumulateAttributeNames", write: true } })], P2.prototype, "accumulateAttributes", void 0), r([o2("accumulateAttributes")], P2.prototype, "readAccumulateAttributes", null), r([r2("accumulateAttributes")], P2.prototype, "writeAccumulateAttributes", null), r([m(t3)], P2.prototype, "apiKey", void 0), r([m({ json: { write: true } })], P2.prototype, "attributeParameterValues", void 0), r([m({ type: String, json: { write: true } })], P2.prototype, "directionsLanguage", void 0), r([r3(a2)], P2.prototype, "directionsLengthUnits", void 0), r([r3(l2)], P2.prototype, "directionsOutputType", void 0), r([r3(U3)], P2.prototype, "directionsStyleName", void 0), r([r3(D2, { name: "directionsTimeAttributeName", ignoreUnknown: false })], P2.prototype, "directionsTimeAttribute", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "findBestSequence", void 0), r([m({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecision", void 0), r([m({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionM", void 0), r([m({ type: Number, json: { write: true } })], P2.prototype, "geometryPrecisionZ", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "ignoreInvalidLocations", void 0), r([r3(w2, { name: "impedanceAttributeName", ignoreUnknown: false })], P2.prototype, "impedanceAttribute", void 0), r([m({ type: Number, json: { write: true } })], P2.prototype, "outputGeometryPrecision", void 0), r([r3(r4)], P2.prototype, "outputGeometryPrecisionUnits", void 0), r([r3(c)], P2.prototype, "outputLines", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], P2.prototype, "outSpatialReference", void 0), r([m({ json: { write: true } })], P2.prototype, "overrides", void 0), r([m({ json: { name: "barriers", write: true } })], P2.prototype, "pointBarriers", void 0), r([r2("pointBarriers")], P2.prototype, "writePointBarriers", null), r([m({ json: { write: true } })], P2.prototype, "polygonBarriers", void 0), r([r2("polygonBarriers")], P2.prototype, "writePolygonBarrier", null), r([m({ json: { write: true } })], P2.prototype, "polylineBarriers", void 0), r([r2("polylineBarriers")], P2.prototype, "writePolylineBarrier", null), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "preserveFirstStop", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "preserveLastStop", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "preserveObjectID", void 0), r([m({ type: [String], json: { name: "restrictionAttributeNames", write: true } })], P2.prototype, "restrictionAttributes", void 0), r([o2("restrictionAttributes")], P2.prototype, "readRestrictionAttributes", null), r([r2("restrictionAttributes")], P2.prototype, "writeRestrictionAttributes", null), r([r3(m2)], P2.prototype, "restrictUTurns", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnDirections", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolygonBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnPolylineBarriers", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnRoutes", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnStops", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedEdges", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedJunctions", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnTraversedTurns", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "returnZ", void 0), r([m({ json: { write: true } })], P2.prototype, "startTime", void 0), r([o2("startTime")], P2.prototype, "readStartTime", null), r([r2("startTime")], P2.prototype, "writeStartTime", null), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "startTimeIsUTC", void 0), r([m({ json: { write: true } })], P2.prototype, "stops", void 0), r([o2("stops")], P2.prototype, "readStops", null), r([r2("stops")], P2.prototype, "writeStops", null), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "timeWindowsAreUTC", void 0), r([m({ type: j3, json: { write: true } })], P2.prototype, "travelMode", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "useHierarchy", void 0), r([m({ type: Boolean, json: { write: true } })], P2.prototype, "useTimeWindows", void 0), P2 = N2 = r([a("esri.rest.support.RouteParameters")], P2);
var O = P2;
function J(t4) {
  return t4 && "type" in t4;
}
function L2(t4) {
  return t4 && "features" in t4 && "doNotLocateOnRestrictedElements" in t4;
}
function R3(t4) {
  return t4 && "url" in t4;
}
function U4(t4) {
  return t4 && "features" in t4;
}
function C2(t4) {
  return J(t4) ? c12.fromJSON(t4) : R3(t4) ? c14.fromJSON(t4) : L2(t4) ? p6.fromJSON(t4) : U4(t4) ? d4.fromJSON(t4) : null;
}
function k2(t4, e2, o6) {
  null != t4 && (e2[o6] = V.isCollection(t4) ? { features: t4.toArray().map((t5) => t5.toJSON()) } : t4.toJSON());
}

// node_modules/@arcgis/core/layers/RouteLayer.js
function z(e2) {
  return e2.length ? e2 : null;
}
function H(e2) {
  switch (e2) {
    case "esriGeometryPoint":
      return { type: "esriSMS", style: "esriSMSCircle", size: 12, color: [0, 0, 0, 0], outline: H("esriGeometryPolyline") };
    case "esriGeometryPolyline":
      return { type: "esriSLS", style: "esriSLSSolid", width: 1, color: [0, 0, 0, 0] };
    case "esriGeometryPolygon":
      return { type: "esriSFS", style: "esriSFSNull", outline: H("esriGeometryPolyline") };
  }
}
function K2(e2) {
  return "layers" in e2;
}
function Q(e2) {
  return "esri.rest.support.FeatureSet" === e2.declaredClass;
}
function Y(e2) {
  return "esri.rest.support.NetworkFeatureSet" === e2.declaredClass;
}
function Z(e2, t4, r5) {
  var _a, _b, _c, _d, _e, _f;
  const o6 = (_a = t4.networkDataset) == null ? void 0 : _a.networkAttributes, i8 = (o6 == null ? void 0 : o6.filter(({ usageType: e3 }) => "cost" === e3)) ?? [], s4 = r5.travelMode ?? t4.defaultTravelMode;
  if (null == s4) return void ue().warn("route-layer:missing-travel-mode", "The routing service must have a default travel mode or one must be specified in the route parameter.");
  const { timeAttributeName: n6, distanceAttributeName: a6 } = s4, u7 = i8.find(({ name: e3 }) => e3 === n6), p8 = i8.find(({ name: e3 }) => e3 === a6), c15 = ((_b = r5.travelMode) == null ? void 0 : _b.impedanceAttributeName) ?? r5.impedanceAttribute ?? t4.impedance, m9 = u7 == null ? void 0 : u7.units, y6 = p8 == null ? void 0 : p8.units;
  if (!m9 || !y6) throw new s2("routelayer:unknown-impedance-units", "the units of either the distance or time impedance are unknown");
  const f7 = r5.directionsLanguage ?? t4.directionsLanguage, d7 = r5.accumulateAttributes ?? t4.accumulateAttributeNames ?? [], h2 = new Set(i8.filter(({ name: e3 }) => e3 === n6 || e3 === a6 || e3 === c15 || null != e3 && d7.includes(e3)).map(({ name: e3 }) => e3)), w4 = (e3) => {
    for (const t5 in e3) h2.has(t5) || delete e3[t5];
  };
  for (const l7 of e2.pointBarriers) null != l7.costs && (l7.addedCost = l7.costs[c15] ?? 0, w4(l7.costs));
  for (const l7 of e2.polygonBarriers) null != l7.costs && (l7.scaleFactor = l7.costs[c15] ?? 1, w4(l7.costs));
  for (const l7 of e2.polylineBarriers) null != l7.costs && (l7.scaleFactor = l7.costs[c15] ?? 1, w4(l7.costs));
  const { routeInfo: S5 } = e2, { findBestSequence: g2, preserveFirstStop: b5, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P3 } = r5;
  S5.analysisSettings = new c3({ accumulateAttributes: d7, directionsLanguage: f7, findBestSequence: g2, preserveFirstStop: b5, preserveLastStop: v3, startTimeIsUTC: B, timeWindowsAreUTC: P3, travelMode: s4 }), S5.totalDuration = X(((_c = S5.totalCosts) == null ? void 0 : _c[n6]) ?? 0, m9), S5.totalDistance = ee(((_d = S5.totalCosts) == null ? void 0 : _d[a6]) ?? 0, y6), S5.totalLateDuration = X(((_e = S5.totalViolations) == null ? void 0 : _e[n6]) ?? 0, m9), S5.totalWaitDuration = X(((_f = S5.totalWait) == null ? void 0 : _f[n6]) ?? 0, m9), null != S5.totalCosts && w4(S5.totalCosts), null != S5.totalViolations && w4(S5.totalViolations), null != S5.totalWait && w4(S5.totalWait);
  for (const l7 of e2.stops) null != l7.serviceCosts && (l7.serviceDuration = X(l7.serviceCosts[n6] ?? 0, m9), l7.serviceDistance = ee(l7.serviceCosts[a6] ?? 0, y6), w4(l7.serviceCosts)), null != l7.cumulativeCosts && (l7.cumulativeDuration = X(l7.cumulativeCosts[n6] ?? 0, m9), l7.cumulativeDistance = ee(l7.cumulativeCosts[a6] ?? 0, y6), w4(l7.cumulativeCosts)), null != l7.violations && (l7.lateDuration = X(l7.violations[n6] ?? 0, m9), w4(l7.violations)), null != l7.wait && (l7.waitDuration = X(l7.wait[n6] ?? 0, m9), w4(l7.wait));
}
async function $(e2) {
  const t4 = g.WGS84;
  return await N(e2.spatialReference, t4), K(e2, t4);
}
function X(e2, t4) {
  switch (t4) {
    case "seconds":
      return e2 / 60;
    case "hours":
      return 60 * e2;
    case "days":
      return 60 * e2 * 24;
    default:
      return e2;
  }
}
function ee(e2, t4) {
  return "decimal-degrees" === t4 || "points" === t4 || "unknown" === t4 ? e2 : I2(e2, t4, "meters");
}
function te(e2) {
  const { attributes: t4, geometry: r5, popupTemplate: o6, symbol: i8 } = e2.toGraphic().toJSON();
  return { attributes: t4, geometry: r5, popupInfo: o6, symbol: i8 };
}
var re = V.ofType(c2);
var oe = V.ofType(y3);
var ie = V.ofType(C);
var se = V.ofType(T);
var ne = V.ofType(j4);
var le = V.ofType(w3);
var ae = "esri.layers.RouteLayer";
var ue = () => n.getLogger(ae);
var pe = class extends l(t2(b2(j2(S2(f4))))) {
  constructor(e2) {
    super(e2), this._cachedServiceDescription = null, this._featureCollection = null, this._type = "Feature Collection", this.defaultSymbols = new d5(), this.directionLines = null, this.directionPoints = null, this.featureCollectionType = "route", this.legendEnabled = false, this.maxScale = 0, this.minScale = 0, this.pointBarriers = new ie(), this.polygonBarriers = new se(), this.polylineBarriers = new ne(), this.routeInfo = null, this.spatialReference = g.WGS84, this.stops = new le(), this.type = "route";
    const t4 = () => {
      this._setStopSymbol(this.stops);
    };
    this.addHandles(v(() => this.stops, "change", t4, { sync: true, onListenerAdd: t4 }));
  }
  writeFeatureCollectionWebmap(e2, t4, r5, o6) {
    const i8 = [this._writePolygonBarriers(), this._writePolylineBarriers(), this._writePointBarriers(), this._writeRouteInfo(), this._writeDirectionLines(), this._writeDirectionPoints(), this._writeStops()].filter((e3) => !!e3), s4 = i8.map((e3, t5) => t5), n6 = "web-map" === o6.origin ? "featureCollection.layers" : "layers";
    e(n6, i8, t4), t4.opacity = this.opacity, t4.visibility = this.visible, t4.visibleLayers = s4;
  }
  readDirectionLines(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionLines", (e3) => c2.fromGraphic(e3));
  }
  readDirectionPoints(e2, t4) {
    return this._getNetworkFeatures(t4, "DirectionPoints", (e3) => y3.fromGraphic(e3));
  }
  get fullExtent() {
    var _a;
    const e2 = new w({ xmin: -180, ymin: -90, xmax: 180, ymax: 90, spatialReference: g.WGS84 });
    if (null != ((_a = this.routeInfo) == null ? void 0 : _a.geometry)) return this.routeInfo.geometry.extent ?? e2;
    if (null == this.stops) return e2;
    const t4 = this.stops.filter((e3) => null != e3.geometry);
    if (t4.length < 2) return e2;
    const { spatialReference: r5 } = t4.at(0).geometry;
    if (null == r5) return e2;
    const o6 = t4.toArray().map((e3) => {
      const t5 = e3.geometry;
      return [t5.x, t5.y];
    });
    return new u({ points: o6, spatialReference: r5 }).extent;
  }
  readMaxScale(e2, t4) {
    var _a;
    const r5 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o6 = r5 == null ? void 0 : r5.find((e3) => null != e3.layerDefinition.maxScale);
    return (o6 == null ? void 0 : o6.layerDefinition.maxScale) ?? 0;
  }
  readMinScale(e2, t4) {
    var _a;
    const r5 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers, o6 = r5 == null ? void 0 : r5.find((e3) => null != e3.layerDefinition.minScale);
    return (o6 == null ? void 0 : o6.layerDefinition.minScale) ?? 0;
  }
  readPointBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "Barriers", (e3) => C.fromGraphic(e3));
  }
  readPolygonBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolygonBarriers", (e3) => T.fromGraphic(e3));
  }
  readPolylineBarriers(e2, t4) {
    return this._getNetworkFeatures(t4, "PolylineBarriers", (e3) => j4.fromGraphic(e3));
  }
  readRouteInfo(e2, t4) {
    return this._getNetworkFeatures(t4, "RouteInfo", (e3) => S4.fromGraphic(e3)).at(0) ?? null;
  }
  readSpatialReference(e2, t4) {
    var _a, _b;
    const r5 = K2(t4) ? t4.layers : (_a = t4.featureCollection) == null ? void 0 : _a.layers;
    if (!(r5 == null ? void 0 : r5.length)) return g.WGS84;
    const { layerDefinition: o6, featureSet: i8 } = r5[0], s4 = i8.features[0], n6 = ((_b = s4 == null ? void 0 : s4.geometry) == null ? void 0 : _b.spatialReference) ?? i8.spatialReference ?? o6.spatialReference ?? o6.extent.spatialReference ?? U2;
    return g.fromJSON(n6);
  }
  readStops(e2, t4) {
    return this._getNetworkFeatures(t4, "Stops", (e3) => w3.fromGraphic(e3), (e3) => this._setStopSymbol(e3));
  }
  get title() {
    var _a;
    return ((_a = this.routeInfo) == null ? void 0 : _a.name) ?? "Route";
  }
  set title(e2) {
    this._overrideIfSome("title", e2);
  }
  get url() {
    return s.routeServiceUrl;
  }
  set url(e2) {
    null != e2 ? this._set("url", y(e2, ue())) : this._set("url", s.routeServiceUrl);
  }
  load(e2) {
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Feature Collection"] }, e2)), Promise.resolve(this);
  }
  removeAll() {
    this.removeResult(), this.pointBarriers.removeAll(), this.polygonBarriers.removeAll(), this.polylineBarriers.removeAll(), this.stops.removeAll();
  }
  removeResult() {
    null != this.directionLines && (this.directionLines.removeAll(), this._set("directionLines", null)), null != this.directionPoints && (this.directionPoints.removeAll(), this._set("directionPoints", null)), null != this.routeInfo && this._set("routeInfo", null);
  }
  async save() {
    await this.load();
    const { fullExtent: e2, portalItem: t4 } = this;
    if (!t4) throw new s2("routelayer:portal-item-not-set", "save() requires to the layer to have a portal item");
    if (!t4.id) throw new s2("routelayer:portal-item-not-saved", "Please use saveAs() first to save the routelayer");
    if ("Feature Collection" !== t4.type) throw new s2("routelayer:portal-item-wrong-type", 'Portal item needs to have type "Feature Collection"');
    if (null == this.routeInfo) throw new s2("routelayer:route-unsolved", "save() requires a solved route");
    const { portal: r5 } = t4;
    await r5.signIn(), r5.user || await t4.reload();
    const { itemUrl: o6, itemControl: i8 } = t4;
    if ("admin" !== i8 && "update" !== i8) throw new s2("routelayer:insufficient-permissions", "To save this layer, you need to be the owner or an administrator of your organization");
    const s4 = { messages: [], origin: "portal-item", portal: r5, url: o6 ? I(o6) : void 0, writtenProperties: [] }, n6 = this.write(void 0, s4);
    return t4.extent = await $(e2), t4.title = this.title, await t4.update({ data: n6 }), t4;
  }
  async saveAs(e2, t4 = {}) {
    if (await this.load(), null == this.routeInfo) throw new s2("routelayer:route-unsolved", "saveAs() requires a solved route");
    const r5 = S.from(e2).clone();
    r5.extent ?? (r5.extent = await $(this.fullExtent)), r5.id = null, r5.portal ?? (r5.portal = b4.getDefault()), r5.title ?? (r5.title = this.title), r5.type = "Feature Collection", r5.typeKeywords = ["Data", "Feature Collection", f3.MULTI_LAYER, "Route Layer"];
    const { portal: o6 } = r5, i8 = { messages: [], origin: "portal-item", portal: o6, url: null, writtenProperties: [] };
    await o6.signIn();
    const s4 = t4 == null ? void 0 : t4.folder, n6 = this.write(void 0, i8);
    return await o6.user.addItem({ item: r5, folder: s4, data: n6 }), this.portalItem = r5, i2(i8), i8.portalItem = r5, r5;
  }
  async solve(e2, t4) {
    const r5 = (e2 == null ? void 0 : e2.stops) ?? this.stops, o6 = (e2 == null ? void 0 : e2.pointBarriers) ?? z(this.pointBarriers), i8 = (e2 == null ? void 0 : e2.polylineBarriers) ?? z(this.polylineBarriers), s4 = (e2 == null ? void 0 : e2.polygonBarriers) ?? z(this.polygonBarriers);
    if (null == r5) throw new s2("routelayer:undefined-stops", "the route layer must have stops defined in the route parameters.");
    if ((Q(r5) || Y(r5)) && r5.features.length < 2 || V.isCollection(r5) && r5.length < 2) throw new s2("routelayer:insufficent-stops", "the route layer must have two or more stops to solve a route.");
    if (V.isCollection(r5)) for (const n6 of r5) n6.routeName = null;
    const a6 = e2 == null ? void 0 : e2.apiKey, u7 = this.url, c15 = await this._getServiceDescription(u7, a6, t4), m9 = (e2 == null ? void 0 : e2.travelMode) ?? c15.defaultTravelMode, y6 = (e2 == null ? void 0 : e2.accumulateAttributes) ?? [];
    null != m9 && (y6.push(m9.distanceAttributeName), m9.timeAttributeName && y6.push(m9.timeAttributeName));
    const f7 = { accumulateAttributes: y6, directionsOutputType: "featuresets", ignoreInvalidLocations: true, pointBarriers: o6, polylineBarriers: i8, polygonBarriers: s4, preserveFirstStop: true, preserveLastStop: true, returnBarriers: !!o6, returnDirections: true, returnPolygonBarriers: !!s4, returnPolylineBarriers: !!i8, returnRoutes: true, returnStops: true, stops: r5 }, d7 = O.from(e2 ?? {});
    let h2;
    d7.set(f7);
    try {
      h2 = await l5(u7, d7, t4);
    } catch (S5) {
      throw b(S5) ? S5 : new s2("routelayer:failed-route-request", "the routing request failed", { error: S5 });
    }
    const w4 = this._toRouteLayerSolution(h2);
    return this._isOverridden("title") || (this.title = w4.routeInfo.name ?? "Route"), Z(w4, c15, d7), w4;
  }
  update(e2) {
    const { stops: t4, directionLines: r5, directionPoints: o6, pointBarriers: i8, polylineBarriers: s4, polygonBarriers: n6, routeInfo: l7 } = e2;
    this.set({ stops: t4, pointBarriers: i8, polylineBarriers: s4, polygonBarriers: n6 }), this._set("directionLines", r5), this._set("directionPoints", o6), this._set("routeInfo", l7), null != l7.geometry && (this.spatialReference = l7.geometry.spatialReference);
  }
  _getNetworkFeatures(e2, t4, s4, l7) {
    var _a;
    const a6 = K2(e2) ? e2.layers : (_a = e2.featureCollection) == null ? void 0 : _a.layers, u7 = a6 == null ? void 0 : a6.find((e3) => e3.layerDefinition.name === t4);
    if (null == u7) return new V();
    const { layerDefinition: p8, popupInfo: c15, featureSet: m9 } = u7, y6 = p8.drawingInfo.renderer, { features: f7 } = m9, d7 = m9.spatialReference ?? p8.spatialReference ?? p8.extent.spatialReference ?? U2, h2 = y6 && o3(y6), w4 = g.fromJSON(d7), S5 = f7.map((e3) => {
      const i8 = d3.fromJSON(e3);
      null != i8.geometry && null != e3.geometry && null == e3.geometry.spatialReference && (i8.geometry.spatialReference = w4);
      const n6 = s4(i8);
      return n6.symbol ?? (n6.symbol = (h2 == null ? void 0 : h2.getSymbol(i8)) ?? this._getNetworkSymbol(t4)), n6.popupTemplate ?? (n6.popupTemplate = c15 && q.fromJSON(c15)), n6;
    });
    return l7 && S5.some(({ symbol: e3 }) => !e3) && l7(S5), new V(S5);
  }
  _getNetworkSymbol(e2) {
    switch (e2) {
      case "Barriers":
        return this.defaultSymbols.pointBarriers;
      case "DirectionPoints":
        return this.defaultSymbols.directionPoints;
      case "DirectionLines":
        return this.defaultSymbols.directionLines;
      case "PolylineBarriers":
        return this.defaultSymbols.polylineBarriers;
      case "PolygonBarriers":
        return this.defaultSymbols.polygonBarriers;
      case "RouteInfo":
        return this.defaultSymbols.routeInfo;
      case "Stops":
        return null;
    }
  }
  async _getServiceDescription(e2, t4, r5) {
    if (null != this._cachedServiceDescription && this._cachedServiceDescription.url === e2) return this._cachedServiceDescription.serviceDescription;
    const o6 = await d6(e2, t4, r5);
    return this._cachedServiceDescription = { serviceDescription: o6, url: e2 }, o6;
  }
  _setStopSymbol(e2) {
    if (!e2 || 0 === e2.length) return;
    if (null == this.defaultSymbols.stops) return;
    if (e2.every(({ symbol: e3 }) => null != e3)) return;
    const { first: t4, last: r5, middle: o6, unlocated: i8, waypoint: s4, break: n6 } = this.defaultSymbols.stops;
    if (null == this.routeInfo || 1 === e2.length) return void e2.forEach((i9, s5) => {
      switch (s5) {
        case 0:
          i9.symbol = t4;
          break;
        case e2.length - 1:
          i9.symbol = r5;
          break;
        default:
          i9.symbol = o6;
      }
    });
    const l7 = e2.map(({ sequence: e3 }) => e3).filter((e3) => null != e3), a6 = Math.min(...l7), u7 = Math.max(...l7);
    for (const p8 of e2) p8.sequence !== a6 ? p8.sequence !== u7 ? "ok" === p8.status || "not-located-on-closest" === p8.status ? "waypoint" !== p8.locationType ? "break" !== p8.locationType ? p8.symbol = o6 : p8.symbol = n6 : p8.symbol = s4 : p8.symbol = i8 : p8.symbol = r5 : p8.symbol = t4;
  }
  _toRouteLayerSolution(e2) {
    var _a, _b, _c, _d, _e, _f, _g;
    const t4 = (_a = e2.routeResults[0].stops) == null ? void 0 : _a.map((e3) => w3.fromJSON(e3.toJSON()));
    this._setStopSymbol(t4);
    const r5 = new le(t4), o6 = new se((_b = e2.polygonBarriers) == null ? void 0 : _b.map((e3) => {
      const t5 = T.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polygonBarriers, t5;
    })), i8 = new ne((_c = e2.polylineBarriers) == null ? void 0 : _c.map((e3) => {
      const t5 = j4.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.polylineBarriers, t5;
    })), s4 = new ie((_d = e2.pointBarriers) == null ? void 0 : _d.map((e3) => {
      const t5 = C.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.pointBarriers, t5;
    })), n6 = (_e = e2.routeResults[0].route) == null ? void 0 : _e.toJSON(), l7 = S4.fromJSON(n6);
    l7.symbol = this.defaultSymbols.routeInfo;
    const a6 = new oe((_f = e2.routeResults[0].directionPoints) == null ? void 0 : _f.features.map((e3) => {
      const t5 = y3.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionPoints, t5;
    }));
    return { directionLines: new re((_g = e2.routeResults[0].directionLines) == null ? void 0 : _g.features.map((e3) => {
      const t5 = c2.fromJSON(e3.toJSON());
      return t5.symbol = this.defaultSymbols.directionLines, t5;
    })), directionPoints: a6, pointBarriers: s4, polygonBarriers: o6, polylineBarriers: i8, routeInfo: l7, stops: r5 };
  }
  _writeDirectionLines() {
    return this._writeNetworkFeatures(this.directionLines, this.defaultSymbols.directionLines, "esriGeometryPolyline", c2.fields, "DirectionLines", "Direction Lines");
  }
  _writeDirectionPoints() {
    return this._writeNetworkFeatures(this.directionPoints, this.defaultSymbols.directionPoints, "esriGeometryPoint", y3.fields, "DirectionPoints", "Direction Points");
  }
  _writeNetworkFeatures(e2, t4, r5, o6, i8, s4) {
    if (!(e2 == null ? void 0 : e2.length)) return null;
    const n6 = this.spatialReference.toJSON(), { fullExtent: l7, maxScale: a6, minScale: u7 } = this;
    return { featureSet: { features: e2.toArray().map((e3) => te(e3)), geometryType: r5, spatialReference: n6 }, layerDefinition: { capabilities: "Query,Update,Editing", drawingInfo: { renderer: { type: "simple", symbol: null != t4 ? t4.toJSON() : H(r5) } }, extent: l7.toJSON(), fields: o6, geometryType: r5, hasM: false, hasZ: false, maxScale: a6, minScale: u7, name: i8, objectIdField: "ObjectID", spatialReference: n6, title: s4, type: "Feature Layer", typeIdField: "" } };
  }
  _writePointBarriers() {
    return this._writeNetworkFeatures(this.pointBarriers, this.defaultSymbols.pointBarriers, "esriGeometryPoint", C.fields, "Barriers", "Point Barriers");
  }
  _writePolygonBarriers() {
    return this._writeNetworkFeatures(this.polygonBarriers, this.defaultSymbols.polygonBarriers, "esriGeometryPolygon", T.fields, "PolygonBarriers", "Polygon Barriers");
  }
  _writePolylineBarriers() {
    return this._writeNetworkFeatures(this.polylineBarriers, this.defaultSymbols.polylineBarriers, "esriGeometryPolyline", j4.fields, "PolylineBarriers", "Line Barriers");
  }
  _writeRouteInfo() {
    return this._writeNetworkFeatures(null != this.routeInfo ? new V([this.routeInfo]) : null, this.defaultSymbols.routeInfo, "esriGeometryPolyline", S4.fields, "RouteInfo", "Route Details");
  }
  _writeStops() {
    var _a, _b, _c;
    const e2 = this._writeNetworkFeatures(this.stops, null, "esriGeometryPoint", w3.fields, "Stops", "Stops");
    if (null == e2) return null;
    const { stops: t4 } = this.defaultSymbols, r5 = (_a = t4 == null ? void 0 : t4.first) == null ? void 0 : _a.toJSON(), o6 = (_b = t4 == null ? void 0 : t4.middle) == null ? void 0 : _b.toJSON(), i8 = (_c = t4 == null ? void 0 : t4.last) == null ? void 0 : _c.toJSON();
    return e2.layerDefinition.drawingInfo.renderer = { type: "uniqueValue", field1: "Sequence", defaultSymbol: o6, uniqueValueInfos: [{ value: "1", symbol: r5, label: "First Stop" }, { value: `${this.stops.length}`, symbol: i8, label: "Last Stop" }] }, e2;
  }
};
r([m({ readOnly: true, json: { read: false, origins: { "portal-item": { write: { allowNull: true, ignoreOrigin: true } }, "web-map": { write: { overridePolicy() {
  return { allowNull: true, ignoreOrigin: null == this.portalItem };
} } } } } })], pe.prototype, "_featureCollection", void 0), r([r2(["web-map", "portal-item"], "_featureCollection")], pe.prototype, "writeFeatureCollectionWebmap", null), r([m({ readOnly: true, json: { read: false, origins: { "web-map": { write: { target: "type", overridePolicy() {
  return { ignoreOrigin: null != this.portalItem };
} } } } } })], pe.prototype, "_type", void 0), r([m({ nonNullable: true, type: d5 })], pe.prototype, "defaultSymbols", void 0), r([m({ readOnly: true })], pe.prototype, "directionLines", void 0), r([o2(["web-map", "portal-item"], "directionLines", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionLines", null), r([m({ readOnly: true })], pe.prototype, "directionPoints", void 0), r([o2(["web-map", "portal-item"], "directionPoints", ["layers", "featureCollection.layers"])], pe.prototype, "readDirectionPoints", null), r([m({ readOnly: true, json: { read: false, origins: { "web-map": { write: { ignoreOrigin: true } } } } })], pe.prototype, "featureCollectionType", void 0), r([m({ readOnly: true })], pe.prototype, "fullExtent", null), r([m({ json: { origins: { "web-map": { name: "featureCollection.showLegend" } }, write: true } })], pe.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], pe.prototype, "listMode", void 0), r([m({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "maxScale", void 0), r([o2(["web-map", "portal-item"], "maxScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMaxScale", null), r([m({ type: Number, nonNullable: true, json: { write: false } })], pe.prototype, "minScale", void 0), r([o2(["web-map", "portal-item"], "minScale", ["layers", "featureCollection.layers"])], pe.prototype, "readMinScale", null), r([m({ type: ["ArcGISFeatureLayer"], value: "ArcGISFeatureLayer" })], pe.prototype, "operationalLayerType", void 0), r([m({ nonNullable: true, type: V.ofType(C) })], pe.prototype, "pointBarriers", void 0), r([o2(["web-map", "portal-item"], "pointBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPointBarriers", null), r([m({ nonNullable: true, type: V.ofType(T) })], pe.prototype, "polygonBarriers", void 0), r([o2(["web-map", "portal-item"], "polygonBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolygonBarriers", null), r([m({ nonNullable: true, type: V.ofType(j4) })], pe.prototype, "polylineBarriers", void 0), r([o2(["web-map", "portal-item"], "polylineBarriers", ["layers", "featureCollection.layers"])], pe.prototype, "readPolylineBarriers", null), r([m({ readOnly: true })], pe.prototype, "routeInfo", void 0), r([o2(["web-map", "portal-item"], "routeInfo", ["layers", "featureCollection.layers"])], pe.prototype, "readRouteInfo", null), r([m({ type: g })], pe.prototype, "spatialReference", void 0), r([o2(["web-map", "portal-item"], "spatialReference", ["layers", "featureCollection.layers"])], pe.prototype, "readSpatialReference", null), r([m({ nonNullable: true, type: V.ofType(w3) })], pe.prototype, "stops", void 0), r([o2(["web-map", "portal-item"], "stops", ["layers", "featureCollection.layers"])], pe.prototype, "readStops", null), r([m()], pe.prototype, "title", null), r([m({ readOnly: true, json: { read: false } })], pe.prototype, "type", void 0), r([m()], pe.prototype, "url", null), pe = r([a(ae)], pe);
var ce = pe;
export {
  ce as default
};
//# sourceMappingURL=RouteLayer-4ATPF6AY.js.map
