import {
  A,
  C,
  D as D2,
  E,
  F as F2,
  I,
  L,
  O,
  S as S3,
  T as T2,
  a as a2,
  f as f4,
  f2 as f5,
  g as g3,
  h,
  m as m3,
  p,
  s as s2,
  t as t2,
  t2 as t3,
  w,
  w2
} from "./chunk-QPKZXDIJ.js";
import {
  t
} from "./chunk-IYIF3BRH.js";
import {
  N as N2
} from "./chunk-3FC4BMWX.js";
import {
  K,
  _e,
  ze
} from "./chunk-DP4BKMXB.js";
import {
  D,
  F,
  J,
  M,
  N,
  T,
  d,
  f as f2,
  g as g2,
  j,
  k,
  l,
  s,
  y as y2
} from "./chunk-ZFCZ2Q23.js";
import {
  Z,
  a,
  n as n4,
  r,
  u
} from "./chunk-WCAEZENI.js";
import {
  c as c2,
  n as n3,
  n2 as n5
} from "./chunk-MBR7IVUG.js";
import {
  Xe
} from "./chunk-ER5KJVHG.js";
import {
  n as n7,
  x
} from "./chunk-H4E2VVPD.js";
import {
  n as n8
} from "./chunk-QB7C6VGC.js";
import {
  Z as Z2
} from "./chunk-GGPPKSP2.js";
import {
  c as c3
} from "./chunk-5IA763KB.js";
import {
  d as d3
} from "./chunk-G54IOEGF.js";
import {
  b
} from "./chunk-WGIZLWW7.js";
import {
  m
} from "./chunk-PUOCGOJB.js";
import {
  y
} from "./chunk-AMH7OVBF.js";
import {
  d as d2
} from "./chunk-VILGTHTP.js";
import {
  f as f3
} from "./chunk-2HEBE37N.js";
import {
  n as n6
} from "./chunk-445IB4DS.js";
import {
  f
} from "./chunk-F26LCWNQ.js";
import {
  S as S2
} from "./chunk-BMGF5ELJ.js";
import {
  m as m2
} from "./chunk-CY5MS6DC.js";
import {
  n as n2
} from "./chunk-A3J7W53Y.js";
import {
  g
} from "./chunk-L6D73M4D.js";
import {
  c
} from "./chunk-DRBJFCLQ.js";
import {
  U,
  i
} from "./chunk-X7VTUWCX.js";
import {
  S
} from "./chunk-GRW2QIBT.js";
import {
  n
} from "./chunk-R2PAF6JT.js";

// node_modules/@arcgis/core/arcade/featureSetCollection.js
var e = class {
  constructor() {
    this.declaredRootClass = "esri.arcade.featureSetCollection", this._layerById = {}, this._layerByName = {};
  }
  add(e3, t5, a6) {
    this._layerById[t5] = a6, this._layerByName[e3] = a6;
  }
  async featureSetByName(e3, t5 = true, a6 = ["*"]) {
    return void 0 === this._layerByName[e3] ? null : this._layerByName[e3];
  }
  async featureSetById(e3, t5 = true, a6 = ["*"]) {
    return void 0 === this._layerById[e3] ? null : this._layerById[e3];
  }
  castToText(e3 = false) {
    return "object, FeatureSetCollection";
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/AttributeFilter.js
var c4 = class _c extends C {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.actions.AttributeFilter", this._maxProcessing = 1e3, this._parent = e3.parentfeatureset, e3.whereclause instanceof Z ? (this._whereclause = e3.whereclause, this._whereClauseFunction = null) : (this._whereClauseFunction = e3.whereclause, this._whereclause = null);
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.fields = this._parent.fields.slice(), this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types, this.subtypeField = this._parent.subtypeField, this.subtypes = this._parent.subtypes) : (this.fields = [], this.typeIdField = "", this.subtypeField = "", this.objectIdField = "", this.globalIdField = "", this.spatialReference = new g({ wkid: 4326 }), this.geometryType = N.point);
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t5 = await this._parent._getFilteredSet("", null, this._whereclause, null, e3);
      return this._checkCancelled(e3), null !== this._whereClauseFunction ? this._wset = new t3(t5._candidates.slice().concat(t5._known.slice()), [], t5._ordered, this._clonePageDefinition(t5.pagesDefinition)) : this._wset = new t3(t5._candidates.slice(), t5._known.slice(), t5._ordered, this._clonePageDefinition(t5.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e3) {
    var _a;
    let t5 = (_a = this._parent) == null ? void 0 : _a._isInFeatureSet(e3);
    return t5 === s.NotInFeatureSet ? t5 : (t5 = this._idstates[e3], void 0 === t5 ? s.Unknown : t5);
  }
  _getFeature(e3, t5, s4) {
    return this._parent._getFeature(e3, t5, s4);
  }
  _getFeatures(e3, t5, s4, i2) {
    return this._parent._getFeatures(e3, t5, s4, i2);
  }
  _featureFromCache(e3) {
    return this._parent._featureFromCache(e3);
  }
  executeWhereClause(e3) {
    var _a;
    return ((_a = this._whereclause) == null ? void 0 : _a.testFeature(e3)) ?? false;
  }
  async executeWhereClauseDeferred(e3) {
    if (null !== this._whereClauseFunction) {
      const t5 = this._whereClauseFunction(e3);
      return S(t5), t5;
    }
    return this.executeWhereClause(e3);
  }
  async _fetchAndRefineFeatures(e3, t5, s4) {
    var _a, _b, _c2;
    const r2 = new t3([], e3, false, null), a6 = Math.min(t5, e3.length);
    if (await ((_a = this._parent) == null ? void 0 : _a._getFeatures(r2, -1, a6, s4)), this._checkCancelled(s4), null == this._whereClauseFunction) {
      for (let t6 = 0; t6 < a6; t6++) {
        const s5 = (_b = this._parent) == null ? void 0 : _b._featureFromCache(e3[t6]);
        true === this.executeWhereClause(s5) ? this._idstates[e3[t6]] = s.InFeatureSet : this._idstates[e3[t6]] = s.NotInFeatureSet;
      }
      return "success";
    }
    const l2 = [];
    for (let i2 = 0; i2 < a6; i2++) {
      const t6 = (_c2 = this._parent) == null ? void 0 : _c2._featureFromCache(e3[i2]);
      l2.push(await this.executeWhereClauseDeferred(t6));
    }
    for (let i2 = 0; i2 < t5; i2++) true === l2[i2] ? this._idstates[e3[i2]] = s.InFeatureSet : this._idstates[e3[i2]] = s.NotInFeatureSet;
    return "success";
  }
  async _getFilteredSet(e3, t5, s4, r2, n9) {
    null !== this._whereClauseFunction || (null !== s4 ? null !== this._whereclause && (s4 = g3(this._whereclause, s4)) : s4 = this._whereclause), await this._ensureLoaded();
    const l2 = await this._parent._getFilteredSet(e3, t5, s4, r2, n9);
    let h2;
    return this._checkCancelled(n9), h2 = null !== this._whereClauseFunction ? new t3(l2._candidates.slice().concat(l2._known.slice()), [], l2._ordered, this._clonePageDefinition(l2.pagesDefinition)) : new t3(l2._candidates.slice(), l2._known.slice(), l2._ordered, this._clonePageDefinition(l2.pagesDefinition)), h2;
  }
  async _stat(e3, t5, s4, i2, r2, n9, l2) {
    if (null !== this._whereClauseFunction) return null === r2 && "" === s4 && null === i2 ? this._manualStat(e3, t5, n9, l2) : { calculated: false };
    let h2 = this._whereclause;
    null !== r2 && null !== this._whereclause && (h2 = g3(this._whereclause, r2));
    const u2 = await this._parent._stat(e3, t5, s4, i2, h2, n9, l2);
    return false === u2.calculated ? null === r2 && "" === s4 && null === i2 ? this._manualStat(e3, t5, n9, l2) : { calculated: false } : u2;
  }
  async _canDoAggregates(e3, t5, s4, i2, r2) {
    return null === this._whereClauseFunction && (null !== r2 ? null !== this._whereclause && (r2 = g3(this._whereclause, r2)) : r2 = this._whereclause, null !== this._parent && this._parent._canDoAggregates(e3, t5, s4, i2, r2));
  }
  async _getAggregatePagesDataSourceDefinition(s4, i2, r2, n9, l2, h2, u2) {
    if (null === this._parent) throw new s2(t2.NeverReach);
    return null !== l2 ? null !== this._whereclause && (l2 = g3(this._whereclause, l2)) : l2 = this._whereclause, this._parent._getAggregatePagesDataSourceDefinition(s4, i2, r2, n9, l2, h2, u2);
  }
  static registerAction() {
    C._featuresetFunctions.filter = function(e3) {
      if ("function" == typeof e3) return new _c({ parentfeatureset: this, whereclause: e3 });
      let t5 = null;
      return e3 instanceof Z && (t5 = e3), new _c({ parentfeatureset: this, whereclause: t5 });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Adapted.js
var I2 = class {
  constructor(e3) {
    this.field = e3, this.sqlRewritable = false;
  }
  postInitialization(e3, t5) {
  }
};
var k2 = class extends I2 {
  constructor(e3) {
    super(e3), this.sqlRewritable = true;
  }
  extractValue(e3) {
    return e3.attributes[this.field.name];
  }
  rewriteSql(e3) {
    return { rewritten: this.sqlRewritable, where: e3 };
  }
};
var b2 = class extends I2 {
  constructor(e3, t5, r2) {
    super(y2(e3)), this.originalField = e3, this.sqlRewritable = true, this.field.name = t5, this.field.alias = r2;
  }
  rewriteSql(e3, t5) {
    return { rewritten: this.sqlRewritable, where: p(e3, this.field.name, this.originalField.name, t5.getFieldsIndex()) };
  }
  extractValue(e3) {
    return e3.attributes[this.originalField.name];
  }
};
var B = class _B extends I2 {
  constructor(e3, t5, r2) {
    super(e3), this.codefield = t5, this.lkp = r2, this.reverseLkp = {};
    for (const s4 in r2) this.reverseLkp[r2[s4]] = s4;
    this.sqlRewritable = true;
  }
  rewriteSql(e3, t5) {
    const r2 = this.evaluateNodeToWhereClause(e3.parseTree, l.Standardised, this.field.name, this.codefield instanceof Z ? f4(this.codefield, l.Standardised) : this.codefield, e3.parameters);
    return r2.includes(_B.BADNESS) ? { rewritten: false, where: e3 } : { rewritten: this.sqlRewritable, where: Z.create(r2, { fieldsIndex: t5._parent.getFieldsIndex(), timeZone: t5.dateFieldsTimeZoneDefaultUTC }) };
  }
  evaluateNodeToWhereClause(e3, t5, r2 = null, s4 = null, a6) {
    let i2, l2, n9, p2;
    switch (e3.type) {
      case "interval":
        return F2(this.evaluateNodeToWhereClause(e3.value, t5, r2, s4, a6), e3.qualifier, e3.op);
      case "case-expression": {
        let s5 = " CASE ";
        "simple" === e3.format && (s5 += this.evaluateNodeToWhereClause(e3.operand, t5, r2, _B.BADNESS, a6));
        for (let i3 = 0; i3 < e3.clauses.length; i3++) s5 += " WHEN " + this.evaluateNodeToWhereClause(e3.clauses[i3].operand, t5, r2, _B.BADNESS, a6) + " THEN " + this.evaluateNodeToWhereClause(e3.clauses[i3].value, t5, r2, _B.BADNESS, a6);
        return null !== e3.else && (s5 += " ELSE " + this.evaluateNodeToWhereClause(e3.else, t5, r2, _B.BADNESS, a6)), s5 += " END ", s5;
      }
      case "parameter": {
        const r3 = a6[e3.value.toLowerCase()];
        if ("string" == typeof r3) return "'" + r3.toString().replaceAll("'", "''") + "'";
        if (f2(r3)) return I(r3, t5);
        if (d(r3)) return I(r3, t5);
        if (F(r3)) return A(r3, t5);
        if (g2(r3)) return S3(r3, t5);
        if (T(r3)) return E(r3, t5);
        if (Array.isArray(r3)) {
          const e4 = [];
          for (let s5 = 0; s5 < r3.length; s5++) "string" == typeof r3[s5] ? e4.push("'" + r3[s5].toString().replaceAll("'", "''") + "'") : f2(r3[s5]) || d(r3[s5]) ? e4.push(I(r3[s5], t5)) : F(r3[s5]) ? e4.push(A(r3[s5], t5)) : g2(r3[s5]) ? e4.push(S3(r3[s5], t5)) : T(r3[s5]) ? e4.push(E(r3[s5], t5)) : e4.push(r3[s5].toString());
          return e4;
        }
        return r3.toString();
      }
      case "expression-list":
        l2 = [];
        for (const i3 of e3.value) l2.push(this.evaluateNodeToWhereClause(i3, t5, r2, s4, a6));
        return l2;
      case "unary-expression":
        return " ( NOT " + this.evaluateNodeToWhereClause(e3.expr, t5, r2, _B.BADNESS, a6) + " ) ";
      case "binary-expression":
        switch (e3.operator) {
          case "AND":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " AND " + this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6) + ") ";
          case "OR":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " OR " + this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6) + ") ";
          case "IS":
            if ("null" !== e3.right.type) throw new n4(a.UnsupportedIsRhs);
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IS NULL )";
          case "ISNOT":
            if ("null" !== e3.right.type) throw new n4(a.UnsupportedIsRhs);
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IS NOT NULL )";
          case "IN":
            if (i2 = [], "expression-list" === e3.right.type) {
              if ("column-reference" === e3.left.type && e3.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i3 = [];
                let l3 = true;
                for (const t6 of e3.right.value) {
                  if ("string" !== t6.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t6.value]) {
                    l3 = false;
                    break;
                  }
                  i3.push(this.lkp[t6.value].toString());
                }
                if (l3) return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IN (" + i3.join(",") + ")) ";
              }
              return i2 = this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6), " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IN (" + i2.join(",") + ")) ";
            }
            return p2 = this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6), Array.isArray(p2) ? " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IN (" + p2.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " IN (" + p2 + ")) ";
          case "NOT IN":
            if (i2 = [], "expression-list" === e3.right.type) {
              if ("column-reference" === e3.left.type && e3.left.column.toUpperCase() === this.field.name.toUpperCase()) {
                const i3 = [];
                let l3 = true;
                for (const t6 of e3.right.value) {
                  if ("string" !== t6.type) {
                    l3 = false;
                    break;
                  }
                  if (void 0 === this.lkp[t6.value]) {
                    l3 = false;
                    break;
                  }
                  i3.push(this.lkp[t6.value].toString());
                }
                if (l3) return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " NOT IN (" + i3.join(",") + ")) ";
              }
              return i2 = this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6), " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " NOT IN (" + i2.join(",") + ")) ";
            }
            return p2 = this.evaluateNodeToWhereClause(e3.right, t5, r2, s4, a6), Array.isArray(p2) ? " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " NOT IN (" + p2.join(",") + ")) " : " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, s4, a6) + " NOT IN (" + p2 + ")) ";
          case "BETWEEN":
            return n9 = this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6), " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " BETWEEN " + n9[0] + " AND " + n9[1] + " ) ";
          case "NOTBETWEEN":
            return n9 = this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6), " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " NOT BETWEEN " + n9[0] + " AND " + n9[1] + " ) ";
          case "LIKE":
            return "" !== e3.escape ? " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " LIKE " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + " ESCAPE '" + e3.escape + "') " : " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " LIKE " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + ") ";
          case "NOT LIKE":
            return "" !== e3.escape ? " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " NOT LIKE " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + " ESCAPE '" + e3.escape + "') " : " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " NOT LIKE " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + ") ";
          case "<>":
          case "=":
            if ("column-reference" === e3.left.type && "string" === e3.right.type) {
              if (e3.left.column.toUpperCase() === this.field.name.toUpperCase() && void 0 !== this.lkp[e3.right.value.toString()]) return " (" + s4 + " " + e3.operator + " " + this.lkp[e3.right.value.toString()].toString() + ") ";
            } else if ("column-reference" === e3.right.type && "string" === e3.left.type && e3.right.column.toUpperCase() === this.field.name.toUpperCase()) return " (" + this.lkp[e3.right.value.toString()].toString() + " " + e3.operator + " " + s4 + ") ";
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " " + e3.operator + " " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + ") ";
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "*":
          case "-":
          case "+":
          case "/":
          case "||":
            return " (" + this.evaluateNodeToWhereClause(e3.left, t5, r2, _B.BADNESS, a6) + " " + e3.operator + " " + this.evaluateNodeToWhereClause(e3.right, t5, r2, _B.BADNESS, a6) + ") ";
        }
      case "null":
        return "null";
      case "boolean":
        return true === e3.value ? "1" : "0";
      case "string":
        return "'" + e3.value.toString().replaceAll("'", "''") + "'";
      case "timestamp":
        return `timestamp '${e3.value}'`;
      case "date":
        return `date '${e3.value}'`;
      case "time":
        return `time '${e3.value}'`;
      case "number":
        return e3.value.toString();
      case "current-time":
        return L(e3.mode, t5);
      case "current-user":
        return "CURRENT_USER";
      case "column-reference":
        return r2 && r2.toLowerCase() === e3.column.toLowerCase() ? "(" + s4 + ")" : h(e3.column);
      case "data-type":
        return e3.value;
      case "function": {
        const s5 = this.evaluateNodeToWhereClause(e3.args, t5, r2, _B.BADNESS, a6);
        return T2(e3.name, s5, t5);
      }
    }
    throw new n4(a.UnsupportedSyntax, { node: e3.type });
  }
  extractValue(e3) {
    return this.codefield instanceof Z ? this.reverseLkp[Z.convertValueToStorageFormat(this.codefield.calculateValueCompiled(e3))] : this.reverseLkp[e3.attributes[this.codefield]];
  }
};
B.BADNESS = "_!!!_BAD_LKP_!!!!";
var L2 = class extends I2 {
  constructor(e3, t5) {
    super(e3), this._sql = t5;
  }
  rewriteSql(e3, t5) {
    return { rewritten: true, where: p(e3, this.field.name, f4(this._sql, l.Standardised), t5.getFieldsIndex()) };
  }
  extractValue(e3) {
    return Z.convertValueToStorageFormat(this._sql.calculateValueCompiled(e3), this.field.type);
  }
};
var R = class extends C {
  static findField(e3, t5) {
    for (const r2 of e3) if (r2.name.toLowerCase() === t5.toString().toLowerCase()) return r2;
    return null;
  }
  constructor(e3) {
    super(e3), this._calcFunc = null, this.declaredClass = "esri.arcade.featureset.actions.Adapted", this.adaptedFields = [], this._extraFilter = null, this._extraFilter = e3.extraFilter, this._parent = e3.parentfeatureset, this._maxProcessing = 30, this.adaptedFields = e3.adaptedFields;
  }
  _initialiseFeatureSet() {
    null !== this._parent ? (this.geometryType = this._parent.geometryType, this.objectIdField = this._parent.objectIdField, this.globalIdField = this._parent.globalIdField, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = this._parent.typeIdField, this.types = this._parent.types) : (this.spatialReference = new g({ wkid: 4326 }), this.objectIdField = "", this.globalIdField = "", this.geometryType = N.point, this.typeIdField = "", this.types = null, this.subtypeField = null, this.subtypes = null), this.fields = [];
    for (const e3 of this.adaptedFields) e3.postInitialization(this, this._parent), this.fields.push(e3.field);
  }
  async _getSet(e3) {
    var _a;
    if (null === this._wset) {
      await this._ensureLoaded();
      let t5 = null;
      return t5 = this._extraFilter ? await this._getFilteredSet("", null, null, null, e3) : await ((_a = this._parent) == null ? void 0 : _a._getSet(e3)), this._checkCancelled(e3), n(t5), this._wset = new t3(t5._candidates.slice(), t5._known.slice(), t5._ordered, this._clonePageDefinition(t5.pagesDefinition)), this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet(e3) {
    return this._parent._isInFeatureSet(e3);
  }
  async _getFeatures(r2, s4, a6, l2) {
    var _a, _b;
    const n9 = [];
    -1 !== s4 && void 0 === this._featureCache[s4] && n9.push(s4);
    const o = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(r2, o)) return await this._expandPagedSet(r2, o, 0, 0, l2), this._getFeatures(r2, s4, a6, l2);
    let u2 = 0;
    for (let e3 = r2._lastFetchedIndex; e3 < r2._known.length && (u2++, u2 <= a6 && (r2._lastFetchedIndex += 1), !(void 0 === this._featureCache[r2._known[e3]] && (r2._known[e3] !== s4 && n9.push(r2._known[e3]), n9.length >= o))); e3++) ;
    if (0 === n9.length) return "success";
    r2 = new t3([], n9, r2._ordered, null);
    const h2 = Math.min(n9.length, a6);
    await ((_a = this._parent) == null ? void 0 : _a._getFeatures(r2, -1, h2, l2)), this._checkCancelled(l2);
    const c5 = [];
    for (let e3 = 0; e3 < h2; e3++) {
      const t5 = (_b = this._parent) == null ? void 0 : _b._featureFromCache(n9[e3]);
      void 0 !== t5 && c5.push({ geometry: t5.geometry, attributes: t5.attributes, id: n9[e3] });
    }
    for (const i2 of c5) {
      const r3 = [];
      for (const e3 of this.adaptedFields) r3[e3.field.name] = e3.extractValue(i2);
      this._featureCache[i2.id] = new d2({ attributes: r3, geometry: c2(i2.geometry) });
    }
    return "success";
  }
  async _fetchAndRefineFeatures() {
    throw new s2(t2.NeverReach);
  }
  async _getFilteredSet(e3, t5, r2, s4, a6) {
    let l2 = false;
    const n9 = this._reformulateWithoutAdaptions(r2);
    l2 = n9.cannot, r2 = n9.where;
    let o = false;
    if (null !== s4) {
      o = true;
      const e4 = [];
      for (const t6 of this.adaptedFields) if (!(t6 instanceof k2) && true === s4.scanForField(t6.field.name)) {
        if (!(t6 instanceof b2)) {
          s4 = null, o = false;
          break;
        }
        e4.push({ field: t6.field.name, newfield: t6.originalField.name });
      }
      s4 && e4.length > 0 && (s4 = s4.replaceFields(e4));
    }
    null !== r2 ? null !== this._extraFilter && (r2 = g3(this._extraFilter, r2)) : r2 = this._extraFilter, await this._ensureLoaded();
    const u2 = await this._parent._getFilteredSet(e3, t5, r2, s4, a6);
    let h2;
    return this._checkCancelled(a6), h2 = true === l2 ? new t3(u2._candidates.slice().concat(u2._known.slice()), [], true === o && u2._ordered, this._clonePageDefinition(u2.pagesDefinition)) : new t3(u2._candidates.slice(), u2._known.slice(), true === o && u2._ordered, this._clonePageDefinition(u2.pagesDefinition)), h2;
  }
  _reformulateWithoutAdaptions(e3) {
    const t5 = { cannot: false, where: e3 };
    if (null !== e3) {
      for (const r2 of this.adaptedFields) if (true === D2(e3, r2.field.name)) {
        const s4 = r2.rewriteSql(e3, this);
        if (true !== s4.rewritten) {
          t5.cannot = true, t5.where = null;
          break;
        }
        t5.where = s4.where;
      }
    }
    return t5;
  }
  async _stat(e3, t5, r2, s4, a6, i2, l2) {
    let n9 = false, o = this._reformulateWithoutAdaptions(t5);
    if (n9 = o.cannot, t5 = o.where, o = this._reformulateWithoutAdaptions(a6), n9 = n9 || o.cannot, null !== (a6 = o.where) ? null !== this._extraFilter && (a6 = g3(this._extraFilter, a6)) : a6 = this._extraFilter, true === n9) return null === a6 && "" === r2 && null === s4 ? this._manualStat(e3, t5, i2, l2) : { calculated: false };
    const u2 = await this._parent._stat(e3, t5, r2, s4, a6, i2, l2);
    return false === u2.calculated ? null === a6 && "" === r2 && null === s4 ? this._manualStat(e3, t5, i2, l2) : { calculated: false } : u2;
  }
  async _canDoAggregates(e3, t5, r2, s4, a6) {
    if (null === this._parent) return false;
    for (let n9 = 0; n9 < e3.length; n9++) for (const t6 of this.adaptedFields) if (e3[n9].toLowerCase() === t6.field.name.toLowerCase() && !(t6 instanceof k2)) return false;
    const i2 = [];
    for (let n9 = 0; n9 < t5.length; n9++) {
      const e4 = t5[n9];
      if (null !== e4.workingexpr) {
        const t6 = this._reformulateWithoutAdaptions(e4.workingexpr);
        if (t6.cannot) return false;
        const r3 = e4.clone();
        r3.workingexpr = t6.where, i2.push(r3);
      } else i2.push(e4);
    }
    const l2 = this._reformulateWithoutAdaptions(a6);
    return !l2.cannot && (null !== (a6 = l2.where) ? null !== this._extraFilter && (a6 = g3(this._extraFilter, a6)) : a6 = this._extraFilter, this._parent._canDoAggregates(e3, i2, r2, s4, a6));
  }
  async _getAggregatePagesDataSourceDefinition(e3, t5, a6, i2, l2, n9, o) {
    if (null === this._parent) throw new s2(t2.NeverReach);
    const u2 = [];
    for (let c5 = 0; c5 < t5.length; c5++) {
      const e4 = t5[c5];
      if (null !== e4.workingexpr) {
        const t6 = this._reformulateWithoutAdaptions(e4.workingexpr);
        if (t6.cannot) throw new s2(t2.NeverReach);
        const a7 = e4.clone();
        a7.workingexpr = t6.where, u2.push(a7);
      } else u2.push(e4);
    }
    const h2 = this._reformulateWithoutAdaptions(l2);
    if (h2.cannot) throw new s2(t2.NeverReach);
    return null !== (l2 = h2.where) ? null !== this._extraFilter && (l2 = g3(this._extraFilter, l2)) : l2 = this._extraFilter, this._parent._getAggregatePagesDataSourceDefinition(e3, u2, a6, i2, l2, n9, o);
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/OrderbyClause.js
function t4(t5, e3) {
  return t5 === e3 ? 0 : null === t5 ? -1 : null === e3 ? 1 : t5 < e3 ? -1 : 1;
}
var e2 = class _e2 {
  constructor(t5) {
    const e3 = t5.split(",");
    this._fields = [], this._directions = [];
    for (let s4 = 0; s4 < e3.length; s4++) {
      const t6 = e3[s4].match(/\S+/g);
      this._fields.push(t6[0]), 2 === t6.length ? "asc" === t6[1].toLowerCase() ? this._directions.push(1) : this._directions.push(0) : this._directions.push(1);
    }
  }
  constructClause() {
    let t5 = "";
    for (let e3 = 0; e3 < this._fields.length; e3++) 0 !== e3 && (t5 += ","), t5 += this._fields[e3], 1 === this._directions[e3] ? t5 += " ASC" : t5 += " DESC";
    return t5;
  }
  order(e3) {
    e3.sort((e4, s4) => {
      for (let i2 = 0; i2 < this._fields.length; i2++) {
        const r2 = this.featureValue(e4.feature, this._fields[i2], i2), l2 = this.featureValue(s4.feature, this._fields[i2], i2);
        let o = 0;
        if (o = 1 === this._directions[i2] ? t4(r2, l2) : -1 * t4(r2, l2), 0 !== o) return o;
      }
      return 0;
    });
  }
  scanForField(t5) {
    for (let e3 = 0; e3 < this._fields.length; e3++) if (this._fields[e3].toLowerCase().trim() === t5.toLowerCase().trim()) return true;
    return false;
  }
  replaceFields(t5) {
    let s4 = "";
    for (let e3 = 0; e3 < this._fields.length; e3++) {
      0 !== e3 && (s4 += ",");
      let i2 = this._fields[e3];
      for (const e4 of t5) if (i2.toLowerCase() === e4.field.toLowerCase()) {
        i2 = e4.newfield;
        break;
      }
      s4 += i2, 1 === this._directions[e3] ? s4 += " ASC" : s4 += " DESC";
    }
    return new _e2(s4);
  }
  featureValue(t5, e3, s4) {
    const i2 = t5.attributes[e3];
    if (void 0 !== i2) return i2;
    for (const r2 in t5.attributes) if (e3.toLowerCase() === r2.toLowerCase()) return this._fields[s4] = r2, t5.attributes[r2];
    return null;
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/OrderBy.js
var a3 = class _a extends C {
  constructor(e3) {
    super(e3), this._orderbyclause = null, this.declaredClass = "esri.arcade.featureset.actions.OrderBy", this._maxProcessing = 100, this._orderbyclause = e3.orderbyclause, this._parent = e3.parentfeatureset;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t5 = await this._getFilteredSet("", null, null, this._orderbyclause, e3);
      return this._checkCancelled(e3), this._wset = t5, this._wset;
    }
    return this._wset;
  }
  async manualOrderSet(e3, t5) {
    var _a2;
    const r2 = await this.getIdColumnDictionary(e3, [], -1, t5);
    (_a2 = this._orderbyclause) == null ? void 0 : _a2.order(r2);
    const n9 = new t3([], [], true, null);
    for (let s4 = 0; s4 < r2.length; s4++) n9._known.push(r2[s4].id);
    return n9;
  }
  async getIdColumnDictionary(t5, r2, n9, s4) {
    if (n9 < t5._known.length - 1) {
      const i2 = this._maxQueryRate();
      if ("GETPAGES" === t5._known[n9 + 1]) return await _e(this._parent._expandPagedSet(t5, i2, 0, 0, s4)), this.getIdColumnDictionary(t5, r2, n9, s4);
      let a6 = n9 + 1;
      const o = [];
      for (; a6 < t5._known.length && "GETPAGES" !== t5._known[a6]; ) o.push(t5._known[a6]), a6++;
      n9 += o.length;
      const u2 = await _e(this._parent._getFeatureBatch(o, s4));
      this._checkCancelled(s4);
      for (const e3 of u2) r2.push({ id: e3.attributes[this.objectIdField], feature: e3 });
      return this.getIdColumnDictionary(t5, r2, n9, s4);
    }
    return t5._candidates.length > 0 ? (await _e(this._refineSetBlock(t5, this._maxProcessingRate(), s4)), this._checkCancelled(s4), this.getIdColumnDictionary(t5, r2, n9, s4)) : r2;
  }
  _isInFeatureSet(e3) {
    return this._parent._isInFeatureSet(e3);
  }
  _getFeatures(e3, t5, r2, n9) {
    return this._parent._getFeatures(e3, t5, r2, n9);
  }
  _featureFromCache(e3) {
    if (void 0 === this._featureCache[e3]) {
      const t5 = this._parent._featureFromCache(e3);
      if (void 0 === t5) return;
      return null === t5 ? null : (this._featureCache[e3] = t5, t5);
    }
    return this._featureCache[e3];
  }
  async _fetchAndRefineFeatures() {
    throw new s2(t2.NeverReach);
  }
  async _getFilteredSet(e3, t5, r2, n9, i2) {
    await this._ensureLoaded();
    const a6 = await this._parent._getFilteredSet(e3, t5, r2, null === n9 ? this._orderbyclause : n9, i2);
    this._checkCancelled(i2);
    const o = new t3(a6._candidates.slice(), a6._known.slice(), a6._ordered, this._clonePageDefinition(a6.pagesDefinition));
    let u2 = true;
    if (a6._candidates.length > 0 && (u2 = false), false === o._ordered) {
      let e4 = await this.manualOrderSet(o, i2);
      return false === u2 && (null === t5 && null === r2 || (e4 = new t3(e4._candidates.slice().concat(e4._known.slice()), [], e4._ordered, this._clonePageDefinition(e4.pagesDefinition)))), e4;
    }
    return o;
  }
  static registerAction() {
    C._featuresetFunctions.orderBy = function(e3) {
      return "" === e3 ? this : new _a({ parentfeatureset: this, orderbyclause: new e2(e3) });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/support/StatsField.js
function s3(s4) {
  if ("function" === s4.parseTree.type) {
    if (0 === s4.parseTree.args.value.length) return { name: s4.parseTree.name, expr: null };
    if (s4.parseTree.args.value.length > 1) throw new n4(a.MissingStatisticParameters);
    const a6 = Z.create(m3(s4.parseTree.args.value[0], l.Standardised, s4.parameters), { fieldsIndex: s4.fieldsIndex, timeZone: s4.timeZone, currentUser: s4.currentUser });
    return { name: s4.parseTree.name, expr: a6 };
  }
  return null;
}
var a4 = class _a {
  constructor() {
    this.field = "", this.tofieldname = "", this.typeofstat = "MIN", this.workingexpr = null;
  }
  clone() {
    const e3 = new _a();
    return e3.field = this.field, e3.tofieldname = this.tofieldname, e3.typeofstat = this.typeofstat, e3.workingexpr = this.workingexpr, e3;
  }
  static parseStatField(e3, t5, o, l2) {
    const f7 = new _a();
    f7.field = e3;
    const u2 = Z.create(t5, { fieldsIndex: o, timeZone: l2 }), p2 = s3(u2);
    if (null === p2) throw new n4(a.UnsupportedSqlFunction, { function: "" });
    const c5 = p2.name.toUpperCase().trim();
    if ("MIN" === c5) {
      if (f7.typeofstat = "MIN", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "min" });
    } else if ("MAX" === c5) {
      if (f7.typeofstat = "MAX", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "max" });
    } else if ("COUNT" === c5) f7.typeofstat = "COUNT", f7.workingexpr = p2.expr;
    else if ("STDEV" === c5) {
      if (f7.typeofstat = "STDDEV", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "stdev" });
    } else if ("SUM" === c5) {
      if (f7.typeofstat = "SUM", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "sum" });
    } else if ("MEAN" === c5) {
      if (f7.typeofstat = "AVG", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: c5 });
    } else if ("AVG" === c5) {
      if (f7.typeofstat = "AVG", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "avg" });
    } else {
      if ("VAR" !== c5) throw new n4(a.UnsupportedSqlFunction, { function: c5 });
      if (f7.typeofstat = "VAR", f7.workingexpr = p2.expr, null === u2) throw new n4(a.InvalidFunctionParameters, { function: "var" });
    }
    return f7;
  }
  toStatisticsName() {
    switch (this.typeofstat.toUpperCase()) {
      case "MIN":
        return "min";
      case "MAX":
        return "max";
      case "SUM":
        return "sum";
      case "COUNT":
      default:
        return "count";
      case "VAR":
        return "var";
      case "STDDEV":
        return "stddev";
      case "AVG":
        return "avg";
    }
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/GroupBy.js
function G(e3) {
  if (!e3) return "COUNT";
  switch (e3.toLowerCase()) {
    case "max":
      return "MAX";
    case "var":
    case "variance":
      return "VAR";
    case "avg":
    case "average":
    case "mean":
      return "AVG";
    case "min":
      return "MIN";
    case "sum":
      return "SUM";
    case "stdev":
    case "stddev":
      return "STDDEV";
    case "count":
      return "COUNT";
  }
  return "COUNT";
}
var O2 = class _O extends C {
  constructor(e3) {
    super(e3), this._decodedStatsfield = [], this._decodedGroupbyfield = [], this._candosimplegroupby = true, this.phsyicalgroupbyfields = [], this.objectIdField = "ROW__ID", this._internalObjectIdField = "ROW__ID", this._adaptedFields = [], this.declaredClass = "esri.arcade.featureset.actions.Aggregate", this._uniqueIds = 1, this._maxQuery = 10, this._maxProcessing = 10, this._parent = e3.parentfeatureset, this._config = e3;
  }
  isTable() {
    return true;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      const t5 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t5, this._wset;
    }
    return this._wset;
  }
  _isInFeatureSet() {
    return s.InFeatureSet;
  }
  _nextUniqueName(e3) {
    for (; 1 === e3["T" + this._uniqueIds.toString()]; ) this._uniqueIds++;
    const t5 = "T" + this._uniqueIds.toString();
    return e3[t5] = 1, t5;
  }
  _convertToEsriFieldType(e3) {
    return e3;
  }
  _initialiseFeatureSet() {
    const e3 = {};
    let t5 = false, n9 = 1;
    const r2 = this._parent ? this._parent.getFieldsIndex() : new Z2([]);
    for (this.objectIdField = "ROW__ID", this.globalIdField = ""; false === t5; ) {
      let e4 = false;
      for (let t6 = 0; t6 < this._config.groupbyfields.length; t6++) if (this._config.groupbyfields[t6].name.toLowerCase() === this.objectIdField.toLowerCase()) {
        e4 = true;
        break;
      }
      if (false === e4) {
        for (let t6 = 0; t6 < this._config.statsfields.length; t6++) if (this._config.statsfields[t6].name.toLowerCase() === this.objectIdField.toLowerCase()) {
          e4 = true;
          break;
        }
      }
      false === e4 ? t5 = true : (this.objectIdField = "ROW__ID" + n9.toString(), n9++);
    }
    for (const i2 of this._config.statsfields) {
      const e4 = new a4();
      e4.field = i2.name, e4.tofieldname = i2.name, e4.workingexpr = i2.expression instanceof Z ? i2.expression : Z.create(i2.expression, { fieldsIndex: r2, timeZone: this.dateFieldsTimeZoneDefaultUTC }), e4.typeofstat = G(i2.statistic), this._decodedStatsfield.push(e4);
    }
    this._decodedGroupbyfield = [];
    for (const i2 of this._config.groupbyfields) {
      const e4 = { name: i2.name, singlefield: null, tofieldname: i2.name, expression: i2.expression instanceof Z ? i2.expression : Z.create(i2.expression, { fieldsIndex: r2, timeZone: this.dateFieldsTimeZoneDefaultUTC }), sqlType: null };
      this._decodedGroupbyfield.push(e4);
    }
    if (null !== this._parent) {
      this.geometryType = this._parent.geometryType, this.spatialReference = this._parent.spatialReference, this.hasM = this._parent.hasM, this.hasZ = this._parent.hasZ, this.typeIdField = "";
      for (const t6 of this._parent.fields) e3[t6.name.toUpperCase()] = 1;
      this.types = null, this.subtypes = null, this.subtypeField = "";
    } else this.geometryType = N.point, this.typeIdField = "", this.types = null, this.subtypes = null, this.subtypeField = "", this.spatialReference = new g({ wkid: 4326 });
    this.fields = [];
    const a6 = new a4();
    a6.field = this._nextUniqueName(e3), a6.tofieldname = this.objectIdField, a6.workingexpr = Z.create(this._parent.objectIdField, { fieldsIndex: this._parent.getFieldsIndex(), timeZone: this.dateFieldsTimeZoneDefaultUTC }), a6.typeofstat = "MIN", this._decodedStatsfield.push(a6);
    for (const s4 of this._decodedGroupbyfield) {
      const t6 = new y();
      if (s4.name = this._nextUniqueName(e3), t6.name = s4.tofieldname, t6.alias = t6.name, O(s4.expression)) {
        const e4 = this._parent.getField(f4(s4.expression, l.Standardised));
        if (!e4) throw new s2(t2.AggregationFieldNotFound);
        s4.name = e4.name, s4.singlefield = e4.name, this.phsyicalgroupbyfields.push(e4.name), t6.type = e4.type, s4.sqlType = e4.type;
      } else {
        t6.type = this._convertToEsriFieldType(w(s4.expression, this._parent.fields));
        const e4 = new y();
        e4.name = s4.name, e4.alias = e4.name, this.phsyicalgroupbyfields.push(s4.name), this._adaptedFields.push(new L2(e4, s4.expression)), this._candosimplegroupby = false, s4.sqlType = t6.type;
      }
      this.fields.push(t6);
    }
    if (this._adaptedFields.length > 0) for (const i2 of this._parent.fields) this._adaptedFields.push(new k2(i2));
    for (let i2 = 0; i2 < this._decodedStatsfield.length; i2++) {
      const t6 = new y();
      let s4 = null;
      const n10 = this._decodedStatsfield[i2];
      n10.field = this._nextUniqueName(e3), n10.tofieldname === this.objectIdField && (this._internalObjectIdField = n10.field), t6.name = n10.tofieldname, t6.alias = t6.name;
      const r3 = null !== n10.workingexpr && O(n10.workingexpr) ? f4(n10.workingexpr, l.Standardised) : "";
      switch (this._decodedStatsfield[i2].typeofstat) {
        case "SUM":
          if ("" !== r3) {
            if (s4 = this._parent.getField(r3), !s4) throw new s2(t2.AggregationFieldNotFound);
            t6.type = s4.type;
          } else t6.type = "double";
          break;
        case "MIN":
        case "MAX":
          if ("" !== r3) {
            if (s4 = this._parent.getField(r3), !s4) throw new s2(t2.AggregationFieldNotFound);
            t6.type = s4.type;
          } else t6.type = "double";
          break;
        case "COUNT":
          t6.type = "integer";
          break;
        case "STDDEV":
        case "VAR":
        case "AVG":
          if ("" !== r3 && (s4 = this._parent.getField(r3), !s4)) throw new s2(t2.AggregationFieldNotFound);
          t6.type = "double";
      }
      this.fields.push(t6);
    }
  }
  async _canDoAggregates() {
    return false;
  }
  async _getFeatures(e3, t5, i2, s4) {
    -1 !== t5 && this._featureCache[t5];
    const n9 = this._maxQuery;
    return true === this._checkIfNeedToExpandKnownPage(e3, n9) ? (await this._expandPagedSet(e3, n9, 0, 0, s4), this._getFeatures(e3, t5, i2, s4)) : "success";
  }
  async _getFilteredSet(e3, t5, i2, s4, o) {
    if ("" !== e3) return new t3([], [], true, null);
    let l2 = null;
    const d5 = { ordered: false, nowhereclause: false };
    if (await this._ensureLoaded(), null !== i2) {
      for (let n9 = 0; n9 < this._decodedStatsfield.length; n9++) if (true === D2(i2, this._decodedStatsfield[n9].tofieldname)) {
        d5.nowhereclause = true, i2 = null;
        break;
      }
    }
    if (null !== s4) {
      d5.ordered = true;
      for (let e4 = 0; e4 < this._decodedStatsfield.length; e4++) if (true === s4.scanForField(this._decodedStatsfield[e4].tofieldname)) {
        s4 = null, d5.ordered = false;
        break;
      }
      if (null !== s4) {
        for (const e4 of this._decodedGroupbyfield) if (null === e4.singlefield && true === s4.scanForField(e4.tofieldname)) {
          s4 = null, d5.ordered = false;
          break;
        }
      }
    }
    if (false !== this._candosimplegroupby && await this._parent._canDoAggregates(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, null)) {
      let e4 = null;
      i2 && (e4 = this._reformulateWhereClauseWithoutGroupByFields(i2));
      let t6 = null;
      s4 && (t6 = this._reformulateOrderClauseWithoutGroupByFields(s4));
      const n9 = await this._parent._getAggregatePagesDataSourceDefinition(this.phsyicalgroupbyfields, this._decodedStatsfield, "", null, e4, t6, this._internalObjectIdField);
      return this._checkCancelled(o), l2 = true === d5.nowhereclause ? new t3(n9._candidates.slice().concat(n9._known.slice()), [], true === d5.ordered && n9._ordered, this._clonePageDefinition(n9.pagesDefinition)) : new t3(n9._candidates.slice(), n9._known.slice(), true === d5.ordered && n9._ordered, this._clonePageDefinition(n9.pagesDefinition)), l2;
    }
    let c5 = this._parent;
    if (this._adaptedFields.length > 0 && (c5 = new R({ parentfeatureset: this._parent, adaptedFields: this._adaptedFields, extraFilter: null })), true === d5.nowhereclause) l2 = new t3(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new a3({ parentfeatureset: c5, orderbyclause: new e2(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    else {
      let e4 = c5;
      if (null !== i2) {
        let t6 = null;
        i2 && (t6 = this._reformulateWhereClauseWithoutGroupByFields(i2)), e4 = new c4({ parentfeatureset: e4, whereclause: t6 });
      }
      l2 = new t3(["GETPAGES"], [], false, { aggregatefeaturesetpagedefinition: true, resultOffset: 0, resultRecordCount: this._maxQuery, internal: { fullyResolved: false, workingItem: null, type: "manual", iterator: null, set: [], subfeatureset: new a3({ parentfeatureset: e4, orderbyclause: new e2(this.phsyicalgroupbyfields.join(",") + "," + this._parent.objectIdField + " ASC") }) } });
    }
    return l2;
  }
  _reformulateWhereClauseWithoutStatsFields(e3) {
    for (const t5 of this._decodedStatsfield) e3 = p(e3, t5.tofieldname, f4(t5.workingexpr, l.Standardised), this._parent.getFieldsIndex());
    return e3;
  }
  _reformulateWhereClauseWithoutGroupByFields(e3) {
    for (const t5 of this._decodedGroupbyfield) t5.tofieldname !== t5.name && (e3 = p(e3, t5.tofieldname, f4(t5.expression, l.Standardised), this._parent.getFieldsIndex()));
    return e3;
  }
  _reformulateOrderClauseWithoutGroupByFields(e3) {
    const t5 = [];
    for (const i2 of this._decodedGroupbyfield) i2.tofieldname !== i2.name && t5.push({ field: i2.tofieldname, newfield: i2.name });
    return t5.length > 0 ? e3.replaceFields(t5) : e3;
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true === e3.aggregatefeaturesetpagedefinition ? { aggregatefeaturesetpagedefinition: true, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, internal: e3.internal } : this._parent._clonePageDefinition(e3);
  }
  async _refineSetBlock(e3, t5, i2) {
    if (true === this._checkIfNeedToExpandCandidatePage(e3, this._maxQuery)) return await this._expandPagedSet(e3, this._maxQuery, 0, 0, i2), this._refineSetBlock(e3, t5, i2);
    this._checkCancelled(i2);
    const s4 = e3._candidates.length;
    this._refineKnowns(e3, t5);
    e3._candidates.length;
    return e3._candidates.length, e3;
  }
  _expandPagedSet(e3, t5, i2, s4, n9) {
    return this._expandPagedSetFeatureSet(e3, t5, i2, s4, n9);
  }
  async _getPhysicalPage(t5, i2, s4) {
    if (true === t5.pagesDefinition.aggregatefeaturesetpagedefinition) return this._sequentialGetPhysicalItem(t5, t5.pagesDefinition.resultRecordCount, s4, []);
    const n9 = await this._getAgregagtePhysicalPage(t5, i2, s4);
    for (const r2 of n9) {
      const t6 = { geometry: r2.geometry, attributes: {} }, i3 = {};
      for (const e3 in r2.attributes) i3[e3.toLowerCase()] = r2.attributes[e3];
      for (const e3 of this._decodedGroupbyfield) t6.attributes[e3.tofieldname] = i3[e3.name.toLowerCase()];
      for (const e3 of this._decodedStatsfield) t6.attributes[e3.tofieldname] = i3[e3.field.toLowerCase()];
      this._featureCache[t6.attributes[this.objectIdField]] = new d2(t6);
    }
    return n9.length;
  }
  _sequentialGetPhysicalItem(e3, t5, i2, s4) {
    return new Promise((n9, r2) => {
      null === e3.pagesDefinition.internal.iterator && (e3.pagesDefinition.internal.iterator = e3.pagesDefinition.internal.subfeatureset.iterator(i2)), true === e3.pagesDefinition.internal.fullyResolved || 0 === t5 ? n9(s4.length) : this._nextAggregateItem(e3, t5, i2, s4, (r3) => {
        null === r3 ? n9(s4.length) : (t5 -= 1, n9(this._sequentialGetPhysicalItem(e3, t5, i2, s4)));
      }, r2);
    });
  }
  _nextAggregateItem(e3, i2, s4, n9, r2, a6) {
    try {
      _e(e3.pagesDefinition.internal.iterator.next()).then((t5) => {
        if (null === t5) if (null !== e3.pagesDefinition.internal.workingItem) {
          const t6 = this._calculateAndAppendAggregateItem(e3.pagesDefinition.internal.workingItem);
          n9.push(t6), e3.pagesDefinition.internal.workingItem = null, e3.pagesDefinition.internal.set.push(t6.attributes[this.objectIdField]), e3.pagesDefinition.internal.fullyResolved = true, r2(null);
        } else e3.pagesDefinition.internal.fullyResolved = true, r2(null);
        else {
          const o = this._generateAggregateHash(t5);
          if (null === e3.pagesDefinition.internal.workingItem) e3.pagesDefinition.internal.workingItem = { features: [t5], id: o };
          else {
            if (o !== e3.pagesDefinition.internal.workingItem.id) {
              const s5 = this._calculateAndAppendAggregateItem(e3.pagesDefinition.internal.workingItem);
              return n9.push(s5), e3.pagesDefinition.internal.workingItem = null, e3.pagesDefinition.internal.set.push(s5.attributes[this.objectIdField]), i2 -= 1, e3.pagesDefinition.internal.workingItem = { features: [t5], id: o }, void r2(s5);
            }
            e3.pagesDefinition.internal.workingItem.features.push(t5);
          }
          this._nextAggregateItem(e3, i2, s4, n9, r2, a6);
        }
      }, a6);
    } catch (o) {
      a6(o);
    }
  }
  _calculateFieldStat(e3, t5, i2) {
    const s4 = [];
    for (const n9 of e3.features) if (null !== t5.workingexpr) {
      const e4 = t5.workingexpr.calculateValue(n9);
      null !== e4 && (e4 instanceof n3 || e4 instanceof n5 ? s4.push(e4.toNumber()) : e4 instanceof r ? s4.push(e4.toMilliseconds()) : s4.push(e4));
    } else s4.push(null);
    i2.attributes[t5.tofieldname] = u(t5.typeofstat, [s4]);
  }
  _calculateAndAppendAggregateItem(t5) {
    const i2 = { attributes: {}, geometry: null };
    for (const e3 of this._decodedGroupbyfield) {
      const s5 = e3.singlefield ? t5.features[0].attributes[e3.singlefield] : Z.convertValueToStorageFormat(e3.expression.calculateValue(t5.features[0]), e3.sqlType);
      i2.attributes[e3.tofieldname] = s5;
    }
    for (const e3 of this._decodedStatsfield) this._calculateFieldStat(t5, e3, i2);
    const s4 = [];
    for (let e3 = 0; e3 < this._decodedStatsfield.length; e3++) s4.push(this._calculateFieldStat(t5, this._decodedStatsfield[e3], i2));
    return this._featureCache[i2.attributes[this.objectIdField]] = new d2({ attributes: i2.attributes, geometry: i2.geometry }), i2;
  }
  _generateAggregateHash(e3) {
    let t5 = "";
    for (const i2 of this._decodedGroupbyfield) {
      const s4 = i2.singlefield ? e3.attributes[i2.singlefield] : i2.expression.calculateValue(e3);
      t5 += null == s4 ? ":" : ":" + s4.toString();
    }
    return x(t5, n7.String);
  }
  async _stat() {
    return { calculated: false };
  }
  async getFeatureByObjectId() {
    return null;
  }
  static registerAction() {
    C._featuresetFunctions.groupby = function(e3, t5) {
      return new _O({ parentfeatureset: this, groupbyfields: e3, statsfields: t5 });
    };
  }
};

// node_modules/@arcgis/core/arcade/featureset/actions/Top.js
var a5 = class _a extends C {
  constructor(t5) {
    super(t5), this._topnum = 0, this.declaredClass = "esri.arcade.featureset.actions.Top", this._countedin = 0, this._maxProcessing = 100, this._topnum = t5.topnum, this._parent = t5.parentfeatureset;
  }
  async _getSet(t5) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const e3 = await this._parent._getSet(t5);
      return this._wset = new t3(e3._candidates.slice(), e3._known.slice(), false, this._clonePageDefinition(e3.pagesDefinition)), this._setKnownLength(this._wset) > this._topnum && (this._wset._known = this._wset._known.slice(0, this._topnum)), this._setKnownLength(this._wset) >= this._topnum && (this._wset._candidates = []), this._wset;
    }
    return this._wset;
  }
  _setKnownLength(t5) {
    return t5._known.length > 0 && "GETPAGES" === t5._known[t5._known.length - 1] ? t5._known.length - 1 : t5._known.length;
  }
  _isInFeatureSet(t5) {
    const e3 = this._parent._isInFeatureSet(t5);
    if (e3 === s.NotInFeatureSet) return e3;
    const n9 = this._idstates[t5];
    return n9 === s.InFeatureSet || n9 === s.NotInFeatureSet ? n9 : e3 === s.InFeatureSet && void 0 === n9 ? this._countedin < this._topnum ? (this._idstates[t5] = s.InFeatureSet, this._countedin++, s.InFeatureSet) : (this._idstates[t5] = s.NotInFeatureSet, s.NotInFeatureSet) : s.Unknown;
  }
  async _expandPagedSet(n9, s4, i2, a6, o) {
    if (null === this._parent) throw new s2(t2.NotImplemented);
    if (s4 > this._topnum && (s4 = this._topnum), this._countedin >= this._topnum && n9.pagesDefinition.internal.set.length <= n9.pagesDefinition.resultOffset) {
      let t5 = n9._known.length;
      return t5 > 0 && "GETPAGES" === n9._known[t5 - 1] && (n9._known.length = t5 - 1), t5 = n9._candidates.length, t5 > 0 && "GETPAGES" === n9._candidates[t5 - 1] && (n9._candidates.length = t5 - 1), "success";
    }
    const r2 = await this._parent._expandPagedSet(n9, s4, i2, a6, o);
    return this._setKnownLength(n9) > this._topnum && (n9._known.length = this._topnum), this._setKnownLength(n9) >= this._topnum && (n9._candidates.length = 0), r2;
  }
  async _getFeatures(t5, e3, n9, i2) {
    const a6 = [], o = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(t5, o)) return await this._expandPagedSet(t5, o, 0, 0, i2), this._getFeatures(t5, e3, n9, i2);
    -1 !== e3 && void 0 === this._featureCache[e3] && a6.push(e3);
    let r2 = 0;
    for (let s4 = t5._lastFetchedIndex; s4 < t5._known.length && (r2++, r2 <= n9 && (t5._lastFetchedIndex += 1), !(void 0 === this._featureCache[t5._known[s4]] && (t5._known[s4] !== e3 && a6.push(t5._known[s4]), a6.length > o))); s4++) ;
    if (0 === a6.length) return "success";
    const _ = new t3([], a6, false, null), h2 = Math.min(a6.length, n9);
    await this._parent._getFeatures(_, -1, h2, i2);
    for (let s4 = 0; s4 < h2; s4++) {
      const t6 = this._parent._featureFromCache(a6[s4]);
      void 0 !== t6 && (this._featureCache[a6[s4]] = t6);
    }
    return "success";
  }
  async _getFilteredSet(t5, e3, n9, i2, a6) {
    await this._ensureLoaded();
    const o = await this._getSet(a6);
    return new t3(o._candidates.slice().concat(o._known.slice()), [], false, this._clonePageDefinition(o.pagesDefinition));
  }
  _refineKnowns(t5, e3) {
    let n9 = 0, s4 = null;
    const a6 = [];
    for (let o = 0; o < t5._candidates.length; o++) {
      const r2 = this._isInFeatureSet(t5._candidates[o]);
      if (r2 === s.InFeatureSet) {
        if (t5._known.push(t5._candidates[o]), n9 += 1, null === s4 ? s4 = { start: o, end: o } : s4.end === o - 1 ? s4.end = o : (a6.push(s4), s4 = { start: o, end: o }), t5._known.length >= this._topnum) break;
      } else if (r2 === s.NotInFeatureSet) null === s4 ? s4 = { start: o, end: o } : s4.end === o - 1 ? s4.end = o : (a6.push(s4), s4 = { start: o, end: o }), n9 += 1;
      else if (r2 === s.Unknown) break;
      if (n9 >= e3) break;
    }
    null !== s4 && a6.push(s4);
    for (let i2 = a6.length - 1; i2 >= 0; i2--) t5._candidates.splice(a6[i2].start, a6[i2].end - a6[i2].start + 1);
    this._setKnownLength(t5) > this._topnum && (t5._known = t5._known.slice(0, this._topnum)), this._setKnownLength(t5) >= this._topnum && (t5._candidates = []);
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  static registerAction() {
    C._featuresetFunctions.top = function(t5) {
      return new _a({ parentfeatureset: this, topnum: t5 });
    };
  }
  getFieldsIndex() {
    return this._parent.getFieldsIndex();
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerDynamic.js
var P = class _P extends C {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerDynamic", this._removeGeometry = false, this._overrideFields = null, this.formulaCredential = null, this._pageJustIds = false, this._requestStandardised = false, this._useDefinitionExpression = true, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return D;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries(e3) {
    this._pageJustIds = e3;
  }
  get urlQueryPath() {
    return this._layer.parsedUrl.path || "";
  }
  convertQueryToLruCacheKey(e3) {
    const t5 = this.urlQueryPath + "," + J(e3.toJSON());
    return x(t5, n7.String);
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  _initialiseFeatureSet() {
    var _a, _b, _c, _d, _e2, _f;
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType ?? "", this.fields = this._layer.fields.slice(), this.hasZ = true === ((_c = (_b = (_a = this._layer) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.data) == null ? void 0 : _c.supportsZ), this.hasM = true === ((_f = (_e2 = (_d = this._layer) == null ? void 0 : _d.capabilities) == null ? void 0 : _e2.data) == null ? void 0 : _f.supportsM), null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e3 = [], t5 = [];
      for (const r2 of this.fields) if ("oid" === r2.type) e3.push(r2), t5.push(r2.name);
      else for (const i2 of this._overrideFields) if (i2.toLowerCase() === r2.name.toLowerCase()) {
        e3.push(r2), t5.push(r2.name);
        break;
      }
      this.fields = e3, this._overrideFields = t5;
    }
    if (this._layer.source && this._layer.source.sourceJSON) {
      const e3 = this._layer.source.sourceJSON.currentVersion;
      true === this._layer.source.sourceJSON.useStandardizedQueries ? (this._databaseType = l.StandardisedNoInterval, null != e3 && e3 >= 10.61 && (this._databaseType = l.Standardised)) : null != e3 && (e3 >= 10.5 && (this._databaseType = l.StandardisedNoInterval, this._requestStandardised = true), e3 >= 10.61 && (this._databaseType = l.Standardised));
    }
    this.objectIdField = this._layer.objectIdField;
    for (const e3 of this.fields) "global-id" === e3.type && (this.globalIdField = e3.name);
    this.subtypeField = this._layer.subtypeField ?? "", this.subtypes = this._layer.subtypes, this.typeIdField = ("typeIdField" in this._layer ? this._layer.typeIdField : null) ?? "", this.types = "types" in this._layer ? this._layer.types : null;
  }
  _isInFeatureSet() {
    return s.InFeatureSet;
  }
  async _refineSetBlock(e3) {
    return e3;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t5 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t5, t5;
    }
    return this._wset;
  }
  async _runDatabaseProbe(e3) {
    await this._ensureLoaded();
    const t5 = new b();
    this.datesInUnknownTimezone && (t5.timeReferenceUnknownClient = true), t5.where = e3.replace("OBJECTID", this._layer.objectIdField);
    try {
      return await this._layer.queryObjectIds(t5), true;
    } catch (r2) {
      return false;
    }
  }
  _canUsePagination() {
    return !(!this._layer.capabilities || !this._layer.capabilities.query || true !== this._layer.capabilities.query.supportsPagination);
  }
  _cacheableFeatureSetSourceKey() {
    return this._layer.url;
  }
  get gdbVersion() {
    return this._layer && this._layer.capabilities && this._layer.capabilities.data && this._layer.capabilities.data.isVersioned ? this._layer.gdbVersion || "SDE.DEFAULT" : "";
  }
  nativeCapabilities() {
    return { title: this._layer.title ?? "", source: this, canQueryRelated: true, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: this._requestStandardised };
  }
  _createQuery() {
    const e3 = this._layer.createQuery();
    return e3.returnZ = this.hasZ, e3.returnM = this.hasM, this.datesInUnknownTimezone && (e3.timeReferenceUnknownClient = true), this._requestStandardised && (e3.sqlFormat = "standard"), this._useDefinitionExpression ? "subtype-group" === this._layer.type && (e3.where = this._layer.definitionExpression) : e3.where = null, e3;
  }
  executeQuery(e3, t5) {
    const r2 = "execute" === t5 ? this._layer.queryFeatures.bind(this._layer) : "executeForCount" === t5 ? this._layer.queryFeatureCount.bind(this._layer) : this._layer.queryObjectIds.bind(this._layer);
    let i2 = null;
    if (this.recentlyUsedQueries) {
      const t6 = this.convertQueryToLruCacheKey(e3);
      i2 = this.recentlyUsedQueries.getFromCache(t6), null === i2 && (i2 = r2(e3), this.recentlyUsedQueries.addToCache(t6, i2), i2 = i2.catch((e4) => {
        var _a;
        throw (_a = this.recentlyUsedQueries) == null ? void 0 : _a.removeFromCache(t6), e4;
      }));
    }
    return this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: e3, method: t5 }), null === i2 && (i2 = r2(e3)), i2;
  }
  async _getFilteredSet(e3, t5, r2, i2, s4) {
    const a6 = await this.databaseType();
    if (this.isTable() && t5 && null !== e3 && "" !== e3) {
      return new t3([], [], true, null);
    }
    if (this._canUsePagination()) return this._getFilteredSetUsingPaging(e3, t5, r2, i2, s4);
    let n9 = "", l2 = false;
    null !== i2 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (n9 = i2.constructClause(), l2 = true);
    const u2 = this._createQuery();
    u2.where = n6(u2.where, null === r2 ? null === t5 ? "1=1" : "" : f4(r2, a6)), u2.spatialRelationship = this._makeRelationshipEnum(e3), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== n9 ? n9.split(",") : null, u2.geometry = null === t5 ? null : t5, u2.relationParameter = this._makeRelationshipParam(e3);
    let d5 = await this.executeQuery(u2, "executeForIds");
    null === d5 && (d5 = []), this._checkCancelled(s4);
    return new t3([], d5, l2, null);
  }
  _expandPagedSet(e3, t5, r2, i2, s4) {
    return this._expandPagedSetFeatureSet(e3, t5, r2, i2, s4);
  }
  async _getFilteredSetUsingPaging(e3, t5, r2, i2, s4) {
    var _a;
    let a6 = "", n9 = false;
    null !== i2 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (a6 = i2.constructClause(), n9 = true);
    const l2 = await this.databaseType(), u2 = null === r2 ? null === t5 ? "1=1" : "" : f4(r2, l2);
    let d5 = this._maxQueryRate();
    const c5 = (_a = this._layer.capabilities) == null ? void 0 : _a.query.maxRecordCount;
    null != c5 && c5 < d5 && (d5 = c5);
    let h2 = null;
    if (true === this._pageJustIds) h2 = new t3([], ["GETPAGES"], n9, { spatialRel: this._makeRelationshipEnum(e3), relationParam: this._makeRelationshipParam(e3), outFields: this._layer.objectIdField, resultRecordCount: d5, resultOffset: 0, geometry: null === t5 ? null : t5, where: u2, orderByFields: a6, returnGeometry: false, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    else {
      let r3 = true;
      true === this._removeGeometry && (r3 = false);
      const i3 = this._overrideFields ?? this._fieldsIncludingObjectId(["*"]);
      h2 = new t3([], ["GETPAGES"], n9, { spatialRel: this._makeRelationshipEnum(e3), relationParam: this._makeRelationshipParam(e3), outFields: i3.join(","), resultRecordCount: d5, resultOffset: 0, geometry: null === t5 ? null : t5, where: u2, orderByFields: a6, returnGeometry: r3, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
    }
    return await this._expandPagedSet(h2, d5, 0, 1, s4), h2;
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true !== e3.groupbypage ? { groupbypage: false, spatialRel: e3.spatialRel, relationParam: e3.relationParam, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, geometry: e3.geometry, where: e3.where, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal } : { groupbypage: true, spatialRel: e3.spatialRel, relationParam: e3.relationParam, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, useOIDpagination: e3.useOIDpagination, generatedOid: e3.generatedOid, groupByFieldsForStatistics: e3.groupByFieldsForStatistics, resultOffset: e3.resultOffset, outStatistics: e3.outStatistics, geometry: e3.geometry, where: e3.where, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal };
  }
  async _getPhysicalPage(e3, t5, r2) {
    const i2 = e3.pagesDefinition.internal.lastRetrieved, s4 = i2, a6 = e3.pagesDefinition.internal.lastPage, n9 = this._createQuery();
    n9.spatialRelationship = e3.pagesDefinition.spatialRel, n9.relationParameter = e3.pagesDefinition.relationParam, n9.outFields = e3.pagesDefinition.outFields.split(","), n9.num = e3.pagesDefinition.resultRecordCount, n9.start = e3.pagesDefinition.internal.lastPage, n9.geometry = e3.pagesDefinition.geometry, n9.where = n6(n9.where, e3.pagesDefinition.where), n9.orderByFields = "" !== e3.pagesDefinition.orderByFields ? e3.pagesDefinition.orderByFields.split(",") : null, n9.returnGeometry = e3.pagesDefinition.returnGeometry, n9.outSpatialReference = this.spatialReference;
    const l2 = await this.executeQuery(n9, "execute");
    if (this._checkCancelled(r2), e3.pagesDefinition.internal.lastPage !== a6) return "done";
    const o = this._layer.objectIdField;
    for (let u2 = 0; u2 < l2.features.length; u2++) e3.pagesDefinition.internal.set[s4 + u2] = l2.features[u2].attributes[o];
    if (false === this._pageJustIds) for (let u2 = 0; u2 < l2.features.length; u2++) this._featureCache[l2.features[u2].attributes[o]] = l2.features[u2];
    return (void 0 === l2.exceededTransferLimit && l2.features.length !== e3.pagesDefinition.resultRecordCount || false === l2.exceededTransferLimit) && (e3.pagesDefinition.internal.fullyResolved = true), e3.pagesDefinition.internal.lastRetrieved = i2 + l2.features.length, e3.pagesDefinition.internal.lastPage += e3.pagesDefinition.resultRecordCount, "done";
  }
  _fieldsIncludingObjectId(e3) {
    if (null === e3) return [this.objectIdField];
    const t5 = e3.slice();
    if (t5.includes("*")) return t5;
    let r2 = false;
    for (const i2 of t5) if (i2.toUpperCase() === this.objectIdField.toUpperCase()) {
      r2 = true;
      break;
    }
    return false === r2 && t5.push(this.objectIdField), t5;
  }
  async _getFeatures(e3, t5, r2, i2) {
    const s4 = [];
    if (-1 !== t5 && void 0 === this._featureCache[t5] && s4.push(t5), true === this._checkIfNeedToExpandKnownPage(e3, this._maxProcessingRate())) return await this._expandPagedSet(e3, this._maxProcessingRate(), 0, 0, i2), this._getFeatures(e3, t5, r2, i2);
    let l2 = 0;
    for (let a6 = e3._lastFetchedIndex; a6 < e3._known.length; a6++) {
      if (e3._lastFetchedIndex += 1, l2++, void 0 === this._featureCache[e3._known[a6]]) {
        let r3 = false;
        if (null !== this._layer._mode && void 0 !== this._layer._mode) {
          const t6 = this._layer._mode;
          if (void 0 !== t6._featureMap[e3._known[a6]]) {
            const i3 = t6._featureMap[e3._known[a6]];
            null !== i3 && (r3 = true, this._featureCache[e3._known[a6]] = i3);
          }
        }
        if (false === r3 && (e3._known[a6] !== t5 && s4.push(e3._known[a6]), s4.length >= this._maxProcessingRate() - 1)) break;
      }
      if (l2 >= r2 && 0 === s4.length) break;
    }
    if (0 === s4.length) return "success";
    const o = this._createQuery();
    o.objectIds = s4, o.outFields = this._overrideFields ?? this._fieldsIncludingObjectId(["*"]), o.returnGeometry = true, true === this._removeGeometry && (o.returnGeometry = false), o.outSpatialReference = this.spatialReference;
    const u2 = await this.executeQuery(o, "execute");
    if (this._checkCancelled(i2), void 0 !== u2.error) throw new s2(t2.RequestFailed, { reason: u2.error });
    const d5 = this._layer.objectIdField;
    for (let a6 = 0; a6 < u2.features.length; a6++) this._featureCache[u2.features[a6].attributes[d5]] = u2.features[a6];
    return "success";
  }
  async _getDistinctPages(e3, t5, r2, i2, s4, l2, o, u2, d5) {
    var _a;
    await this._ensureLoaded();
    const c5 = await this.databaseType();
    let h2 = r2.parseTree.column;
    const p2 = this._layer.fields ?? [];
    for (let a6 = 0; a6 < p2.length; a6++) if (p2[a6].name.toLowerCase() === h2.toLowerCase()) {
      h2 = p2[a6].name;
      break;
    }
    const f7 = this._createQuery();
    f7.where = n6(f7.where, null === l2 ? null === s4 ? "1=1" : "" : f4(l2, c5)), f7.spatialRelationship = this._makeRelationshipEnum(i2), f7.relationParameter = this._makeRelationshipParam(i2), f7.geometry = null === s4 ? null : s4, f7.returnDistinctValues = true, f7.returnGeometry = false, f7.outFields = [h2];
    const _ = await this.executeQuery(f7, "execute");
    if (this._checkCancelled(d5), !_.hasOwnProperty("features")) throw new s2(t2.InvalidStatResponse);
    let g5 = false;
    for (let a6 = 0; a6 < p2.length; a6++) if (p2[a6].name === h2) {
      "date" === p2[a6].type && (g5 = true);
      break;
    }
    for (let a6 = 0; a6 < _.features.length; a6++) {
      if (g5) {
        const e4 = _.features[a6].attributes[h2];
        null !== e4 ? u2.push(new Date(e4)) : u2.push(e4);
      } else u2.push(_.features[a6].attributes[h2]);
      if (u2.length >= o) break;
    }
    if (0 === _.features.length) return u2;
    if (_.features.length === ((_a = this._layer.capabilities) == null ? void 0 : _a.query.maxRecordCount) && u2.length < o) {
      return { calculated: true, result: await this._getDistinctPages(e3 + _.features.length, t5, r2, i2, s4, l2, o, u2, d5) };
    }
    return u2;
  }
  async _distinctStat(e3, t5, r2, i2, s4, a6, n9) {
    return { calculated: true, result: await this._getDistinctPages(0, e3, t5, r2, i2, s4, a6, [], n9) };
  }
  isTable() {
    return this._layer.isTable || null === this._layer.geometryType || "table" === this._layer.type || "" === this._layer.geometryType || "esriGeometryNull" === this._layer.geometryType;
  }
  async _countstat(e3, t5, r2, i2) {
    const s4 = await this.databaseType();
    if (this.isTable() && r2 && null !== t5 && "" !== t5) return { calculated: true, result: 0 };
    const a6 = this._createQuery();
    a6.where = n6(a6.where, null === i2 ? null === r2 ? "1=1" : "" : f4(i2, s4)), a6.spatialRelationship = this._makeRelationshipEnum(t5), a6.relationParameter = this._makeRelationshipParam(t5), a6.geometry = null === r2 ? null : r2, a6.returnGeometry = false;
    return { calculated: true, result: await this.executeQuery(a6, "executeForCount") };
  }
  async _stats(e3, t5, r2, i2, s4, l2, o) {
    await this._ensureLoaded();
    const u2 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsSqlExpression, d5 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsStatistics, c5 = this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsDistinct;
    if ("count" === e3) return c5 ? this._countstat(e3, r2, i2, s4) : { calculated: false };
    if (false === d5 || false === O(t5) && false === u2 || false === t5.isStandardized) return "" !== r2 || null !== s4 ? { calculated: false } : this._manualStat(e3, t5, l2, o);
    if ("distinct" === e3) return false === c5 ? "" !== r2 || null !== s4 ? { calculated: false } : this._manualStat(e3, t5, l2, o) : this._distinctStat(e3, t5, r2, i2, s4, l2, o);
    const h2 = await this.databaseType();
    if (this.isTable() && i2 && null !== r2 && "" !== r2) return { calculated: true, result: null };
    const p2 = this._createQuery();
    p2.where = n6(p2.where, null === s4 ? null === i2 ? "1=1" : "" : f4(s4, h2)), p2.spatialRelationship = this._makeRelationshipEnum(r2), p2.relationParameter = this._makeRelationshipParam(r2), p2.geometry = null === i2 ? null : i2;
    const g5 = new m();
    g5.statisticType = w2(e3), g5.onStatisticField = f4(t5, h2), g5.outStatisticFieldName = "ARCADE_STAT_RESULT", p2.returnGeometry = false;
    let m4 = "ARCADE_STAT_RESULT";
    p2.outStatistics = [g5];
    const b4 = await this.executeQuery(p2, "execute");
    if (!b4.hasOwnProperty("features") || 0 === b4.features.length) throw new s2(t2.InvalidStatResponse);
    let w3 = false;
    const S4 = b4.fields ?? [];
    for (let a6 = 0; a6 < S4.length; a6++) if ("ARCADE_STAT_RESULT" === S4[a6].name.toUpperCase()) {
      m4 = S4[a6].name, "date" === S4[a6].type && (w3 = true);
      break;
    }
    if (w3) {
      let e4 = b4.features[0].attributes[m4];
      return null !== e4 && (e4 = new Date(b4.features[0].attributes[m4])), { calculated: true, result: e4 };
    }
    return { calculated: true, result: b4.features[0].attributes[m4] };
  }
  _stat(e3, t5, r2, i2, s4, a6, n9) {
    return this._stats(e3, t5, r2, i2, s4, a6, n9);
  }
  async _canDoAggregates(e3, t5) {
    var _a, _b;
    await this._ensureLoaded();
    let r2 = false;
    const i2 = (_a = this._layer.capabilities) == null ? void 0 : _a.query, s4 = true === (i2 == null ? void 0 : i2.supportsSqlExpression);
    if (null != i2 && true === i2.supportsStatistics && true === i2.supportsOrderBy && (r2 = true), r2) for (let a6 = 0; a6 < t5.length - 1; a6++) (false === ((_b = t5[a6].workingexpr) == null ? void 0 : _b.isStandardized) || false === O(t5[a6].workingexpr) && false === s4) && (r2 = false);
    return false !== r2;
  }
  _makeRelationshipEnum(e3) {
    if (e3.includes("esriSpatialRelRelation")) return "relation";
    switch (e3) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e3;
  }
  _makeRelationshipParam(e3) {
    return e3.includes("esriSpatialRelRelation") ? e3.split(":")[1] : "";
  }
  async _getAggregatePagesDataSourceDefinition(e3, t5, r2, i2, s4, a6, n9) {
    var _a;
    await this._ensureLoaded();
    const l2 = await this.databaseType();
    let u2 = "", d5 = false, c5 = false;
    null !== a6 && this._layer.capabilities && this._layer.capabilities.query && true === this._layer.capabilities.query.supportsOrderBy && (u2 = a6.constructClause(), c5 = true), this._layer.capabilities && this._layer.capabilities.query && false === this._layer.capabilities.query.supportsPagination && (c5 = false, d5 = true, u2 = this._layer.objectIdField);
    const h2 = [];
    for (let o = 0; o < t5.length; o++) {
      const e4 = new m();
      e4.onStatisticField = null !== t5[o].workingexpr ? f4(t5[o].workingexpr, l2) : "", e4.outStatisticFieldName = t5[o].field, e4.statisticType = t5[o].toStatisticsName(), h2.push(e4);
    }
    "" === u2 && (u2 = e3.join(","));
    let p2 = this._maxQueryRate();
    const f7 = (_a = this._layer.capabilities) == null ? void 0 : _a.query.maxRecordCount;
    null != f7 && f7 < p2 && (p2 = f7);
    const _ = null === s4 ? null === i2 ? "1=1" : "" : f4(s4, l2);
    return new t3([], ["GETPAGES"], c5, { groupbypage: true, spatialRel: this._makeRelationshipEnum(r2), relationParam: this._makeRelationshipParam(r2), outFields: ["*"], useOIDpagination: d5, generatedOid: n9, resultRecordCount: p2, resultOffset: 0, groupByFieldsForStatistics: e3, outStatistics: h2, geometry: null === i2 ? null : i2, where: _, orderByFields: u2, returnGeometry: false, returnIdsOnly: false, internal: { lastMaxId: -1, set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } });
  }
  async _getAgregagtePhysicalPage(t5, r2, i2) {
    let s4 = t5.pagesDefinition.where;
    true === t5.pagesDefinition.useOIDpagination && (s4 = n6(s4, t5.pagesDefinition.generatedOid + ">" + t5.pagesDefinition.internal.lastMaxId.toString()));
    const l2 = t5.pagesDefinition.internal.lastRetrieved, o = l2, u2 = t5.pagesDefinition.internal.lastPage, d5 = this._createQuery();
    if (d5.where = n6(d5.where, s4), d5.spatialRelationship = t5.pagesDefinition.spatialRel, d5.relationParameter = t5.pagesDefinition.relationParam, d5.outFields = t5.pagesDefinition.outFields, d5.outStatistics = t5.pagesDefinition.outStatistics, d5.geometry = t5.pagesDefinition.geometry, d5.groupByFieldsForStatistics = t5.pagesDefinition.groupByFieldsForStatistics, d5.num = t5.pagesDefinition.resultRecordCount, d5.start = t5.pagesDefinition.internal.lastPage, d5.returnGeometry = t5.pagesDefinition.returnGeometry, d5.orderByFields = "" !== t5.pagesDefinition.orderByFields ? t5.pagesDefinition.orderByFields.split(",") : null, this.isTable() && d5.geometry && d5.spatialRelationship) return [];
    const c5 = await this.executeQuery(d5, "execute");
    if (this._checkCancelled(i2), !c5.hasOwnProperty("features")) throw new s2(t2.InvalidStatResponse);
    const h2 = [];
    if (t5.pagesDefinition.internal.lastPage !== u2) return [];
    c5.features.length > 0 && void 0 === c5.features[0].attributes[t5.pagesDefinition.generatedOid] && (t5.pagesDefinition.generatedOid = t5.pagesDefinition.generatedOid.toLowerCase());
    for (let e3 = 0; e3 < c5.features.length; e3++) t5.pagesDefinition.internal.set[o + e3] = c5.features[e3].attributes[t5.pagesDefinition.generatedOid];
    for (let a6 = 0; a6 < c5.features.length; a6++) h2.push(new d2({ attributes: c5.features[a6].attributes, geometry: null }));
    return true === t5.pagesDefinition.useOIDpagination ? 0 === c5.features.length ? t5.pagesDefinition.internal.fullyResolved = true : t5.pagesDefinition.internal.lastMaxId = c5.features[c5.features.length - 1].attributes[t5.pagesDefinition.generatedOid] : (void 0 === c5.exceededTransferLimit && c5.features.length !== t5.pagesDefinition.resultRecordCount || false === c5.exceededTransferLimit) && (t5.pagesDefinition.internal.fullyResolved = true), t5.pagesDefinition.internal.lastRetrieved = l2 + c5.features.length, t5.pagesDefinition.internal.lastPage += t5.pagesDefinition.resultRecordCount, h2;
  }
  static create(e3, t5, r2, i2, s4) {
    const a6 = new Xe({ url: e3, outFields: null === t5 ? ["*"] : t5 });
    return new _P({ layer: a6, spatialReference: r2, lrucache: i2, interceptor: s4 });
  }
  relationshipMetaData() {
    var _a;
    return this._layer && this._layer.source && ((_a = this._layer.source.sourceJSON) == null ? void 0 : _a.relationships) ? this._layer.source.sourceJSON.relationships : [];
  }
  serviceUrl() {
    return k(this._layer.parsedUrl.path);
  }
  async queryAttachments(e3, t5, r2, a6, n9) {
    function l2(e4) {
      const t6 = e4.capabilities;
      return (t6 == null ? void 0 : t6.data.supportsAttachment) && (t6 == null ? void 0 : t6.operations.supportsQueryAttachments);
    }
    const o = this._layer;
    if (l2(o)) {
      const l3 = { objectIds: [e3], returnMetadata: n9 };
      (t5 && t5 > 0 || r2 && r2 > 0) && (l3.size = [t5 && t5 > 0 ? t5 : 0, r2 && r2 > 0 ? r2 : t5 + 1]), a6 && a6.length > 0 && (l3.attachmentTypes = a6), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: o, query: l3, method: "attachments" });
      const u2 = await o.queryAttachments(new c3(l3)), d5 = [];
      return u2 && u2[e3] && u2[e3].forEach((t6) => {
        const r3 = this._layer.parsedUrl.path + "/" + e3.toString() + "/attachments/" + t6.id.toString();
        let a7 = null;
        n9 && t6.exifInfo && (a7 = N2.convertJsonToArcade(t6.exifInfo, "system", true)), d5.push(new t(t6.id, t6.name, t6.contentType, t6.size, r3, a7, t6.keywords ?? null));
      }), d5;
    }
    return [];
  }
  async queryRelatedFeatures(t5) {
    var _a;
    const i2 = { f: "json", relationshipId: t5.relationshipId.toString(), definitionExpression: t5.where, outFields: (_a = t5.outFields) == null ? void 0 : _a.join(","), returnGeometry: t5.returnGeometry.toString() };
    void 0 !== t5.resultOffset && null !== t5.resultOffset && (i2.resultOffset = t5.resultOffset.toString()), void 0 !== t5.resultRecordCount && null !== t5.resultRecordCount && (i2.resultRecordCount = t5.resultRecordCount.toString()), t5.orderByFields && (i2.orderByFields = t5.orderByFields.join(",")), t5.objectIds && t5.objectIds.length > 0 && (i2.objectIds = t5.objectIds.join(",")), t5.outSpatialReference && (i2.outSR = c(t5.outSpatialReference)), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preRequestCallback({ layer: this._layer, queryPayload: i2, method: "relatedrecords", url: this._layer.parsedUrl.path + "/queryRelatedRecords" });
    const s4 = await U(this._layer.parsedUrl.path + "/queryRelatedRecords", { responseType: "json", query: i2 });
    if (s4.data) {
      const t6 = {}, r2 = s4.data;
      if (r2 == null ? void 0 : r2.relatedRecordGroups) {
        const i3 = r2.spatialReference;
        for (const s5 of r2.relatedRecordGroups) {
          const a6 = s5.objectId, n9 = [];
          for (const t7 of s5.relatedRecords) {
            t7.geometry && (t7.geometry.spatialReference = i3);
            const r3 = new d2({ geometry: t7.geometry ? f(t7.geometry) : null, attributes: t7.attributes });
            n9.push(r3);
          }
          t6[a6] = { features: n9, exceededTransferLimit: true === r2.exceededTransferLimit };
        }
      }
      return t6;
    }
    throw new s2(t2.InvalidRequest);
  }
  async getFeatureByObjectId(e3, t5) {
    const r2 = this._createQuery();
    r2.outFields = t5, r2.returnGeometry = false, r2.outSpatialReference = this.spatialReference, r2.where = n6(r2.where, this.objectIdField + "=" + e3.toString()), this.featureSetQueryInterceptor && this.featureSetQueryInterceptor.preLayerQueryCallback({ layer: this._layer, query: r2, method: "execute" });
    const i2 = await this._layer.queryFeatures(r2);
    return 1 === i2.features.length ? i2.features[0] : null;
  }
  async getIdentityUser() {
    var _a;
    await this.load();
    const e3 = (_a = i) == null ? void 0 : _a.findCredential(this._layer.url);
    return e3 ? e3.userId : null;
  }
  async getOwningSystemUrl() {
    var _a, _b;
    await this.load();
    const e3 = (_a = i) == null ? void 0 : _a.findServerInfo(this._layer.url);
    if (e3) return e3.owningSystemUrl;
    let i2 = this._layer.url;
    const s4 = i2.toLowerCase().indexOf("/rest/services");
    if (i2 = s4 > -1 ? i2.slice(0, s4) : i2, i2) {
      i2 += "/rest/info";
      try {
        const e4 = await U(i2, { query: { f: "json" } });
        let t5 = "";
        return ((_b = e4.data) == null ? void 0 : _b.owningSystemUrl) && (t5 = e4.data.owningSystemUrl), t5;
      } catch (a6) {
        return "";
      }
    }
    return "";
  }
  getDataSourceFeatureSet() {
    const e3 = new _P({ layer: this._layer, spatialReference: this.spatialReference ?? void 0, outFields: this._overrideFields ?? void 0, includeGeometry: !this._removeGeometry, lrucache: this.recentlyUsedQueries ?? void 0, interceptor: this.featureSetQueryInterceptor ?? void 0 });
    return e3._useDefinitionExpression = false, e3;
  }
  get preferredTimeZone() {
    return this._layer.preferredTimeZone ?? null;
  }
  get dateFieldsTimeZone() {
    return this._layer.dateFieldsTimeZone ?? null;
  }
  get datesInUnknownTimezone() {
    return this._layer.datesInUnknownTimezone ?? false;
  }
  get editFieldsInfo() {
    return this._layer.editFieldsInfo ?? null;
  }
  get timeInfo() {
    return this._layer.timeInfo ?? null;
  }
  async getFeatureSetInfo() {
    var _a, _b;
    if (this.fsetInfo) return this.fsetInfo;
    let e3 = null, t5 = "serviceItemId" in this._layer ? this._layer.serviceItemId : null;
    const i2 = this._layer.parsedUrl.path;
    if (i2) {
      const s5 = await U(i2, { responseType: "json", query: { f: "json" } });
      e3 = ((_a = s5 == null ? void 0 : s5.data) == null ? void 0 : _a.name) ?? null, t5 = ((_b = s5 == null ? void 0 : s5.data) == null ? void 0 : _b.serviceItemId) ?? null;
    }
    const s4 = this._layer.title && null !== (this._layer.parent ?? null);
    return this.featureSetInfo = { layerId: this._layer.layerId, layerName: "" === e3 ? null : e3, itemId: "" === t5 ? null : t5, serviceLayerUrl: "" === i2 ? null : i2, webMapLayerId: s4 ? this._layer.id ?? null : null, webMapLayerTitle: s4 ? this._layer.title ?? null : null, className: null, objectClassId: null }, this.fsetInfo;
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerMemory.js
var f6 = class _f extends C {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerMemory", this._removeGeometry = false, this._overrideFields = null, this._forceIsTable = false, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, true === e3.isTable && (this._forceIsTable = true), void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return D;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    return true === this._layer.loaded ? (this._initialiseFeatureSet(), this) : (await this._layer.load(), this._initialiseFeatureSet(), this);
  }
  get gdbVersion() {
    return "";
  }
  _initialiseFeatureSet() {
    var _a, _b, _c, _d, _e2, _f2;
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._layer.geometryType ?? "", this.fields = this._layer.fields.slice(), null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e3 = [], t5 = [];
      for (const s4 of this.fields) if ("oid" === s4.type) e3.push(s4), t5.push(s4.name);
      else for (const r2 of this._overrideFields) if (r2.toLowerCase() === s4.name.toLowerCase()) {
        e3.push(s4), t5.push(s4.name);
        break;
      }
      this.fields = e3, this._overrideFields = t5;
    }
    this.objectIdField = this._layer.objectIdField;
    for (const e3 of this.fields) "global-id" === e3.type && (this.globalIdField = e3.name);
    this._databaseType = l.Standardised, this.hasZ = true === ((_c = (_b = (_a = this._layer) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.data) == null ? void 0 : _c.supportsZ), this.hasM = true === ((_f2 = (_e2 = (_d = this._layer) == null ? void 0 : _d.capabilities) == null ? void 0 : _e2.data) == null ? void 0 : _f2.supportsM), this.subtypeField = ("subtypeField" in this._layer ? this._layer.subtypeField : null) ?? "", this.subtypes = "subtypes" in this._layer ? this._layer.subtypes : null, this.typeIdField = ("typeIdField" in this._layer ? this._layer.typeIdField : null) ?? "", this.types = "types" in this._layer ? this._layer.types : null;
  }
  isTable() {
    return this._forceIsTable || "isTable" in this._layer && this._layer.isTable || "table" === this._layer.type || !this._layer.geometryType;
  }
  _isInFeatureSet() {
    return s.InFeatureSet;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t5 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t5, t5;
    }
    return this._wset;
  }
  _changeFeature(t5) {
    const s4 = {};
    for (const e3 of this.fields) s4[e3.name] = t5.attributes[e3.name];
    return new d2({ geometry: true === this._removeGeometry ? null : t5.geometry, attributes: s4 });
  }
  async _getFilteredSet(e3, t5, s4, r2, a6) {
    let n9 = "", h2 = false;
    if (null !== r2 && (n9 = r2.constructClause(), h2 = true), this.isTable() && t5 && null !== e3 && "" !== e3) {
      return new t3([], [], true, null);
    }
    const y3 = this._layer.createQuery();
    y3.returnZ = this.hasZ, y3.returnM = this.hasM, y3.where = n6(y3.where, null === s4 ? null === t5 ? "1=1" : "" : f4(s4, l.Standardised)), y3.spatialRelationship = this._makeRelationshipEnum(e3), y3.outSpatialReference = this.spatialReference, y3.orderByFields = "" !== n9 ? n9.split(",") : null, y3.geometry = null === t5 ? null : t5, y3.returnGeometry = true, y3.relationParameter = this._makeRelationshipParam(e3);
    const c5 = await this._layer.queryFeatures(y3);
    if (null === c5) return new t3([], [], h2, null);
    this._checkCancelled(a6);
    const d5 = [];
    c5.features.forEach((e4) => {
      const t6 = e4.attributes[this._layer.objectIdField];
      d5.push(t6), this._featureCache[t6] = this._changeFeature(e4);
    });
    return new t3([], d5, h2, null);
  }
  _makeRelationshipEnum(e3) {
    if (e3.includes("esriSpatialRelRelation")) return "relation";
    switch (e3) {
      case "esriSpatialRelRelation":
        return "relation";
      case "esriSpatialRelIntersects":
        return "intersects";
      case "esriSpatialRelContains":
        return "contains";
      case "esriSpatialRelOverlaps":
        return "overlaps";
      case "esriSpatialRelWithin":
        return "within";
      case "esriSpatialRelTouches":
        return "touches";
      case "esriSpatialRelCrosses":
        return "crosses";
      case "esriSpatialRelEnvelopeIntersects":
        return "envelope-intersects";
    }
    return e3;
  }
  _makeRelationshipParam(e3) {
    return e3.includes("esriSpatialRelRelation") ? e3.split(":")[1] : "";
  }
  async _queryAllFeatures() {
    if (this._wset) return this._wset;
    const e3 = new b();
    if (e3.where = "1=1", await this._ensureLoaded(), this._layer.source && this._layer.source.items) {
      const e4 = [];
      return this._layer.source.items.forEach((t6) => {
        const s5 = t6.attributes[this._layer.objectIdField];
        e4.push(s5), this._featureCache[s5] = this._changeFeature(t6);
      }), this._wset = new t3([], e4, false, null), this._wset;
    }
    e3.returnZ = this.hasZ, e3.returnM = this.hasM;
    const t5 = await this._layer.queryFeatures(e3), s4 = [];
    return t5.features.forEach((e4) => {
      const t6 = e4.attributes[this._layer.objectIdField];
      s4.push(t6), this._featureCache[t6] = this._changeFeature(e4);
    }), this._wset = new t3([], s4, false, null), this._wset;
  }
  async _getFeatures(e3, r2, i2) {
    const a6 = [];
    -1 !== r2 && void 0 === this._featureCache[r2] && a6.push(r2);
    for (let t5 = e3._lastFetchedIndex; t5 < e3._known.length && (e3._lastFetchedIndex += 1, !(void 0 === this._featureCache[e3._known[t5]] && (e3._known[t5] !== r2 && a6.push(e3._known[t5]), a6.length > i2))); t5++) ;
    if (0 === a6.length) return "success";
    throw new s2(t2.MissingFeatures);
  }
  async _refineSetBlock(e3) {
    return e3;
  }
  async _stat() {
    return { calculated: false };
  }
  async _canDoAggregates() {
    return false;
  }
  relationshipMetaData() {
    return [];
  }
  static _cloneAttr(e3) {
    const t5 = {};
    for (const s4 in e3) t5[s4] = e3[s4];
    return t5;
  }
  nativeCapabilities() {
    return { title: this._layer.title ?? "", canQueryRelated: false, source: this, capabilities: this._layer.capabilities, databaseType: this._databaseType, requestStandardised: true };
  }
  static create(e3, t5) {
    var _a, _b, _c, _d, _e2, _f2;
    let s4 = e3.layerDefinition.objectIdField;
    const r2 = e3.layerDefinition.typeIdField ?? "", i2 = [];
    if (e3.layerDefinition.types) for (const h2 of e3.layerDefinition.types) i2.push(n8.fromJSON(h2));
    let a6 = e3.layerDefinition.geometryType;
    void 0 === a6 && (a6 = e3.featureSet.geometryType || "");
    let l2 = e3.featureSet.features;
    const n9 = t5.toJSON();
    if (!s4) {
      let t6 = false;
      for (const r3 of e3.layerDefinition.fields) if ("oid" === r3.type || "esriFieldTypeOID" === r3.type) {
        s4 = r3.name, t6 = true;
        break;
      }
      if (false === t6) {
        let t7 = "FID", r3 = true, i3 = 0;
        for (; r3; ) {
          let s5 = true;
          for (const r4 of e3.layerDefinition.fields) if (r4.name === t7) {
            s5 = false;
            break;
          }
          true === s5 ? r3 = false : (i3++, t7 = "FID" + i3.toString());
        }
        e3.layerDefinition.fields.push({ type: "esriFieldTypeOID", name: t7, alias: t7 });
        const a7 = [];
        for (let s5 = 0; s5 < l2.length; s5++) a7.push({ geometry: e3.featureSet.features[s5].geometry, attributes: e3.featureSet.features[s5].attributes ? this._cloneAttr(e3.featureSet.features[s5].attributes) : {} }), a7[s5].attributes[t7] = s5;
        l2 = a7, s4 = t7;
      }
    }
    const o = [];
    for (const h2 of e3.layerDefinition.fields) h2 instanceof y ? o.push(h2) : o.push(y.fromJSON(h2));
    let u2 = a6;
    switch (u2 || (u2 = ""), u2) {
      case "esriGeometryPoint":
        u2 = "point";
        break;
      case "esriGeometryPolyline":
        u2 = "polyline";
        break;
      case "esriGeometryPolygon":
        u2 = "polygon";
        break;
      case "esriGeometryEnvelope":
        u2 = "extent";
        break;
      case "esriGeometryMultipoint":
        u2 = "multipoint";
        break;
      case "":
      case "esriGeometryNull":
        u2 = "esriGeometryNull";
    }
    if ("esriGeometryNull" !== u2) for (const y3 of l2) y3.geometry && y3.geometry instanceof n2 == false && (y3.geometry.type = u2, void 0 === y3.geometry.spatialReference && (y3.geometry.spatialReference = n9));
    else for (const h2 of l2) h2.geometry && (h2.geometry = null);
    const p2 = { outFields: ["*"], source: l2, fields: o, hasZ: true === ((_a = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _a.hasZ) || true === ((_b = e3 == null ? void 0 : e3.featureSet) == null ? void 0 : _b.hasZ), hasM: true === ((_c = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _c.hasM) || true === ((_d = e3 == null ? void 0 : e3.featureSet) == null ? void 0 : _d.hasM), types: i2, typeIdField: r2, objectIdField: s4, spatialReference: t5 }, _ = "esriGeometryNull" === u2 || null === u2;
    _ || (p2.geometryType = u2);
    const m4 = new Xe(p2);
    ((_e2 = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _e2.subtypeField) && ((_f2 = e3 == null ? void 0 : e3.layerDefinition) == null ? void 0 : _f2.subtypes) && m4.read({ subtypes: e3.layerDefinition.subtypes, subtypeField: e3.layerDefinition.subtypeField });
    return new _f({ layer: m4, spatialReference: t5, isTable: _ });
  }
  async queryAttachments() {
    return [];
  }
  async getFeatureByObjectId(e3) {
    const t5 = new b();
    t5.where = this.objectIdField + "=" + e3.toString(), t5.returnZ = this.hasZ, t5.returnM = this.hasM;
    const s4 = await this._layer.queryFeatures(t5);
    return 1 === s4.features.length ? s4.features[0] : null;
  }
  async getOwningSystemUrl() {
    return "";
  }
  async getIdentityUser() {
    return "";
  }
  get preferredTimeZone() {
    return "preferredTimeZone" in this._layer ? this._layer.preferredTimeZone : null;
  }
  get dateFieldsTimeZone() {
    return "dateFieldsTimeZone" in this._layer ? this._layer.dateFieldsTimeZone : null;
  }
  get datesInUnknownTimezone() {
    return "datesInUnknownTimezone" in this._layer && this._layer.datesInUnknownTimezone;
  }
  get editFieldsInfo() {
    return "editFieldsInfo" in this._layer ? this._layer.editFieldsInfo : null;
  }
  get timeInfo() {
    var _a;
    return (_a = this._layer) == null ? void 0 : _a.timeInfo;
  }
  async getFeatureSetInfo() {
    const e3 = this._layer.title && this._layer.parent;
    return this.fsetInfo ?? { layerId: null, layerName: null, itemId: null, serviceLayerUrl: null, webMapLayerId: e3 ? this._layer.id ?? null : null, webMapLayerTitle: e3 ? this._layer.title ?? null : null, className: null, objectClassId: null };
  }
};

// node_modules/@arcgis/core/arcade/featureset/sources/FeatureLayerRelated.js
var d4 = class extends C {
  constructor(e3) {
    super(e3), this.declaredClass = "esri.arcade.featureset.sources.FeatureLayerRelated", this._findObjectId = -1, this._requestStandardised = false, this._removeGeometry = false, this._overrideFields = null, this.featureObjectId = null, e3.spatialReference && (this.spatialReference = e3.spatialReference), this._transparent = true, this._maxProcessing = 1e3, this._layer = e3.layer, this._wset = null, this._findObjectId = e3.objectId, this.featureObjectId = e3.objectId, this.relationship = e3.relationship, this._relatedLayer = e3.relatedLayer, void 0 !== e3.outFields && (this._overrideFields = e3.outFields), void 0 !== e3.includeGeometry && (this._removeGeometry = false === e3.includeGeometry);
  }
  _maxQueryRate() {
    return D;
  }
  end() {
    return this._layer;
  }
  optimisePagingFeatureQueries() {
  }
  async loadImpl() {
    var _a;
    return await Promise.all([this._layer.load(), (_a = this._relatedLayer) == null ? void 0 : _a.load()]), this._initialiseFeatureSet(), this;
  }
  nativeCapabilities() {
    return this._relatedLayer.nativeCapabilities();
  }
  _initialiseFeatureSet() {
    if (null == this.spatialReference && (this.spatialReference = this._layer.spatialReference), this.geometryType = this._relatedLayer.geometryType, this.fields = this._relatedLayer.fields.slice(), this.hasZ = this._relatedLayer.hasZ, this.hasM = this._relatedLayer.hasM, null !== this._overrideFields) if (1 === this._overrideFields.length && "*" === this._overrideFields[0]) this._overrideFields = null;
    else {
      const e4 = [], t5 = [];
      for (const r2 of this.fields) if ("oid" === r2.type) e4.push(r2), t5.push(r2.name);
      else for (const i2 of this._overrideFields) if (i2.toLowerCase() === r2.name.toLowerCase()) {
        e4.push(r2), t5.push(r2.name);
        break;
      }
      this.fields = e4, this._overrideFields = t5;
    }
    const e3 = this._layer.nativeCapabilities();
    e3 && (this._databaseType = e3.databaseType, this._requestStandardised = e3.requestStandardised), this.objectIdField = this._relatedLayer.objectIdField, this.globalIdField = this._relatedLayer.globalIdField, this.hasM = this._relatedLayer.supportsM, this.hasZ = this._relatedLayer.supportsZ, this.typeIdField = this._relatedLayer.typeIdField, this.types = this._relatedLayer.types, this.subtypeField = this._relatedLayer.subtypeField, this.subtypes = this._relatedLayer.subtypes;
  }
  async databaseType() {
    return await this._relatedLayer.databaseType(), this._databaseType = this._relatedLayer._databaseType, this._databaseType;
  }
  isTable() {
    return this._relatedLayer.isTable();
  }
  _isInFeatureSet() {
    return s.InFeatureSet;
  }
  _candidateIdTransform(e3) {
    return e3;
  }
  async _getSet(e3) {
    if (null === this._wset) {
      await this._ensureLoaded();
      const t5 = await this._getFilteredSet("", null, null, null, e3);
      return this._wset = t5, t5;
    }
    return this._wset;
  }
  _changeFeature(t5) {
    const r2 = {};
    for (const e3 of this.fields) r2[e3.name] = t5.attributes[e3.name];
    return new d2({ geometry: true === this._removeGeometry ? null : t5.geometry, attributes: r2 });
  }
  async _getFilteredSet(e3, t5, r2, i2, a6) {
    var _a, _b;
    if (await this.databaseType(), this.isTable() && t5 && null !== e3 && "" !== e3) {
      return new t3([], [], true, null);
    }
    const n9 = this._layer.nativeCapabilities();
    if (false === n9.canQueryRelated) {
      return new t3([], [], true, null);
    }
    if ((_a = n9.capabilities) == null ? void 0 : _a.queryRelated.supportsPagination) return this._getFilteredSetUsingPaging(e3, t5, r2, i2, a6);
    let d5 = "", o = false;
    null !== i2 && true === ((_b = n9.capabilities) == null ? void 0 : _b.queryRelated.supportsOrderBy) && (d5 = i2.constructClause(), o = true);
    const u2 = new d3();
    u2.objectIds = [this._findObjectId];
    const h2 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._relatedLayer.fields ? this._relatedLayer.fields.map((e4) => e4.name) : ["*"]);
    u2.outFields = h2, u2.relationshipId = this.relationship.id, u2.where = "1=1";
    let c5 = true;
    true === this._removeGeometry && (c5 = false), u2.returnGeometry = c5, this._requestStandardised && (u2.sqlFormat = "standard"), u2.outSpatialReference = this.spatialReference, u2.orderByFields = "" !== d5 ? d5.split(",") : null;
    const y3 = await n9.source.queryRelatedFeatures(u2);
    this._checkCancelled(a6);
    const p2 = y3[this._findObjectId] ? y3[this._findObjectId].features : [], _ = [];
    for (let s4 = 0; s4 < p2.length; s4++) this._featureCache[p2[s4].attributes[this._relatedLayer.objectIdField]] = p2[s4], _.push(p2[s4].attributes[this._relatedLayer.objectIdField]);
    const f7 = t5 && null !== e3 && "" !== e3, g5 = null != r2;
    return new t3(f7 || g5 ? _ : [], f7 || g5 ? [] : _, o, null);
  }
  _fieldsIncludingObjectId(e3) {
    if (null === e3) return [this.objectIdField];
    const t5 = e3.slice();
    if (t5.includes("*")) return t5;
    let r2 = false;
    for (const i2 of t5) if (i2.toUpperCase() === this.objectIdField.toUpperCase()) {
      r2 = true;
      break;
    }
    return false === r2 && t5.push(this.objectIdField), t5;
  }
  async _getFilteredSetUsingPaging(e3, t5, r2, i2, a6) {
    var _a, _b;
    let n9 = "", l2 = false;
    const d5 = this._layer.nativeCapabilities();
    null !== i2 && true === ((_a = d5.capabilities) == null ? void 0 : _a.queryRelated.supportsOrderBy) && (n9 = i2.constructClause(), l2 = true), await this.databaseType();
    const o = "1=1";
    let u2 = this._maxQueryRate();
    const h2 = (_b = d5.capabilities) == null ? void 0 : _b.query.maxRecordCount;
    null != h2 && h2 < u2 && (u2 = h2);
    const c5 = t5 && null !== e3 && "" !== e3, y3 = null != r2;
    let p2 = null, _ = true;
    true === this._removeGeometry && (_ = false);
    const f7 = null !== this._overrideFields ? this._overrideFields : this._fieldsIncludingObjectId(this._relatedLayer.fields ? this._relatedLayer.fields.map((e4) => e4.name) : ["*"]);
    return p2 = new t3(c5 || y3 ? ["GETPAGES"] : [], c5 || y3 ? [] : ["GETPAGES"], l2, { outFields: f7.join(","), resultRecordCount: u2, resultOffset: 0, objectIds: [this._findObjectId], where: o, orderByFields: n9, returnGeometry: _, returnIdsOnly: "false", internal: { set: [], lastRetrieved: 0, lastPage: 0, fullyResolved: false } }), await this._expandPagedSet(p2, u2, 0, 0, a6), p2;
  }
  _expandPagedSet(e3, t5, r2, i2, s4) {
    return this._expandPagedSetFeatureSet(e3, t5, r2, i2, s4);
  }
  _clonePageDefinition(e3) {
    return null === e3 ? null : true !== e3.groupbypage ? { groupbypage: false, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, resultOffset: e3.resultOffset, where: e3.where, objectIds: e3.objectIds, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal } : { groupbypage: true, outFields: e3.outFields, resultRecordCount: e3.resultRecordCount, useOIDpagination: e3.useOIDpagination, generatedOid: e3.generatedOid, groupByFieldsForStatistics: e3.groupByFieldsForStatistics, resultOffset: e3.resultOffset, outStatistics: e3.outStatistics, geometry: e3.geometry, where: e3.where, objectIds: e3.objectIds, orderByFields: e3.orderByFields, returnGeometry: e3.returnGeometry, returnIdsOnly: e3.returnIdsOnly, internal: e3.internal };
  }
  async _getPhysicalPage(e3, t5, r2) {
    const i2 = e3.pagesDefinition.internal.lastRetrieved, s4 = i2, a6 = e3.pagesDefinition.internal.lastPage, n9 = this._layer.nativeCapabilities(), d5 = new d3();
    true === this._requestStandardised && (d5.sqlFormat = "standard"), d5.relationshipId = this.relationship.id, d5.objectIds = e3.pagesDefinition.objectIds, d5.resultOffset = e3.pagesDefinition.internal.lastPage, d5.resultRecordCount = e3.pagesDefinition.resultRecordCount, d5.outFields = e3.pagesDefinition.outFields.split(","), d5.where = e3.pagesDefinition.where, d5.orderByFields = "" !== e3.pagesDefinition.orderByFields ? e3.pagesDefinition.orderByFields.split(",") : null, d5.returnGeometry = e3.pagesDefinition.returnGeometry, d5.outSpatialReference = this.spatialReference;
    const o = await n9.source.queryRelatedFeatures(d5);
    if (this._checkCancelled(r2), e3.pagesDefinition.internal.lastPage !== a6) return 0;
    const u2 = o[this._findObjectId] ? o[this._findObjectId].features : [];
    for (let l2 = 0; l2 < u2.length; l2++) e3.pagesDefinition.internal.set[s4 + l2] = u2[l2].attributes[this._relatedLayer.objectIdField];
    for (let l2 = 0; l2 < u2.length; l2++) this._featureCache[u2[l2].attributes[this._relatedLayer.objectIdField]] = u2[l2];
    const h2 = !o[this._findObjectId] || false === o[this._findObjectId].exceededTransferLimit;
    return u2.length !== e3.pagesDefinition.resultRecordCount && h2 && (e3.pagesDefinition.internal.fullyResolved = true), e3.pagesDefinition.internal.lastRetrieved = i2 + u2.length, e3.pagesDefinition.internal.lastPage += e3.pagesDefinition.resultRecordCount, u2.length;
  }
  async _getFeatures(e3, i2, s4, a6) {
    const n9 = [];
    -1 !== i2 && void 0 === this._featureCache[i2] && n9.push(i2);
    const l2 = this._maxQueryRate();
    if (true === this._checkIfNeedToExpandKnownPage(e3, l2)) return await this._expandPagedSet(e3, l2, 0, 0, a6), this._getFeatures(e3, i2, s4, a6);
    let d5 = 0;
    for (let t5 = e3._lastFetchedIndex; t5 < e3._known.length && (d5++, d5 <= s4 && (e3._lastFetchedIndex += 1), !("GETPAGES" !== e3._known[t5] && void 0 === this._featureCache[e3._known[t5]] && (e3._known[t5] !== i2 && n9.push(e3._known[t5]), n9.length > s4))) && !(d5 >= s4 && 0 === n9.length); t5++) ;
    if (0 === n9.length) return "success";
    throw new s2(t2.MissingFeatures);
  }
  async _refineSetBlock(e3, t5, r2) {
    return e3;
  }
  async _stat(e3, t5, r2, i2, s4, a6, n9) {
    return { calculated: false };
  }
  get gdbVersion() {
    return this._relatedLayer.gdbVersion;
  }
  async _canDoAggregates(e3, t5, r2, i2, s4) {
    return false;
  }
  relationshipMetaData() {
    return this._relatedLayer.relationshipMetaData();
  }
  serviceUrl() {
    return this._relatedLayer.serviceUrl();
  }
  queryAttachments(e3, t5, r2, i2, s4) {
    return this._relatedLayer.queryAttachments(e3, t5, r2, i2, s4);
  }
  getFeatureByObjectId(e3, t5) {
    return this._relatedLayer.getFeatureByObjectId(e3, t5);
  }
  getOwningSystemUrl() {
    return this._relatedLayer.getOwningSystemUrl();
  }
  getIdentityUser() {
    return this._relatedLayer.getIdentityUser();
  }
  getDataSourceFeatureSet() {
    return this._relatedLayer;
  }
  get preferredTimeZone() {
    var _a;
    return ((_a = this._relatedLayer) == null ? void 0 : _a.preferredTimeZone) ?? null;
  }
  get dateFieldsTimeZone() {
    var _a;
    return ((_a = this._relatedLayer) == null ? void 0 : _a.dateFieldsTimeZone) ?? null;
  }
  get datesInUnknownTimezone() {
    var _a;
    return (_a = this._relatedLayer) == null ? void 0 : _a.datesInUnknownTimezone;
  }
  get editFieldsInfo() {
    var _a;
    return ((_a = this._relatedLayer) == null ? void 0 : _a.editFieldsInfo) ?? null;
  }
  get timeInfo() {
    var _a;
    return ((_a = this._relatedLayer) == null ? void 0 : _a.timeInfo) ?? null;
  }
  async getFeatureSetInfo() {
    return this.fsetInfo ?? this._layer.featureSetInfo;
  }
};

// node_modules/@arcgis/core/arcade/featureSetUtils.js
function g4() {
  null === a2.applicationCache && (a2.applicationCache = new a2());
}
async function F3(e3, t5, a6) {
  if (a2.applicationCache) {
    const a7 = a2.applicationCache.getLayerInfo(e3);
    if (a7) {
      const r2 = await a7;
      return new Xe({ url: e3, outFields: t5, sourceJSON: r2 });
    }
    const n9 = new Xe({ url: e3, outFields: t5 }), i2 = (async () => (await n9.load(), n9.sourceJSON))();
    if (a2.applicationCache) {
      a2.applicationCache.setLayerInfo(e3, i2);
      try {
        return await i2, n9;
      } catch (r2) {
        throw a2.applicationCache.clearLayerInfo(e3), r2;
      }
    }
    return await i2, n9;
  }
  if (null != a6) {
    const r2 = a6.getCachedLayerMetadata(e3);
    if (r2) {
      const a7 = await r2;
      return new Xe({ url: e3, outFields: t5, sourceJSON: a7 });
    }
    const i2 = new Xe({ url: e3, outFields: t5 }), l2 = (async () => (await i2.load(), i2.sourceJSON))();
    a6.setCachedLayerMetadata(e3, l2);
    try {
      return await l2, i2;
    } catch (n9) {
      throw a6.removeCachedLayerMetadata(e3, l2), n9;
    }
  }
  return new Xe({ url: e3, outFields: t5 });
}
async function N3(e3, t5, a6, r2, n9, i2 = null) {
  return T3(await F3(e3, ["*"], n9), t5, a6, r2, n9, i2);
}
function T3(e3, t5 = null, a6 = null, r2 = true, n9 = null, i2 = null) {
  switch (e3.type) {
    case "catalog-footprint":
      return T3(e3.parent, t5, a6, r2, n9, i2);
    case "subtype-sublayer": {
      const l2 = T3(e3.parent, t5, a6, r2, n9, i2);
      return l2.filter(Z.create(e3.parent.subtypeField + "=" + e3.subtypeCode.toString(), { fieldsIndex: e3.parent.fieldsIndex, timeZone: l2.dateFieldsTimeZoneDefaultUTC }));
    }
    case "csv":
    case "geojson":
    case "wfs":
      return new f6({ layer: e3, spatialReference: t5, outFields: a6, includeGeometry: r2, lrucache: n9, interceptor: i2 });
    case "catalog":
    case "feature":
    case "oriented-imagery":
    case "subtype-group": {
      const l2 = { layer: e3, spatialReference: t5, outFields: a6, includeGeometry: r2, lrucache: n9, interceptor: i2 };
      return !e3.url && e3.source ? new f6(l2) : new P(l2);
    }
    default:
      throw new Error(`Unsupported layer type: ${e3.type}`);
  }
}
async function A2(t5) {
  if (null !== a2.applicationCache) {
    const e3 = a2.applicationCache.getLayerInfo(t5);
    if (null !== e3) return e3;
  }
  const a6 = (async () => {
    const a7 = await U(t5, { responseType: "json", query: { f: "json" } });
    return a7.data ? a7.data : null;
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(t5, a6);
    try {
      return await a6;
    } catch (r2) {
      throw a2.applicationCache.clearLayerInfo(t5), r2;
    }
  }
  return a6;
}
async function b3(t5, a6) {
  const r2 = "QUERYDATAELEMTS:" + a6.toString() + ":" + t5;
  if (null !== a2.applicationCache) {
    const e3 = a2.applicationCache.getLayerInfo(r2);
    if (null !== e3) return e3;
  }
  const n9 = (async () => {
    var _a;
    const r3 = await U(t5 + "/queryDataElements", { method: "post", responseType: "json", query: { layers: JSON.stringify([a6.toString()]), f: "json" } });
    if (r3.data) {
      const e3 = r3.data;
      if ((_a = e3.layerDataElements) == null ? void 0 : _a[0]) return e3.layerDataElements[0];
    }
    throw new s2(t2.DataElementsNotFound);
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(r2, n9);
    try {
      return await n9;
    } catch (i2) {
      throw a2.applicationCache.clearLayerInfo(r2), i2;
    }
  }
  return n9;
}
async function k3(t5, a6) {
  if (null !== a2.applicationCache) {
    const e3 = a2.applicationCache.getLayerInfo(t5);
    if (null !== e3) return e3;
  }
  if (null != a6) {
    const e3 = a6.getCachedServiceMetadata(t5);
    if (null != e3) return e3;
  }
  const r2 = (async () => {
    const a7 = await U(t5, { responseType: "json", query: { f: "json" } });
    if (a7.data) {
      const e3 = a7.data;
      return e3.layers || (e3.layers = []), e3.tables || (e3.tables = []), e3;
    }
    return { layers: [], tables: [] };
  })();
  if (null !== a2.applicationCache) {
    a2.applicationCache.setLayerInfo(t5, r2);
    try {
      return await r2;
    } catch (n9) {
      throw a2.applicationCache.clearLayerInfo(t5), n9;
    }
  }
  if (null != a6) {
    a6.setCachedServiceMetadata(t5, r2);
    try {
      return await r2;
    } catch (i2) {
      throw a6.removeCachedServiceMetadata(t5, r2), i2;
    }
  }
  return r2;
}
async function O3(e3, t5) {
  var _a, _b, _c;
  const a6 = { metadata: null, networkId: -1, unVersion: 3, terminals: [], queryelem: null, layerNameLkp: {}, lkp: null }, r2 = await k3(e3, null);
  if (a6.metadata = r2, void 0 !== ((_a = r2.controllerDatasetLayers) == null ? void 0 : _a.utilityNetworkLayerId) && null !== r2.controllerDatasetLayers.utilityNetworkLayerId) {
    if (r2.layers) for (const e4 of r2.layers) a6.layerNameLkp[e4.id] = e4.name;
    if (r2.tables) for (const e4 of r2.tables) a6.layerNameLkp[e4.id] = e4.name;
    const n9 = r2.controllerDatasetLayers.utilityNetworkLayerId;
    a6.networkId = n9;
    const i2 = await b3(e3, n9);
    if (i2) {
      a6.queryelem = i2, ((_b = a6.queryelem) == null ? void 0 : _b.dataElement) && void 0 !== a6.queryelem.dataElement.schemaGeneration && (a6.unVersion = a6.queryelem.dataElement.schemaGeneration), a6.lkp = {}, a6.queryelem.dataElement.domainNetworks || (a6.queryelem.dataElement.domainNetworks = []);
      for (const e4 of a6.queryelem.dataElement.domainNetworks) {
        for (const t6 of e4.edgeSources ?? []) {
          const e5 = { layerId: t6.layerId, sourceId: t6.sourceId, className: a6.layerNameLkp[t6.layerId] ?? null };
          e5.className && (a6.lkp[e5.className] = e5);
        }
        for (const t6 of e4.junctionSources ?? []) {
          const e5 = { layerId: t6.layerId, sourceId: t6.sourceId, className: a6.layerNameLkp[t6.layerId] ?? null };
          e5.className && (a6.lkp[e5.className] = e5);
        }
      }
      if (a6.queryelem.dataElement.terminalConfigurations) for (const e4 of a6.queryelem.dataElement.terminalConfigurations) for (const t6 of e4.terminals) a6.terminals.push({ terminalId: t6.terminalId, terminalName: t6.terminalName });
      const r3 = await A2(e3 + "/" + n9);
      if (void 0 !== ((_c = r3.systemLayers) == null ? void 0 : _c.associationsTableId) && null !== r3.systemLayers.associationsTableId) {
        const n10 = [];
        a6.unVersion >= 4 && (n10.push("STATUS"), n10.push("PERCENTALONG"));
        let i3 = await N3(e3 + "/" + r3.systemLayers.associationsTableId.toString(), t5, ["OBJECTID", "FROMNETWORKSOURCEID", "TONETWORKSOURCEID", "FROMGLOBALID", "TOGLOBALID", "TOTERMINALID", "FROMTERMINALID", "ASSOCIATIONTYPE", "ISCONTENTVISIBLE", "GLOBALID", ...n10], false, null, null);
        return await i3.load(), a6.unVersion >= 4 && (i3 = i3.filter(Z.create("STATUS NOT IN (1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 30, 31, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63)", { fieldsIndex: i3.getFieldsIndex(), timeZone: i3.dateFieldsTimeZoneDefaultUTC })), await i3.load()), { lkp: a6.lkp, associations: i3, unVersion: a6.unVersion, terminals: a6.terminals };
      }
      return { associations: null, unVersion: a6.unVersion, lkp: null, terminals: [] };
    }
    return { associations: null, unVersion: a6.unVersion, lkp: null, terminals: [] };
  }
  return { associations: null, unVersion: a6.unVersion, lkp: null, terminals: [] };
}
async function E2(e3, t5, a6, r2 = null, n9 = null, i2 = true, l2 = null, s4 = null) {
  let o = e3.serviceUrl();
  if (!o) return null;
  o = "/" === o.charAt(o.length - 1) ? o + t5.relatedTableId.toString() : o + "/" + t5.relatedTableId.toString();
  const u2 = await N3(o, r2, n9, i2, l2, s4);
  return new d4({ layer: e3, relatedLayer: u2, relationship: t5, objectId: a6, spatialReference: r2, outFields: n9, includeGeometry: i2, lrucache: l2, interceptor: s4 });
}
c4.registerAction(), O2.registerAction(), a3.registerAction(), f5.registerAction(), a5.registerAction();
var j2 = class extends e {
  constructor(e3, t5 = null, a6 = null, r2 = null) {
    super(), this._map = e3, this._overrideSpatialReference = t5, this._lrucache = a6, this._interceptor = r2, this._instantLayers = [];
  }
  _makeAndAddFeatureSet(e3, t5 = true, a6 = null) {
    const r2 = T3(e3, this._overrideSpatialReference, null === a6 ? ["*"] : a6, t5, this._lrucache, this._interceptor);
    return this._instantLayers.push({ featureset: r2, opitem: e3, includeGeometry: t5, outFields: JSON.stringify(a6) }), r2;
  }
  async featureSetByName(e3, t5 = true, a6 = null) {
    if (m2.isLoadable(this._map) && !this._map.loaded) return await this._map.load(), this.featureSetByName(e3, t5, a6);
    null === a6 && (a6 = ["*"]), a6 = (a6 = a6.slice()).sort();
    const r2 = JSON.stringify(a6);
    for (let i2 = 0; i2 < this._instantLayers.length; i2++) {
      const a7 = this._instantLayers[i2];
      if (a7.opitem.title === e3 && a7.includeGeometry === t5 && a7.outFields === r2) return this._instantLayers[i2].featureset;
    }
    const n9 = this._map.allLayers.find((t6) => j(t6) && t6.title === e3);
    if (null != n9) return this._makeAndAddFeatureSet(n9, t5, a6);
    if (this._map.tables) {
      const r3 = this._map.tables.find((t6) => t6.title === e3);
      if (null != r3) {
        if (r3 instanceof Xe) return this._makeAndAddFeatureSet(r3, t5, a6);
        if (null == r3._materializedTable) {
          const e4 = r3.outFields ? r3 : { ...r3, outFields: ["*"] };
          r3._materializedTable = new Xe(e4);
        }
        return await r3._materializedTable.load(), this._makeAndAddFeatureSet(r3._materializedTable, t5, a6);
      }
    }
    return null;
  }
  async featureSetById(e3, t5 = true, a6 = ["*"]) {
    if (m2.isLoadable(this._map) && !this._map.loaded) return await this._map.load(), this.featureSetById(e3, t5, a6);
    null === a6 && (a6 = ["*"]), a6 = (a6 = a6.slice()).sort();
    const r2 = JSON.stringify(a6);
    for (let i2 = 0; i2 < this._instantLayers.length; i2++) {
      const a7 = this._instantLayers[i2];
      if (a7.opitem.id === e3 && a7.includeGeometry === t5 && a7.outFields === r2) return this._instantLayers[i2].featureset;
    }
    const n9 = this._map.allLayers.find((t6) => j(t6) && t6.id === e3);
    if (n9) return this._makeAndAddFeatureSet(n9, t5, a6);
    if (this._map.tables) {
      const r3 = this._map.tables.find((t6) => t6.id === e3);
      if (null != r3) {
        if (r3 instanceof Xe) return this._makeAndAddFeatureSet(r3, t5, a6);
        if (null == r3._materializedTable) {
          const e4 = { ...r3, outFields: ["*"] };
          r3._materializedTable = new Xe(e4);
        }
        return await r3._materializedTable.load(), this._makeAndAddFeatureSet(r3._materializedTable, t5, a6);
      }
    }
    return null;
  }
};
var D3 = class _D extends e {
  constructor(e3, t5 = null, a6 = null, r2 = null) {
    super(), this._url = e3, this._overrideSpatialReference = t5, this._lrucache = a6, this._interceptor = r2, this.metadata = null, this._instantLayers = [];
  }
  get url() {
    return this._url;
  }
  _makeAndAddFeatureSet(e3, t5 = true, a6 = null) {
    const r2 = T3(e3, this._overrideSpatialReference, null === a6 ? ["*"] : a6, t5, this._lrucache);
    return this._instantLayers.push({ featureset: r2, opitem: e3, includeGeometry: t5, outFields: JSON.stringify(a6) }), r2;
  }
  async _loadMetaData() {
    const e3 = await k3(this._url, this._lrucache);
    return this.metadata = e3, e3;
  }
  load() {
    return this._loadMetaData();
  }
  clone() {
    return new _D(this._url, this._overrideSpatialReference, this._lrucache, this._interceptor);
  }
  async featureSetByName(e3, t5 = true, a6 = null) {
    null === a6 && (a6 = ["*"]), a6 = (a6 = a6.slice()).sort();
    const r2 = JSON.stringify(a6);
    for (let l2 = 0; l2 < this._instantLayers.length; l2++) {
      const a7 = this._instantLayers[l2];
      if (a7.opitem.title === e3 && a7.includeGeometry === t5 && a7.outFields === r2) return this._instantLayers[l2].featureset;
    }
    const n9 = await this._loadMetaData();
    let i2 = null;
    for (const l2 of n9.layers ?? []) l2.name === e3 && (i2 = l2);
    if (!i2) for (const l2 of n9.tables ?? []) l2.name === e3 && (i2 = l2);
    if (i2) {
      const e4 = await F3(this._url + "/" + i2.id, ["*"], this._lrucache);
      return this._makeAndAddFeatureSet(e4, t5, a6);
    }
    return null;
  }
  async featureSetById(e3, t5 = true, a6 = ["*"]) {
    null === a6 && (a6 = ["*"]), a6 = (a6 = a6.slice()).sort();
    const r2 = JSON.stringify(a6);
    e3 = null != e3 ? e3.toString() : "";
    for (let l2 = 0; l2 < this._instantLayers.length; l2++) {
      const a7 = this._instantLayers[l2];
      if (a7.opitem.id === e3 && a7.includeGeometry === t5 && a7.outFields === r2) return this._instantLayers[l2].featureset;
    }
    const n9 = await this._loadMetaData();
    let i2 = null;
    for (const l2 of n9.layers ?? []) null !== l2.id && void 0 !== l2.id && l2.id.toString() === e3 && (i2 = l2);
    if (!i2) for (const l2 of n9.tables ?? []) null !== l2.id && void 0 !== l2.id && l2.id.toString() === e3 && (i2 = l2);
    if (i2) {
      const e4 = await F3(this._url + "/" + i2.id, ["*"], this._lrucache);
      return this._makeAndAddFeatureSet(e4, t5, a6);
    }
    return null;
  }
};
function v(e3, t5, a6 = null, r2 = null) {
  return new j2(e3, t5, a6, r2);
}
function R2(e3, t5, a6 = null, r2 = null) {
  return new D3(e3, t5, a6, r2);
}
function M2(e3, t5, n9, i2, l2) {
  if (null === e3) return null;
  if (K(e3)) {
    switch (t5) {
      case "datasource":
        return e3.getDataSourceFeatureSet();
      case "parent":
        return e3;
      case "root":
        return e3.getRootFeatureSet();
    }
    return null;
  }
  if (e3 instanceof f3 && M(e3)) {
    const a6 = e3;
    switch (t5) {
      case "datasource":
        return T3(a6, l2, a6.outFields, true, n9, i2).getDataSourceFeatureSet();
      case "parent":
      case "root":
        return T3(a6, l2, a6.outFields, true, n9, i2);
    }
    return null;
  }
  if (ze(e3)) {
    switch (t5) {
      case "datasource":
        return T3(e3.parent, l2, e3.parent.outFields, true, n9, i2).getDataSourceFeatureSet();
      case "parent":
      case "root":
        return T3(e3, l2, e3.parent.outFields, true, n9, i2);
    }
    return null;
  }
  return null;
}
async function q(e3, t5, a6, r2, n9, i2, l2, s4 = null) {
  if (a2.applicationCache) {
    const o2 = a2.applicationCache.getLayerInfo(e3 + ":" + i2.url);
    if (o2) return G2(await o2, t5, a6, r2, n9, l2, s4);
  }
  if (null != l2) {
    const o2 = l2.getCachedPortalItem(i2.url, e3);
    if (null != o2) return await G2(await o2, t5, a6, r2, n9, l2, s4);
  }
  const o = new S2({ id: e3, portal: i2 }).load();
  a2.applicationCache ? a2.applicationCache.setLayerInfo(e3 + ":" + i2.url, o) : null != l2 && l2.setCachedPortalItem(i2.url, e3, o);
  try {
    return await G2(await o, t5, a6, r2, n9, l2, s4);
  } catch (u2) {
    throw a2.applicationCache && a2.applicationCache.clearLayerInfo(e3 + ":" + i2.url), null != l2 && l2.removeCachedPortalItem(i2.url, e3, o), u2;
  }
}
async function G2(e3, t5, a6, r2, n9, i2, l2) {
  let s4;
  if ("Feature Service" === e3.type || "Map Service" === e3.type) s4 = await F3(k(e3.url ?? "") + "/" + t5, ["*"], i2);
  else {
    if (t5) throw new Error(`layerId=${t5} provided for ${e3.type} item`);
    if (null != i2) {
      const t6 = i2.getCachedPortalItemLayer(e3.portal.url, e3.id);
      if (null != t6) s4 = await t6;
      else {
        const t7 = f3.fromPortalItem(e3);
        i2.setCachedPortalItemLayer(e3.portal.url, e3.id, t7);
        try {
          s4 = await t7;
        } catch (o) {
          throw i2.removeCachedPortalItemLayer(e3.portal.url, e3.id, t7), o;
        }
      }
    } else s4 = await f3.fromPortalItem(e3);
  }
  return T3(s4, a6, r2, n9, i2, l2);
}

export {
  c4 as c,
  k2 as k,
  b2 as b,
  B,
  L2 as L,
  R,
  e2 as e,
  a3 as a,
  a5 as a2,
  f6 as f,
  g4 as g,
  N3 as N,
  T3 as T,
  O3 as O,
  E2 as E,
  v,
  R2,
  M2 as M,
  q
};
//# sourceMappingURL=chunk-7SEW7HZS.js.map
