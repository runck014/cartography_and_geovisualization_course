import {
  i as i2,
  t2,
  t3
} from "./chunk-OBWNWUWS.js";
import {
  n4 as n
} from "./chunk-CGJR3XCF.js";
import {
  C2,
  G2 as G,
  H2 as H,
  I as I2,
  P,
  S,
  e as e2,
  g,
  h as h2,
  hn,
  j,
  j2,
  le,
  m,
  tt,
  v,
  w
} from "./chunk-JI3JMSDL.js";
import {
  r as r2
} from "./chunk-JMY2H33H.js";
import {
  mt
} from "./chunk-CAQ63GSR.js";
import {
  E as E2,
  e as e3
} from "./chunk-JRUJALSE.js";
import {
  t
} from "./chunk-EHD5KM2T.js";
import {
  C,
  E,
  I,
  O
} from "./chunk-KV3S4QI2.js";
import {
  M,
  f,
  h,
  i,
  o
} from "./chunk-D6FJTDNK.js";
import {
  L
} from "./chunk-IJO7BOFI.js";
import {
  u as u2
} from "./chunk-2TEGRXBS.js";
import {
  d
} from "./chunk-DRBJFCLQ.js";
import {
  e,
  r
} from "./chunk-MV5XBD6C.js";
import {
  u
} from "./chunk-R2PAF6JT.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/OverlayShader.js
var x = class extends I2 {
};
r([h2(0, C2)], x.prototype, "pos", void 0), r([h2(1, C2)], x.prototype, "uv", void 0);
var h3 = class extends v {
};
var w2 = class extends P {
};
r([g(tt)], w2.prototype, "dvs", void 0);
var S2 = class extends P {
};
r([g(C2)], S2.prototype, "perspective", void 0), r([g(C2)], S2.prototype, "texSize", void 0), r([g(j)], S2.prototype, "wrapAroundShift", void 0), r([g(j)], S2.prototype, "opacity", void 0), r([g(S)], S2.prototype, "texture", void 0);
var j3 = class extends j2 {
  vertex(t4) {
    const o2 = t4.uv.divide(this.config.texSize), e4 = new j(1).add(hn(o2, this.config.perspective)), r3 = new G(t4.pos.add(new C2(this.config.wrapAroundShift, 0)), 1), p = this.transform.dvs.multiply(r3);
    return { uv: o2, glPosition: new H(p.xy.multiply(e4), 0, e4) };
  }
  fragment(t4) {
    const o2 = le(this.config.texture, t4.uv).multiply(this.config.opacity), e4 = new w();
    return e4.glFragColor = o2, e4;
  }
};
r([g(w2)], j3.prototype, "transform", void 0), r([g(S2)], j3.prototype, "config", void 0), r([e(0, m(x))], j3.prototype, "vertex", null), r([e(0, m(h3))], j3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/overlay/OverlayTechnique.js
var u3 = class extends t3 {
  constructor() {
    super(...arguments), this.type = e2.Overlay, this._mesh = null, this.shaders = { overlay: new j3() };
  }
  render(e4, t4) {
    const { context: i3, painter: o2 } = e4, r3 = this._getMesh(e4, t4);
    o2.setPipelineState(t2);
    const { isWrapAround: p, wrapAroundShift: h4 } = t4.config, u5 = { ...t4.config, wrapAroundShift: 0 }, m2 = { shader: this.shaders.overlay, uniforms: { transform: t4.transform, config: u5 }, defines: null, optionalAttributes: null, useComputeBuffer: false };
    o2.setPipelineState({ ...t2, stencil: { write: false, test: { compare: O.EQUAL, op: { fail: I.KEEP, zFail: I.KEEP, zPass: I.REPLACE }, ref: 0, mask: 255 } } }), o2.submitDrawMeshUntyped(i3, m2, r3), p && (u5.wrapAroundShift = h4, o2.submitDrawMeshUntyped(i3, m2, r3));
  }
  shutdown() {
    u(this._mesh);
  }
  _getMesh(e4, s) {
    const { context: i3 } = e4;
    if (this._mesh) {
      const e5 = this._mesh.vertexBuffers.get("positions");
      if (!e5) throw new Error("Buffer not found");
      e5.setData(s.position);
    } else {
      const e5 = null != s.index ? s.index.length : s.position.length / 2;
      this._mesh = new i2(i3, { vertex: { positions: s.position, uvs: s.tex }, index: null != s.index ? { index: s.index } : void 0, groups: [{ attributes: [{ name: "pos", count: 2, type: C.FLOAT, location: 0, vertex: "positions", stride: 8, offset: 0 }, { name: "tex", count: 2, type: C.UNSIGNED_SHORT, location: 1, vertex: "uvs", stride: 4, offset: 0 }], index: null != s.index ? "index" : void 0, primitive: E.TRIANGLE_STRIP }], parts: [{ group: 0, start: 0, count: e5 }] });
    }
    return this._mesh;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/OverlayContainer.js
var u4 = class extends n {
  constructor() {
    super(...arguments), this._viewStateId = -1, this._dvsMat3 = e3(), this._overlayTechnique = new u3();
  }
  get dvsMat3() {
    return this._dvsMat3;
  }
  beforeRender(t4) {
    this._updateMatrices(t4), this._updateOverlays(t4, this.children);
    for (const e4 of this.children) e4.beforeRender(t4);
  }
  doRender(t4) {
    if (t4.drawPhase !== E2.MAP || !this.visible) return;
    super.doRender(t4);
    const e4 = this._overlayTechnique;
    for (const r3 of this.children) r3.draw(t4, e4);
  }
  onDetach() {
    this._overlayTechnique.shutdown();
  }
  _updateMatrices(a) {
    const { state: h4 } = a, { id: m2, size: d2, pixelRatio: p, resolution: f2, rotation: u5, viewpoint: v2, displayMat3: _ } = h4;
    if (this._viewStateId === m2) return;
    const M2 = u2(u5), g2 = p * d2[0], y = p * d2[1];
    this._localOrigin = v2.targetGeometry.clone();
    const { x: w3, y: x2 } = this._localOrigin, b = L(w3, h4.spatialReference);
    this._localOrigin.x = b, this._localOrigin.y = x2;
    const j4 = f2 * g2, O2 = f2 * y, R = o(this._dvsMat3);
    i(R, R, _), M(R, R, t(g2 / 2, y / 2)), f(R, R, r2(g2 / j4, -y / O2, 1)), h(R, R, -M2), this._viewStateId = m2;
  }
  _updateOverlays(e4, r3) {
    const { state: o2 } = e4, { rotation: i3, spatialReference: s, worldScreenWidth: a, size: n2, viewpoint: l } = o2, c = this._localOrigin;
    let d2, p = 0;
    const f2 = d(s);
    if (f2 && s.isWrappable) {
      const e5 = n2[0], r4 = n2[1], c2 = u2(i3), h4 = Math.abs(Math.cos(c2)), u5 = Math.abs(Math.sin(c2)), v2 = Math.round(e5 * h4 + r4 * u5), [_, M2] = f2.valid, g2 = mt(s), { x: y, y: w3 } = l.targetGeometry, x2 = [y, w3], b = [0, 0];
      o2.toScreen(b, x2);
      const j4 = [0, 0];
      let O2;
      O2 = v2 > a ? 0.5 * a : 0.5 * v2;
      const R = Math.floor((y + 0.5 * g2) / g2), q = _ + R * g2, S3 = M2 + R * g2, G2 = [b[0] + O2, 0];
      o2.toMap(j4, G2), j4[0] > S3 && (p = g2), G2[0] = b[0] - O2, o2.toMap(j4, G2), j4[0] < q && (p = -g2), d2 = { worldWidth: g2, xBounds: [_, M2] };
    }
    for (const t4 of r3) t4.updateDrawCoords(c, p, s, d2);
  }
};

export {
  u4 as u
};
//# sourceMappingURL=chunk-KJECNQ2J.js.map
