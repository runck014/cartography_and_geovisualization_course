import {
  p as p2
} from "./chunk-QKS6PIY6.js";
import {
  A
} from "./chunk-R5BTSPWT.js";
import {
  d
} from "./chunk-G54IOEGF.js";
import {
  b as b2
} from "./chunk-WGIZLWW7.js";
import {
  i as i2,
  p
} from "./chunk-AMH7OVBF.js";
import {
  h5 as h
} from "./chunk-LEOFRCUR.js";
import {
  me,
  ye
} from "./chunk-6D5XULXX.js";
import {
  e as e2
} from "./chunk-445IB4DS.js";
import {
  x
} from "./chunk-6RLUKSNK.js";
import {
  e
} from "./chunk-VEUN2EF3.js";
import {
  b
} from "./chunk-QSRFVAIF.js";
import {
  r as r2
} from "./chunk-L6D73M4D.js";
import {
  n
} from "./chunk-7O7KFKCG.js";
import {
  i
} from "./chunk-X7VTUWCX.js";
import {
  f
} from "./chunk-VU6O6TFT.js";
import {
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a2,
  u4 as u,
  w
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/layers/support/featureQueryAll.js
async function r3(e3, r4, a5) {
  r4 = r4.clone(), e3.capabilities.query.supportsMaxRecordCountFactor && (r4.maxRecordCountFactor = u2(e3));
  const n2 = t(e3), o = e3.capabilities.query.supportsPagination;
  r4.start = 0, r4.num = n2;
  let i3 = null;
  for (; ; ) {
    const t2 = await e3.source.queryFeaturesJSON(r4, a5);
    if (null == i3 ? i3 = t2 : i3.features = i3.features.concat(t2.features), i3.exceededTransferLimit = t2.exceededTransferLimit, !o || !t2.exceededTransferLimit) break;
    r4.start += n2;
  }
  return i3;
}
function t(e3) {
  return u2(e3) * a3(e3);
}
function a3(e3) {
  return e3.capabilities.query.maxRecordCount || 2e3;
}
function u2(r4) {
  return r4.capabilities.query.supportsMaxRecordCountFactor ? b2.MAX_MAX_RECORD_COUNT_FACTOR : 1;
}

// node_modules/@arcgis/core/rest/support/AttachmentQuery.js
var a4;
var p3 = a4 = class extends f {
  constructor(t2) {
    super(t2), this.attachmentTypes = null, this.attachmentsWhere = null, this.cacheHint = void 0, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.returnMetadata = false, this.size = null, this.start = null, this.where = null;
  }
  writeStart(t2, e3) {
    e3.resultOffset = this.start, e3.resultRecordCount = this.num || 10;
  }
  clone() {
    return new a4(a({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, cacheHint: this.cacheHint, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
};
r([m({ type: [String], json: { write: true } })], p3.prototype, "attachmentTypes", void 0), r([m({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], p3.prototype, "attachmentsWhere", void 0), r([m({ type: Boolean, json: { write: true } })], p3.prototype, "cacheHint", void 0), r([m({ type: [String], json: { write: true } })], p3.prototype, "keywords", void 0), r([m({ type: [String], json: { write: true } })], p3.prototype, "globalIds", void 0), r([m({ json: { write: true } })], p3.prototype, "name", void 0), r([m({ type: Number, json: { read: { source: "resultRecordCount" } } })], p3.prototype, "num", void 0), r([m({ type: [Number], json: { write: true } })], p3.prototype, "objectIds", void 0), r([m({ type: Boolean, json: { default: false, write: true } })], p3.prototype, "returnMetadata", void 0), r([m({ type: [Number], json: { write: true } })], p3.prototype, "size", void 0), r([m({ type: Number, json: { read: { source: "resultOffset" } } })], p3.prototype, "start", void 0), r([r2("start"), r2("num")], p3.prototype, "writeStart", null), r([m({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], p3.prototype, "where", void 0), p3 = a4 = r([a2("esri.rest.support.AttachmentQuery")], p3), p3.from = w(p3);
var c = p3;

// node_modules/@arcgis/core/layers/support/featureLayerUtils.js
var g = new n({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" });
async function I(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (await j(e3, t2, o), !s2.addAttachment) throw new s(o, "Layer source does not support addAttachment capability");
  return s2.addAttachment(t2, r4);
}
function j(e3, t2, r4) {
  var _a, _b;
  const { attributes: o } = t2, { objectIdField: s2 } = e3;
  return ((_b = (_a = e3.capabilities) == null ? void 0 : _a.data) == null ? void 0 : _b.supportsAttachment) ? t2 ? o ? s2 && o[s2] ? Promise.resolve() : Promise.reject(new s(r4, `feature is missing the identifying attribute ${s2}`)) : Promise.reject(new s(r4, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s(r4, "A feature is required to add/delete/update attachments")) : Promise.reject(new s(r4, "this layer doesn't support attachments"));
}
async function F(e3, t2, r4, o, s2) {
  const i3 = await N(e3);
  if (await j(e3, t2, s2), !i3.updateAttachment) throw new s(s2, "Layer source does not support updateAttachment capability");
  return i3.updateAttachment(t2, r4, o);
}
async function q(e3, t2, r4) {
  const { applyEdits: n2 } = await import("./editingSupport-BHLOAWIR.js"), o = await e3.load();
  let s2 = r4;
  return "feature" === o.type && o.infoFor3D && null != t2.deleteFeatures && null != o.globalIdField && (s2 = { ...s2, globalIdToObjectId: await K(o, t2.deleteFeatures, o.globalIdField) }), n2(o, o.source, t2, r4);
}
async function x2(e3, t2, r4) {
  const { uploadAssets: n2 } = await import("./editingSupport-BHLOAWIR.js"), o = await e3.load();
  return n2(o, o.source, t2, r4);
}
async function A2(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (await j(e3, t2, o), !s2.deleteAttachments) throw new s(o, "Layer source does not support deleteAttachments capability");
  return s2.deleteAttachments(t2, r4);
}
async function v(e3, t2, r4) {
  const o = (await e3.load({ signal: t2 == null ? void 0 : t2.signal })).source;
  if (!o.fetchRecomputedExtents) throw new s(r4, "Layer source does not support fetchUpdates capability");
  return o.fetchRecomputedExtents(t2);
}
async function S(e3, t2, r4, o) {
  var _a, _b;
  t2 = c.from(t2), await e3.load();
  const s2 = e3.source, i3 = e3.capabilities;
  if (!((_a = i3 == null ? void 0 : i3.data) == null ? void 0 : _a.supportsAttachment)) throw new s(o, "this layer doesn't support attachments");
  const { attachmentTypes: a5, objectIds: u3, globalIds: c2, num: l, size: p4, start: d2, where: f2 } = t2;
  if (!((_b = i3 == null ? void 0 : i3.operations) == null ? void 0 : _b.supportsQueryAttachments)) {
    if ((a5 == null ? void 0 : a5.length) > 0 || (c2 == null ? void 0 : c2.length) > 0 || (p4 == null ? void 0 : p4.length) > 0 || l || d2 || f2) throw new s(o, "when 'capabilities.operations.supportsQueryAttachments' is false, only objectIds is supported", t2);
  }
  if (!((u3 == null ? void 0 : u3.length) || (c2 == null ? void 0 : c2.length) || f2)) throw new s(o, "'objectIds', 'globalIds', or 'where' are required to perform attachment query", t2);
  if (!s2.queryAttachments) throw new s(o, "Layer source does not support queryAttachments capability", t2);
  return s2.queryAttachments(t2);
}
async function O(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (!s2.queryObjectIds) throw new s(o, "Layer source does not support queryObjectIds capability");
  return s2.queryObjectIds(b2.from(t2) ?? e3.createQuery(), r4);
}
async function P(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (!s2.queryFeatureCount) throw new s(o, "Layer source does not support queryFeatureCount capability");
  return s2.queryFeatureCount(b2.from(t2) ?? e3.createQuery(), r4);
}
async function E(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (!s2.queryExtent) throw new s(o, "Layer source does not support queryExtent capability");
  return s2.queryExtent(b2.from(t2) ?? e3.createQuery(), r4);
}
async function L(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (!s2.queryRelatedFeatures) throw new s(o, "Layer source does not support queryRelatedFeatures capability");
  return s2.queryRelatedFeatures(d.from(t2), r4);
}
async function C(e3, t2, r4, o) {
  const s2 = await N(e3);
  if (!s2.queryRelatedFeaturesCount) throw new s(o, "Layer source does not support queryRelatedFeaturesCount capability");
  return s2.queryRelatedFeaturesCount(d.from(t2), r4);
}
async function R(e3) {
  const t2 = e3.source;
  if (t2 == null ? void 0 : t2.refresh) try {
    const { dataChanged: r4, updates: n2 } = await t2.refresh();
    if (null != n2 && (e3.sourceJSON = { ...e3.sourceJSON, ...n2 }, e3.read(n2, { origin: "service", url: e3.parsedUrl })), r4) return true;
  } catch {
  }
  if (e3.definitionExpression) try {
    return (await e2(e3.definitionExpression, e3.fieldsIndex)).hasDateFunctions;
  } catch {
  }
  return false;
}
function M(e3) {
  var _a, _b;
  const t2 = new b2(), r4 = (_a = e3.capabilities) == null ? void 0 : _a.data, n2 = (_b = e3.capabilities) == null ? void 0 : _b.query;
  t2.historicMoment = e3.historicMoment, t2.gdbVersion = e3.gdbVersion, t2.returnGeometry = true, n2 && (t2.compactGeometryEnabled = n2.supportsCompactGeometry, t2.defaultSpatialReferenceEnabled = n2.supportsDefaultSpatialReference), r4 && (r4.supportsZ && null != e3.returnZ && (t2.returnZ = e3.returnZ), r4.supportsM && null != e3.returnM && (t2.returnM = e3.returnM)), t2.outFields = ["*"];
  const { timeOffset: o, timeExtent: s2 } = e3;
  return t2.timeExtent = null != o && null != s2 ? s2.offset(-o.value, o.unit) : s2 || null, t2.multipatchOption = "multipatch" === e3.geometryType ? "xyFootprint" : null, t2;
}
function V(e3) {
  const { globalIdField: t2, fields: r4 } = e3;
  if (t2) return t2;
  if (r4) {
    for (const n2 of r4) if ("esriFieldTypeGlobalID" === n2.type) return n2.name;
  }
}
function D(e3) {
  const { objectIdField: t2, fields: r4 } = e3;
  if (t2) return t2;
  if (r4) {
    for (const n2 of r4) if ("esriFieldTypeOID" === n2.type) return n2.name;
  }
}
function G(e3) {
  return e3.currentVersion ? e3.currentVersion : e3.hasOwnProperty("capabilities") || e3.hasOwnProperty("drawingInfo") || e3.hasOwnProperty("hasAttachments") || e3.hasOwnProperty("htmlPopupType") || e3.hasOwnProperty("relationships") || e3.hasOwnProperty("timeInfo") || e3.hasOwnProperty("typeIdField") || e3.hasOwnProperty("types") ? 10 : 9.3;
}
function Q(e3, t2) {
  const { subtypes: r4, subtypeField: n2 } = e3;
  if (!(t2 == null ? void 0 : t2.attributes) || !(r4 == null ? void 0 : r4.length) || !n2) return null;
  const o = t2.attributes[n2];
  return null == o ? null : r4.find((e4) => e4.code === o);
}
function T(e3, t2) {
  var _a, _b;
  const { fieldsIndex: r4, subtypeField: n2 } = e3, { name: o, type: s2 } = r4.get(t2) ?? {};
  if (!o) return null;
  if ((n2 && ((_a = r4.get(n2)) == null ? void 0 : _a.name)) === o && ((_b = e3.subtypes) == null ? void 0 : _b.length)) {
    const t3 = e3.subtypes.map((e4) => new p({ code: k(e4.code, s2), name: e4.name }));
    if (t3 == null ? void 0 : t3.length) return new i2({ codedValues: t3 });
  }
  return null;
}
function U(e3, t2) {
  var _a, _b;
  const { fieldsIndex: r4 } = e3, { name: n2, type: o } = r4.get(t2) ?? {};
  if (!n2) return null;
  if (("typeIdField" in e3 ? (_a = r4.get(e3.typeIdField)) == null ? void 0 : _a.name : null) === n2 && "types" in e3 && ((_b = e3.types) == null ? void 0 : _b.length)) {
    const t3 = e3.types.map((e4) => new p({ code: k(e4.id, o), name: e4.name }));
    return new i2({ codedValues: t3 });
  }
  return null;
}
function k(e3, t2) {
  return t2 ? ye({ type: t2 }) && "number" == typeof e3 ? `${e3}` : me({ type: t2 }) && "string" == typeof e3 ? Number.parseInt(e3, 10) : e3 : e3;
}
async function N(e3) {
  return (await e3.load()).source;
}
async function $(t2, r4) {
  if (!i) return;
  if (i.findCredential(t2)) return;
  let n2;
  try {
    const o = await x(t2, r4);
    o && (n2 = await i.checkSignInStatus(`${o}/sharing`));
  } catch (o) {
  }
  if (n2) try {
    const n3 = null != r4 ? r4.signal : null;
    await i.getCredential(t2, { signal: n3 });
  } catch (o) {
  }
}
async function J(e3, t2, r4) {
  var _a;
  const n2 = (_a = e3.parsedUrl) == null ? void 0 : _a.path;
  n2 && e3.authenticationTriggerEvent === t2 && await $(n2, r4);
}
function Z(e3) {
  return !X(e3) && (e3.userHasUpdateItemPrivileges || e3.editingEnabled);
}
var H = u({ types: h });
function z(e3, t2) {
  var _a;
  if (e3.defaultSymbol) return ((_a = e3.types) == null ? void 0 : _a.length) ? new A({ defaultSymbol: H(e3.defaultSymbol, e3, t2), field: e3.typeIdField, uniqueValueInfos: e3.types.map((e4) => ({ id: e4.id, symbol: H(e4.symbol, e4, t2) })) }) : new p2({ symbol: H(e3.defaultSymbol, e3, t2) });
}
function B(e3) {
  var _a, _b, _c;
  let t2 = (_a = e3.sourceJSON) == null ? void 0 : _a.cacheMaxAge;
  if (!t2) return false;
  const r4 = (_c = (_b = e3.editingInfo) == null ? void 0 : _b.lastEditDate) == null ? void 0 : _c.getTime();
  return null == r4 || (t2 *= 1e3, Date.now() - r4 < t2);
}
async function K(e3, t2, n2) {
  if (null == t2) return null;
  const o = [], { objectIdField: s2 } = e3;
  if (t2.forEach((e4) => {
    let t3 = null;
    if ("attributes" in e4) {
      const { attributes: r4 } = e4;
      t3 = { globalId: r4[n2], objectId: null != r4[s2] && -1 !== r4[s2] ? r4[s2] : null };
    } else t3 = { globalId: e4.globalId, objectId: null != e4.objectId && -1 !== e4.objectId ? e4.objectId : null };
    null != t3.globalId && (null != t3.objectId && -1 !== t3.objectId || o.push(t3.globalId));
  }), 0 === o.length) return null;
  const a5 = e3.createQuery();
  a5.where = o.map((e4) => `${n2}='${e4}'`).join(" OR "), a5.returnGeometry = false, a5.outFields = [s2, n2], a5.cacheHint = false;
  const u3 = await b(r3(e3, a5));
  if (!u3.ok) return null;
  const c2 = /* @__PURE__ */ new Map(), p4 = u3.value.features;
  for (const r4 of p4) {
    const e4 = r4.attributes[n2], t3 = r4.attributes[s2];
    null != e4 && null != t3 && -1 !== t3 && c2.set(e(e4), t3);
  }
  return c2;
}
function W(e3, t2, r4) {
  if (!t2 || !r4 || !e3) return null;
  const n2 = r4.getAttribute(t2);
  return null == n2 ? null : e3.find((e4) => {
    const { id: t3 } = e4;
    return null != t3 && t3.toString() === n2.toString();
  }) ?? null;
}
function X(e3) {
  var _a;
  return ((_a = e3.sourceJSON) == null ? void 0 : _a.isMultiServicesView) || Y(e3);
}
function Y(e3) {
  var _a, _b;
  return !!((_b = (_a = e3.sourceJSON) == null ? void 0 : _a.capabilities) == null ? void 0 : _b.toLowerCase().split(",").map((e4) => e4.trim()).includes("map"));
}
function _(e3, t2, r4) {
  const o = t2 == null ? void 0 : t2.queryBins;
  if (!o) throw new s(r4, "Layer source does not support binning");
  switch (e3.binParameters.type) {
    case "auto-interval":
      if (!o.supportsAutoInterval) throw new s(r4, "Layer source does not support auto-interval binning");
      break;
    case "date":
      if (!o.supportsDate) throw new s(r4, "Layer source does not support date binning");
      break;
    case "fixed-boundaries":
      if (!o.supportsFixedBoundaries) throw new s(r4, "Layer source does not support fixed-boundaries binning");
      break;
    case "fixed-interval":
      if (!o.supportsFixedInterval) throw new s(r4, "Layer source does not support fixed-interval binning");
  }
  const s2 = o == null ? void 0 : o.supportedStatistics;
  if (e3.outStatistics && s2) {
    const t3 = /* @__PURE__ */ new Map([["count", "count"], ["sum", "sum"], ["min", "min"], ["max", "max"], ["avg", "avg"], ["stddev", "stddev"], ["var", "var"], ["percentile-continuous", "percentileContinuous"], ["percentile-discrete", "percentileDiscrete"], ["centroid-aggregate", "centroid"], ["convex-hull-aggregate", "convexHull"], ["envelope-aggregate", "envelope"]]);
    for (const { statisticType: o2 } of e3.outStatistics) {
      const e4 = t3.get(o2);
      if (e4 && !s2[e4]) throw new s(r4, `Layer source does not support ${o2} statistic type`);
    }
  }
}

export {
  r3 as r,
  c,
  g,
  I,
  F,
  q,
  x2 as x,
  A2 as A,
  v,
  S,
  O,
  P,
  E,
  L,
  C,
  R,
  M,
  V,
  D,
  G,
  Q,
  T,
  U,
  J,
  Z,
  z,
  B,
  K,
  W,
  X,
  _
};
//# sourceMappingURL=chunk-5IA763KB.js.map
