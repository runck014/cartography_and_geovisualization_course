import "./chunk-H2HEE74G.js";
import "./chunk-HB2JTNV2.js";
import "./chunk-R7BLUDCP.js";
import "./chunk-DLJHW32W.js";
import "./chunk-IWXHREP5.js";
import "./chunk-57M37V54.js";
import "./chunk-CQ5ECUDF.js";
import "./chunk-374X2AXO.js";
import "./chunk-W3O5CFJ6.js";
import "./chunk-HRP7POO2.js";
import "./chunk-JVGNMUKK.js";
import "./chunk-X2UYZD2B.js";
import "./chunk-JQJITHTO.js";
import "./chunk-6LGJYARD.js";
import "./chunk-N42IF4WX.js";
import "./chunk-L7OHH2HW.js";
import "./chunk-I2OLSNCI.js";
import {
  f,
  l
} from "./chunk-QYBCLVRN.js";
import "./chunk-U7ZFK3X2.js";
import "./chunk-VMQKPMJK.js";
import "./chunk-A7PB2PTS.js";
import {
  a,
  a2
} from "./chunk-D67YPTQ2.js";
import "./chunk-LTCEJX6G.js";
import "./chunk-L6HI4BLZ.js";
import "./chunk-5FROWG6B.js";
import "./chunk-NW7VXBHZ.js";
import "./chunk-BOSRS73G.js";
import "./chunk-ECMDQ4LS.js";
import "./chunk-D6FJTDNK.js";
import "./chunk-RENLZYKC.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-WGIZLWW7.js";
import "./chunk-PUOCGOJB.js";
import "./chunk-LPNAPHOF.js";
import "./chunk-DBQLTBDH.js";
import "./chunk-AMH7OVBF.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-5A4G4OVM.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import {
  g
} from "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import {
  A
} from "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import {
  n
} from "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n2;
var e;
!function(n4) {
  n4[n4.None = 0] = "None", n4[n4.Int16 = 1] = "Int16", n4[n4.Int32 = 2] = "Int32";
}(n2 || (n2 = {})), function(n4) {
  n4[n4.Replace = 0] = "Replace", n4[n4.Outside = 1] = "Outside", n4[n4.Inside = 2] = "Inside", n4[n4.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n3 || (n3 = new Promise((t) => import("./i3s-7GFITTZY.js").then((t2) => t2.i).then(({ default: e4 }) => {
    const n4 = e4({ locateFile: i, onRuntimeInitialized: () => t(n4) });
    delete n4.then;
  })).catch((t) => {
    throw t;
  })), n3;
}
function i(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n3;

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r2;
var a3;
var d;
var c;
!function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
}(o || (o = {})), function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
}(r2 || (r2 = {}));
!function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
}(a3 || (a3 = {})), function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(d || (d = {})), function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
}(c || (c = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function c2(e4) {
  g2 = await S();
  const t = [e4.geometryBuffer];
  return { result: E(g2, e4, t), transferList: t };
}
async function l2(e4) {
  var _a;
  g2 = await S();
  const t = [e4.geometryBuffer], { geometryBuffer: r3 } = e4, o2 = r3.byteLength, n4 = g2._malloc(o2), s = new Uint8Array(g2.HEAPU8.buffer, n4, o2);
  s.set(new Uint8Array(r3));
  const i2 = g2.dracoDecompressPointCloudData(n4, s.byteLength);
  if (g2._free(n4), i2.error.length > 0) throw new Error(`i3s.wasm: ${i2.error}`);
  const a4 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f2 = i2.positions.slice();
  return a4 && t.push(a4.buffer), t.push(f2.buffer), { result: { positions: f2, featureIds: a4 }, transferList: t };
}
async function u(e4) {
  await S(), j(e4);
  const t = { buffer: e4.buffer };
  return { result: t, transferList: [t.buffer] };
}
async function m(e4) {
  await S(), w(e4);
}
async function y(e4) {
  g2 = await S(), g2.setLegacySchema(e4.context, e4.jsonSchema);
}
async function p(e4) {
  const { localMatrix: n4, origin: s, positions: i2, vertexSpace: a4 } = e4, f2 = g.fromJSON(e4.inSpatialReference), c3 = g.fromJSON(e4.outSpatialReference);
  let l3;
  const [{ projectBuffer: u2 }, { initializeProjection: m2 }] = await Promise.all([import("./projectBuffer-2CFBOHNJ.js"), import("./projection-6RJGPVIH.js")]);
  await m2(f2, c3);
  const y2 = [0, 0, 0];
  if (!u2(s, f2, 0, y2, c3, 0)) throw new Error("Failed to project");
  if ("georeferenced" === a4.type && null == a4.origin) {
    if (l3 = new Float64Array(i2.length), !u2(i2, f2, 0, l3, c3, 0, l3.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === a4.type ? a.fromJSON(a4) : a2.fromJSON(a4), { projectMeshVertexPositions: t } = await import("./projectMeshVertexPositions-ORMJR7C2.js"), s2 = t({ vertexAttributes: { position: i2 }, transform: n4 ? { localMatrix: n4 } : void 0, vertexSpace: e5, spatialReference: f2 }, c3);
    if (!s2) throw new Error("Failed to project");
    l3 = s2;
  }
  const p2 = l3.length, [d3, h2, b2] = y2;
  for (let t = 0; t < p2; t += 3) l3[t] -= d3, l3[t + 1] -= h2, l3[t + 2] -= b2;
  return { result: { projected: l3, original: i2, projectedOrigin: y2 }, transferList: [l3.buffer, i2.buffer] };
}
async function d2({ normalMatrix: t, normals: r3 }) {
  const o2 = new Float32Array(r3.length);
  return f(o2, r3, t), A(t) && l(o2, o2), { result: { transformed: o2, original: r3 }, transferList: [o2.buffer, r3.buffer] };
}
function h(e4) {
  L(e4);
}
var b;
var g2;
function w(e4) {
  if (!g2) return;
  const t = e4.modifications, r3 = g2._malloc(8 * t.length), o2 = new Float64Array(g2.HEAPU8.buffer, r3, t.length);
  for (let n4 = 0; n4 < t.length; ++n4) o2[n4] = t[n4];
  g2.setModifications(e4.context, r3, t.length, e4.isGeodetic), g2._free(r3);
}
function E(e4, t, r3) {
  const { context: o2, globalTrafo: n4, mbs: s, obbData: a4, elevationOffset: f2, geometryBuffer: c3, geometryDescriptor: l3, indexToVertexProjector: u2, vertexToRenderProjector: m2 } = t, y2 = e4._malloc(c3.byteLength), p2 = 33, d3 = e4._malloc(p2 * Float64Array.BYTES_PER_ELEMENT), h2 = new Uint8Array(e4.HEAPU8.buffer, y2, c3.byteLength);
  h2.set(new Uint8Array(c3));
  const b2 = new Float64Array(e4.HEAPU8.buffer, d3, p2);
  I(b2, [NaN, NaN, NaN]);
  let g3 = b2.byteOffset + 3 * b2.BYTES_PER_ELEMENT, w2 = new Float64Array(b2.buffer, g3);
  I(w2, n4), g3 += 16 * b2.BYTES_PER_ELEMENT, w2 = new Float64Array(b2.buffer, g3), I(w2, s), g3 += 4 * b2.BYTES_PER_ELEMENT, a4 && (w2 = new Float64Array(b2.buffer, g3), I(w2, a4));
  const E2 = l3, A3 = { isDraco: false, isLegacy: false, color: t.layouts.some((e5) => e5.some((e6) => "color" === e6.name)), normal: t.needNormals && t.layouts.some((e5) => e5.some((e6) => "normalCompressed" === e6.name)), uv0: t.layouts.some((e5) => e5.some((e6) => "uv0" === e6.name)), uvRegion: t.layouts.some((e5) => e5.some((e6) => "uvRegion" === e6.name)), featureIndex: E2.featureIndex }, j2 = e4.process(o2, !!t.obbData, y2, h2.byteLength, E2, A3, d3, f2, u2, m2, t.normalReferenceFrame);
  if (e4._free(d3), e4._free(y2), j2.error.length > 0) throw new Error(`i3s.wasm: ${j2.error}`);
  if (j2.discarded) return null;
  const L2 = j2.componentOffsets.length > 0 ? j2.componentOffsets.slice() : null, x2 = j2.featureIds.length > 0 ? j2.featureIds.slice() : null, S2 = j2.anchorIds.length > 0 ? Array.from(j2.anchorIds) : null, _2 = j2.anchors.length > 0 ? Array.from(j2.anchors) : null, P = j2.interleavedVertedData.slice().buffer, M = j2.indicesType === n2.Int16 ? new Uint16Array(j2.indices.buffer, j2.indices.byteOffset, j2.indices.byteLength / 2).slice() : new Uint32Array(j2.indices.buffer, j2.indices.byteOffset, j2.indices.byteLength / 4).slice(), N = j2.positions.slice(), U = j2.positionIndicesType === n2.Int16 ? new Uint16Array(j2.positionIndices.buffer, j2.positionIndices.byteOffset, j2.positionIndices.byteLength / 2).slice() : new Uint32Array(j2.positionIndices.buffer, j2.positionIndices.byteOffset, j2.positionIndices.byteLength / 4).slice(), T = { layout: t.layouts[0], interleavedVertexData: P, indices: M, hasColors: j2.hasColors, hasModifications: j2.hasModifications, positionData: { data: N, indices: U } };
  return x2 && r3.push(x2.buffer), L2 && r3.push(L2.buffer), r3.push(P), r3.push(M.buffer), r3.push(N.buffer), r3.push(U.buffer), { componentOffsets: L2, featureIds: x2, anchorIds: S2, anchors: _2, transformedGeometry: T, obb: j2.obb, globalTrafo: n4 };
}
function A2(e4) {
  return 0 === e4 ? r2.Unmodified : 1 === e4 ? r2.PotentiallyModified : 2 === e4 ? r2.Culled : r2.Unknown;
}
function j(e4) {
  if (!g2) return;
  const { context: t, buffer: r3 } = e4, o2 = g2._malloc(r3.byteLength), n4 = r3.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(g2.HEAPU8.buffer, o2, n4), i2 = new Float64Array(r3);
  s.set(i2), g2.filterOBBs(t, o2, n4), i2.set(s), g2._free(o2);
}
function L(e4) {
  g2 && 0 === g2.destroy(e4) && (g2 = null);
}
function I(e4, t) {
  for (let r3 = 0; r3 < t.length; ++r3) e4[r3] = t[r3];
}
async function x() {
  g2 || await S();
}
function S() {
  return g2 ? Promise.resolve(g2) : (b || (b = e2().then((e4) => (g2 = e4, b = null, g2))), b);
}
var _ = { transform: (e4, t) => g2 && E(g2, e4, t), destroy: L };
export {
  h as destroyContext,
  l2 as dracoDecompressPointCloudData,
  u as filterObbsForModifications,
  j as filterObbsForModificationsSync,
  x as initialize,
  A2 as interpretObbModificationResults,
  c2 as process,
  p as project,
  y as setLegacySchema,
  m as setModifications,
  w as setModificationsSync,
  _ as test,
  d2 as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-3LDPAQIA.js.map
