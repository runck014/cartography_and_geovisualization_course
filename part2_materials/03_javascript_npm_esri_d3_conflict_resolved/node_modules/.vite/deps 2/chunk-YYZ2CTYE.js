import {
  y as y3
} from "./chunk-HZRXUNDJ.js";
import {
  a as a4,
  c as c2,
  e as e2
} from "./chunk-XKMN3LJN.js";
import {
  Z
} from "./chunk-GGPPKSP2.js";
import {
  z
} from "./chunk-JHXGQ3AW.js";
import {
  J,
  R
} from "./chunk-MR727DXB.js";
import {
  e
} from "./chunk-WPERPIJF.js";
import {
  p as p3
} from "./chunk-QKS6PIY6.js";
import {
  A,
  b as b2,
  c,
  j,
  n as n2,
  p,
  p2,
  v
} from "./chunk-R5BTSPWT.js";
import {
  a2 as a3
} from "./chunk-VNPGSD2C.js";
import {
  r as r4
} from "./chunk-XQH2QDB2.js";
import {
  d
} from "./chunk-LEOFRCUR.js";
import {
  S,
  d as d2,
  y as y2
} from "./chunk-CP4GPQHD.js";
import {
  l
} from "./chunk-VFTH6C2E.js";
import {
  i
} from "./chunk-M5RSIRGD.js";
import {
  r as r3
} from "./chunk-UYSPJCCV.js";
import {
  o
} from "./chunk-YVSEBNS4.js";
import {
  h,
  i as i2,
  u as u3,
  w
} from "./chunk-6D5XULXX.js";
import {
  s as s4,
  y
} from "./chunk-F26LCWNQ.js";
import {
  r as r2
} from "./chunk-L6D73M4D.js";
import {
  s as s3
} from "./chunk-H6RIEXAG.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import {
  f
} from "./chunk-VU6O6TFT.js";
import {
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a2,
  s4 as s2,
  u,
  u4 as u2,
  x
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  b
} from "./chunk-GRW2QIBT.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/renderers/support/DictionaryLoader.js
var g = "esri.renderers.support.DictionaryLoader";
var _ = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
var b3 = class {
  constructor(e4, t2, i6) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = /* @__PURE__ */ new Map(), this._symbolCache = new e(100), this._dictionaryVersion = null, this._fieldIndex = null, this._dictionaryPromise = null, this.url = e4, this.config = t2, this.fieldMap = i6;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t2, i6) {
    var _a;
    let s6;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(i6));
    try {
      s6 = await this._dictionaryPromise;
    } catch (y5) {
      if (b(y5)) return this._dictionaryPromise = null, null;
    }
    const r5 = (_a = this._dictionaryVersion) == null ? void 0 : _a.greaterEqual(4, 0), o3 = {};
    if (this.fieldMap) for (const e4 of this._symbolFields) {
      const i7 = J(this.fieldMap[e4], this._fieldIndex);
      if (i7) {
        const s7 = t2.attributes[i7];
        o3[e4] = r5 ? s7 : null != s7 ? "" + t2.attributes[i7] : "";
      } else o3[e4] = "";
    }
    let l3 = null;
    try {
      l3 = s6 == null ? void 0 : s6(o3, i6);
    } catch (d4) {
      return null;
    }
    if (!l3 || "string" != typeof l3 || "invalid" === l3) return null;
    const f4 = l3.split(";"), m4 = [], u7 = [];
    for (let n4 = 0; n4 < f4.length; n4++) {
      const i7 = f4[n4];
      if (i7) {
        if (i7.includes("po:")) {
          const s7 = i7.slice(3).split("|");
          if (3 === s7.length) {
            const i8 = s7[0], r6 = s7[1];
            let o4 = s7[2];
            const n5 = "countrylabel";
            if (i8 === n5 && "TextString" === r6) {
              if (null != this.fieldMap) {
                let e4 = this.fieldMap[n5];
                null == e4 && (e4 = n5, this.fieldMap[e4] = e4), t2.attributes[e4] = o4;
              }
              continue;
            }
            if ("DashTemplate" === r6) o4 = o4.split(" ").map((e4) => Number(e4));
            else if ("Color" === r6) {
              const t3 = new l(o4).toRgba();
              o4 = [t3[0], t3[1], t3[2], 255 * t3[3]];
            } else o4 = Number(o4);
            u7.push({ primitiveName: i8, propertyName: r6, value: o4, defaultValue: null });
          }
        } else if (i7.includes("|")) {
          for (const e4 of i7.split("|")) if (this._itemNames.has(e4)) {
            m4.push(e4);
            break;
          }
        } else if (this._itemNames.has(i7)) m4.push(i7);
        else if (0 === n4) {
          m4.length = 0;
          let e4 = "Invalid_P";
          null != t2.geometry && (y(t2.geometry) ? e4 = "Invalid_A" : s4(t2.geometry) && (e4 = "Invalid_L")), m4.push(e4);
          break;
        }
      }
    }
    const h3 = null == t2.geometry || !t2.geometry.hasZ && "point" === t2.geometry.type;
    return this._cimPartsToCIMSymbol(t2, m4, u7, h3, i6);
  }
  async fetchResources(e4) {
    if (this._dictionaryPromise) return this._dictionaryPromise;
    if (!this.url) return void n.getLogger(g).error("no valid URL!");
    const s6 = U(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: null != e4 ? e4.signal : null }), [{ data: o3 }] = await Promise.all([s6, i2()]);
    if (!o3) throw this._dictionaryPromise = null, new s("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
    const { authoringInfo: n4, dictionary_version: a5, expression: c7, itemsNames: h3 } = o3, y5 = c7;
    let p8 = false;
    a5 && (this._dictionaryVersion = r4.parse(a5), p8 = this._dictionaryVersion.greaterEqual(4, 0)), this._refSymbolUrlTemplate = this.url + "/" + o3.cimRefTemplateUrl, this._itemNames = new Set(h3), this._symbolFields = n4.symbol;
    const d4 = {};
    if (this.config) {
      const e5 = this.config;
      for (const t2 in e5) d4[t2] = e5[t2];
    }
    if (n4.configuration) for (const t2 of n4.configuration) d4.hasOwnProperty(t2.name) || (d4[t2.name] = t2.value);
    const _2 = [];
    if ((e4 == null ? void 0 : e4.fields) && this.fieldMap) for (const t2 in this.fieldMap) {
      const i6 = this.fieldMap[t2], s7 = e4.fields.filter((e5) => e5.name.toLowerCase() === (i6 == null ? void 0 : i6.toLowerCase()));
      s7.length > 0 && _2.push({ ...s7[0], type: p8 ? s7[0].type : "esriFieldTypeString" });
    }
    _2.length > 0 && (this._fieldIndex = new Z(_2));
    const b5 = u3(y5, null != e4 ? e4.spatialReference : null, _2, d4).then((e5) => {
      const t2 = { scale: 0 };
      return (i6, s7) => {
        if (null == e5) return null;
        const r5 = e5.repurposeFeature({ geometry: null, attributes: i6 });
        return t2.scale = null != s7 ? s7.scale ?? void 0 : void 0, e5.evaluate({ $feature: r5, $view: t2 }, e5.services);
      };
    }).catch((e5) => (n.getLogger(g).error("Creating dictionary expression failed:", e5), null));
    return this._dictionaryPromise = b5, b5;
  }
  async _cimPartsToCIMSymbol(e4, t2, i6, r5, o3) {
    const n4 = new Array(t2.length);
    for (let s6 = 0; s6 < t2.length; s6++) n4[s6] = this._getSymbolPart(t2[s6], o3);
    let l3 = await Promise.all(n4);
    const a5 = this.fieldMap;
    if (a5) {
      l3 = a(l3);
      for (const t3 of l3) y3.applyDictionaryTextOverrides(t3, e4, a5, this._fieldIndex, R(t3));
    }
    return new d({ data: j2(l3, i6, r5) });
  }
  async _getSymbolPart(e4, i6) {
    const s6 = this._symbolCache.get(e4);
    if (s6) return s6;
    if (this._ongoingRequests.has(e4)) return this._ongoingRequests.get(e4).then((e5) => e5.data);
    const r5 = this._refSymbolUrlTemplate.replaceAll(/\{itemName\}/gi, e4), o3 = U(r5, { responseType: "json", query: { f: "json" }, ...i6 });
    this._ongoingRequests.set(e4, o3), o3.finally(() => this._ongoingRequests.delete(e4));
    try {
      const t2 = await o3;
      return this._symbolCache.put(e4, t2.data), t2.data;
    } catch (n4) {
      throw n4;
    }
  }
};
function j2(e4, t2, i6) {
  if (!e4 || 0 === e4.length) return null;
  const s6 = { ...e4[0] };
  if (e4.length > 1) {
    s6.effects = null, s6.symbolLayers = [];
    for (const t3 of e4) {
      const e5 = t3;
      if (null != e5.effects) for (const t4 of e5.symbolLayers) null == t4.effects ? t4.effects = e5.effects : t4.effects.unshift(...e5.effects);
      s6.symbolLayers.unshift(...e5.symbolLayers);
    }
  }
  return i6 && (s6.callout = _), { type: "CIMSymbolReference", symbol: s6, primitiveOverrides: t2 };
}

// node_modules/@arcgis/core/renderers/DictionaryRenderer.js
var p4;
var c3 = p4 = class extends v(p) {
  constructor(e4) {
    super(e4), this.config = null, this.fieldMap = null, this.scaleExpression = null, this.scaleExpressionTitle = null, this.url = null, this.type = "dictionary";
  }
  get _loader() {
    return new b3(this.url, this.config, this.fieldMap);
  }
  writeData(e4, r5) {
    e4 && (r5.scalingExpressionInfo = { expression: e4, returnType: "number" });
  }
  writeVisualVariables(e4, r5, s6, i6) {
    (i6 == null ? void 0 : i6.origin) || super.writeVisualVariables(e4, r5, s6, i6);
  }
  clone() {
    return new p4({ config: a(this.config), scaleExpression: this.scaleExpression, scaleExpressionTitle: this.scaleExpressionTitle, fieldMap: a(this.fieldMap), url: a(this.url), visualVariables: a(this.visualVariables) });
  }
  async getSymbolAsync(e4, r5) {
    return this._loader.getSymbolAsync(e4, r5);
  }
  async collectRequiredFields(e4, r5) {
    await this.collectVVRequiredFields(e4, r5), this.scaleExpression && await h(e4, r5, this.scaleExpression);
    for (const s6 in this.fieldMap) {
      const i6 = this.fieldMap[s6];
      r5.has(i6) && e4.add(i6);
    }
  }
  get arcadeRequired() {
    return true;
  }
  getSymbol() {
    return null;
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    var _a;
    return ((_a = this.visualVariables) == null ? void 0 : _a.reduce((e4, r5) => e4 + r5.getAttributeHash(), "")) ?? "";
  }
  getMeshHash() {
    return `${this.url}-${JSON.stringify(this.fieldMap)}`;
  }
  getSymbolFields() {
    return this._loader.getSymbolFields();
  }
};
r([m({ type: b3 })], c3.prototype, "_loader", null), r([m({ type: Object, json: { read: { source: "configuration" }, write: { target: "configuration" } } })], c3.prototype, "config", void 0), r([m({ type: Object, json: { write: true } })], c3.prototype, "fieldMap", void 0), r([m({ type: String, json: { read: { source: "scalingExpressionInfo.expression" }, write: true } })], c3.prototype, "scaleExpression", void 0), r([r2("scaleExpression")], c3.prototype, "writeData", null), r([m({ type: String, json: { read: { source: "scalingExpressionInfo.title" }, write: { target: "scalingExpressionInfo.title", overridePolicy(e4) {
  return { enabled: !!e4 && !!this.scaleExpression };
} } } })], c3.prototype, "scaleExpressionTitle", void 0), r([m({ type: String, json: { write: true } })], c3.prototype, "url", void 0), r([r2("visualVariables")], c3.prototype, "writeVisualVariables", null), c3 = p4 = r([a2("esri.renderers.DictionaryRenderer")], c3);
var u4 = c3;

// node_modules/@arcgis/core/renderers/support/AttributeColorInfo.js
var n3;
var u5 = n3 = class extends f {
  constructor(e4) {
    super(e4), this.color = null, this.field = null, this.label = null, this.valueExpression = null, this.valueExpressionTitle = null;
  }
  castField(e4) {
    return null == e4 ? e4 : "function" == typeof e4 ? (n.getLogger(this).error(".field: field must be a string value"), null) : u(e4);
  }
  getAttributeHash() {
    return `${this.field}-${this.valueExpression}`;
  }
  clone() {
    var _a;
    return new n3({ color: (_a = this.color) == null ? void 0 : _a.clone(), field: this.field, label: this.label, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
r([m({ type: l, json: { type: [Number], write: true } })], u5.prototype, "color", void 0), r([m({ type: String, json: { write: true } })], u5.prototype, "field", void 0), r([s3("field")], u5.prototype, "castField", null), r([m({ type: String, json: { write: true } })], u5.prototype, "label", void 0), r([m({ type: String, json: { write: true } })], u5.prototype, "valueExpression", void 0), r([m({ type: String, json: { write: true } })], u5.prototype, "valueExpressionTitle", void 0), u5 = n3 = r([a2("esri.renderers.support.AttributeColorInfo")], u5);
var c4 = u5;

// node_modules/@arcgis/core/renderers/support/DotDensityLegendOptions.js
var e3;
var p5 = e3 = class extends f {
  constructor() {
    super(...arguments), this.unit = null;
  }
  clone() {
    return new e3({ unit: this.unit });
  }
};
r([m({ type: String, json: { write: true } })], p5.prototype, "unit", void 0), p5 = e3 = r([a2("esri.renderers.support.DotDensityLegendOptions")], p5);
var i3 = p5;

// node_modules/@arcgis/core/renderers/DotDensityRenderer.js
var h2;
var m2 = h2 = class extends v(p) {
  constructor(t2) {
    super(t2), this.attributes = null, this.backgroundColor = new l([0, 0, 0, 0]), this.dotBlendingEnabled = true, this.dotShape = "square", this.dotSize = 1, this.legendOptions = null, this.outline = new d2(), this.dotValue = null, this.referenceScale = null, this.seed = 1, this.type = "dot-density";
  }
  calculateDotValue(t2) {
    if (null == this.referenceScale) return this.dotValue;
    const e4 = t2 / this.referenceScale * this.dotValue;
    return e4 < 1 ? 1 : e4;
  }
  getSymbol() {
    return new S({ outline: this.outline });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  getAttributeHash() {
    var _a;
    return ((_a = this.attributes) == null ? void 0 : _a.reduce((t2, e4) => t2 + e4.getAttributeHash(), "")) ?? "";
  }
  getMeshHash() {
    return JSON.stringify(this.outline);
  }
  clone() {
    return new h2({ attributes: a(this.attributes), backgroundColor: a(this.backgroundColor), dotBlendingEnabled: a(this.dotBlendingEnabled), dotShape: a(this.dotShape), dotSize: a(this.dotSize), dotValue: a(this.dotValue), legendOptions: a(this.legendOptions), outline: a(this.outline), referenceScale: a(this.referenceScale), seed: a(this.seed), visualVariables: a(this.visualVariables), authoringInfo: a(this.authoringInfo) });
  }
  getControllerHash() {
    var _a;
    const t2 = (_a = this.attributes) == null ? void 0 : _a.map((t3) => t3.field || t3.valueExpression || "");
    return `${t2}-${this.outline && JSON.stringify(this.outline.toJSON()) || ""}`;
  }
  async collectRequiredFields(t2, e4) {
    await this.collectVVRequiredFields(t2, e4);
    for (const o3 of this.attributes ?? []) o3.valueExpression && await h(t2, e4, o3.valueExpression), o3.field && t2.add(o3.field);
  }
};
r([m({ type: [c4], json: { write: true } })], m2.prototype, "attributes", void 0), r([m({ type: l, json: { write: true } })], m2.prototype, "backgroundColor", void 0), r([m({ type: Boolean, json: { write: true } })], m2.prototype, "dotBlendingEnabled", void 0), r([m({ type: String, json: { write: false } })], m2.prototype, "dotShape", void 0), r([m({ type: Number, json: { write: true } })], m2.prototype, "dotSize", void 0), r([m({ type: i3, json: { write: true } })], m2.prototype, "legendOptions", void 0), r([m({ type: d2, json: { default: null, write: true } })], m2.prototype, "outline", void 0), r([m({ type: Number, json: { write: true } })], m2.prototype, "dotValue", void 0), r([m({ type: Number, json: { write: true } })], m2.prototype, "referenceScale", void 0), r([m({ type: Number, json: { write: true } })], m2.prototype, "seed", void 0), r([r3({ dotDensity: "dot-density" })], m2.prototype, "type", void 0), m2 = h2 = r([a2("esri.renderers.DotDensityRenderer")], m2);
var y4 = m2;

// node_modules/@arcgis/core/renderers/support/HeatmapColorStop.js
var c5;
var i4 = c5 = class extends f {
  constructor(o3) {
    super(o3), this.color = null, this.ratio = null;
  }
  clone() {
    return new c5({ color: this.color && this.color.clone(), ratio: this.ratio });
  }
};
r([m({ type: l, json: { type: [x], default: null, write: true } })], i4.prototype, "color", void 0), r([m({ type: Number, json: { write: true } })], i4.prototype, "ratio", void 0), i4 = c5 = r([a2("esri.renderers.support.HeatmapColorStop")], i4);
var l2 = i4;

// node_modules/@arcgis/core/renderers/support/HeatmapLegendOptions.js
var p6 = class extends i(f) {
  constructor() {
    super(...arguments), this.minLabel = null, this.maxLabel = null, this.title = null;
  }
};
r([m({ type: String, json: { write: true } })], p6.prototype, "minLabel", void 0), r([m({ type: String, json: { write: true } })], p6.prototype, "maxLabel", void 0), r([m({ type: String, json: { write: true } })], p6.prototype, "title", void 0), p6 = r([a2("esri.renderers.support.HeatmapLegendOptions")], p6);

// node_modules/@arcgis/core/renderers/HeatmapRenderer.js
var g2;
function f2(t2) {
  if (null != t2) {
    const { maxDensity: e4, minDensity: i6, radius: s6 } = t2;
    if (null != e4 || null != i6 || null != s6) {
      const { blurRadius: e5, maxPixelIntensity: i7, minPixelIntensity: s7, ...r5 } = t2;
      return r5;
    }
  }
  return t2;
}
var b4 = g2 = class extends p {
  constructor(t2) {
    super(t2), this.authoringInfo = null, this.colorStops = [new l2({ ratio: 0, color: new l("rgba(255, 140, 0, 0)") }), new l2({ ratio: 0.75, color: new l("rgba(255, 140, 0, 1)") }), new l2({ ratio: 0.9, color: new l("rgba(255, 0,   0, 1)") })], this.field = null, this.legendOptions = null, this.maxDensity = 0.04, this.minDensity = 0, this.radius = 18, this.referenceScale = 0, this.type = "heatmap", this.valueExpression = null, this.valueExpressionTitle = null;
  }
  normalizeCtorArgs(t2) {
    return f2(t2);
  }
  get blurRadius() {
    return a4(this.radius);
  }
  set blurRadius(t2) {
    const e4 = this.maxPixelIntensity, i6 = this.minPixelIntensity;
    this._set("radius", e2(t2)), this._set("maxDensity", e4 * this._pixelIntensityToDensity), this._set("minDensity", i6 * this._pixelIntensityToDensity);
  }
  get maxPixelIntensity() {
    return this.maxDensity / this._pixelIntensityToDensity;
  }
  set maxPixelIntensity(t2) {
    this._set("maxDensity", t2 * this._pixelIntensityToDensity);
  }
  get minPixelIntensity() {
    return this.minDensity / this._pixelIntensityToDensity;
  }
  set minPixelIntensity(t2) {
    this._set("minDensity", t2 * this._pixelIntensityToDensity);
  }
  get _pixelIntensityToDensity() {
    return 24 / (c2 ** 2 * this.blurRadius ** 4);
  }
  read(t2, e4) {
    t2 = f2(t2), super.read(t2, e4);
  }
  getSymbol() {
    return new y2();
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  async collectRequiredFields(t2, e4) {
    const i6 = this.field, s6 = this.valueExpression;
    i6 && "string" == typeof i6 && w(t2, e4, i6), s6 && "string" == typeof s6 && await h(t2, e4, s6);
  }
  getAttributeHash() {
    return "";
  }
  getMeshHash() {
    return `${JSON.stringify(this.colorStops)}.${this.blurRadius}.${this.field}`;
  }
  clone() {
    return new g2({ authoringInfo: this.authoringInfo && this.authoringInfo.clone(), colorStops: a(this.colorStops), field: this.field, legendOptions: a(this.legendOptions), maxDensity: this.maxDensity, minDensity: this.minDensity, radius: this.radius, referenceScale: this.referenceScale, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
r([m({ type: j, json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], b4.prototype, "authoringInfo", void 0), r([m({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], b4.prototype, "blurRadius", null), r([m({ type: [l2], json: { write: true } })], b4.prototype, "colorStops", void 0), r([m({ type: String, json: { write: true } })], b4.prototype, "field", void 0), r([m({ type: p6, json: { write: true } })], b4.prototype, "legendOptions", void 0), r([m({ type: Number, json: { write: true } })], b4.prototype, "maxDensity", void 0), r([m({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], b4.prototype, "maxPixelIntensity", null), r([m({ type: Number, json: { write: true } })], b4.prototype, "minDensity", void 0), r([m({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], b4.prototype, "minPixelIntensity", null), r([m({ type: Number, cast: o, json: { write: true } })], b4.prototype, "radius", void 0), r([m({ type: Number, range: { min: 0 }, json: { default: 0, write: true } })], b4.prototype, "referenceScale", void 0), r([r3({ heatmap: "heatmap" })], b4.prototype, "type", void 0), r([m({ type: String, json: { write: true, origins: { "web-document": { write: false }, "portal-item": { write: false } } } })], b4.prototype, "valueExpression", void 0), r([m({ type: String })], b4.prototype, "valueExpressionTitle", void 0), r([m({ readOnly: true })], b4.prototype, "_pixelIntensityToDensity", null), b4 = g2 = r([a2("esri.renderers.HeatmapRenderer")], b4);
var w2 = b4;

// node_modules/@arcgis/core/renderers/support/OthersCategory.js
var i5 = class extends i(f) {
  constructor() {
    super(...arguments), this.color = new l([0, 0, 0, 0]), this.label = null, this.threshold = 0;
  }
};
r([m({ type: l, json: { write: true } })], i5.prototype, "color", void 0), r([m({ type: String, json: { write: true } })], i5.prototype, "label", void 0), r([m({ type: Number, range: { min: 0, max: 1 }, json: { write: true } })], i5.prototype, "threshold", void 0), i5 = r([a2("esri.renderers.support.OthersCategory")], i5);

// node_modules/@arcgis/core/renderers/PieChartRenderer.js
var v2 = { base: c, key: "type", typeMap: { size: b2, opacity: p2 } };
var S2 = class extends v(i(p)) {
  constructor(e4) {
    super(e4), this.attributes = null, this.backgroundFillSymbol = null, this.defaultColor = new l([0, 0, 0, 0]), this.defaultLabel = null, this.holePercentage = 0, this.othersCategory = new i5(), this.legendOptions = null, this.outline = null, this.size = 12, this.type = "pie-chart", this.visualVariables = null;
  }
  getSymbol() {
    var _a;
    return new y2({ size: this.size ? this.size / 2 + (((_a = this.outline) == null ? void 0 : _a.width) || 0) : 0 });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol(), this.backgroundFillSymbol].filter(F);
  }
  getAttributeHash() {
    var _a;
    return ((_a = this.visualVariables) == null ? void 0 : _a.reduce((e4, t2) => e4 + t2.getAttributeHash(), "")) ?? "";
  }
  getMeshHash() {
    return this.getSymbols().reduce((e4, t2) => e4 + JSON.stringify(t2), "");
  }
  async collectRequiredFields(e4, t2) {
    await this.collectVVRequiredFields(e4, t2);
    for (const r5 of this.attributes) r5.valueExpression && await h(e4, t2, r5.valueExpression), r5.field && e4.add(r5.field);
  }
};
r([m({ type: [c4], json: { write: true } })], S2.prototype, "attributes", void 0), r([m(n2)], S2.prototype, "backgroundFillSymbol", void 0), r([m({ type: l, json: { write: true } })], S2.prototype, "defaultColor", void 0), r([m({ type: String, json: { write: true } })], S2.prototype, "defaultLabel", void 0), r([m({ type: Number, range: { min: 0, max: 1 }, json: { write: true } })], S2.prototype, "holePercentage", void 0), r([m({ type: i5, json: { write: true } })], S2.prototype, "othersCategory", void 0), r([m({ type: a3, json: { write: true } })], S2.prototype, "legendOptions", void 0), r([m({ type: d2, json: { default: null, write: true } })], S2.prototype, "outline", void 0), r([m({ type: Number, cast: o, json: { write: true } })], S2.prototype, "size", void 0), r([r3({ pieChart: "pie-chart" })], S2.prototype, "type", void 0), r([m({ types: [v2] })], S2.prototype, "visualVariables", void 0), S2 = r([a2("esri.renderers.PieChartRenderer")], S2);
var w3 = S2;

// node_modules/@arcgis/core/renderers/support/types.js
var m3 = { key: "type", base: p, typeMap: { heatmap: w2, simple: p3, "unique-value": A, "class-breaks": z, "dot-density": y4, dictionary: u4, "pie-chart": w3 }, errorContext: "renderer" };
var u6 = { key: "type", base: p, typeMap: { simple: p3, "unique-value": A, "class-breaks": z, heatmap: w2 }, errorContext: "renderer", validate: p7 };
function p7(e4) {
  switch (e4.type) {
    case "simple":
      return c6(e4);
    case "unique-value":
      return f3(e4);
    case "class-breaks":
      return d3(e4);
    case "heatmap":
      return e4;
  }
}
function c6(r5) {
  if (r5.symbol) return r5;
  n.getLogger("esri.renderers.support.types").error("Removed invalid 'simple' renderer without a symbol from web scene.");
}
function f3(r5) {
  const s6 = r5.uniqueValueInfos, t2 = s6 == null ? void 0 : s6.filter(({ symbol: r6, label: s7 }, t3) => (r6 || n.getLogger("esri.renderers.support.types").error(`Removed invalid unique value info ([${t3}] ${s7}) without a symbol from web scene.`), !!r6));
  return (t2 == null ? void 0 : t2.length) !== (s6 == null ? void 0 : s6.length) && (r5.uniqueValueInfos = t2), r5;
}
function d3(r5) {
  const s6 = r5.classBreakInfos, t2 = s6 == null ? void 0 : s6.filter(({ symbol: r6, label: s7 }, t3) => (r6 || n.getLogger("esri.renderers.support.types").error(`Removed invalid class break info ([${t3}] ${s7}) without a symbol from web scene.`), !!r6));
  return (t2 == null ? void 0 : t2.length) !== (s6 == null ? void 0 : s6.length) && (r5.classBreakInfos = t2), r5;
}

// node_modules/@arcgis/core/renderers/support/jsonUtils.js
function t(e4, r5) {
  return o2(e4, null, r5);
}
var s5 = u2({ types: m3 });
function o2(r5, n4, t2) {
  return r5 ? r5 && (r5.styleName || r5.styleUrl) && "uniqueValue" !== r5.type ? ((t2 == null ? void 0 : t2.messages) && t2.messages.push(new s2("renderer:unsupported", "Only UniqueValueRenderer can be referenced from a web style, but found '" + r5.type + "'", { definition: r5, context: t2 })), null) : s5(r5, n4, t2) : null;
}

export {
  l2 as l,
  m3 as m,
  u6 as u,
  t,
  o2 as o
};
//# sourceMappingURL=chunk-YYZ2CTYE.js.map
