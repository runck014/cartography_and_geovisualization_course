{
  "version": 3,
  "sources": ["../../@arcgis/core/chunks/RealisticTree.glsl.js"],
  "sourcesContent": ["/*\nAll material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/4.31/esri/copyright.txt for details.\n*/\nimport{ForwardLinearDepth as e}from\"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js\";import{Offset as r}from\"../views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js\";import{ShaderOutput as i}from\"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js\";import{SliceDraw as o}from\"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js\";import{Transform as a}from\"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js\";import{InstancedDoublePrecision as l}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js\";import{NormalAttribute as t}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js\";import{PositionAttribute as s}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js\";import{SymbolColor as n}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js\";import{TextureCoordinateAttribute as d}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js\";import{VertexColor as c}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js\";import{VerticalOffset as g}from\"../views/3d/webgl-engine/core/shaderLibrary/attributes/VerticalOffset.glsl.js\";import{DefaultMaterialAuxiliaryPasses as m}from\"../views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js\";import{EvaluateAmbientOcclusion as v}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js\";import{EvaluateSceneLighting as b,addAmbientBoostFactor as w,addLightingGlobalFactor as h}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js\";import{addMainLightDirection as p,addMainLightIntensity as f}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js\";import{PhysicallyBasedRendering as u}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js\";import{PBRMode as x,PhysicallyBasedRenderingParameters as y}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js\";import{ReadShadowMapPass as C,ReadShadowMapDraw as L}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js\";import{terrainDepthTest as j}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js\";import{VisualVariables as O}from\"../views/3d/webgl-engine/core/shaderLibrary/shading/VisualVariables.glsl.js\";import{alphaCutoff as M}from\"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaCutoff.js\";import{DiscardOrAdjustAlphaPass as P}from\"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js\";import{MixExternalColor as A}from\"../views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js\";import{addProjViewLocalOrigin as S,addCameraPosition as D}from\"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js\";import{Float3PassUniform as E}from\"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js\";import{Float4PassUniform as $}from\"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js\";import{FloatPassUniform as F}from\"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js\";import{glsl as N,If as T}from\"../views/3d/webgl-engine/core/shaderModules/interfaces.js\";import{ShaderBuilder as V}from\"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js\";import{Texture2DPassUniform as I}from\"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js\";import{VertexAttribute as _}from\"../views/3d/webgl-engine/lib/VertexAttribute.js\";import{outputColorHighlightOID as B}from\"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js\";function R(R){const z=new V,{vertex:k,fragment:G,varyings:U}=z,{output:W,offsetBackfaces:H,instancedColor:q,pbrMode:J,snowCover:K,spherical:Q}=R,X=J===x.Normal||J===x.Schematic;if(S(k,R),z.include(s),U.add(\"vpos\",\"vec3\"),z.include(O,R),z.include(l,R),z.include(g,R),W===i.Color&&(D(z.vertex,R),z.include(t,R),z.include(a,R),H&&z.include(r),q&&z.attributes.add(_.INSTANCECOLOR,\"vec4\"),U.add(\"vNormalWorld\",\"vec3\"),U.add(\"localvpos\",\"vec3\"),R.terrainDepthTest&&U.add(\"depth\",\"float\"),z.include(d,R),z.include(e,R),z.include(n,R),z.include(c,R),k.uniforms.add(new $(\"externalColor\",(e=>e.externalColor))),U.add(\"vcolorExt\",\"vec4\"),k.main.add(N`\n      forwardNormalizedVertexColor();\n      vcolorExt = externalColor;\n      ${T(q,\"vcolorExt *= instanceColor * 0.003921568627451;\")}\n      vcolorExt *= vvColor();\n      vcolorExt *= getSymbolColor();\n      forwardColorMixMode();\n\n      if (vcolorExt.a < ${N.float(M)}) {\n        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      } else {\n        vpos = getVertexInLocalOriginSpace();\n        localvpos = vpos - view[3].xyz;\n        vpos = subtractOrigin(vpos);\n        vNormalWorld = dpNormal(vvLocalNormal(normalModel()));\n        vpos = addVerticalOffset(vpos, localOrigin);\n        gl_Position = transformPosition(proj, view, vpos);\n        ${T(H,\"gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);\")}\n      }\n      ${T(R.terrainDepthTest,\"depth = (view * vec4(vpos, 1.0)).z;\")}\n      forwardLinearDepth();\n      forwardTextureCoordinates();`)),W===i.Color){const{hasColorTexture:e,hasColorTextureTransform:r,receiveShadows:i}=R;z.include(b,R),z.include(v,R),z.include(P,R),z.include(R.instancedDoublePrecision?C:L,R),z.include(j,R),z.include(o,R),z.include(B,R),D(z.fragment,R),p(G),w(G),h(G),G.uniforms.add(k.uniforms.get(\"localOrigin\"),k.uniforms.get(\"view\"),new E(\"ambient\",(e=>e.ambient)),new E(\"diffuse\",(e=>e.diffuse)),new F(\"opacity\",(e=>e.opacity)),new F(\"layerOpacity\",(e=>e.layerOpacity))),e&&G.uniforms.add(new I(\"tex\",(e=>e.texture))),z.include(y,R),z.include(u,R),G.include(A),f(G),G.main.add(N`\n      discardBySlice(vpos);\n      ${T(R.terrainDepthTest,\"terrainDepthTest(depth);\")}\n      vec4 texColor = ${e?`texture(tex, ${r?\"colorUV\":\"vuv0\"})`:\" vec4(1.0)\"};\n      ${T(e,`${T(R.textureAlphaPremultiplied,\"texColor.rgb /= texColor.a;\")}\\n        discardOrAdjustAlpha(texColor);`)}\n      vec3 viewDirection = normalize(vpos - cameraPosition);\n      applyPBRFactors();\n      float ssao = evaluateAmbientOcclusionInverse();\n      ssao *= getBakedOcclusion();\n\n      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);\n      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n      float shadow = ${i?\"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))\":Q?\"lightingGlobalFactor * (1.0 - additionalAmbientScale)\":\"0.0\"};\n      vec3 matColor = max(ambient, diffuse);\n      ${R.hasVertexColors?N`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));`:N`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}\n      ${T(K,\"albedo = mix(albedo, vec3(1), 0.9);\")}\n      ${N`vec3 shadingNormal = normalize(vNormalWorld);\n             albedo *= 1.2;\n             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);\n             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);\n             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);\n             float treeRadialFalloff = vColor.r;\n             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n             additionalLight += backLightFactor * mainLightIntensity;`}\n      ${T(X,`vec3 normalGround = ${Q?\"normalize(vpos + localOrigin)\":\"vec3(0.0, 0.0, 1.0)\"};`)}\n      ${X?N`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];\n                 ${T(K,N`mrr = vec3(0.0, 1.0, 0.04);`)}\n            vec4 emission = ${K?\"vec4(0.0)\":\"getEmissions()\"};\n            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);`:N`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}\n      vec4 finalColor = vec4(shadedColor, opacity_);\n      outputColorHighlightOID(finalColor, vpos);`)}return z.include(m,R),z}const z=Object.freeze(Object.defineProperty({__proto__:null,build:R},Symbol.toStringTag,{value:\"Module\"}));export{z as R,R as b};\n"],
  "mappings": "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",
  "names": ["R", "z", "o", "n", "e", "r", "i", "t", "m", "a", "d", "h"]
}
