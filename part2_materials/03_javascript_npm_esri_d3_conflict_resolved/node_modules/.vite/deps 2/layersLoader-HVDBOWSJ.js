import {
  v
} from "./chunk-VEXFKN25.js";
import {
  a,
  c,
  e,
  i,
  l,
  n,
  o,
  t as t3,
  u
} from "./chunk-EFNL5Y7R.js";
import "./chunk-7W7WBJSE.js";
import {
  t as t2
} from "./chunk-WHBT5WHI.js";
import {
  t
} from "./chunk-VZ5SMATQ.js";
import {
  a as a2
} from "./chunk-7HWB7LKO.js";
import {
  t as t4
} from "./chunk-VH245UJV.js";
import {
  e as e2
} from "./chunk-HJ7SKBLO.js";
import {
  s as s2
} from "./chunk-2DHZIDQK.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import {
  d
} from "./chunk-TDZ623HP.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-BMGF5ELJ.js";
import {
  b
} from "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/portal/support/layersLoader.js
async function g(e3, t5) {
  const r = e3.instance.portalItem;
  if (r == null ? void 0 : r.id) return await r.load(t5), b2(e3), e3.validateItem && e3.validateItem(r), L(e3, t5);
}
function b2(t5) {
  const r = t5.instance.portalItem;
  if (!(r == null ? void 0 : r.type) || !t5.supportedTypes.includes(r.type)) throw new s("portal:invalid-layer-item-type", "Invalid layer item type '${type}', expected '${expectedType}'", { type: r == null ? void 0 : r.type, expectedType: t5.supportedTypes.join(", ") });
}
async function L(e3, t5) {
  const r = e3.instance, o2 = r.portalItem;
  if (!o2) return;
  const { url: n2, title: s3 } = o2, l2 = e2(o2, "portal-item");
  if ("group" === r.type) return S(r, l2, e3);
  n2 && "media" !== r.type && r.read({ url: n2 }, l2);
  const c2 = new e(), u2 = await M(e3, c2, t5);
  return u2 && r.read(u2, l2), r.resourceReferences = { portalItem: o2, paths: l2.readResourcePaths ?? [] }, "subtype-group" !== r.type && r.read({ title: s3 }, l2), t4(r, l2);
}
async function S(t5, r, a3) {
  const o2 = t5.portalItem;
  if (!t5.sourceIsPortalItem) return;
  const { title: n2, type: s3 } = o2;
  if ("Group Layer" === s3) {
    if (!s2(o2, "Map")) throw new s("portal:invalid-layer-item-typekeyword", "'Group Layer' item without 'Map' type keyword is not supported");
    return T(t5);
  }
  return t5.read({ title: n2 }, r), v2(t5, a3);
}
async function T(e3) {
  const t5 = e3.portalItem, r = await t5.fetchData("json");
  if (!r) return;
  const a3 = e2(t5, "web-map");
  e3.read(r, a3), await v(e3, r, { context: a3 }), e3.resourceReferences = { portalItem: t5, paths: a3.readResourcePaths ?? [] };
}
async function v2(t5, r) {
  var _a;
  let o2;
  const { portalItem: n2 } = t5;
  if (!n2) return;
  const s3 = n2.type, i2 = r.layerModuleTypeMap;
  switch (s3) {
    case "Feature Service":
    case "Feature Collection":
      o2 = i2.FeatureLayer;
      break;
    case "Stream Service":
      o2 = i2.StreamLayer;
      break;
    case "Scene Service":
      o2 = i2.SceneLayer;
      break;
    default:
      throw new s("portal:unsupported-item-type-as-group", `The item type '${s3}' is not supported as a 'IGroupLayer'`);
  }
  const y = new e();
  let [f, m] = await Promise.all([o2(), M(r, y)]), d2 = () => f;
  if ("Feature Service" === s3) {
    const e3 = (_a = l(m)) == null ? void 0 : _a.customParameters;
    m = n2.url ? await a(m, n2.url, y) : {}, d2 = await E(m, i2) || d2;
    const r2 = await k(n2.url, { customParameters: e3, loadContext: y });
    return await F(t5, d2, m, r2);
  }
  return "Scene Service" === s3 && n2.url && (m = await o(n2, m, y)), u(m) > 0 ? await F(t5, d2, m) : await j(t5, d2);
}
async function j(e3, t5) {
  var _a, _b;
  const { portalItem: r } = e3;
  if (!(r == null ? void 0 : r.url)) return;
  const a3 = await t(r.url);
  a3 && F(e3, t5, { layers: (_a = a3.layers) == null ? void 0 : _a.map(t3), tables: (_b = a3.tables) == null ? void 0 : _b.map(t3) });
}
async function F(e3, t5, r, a3) {
  var _a;
  let o2 = r.layers || [];
  const s3 = r.tables || [];
  if ("Feature Collection" === ((_a = e3.portalItem) == null ? void 0 : _a.type) ? (o2.forEach((e4, t6) => {
    var _a2;
    e4.id = t6, "Table" === ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type) && s3.push(e4);
  }), o2 = o2.filter((e4) => {
    var _a2;
    return "Table" !== ((_a2 = e4 == null ? void 0 : e4.layerDefinition) == null ? void 0 : _a2.type);
  })) : (o2.reverse(), s3.reverse()), o2.forEach((o3) => {
    const n2 = a3 == null ? void 0 : a3(o3);
    if (n2 || !a3) {
      const a4 = P(e3, t5(o3), r, o3, n2);
      e3.add(a4);
    }
  }), s3.length) {
    const t6 = await a2.FeatureLayer();
    s3.forEach((o3) => {
      const n2 = a3 == null ? void 0 : a3(o3);
      if (n2 || !a3) {
        const a4 = P(e3, t6, r, o3, n2);
        e3.tables.add(a4);
      }
    });
  }
}
function P(e3, t5, r, a3, o2) {
  const n2 = e3.portalItem, i2 = { portalItem: n2.clone(), layerId: a3.id };
  null != a3.url && (i2.url = a3.url);
  const l2 = new t5(i2);
  if ("sourceJSON" in l2 && (l2.sourceJSON = o2), "subtype-group" !== l2.type && "catalog" !== l2.type && (l2.sublayerTitleMode = "service-name"), "Feature Collection" === n2.type) {
    const e4 = { origin: "portal-item", portal: n2.portal || b.getDefault() };
    l2.read(a3, e4);
    const t6 = r.showLegend;
    null != t6 && l2.read({ showLegend: t6 }, e4);
  }
  return l2;
}
async function M(e3, t5, r) {
  if (false === e3.supportsData) return;
  const a3 = e3.instance, o2 = a3.portalItem;
  if (!o2) return;
  let n2 = null;
  try {
    n2 = await o2.fetchData("json", r);
  } catch (s3) {
  }
  if (D(a3)) {
    let e4 = null;
    const r2 = await x(o2, n2, t5);
    if (((n2 == null ? void 0 : n2.layers) || (n2 == null ? void 0 : n2.tables)) && r2 > 0) {
      if (null == a3.layerId) {
        const e5 = c(a3.type), t6 = e5 ? n(n2, e5)[0] : l(n2);
        t6 && (a3.layerId = t6.id);
      }
      e4 = C(n2, a3), "OrientedImageryLayer" === (e4 == null ? void 0 : e4.layerType) && "oriented-imagery" === a3.type && a3.supportedSourceTypes.add("Feature Layer"), e4 && null != n2.showLegend && (e4.showLegend = n2.showLegend);
    }
    return r2 > 1 && "sublayerTitleMode" in a3 && "service-name" !== a3.sublayerTitleMode && (a3.sublayerTitleMode = "item-title-and-service-name"), e4;
  }
  return n2;
}
async function x(e3, r, a3) {
  var _a, _b, _c, _d, _e;
  if ((r == null ? void 0 : r.layers) && (r == null ? void 0 : r.tables)) return u(r);
  const o2 = d(e3.url);
  if (!o2) return 1;
  const n2 = await a3.fetchServiceMetadata(o2.url.path, { customParameters: (_a = l(r)) == null ? void 0 : _a.customParameters }).catch(() => null);
  return (((_b = r == null ? void 0 : r.layers) == null ? void 0 : _b.length) ?? ((_c = n2 == null ? void 0 : n2.layers) == null ? void 0 : _c.length) ?? 0) + (((_d = r == null ? void 0 : r.tables) == null ? void 0 : _d.length) ?? ((_e = n2 == null ? void 0 : n2.tables) == null ? void 0 : _e.length) ?? 0);
}
function C(e3, t5) {
  var _a, _b;
  const { layerId: r } = t5, a3 = ((_a = e3.layers) == null ? void 0 : _a.find((e4) => e4.id === r)) || ((_b = e3.tables) == null ? void 0 : _b.find((e4) => e4.id === r));
  return a3 && G(a3, t5) ? a3 : null;
}
function D(e3) {
  return "stream" !== e3.type && "layerId" in e3;
}
function G(e3, t5) {
  const r = "layerType" in e3 && e3.layerType, { type: a3 } = t5;
  return !("feature" === a3 && r && "ArcGISFeatureLayer" !== e3.layerType || "catalog" === a3 && !r || "oriented-imagery" === a3 && !r || "subtype-group" === a3 && !r);
}
async function k(e3, t5) {
  const { layersJSON: a3 } = await t2(e3, t5);
  if (!a3) return null;
  const o2 = [...a3.layers, ...a3.tables];
  return (e4) => o2.find((t6) => t6.id === e4.id);
}
async function E(e3, t5) {
  const { layers: r } = e3;
  if (!(r == null ? void 0 : r.length)) return;
  const a3 = /* @__PURE__ */ new Set(), o2 = [];
  for (const { layerType: i2 } of r) {
    const e4 = i2 ?? "ArcGISFeatureLayer";
    if (a3.has(e4)) continue;
    a3.add(e4);
    const r2 = t5[i(e4)];
    o2.push(r2());
  }
  const n2 = await Promise.all(o2), s3 = /* @__PURE__ */ new Map();
  return Array.from(a3).forEach((e4, t6) => {
    s3.set(e4, n2[t6]);
  }), ({ layerType: e4 }) => {
    const t6 = e4 ?? "ArcGISFeatureLayer";
    return s3.get(t6);
  };
}
export {
  g as load
};
//# sourceMappingURL=layersLoader-HVDBOWSJ.js.map
