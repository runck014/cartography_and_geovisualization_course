import {
  i
} from "./chunk-2XVRGGEF.js";
import {
  t
} from "./chunk-AHZHHHCW.js";
import {
  m,
  p,
  s as s2
} from "./chunk-QJXYURT2.js";
import {
  C,
  U
} from "./chunk-KV3S4QI2.js";
import {
  l2 as l,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayRecord.js
var t2 = class _t {
  constructor(t5, e3, s6, r3, i2, h2, n5) {
    this.instanceId = t5, this.textureKey = e3, this.indexStart = s6, this.indexCount = r3, this.vertexStart = i2, this.vertexCount = h2, this.overlaps = n5;
  }
  updateBaseOffsets(t5) {
    this.vertexStart += t5.vertexFrom, this.indexStart += t5.indexFrom;
  }
  clone() {
    return new _t(this.instanceId, this.textureKey, this.indexStart, this.indexCount, this.vertexStart, this.vertexCount, this.overlaps);
  }
  static write(t5, e3, s6, r3, i2, h2, n5, a3) {
    t5.push(e3), t5.push(s6), t5.push(r3), t5.push(i2), t5.push(h2), t5.push(n5), t5.push(a3);
  }
  serialize(t5) {
    return t5.push(this.instanceId), t5.push(this.textureKey), t5.push(this.indexStart), t5.push(this.indexCount), t5.push(this.vertexStart), t5.push(this.vertexCount), t5.push(this.overlaps), t5;
  }
  static deserialize(e3) {
    const s6 = e3.readInt32(), r3 = e3.readInt32(), i2 = e3.readInt32(), h2 = e3.readInt32(), n5 = e3.readInt32(), a3 = e3.readInt32(), u2 = e3.readInt32();
    return new _t(s6, r3, i2, h2, n5, a3, u2);
  }
};
t2.byteSizeHint = 7 * Uint32Array.BYTES_PER_ELEMENT;

// node_modules/@arcgis/core/views/2d/engine/webgl/util/serializationUtils.js
function e(e3, n5) {
  if (null !== n5) {
    e3.push(n5.length);
    for (const r3 of n5) r3.serialize(e3);
    return e3;
  }
  e3.push(0);
}
function n2(e3, n5, r3) {
  const t5 = e3.readInt32(), o3 = new Array(t5);
  for (let i2 = 0; i2 < o3.length; i2++) o3[i2] = n5.deserialize(e3, r3);
  return o3;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/DisplayEntity.js
var s3 = class _s {
  constructor(t5, r3) {
    this.id = t5, this.sortKey = r3, this.records = [];
  }
  serialize(t5) {
    return t5.push(this.id), t5.writeF32(this.sortKey), e(t5, this.records), t5;
  }
  static deserialize(r3) {
    const e3 = r3.readInt32(), o3 = r3.readF32(), a3 = new _s(e3, o3);
    return a3.records = n2(r3, t2) ?? [], a3;
  }
};
s3.byteSizeHint = 2 * Uint32Array.BYTES_PER_ELEMENT + t2.byteSizeHint;

// node_modules/@arcgis/core/views/2d/engine/webgl/number.js
var n3 = new Float32Array(1);
var t3 = new Uint32Array(n3.buffer);
function a(r3) {
  return n3[0] = r3, t3[0];
}
function s4(n5, t5) {
  return 65535 & n5 | t5 << 16;
}
function y(n5) {
  const t5 = a(n5), r3 = t5 >>> 31;
  let u2 = t5 >>> 23 & 255, o3 = 8388607 & t5;
  return u2 -= 127, u2 > 15 ? r3 << 15 | 31744 : u2 < -25 ? 0 : (u2 < -14 && (o3 += 8388608, o3 /= 2 ** (-14 - u2), u2 = -15), u2 += 15, o3 /= 8192, o3 = A(o3, 1023), r3 << 15 | u2 << 10 | o3);
}
function A(n5, t5) {
  const r3 = Math.floor(n5), u2 = n5 - r3;
  return r3 < t5 && (u2 > 0.5 || 0.5 === u2 && r3 % 2 == 1) ? r3 + 1 : r3;
}
function b(n5) {
  let t5 = n5 >>> 15, r3 = n5 >> 10 & 31, u2 = 1023 & n5;
  return t5 = t5 ? -1 : 1, r3 -= 15, u2 /= 1024, r3 > -15 ? u2 += 1 : r3 = -14, t5 * 2 ** r3 * u2;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/utils.js
function r(r3) {
  const t5 = r3.map(({ name: e3, count: r4, type: t6 }) => `${e3}.${r4}.${t6}`).join(",");
  return l(t5);
}
function t4(e3, r3, o3, a3, c2, n5, s6) {
  if (e3.primitiveName === r3) {
    let r4 = a3 == null ? void 0 : a3.readWithDefault(c2, n5, e3[o3] && s6);
    return "text" === e3.type && (r4 = r4.toString()), void (e3[o3] = r4);
  }
  if ("type" in e3 && null != e3.type) {
    if (e3.effects) for (const i2 of e3.effects) t4(i2, r3, o3, a3, c2, n5, s6);
    switch (e3.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e3.symbolLayers) for (const i2 of e3.symbolLayers) t4(i2, r3, o3, a3, c2, n5, s6);
        break;
      case "CIMTextSymbol":
        e3.symbol && t4(e3.symbol, r3, o3, a3, c2, n5, s6);
        break;
      case "CIMHatchFill":
        e3.lineSymbol && t4(e3.lineSymbol, r3, o3, a3, c2, n5, s6);
        break;
      case "CIMPictureMarker":
      case "CIMCharacterMarker":
      case "CIMVectorMarker":
        if (e3.markerPlacement && t4(e3.markerPlacement, r3, o3, a3, c2, n5, s6), "CIMVectorMarker" === e3.type && e3.markerGraphics) for (const i2 of e3.markerGraphics) t4(i2, r3, o3, a3, c2, n5, s6), t4(i2.symbol, r3, o3, a3, c2, n5, s6);
    }
  }
}
var o = 400;
function a2(e3) {
  const r3 = e3.width;
  return null != e3.effects ? o : Math.max(1.25 * r3, 8);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/Utils.js
var u = () => n.getLogger("esri.views.2d.engine.webgl.Utils");
function c(t5) {
  switch (t5) {
    case U.UNSIGNED_BYTE:
      return 1;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return 2;
    case U.FLOAT:
      return 4;
    default:
      return void u().error(new s("webgl-utils", `Unable to handle type ${t5}`));
  }
}
function d(t5) {
  switch (t5) {
    case U.UNSIGNED_BYTE:
      return Uint8Array;
    case U.UNSIGNED_SHORT_4_4_4_4:
      return Uint16Array;
    case U.FLOAT:
      return Float32Array;
    default:
      return void u().error(new s("webgl-utils", `Unable to handle type ${t5}`));
  }
}
function f(e3) {
  const t5 = /* @__PURE__ */ new Map();
  for (const r3 in e3) {
    const n5 = e3[r3];
    let o3 = 0;
    t5.set(r3, n5.map((e4) => {
      const t6 = new t(e4.name, e4.count, e4.type, o3, 0, e4.normalized || false);
      return o3 += e4.count * s2(e4.type), t6;
    })), t5.get(r3).forEach((e4) => e4.stride = o3);
  }
  return t5;
}
var g = (e3) => {
  const t5 = /* @__PURE__ */ new Map();
  for (const r3 in e3) for (const n5 of e3[r3]) t5.set(n5.name, n5.location);
  return t5;
};
var w = (e3) => {
  const t5 = {};
  return e3.forEach((e4, r3) => t5[r3] = (e4 == null ? void 0 : e4.length) ? e4[0].stride : 0), t5;
};
var h = /* @__PURE__ */ new Map();
var b2 = (e3, t5) => {
  if (!h.has(e3)) {
    const r3 = f(t5), n5 = { strides: w(r3), bufferLayouts: r3, attributes: g(t5) };
    h.set(e3, n5);
  }
  return h.get(e3);
};
var y2 = (e3) => e3.includes("data:image/svg+xml");
function A2(e3) {
  const t5 = [];
  for (let r3 = 0; r3 < e3.length; r3++) t5.push(e3.charCodeAt(r3));
  return t5;
}
function T(e3, t5, r3) {
  const n5 = new p(t5.width, t5.height);
  return n5.dataType = t5.dataType, t5.depth && (n5.depth = t5.depth), t5.flipped && (n5.flipped = t5.flipped), t5.hasMipmap && (n5.hasMipmap = t5.hasMipmap), n5.internalFormat = t5.internalFormat, t5.isImmutable && (n5.isImmutable = t5.isImmutable), t5.isOpaque && (n5.isOpaque = t5.isOpaque), t5.maxAnisotropy && (n5.maxAnisotropy = t5.maxAnisotropy), n5.pixelFormat = t5.pixelFormat, t5.preMultiplyAlpha && (n5.preMultiplyAlpha = t5.preMultiplyAlpha), t5.samplingMode && (n5.samplingMode = t5.samplingMode), t5.target && (n5.target = t5.target), n5.uniform = t5.uniform, t5.unpackAlignment && (n5.unpackAlignment = t5.unpackAlignment), t5.wrapMode && (n5.wrapMode = t5.wrapMode), new m(e3, n5, r3);
}
function j(e3) {
  return "url" in e3 && "urlHash" in e3 ? { ...e3, url: "" } : e3;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/LabelMetric.js
var r2 = class _r {
  constructor(e3, i2, t5, r3, s6, n5, o3, a3, h2 = []) {
    this.entityTexel = e3, this.anchorX = i2, this.anchorY = t5, this.directionX = r3, this.directionY = s6, this.maxScale = n5, this.minScale = o3, this.referenceBounds = a3, this.bounds = h2;
  }
  serialize(e3) {
    e3.push(this.entityTexel), e3.writeF32(this.anchorX), e3.writeF32(this.anchorY), e3.writeF32(this.directionX), e3.writeF32(this.directionY), e3.writeF32(this.maxScale), e3.writeF32(this.minScale), null === this.referenceBounds ? (e3.writeF32(0), e3.writeF32(0), e3.writeF32(0)) : (e3.writeF32(this.referenceBounds.size), e3.writeF32(this.referenceBounds.offsetX), e3.writeF32(this.referenceBounds.offsetY)), e(e3, this.bounds);
  }
  static deserialize(i2) {
    const s6 = i2.readInt32(), n5 = i2.readF32(), o3 = i2.readF32(), a3 = i2.readF32(), h2 = i2.readF32(), d2 = i2.readF32(), c2 = i2.readF32(), F = i2.readF32(), f2 = i2.readF32(), l2 = i2.readF32(), u2 = n2(i2, i) ?? [];
    return new _r(s6, n5, o3, a3, h2, d2, c2, { size: F, offsetX: f2, offsetY: l2 }, u2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/dataViewUtils.js
function o2(e3, o3, s6, f2) {
  const r3 = s6.packPrecisionFactor ?? 1;
  switch (s6.type) {
    case C.BYTE:
      if (1 === s6.count) e3.setInt8(f2 + s6.offset, o3 * r3);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Int8Array.BYTES_PER_ELEMENT;
        e3.setInt8(f2 + s6.offset + n5, o3[t5] * r3);
      }
      break;
    case C.UNSIGNED_BYTE:
      if (1 === s6.count) e3.setUint8(f2 + s6.offset, o3 * r3);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Uint8Array.BYTES_PER_ELEMENT;
        e3.setUint8(f2 + s6.offset + n5, o3[t5] * r3);
      }
      break;
    case C.SHORT:
      if (1 === s6.count) e3.setInt16(f2 + s6.offset, o3 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Int16Array.BYTES_PER_ELEMENT;
        e3.setInt16(f2 + s6.offset + n5, o3[t5] * r3, true);
      }
      break;
    case C.UNSIGNED_SHORT:
      if (1 === s6.count) e3.setUint16(f2 + s6.offset, o3 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Uint16Array.BYTES_PER_ELEMENT;
        e3.setUint16(f2 + s6.offset + n5, o3[t5] * r3, true);
      }
      break;
    case C.INT:
      if (1 === s6.count) e3.setInt32(f2 + s6.offset, o3 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Int32Array.BYTES_PER_ELEMENT;
        e3.setInt32(f2 + s6.offset + n5, o3[t5] * r3, true);
      }
      break;
    case C.UNSIGNED_INT:
      if (1 === s6.count) e3.setUint32(f2 + s6.offset, o3 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Uint32Array.BYTES_PER_ELEMENT;
        e3.setUint32(f2 + s6.offset + n5, o3[t5] * r3, true);
      }
      break;
    case C.FLOAT:
      if (1 === s6.count) e3.setFloat32(f2 + s6.offset, o3 * r3, true);
      else for (let t5 = 0; t5 < s6.count; t5++) {
        const n5 = t5 * Float32Array.BYTES_PER_ELEMENT;
        e3.setFloat32(f2 + s6.offset + n5, o3[t5] * r3, true);
      }
      break;
    case C.HALF_FLOAT:
      if (1 === s6.count) e3.setUint16(f2 + s6.offset, y(o3 * r3), true);
      else for (let n5 = 0; n5 < s6.count; n5++) {
        const E = n5 * Uint16Array.BYTES_PER_ELEMENT;
        e3.setUint16(f2 + s6.offset + E, y(o3[n5] * r3), true);
      }
  }
}
function s5(t5, o3, s6) {
  switch (o3.type) {
    case C.BYTE: {
      if (1 === o3.count) return t5.getInt8(s6 + o3.offset);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Int8Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt8(s6 + o3.offset + f2));
      }
      return e3;
    }
    case C.UNSIGNED_BYTE: {
      if (1 === o3.count) return t5.getUint8(s6 + o3.offset);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Uint8Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint8(s6 + o3.offset + f2));
      }
      return e3;
    }
    case C.SHORT: {
      if (1 === o3.count) return t5.getInt16(s6 + o3.offset, true);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Int16Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt16(s6 + o3.offset + f2, true));
      }
      return e3;
    }
    case C.UNSIGNED_SHORT: {
      if (1 === o3.count) return t5.getUint16(s6 + o3.offset, true);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Uint16Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint16(s6 + o3.offset + f2, true));
      }
      return e3;
    }
    case C.INT: {
      if (1 === o3.count) return t5.getInt32(s6 + o3.offset, true);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Int32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getInt32(s6 + o3.offset + f2, true));
      }
      return e3;
    }
    case C.UNSIGNED_INT: {
      if (1 === o3.count) return t5.getUint32(s6 + o3.offset, true);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Uint32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getUint32(s6 + o3.offset + f2, true));
      }
      return e3;
    }
    case C.FLOAT: {
      if (1 === o3.count) return t5.getFloat32(s6 + o3.offset, true);
      const e3 = [];
      for (let n5 = 0; n5 < o3.count; n5++) {
        const f2 = n5 * Float32Array.BYTES_PER_ELEMENT;
        e3.push(t5.getFloat32(s6 + o3.offset + f2, true));
      }
      return e3;
    }
    case C.HALF_FLOAT: {
      if (1 === o3.count) return b(t5.getUint16(s6 + o3.offset, true));
      const n5 = [];
      for (let f2 = 0; f2 < o3.count; f2++) {
        const r3 = f2 * Uint16Array.BYTES_PER_ELEMENT;
        n5.push(b(t5.getUint16(s6 + o3.offset + r3, true)));
      }
      return n5;
    }
  }
}

export {
  t2 as t,
  n2 as n,
  s3 as s,
  c,
  d,
  b2 as b,
  y2 as y,
  A2 as A,
  T,
  j,
  s4 as s2,
  r,
  t4 as t2,
  a2 as a,
  o2 as o,
  s5 as s3,
  r2
};
//# sourceMappingURL=chunk-Q3K5MAUZ.js.map
