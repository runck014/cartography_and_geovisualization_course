import {
  a,
  c as c2,
  i,
  s as s4
} from "./chunk-KH6UC6T2.js";
import {
  r as r3
} from "./chunk-HLELEQS5.js";
import "./chunk-MA2KDKKH.js";
import {
  m
} from "./chunk-YJREYHES.js";
import {
  B
} from "./chunk-RMNZGRHI.js";
import "./chunk-U5TYWISK.js";
import "./chunk-QYBCLVRN.js";
import "./chunk-U7ZFK3X2.js";
import "./chunk-VMQKPMJK.js";
import "./chunk-A7PB2PTS.js";
import "./chunk-7QP2TGTK.js";
import "./chunk-D67YPTQ2.js";
import "./chunk-RFXYK5PV.js";
import {
  N,
  T
} from "./chunk-LTCEJX6G.js";
import {
  e,
  r as r2,
  t as t2
} from "./chunk-L6HI4BLZ.js";
import "./chunk-5FROWG6B.js";
import "./chunk-NW7VXBHZ.js";
import {
  C as C2,
  D
} from "./chunk-KV3S4QI2.js";
import "./chunk-MM4IGEXG.js";
import "./chunk-D6FJTDNK.js";
import "./chunk-LP6TMAPE.js";
import {
  A,
  H,
  _ as _2,
  c,
  o
} from "./chunk-RENLZYKC.js";
import "./chunk-URFLFG2R.js";
import "./chunk-VFTH6C2E.js";
import "./chunk-M5RSIRGD.js";
import "./chunk-UYSPJCCV.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import {
  _,
  n as n2,
  s as s3,
  t
} from "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import {
  s as s2
} from "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import {
  r
} from "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  s
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  n2 as n
} from "./chunk-PKLD5YJF.js";
import {
  C
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/glb.js
var t3;
!function(t4) {
  t4[t4.JSON = 1313821514] = "JSON", t4[t4.BIN = 5130562] = "BIN";
}(t3 || (t3 = {}));
var e2 = class _e {
  constructor(i8, r5) {
    if (!i8) throw new Error("GLB requires a JSON gltf chunk");
    this._length = _e.HEADER_SIZE, this._length += _e.CHUNK_HEADER_SIZE;
    const s6 = n3(i8);
    if (this._length += h(s6.byteLength, 4), r5 && (this._length += _e.CHUNK_HEADER_SIZE, this._length += r5.byteLength, r5.byteLength % 4)) throw new Error("Expected BIN chunk length to be divisible by 4 at this point");
    this.buffer = new ArrayBuffer(this._length), this._outView = new DataView(this.buffer), this._writeHeader();
    const _3 = this._writeChunk(s6, 12, t3.JSON, 32);
    r5 && this._writeChunk(r5, _3, t3.BIN);
  }
  _writeHeader() {
    this._outView.setUint32(0, _e.MAGIC, true), this._outView.setUint32(4, _e.VERSION, true), this._outView.setUint32(8, this._length, true);
  }
  _writeChunk(t4, e4, n4, r5 = 0) {
    const s6 = h(t4.byteLength, 4);
    for (this._outView.setUint32(e4, s6, true), this._outView.setUint32(e4 += 4, n4, true), i2(this._outView.buffer, t4, e4 += 4, 0, t4.byteLength), e4 += t4.byteLength; e4 % 4; ) r5 && this._outView.setUint8(e4, r5), e4++;
    return e4;
  }
};
function i2(t4, e4, i8, n4, h2) {
  new Uint8Array(t4, i8, h2).set(new Uint8Array(e4, n4, h2), 0);
}
function n3(t4) {
  return new TextEncoder().encode(t4).buffer;
}
function h(t4, e4) {
  return e4 * Math.ceil(t4 / e4);
}
e2.HEADER_SIZE = 12, e2.CHUNK_HEADER_SIZE = 8, e2.MAGIC = 1179937895, e2.VERSION = 2;

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/types.js
var E;
var A2;
var R;
var L;
var o2;
var I;
var N2;
!function(E2) {
  E2[E2.External = 0] = "External", E2[E2.DataURI = 1] = "DataURI", E2[E2.GLB = 2] = "GLB";
}(E || (E = {})), function(E2) {
  E2[E2.External = 0] = "External", E2[E2.DataURI = 1] = "DataURI", E2[E2.GLB = 2] = "GLB";
}(A2 || (A2 = {})), function(E2) {
  E2[E2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", E2[E2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER";
}(R || (R = {})), function(E2) {
  E2.SCALAR = "SCALAR", E2.VEC2 = "VEC2", E2.VEC3 = "VEC3", E2.VEC4 = "VEC4", E2.MAT2 = "MAT2", E2.MAT3 = "MAT3", E2.MAT4 = "MAT4";
}(L || (L = {})), function(E2) {
  E2[E2.POINTS = 0] = "POINTS", E2[E2.LINES = 1] = "LINES", E2[E2.LINE_LOOP = 2] = "LINE_LOOP", E2[E2.LINE_STRIP = 3] = "LINE_STRIP", E2[E2.TRIANGLES = 4] = "TRIANGLES", E2[E2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", E2[E2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
}(o2 || (o2 = {})), function(E2) {
  E2.OPAQUE = "OPAQUE", E2.MASK = "MASK", E2.BLEND = "BLEND";
}(I || (I = {})), function(E2) {
  E2[E2.NoColor = 0] = "NoColor", E2[E2.FaceColor = 1] = "FaceColor", E2[E2.VertexColor = 2] = "VertexColor";
}(N2 || (N2 = {}));

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/bufferview.js
var i3 = class {
  constructor(t4, s6, i8, r5, n4) {
    this._buffer = t4, this._componentType = i8, this._dataType = r5, this._data = [], this._isFinalized = false, this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, s6.bufferViews || (s6.bufferViews = []), this.index = s6.bufferViews.length, this._bufferView = { buffer: t4.index, byteLength: -1, target: n4 };
    const a3 = this._getElementSize();
    a3 >= 4 && n4 !== R.ELEMENT_ARRAY_BUFFER && (this._bufferView.byteStride = a3), s6.bufferViews.push(this._bufferView), this._numComponentsForDataType = this._calculateNumComponentsForDataType();
  }
  push(e4) {
    const t4 = this._data.length;
    if (this._data.push(e4), this._accessorIndex >= 0) {
      const s6 = t4 % this._numComponentsForDataType, i8 = this._accessorMin[s6];
      this._accessorMin[s6] = "number" != typeof i8 ? e4 : Math.min(i8, e4);
      const r5 = this._accessorMax[s6];
      this._accessorMax[s6] = "number" != typeof r5 ? e4 : Math.max(r5, e4);
    }
  }
  get dataSize() {
    return this._data.length * this._sizeComponentType();
  }
  get byteSize() {
    function e4(e5, t4) {
      return t4 * Math.ceil(e5 / t4);
    }
    return e4(this.dataSize, 4);
  }
  getByteOffset() {
    if (!this._isFinalized) throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  get byteOffset() {
    if (!this._isFinalized) throw new Error("Cannot get BufferView offset until it is finalized");
    return this._buffer.getByteOffset(this);
  }
  _createTypedArray(e4, t4) {
    switch (this._componentType) {
      case C2.BYTE:
        return new Int8Array(e4, t4);
      case C2.FLOAT:
        return new Float32Array(e4, t4);
      case C2.SHORT:
        return new Int16Array(e4, t4);
      case C2.UNSIGNED_BYTE:
        return new Uint8Array(e4, t4);
      case C2.UNSIGNED_INT:
        return new Uint32Array(e4, t4);
      case C2.UNSIGNED_SHORT:
        return new Uint16Array(e4, t4);
    }
  }
  writeOutToBuffer(e4, t4) {
    this._createTypedArray(e4, t4).set(this._data);
  }
  writeAsync(e4) {
    if (this._asyncWritePromise) throw new Error("Can't write multiple bufferView values asynchronously");
    return this._asyncWritePromise = e4.then((e5) => {
      const t4 = new Uint8Array(e5);
      for (let s6 = 0; s6 < t4.length; ++s6) this._data.push(t4[s6]);
      delete this._asyncWritePromise;
    }), this._asyncWritePromise;
  }
  startAccessor(e4) {
    if (this._accessorIndex >= 0) throw new Error("Accessor was started without ending the previous one");
    this._accessorIndex = this._data.length, this._accessorAttribute = e4;
    const t4 = this._numComponentsForDataType;
    this._accessorMin = new Array(t4), this._accessorMax = new Array(t4);
  }
  endAccessor() {
    if (this._accessorIndex < 0) throw new Error("An accessor was not started, but was attempted to be ended");
    const e4 = this._getElementSize(), t4 = this._numComponentsForDataType, i8 = (this._data.length - this._accessorIndex) / t4;
    if (i8 % 1) throw new Error("An accessor was ended with missing component values");
    for (let s6 = 0; s6 < this._accessorMin.length; ++s6) "number" != typeof this._accessorMin[s6] && (this._accessorMin[s6] = 0), "number" != typeof this._accessorMax[s6] && (this._accessorMax[s6] = 0);
    const r5 = { byteOffset: e4 * (this._accessorIndex / t4), componentType: this._componentType, count: i8, type: this._dataType, min: this._accessorMin, max: this._accessorMax, name: this._accessorAttribute };
    switch (this._accessorAttribute) {
      case "TEXCOORD_0":
      case "TEXCOORD_1":
      case "COLOR_0":
      case "WEIGHTS_0":
        switch (this._componentType) {
          case C2.UNSIGNED_BYTE:
          case C2.UNSIGNED_SHORT:
            r5.normalized = true;
        }
    }
    return this._accessorIndex = -1, this._accessorAttribute = null, this._accessorMin = null, this._accessorMax = null, r5;
  }
  get finalized() {
    return this._finalizedPromise ? this._finalizedPromise : this._isFinalized ? this._finalizedPromise = Promise.resolve() : this._finalizedPromise = new Promise((e4) => this._finalizedPromiseResolve = e4);
  }
  async finalize() {
    const e4 = this._bufferView, t4 = this._buffer.getViewFinalizePromises(this);
    this._asyncWritePromise && t4.push(this._asyncWritePromise), await Promise.allSettled(t4), this._isFinalized = true, e4.byteOffset = this.getByteOffset(), e4.byteLength = this.dataSize, this._finalizedPromiseResolve && this._finalizedPromiseResolve();
  }
  _getElementSize() {
    return this._sizeComponentType() * this._numComponentsForDataType;
  }
  _sizeComponentType() {
    switch (this._componentType) {
      case C2.BYTE:
      case C2.UNSIGNED_BYTE:
        return 1;
      case C2.SHORT:
      case C2.UNSIGNED_SHORT:
        return 2;
      case C2.UNSIGNED_INT:
      case C2.FLOAT:
        return 4;
    }
  }
  _calculateNumComponentsForDataType() {
    switch (this._dataType) {
      case L.SCALAR:
        return 1;
      case L.VEC2:
        return 2;
      case L.VEC3:
        return 3;
      case L.VEC4:
      case L.MAT2:
        return 4;
      case L.MAT3:
        return 9;
      case L.MAT4:
        return 16;
    }
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/buffer.js
var i4 = class {
  constructor(e4) {
    this._gltf = e4, this._bufferViews = [], this._isFinalized = false, e4.buffers || (e4.buffers = []), this.index = e4.buffers.length;
    const i8 = { byteLength: -1 };
    e4.buffers.push(i8), this._buffer = i8;
  }
  addBufferView(i8, t4, r5) {
    if (this._finalizePromise) throw new Error("Cannot add buffer view after fiinalizing buffer");
    const f3 = new i3(this, this._gltf, i8, t4, r5);
    return this._bufferViews.push(f3), f3;
  }
  getByteOffset(e4) {
    let i8 = 0;
    for (const t4 of this._bufferViews) {
      if (t4 === e4) return i8;
      i8 += t4.byteSize;
    }
    throw new Error("Given bufferView was not present in this buffer");
  }
  getViewFinalizePromises(e4) {
    const i8 = [];
    for (const t4 of this._bufferViews) {
      if (e4 && t4 === e4) return i8;
      i8.push(t4.finalized);
    }
    return i8;
  }
  getArrayBuffer() {
    if (!this._isFinalized) throw new Error("Cannot get ArrayBuffer from Buffer before it is finalized");
    const e4 = this._getTotalSize(), i8 = new ArrayBuffer(e4);
    let t4 = 0;
    for (const r5 of this._bufferViews) r5.writeOutToBuffer(i8, t4), t4 += r5.byteSize;
    return i8;
  }
  finalize() {
    if (this._finalizePromise) throw new Error(`Buffer ${this.index} was already finalized`);
    return this._finalizePromise = Promise.allSettled(this.getViewFinalizePromises()).then(() => {
      this._isFinalized = true;
      const e4 = this.getArrayBuffer();
      this._buffer.byteLength = e4.byteLength, this._buffer.uri = e4;
    }), this._gltf.extras.promises.push(this._finalizePromise), this._finalizePromise;
  }
  _getTotalSize() {
    let e4 = 0;
    for (const i8 of this._bufferViews) e4 += i8.byteSize;
    return e4;
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/geometry.js
function r4(o3, n4) {
  if (o3.components) for (const t4 of o3.components) t4.faces && "smooth" === t4.shading && c3(t4, n4);
}
function c3(e4, r5) {
  null == r5.normal && (r5.normal = new Float32Array(r5.position.length));
  const c4 = e4.faces, { position: m2, normal: p } = r5, h2 = c4.length / 3;
  for (let s6 = 0; s6 < h2; ++s6) {
    const e5 = 3 * c4[3 * s6], r6 = 3 * c4[3 * s6 + 1], l3 = 3 * c4[3 * s6 + 2], h3 = o(a2, m2[e5], m2[e5 + 1], m2[e5 + 2]), g = o(i5, m2[r6], m2[r6 + 1], m2[r6 + 2]), u2 = o(f, m2[l3], m2[l3 + 1], m2[l3 + 2]), d2 = c(g, g, h3), j = c(u2, u2, h3), v2 = _2(d2, d2, j);
    p[e5] += v2[0], p[e5 + 1] += v2[1], p[e5 + 2] += v2[2], p[r6] += v2[0], p[r6 + 1] += v2[1], p[r6 + 2] += v2[2], p[l3] += v2[0], p[l3 + 1] += v2[1], p[l3 + 2] += v2[2];
  }
  for (let n4 = 0; n4 < p.length; n4 += 3) o(l, p[n4], p[n4 + 1], p[n4 + 2]), A(l, l), p[n4] = l[0], p[n4 + 1] = l[1], p[n4 + 2] = l[2];
}
var a2 = n2();
var i5 = n2();
var f = n2();
var l = n2();

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltf.js
var M = () => n.getLogger("esri.geometry.support.meshUtils.exporters.gltf.gltf");
var O = class {
  constructor(e4, t4) {
    this.options = t4, this._materialMap = new Array(), this._imageMap = /* @__PURE__ */ new Map(), this._textureMap = /* @__PURE__ */ new Map(), this.gltf = { asset: { version: "2.0", copyright: e4.copyright, generator: e4.generator }, extras: { output: t4.output, binChunkBuffer: null, promises: [] } }, this._addScenes(e4);
  }
  _addScenes(e4) {
    this.gltf.scene = e4.defaultScene;
    const t4 = this.gltf.extras, s6 = t4.output.buffer === E.GLB || t4.output.image === A2.GLB;
    s6 && (t4.binChunkBuffer = new i4(this.gltf)), e4.forEachScene((e5) => {
      this._addScene(e5);
    }), s6 && t4.binChunkBuffer.finalize();
  }
  _addScene(e4) {
    this.gltf.scenes || (this.gltf.scenes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name), e4.forEachNode((e5) => {
      t4.nodes || (t4.nodes = []), t4.nodes.push(...this._addNodes(e5));
    }), this.gltf.scenes.push(t4);
  }
  _addNodes(e4) {
    this.gltf.nodes || (this.gltf.nodes = []);
    const t4 = {};
    e4.name && (t4.name = e4.name);
    const s6 = e4.translation;
    H(s6, _) || (t4.translation = t(s6));
    const u2 = e4.rotation;
    N(u2, r2) || (t4.rotation = t2(u2));
    const h2 = e4.scale;
    H(h2, s3) || (t4.scale = t(h2));
    const f3 = this.gltf.nodes.length;
    if (this.gltf.nodes.push(t4), e4.mesh && e4.mesh.vertexAttributes.position) {
      const s7 = this._createMeshes(e4.mesh), r5 = [f3];
      if (1 === s7.length) this._addMesh(t4, s7[0]);
      else for (const e5 of s7) {
        const t5 = {};
        this._addMesh(t5, e5), r5.push(this.gltf.nodes.length), this.gltf.nodes.push(t5);
      }
      return r5;
    }
    return e4.forEachNode((e5) => {
      t4.children || (t4.children = []), t4.children.push(...this._addNodes(e5));
    }), [f3];
  }
  _addMesh(e4, t4) {
    var _a;
    (_a = this.gltf).meshes ?? (_a.meshes = []);
    const s6 = this.gltf.meshes.length;
    this.gltf.meshes.push(t4), e4.mesh = s6;
  }
  _createMeshes(e4) {
    var _a;
    const t4 = this.gltf.extras, s6 = t4.output.buffer === E.GLB;
    let r5;
    r5 = s6 ? t4.binChunkBuffer : new i4(this.gltf);
    const i8 = this.options.origin, a3 = e4.vertexSpace.clone();
    a3.origin = [i8.x, i8.y, i8.z ?? 0];
    const o3 = B({ vertexAttributes: e4.vertexAttributes, vertexSpace: e4.vertexSpace, transform: ((_a = this.options) == null ? void 0 : _a.ignoreLocalTransform) ? null : e4.transform, spatialReference: e4.spatialReference }, a3, { targetUnit: this.options.unitConversionDisabled ? void 0 : "meters" });
    if (!o3) return [];
    r4(e4, o3), w(o3);
    const { position: n4, normal: l3, tangent: c4 } = o3, { uv: u2, color: d2 } = e4.vertexAttributes, _3 = r5.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER);
    let T2, R2, A3, E2;
    l3 && (T2 = r5.addBufferView(C2.FLOAT, L.VEC3, R.ARRAY_BUFFER)), u2 && (R2 = r5.addBufferView(C2.FLOAT, L.VEC2, R.ARRAY_BUFFER)), c4 && (A3 = r5.addBufferView(C2.FLOAT, L.VEC4, R.ARRAY_BUFFER)), d2 && (E2 = r5.addBufferView(C2.UNSIGNED_BYTE, L.VEC4, R.ARRAY_BUFFER)), _3.startAccessor("POSITION"), T2 && T2.startAccessor("NORMAL"), R2 && R2.startAccessor("TEXCOORD_0"), A3 && A3.startAccessor("TANGENT"), E2 && E2.startAccessor("COLOR_0");
    const M2 = o3.position.length / 3;
    for (let h2 = 0; h2 < M2; ++h2) _3.push(n4[3 * h2]), _3.push(n4[3 * h2 + 1]), _3.push(n4[3 * h2 + 2]), T2 && null != l3 && (T2.push(l3[3 * h2]), T2.push(l3[3 * h2 + 1]), T2.push(l3[3 * h2 + 2])), R2 && null != u2 && (R2.push(u2[2 * h2]), R2.push(u2[2 * h2 + 1])), A3 && null != c4 && (A3.push(c4[4 * h2]), A3.push(c4[4 * h2 + 1]), A3.push(c4[4 * h2 + 2]), A3.push(c4[4 * h2 + 3])), E2 && null != d2 && (E2.push(d2[4 * h2]), E2.push(d2[4 * h2 + 1]), E2.push(d2[4 * h2 + 2]), E2.push(d2[4 * h2 + 3]));
    const O2 = _3.endAccessor(), v2 = this._addAccessor(_3.index, O2);
    let C3, I2, N3, S, B2;
    if (T2) {
      const e5 = T2.endAccessor();
      C3 = this._addAccessor(T2.index, e5);
    }
    if (R2) {
      const e5 = R2.endAccessor();
      I2 = this._addAccessor(R2.index, e5);
    }
    if (A3) {
      const e5 = A3.endAccessor();
      N3 = this._addAccessor(A3.index, e5);
    }
    if (E2) {
      const e5 = E2.endAccessor();
      S = this._addAccessor(E2.index, e5);
    }
    const L2 = [];
    return e4.components && e4.components.length > 0 && e4.components[0].faces ? (B2 = r5.addBufferView(C2.UNSIGNED_INT, L.SCALAR, R.ELEMENT_ARRAY_BUFFER), this._addMeshVertexIndexed(B2, e4.components, L2, v2, C3, I2, N3, S)) : this._addMeshVertexNonIndexed(e4.components, L2, v2, C3, I2, N3, S), _3.finalize(), T2 && T2.finalize(), R2 && R2.finalize(), A3 && A3.finalize(), B2 && B2.finalize(), E2 && E2.finalize(), s6 || r5.finalize(), L2;
  }
  _addMaterial(e4) {
    if (null === e4) return;
    const t4 = this._materialMap.indexOf(e4);
    if (-1 !== t4) return t4;
    this.gltf.materials || (this.gltf.materials = []);
    const s6 = {};
    switch (e4.alphaMode) {
      case "mask":
        s6.alphaMode = I.MASK;
        break;
      case "auto":
      case "blend":
        s6.alphaMode = I.BLEND;
    }
    s6.alphaCutoff = e4.alphaCutoff, e4.doubleSided && (s6.doubleSided = e4.doubleSided), s6.pbrMetallicRoughness = {};
    const r5 = (e5) => e5 ** 2.1, i8 = (e5) => {
      const t5 = e5.toRgba();
      return t5[0] = r5(t5[0] / 255), t5[1] = r5(t5[1] / 255), t5[2] = r5(t5[2] / 255), t5;
    };
    if (null != e4.color && (s6.pbrMetallicRoughness.baseColorFactor = i8(e4.color)), null != e4.colorTexture && (s6.pbrMetallicRoughness.baseColorTexture = this._createTextureInfo(e4.colorTexture, e4.colorTextureTransform)), null != e4.normalTexture && (s6.normalTexture = this._createTextureInfo(e4.normalTexture, e4.normalTextureTransform)), e4 instanceof m) {
      if (null != e4.emissiveTexture && (s6.emissiveTexture = this._createTextureInfo(e4.emissiveTexture, e4.emissiveTextureTransform)), null != e4.emissiveColor) {
        const t5 = i8(e4.emissiveColor);
        s6.emissiveFactor = [t5[0], t5[1], t5[2]];
      }
      null != e4.occlusionTexture && (s6.occlusionTexture = this._createTextureInfo(e4.occlusionTexture, e4.occlusionTextureTransform)), null != e4.metallicRoughnessTexture && (s6.pbrMetallicRoughness.metallicRoughnessTexture = this._createTextureInfo(e4.metallicRoughnessTexture, e4.metallicRoughnessTextureTransform)), s6.pbrMetallicRoughness.metallicFactor = e4.metallic, s6.pbrMetallicRoughness.roughnessFactor = e4.roughness;
    } else s6.pbrMetallicRoughness.metallicFactor = 1, s6.pbrMetallicRoughness.roughnessFactor = 1, M().warnOnce("Meshes exported to GLTF without MeshMaterialMetallicRoughness material will appear different when imported back.");
    const a3 = this.gltf.materials.length;
    return this.gltf.materials.push(s6), this._materialMap.push(e4), a3;
  }
  _createTextureInfo(e4, t4) {
    const r5 = { index: this._addTexture(e4) };
    return t4 ? (r5.extensions || (r5.extensions = {}), r5.extensions.KHR_texture_transform = { scale: t4.scale, offset: t4.offset, rotation: s2(t4.rotation) }, r5) : r5;
  }
  _addTexture(e4) {
    const s6 = this.gltf.textures ?? [];
    return this.gltf.textures = s6, r(this._textureMap, e4, () => {
      const t4 = { sampler: this._addSampler(e4), source: this._addImage(e4) }, r5 = s6.length;
      return s6.push(t4), r5;
    });
  }
  _addImage(e4) {
    const t4 = this._imageMap.get(e4);
    if (null != t4) return t4;
    this.gltf.images || (this.gltf.images = []);
    const s6 = {};
    if (e4.url) s6.uri = e4.url;
    else {
      const t5 = e4.data;
      s6.extras = t5;
      for (let e5 = 0; e5 < this.gltf.images.length; ++e5) if (t5 === this.gltf.images[e5].extras) return e5;
      const r6 = this.gltf.extras;
      switch (r6.output.image) {
        case A2.GLB: {
          const e5 = r6.binChunkBuffer.addBufferView(C2.UNSIGNED_BYTE, L.SCALAR);
          if (r3(t5)) null != t5.data && e5.writeOutToBuffer(t5.data, 0);
          else {
            const i8 = i(t5, this.options.signal).then(({ data: e6, type: t6 }) => (s6.mimeType = t6, e6));
            r6.promises.push(e5.writeAsync(i8).then(() => {
              e5.finalize();
            }));
          }
          s6.bufferView = e5.index;
          break;
        }
        case A2.DataURI:
          if (r3(t5)) {
            M().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          s6.uri = a(t5);
          break;
        default:
          if (r3(t5)) {
            M().warnOnce("Image export for basis compressed textures not available.");
            break;
          }
          r6.promises.push(i(t5, this.options.signal).then(({ data: e5, type: t6 }) => {
            s6.uri = e5, s6.mimeType = t6;
          }));
      }
    }
    const r5 = this.gltf.images.length;
    return this.gltf.images.push(s6), this._imageMap.set(e4, r5), r5;
  }
  _addSampler(e4) {
    this.gltf.samplers || (this.gltf.samplers = []);
    let t4 = D.REPEAT, s6 = D.REPEAT;
    if ("string" == typeof e4.wrap) switch (e4.wrap) {
      case "clamp":
        t4 = D.CLAMP_TO_EDGE, s6 = D.CLAMP_TO_EDGE;
        break;
      case "mirror":
        t4 = D.MIRRORED_REPEAT, s6 = D.MIRRORED_REPEAT;
    }
    else {
      switch (e4.wrap.vertical) {
        case "clamp":
          s6 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          s6 = D.MIRRORED_REPEAT;
      }
      switch (e4.wrap.horizontal) {
        case "clamp":
          t4 = D.CLAMP_TO_EDGE;
          break;
        case "mirror":
          t4 = D.MIRRORED_REPEAT;
      }
    }
    const r5 = { wrapS: t4, wrapT: s6 };
    for (let a3 = 0; a3 < this.gltf.samplers.length; ++a3) if (JSON.stringify(r5) === JSON.stringify(this.gltf.samplers[a3])) return a3;
    const i8 = this.gltf.samplers.length;
    return this.gltf.samplers.push(r5), i8;
  }
  _addAccessor(e4, t4) {
    this.gltf.accessors || (this.gltf.accessors = []);
    const s6 = { bufferView: e4, byteOffset: t4.byteOffset, componentType: t4.componentType, count: t4.count, type: t4.type, min: t4.min, max: t4.max, name: t4.name };
    t4.normalized && (s6.normalized = true);
    const r5 = this.gltf.accessors.length;
    return this.gltf.accessors.push(s6), r5;
  }
  _addMeshVertexIndexed(e4, t4, s6, r5, i8, a3, o3, n4) {
    const l3 = /* @__PURE__ */ new Map();
    for (const c4 of t4) {
      e4.startAccessor("INDICES");
      for (let s7 = 0; s7 < c4.faces.length; ++s7) e4.push(c4.faces[s7]);
      const t5 = e4.endAccessor(), u2 = { attributes: { POSITION: r5 }, indices: this._addAccessor(e4.index, t5), material: this._addMaterial(c4.material) };
      i8 && "flat" !== c4.shading && (u2.attributes.NORMAL = i8), a3 && (u2.attributes.TEXCOORD_0 = a3), o3 && "flat" !== c4.shading && (u2.attributes.TANGENT = o3), n4 && (u2.attributes.COLOR_0 = n4);
      const h2 = l3.get(c4.name);
      if (h2) h2.primitives.push(u2);
      else {
        const e5 = { name: c4.name, primitives: [u2] };
        l3.set(c4.name, e5), s6.push(e5);
      }
    }
  }
  _addMeshVertexNonIndexed(e4, t4, s6, r5, i8, a3, o3) {
    const n4 = { primitives: [] };
    t4.push(n4);
    const l3 = { attributes: { POSITION: s6 } };
    r5 && (l3.attributes.NORMAL = r5), i8 && (l3.attributes.TEXCOORD_0 = i8), a3 && (l3.attributes.TANGENT = a3), o3 && (l3.attributes.COLOR_0 = o3), e4 && (l3.material = this._addMaterial(e4[0].material)), n4.primitives.push(l3);
  }
};
function w({ position: e4, normal: t4, tangent: s6 }) {
  v(e4, 3), v(t4, 3), v(s6, 4);
}
function v(e4, t4) {
  if (null != e4) for (let s6 = 1, r5 = 2; s6 < e4.length; s6 += t4, r5 += t4) {
    const t5 = e4[s6], i8 = e4[r5];
    e4[s6] = i8, e4[r5] = -t5;
  }
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/asset.js
var s5 = class {
  constructor() {
    this.copyright = "", this.defaultScene = 0, this.generator = "", this._scenes = [];
  }
  addScene(e4) {
    if (this._scenes.includes(e4)) throw new Error("Scene already added");
    this._scenes.push(e4);
  }
  removeScene(s6) {
    C(this._scenes, s6);
  }
  forEachScene(e4) {
    this._scenes.forEach(e4);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/scene.js
var d = class {
  constructor() {
    this.name = "", this._nodes = [];
  }
  addNode(d2) {
    if (this._nodes.includes(d2)) throw new Error("Node already added");
    this._nodes.push(d2);
  }
  forEachNode(d2) {
    this._nodes.forEach(d2);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/node.js
var e3 = class {
  constructor(t4) {
    this.mesh = t4, this.name = "", this.translation = n2(), this.rotation = e(), this.scale = t(s3), this._nodes = [];
  }
  addNode(t4) {
    if (this._nodes.includes(t4)) throw new Error("Node already added");
    this._nodes.push(t4);
  }
  forEachNode(t4) {
    this._nodes.forEach(t4);
  }
  set rotationAngles(s6) {
    T(this.rotation, s6[0], s6[1], s6[2]);
  }
};

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/index.js
var f2 = "model.gltf";
var i6 = "model.glb";
async function u(u2, l3) {
  var _a, _b;
  const c4 = new O(u2, l3).gltf, p = c4.extras.promises;
  let m2 = 1, g = 1, d2 = null;
  await Promise.allSettled(p), s(l3.signal);
  const b = l3.jsonSpacing ?? 4, j = /* @__PURE__ */ new Map(), w2 = JSON.stringify(c4, (e4, t4) => {
    var _a2, _b2;
    if ("extras" !== e4) {
      if (t4 instanceof ArrayBuffer) {
        if (c2(t4)) switch ((_a2 = l3.output) == null ? void 0 : _a2.image) {
          case A2.DataURI:
          case A2.GLB:
            break;
          case A2.External:
          default: {
            const e5 = `img${g}.png`;
            return g++, j.set(e5, t4), e5;
          }
        }
        switch ((_b2 = l3.output) == null ? void 0 : _b2.buffer) {
          case E.DataURI:
            return s4(t4);
          case E.GLB:
            if (d2) throw new Error("Already encountered an ArrayBuffer, there should only be one in the GLB format.");
            return void (d2 = t4);
          case E.External:
          default: {
            const e5 = `data${m2}.bin`;
            return m2++, j.set(e5, t4), e5;
          }
        }
      }
      return t4;
    }
  }, b);
  return ((_a = l3.output) == null ? void 0 : _a.buffer) === E.GLB || ((_b = l3.output) == null ? void 0 : _b.image) === A2.GLB ? j.set(i6, new e2(w2, d2).buffer) : j.set(f2, w2), j;
}
async function l2(e4, t4) {
  const r5 = (await u(e4, { output: { buffer: E.GLB, image: A2.GLB }, jsonSpacing: 0, ...t4 })).get(i6);
  if (!(r5 && r5 instanceof ArrayBuffer)) throw new Error("failed to export to glb");
  return r5;
}

// node_modules/@arcgis/core/geometry/support/meshUtils/exporters/gltf/gltfexport.js
async function i7(i8, t4) {
  const s6 = new s5(), m2 = new d();
  return s6.addScene(m2), m2.addNode(new e3(i8)), await l2(s6, { origin: i8.origin, ...t4 });
}
export {
  i7 as toBinaryGLTF
};
//# sourceMappingURL=gltfexport-NXJ5S463.js.map
