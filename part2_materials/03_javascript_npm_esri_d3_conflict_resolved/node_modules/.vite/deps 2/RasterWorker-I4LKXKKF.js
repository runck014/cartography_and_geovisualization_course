import {
  T,
  a as a2,
  c,
  y
} from "./chunk-3UU6HCT2.js";
import {
  ie,
  v,
  w as w2
} from "./chunk-QOUKS7KN.js";
import {
  _,
  h,
  j as j2,
  m3 as m
} from "./chunk-3YPKNKEV.js";
import {
  D,
  E,
  R,
  U,
  W,
  f2 as f,
  g,
  s3 as s2,
  u3 as u
} from "./chunk-OIUY22MH.js";
import "./chunk-UFFVFTYV.js";
import "./chunk-GNY4KZ34.js";
import "./chunk-X5EOLPIE.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-AMH7OVBF.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-VFTH6C2E.js";
import {
  r as r2
} from "./chunk-UYSPJCCV.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import {
  s
} from "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-X6JBJVM2.js";
import {
  j2 as j,
  w
} from "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import {
  a4 as a
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var a3 = e = class extends a2 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
r([r2({ IdentityXform: "identity" })], a3.prototype, "type", void 0), a3 = e = r([a("esri.layers.support.rasterTransforms.IdentityTransform")], a3);
var p = a3;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o = { GCSShiftXform: c, IdentityXform: p, PolynomialXform: y };
var e2 = Object.keys(o);
function i(r3) {
  const t = r3 == null ? void 0 : r3.type;
  if (!t) return null;
  const n = o[r3 == null ? void 0 : r3.type];
  if (n) {
    const t2 = new n();
    return t2.read(r3), t2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var J = class {
  convertVectorFieldData(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = f(t, r3.type);
    return Promise.resolve(null != s3 ? s3.toJSON() : null);
  }
  computeStatisticsHistograms(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = m(t);
    return Promise.resolve(s3);
  }
  async decode(r3) {
    const e3 = await j2(r3.data, r3.options);
    return e3 && e3.toJSON();
  }
  symbolize(r3) {
    r3.pixelBlock = g.fromJSON(r3.pixelBlock), r3.extent = r3.extent ? w.fromJSON(r3.extent) : null;
    const t = this.symbolizer.symbolize(r3);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  async updateSymbolizer(r3) {
    var _a;
    this.symbolizer = _.fromJSON(r3.symbolizerJSON), r3.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r3.histograms);
  }
  async updateRasterFunction(r3) {
    this.rasterFunction = T(r3.rasterFunctionJSON);
  }
  async process(r3) {
    var _a;
    const t = this.rasterFunction.process({ extent: w.fromJSON(r3.extent), primaryPixelBlocks: r3.primaryPixelBlocks.map((r4) => null != r4 ? g.fromJSON(r4) : null), primaryPixelSizes: (_a = r3.primaryPixelSizes) == null ? void 0 : _a.map((r4) => null != r4 ? j.fromJSON(r4) : null), primaryRasterIds: r3.primaryRasterIds });
    return null != t ? t.toJSON() : null;
  }
  stretch(r3) {
    const t = this.symbolizer.simpleStretch(g.fromJSON(r3.srcPixelBlock), r3.stretchParams);
    return Promise.resolve(t == null ? void 0 : t.toJSON());
  }
  estimateStatisticsHistograms(r3) {
    const t = h(g.fromJSON(r3.srcPixelBlock));
    return Promise.resolve(t);
  }
  split(r3) {
    const t = W(g.fromJSON(r3.srcPixelBlock), r3.tileSize, r3.maximumPyramidLevel ?? 0, false === r3.useBilinear);
    return t && t.forEach((r4, e3) => {
      t.set(e3, r4 == null ? void 0 : r4.toJSON());
    }), Promise.resolve(t);
  }
  clipTile(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = E({ ...r3, pixelBlock: t });
    return Promise.resolve(s3 == null ? void 0 : s3.toJSON());
  }
  async mosaicAndTransform(r3) {
    const t = r3.srcPixelBlocks.map((r4) => r4 ? new g(r4) : null), s3 = U(t, r3.srcMosaicSize, { blockWidths: r3.blockWidths, alignmentInfo: r3.alignmentInfo, clipOffset: r3.clipOffset, clipSize: r3.clipSize });
    let o2, l = s3;
    return r3.coefs && (l = D(s3, r3.destDimension, r3.coefs, r3.sampleSpacing, r3.interpolation)), r3.projectDirections && r3.gcsGrid && (o2 = R(r3.destDimension, r3.gcsGrid), l = u(l, r3.isUV ? "vector-uv" : "vector-magdir", o2)), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: o2 };
  }
  async createFlowMesh(r3, e3) {
    const t = { data: new Float32Array(r3.flowData.buffer), mask: new Uint8Array(r3.flowData.maskBuffer), width: r3.flowData.width, height: r3.flowData.height }, { vertexData: s3, indexData: o2 } = await s2(r3.meshType, r3.simulationSettings, t, e3.signal);
    return { result: { vertexBuffer: s3.buffer, indexBuffer: o2.buffer }, transferList: [s3.buffer, o2.buffer] };
  }
  async getProjectionOffsetGrid(e3) {
    const t = w.fromJSON(e3.projectedExtent), s3 = w.fromJSON(e3.srcBufferExtent);
    let o2 = null;
    e3.datumTransformationSteps && (o2 = new s({ steps: e3.datumTransformationSteps })), (e3.includeGCSGrid || w2(t.spatialReference, s3.spatialReference, o2)) && await v();
    const i2 = e3.rasterTransform ? i(e3.rasterTransform) : null;
    return ie({ ...e3, projectedExtent: t, srcBufferExtent: s3, datumTransformation: o2, rasterTransform: i2 });
  }
};
export {
  J as default
};
//# sourceMappingURL=RasterWorker-I4LKXKKF.js.map
