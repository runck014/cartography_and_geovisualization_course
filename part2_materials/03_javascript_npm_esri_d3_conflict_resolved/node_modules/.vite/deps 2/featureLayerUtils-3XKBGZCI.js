import {
  $,
  I,
  P,
  d as d2,
  f as f2,
  m,
  p,
  v,
  w,
  y
} from "./chunk-JGBVBEGF.js";
import {
  i as i3
} from "./chunk-JEA2CH67.js";
import "./chunk-FDS5NNQY.js";
import "./chunk-ACRZEGQW.js";
import {
  i,
  t
} from "./chunk-WHBT5WHI.js";
import "./chunk-VZ5SMATQ.js";
import {
  a as a2
} from "./chunk-7HWB7LKO.js";
import "./chunk-HJ7SKBLO.js";
import {
  a,
  f,
  i as i2,
  l,
  u
} from "./chunk-2DHZIDQK.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import {
  d
} from "./chunk-TDZ623HP.js";
import {
  L
} from "./chunk-6RLUKSNK.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-BMGF5ELJ.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F,
  c,
  h
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/save/featureLayerUtils.js
var L2 = "Feature Service";
var P2 = "feature-layer-utils";
var N = `${P2}-save`;
var $2 = `${P2}-save-as`;
var g = `${P2}-saveall`;
var x = `${P2}-saveall-as`;
function O(e) {
  return { isValid: L(e) && (!("dynamicDataSource" in e) || !e.dynamicDataSource), errorMessage: "Feature layer should be a layer or table in a map or feature service" };
}
function R(e) {
  const r = [], a3 = [];
  for (const { layer: t2, layerJSON: n } of e) t2.isTable ? a3.push(n) : r.push(n);
  return { layers: r, tables: a3 };
}
function U(e) {
  return R([e]);
}
async function j(e, r) {
  return /\/\d+\/?$/.test(e.url) ? U(r[0]) : M(r, e);
}
async function M(e, r) {
  if (e.reverse(), !r) return R(e);
  const a3 = await D(r, e);
  for (const t2 of e) k(t2.layer, t2.layerJSON, a3);
  return _(a3, e), a3;
}
async function D(e, r) {
  let a3 = await e.fetchData("json");
  if (J(a3)) return a3;
  a3 || (a3 = {}), Y(a3);
  const { layer: { url: t2, customParameters: n, apiKey: o } } = r[0];
  return await K(a3, { url: t2 ?? "", customParameters: n, apiKey: o }, r.map((e2) => e2.layer.layerId)), a3;
}
function J(e) {
  return !!(e && Array.isArray(e.layers) && Array.isArray(e.tables));
}
function Y(e) {
  e.layers || (e.layers = []), e.tables || (e.tables = []);
}
function _(e, r) {
  const a3 = [], t2 = [];
  for (const { layer: n } of r) {
    const { isTable: e2, layerId: r2 } = n;
    e2 ? t2.push(r2) : a3.push(r2);
  }
  F2(e.layers, a3), F2(e.tables, t2);
}
function F2(r, a3) {
  if (r.length < 2) return;
  const t2 = [];
  for (const { id: e } of r) t2.push(e);
  c(t2.sort(G), a3.slice().sort(G)) && r.sort((e, r2) => {
    const t3 = a3.indexOf(e.id), n = a3.indexOf(r2.id);
    return t3 < n ? -1 : t3 > n ? 1 : 0;
  });
}
function G(e, r) {
  return e < r ? -1 : e > r ? 1 : 0;
}
async function K(e, r, a3) {
  const { url: t2, customParameters: n, apiKey: o } = r, { serviceJSON: s2, layersJSON: i4 } = await t(t2, { customParameters: n, apiKey: o }), l2 = z(e.layers, s2.layers, a3), c2 = z(e.tables, s2.tables, a3);
  e.layers = l2.itemResources, e.tables = c2.itemResources;
  const u2 = [...l2.added, ...c2.added], p2 = i4 ? [...i4.layers, ...i4.tables] : [];
  await B(e, u2, t2, p2);
}
function z(e, a3, t2) {
  const n = h(e, a3, (e2, r) => e2.id === r.id);
  e = e.filter((e2) => !n.removed.some((r) => r.id === e2.id));
  const o = n.added;
  return o.forEach(({ id: r }) => {
    e.push({ id: r });
  }), { itemResources: e, added: o.filter(({ id: e2 }) => !t2.includes(e2)) };
}
async function B(e, r, a3, t2) {
  const n = await V(r), o = r.map(({ id: e2, type: r2 }) => new (n.get(r2))({ url: a3, layerId: e2, sourceJSON: t2.find(({ id: r3 }) => r3 === e2) }));
  await Promise.allSettled(o.map((e2) => e2.load())), o.forEach((r2) => {
    const { layerId: a4, loaded: t3, defaultPopupTemplate: n2 } = r2;
    if (!t3 || null == n2) return;
    const o2 = { id: a4, popupInfo: n2.toJSON() };
    "ArcGISFeatureLayer" !== r2.operationalLayerType && (o2.layerType = r2.operationalLayerType), k(r2, o2, e);
  });
}
async function V(e) {
  const r = [];
  e.forEach(({ type: e2 }) => {
    const a4 = i(e2), t3 = a2[a4];
    r.push(t3());
  });
  const a3 = await Promise.all(r), t2 = /* @__PURE__ */ new Map();
  return e.forEach(({ type: e2 }, r2) => {
    t2.set(e2, a3[r2]);
  }), t2;
}
function k(e, r, a3) {
  e.isTable ? q(a3.tables, r) : q(a3.layers, r);
}
function q(e, r) {
  const a3 = e.findIndex(({ id: e2 }) => e2 === r.id);
  -1 === a3 ? e.push(r) : e[a3] = r;
}
function C(e, r) {
  if (!e.length) throw new s(`${r}:missing-parameters`, "'layers' array should contain at least one feature layer");
}
function H(e, r) {
  const a3 = e.map((e2) => e2.portalItem.id);
  if (new Set(a3).size > 1) throw new s(`${r}:invalid-parameters`, "All layers in the 'layers' array should be loaded from the same portal item");
}
function Q(e, r) {
  const a3 = e.map((e2) => e2.layerId);
  if (new Set(a3).size !== a3.length) throw new s(`${r}:invalid-parameters`, "'layers' array should contain only one instance each of layer or table in a feature service");
}
async function W(e) {
  C(e, g), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p(r, g, O), f2({ layer: r, itemType: L2, errorNamePrefix: g });
  H(e, g), Q(e, g);
}
function X(e, r) {
  const a3 = e.layers.some((e2) => "OrientedImageryLayer" === e2.layerType);
  u(r, f.ORIENTED_IMAGERY_LAYER, a3);
}
function Z(e, r) {
  const a3 = e.some((e2) => "oriented-imagery" === e2.type);
  u(r, f.ORIENTED_IMAGERY_LAYER, a3);
}
async function ee(e, r, a3) {
  X(a3, r);
}
async function re(e, r) {
  const { url: a3, layerId: t2, title: n, fullExtent: o, isTable: s2 } = e, i4 = d(a3);
  r.url = ("FeatureServer" === (i4 == null ? void 0 : i4.serverType) ? a3 : `${a3}/${t2}`) ?? null, r.title || (r.title = n), r.extent = null, s2 || null == o || (r.extent = await l(o)), a(r, f.METADATA), a(r, f.MULTI_LAYER), i2(r, f.SINGLE_LAYER), u(r, f.TABLE, s2), Z([e], r);
}
function ae(e, r) {
  for (const s2 of e) {
    const a4 = s2.parsedUrl.path, n2 = d(a4), o2 = n2 == null ? void 0 : n2.url.path;
    if (!o2) throw new s(`${r}:invalid-parameters`, m(s2, `has unsupported url pattern: ${a4}`), { layer: s2 });
    const i4 = n2 == null ? void 0 : n2.serverType;
    if ("FeatureServer" !== i4 && "MapServer" !== i4) throw new s(`${r}:invalid-parameters`, m(s2, `has unsupported server type: ${i4}`), { layer: s2 });
    if ("MapServer" === i4 && e.length > 1) throw new s(`${r}:invalid-parameters`, "Only one layer or table in a map service can be saved");
  }
  const a3 = d(e[0].parsedUrl.path), n = a3 == null ? void 0 : a3.url.path, o = e.every((e2) => {
    const r2 = d(e2.parsedUrl.path);
    return (r2 == null ? void 0 : r2.url.path) === n;
  });
  if (!o) throw new s(`${r}:invalid-parameters`, "'layers' array should only contain layers or tables that belong to the same feature service");
}
async function te(e) {
  C(e, x), await Promise.all(e.map((e2) => e2.load()));
  for (const r of e) p(r, x, O);
  ae(e, x), Q(e, x);
}
function ne(e, r) {
  X(r, e), I(e);
}
async function oe(e, r) {
  let t2 = 0, n = 0;
  for (const { isTable: a3 } of r) a3 ? n++ : t2++;
  const o = r[0].parsedUrl.path, s2 = d(o);
  if (e.url = "FeatureServer" === (s2 == null ? void 0 : s2.serverType) ? s2.url.path : o, e.title || (e.title = s2.title), e.extent = null, t2 > 0) {
    const t3 = r.map((e2) => e2.fullExtent).filter(F).reduce((e2, r2) => e2.clone().union(r2));
    t3 && (e.extent = await l(t3));
  }
  a(e, f.METADATA), u(e, f.MULTI_LAYER, r.length > 1), u(e, f.SINGLE_LAYER, 1 === r.length), u(e, f.TABLE, n > 0 && 0 === t2), Z(r, e), I(e);
}
async function se(e, r) {
  return P({ layer: e, itemType: L2, validateLayer: O, createItemData: (e2, r2) => j(r2, [e2]), errorNamePrefix: N, setItemProperties: ee }, r);
}
async function ie(e, r) {
  await W(e);
  const a3 = e[0].portalItem, t2 = y(a3), o = await Promise.all(e.map((e2) => w(e2, t2, r))), l2 = await j(a3, e.map((e2, r2) => ({ layer: e2, layerJSON: o[r2] })));
  return ne(a3, l2), await a3.update({ data: l2 }), await Promise.all(e.slice(1).map((e2) => e2.portalItem.reload())), i3(t2), a3.clone();
}
async function le(e, r, a3) {
  return $({ layer: e, itemType: L2, validateLayer: O, createItemData: (e2, r2) => Promise.resolve(U(e2)), errorNamePrefix: $2, newItem: r, setItemProperties: re }, a3);
}
async function ce(e, r, a3) {
  await te(e);
  const t2 = d2({ itemType: L2, errorNamePrefix: x, newItem: r }), o = y(t2), l2 = await Promise.all(e.map((e2) => w(e2, o, a3))), p2 = await M(e.map((e2, r2) => ({ layer: e2, layerJSON: l2[r2] })));
  await oe(t2, e), await v(t2, p2, a3);
  for (const n of e) n.portalItem = t2.clone();
  return i3(o), t2;
}
export {
  se as save,
  ie as saveAll,
  ce as saveAllAs,
  le as saveAs
};
//# sourceMappingURL=featureLayerUtils-3XKBGZCI.js.map
