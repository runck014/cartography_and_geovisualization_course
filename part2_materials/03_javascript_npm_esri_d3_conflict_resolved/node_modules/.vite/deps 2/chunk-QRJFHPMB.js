import {
  n
} from "./chunk-G6REFQRQ.js";
import {
  d
} from "./chunk-DRBJFCLQ.js";
import {
  c
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/geometry/support/coordsUtils.js
function i(t, n2) {
  const r = n2[0] - t[0], e = n2[1] - t[1];
  if (t.length > 2 && n2.length > 2) {
    const i2 = t[2] - n2[2];
    return Math.sqrt(r * r + e * e + i2 * i2);
  }
  return Math.sqrt(r * r + e * e);
}
function o(t, n2, r) {
  const e = t[0] + r * (n2[0] - t[0]), i2 = t[1] + r * (n2[1] - t[1]);
  return t.length > 2 && n2.length > 2 ? [e, i2, t[2] + r * (n2[2] - t[2])] : [e, i2];
}
function s(t, n2, r, e) {
  return f(t, n2, r[e], r[e + 1]);
}
function f(t, n2, r, e) {
  const [i2, o2] = n2, [s2, f2] = r, [u, l2] = e, c3 = u - s2, h2 = l2 - f2, p = c3 * c3 + h2 * h2, a2 = (i2 - s2) * c3 + (o2 - f2) * h2, y2 = Math.min(1, Math.max(0, a2 / p));
  return t[0] = s2 + c3 * y2, t[1] = f2 + h2 * y2, t;
}
function l(t, n2, r, e, i2, o2) {
  let s2 = r, f2 = e, u = i2 - s2, l2 = o2 - f2;
  if (0 !== u || 0 !== l2) {
    const r2 = ((t - s2) * u + (n2 - f2) * l2) / (u * u + l2 * l2);
    r2 > 1 ? (s2 = i2, f2 = o2) : r2 > 0 && (s2 += u * r2, f2 += l2 * r2);
  }
  return u = t - s2, l2 = n2 - f2, u * u + l2 * l2;
}
function c2(t, n2) {
  return o(t, n2, 0.5);
}
function h(t) {
  const n2 = t.length;
  let r = 0;
  for (let e = 0; e < n2 - 1; ++e) r += i(t[e], t[e + 1]);
  return r;
}
function a(t, r = n.X, e = n.Y) {
  let i2 = 0;
  const o2 = t.length;
  let s2 = t[0];
  for (let n2 = 1; n2 < o2; n2++) {
    const o3 = t[n2];
    i2 += (o3[r] - s2[r]) * (o3[e] + s2[e]), s2 = o3;
  }
  if (!y(t)) {
    const n2 = t[0];
    i2 += (n2[r] - s2[r]) * (n2[e] + s2[e]);
  }
  return i2 >= 0;
}
function y(n2) {
  const r = n2.length;
  return r < 3 || c(n2[0], n2[r - 1]);
}
function m(t) {
  "rings" in t && (g(t), x(t));
}
function g(t) {
  if (!("rings" in t)) return false;
  let n2 = false;
  for (const r of t.rings) y(r) || (r.push(r[0].slice()), n2 = true);
  return n2;
}
function x(t) {
  if (!("rings" in t)) return false;
  if (0 === t.rings.length || a(t.rings[0])) return false;
  for (const n2 of t.rings) n2.reverse();
  return true;
}
function M(t) {
  if ("polygon" !== t.type && "polyline" !== t.type) return t;
  return z("polygon" === t.type ? t.rings : t.paths, t.spatialReference), t;
}
function z(t, n2) {
  const e = d(n2);
  if (!e) return;
  const i2 = e.valid[0], o2 = e.valid[1], s2 = o2 - i2;
  for (const r of t) {
    let t2 = 1 / 0, n3 = -1 / 0;
    for (const s3 of r) {
      const r2 = v(s3[0], i2, o2);
      t2 = Math.min(t2, r2), n3 = Math.max(n3, r2), s3[0] = r2;
    }
    const e2 = n3 - t2;
    s2 - e2 < e2 && r.forEach((t3) => {
      t3[0] < 0 && (t3[0] += s2);
    });
  }
}
function v(t, n2, r) {
  const e = r - n2;
  return t < n2 ? r - (n2 - t) % e : t > r ? n2 + (t - n2) % e : t;
}
function j(t, n2) {
  if (t === n2) return true;
  if (t.type !== n2.type) return false;
  if ("point" === t.type || "mesh" === t.type || "extent" === t.type) return true;
  if ("multipoint" === t.type) return t.points.length === n2.points.length;
  const [r, e] = "polyline" === t.type ? [t.paths, n2.paths] : [t.rings, n2.rings];
  return r.length === e.length && r.every((t2, n3) => t2.length === e[n3].length);
}

export {
  i,
  s,
  f,
  l,
  c2 as c,
  h,
  a,
  m,
  g,
  M,
  z,
  j
};
//# sourceMappingURL=chunk-QRJFHPMB.js.map
