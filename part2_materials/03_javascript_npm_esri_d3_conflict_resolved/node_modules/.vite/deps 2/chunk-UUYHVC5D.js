import {
  B,
  C as C2,
  D,
  E as E2,
  F,
  H,
  S4 as S2,
  o,
  q,
  w3 as w2
} from "./chunk-JI3JMSDL.js";
import {
  e as e3
} from "./chunk-J3GKRP7Y.js";
import {
  a as a4,
  o as o2,
  r as r2,
  s2 as s6
} from "./chunk-Q3K5MAUZ.js";
import {
  A as A2,
  O,
  Q,
  a as a2,
  g,
  i2 as i4,
  s as s3,
  s2 as s5
} from "./chunk-KJNFPIQW.js";
import {
  a as a5,
  c,
  i as i5
} from "./chunk-C7P44RVS.js";
import {
  e as e2,
  i as i2,
  l as l2
} from "./chunk-HCAIFU2M.js";
import {
  s as s2
} from "./chunk-KI5F6KDS.js";
import {
  n as n3
} from "./chunk-73FHIZIF.js";
import {
  a as a3,
  i as i3,
  s as s4
} from "./chunk-ICIPRMPO.js";
import {
  A,
  G,
  R,
  a,
  mi,
  ti,
  yi,
  zi
} from "./chunk-CGJUTDVJ.js";
import {
  C
} from "./chunk-KV3S4QI2.js";
import {
  S
} from "./chunk-LP6TMAPE.js";
import {
  E
} from "./chunk-MR727DXB.js";
import {
  U,
  e,
  i,
  n as n2,
  w
} from "./chunk-VLKWWBLY.js";
import {
  l
} from "./chunk-VFTH6C2E.js";
import {
  u
} from "./chunk-YVSEBNS4.js";
import {
  t
} from "./chunk-VNRDIGVF.js";
import {
  r
} from "./chunk-6YWQXXBX.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/bufcut.js
function e4(e9, t4, r6, i14, u6, o9, l8) {
  D2 = 0;
  const y3 = (i14 - r6) * o9, p6 = u6 && u6.length, c8 = p6 ? (u6[0] - r6) * o9 : y3;
  let v3, s13, h7, d6, Z2, a10 = n4(t4, r6, i14, 0, c8, o9, true);
  if (a10 && a10.next !== a10.prev) {
    if (p6 && (a10 = f(t4, r6, i14, u6, a10, o9)), y3 > 80 * o9) {
      v3 = h7 = t4[0 + r6 * o9], s13 = d6 = t4[1 + r6 * o9];
      for (let e10 = o9; e10 < c8; e10 += o9) {
        const n11 = t4[e10 + r6 * o9], x5 = t4[e10 + 1 + r6 * o9];
        v3 = Math.min(v3, n11), s13 = Math.min(s13, x5), h7 = Math.max(h7, n11), d6 = Math.max(d6, x5);
      }
      Z2 = Math.max(h7 - v3, d6 - s13), Z2 = 0 !== Z2 ? 1 / Z2 : 0;
    }
    x(a10, e9, o9, v3, s13, Z2, l8, 0);
  }
}
function n4(e9, n11, t4, x5, r6, i14, l8) {
  let f6;
  if (l8 === Z(e9, n11, t4, x5, r6, i14) > 0) for (let o9 = x5; o9 < r6; o9 += i14) f6 = u2(o9 + n11 * i14, e9[o9 + n11 * i14], e9[o9 + 1 + n11 * i14], f6);
  else for (let o9 = r6 - i14; o9 >= x5; o9 -= i14) f6 = u2(o9 + n11 * i14, e9[o9 + n11 * i14], e9[o9 + 1 + n11 * i14], f6);
  return f6 && m(f6, f6.next) && (o3(f6), f6 = f6.next), f6;
}
function t2(e9, n11 = e9) {
  if (!e9) return e9;
  let t4, x5 = e9;
  do {
    if (t4 = false, x5.steiner || !m(x5, x5.next) && 0 !== s7(x5.prev, x5, x5.next)) x5 = x5.next;
    else {
      if (o3(x5), x5 = n11 = x5.prev, x5 === x5.next) break;
      t4 = true;
    }
  } while (t4 || x5 !== n11);
  return n11;
}
function x(e9, n11, u6, l8, f6, y3, p6, v3) {
  if (!e9) return;
  !v3 && y3 && (e9 = c2(e9, l8, f6, y3));
  let s13 = e9;
  for (; e9.prev !== e9.next; ) {
    const c8 = e9.prev, h7 = e9.next;
    if (y3 ? i6(e9, l8, f6, y3) : r3(e9)) n11.push(c8.index / u6 + p6), n11.push(e9.index / u6 + p6), n11.push(h7.index / u6 + p6), o3(e9), e9 = h7.next, s13 = h7.next;
    else if ((e9 = h7) === s13) {
      v3 ? 1 === v3 ? x(e9 = b(e9, n11, u6, p6), n11, u6, l8, f6, y3, p6, 2) : 2 === v3 && g2(e9, n11, u6, l8, f6, y3, p6) : x(t2(e9), n11, u6, l8, f6, y3, p6, 1);
      break;
    }
  }
}
function r3(e9) {
  const n11 = e9.prev, t4 = e9, x5 = e9.next;
  if (s7(n11, t4, x5) >= 0) return false;
  let r6 = e9.next.next;
  const i14 = r6;
  let u6 = 0;
  for (; r6 !== e9.prev && (0 === u6 || r6 !== i14); ) {
    if (u6++, a6(n11.x, n11.y, t4.x, t4.y, x5.x, x5.y, r6.x, r6.y) && s7(r6.prev, r6, r6.next) >= 0) return false;
    r6 = r6.next;
  }
  return true;
}
function i6(e9, n11, t4, x5) {
  const r6 = e9.prev, i14 = e9, u6 = e9.next;
  if (s7(r6, i14, u6) >= 0) return false;
  const o9 = r6.x < i14.x ? r6.x < u6.x ? r6.x : u6.x : i14.x < u6.x ? i14.x : u6.x, l8 = r6.y < i14.y ? r6.y < u6.y ? r6.y : u6.y : i14.y < u6.y ? i14.y : u6.y, f6 = r6.x > i14.x ? r6.x > u6.x ? r6.x : u6.x : i14.x > u6.x ? i14.x : u6.x, y3 = r6.y > i14.y ? r6.y > u6.y ? r6.y : u6.y : i14.y > u6.y ? i14.y : u6.y, p6 = z(o9, l8, n11, t4, x5), c8 = z(f6, y3, n11, t4, x5);
  let v3 = e9.prevZ, h7 = e9.nextZ;
  for (; v3 && v3.z >= p6 && h7 && h7.z <= c8; ) {
    if (v3 !== e9.prev && v3 !== e9.next && a6(r6.x, r6.y, i14.x, i14.y, u6.x, u6.y, v3.x, v3.y) && s7(v3.prev, v3, v3.next) >= 0) return false;
    if (v3 = v3.prevZ, h7 !== e9.prev && h7 !== e9.next && a6(r6.x, r6.y, i14.x, i14.y, u6.x, u6.y, h7.x, h7.y) && s7(h7.prev, h7, h7.next) >= 0) return false;
    h7 = h7.nextZ;
  }
  for (; v3 && v3.z >= p6; ) {
    if (v3 !== e9.prev && v3 !== e9.next && a6(r6.x, r6.y, i14.x, i14.y, u6.x, u6.y, v3.x, v3.y) && s7(v3.prev, v3, v3.next) >= 0) return false;
    v3 = v3.prevZ;
  }
  for (; h7 && h7.z <= c8; ) {
    if (h7 !== e9.prev && h7 !== e9.next && a6(r6.x, r6.y, i14.x, i14.y, u6.x, u6.y, h7.x, h7.y) && s7(h7.prev, h7, h7.next) >= 0) return false;
    h7 = h7.nextZ;
  }
  return true;
}
function u2(e9, n11, t4, x5) {
  const r6 = q2.create(e9, n11, t4);
  return x5 ? (r6.next = x5.next, r6.prev = x5, x5.next.prev = r6, x5.next = r6) : (r6.prev = r6, r6.next = r6), r6;
}
function o3(e9) {
  e9.next.prev = e9.prev, e9.prev.next = e9.next, e9.prevZ && (e9.prevZ.nextZ = e9.nextZ), e9.nextZ && (e9.nextZ.prevZ = e9.prevZ);
}
function l3(e9) {
  let n11 = e9, t4 = e9;
  do {
    (n11.x < t4.x || n11.x === t4.x && n11.y < t4.y) && (t4 = n11), n11 = n11.next;
  } while (n11 !== e9);
  return t4;
}
function f(e9, t4, x5, r6, i14, u6) {
  const o9 = new Array();
  for (let f6 = 0, y3 = r6.length; f6 < y3; f6++) {
    const i15 = n4(e9, t4, x5, r6[f6] * u6, f6 < y3 - 1 ? r6[f6 + 1] * u6 : x5 * u6, u6, false);
    i15 === i15.next && (i15.steiner = true), o9.push(l3(i15));
  }
  o9.sort(M);
  for (const n11 of o9) i14 = y(n11, i14);
  return i14;
}
function y(e9, n11) {
  const x5 = p(e9, n11);
  if (!x5) return n11;
  const r6 = A3(x5, e9);
  return t2(r6, r6.next), t2(x5, x5.next);
}
function p(e9, n11) {
  let t4 = n11;
  const x5 = e9.x, r6 = e9.y;
  let i14, u6 = -1 / 0;
  do {
    if (r6 <= t4.y && r6 >= t4.next.y && t4.next.y !== t4.y) {
      const e10 = t4.x + (r6 - t4.y) * (t4.next.x - t4.x) / (t4.next.y - t4.y);
      if (e10 <= x5 && e10 > u6) {
        if (u6 = e10, e10 === x5) {
          if (r6 === t4.y) return t4;
          if (r6 === t4.next.y) return t4.next;
        }
        i14 = t4.x < t4.next.x ? t4 : t4.next;
      }
    }
    t4 = t4.next;
  } while (t4 !== n11);
  if (!i14) return null;
  if (x5 === u6) return i14.prev;
  const o9 = i14, l8 = i14.x, f6 = i14.y;
  let y3, p6 = 1 / 0;
  for (t4 = i14.next; t4 !== o9; ) x5 >= t4.x && t4.x >= l8 && x5 !== t4.x && a6(r6 < f6 ? x5 : u6, r6, l8, f6, r6 < f6 ? u6 : x5, r6, t4.x, t4.y) && (y3 = Math.abs(r6 - t4.y) / (x5 - t4.x), (y3 < p6 || y3 === p6 && t4.x > i14.x) && w3(t4, e9) && (i14 = t4, p6 = y3)), t4 = t4.next;
  return i14;
}
function c2(e9, n11, t4, x5) {
  let r6;
  for (; r6 !== e9; r6 = r6.next) {
    if (r6 = r6 || e9, null === r6.z && (r6.z = z(r6.x, r6.y, n11, t4, x5)), r6.prev.next !== r6 || r6.next.prev !== r6) return r6.prev.next = r6, r6.next.prev = r6, c2(e9, n11, t4, x5);
    r6.prevZ = r6.prev, r6.nextZ = r6.next;
  }
  return e9.prevZ.nextZ = null, e9.prevZ = null, v(e9);
}
function v(e9) {
  let n11, t4 = 1;
  for (; ; ) {
    let x5, r6 = e9;
    e9 = null, n11 = null;
    let i14 = 0;
    for (; r6; ) {
      i14++, x5 = r6;
      let u6 = 0;
      for (; u6 < t4 && x5; u6++) x5 = x5.nextZ;
      let o9 = t4;
      for (; u6 > 0 || o9 > 0 && x5; ) {
        let t5;
        0 === u6 ? (t5 = x5, x5 = x5.nextZ, o9--) : 0 !== o9 && x5 ? r6.z <= x5.z ? (t5 = r6, r6 = r6.nextZ, u6--) : (t5 = x5, x5 = x5.nextZ, o9--) : (t5 = r6, r6 = r6.nextZ, u6--), n11 ? n11.nextZ = t5 : e9 = t5, t5.prevZ = n11, n11 = t5;
      }
      r6 = x5;
    }
    if (n11.nextZ = null, t4 *= 2, i14 < 2) return e9;
  }
}
function s7(e9, n11, t4) {
  return (n11.y - e9.y) * (t4.x - n11.x) - (n11.x - e9.x) * (t4.y - n11.y);
}
function h(e9, n11, t4, x5) {
  return !!(m(e9, n11) && m(t4, x5) || m(e9, x5) && m(t4, n11)) || s7(e9, n11, t4) > 0 != s7(e9, n11, x5) > 0 && s7(t4, x5, e9) > 0 != s7(t4, x5, n11) > 0;
}
function d(e9, n11) {
  let t4 = e9;
  do {
    if (t4.index !== e9.index && t4.next.index !== e9.index && t4.index !== n11.index && t4.next.index !== n11.index && h(t4, t4.next, e9, n11)) return true;
    t4 = t4.next;
  } while (t4 !== e9);
  return false;
}
function Z(e9, n11, t4, x5, r6, i14) {
  let u6 = 0;
  for (let o9 = x5, l8 = r6 - i14; o9 < r6; o9 += i14) u6 += (e9[l8 + n11 * i14] - e9[o9 + n11 * i14]) * (e9[o9 + 1 + n11 * i14] + e9[l8 + 1 + n11 * i14]), l8 = o9;
  return u6;
}
function a6(e9, n11, t4, x5, r6, i14, u6, o9) {
  return (r6 - u6) * (n11 - o9) - (e9 - u6) * (i14 - o9) >= 0 && (e9 - u6) * (x5 - o9) - (t4 - u6) * (n11 - o9) >= 0 && (t4 - u6) * (i14 - o9) - (r6 - u6) * (x5 - o9) >= 0;
}
function w3(e9, n11) {
  return s7(e9.prev, e9, e9.next) < 0 ? s7(e9, n11, e9.next) >= 0 && s7(e9, e9.prev, n11) >= 0 : s7(e9, n11, e9.prev) < 0 || s7(e9, e9.next, n11) < 0;
}
function z(e9, n11, t4, x5, r6) {
  return (e9 = 1431655765 & ((e9 = 858993459 & ((e9 = 252645135 & ((e9 = 16711935 & ((e9 = 32767 * (e9 - t4) * r6) | e9 << 8)) | e9 << 4)) | e9 << 2)) | e9 << 1)) | (n11 = 1431655765 & ((n11 = 858993459 & ((n11 = 252645135 & ((n11 = 16711935 & ((n11 = 32767 * (n11 - x5) * r6) | n11 << 8)) | n11 << 4)) | n11 << 2)) | n11 << 1)) << 1;
}
function m(e9, n11) {
  return e9.x === n11.x && e9.y === n11.y;
}
function M(e9, n11) {
  return e9.x - n11.x;
}
function b(e9, n11, t4, x5) {
  let r6 = e9;
  do {
    const i14 = r6.prev, u6 = r6.next.next;
    !m(i14, u6) && h(i14, r6, r6.next, u6) && w3(i14, u6) && w3(u6, i14) && (n11.push(i14.index / t4 + x5), n11.push(r6.index / t4 + x5), n11.push(u6.index / t4 + x5), o3(r6), o3(r6.next), r6 = e9 = u6), r6 = r6.next;
  } while (r6 !== e9);
  return r6;
}
function g2(e9, n11, r6, i14, u6, o9, l8) {
  let f6 = e9;
  do {
    let e10 = f6.next.next;
    for (; e10 !== f6.prev; ) {
      if (f6.index !== e10.index && k(f6, e10)) {
        let y3 = A3(f6, e10);
        return f6 = t2(f6, f6.next), y3 = t2(y3, y3.next), x(f6, n11, r6, i14, u6, o9, l8, 0), void x(y3, n11, r6, i14, u6, o9, l8, 0);
      }
      e10 = e10.next;
    }
    f6 = f6.next;
  } while (f6 !== e9);
}
function k(e9, n11) {
  return e9.next.index !== n11.index && e9.prev.index !== n11.index && !d(e9, n11) && w3(e9, n11) && w3(n11, e9) && j(e9, n11);
}
function j(e9, n11) {
  let t4 = e9, x5 = false;
  const r6 = (e9.x + n11.x) / 2, i14 = (e9.y + n11.y) / 2;
  do {
    t4.y > i14 != t4.next.y > i14 && t4.next.y !== t4.y && r6 < (t4.next.x - t4.x) * (i14 - t4.y) / (t4.next.y - t4.y) + t4.x && (x5 = !x5), t4 = t4.next;
  } while (t4 !== e9);
  return x5;
}
function A3(e9, n11) {
  const t4 = q2.create(e9.index, e9.x, e9.y), x5 = q2.create(n11.index, n11.x, n11.y), r6 = e9.next, i14 = n11.prev;
  return e9.next = n11, n11.prev = e9, t4.next = r6, r6.prev = t4, x5.next = t4, t4.prev = x5, i14.next = x5, x5.prev = i14, x5;
}
var q2 = class _q {
  constructor() {
    this.index = 0, this.x = 0, this.y = 0, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  static create(e9, n11, t4) {
    const x5 = D2 < B2.length ? B2[D2++] : new _q();
    return x5.index = e9, x5.x = n11, x5.y = t4, x5.prev = null, x5.next = null, x5.z = null, x5.prevZ = null, x5.nextZ = null, x5.steiner = false, x5;
  }
};
var B2 = [];
var C3 = 8096;
var D2 = 0;
for (let E4 = 0; E4 < C3; E4++) B2.push(new q2());

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/templateUtils.js
var i7 = 1e-5;
var f2 = new e2(0, 0, 0, 1, 0);
var c3 = new e2(0, 0, 0, 1, 0);
function u3(t4, e9, n11) {
  let o9 = 0;
  for (let r6 = 1; r6 < n11; r6++) {
    const n12 = t4[2 * (e9 + r6 - 1)], s13 = t4[2 * (e9 + r6 - 1) + 1];
    o9 += (t4[2 * (e9 + r6)] - n12) * (t4[2 * (e9 + r6) + 1] + s13);
  }
  return o9;
}
function h2(t4, e9, n11, o9, r6) {
  let s13 = 0;
  const l8 = 2;
  for (let i14 = n11; i14 < o9; i14 += 3) {
    const n12 = (t4[i14] - r6) * l8, o10 = (t4[i14 + 1] - r6) * l8, f6 = (t4[i14 + 2] - r6) * l8;
    s13 += Math.abs((e9[n12] - e9[f6]) * (e9[o10 + 1] - e9[n12 + 1]) - (e9[n12] - e9[o10]) * (e9[f6 + 1] - e9[n12 + 1]));
  }
  return s13;
}
function a7(t4, e9) {
  const { coords: n11, lengths: o9 } = e9, r6 = 0, s13 = t4;
  let f6 = 0;
  for (let c8 = 0; c8 < o9.length; ) {
    let t5 = c8, e10 = o9[c8], a10 = u3(n11, f6, e10);
    const g5 = [];
    for (; ++t5 < o9.length; ) {
      const r7 = o9[t5], s14 = u3(n11, f6 + e10, r7);
      if (!(s14 > 0)) break;
      a10 += s14, g5.push(f6 + e10), e10 += r7;
    }
    const p6 = s13.length;
    e4(s13, n11, f6, f6 + e10, g5, 2, r6);
    const m6 = h2(s13, n11, p6, s13.length, r6), x5 = Math.abs(a10);
    if (Math.abs((m6 - x5) / Math.max(1e-7, x5)) > i7) return s13.length = 0, false;
    c8 = t5, f6 += e10;
  }
  return true;
}
function p2(t4) {
  const { coords: n11, lengths: o9 } = t4, { buffer: r6 } = a5(n11, o9);
  return r6;
}
function m2(t4, e9, n11) {
  let o9 = 0;
  for (let r6 = 0; r6 < t4.lengths.length; r6++) {
    const s13 = t4.lengths[r6];
    for (let r7 = 0; r7 < s13; r7++) {
      const s14 = t4.coords[2 * (r7 + o9)], l8 = t4.coords[2 * (r7 + o9) + 1];
      if (s14 < e9 || s14 > n11 || l8 < e9 || l8 > n11) return true;
    }
    o9 += s13;
  }
  return false;
}
function x2(t4, e9) {
  if (null == t4) return null;
  if (!m2(t4, -128, a + 128)) return t4;
  f2.setPixelMargin(e9), f2.reset(i2.Polygon);
  let n11 = 0;
  for (let o9 = 0; o9 < t4.lengths.length; o9++) {
    const e10 = t4.lengths[o9];
    let r6 = t4.coords[2 * (0 + n11)], s13 = t4.coords[2 * (0 + n11) + 1];
    f2.moveTo(r6, s13);
    for (let o10 = 1; o10 < e10; o10++) r6 = t4.coords[2 * (o10 + n11)], s13 = t4.coords[2 * (o10 + n11) + 1], f2.lineTo(r6, s13);
    f2.close(), n11 += e10;
  }
  const l8 = f2.result(false);
  if (!l8) return null;
  const i14 = [], c8 = [];
  for (const o9 of l8) {
    let t5 = 0;
    for (const e10 of o9) c8.push(e10.x), c8.push(e10.y), t5++;
    i14.push(t5);
  }
  return new s2(i14, c8);
}
function d2(t4, e9) {
  c3.setPixelMargin(e9);
  const n11 = c3, r6 = -e9, l8 = a + e9;
  let i14 = [], f6 = false;
  if (!t4.nextPath()) return null;
  let u6 = true;
  for (; u6; ) {
    t4.seekPathStart();
    const e10 = [];
    if (!t4.pathSize) return null;
    n11.reset(i2.LineString), t4.nextPoint();
    let s13 = t4.x, c8 = t4.y;
    if (f6) n11.moveTo(s13, c8);
    else {
      if (s13 < r6 || s13 > l8 || c8 < r6 || c8 > l8) {
        f6 = true;
        continue;
      }
      e10.push({ x: s13, y: c8 });
    }
    let h7 = false;
    for (; t4.nextPoint(); ) if (s13 = t4.x, c8 = t4.y, f6) n11.lineTo(s13, c8);
    else {
      if (s13 < r6 || s13 > l8 || c8 < r6 || c8 > l8) {
        h7 = true;
        break;
      }
      e10.push({ x: s13, y: c8 });
    }
    if (h7) f6 = true;
    else {
      if (f6) {
        const t5 = n11.resultWithStarts();
        if (t5) for (const e11 of t5) i14.push(e11);
      } else i14.push({ line: e10, start: 0 });
      u6 = t4.nextPath(), f6 = false;
    }
  }
  return i14 = i14.filter((t5) => t5.line.length > 1), 0 === i14.length ? null : i14;
}
f2.setExtent(a), c3.setExtent(a);

// node_modules/@arcgis/core/symbols/cim/effects/CIMEffectHelper.js
var n5 = 96 / 72;
var l4 = class {
  static executeEffects(t4, e9, l8, c8) {
    const f6 = n5, m6 = Q(t4);
    let p6 = new s3(e9);
    for (const o9 of t4) {
      const t5 = A2(o9);
      t5 && (p6 = t5.execute(p6, o9, f6, l8, c8, m6));
    }
    return p6;
  }
  static applyEffects(n11, l8, c8) {
    if (!n11) return l8;
    const f6 = Q(n11);
    let m6, p6 = new s3(a2.fromJSONCIM(l8));
    for (const t4 of n11) {
      const e9 = A2(t4);
      e9 && (p6 = e9.execute(p6, t4, 1, null, c8, f6));
    }
    const u6 = [];
    let i14 = null;
    for (; m6 = p6.next(); ) u6.push(...t(m6)), i14 = m6.geometryType;
    return 0 === u6.length || null === i14 ? null : "esriGeometryPolygon" === i14 ? { rings: u6 } : { paths: u6 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/loadGeometryEngine.js
var n6 = null;
function t3() {
  return n6;
}
async function e6() {
  n6 = await import("./geometryEngineJSON-T2WTIVKL.js");
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/AlignedVertexSpec.js
function e7(t4) {
  switch (t4) {
    case C.BYTE:
    case C.UNSIGNED_BYTE:
      return 1;
    case C.SHORT:
    case C.UNSIGNED_SHORT:
    case C.HALF_FLOAT:
      return 2;
    case C.FLOAT:
    case C.INT:
    case C.UNSIGNED_INT:
      return 4;
  }
}
function o4(t4) {
  const s13 = [], o9 = [], n11 = [];
  for (const i14 of t4) {
    const t5 = e7(i14.type) * i14.count;
    switch (t5 % 2 || t5 % 4 || 4) {
      case 4:
        s13.push(i14);
        continue;
      case 2:
        o9.push(i14);
        continue;
      case 1:
        n11.push(i14);
        continue;
      default:
        throw new Error("Found unexpected dataType byte count");
    }
  }
  return s13.push(...o9), s13.push(...n11), s13;
}
var n7 = class _n {
  static fromVertexSpec(t4, s13) {
    const { attributes: i14, optionalAttributes: a10 } = t4;
    let r6, c8, u6;
    const p6 = [];
    for (const e9 in i14) {
      const t5 = i14[e9];
      "position" === t5.pack ? r6 = { ...t5, name: e9, offset: 0 } : "id" === t5.pack ? c8 = { ...t5, name: e9, offset: 4 } : "bitset" === e9 ? u6 = { ...t5, name: e9, offset: 7 } : p6.push({ ...t5, name: e9 });
    }
    for (const e9 in a10) if (true === s13[e9]) {
      const t5 = a10[e9];
      p6.push({ ...t5, name: e9 });
    }
    const h7 = o4(p6), f6 = [];
    let m6 = 8, b4 = 1;
    for (const o9 of h7) f6.push({ ...o9, offset: m6 }), m6 += e7(o9.type) * o9.count, o9.packAlternating && (b4 = Math.max(o9.packAlternating.count, b4));
    const d6 = Uint32Array.BYTES_PER_ELEMENT, _4 = m6 % d6;
    return new _n(r6, c8, u6, f6, m6 + (_4 ? d6 - _4 : 0), b4);
  }
  constructor(t4, s13, e9, o9, n11, i14) {
    this.position = t4, this.id = s13, this.bitset = e9, this.standardAttributes = o9, this.stride = n11, this.packVertexCount = i14, o9.push(e9), this._attributes = [t4, s13, e9, ...o9];
  }
  get attributeLayout() {
    if (!this._attributeLayout) {
      const s13 = r2(this._attributes), e9 = this._attributes.map((t4) => ({ name: t4.name, count: t4.count, offset: t4.offset, type: t4.type, packPrecisionFactor: t4.packPrecisionFactor, normalized: t4.normalized ?? false }));
      this._attributeLayout = { attributes: e9, hash: s13, stride: this.stride };
    }
    return this._attributeLayout;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriterVertexPack.js
var i8 = class _i {
  static fromVertexSpec(t4, s13) {
    const c8 = n7.fromVertexSpec(t4, s13);
    return new _i(c8);
  }
  constructor(t4) {
    this._spec = t4, this._packed = new Uint8Array(this._spec.stride * this._spec.packVertexCount), this._packedU32View = new Uint32Array(this._packed.buffer), this._dataView = new DataView(this._packed.buffer);
  }
  get attributeLayout() {
    return this._spec.attributeLayout;
  }
  get stride() {
    return this._spec.stride;
  }
  writeVertex(t4, e9, s13, i14, c8, a10) {
    var _a;
    for (let p6 = 0; p6 < this._spec.packVertexCount; p6++) {
      const t5 = p6 * this._spec.stride;
      this._packPosition(s13, i14, t5), this._packId(e9, t5);
      const r6 = this._spec.bitset;
      if (a10) {
        if (r6.packTessellation) {
          const e10 = r6.packTessellation(a10, c8);
          this._pack(e10, r6, t5);
        }
        for (const e10 of this._spec.standardAttributes) if (null != e10.packTessellation) {
          const s14 = e10.packTessellation(a10, c8);
          this._pack(s14, e10, t5);
        } else if ((_a = e10.packAlternating) == null ? void 0 : _a.packTessellation) {
          const t6 = e10.packAlternating.packTessellation(a10, c8);
          for (let s14 = 0; s14 < this._spec.packVertexCount; s14++) {
            const i15 = t6[s14];
            this._pack(i15, e10, s14 * this._spec.stride);
          }
        }
      }
    }
    t4.vertexWriteRegion(this._packedU32View);
  }
  pack(t4, e9) {
    var _a;
    for (const s13 of this._spec.standardAttributes) if (s13.pack && "string" != typeof s13.pack) {
      const i14 = s13.pack(t4, e9);
      for (let t5 = 0; t5 < this._spec.packVertexCount; t5++) this._pack(i14, s13, t5 * this._spec.stride);
    } else if ((_a = s13.packAlternating) == null ? void 0 : _a.pack) {
      const i14 = s13.packAlternating.pack(t4, e9);
      for (let t5 = 0; t5 < this._spec.packVertexCount; t5++) {
        const e10 = i14[t5];
        this._pack(e10, s13, t5 * this._spec.stride);
      }
    }
  }
  _packPosition(e9, s13, i14) {
    const { offset: c8 } = this._spec.position, a10 = this._spec.position.packPrecisionFactor ?? 1, p6 = s6(e9 * a10, s13 * a10);
    this._dataView.setUint32(i14 + c8, p6, true);
  }
  _packId(t4, e9) {
    const s13 = t4 * (this._spec.id.packPrecisionFactor ?? 1), i14 = 4278190080 & this._dataView.getUint32(e9 + this._spec.id.offset, true);
    this._dataView.setUint32(e9 + this._spec.id.offset, s13 | i14, true);
  }
  _pack(t4, e9, i14) {
    o2(this._dataView, t4, e9, i14);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/MeshWriter.js
function i9(e9) {
  if (!e9) return false;
  for (const t4 of e9) switch (t4.effect.type) {
    case "CIMGeometricEffectBuffer":
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectDonut":
      return true;
  }
  return false;
}
var c4 = class {
  constructor(e9, t4, r6, s13) {
    this._instanceId = e9, this._evaluator = t4, this._enabledOptionalAttributes = r6, this._viewParams = s13, this._evaluator.evaluator = (e10) => this.vertexSpec.createComputedParams(e10);
  }
  get _vertexPack() {
    if (!this._cachedVertexPack) {
      const e9 = i8.fromVertexSpec(this.vertexSpec, this._enabledOptionalAttributes);
      this._evaluator.hasDynamicProperties || e9.pack(this._evaluator.evaluatedMeshParams, this._viewParams), this._cachedVertexPack = e9;
    }
    return this._cachedVertexPack;
  }
  get evaluatedMeshParams() {
    return this._evaluator.evaluatedMeshParams;
  }
  get hasEffects() {
    return !!this.evaluatedMeshParams.effects;
  }
  get instanceId() {
    return this._instanceId;
  }
  get attributeLayout() {
    return this._vertexPack.attributeLayout;
  }
  setReferences(e9) {
    this._references = e9;
  }
  getBoundsInfo() {
    return null;
  }
  getTileInfo() {
    return this._viewParams.tileInfo;
  }
  async loadDependencies() {
    var _a;
    i9((_a = this._evaluator.inputMeshParams.effects) == null ? void 0 : _a.effectInfos) && await e6();
  }
  enqueueRequest(e9, t4, r6) {
    this._evaluator.hasDynamicProperties && this._evaluator.enqueueRequest(e9, t4, r6);
  }
  write(r6, a10, i14, c8, o9) {
    var _a;
    this.ensurePacked(a10, i14, c8);
    const n11 = this.evaluatedMeshParams.effects;
    if (!n11 || 0 === n11.length) return void this._write(r6, i14, void 0, o9);
    const u6 = (_a = i14.readGeometryForDisplay()) == null ? void 0 : _a.clone();
    if (!u6) return;
    const h7 = a2.fromOptimizedCIM(u6, i14.geometryType), f6 = t3();
    h7.invertY();
    const m6 = r6.id || "", l8 = l4.executeEffects(n11, h7, m6, f6);
    let v3;
    for (; v3 = l8.next(); ) v3.invertY(), this._write(r6, i14, v3, o9);
  }
  ensurePacked(e9, t4, r6) {
    if (!this._evaluator.hasDynamicProperties) return;
    const s13 = this._evaluator.evaluateMeshParams(e9, t4, r6);
    this._vertexPack.pack(s13, this._viewParams);
  }
  _writeVertex(e9, t4, r6, s13, a10) {
    const i14 = this.evaluatedMeshParams;
    this._vertexPack.writeVertex(e9, t4, r6, s13, i14, a10);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/AFillMeshWriter.js
var o5 = 100;
var n8 = has("featurelayer-fast-triangulation-enabled");
var a8 = class extends c4 {
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), i5()]);
  }
  _write(e9, t4, r6) {
    const s13 = (r6 == null ? void 0 : r6.asOptimized()) ?? t4.readGeometryForDisplay(), i14 = this._clip(s13);
    i14 && (e9.recordStart(this.instanceId, this.attributeLayout), this._writeGeometry(e9, t4, i14), e9.recordEnd());
  }
  _clip(e9) {
    if (!e9) return null;
    const r6 = this.hasEffects;
    return x2(e9, r6 ? 256 : 8);
  }
  _writeGeometry(e9, t4, i14) {
    const a10 = i14.maxLength > o5, c8 = [], l8 = this.createTesselationParams(t4);
    if (!a10 && n8 && a7(c8, i14)) return void (c8.length && this._writeVertices(e9, t4, i14.coords, l8, c8));
    const d6 = p2(i14);
    this._writeVertices(e9, t4, d6, l8);
  }
  _writeVertices(e9, t4, r6, s13, i14) {
    const o9 = t4.getDisplayId(), n11 = e9.vertexCount(), a10 = this.hasEffects;
    let c8 = 0;
    if (i14) for (const l8 of i14) {
      const t5 = r6[2 * l8], i15 = r6[2 * l8 + 1];
      a10 && e9.recordBounds(t5, i15, 0, 0), this._writeVertex(e9, o9, t5, i15, s13), c8++;
    }
    else for (let l8 = 0; l8 < r6.length; l8 += 2) {
      const t5 = Math.round(r6[l8]), i15 = Math.round(r6[l8 + 1]);
      a10 && e9.recordBounds(t5, i15, 0, 0), this._writeVertex(e9, o9, t5, i15, s13), c8++;
    }
    e9.indexEnsureSize(c8);
    for (let l8 = 0; l8 < c8; l8++) e9.indexWrite(l8 + n11);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityMeshWriter.js
var r4 = { createComputedParams: (e9) => e9, optionalAttributes: {}, attributes: { id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1 }, pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, inverseArea: { type: C.FLOAT, count: 1, packTessellation: ({ inverseArea: e9 }) => e9 } } };
var s8 = class extends a8 {
  constructor() {
    super(...arguments), this.vertexSpec = r4;
  }
  createTesselationParams(e9) {
    return { inverseArea: 1 / e9.readGeometryArea() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/meshWriterUtils.js
var i10 = () => n.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils");
var u4 = 0;
var a9 = 100;
function m3(r6, e9) {
  return [!!(r6 == null ? void 0 : r6.minScale) && e9.scaleToZoom(r6.minScale) || u4, !!(r6 == null ? void 0 : r6.maxScale) && e9.scaleToZoom(r6.maxScale) || a9];
}
function f3(r6) {
  return 1 << r6;
}
function l5(r6) {
  let e9 = 0;
  for (const [t4, n11] of r6) n11 && (e9 |= 1 << t4);
  return e9;
}
function g3(t4) {
  let n11;
  if (!t4) return [0, 0, 0, 0];
  if ("string" == typeof t4) {
    const o10 = l.fromString(t4);
    if (!o10) return i10().errorOnce(new s("mapview:mesh-processing", "Unable to parse string into color", { color: t4 })), [0, 0, 0, 0];
    n11 = o10.toArray();
  } else n11 = t4;
  const [o9, s13, c8, u6] = n11;
  return [o9 * (u6 / 255), s13 * (u6 / 255), c8 * (u6 / 255), u6];
}
function h3(r6) {
  switch (r6) {
    case "butt":
    case U.Butt:
      return e.BUTT;
    case "round":
    case U.Round:
      return e.ROUND;
    case "square":
    case U.Square:
      return e.SQUARE;
  }
}
function p3(r6) {
  switch (r6) {
    case "bevel":
    case w.Bevel:
      return n2.BEVEL;
    case "miter":
    case w.Miter:
      return n2.MITER;
    case "round":
    case w.Round:
      return n2.ROUND;
  }
}
function d3(r6, e9) {
  return Math.round(Math.min(Math.sqrt(r6 * e9), 255));
}
function S3(r6, e9) {
  return Math.round(r6 * e9) / e9;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/FillMeshWriter.js
var i11 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: C.SHORT, count: 2, packPrecisionFactor: mi, pack: ({ scaleInfo: t4 }, { tileInfo: o9 }) => m3(t4, o9) } }, attributes: { id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1 }, pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: t4 }) => g3(t4) } } };
var c5 = class extends a8 {
  constructor() {
    super(...arguments), this.vertexSpec = i11;
  }
  createTesselationParams(t4) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternFillMeshWriter.js
var s9 = { createComputedParams: (t4) => t4, optionalAttributes: i11.optionalAttributes, attributes: { ...i11.attributes, tlbr: { count: 4, type: C.UNSIGNED_SHORT, pack: ({ sprite: e9 }) => {
  const { rect: r6, width: i14, height: s13 } = e9, o9 = r6.x + ti, a10 = r6.y + ti;
  return [o9, a10, o9 + i14, a10 + s13];
} }, inverseRasterizationScale: { count: 1, type: C.BYTE, packPrecisionFactor: 16, pack: ({ sprite: t4 }) => 1 / t4.rasterizationScale } } };
var o6 = class extends c5 {
  constructor() {
    super(...arguments), this.vertexSpec = s9;
  }
  _write(t4, e9, r6) {
    var _a;
    const i14 = (r6 == null ? void 0 : r6.asOptimized()) ?? e9.readGeometryForDisplay(), s13 = this._clip(i14);
    if (!s13) return;
    const o9 = (_a = this.evaluatedMeshParams.sprite) == null ? void 0 : _a.textureBinding;
    t4.recordStart(this.instanceId, this.attributeLayout, o9), this._writeGeometry(t4, e9, s13), t4.recordEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexFillMeshWriter.js
function p4(e9) {
  const { sprite: o9, aspectRatio: s13, scaleProportionally: r6 } = e9, i14 = u(e9.height), c8 = i14 > 0 ? i14 : o9.height;
  let a10 = i14 * s13;
  return a10 <= 0 ? a10 = o9.width : r6 && (a10 *= o9.width / o9.height), { width: a10, height: c8 };
}
function n9(t4) {
  const { applyRandomOffset: e9, sampleAlphaOnly: s13 } = t4;
  return l5([[C2, e9], [q, s13]]);
}
var l6 = { createComputedParams: (t4) => t4, optionalAttributes: s9.optionalAttributes, attributes: { ...s9.attributes, bitset: { count: 1, type: C.UNSIGNED_BYTE, pack: n9 }, width: { count: 1, type: C.HALF_FLOAT, pack: (t4) => p4(t4).width }, height: { count: 1, type: C.HALF_FLOAT, pack: (t4) => p4(t4).height }, offset: { count: 2, type: C.HALF_FLOAT, pack: ({ offsetX: e9, offsetY: o9 }) => [u(e9), -u(o9)] }, scale: { count: 2, type: C.UNSIGNED_BYTE, packPrecisionFactor: 16, pack: ({ scaleX: t4, scaleY: e9 }) => [t4, e9] }, angle: { count: 1, type: C.UNSIGNED_BYTE, pack: ({ angle: t4 }) => l2(t4) } } };
var h4 = class extends o6 {
  constructor() {
    super(...arguments), this.vertexSpec = l6;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/LineMeshWriter.js
var d4 = class {
  constructor() {
    this.extrusionOffsetX = 0, this.extrusionOffsetY = 0, this.normalX = 0, this.normalY = 0, this.directionX = 0, this.directionY = 0, this.distance = 0;
  }
};
var f4 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: C.SHORT, count: 2, packPrecisionFactor: mi, pack: ({ scaleInfo: t4 }, { tileInfo: e9 }) => m3(t4, e9) } }, attributes: { id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, bitset: { type: C.UNSIGNED_BYTE, count: 1 }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: t4 }) => g3(t4) }, offset: { type: C.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ extrusionOffsetX: t4, extrusionOffsetY: e9 }) => [S3(t4, 16), S3(e9, 16)] }, normal: { type: C.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ normalX: t4, normalY: e9 }) => [S3(t4, 16), S3(e9, 16)] }, halfWidth: { type: C.HALF_FLOAT, count: 1, pack: ({ width: e9 }) => u(0.5 * e9) }, referenceHalfWidth: { type: C.HALF_FLOAT, count: 1, pack: ({ referenceWidth: e9 }) => u(0.5 * e9) } } };
var _ = class {
  constructor() {
    this.id = 0, this.bitset = 0, this.indexCount = 0, this.vertexCount = 0, this.vertexFrom = 0, this.vertexBounds = 0;
  }
};
var x3 = 65535;
var T = class extends c4 {
  constructor(t4, e9, s13, i14) {
    super(t4, e9, s13, i14), this.vertexSpec = f4, this._currentWrite = new _(), this._tessellationOptions = { halfWidth: 0, pixelCoordRatio: 1, offset: 0, wrapDistance: x3, textured: false }, this._tessParams = new d4(), this._initializeTessellator();
  }
  writeLineVertices(t4, e9, s13) {
    const i14 = this._getLines(e9);
    null != i14 && this._writeVertices(t4, s13, i14);
  }
  _initializeTessellator() {
    this._lineTessellator = new c(this._writeTesselatedVertex.bind(this), this._writeTriangle.bind(this), true);
  }
  _write(t4, s13, i14) {
    const r6 = i14 ?? a2.fromFeatureSetReaderCIM(s13);
    r6 && this._writeGeometry(t4, s13, r6);
  }
  _writeGeometry(t4, e9, s13, i14) {
    t4.recordStart(this.instanceId, this.attributeLayout, i14), this.writeLineVertices(t4, s13, e9), t4.recordEnd();
  }
  _getLines(t4) {
    return d2(t4, a4(this.evaluatedMeshParams));
  }
  _writeVertices(e9, s13, r6) {
    const { _currentWrite: o9, _tessellationOptions: n11, evaluatedMeshParams: a10 } = this, { width: c8, capType: m6, joinType: u6, miterLimit: p6, hasSizeVV: d6 } = a10, f6 = u(0.5 * c8);
    n11.halfWidth = f6, n11.capType = h3(m6), n11.joinType = p3(u6), n11.miterLimit = p6;
    const _4 = !d6;
    o9.out = e9, o9.id = s13.getDisplayId(), o9.vertexCount = 0, o9.indexCount = 0, o9.vertexFrom = e9.vertexCount(), o9.vertexBounds = _4 && f6 < R ? 0 : 1;
    for (const { line: t4, start: i14 } of r6) n11.initialDistance = i14 % x3, this._lineTessellator.tessellate(t4, n11, _4);
  }
  _writeTesselatedVertex(t4, e9, s13, i14, r6, o9, n11, a10, c8, h7, l8) {
    const { out: m6, id: u6, vertexBounds: p6 } = this._currentWrite;
    return this.hasEffects && m6.recordBounds(t4, e9, p6, p6), this._tessParams.extrusionOffsetX = n11, this._tessParams.extrusionOffsetY = a10, this._tessParams.normalX = c8, this._tessParams.normalY = h7, this._tessParams.directionX = r6, this._tessParams.directionY = o9, this._tessParams.distance = l8, this._writeVertex(m6, u6, t4, e9, this._tessParams), this._currentWrite.vertexFrom + this._currentWrite.vertexCount++;
  }
  _writeTriangle(t4, e9, s13) {
    const { out: i14 } = this._currentWrite;
    i14.indexEnsureSize(3), i14.indexWrite(t4), i14.indexWrite(e9), i14.indexWrite(s13), this._currentWrite.indexCount += 3;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/OutlineFillMeshWriter.js
var p5 = { createComputedParams: (e9) => e9, optionalAttributes: f4.optionalAttributes, attributes: { ...f4.attributes, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: (e9) => 0 }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: e9 }) => g3(e9) } } };
var c6 = { createComputedParams: (e9) => e9, optionalAttributes: f4.optionalAttributes, attributes: { ...f4.attributes, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: (e9) => l5([[B, true]]) }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: e9 }) => g3(e9) } } };
var m4 = class extends T {
  constructor() {
    super(...arguments), this.vertexSpec = c6;
  }
};
var h5 = class extends c5 {
  constructor(e9, t4, r6, s13) {
    super(e9, t4, r6, s13), this.vertexSpec = p5, this._lineMeshWriter = this._createOutlineWriter(e9, t4, r6, s13);
  }
  _createOutlineWriter(e9, t4, r6, s13) {
    return new m4(e9, t4, r6, s13);
  }
  _write(t4, r6, s13) {
    const i14 = (s13 == null ? void 0 : s13.asOptimized()) ?? r6.readGeometryForDisplay(), o9 = this._clip(i14);
    o9 && (t4.recordStart(this.instanceId, this.attributeLayout), this._writeGeometry(t4, r6, o9), this._lineMeshWriter.writeLineVertices(t4, a2.fromOptimizedCIM(o9, "esriGeometryPolyline"), r6), t4.recordEnd());
  }
  _clip(e9) {
    return e9 ? x2(e9, a4(this.evaluatedMeshParams)) : null;
  }
  ensurePacked(e9, t4, r6) {
    super.ensurePacked(e9, t4, r6), this._lineMeshWriter.ensurePacked(e9, t4, r6);
  }
  enqueueRequest(e9, t4, r6) {
    super.enqueueRequest(e9, t4, r6), this._lineMeshWriter.enqueueRequest(e9, t4, r6);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexOutlineFillMeshWriter.js
var d5 = l6;
var h6 = c6;
var f5 = { createComputedParams: (e9) => e9, optionalAttributes: d5.optionalAttributes, attributes: { ...d5.attributes, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: (e9) => n9(e9) }, aux1: { count: 1, type: C.HALF_FLOAT, pack: (e9) => p4(e9).width }, aux2: { count: 1, type: C.HALF_FLOAT, pack: (e9) => p4(e9).height }, aux3: { count: 2, type: C.HALF_FLOAT, pack: ({ offsetX: t4, offsetY: r6 }) => [u(t4), u(r6)] }, aux4: { count: 2, type: C.UNSIGNED_BYTE, pack: ({ scaleX: e9, scaleY: t4 }) => [e9 * S2, t4 * S2] } } };
var y2 = { createComputedParams: (e9) => e9, optionalAttributes: d5.optionalAttributes, attributes: { ...d5.attributes, color: h6.attributes.color, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: (e9) => l5([[B, true]]) }, aux1: { count: 1, type: C.HALF_FLOAT, pack: (t4) => u(0.5 * t4.width) }, aux2: { count: 1, type: C.HALF_FLOAT, pack: (t4) => u(0.5 * t4.referenceWidth) }, aux3: { count: 2, type: C.HALF_FLOAT, packTessellation: ({ extrusionOffsetX: e9, extrusionOffsetY: t4 }) => [e9, t4] }, aux4: { count: 2, type: C.UNSIGNED_BYTE, packTessellation: ({ normalX: e9, normalY: t4 }) => [e9 * S2 + w2, t4 * S2 + w2] } } };
var x4 = class extends m4 {
  constructor() {
    super(...arguments), this.vertexSpec = y2;
  }
};
var _2 = class extends h5 {
  constructor() {
    super(...arguments), this.vertexSpec = f5;
  }
  _createOutlineWriter(e9, t4, r6, s13) {
    return new x4(e9, t4, r6, s13);
  }
  _write(e9, r6, s13) {
    var _a;
    const i14 = (s13 == null ? void 0 : s13.asOptimized()) ?? r6.readGeometryForDisplay(), o9 = this._clip(i14);
    if (!o9) return;
    const a10 = (_a = this.evaluatedMeshParams.sprite) == null ? void 0 : _a.textureBinding;
    e9.recordStart(this.instanceId, this.attributeLayout, a10), this._writeGeometry(e9, r6, o9), this._lineMeshWriter.writeLineVertices(e9, a2.fromOptimizedCIM(o9, "esriGeometryPolyline"), r6), e9.recordEnd();
  }
  ensurePacked(e9, t4, r6) {
    super.ensurePacked(e9, t4, r6), this._lineMeshWriter.ensurePacked(e9, t4, r6);
  }
  enqueueRequest(e9, t4, r6) {
    super.enqueueRequest(e9, t4, r6), this._lineMeshWriter.enqueueRequest(e9, t4, r6);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternOutlineFillMeshWriter.js
var n10 = { optionalAttributes: s9.optionalAttributes, createComputedParams: (e9) => e9, attributes: { ...s9.attributes, ...p5.attributes } };
var o7 = { optionalAttributes: s9.optionalAttributes, createComputedParams: (e9) => e9, attributes: { ...s9.attributes, ...c6.attributes } };
var u5 = class extends m4 {
  constructor() {
    super(...arguments), this.vertexSpec = o7;
  }
};
var c7 = class extends h5 {
  constructor() {
    super(...arguments), this.vertexSpec = n10;
  }
  _createOutlineWriter(e9, t4, r6, s13) {
    return new u5(e9, t4, r6, s13);
  }
  _write(t4, r6, s13) {
    var _a;
    const i14 = (s13 == null ? void 0 : s13.asOptimized()) ?? r6.readGeometryForDisplay(), a10 = this._clip(i14);
    if (!a10) return;
    const n11 = (_a = this.evaluatedMeshParams.sprite) == null ? void 0 : _a.textureBinding;
    t4.recordStart(this.instanceId, this.attributeLayout, n11), this._writeGeometry(t4, r6, a10), this._lineMeshWriter.writeLineVertices(t4, a2.fromOptimizedCIM(a10, "esriGeometryPolyline"), r6), t4.recordEnd();
  }
  ensurePacked(e9, t4, r6) {
    super.ensurePacked(e9, t4, r6), this._lineMeshWriter.ensurePacked(e9, t4, r6);
  }
  enqueueRequest(e9, t4, r6) {
    super.enqueueRequest(e9, t4, r6), this._lineMeshWriter.enqueueRequest(e9, t4, r6);
  }
  async loadDependencies() {
    await Promise.all([super.loadDependencies(), this._lineMeshWriter.loadDependencies()]);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapMeshWriter.js
var r5 = { createComputedParams: (t4) => t4, optionalAttributes: {}, attributes: { pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1 }, offset: { type: C.BYTE, count: 2, packAlternating: { count: 4, pack: () => [[-1, -1], [1, -1], [-1, 1], [1, 1]] } } } };
var i12 = class extends c4 {
  constructor() {
    super(...arguments), this.vertexSpec = r5;
  }
  _write(t4, e9) {
    t4.recordStart(this.instanceId, this.attributeLayout);
    const r6 = e9.getDisplayId();
    if ("esriGeometryPoint" === e9.geometryType) {
      const i14 = e9.readXForDisplay(), o9 = e9.readYForDisplay();
      this._writeQuad(t4, r6, i14, o9);
    } else if ("esriGeometryMultipoint" === e9.geometryType) {
      const i14 = e9.readGeometryForDisplay();
      i14 == null ? void 0 : i14.forEachVertex((e10, i15) => {
        e10 >= 0 && e10 <= 512 && i15 >= 0 && i15 <= 512 && this._writeQuad(t4, r6, e10, i15);
      });
    }
    t4.recordEnd();
  }
  _writeQuad(t4, e9, r6, i14) {
    const o9 = t4.vertexCount();
    this._writeVertex(t4, e9, r6, i14), t4.indexWrite(o9 + 0), t4.indexWrite(o9 + 1), t4.indexWrite(o9 + 2), t4.indexWrite(o9 + 1), t4.indexWrite(o9 + 3), t4.indexWrite(o9 + 2);
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/CIMMarkerPlacementHelper.js
var e8 = class {
  static getPlacement(e9, r6, n11, s13, c8, o9) {
    const a10 = g(n11);
    if (!a10) return null;
    -1 === r6 && e9.invertY();
    return a10.execute(e9, n11, s13, c8, o9);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextParams.js
var s10 = 96;
var i13 = class {
  constructor(i14) {
    const { offsetX: o9, offsetY: e9, postAngle: f6, fontSize: h7, haloSize: n11, outlineSize: l8, scaleFactor: z3, transforms: a10 } = i14;
    if (this.offsetX = o9, this.offsetY = e9, this.postAngle = f6, this.fontSize = Math.min(h7, s10), this.haloSize = n11 ?? 0, this.outlineSize = l8 ?? 0, this.transforms = a10, a10 && a10.infos.length > 1) {
      const i15 = E(h7, f6, false, o9, e9, a10, false);
      this.fontSize = Math.min(i15.size, s10);
      const n12 = i15.size / h7;
      this.haloSize *= n12, this.outlineSize *= n12, this.postAngle = i15.rotation, this.offsetX = i15.offsetX, this.offsetY = i15.offsetY;
    }
    z3 && (this.fontSize *= z3, this.offsetX *= z3, this.offsetY *= z3);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextMeshWriter.js
var P = 28;
var T2 = [4, 4];
var b2 = [16, 4];
var k2 = { topLeft: b2, topRight: b2, bottomLeft: b2, bottomRight: b2 };
var z2 = [4, 2];
var B3 = [4, 6];
var M2 = { topLeft: z2, topRight: z2, bottomLeft: B3, bottomRight: B3 };
var R2 = { topLeft: z2, topRight: B3, bottomLeft: z2, bottomRight: B3 };
var w4 = { topLeft: B3, topRight: B3, bottomLeft: T2, bottomRight: T2 };
var L = { topLeft: T2, topRight: T2, bottomLeft: B3, bottomRight: B3 };
var I = { topLeft: B3, topRight: T2, bottomLeft: B3, bottomRight: T2 };
var E3 = { topLeft: T2, topRight: B3, bottomLeft: T2, bottomRight: B3 };
var G2 = { createComputedParams: (t4) => t4, optionalAttributes: { zoomRange: { type: C.UNSIGNED_SHORT, count: 2, packPrecisionFactor: mi, packTessellation: ({ minZoom: t4, maxZoom: e9 }) => [t4 || 0, e9 || P] }, clipAngle: { type: C.UNSIGNED_BYTE, count: 1, packTessellation: ({ clipAngle: t4 }) => A4(t4 || 0) }, referenceSymbol: { type: C.BYTE, count: 4, packPrecisionFactor: 1, packTessellation: (t4, o9) => {
  const r6 = t4.isLineLabel || !t4.referenceBounds, n11 = s5(r6 ? "center" : o9.horizontalAlignment), a10 = i4(r6 ? "middle" : o9.verticalAlignment), { offsetX: c8, offsetY: l8, size: h7 } = r6 ? { offsetX: 0, offsetY: 0, size: 0 } : t4.referenceBounds;
  return [u(c8), -u(l8), Math.round(u(h7)), n11 + 1 << 2 | a10 + 1];
} } }, attributes: { pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1, packTessellation: ({ isBackground: t4, mapAligned: e9 }) => l5([[F, t4], [H, !!e9]]) }, offset: { type: C.SHORT, count: 2, packPrecisionFactor: 8, packAlternating: { count: 4, packTessellation: ({ offsets: t4 }) => {
  const { bottomLeft: e9, bottomRight: o9, topLeft: r6, topRight: i14 } = t4;
  return [r6, i14, e9, o9];
} } }, textureUV: { type: C.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, packTessellation: ({ texcoords: t4 }) => {
  const { bottomLeft: e9, bottomRight: o9, topLeft: r6, topRight: i14 } = t4;
  return [r6, i14, e9, o9];
} } }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, packTessellation: ({ color: t4 }) => t4 }, fontSize: { type: C.UNSIGNED_SHORT, count: 1, packPrecisionFactor: 4, packTessellation: ({ fontSize: t4 }) => Math.round(u(t4)) }, referenceSize: { type: C.UNSIGNED_BYTE, count: 1, packPrecisionFactor: 4, packTessellation: ({ fontSize: t4 }, { referenceSize: o9 }) => Math.round(u(o9 ?? t4)) }, outlineColor: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: t4 }) => g3(t4) }, haloColor: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ haloColor: t4 }) => g3(t4) }, outlineAndHaloSize: { type: C.UNSIGNED_SHORT, count: 2, packPrecisionFactor: 4, packTessellation: ({ outlineSize: t4, haloSize: o9 }) => [Math.round(u(t4)), Math.round(u(o9))] } } };
var N = class extends c4 {
  constructor() {
    super(...arguments), this.vertexSpec = G2, this._textMeshParamsPropsInitialized = false;
  }
  ensurePacked(t4, e9, o9) {
    super.ensurePacked(t4, e9, o9), this._textMeshParamsPropsInitialized && !this._evaluator.hasDynamicProperties || (this._textMeshTransformProps = new i13(this.evaluatedMeshParams), this._textMeshParamsPropsInitialized = true);
  }
  _write(t4, e9, o9) {
    const r6 = this._getShaping();
    if (!r6) return;
    const i14 = e9.getDisplayId();
    if (null != this.evaluatedMeshParams.placement) return this._writePlacedTextMarkers(t4, e9, r6, o9);
    if (o9 == null ? void 0 : o9.nextPath()) return o9.nextPoint(), this._writeGlyphs(t4, i14, o9.x, o9.y, r6, 0);
    if ("esriGeometryPolygon" === e9.geometryType) {
      const o10 = e9.readCentroidForDisplay();
      if (!o10) return;
      const [s14, n12] = o10.coords;
      return this._writeGlyphs(t4, i14, s14, n12, r6, 0);
    }
    if ("esriGeometryMultipoint" === e9.geometryType) {
      const o10 = e9.readGeometryForDisplay();
      return void (o10 == null ? void 0 : o10.forEachVertex((e10, o11) => this._writeGlyphs(t4, i14, e10, o11, r6, 0)));
    }
    const s13 = e9.readXForDisplay(), n11 = e9.readYForDisplay();
    return this._writeGlyphs(t4, i14, s13, n11, r6, 0);
  }
  _writePlacedTextMarkers(t4, i14, s13, n11) {
    const a10 = n11 ?? a2.fromFeatureSetReaderCIM(i14);
    if (!a10) return;
    const c8 = -1, l8 = e8.getPlacement(a10, c8, this.evaluatedMeshParams.placement, u(1), t4.id, t3());
    if (!l8) return;
    const h7 = i14.getDisplayId();
    let f6 = l8.next();
    for (; null != f6; ) {
      const e9 = f6.tx, o9 = -f6.ty, r6 = -f6.getAngle();
      this._writeGlyphs(t4, h7, e9, o9, s13, r6), f6 = l8.next();
    }
  }
  _getShaping(o9) {
    var _a;
    const r6 = this._textMeshTransformProps, i14 = this.evaluatedMeshParams;
    if (!((_a = i14.glyphs) == null ? void 0 : _a.glyphs.length)) return null;
    const s13 = u(r6.fontSize), n11 = u(r6.offsetX), p6 = u(r6.offsetY), m6 = r(u(i14.lineWidth), yi, zi), d6 = G * r(i14.lineHeightRatio, 0.25, 4);
    return O(i14.glyphs, { scale: s13 / A, angle: r6.postAngle, xOffset: n11, yOffset: p6, horizontalAlignment: i14.horizontalAlignment, verticalAlignment: o9 || i14.verticalAlignment, maxLineWidth: m6, lineHeight: d6, decoration: i14.decoration, borderLineSizePx: u(i14.boxBorderLineSize), hasBackground: !!i14.boxBackgroundColor, useCIMAngleBehavior: i14.useCIMAngleBehavior });
  }
  _writeGlyphs(t4, o9, r6, i14, s13, n11, a10, c8) {
    const l8 = this.evaluatedMeshParams, h7 = this._textMeshTransformProps, f6 = u(h7.fontSize), p6 = h7.haloSize, u6 = h7.outlineSize, g5 = u(h7.offsetX), x5 = u(h7.offsetY), [y3, S5] = m3(l8.scaleInfo, this.getTileInfo());
    0 !== n11 && s13.setRotation(n11);
    const _4 = s13.bounds, P2 = r6 + _4.x + g5, T3 = i14 + _4.y - x5, b4 = 2 * (l8.minPixelBuffer ? l8.minPixelBuffer / f6 : 1), k4 = Math.max(_4.width, _4.height) * b4;
    s13.textBox && (t4.recordStart(this.instanceId, this.attributeLayout, s13.glyphs[0].textureBinding), t4.recordBounds(P2, T3, k4, k4), this._writeTextBox(t4, o9, r6, i14, s13.textBox, a10, c8), t4.recordEnd());
    for (const e9 of s13.glyphs) {
      t4.recordStart(this.instanceId, this.attributeLayout, e9.textureBinding), t4.recordBounds(P2, T3, k4, k4);
      const { texcoords: s14, offsets: n12 } = e9;
      this._writeQuad(t4, o9, r6, i14, { texcoords: s14, offsets: n12, fontSize: f6, haloSize: p6, outlineSize: u6, color: g3(l8.color), isBackground: false, referenceBounds: a10, minZoom: y3, maxZoom: S5, ...c8 }), t4.recordEnd();
    }
    0 !== n11 && s13.setRotation(-n11);
  }
  _writeTextBox(t4, e9, o9, r6, i14, s13, n11) {
    const a10 = this.evaluatedMeshParams, { fontSize: c8, haloSize: l8, outlineSize: h7 } = this._textMeshTransformProps, { boxBackgroundColor: f6, boxBorderLineColor: p6 } = a10, d6 = { isBackground: true, fontSize: c8, haloSize: l8, outlineSize: h7, referenceBounds: s13, ...n11 };
    f6 && (this._writeQuad(t4, e9, o9, r6, { texcoords: k2, offsets: i14.main, color: g3(f6), ...d6 }), p6 || (this._writeQuad(t4, e9, o9, r6, { texcoords: w4, offsets: i14.top, color: g3(f6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: L, offsets: i14.bot, color: g3(f6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: I, offsets: i14.left, color: g3(f6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: E3, offsets: i14.right, color: g3(f6), ...d6 }))), p6 && (this._writeQuad(t4, e9, o9, r6, { texcoords: M2, offsets: i14.top, color: g3(p6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: M2, offsets: i14.bot, color: g3(p6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: R2, offsets: i14.left, color: g3(p6), ...d6 }), this._writeQuad(t4, e9, o9, r6, { texcoords: R2, offsets: i14.right, color: g3(p6), ...d6 }));
  }
  _writeQuad(t4, e9, o9, r6, i14) {
    const s13 = t4.vertexCount();
    this._writeVertex(t4, e9, o9, r6, i14), t4.indexWrite(s13 + 0), t4.indexWrite(s13 + 1), t4.indexWrite(s13 + 2), t4.indexWrite(s13 + 1), t4.indexWrite(s13 + 3), t4.indexWrite(s13 + 2);
  }
};
var A4 = (t4) => Math.round(t4 * (254 / 360));

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/TexturedLineMeshWriter.js
var m5 = { createComputedParams: (t4) => t4, optionalAttributes: f4.optionalAttributes, attributes: { ...f4.attributes, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: ({ shouldSampleAlphaOnly: t4, shouldScaleDash: e9, isSDF: r6 }) => l5([[q, t4], [D, e9], [E2, r6]]) }, tlbr: { type: C.UNSIGNED_SHORT, count: 4, pack: ({ sprite: t4 }) => {
  const { rect: e9, width: r6, height: o9 } = t4, i14 = e9.x + ti, n11 = e9.y + ti;
  return [i14, n11, i14 + r6, n11 + o9];
} }, accumulatedDistance: { type: C.UNSIGNED_SHORT, count: 1, packTessellation: ({ distance: t4 }) => t4 }, segmentDirection: { type: C.BYTE, count: 2, packPrecisionFactor: 16, packTessellation: ({ directionX: t4, directionY: e9 }) => [t4, e9] }, offsetAlongLine: { type: C.HALF_FLOAT, count: 1, pack: ({ offsetAlongLine: e9 }) => u(e9) }, capType: { type: C.UNSIGNED_BYTE, count: 1, pack: ({ capType: t4 }) => {
  switch (t4) {
    case U.Butt:
    case "butt":
      return 0;
    case U.Square:
    case "square":
      return 1;
    case U.Round:
    case "round":
      return 2;
    default:
      return 0;
  }
} } } };
var l7 = class extends T {
  constructor(t4, e9, r6, s13) {
    super(t4, e9, r6, s13), this.vertexSpec = m5, this._tessellationOptions.textured = true;
  }
  _write(t4, r6, s13) {
    const o9 = s13 ?? a2.fromFeatureSetReaderCIM(r6);
    if (!o9) return;
    const { sprite: i14 } = this.evaluatedMeshParams;
    this._writeGeometry(t4, r6, o9, i14 == null ? void 0 : i14.textureBinding);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/ComputedMarkerParams.js
var s11 = class _s {
  static from(t4) {
    return "width" in t4 ? this.fromSimpleMeshParams(t4) : this.fromComplexMeshParams(t4);
  }
  static fromSimpleMeshParams(e9) {
    const i14 = new _s(e9.sprite, e9.color, e9.outlineColor, e9.minPixelBuffer, e9.placement, e9.scaleInfo, e9.effects), { type: o9, width: h7, height: r6, angle: a10, alignment: n11, outlineSize: c8, referenceSize: f6, sprite: l8, overrideOutlineColor: m6 } = e9;
    return i14.rawWidth = u(h7), i14.rawHeight = u(r6), i14.angle = a10, i14.alignment = n11, i14.outlineSize = u(c8), i14.referenceSize = u(f6), i14.overrideOutlineColor = m6, i14.offsetX = u(e9.offsetX), i14.offsetY = u(e9.offsetY), "simple" !== o9 || l8.sdf || (i14.rawWidth = l8.width, i14.rawHeight = l8.height), i14._computeSize(e9, false), i14;
  }
  static fromComplexMeshParams(e9) {
    const o9 = new _s(e9.sprite, e9.color, e9.outlineColor, e9.minPixelBuffer, e9.placement, e9.scaleInfo, e9.effects);
    let { alignment: h7, transforms: r6, size: a10, scaleX: n11, anchorX: c8, anchorY: f6, angle: l8, colorLocked: m6, frameHeight: d6, widthRatio: u6, offsetX: p6, offsetY: g5, outlineSize: x5, referenceSize: w5, scaleFactor: z3, sizeRatio: S5, isAbsoluteAnchorPoint: X, rotateClockwise: Y, scaleSymbolsProportionally: C4, sprite: H2 } = e9;
    if (r6 && r6.infos.length > 0) {
      const t4 = E(a10, l8, Y, p6, g5, r6);
      a10 = t4.size, l8 = t4.rotation, p6 = t4.offsetX, g5 = t4.offsetY, Y = false;
    }
    z3 && (a10 *= z3, p6 *= z3, g5 *= z3);
    const M3 = n11 * (H2.width / H2.height);
    o9.alignment = h7, o9.rawHeight = u(a10), o9.rawWidth = o9.rawHeight * M3, o9.referenceSize = u(w5), o9.sizeRatio = S5, o9.sdfDecodeCoeff = (H2.sdfDecodeCoeff ?? 1) * S5, o9.angle = l8, o9.rotateClockwise = Y, o9.anchorX = c8, o9.anchorY = f6, o9.offsetX = u(p6), o9.offsetY = u(g5), X && a10 && (H2.sdf ? o9.anchorX = c8 / (a10 * u6) : o9.anchorX = c8 / (a10 * M3), o9.anchorY = f6 / a10);
    const P2 = C4 && d6 ? a10 / d6 : 1;
    return o9.outlineSize = 0 === x5 || isNaN(x5) ? 0 : u(x5) * P2, o9.scaleSymbolsProportionally = C4, o9.colorLocked = m6, o9._computeSize(e9, true), o9;
  }
  constructor(t4, i14, o9, s13, h7, r6, a10) {
    this.sprite = t4, this.color = i14, this.outlineColor = o9, this.minPixelBuffer = s13, this.placement = h7, this.scaleInfo = r6, this.effects = a10, this.rawWidth = 0, this.rawHeight = 0, this.angle = 0, this.outlineSize = 0, this.referenceSize = 0, this.sizeRatio = 1, this.sdfDecodeCoeff = 1, this.alignment = i.SCREEN, this.scaleSymbolsProportionally = false, this.overrideOutlineColor = false, this.colorLocked = false, this.anchorX = 0, this.anchorY = 0, this.computedWidth = 0, this.computedHeight = 0, this.texXmin = 0, this.texYmin = 0, this.texXmax = 0, this.texYmax = 0, this.offsetX = 0, this.offsetY = 0, this.rotateClockwise = true;
  }
  get boundsInfo() {
    return { size: Math.max(this.computedHeight, this.computedWidth), offsetX: this.offsetX, offsetY: this.offsetY };
  }
  _computeSize(t4, e9) {
    const { sprite: i14, hasSizeVV: s13 } = t4, h7 = !!i14.sdf, r6 = i14.sdfPaddingRatio ?? 0.5, { rawWidth: a10, rawHeight: n11, sizeRatio: c8, outlineSize: f6 } = this, l8 = c8 * (h7 ? 1 / (1 - r6) : 1), m6 = a10 * l8, d6 = n11 * l8;
    if (h7 && !s13) {
      const t5 = e9 && a10 > n11 ? m6 : a10, i15 = n11, o9 = f6 + 2 * 1;
      this.computedWidth = Math.min(t5 + o9, m6), this.computedHeight = Math.min(i15 + o9, d6);
    } else this.computedWidth = m6, this.computedHeight = d6;
    const u6 = h7 ? Math.max(i14.width, i14.height) / Math.max(m6, d6) : 1, p6 = 0.5 * (m6 - this.computedWidth) * u6, g5 = 0.5 * (d6 - this.computedHeight) * u6, x5 = i14.rect.x + ti + p6, w5 = i14.rect.y + ti + g5, z3 = x5 + i14.width - 2 * p6, S5 = w5 + i14.height - 2 * g5;
    this.texXmin = Math.floor(x5), this.texYmin = Math.floor(w5), this.texXmax = Math.ceil(z3), this.texYmax = Math.ceil(S5), this.computedWidth *= (this.texXmax - this.texXmin) / (z3 - x5), this.computedHeight *= (this.texYmax - this.texYmin) / (S5 - w5), this.anchorX *= m6 / this.computedWidth, this.anchorY *= d6 / this.computedHeight;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerMeshWriter.js
var g4 = 3.14159265359 / 180;
var k3 = 128 / Math.PI;
function b3(e9, t4) {
  return e9 %= t4, Math.abs(e9 >= 0 ? e9 : e9 + t4);
}
function v2(e9) {
  return b3(e9 * k3, 256);
}
function S4(e9, a10, i14, n11, c8 = false) {
  const m6 = n3(), l8 = c8 ? 1 : -1;
  return a3(m6), (a10 || i14) && i3(m6, m6, [a10, -i14]), n11 && s4(m6, m6, l8 * g4 * -n11), m6;
}
var I2 = { createComputedParams: (e9) => s11.from(e9), optionalAttributes: { zoomRange: { type: C.SHORT, count: 2, packPrecisionFactor: mi, pack: ({ scaleInfo: e9 }, { tileInfo: t4 }) => m3(e9, t4) } }, attributes: { pos: { type: C.SHORT, count: 2, pack: "position", packPrecisionFactor: 10 }, id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: ({ sprite: e9, alignment: t4, scaleSymbolsProportionally: r6, overrideOutlineColor: o9, colorLocked: s13 }) => {
  let a10 = 0;
  return e9.sdf && (a10 |= f3(o.bitset.isSDF)), t4 === i.MAP && (a10 |= f3(o.bitset.isMapAligned)), r6 && (a10 |= f3(o.bitset.scaleSymbolsProportionally)), o9 && (a10 |= f3(o.bitset.overrideOutlineColor)), s13 && (a10 |= f3(o.bitset.colorLocked)), a10;
} }, offset: { type: C.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, pack: ({ angle: e9, computedWidth: t4, computedHeight: r6, anchorX: o9, anchorY: s13, offsetX: i14, offsetY: n11, rotateClockwise: c8 }) => {
  const m6 = S4(0, i14, n11, -e9, c8), l8 = -(0.5 + o9) * t4, d6 = -(0.5 - s13) * r6, u6 = [l8, d6], p6 = [l8 + t4, d6], h7 = [l8, d6 + r6], f6 = [l8 + t4, d6 + r6];
  return S(u6, u6, m6), S(p6, p6, m6), S(h7, h7, m6), S(f6, f6, m6), [u6, p6, h7, f6];
} } }, textureUV: { type: C.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, pack: ({ texXmax: e9, texXmin: t4, texYmax: r6, texYmin: o9 }) => [[t4, o9], [e9, o9], [t4, r6], [e9, r6]] } }, color: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ color: e9 }) => g3(e9) }, outlineColor: { type: C.UNSIGNED_BYTE, count: 4, normalized: true, pack: ({ outlineColor: e9 }) => g3(e9) }, sizing: { type: C.UNSIGNED_BYTE, count: 4, pack: ({ rawWidth: e9, rawHeight: t4, outlineSize: r6, referenceSize: o9 }) => {
  const s13 = Math.max(e9, t4);
  return [d3(s13, 128), d3(r6, 128), d3(o9, 128), 0];
} }, placementAngle: { type: C.UNSIGNED_BYTE, count: 1, packTessellation: ({ placementAngle: e9 }) => v2(e9) }, sdfDecodeCoeff: { type: C.UNSIGNED_SHORT, count: 1, packPrecisionFactor: 64, pack: ({ sdfDecodeCoeff: e9 }) => e9 } } };
var _3 = class extends c4 {
  constructor() {
    super(...arguments), this.vertexSpec = I2;
  }
  getBoundsInfo() {
    return this.evaluatedMeshParams.boundsInfo;
  }
  _write(e9, t4, r6) {
    var _a;
    const o9 = (_a = this.evaluatedMeshParams.sprite) == null ? void 0 : _a.textureBinding, s13 = t4.getDisplayId();
    e9.recordStart(this.instanceId, this.attributeLayout, o9);
    const a10 = this.evaluatedMeshParams.minPixelBuffer, i14 = Math.max(this.evaluatedMeshParams.computedWidth, a10), c8 = Math.max(this.evaluatedMeshParams.computedHeight, a10), m6 = -this.evaluatedMeshParams.anchorX * this.evaluatedMeshParams.computedWidth, l8 = this.evaluatedMeshParams.anchorY * this.evaluatedMeshParams.computedHeight, d6 = this.evaluatedMeshParams.offsetX + m6, u6 = -this.evaluatedMeshParams.offsetY + l8;
    if (null != this.evaluatedMeshParams.placement) this._writePlacedMarkers(e9, t4, r6, i14, c8);
    else if (r6 == null ? void 0 : r6.nextPath()) {
      r6.nextPoint();
      const t5 = r6.x, o10 = r6.y;
      e9.recordBounds(t5 + d6, o10 + u6, i14, c8), this._writeQuad(e9, s13, t5, o10);
    } else if ("esriGeometryPolygon" === t4.geometryType) {
      const r7 = t4.readCentroidForDisplay();
      if (!r7) return;
      const [o10, a11] = r7.coords;
      e9.recordBounds(o10 + d6, a11 + u6, i14, c8), this._writeQuad(e9, s13, o10, a11);
    } else if ("esriGeometryPoint" === t4.geometryType) {
      const r7 = t4.readXForDisplay(), o10 = t4.readYForDisplay();
      e9.recordBounds(r7 + d6, o10 + u6, i14, c8), this._writeQuad(e9, s13, r7, o10);
    } else {
      const r7 = t4.readGeometryForDisplay();
      r7 == null ? void 0 : r7.forEachVertex((t5, r8) => {
        e9.recordBounds(t5 + d6, r8 + u6, i14, c8), Math.abs(t5) > e3 || Math.abs(r8) > e3 || this._writeQuad(e9, s13, t5, r8);
      });
    }
    e9.recordEnd();
  }
  _writePlacedMarkers(t4, r6, o9, s13, a10) {
    var _a;
    const c8 = o9 ?? ((_a = a2.fromFeatureSetReaderCIM(r6)) == null ? void 0 : _a.clone());
    if (!c8) return;
    const l8 = -1, d6 = e8.getPlacement(c8, l8, this.evaluatedMeshParams.placement, u(1), t4.id, t3());
    if (!d6) return;
    const u6 = r6.getDisplayId();
    let p6 = d6.next();
    const h7 = this.evaluatedMeshParams.offsetX, f6 = -this.evaluatedMeshParams.offsetY;
    for (; null != p6; ) {
      const e9 = p6.tx, r7 = -p6.ty;
      if (Math.abs(e9) > e3 || Math.abs(r7) > e3) {
        p6 = d6.next();
        continue;
      }
      const o10 = -p6.getAngle();
      t4.recordBounds(e9 + h7, r7 + f6, s13, a10), this._writeQuad(t4, u6, e9, r7, o10), p6 = d6.next();
    }
  }
  _writeQuad(e9, t4, r6, o9, s13) {
    const a10 = e9.vertexCount(), i14 = null == s13 ? null : { placementAngle: s13 };
    this._writeVertex(e9, t4, r6, o9, i14), e9.indexWrite(a10 + 0), e9.indexWrite(a10 + 1), e9.indexWrite(a10 + 2), e9.indexWrite(a10 + 1), e9.indexWrite(a10 + 3), e9.indexWrite(a10 + 2);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartMeshWriter.js
var o8 = { createComputedParams: (e9) => e9, optionalAttributes: {}, attributes: { pos: { type: C.SHORT, count: 2, packPrecisionFactor: 10, pack: "position" }, id: { type: C.UNSIGNED_BYTE, count: 3, pack: "id" }, bitset: { type: C.UNSIGNED_BYTE, count: 1, pack: (e9) => 0 }, offset: { type: C.SHORT, count: 2, packPrecisionFactor: 16, packAlternating: { count: 4, pack: ({ size: t4 }) => {
  const r6 = u(t4), i14 = -r6 / 2, o9 = -r6 / 2;
  return [[i14, o9], [i14 + r6, o9], [i14, o9 + r6], [i14 + r6, o9 + r6]];
} } }, texCoords: { type: C.SHORT, count: 2, packPrecisionFactor: 4, packAlternating: { count: 4, pack: () => [[0, 1], [1, 1], [0, 0], [1, 0]] } }, size: { type: C.UNSIGNED_BYTE, count: 2, pack: ({ size: e9 }) => [e9, e9] }, referenceSize: { type: C.UNSIGNED_BYTE, count: 1, pack: ({ size: t4 }) => u(t4) }, zoomRange: { type: C.UNSIGNED_BYTE, count: 2, pack: ({ scaleInfo: e9 }, { tileInfo: r6 }) => m3(e9, r6) } } };
var s12 = class extends c4 {
  constructor() {
    super(...arguments), this.vertexSpec = o8;
  }
  _write(t4, r6) {
    const i14 = r6.getDisplayId(), o9 = this.evaluatedMeshParams.minPixelBuffer, s13 = Math.max(u(this.evaluatedMeshParams.size), o9);
    let c8, n11;
    if ("esriGeometryPoint" === r6.geometryType) c8 = r6.readXForDisplay(), n11 = r6.readYForDisplay();
    else {
      const e9 = r6.readCentroidForDisplay();
      if (!e9) return;
      c8 = e9 == null ? void 0 : e9.coords[0], n11 = e9 == null ? void 0 : e9.coords[1];
    }
    t4.recordStart(this.instanceId, this.attributeLayout), t4.recordBounds(c8, n11, s13, s13);
    const a10 = t4.vertexCount();
    this._writeVertex(t4, i14, c8, n11), t4.indexWrite(a10 + 0), t4.indexWrite(a10 + 1), t4.indexWrite(a10 + 2), t4.indexWrite(a10 + 1), t4.indexWrite(a10 + 3), t4.indexWrite(a10 + 2), t4.recordEnd();
  }
};

export {
  m3 as m,
  f3 as f,
  g3 as g,
  l4 as l,
  c4 as c,
  s8 as s,
  c5 as c2,
  o6 as o,
  h4 as h,
  T,
  h5 as h2,
  _2 as _,
  c7 as c3,
  i12 as i,
  P,
  N,
  l7 as l2,
  _3 as _2,
  s12 as s2
};
//# sourceMappingURL=chunk-UUYHVC5D.js.map
