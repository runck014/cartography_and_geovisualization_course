import {
  a as a2
} from "./chunk-K3DZ25FR.js";
import {
  d as d3
} from "./chunk-TITCAM2J.js";
import {
  i as i3
} from "./chunk-24JRIC5L.js";
import {
  c as c3,
  t as t2
} from "./chunk-A33GYYOL.js";
import {
  Xe
} from "./chunk-ER5KJVHG.js";
import {
  r as r3
} from "./chunk-5IA763KB.js";
import {
  c,
  c2,
  g as g2,
  h,
  i as i2,
  l,
  t
} from "./chunk-EP5G3AVD.js";
import {
  S as S2
} from "./chunk-LN6VH2LB.js";
import {
  b as b3
} from "./chunk-WGIZLWW7.js";
import {
  d as d2
} from "./chunk-VILGTHTP.js";
import {
  r as r2
} from "./chunk-UYSPJCCV.js";
import {
  f as f2
} from "./chunk-F26LCWNQ.js";
import {
  d
} from "./chunk-TDZ623HP.js";
import {
  S
} from "./chunk-BMGF5ELJ.js";
import {
  m as m2
} from "./chunk-CY5MS6DC.js";
import {
  w
} from "./chunk-A3J7W53Y.js";
import {
  g
} from "./chunk-L6D73M4D.js";
import {
  i,
  n as n2
} from "./chunk-7O7KFKCG.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import {
  I
} from "./chunk-QS62R4CH.js";
import {
  f,
  u2
} from "./chunk-VU6O6TFT.js";
import {
  b2,
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  b,
  u
} from "./chunk-GRW2QIBT.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/networks/support/TopologyValidationJobInfo.js
var n3 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var l2 = class extends i3 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const s3 = { ...t3, query: { f: "json" } }, { data: r4 } = await U(this.statusUrl, s3);
    return this.read(r4), this.editsResolver && this.editsResolver.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], exceededTransferLimit: true, historicMoment: null }), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: e2 = 1e3, statusCallback: s3 } = t3;
    return new Promise((t4, o) => {
      this._clearTimer();
      const i5 = setInterval(() => {
        this._timer || o(u()), this.checkJobStatus().then((e3) => {
          const { status: r4 } = e3;
          switch (this.status = r4, r4) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              s3 && s3(this);
          }
        }, (t5) => {
          this._clearTimer(), o(t5);
        });
      }, e2);
      this._timer = i5;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
r([m()], l2.prototype, "editsResolver", void 0), r([m({ type: String, json: { write: true } })], l2.prototype, "statusUrl", void 0), r([r2(n3)], l2.prototype, "status", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e2) => {
  e2.submissionTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "submissionTime", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, e2) => {
  e2.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], l2.prototype, "lastUpdatedTime", void 0), l2 = r([a("esri.networks.support.TopologyValidationJobInfo")], l2);
var m3 = l2;

// node_modules/@arcgis/core/networks/support/utils.js
async function i4(t3, e2) {
  if ("Utility Network Layer" === t3) {
    const { default: t4 } = await import("./UtilityNetwork-X7S3UV4D.js");
    return new t4({ layerUrl: e2 });
  }
  return null;
}
async function l3(r4) {
  var _a;
  let o = "portalItem" in r4 ? r4 : { portalItem: r4 };
  !o.portalItem || o.portalItem instanceof S || (o = { ...o, portalItem: new S(o.portalItem) });
  const n6 = o.portalItem;
  if (await n6.load(), "Feature Service" !== n6.type) throw new s("portal:unknown-item-type", "Unknown item type '${type}'", { type: n6.type });
  const l5 = n6.url, s3 = await U(l5, { responseType: "json", query: { f: "json" } }), p4 = "Network Layer";
  if ((_a = s3.data.type) == null ? void 0 : _a.includes(p4)) return i4(s3.data.type, l5);
  if (s3.data.layers) {
    const t3 = s3.data.layers.find((t4) => t4.type.includes(p4));
    if (t3) {
      const e2 = `${l5}/${t3.id}`;
      return i4(t3.type, e2);
    }
  }
  return null;
}

// node_modules/@arcgis/core/networks/Network.js
var U2 = class extends S2(m2) {
  static fromPortalItem(e2) {
    return l3(e2);
  }
  constructor(e2) {
    super(e2), this.id = null, this.title = null, this.layerUrl = null, this.dataElement = null, this.fullExtent = null, this.spatialReference = null, this.type = null, this.sourceJSON = null, this.gdbVersion = null, this.historicMoment = null, this._sourceIdByLayerId = /* @__PURE__ */ new Map(), this._layerIdBySourceId = /* @__PURE__ */ new Map(), this._applyEditsHandler = (e3) => {
      const { serviceUrl: t3, gdbVersion: r4, result: o } = e3, s3 = t3 === this.featureServiceUrl, i5 = g2(t3, r4, this.gdbVersion);
      s3 && i5 && o.then((e4) => {
        c(t3, r4) && (this.historicMoment = e4.historicMoment);
      });
    }, this._updateMomentHandler = (e3) => {
      const { serviceUrl: t3, gdbVersion: r4, moment: o } = e3, s3 = t3 === this.featureServiceUrl, i5 = g2(t3, r4, this.gdbVersion);
      s3 && i5 && (this.historicMoment = o);
    }, this.when().then(() => {
      this.addHandles([l(this._applyEditsHandler), h(this._updateMomentHandler)]);
    }, () => {
    });
  }
  initialize() {
    this.when().catch((e2) => {
      b(e2) || n.getLogger(this).error("#load()", `Failed to load layer (title: '${this.title ?? "no title"}', id: '${this.id ?? "no id"}')`, { error: e2 });
    });
  }
  get datasetName() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.name) ?? null;
  }
  get owner() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.userIdentity) ?? null;
  }
  get schemaGeneration() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.schemaGeneration) ?? null;
  }
  get parsedUrl() {
    return I(this.layerUrl);
  }
  get featureServiceUrl() {
    return d(this.parsedUrl.path).url.path;
  }
  get networkServiceUrl() {
    return this.featureServiceUrl.replace(/\/FeatureServer/i, "/UtilityNetworkServer");
  }
  get layerId() {
    return d(this.parsedUrl.path).sublayer;
  }
  get networkSystemLayers() {
    return null;
  }
  async load(e2) {
    return this.addResolvingPromise(this._fetchDataElement(this.featureServiceUrl, this.layerId.toString(), e2)), this.addResolvingPromise(this._fetchLayerMetaData(this.layerUrl, e2)), this;
  }
  getLayerIdBySourceId(e2) {
    if (!this.dataElement) return null;
    const t3 = this._layerIdBySourceId.get(e2);
    if (null != t3) return t3;
    const r4 = this.dataElement.domainNetworks, o = this._traverseNetworkSources(r4, this._layerIdBySourceId, "sourceId", "layerId", e2);
    return o >= 0 ? o : null;
  }
  getSourceIdByLayerId(e2) {
    if (!this.dataElement) return null;
    const t3 = this._sourceIdByLayerId.get(e2);
    if (null != t3) return t3;
    const r4 = this.dataElement.domainNetworks, o = this._traverseNetworkSources(r4, this._sourceIdByLayerId, "layerId", "sourceId", e2);
    return o >= 0 ? o : null;
  }
  getObjectIdsFromElements(e2) {
    const t3 = [], r4 = /* @__PURE__ */ new Map();
    for (const s3 of e2) {
      const e3 = this.getLayerIdBySourceId(s3.networkSourceId);
      if (null == e3) continue;
      let t4 = r4.get(e3);
      void 0 === t4 && (t4 = []), t4.push(s3.objectId), r4.set(e3, t4);
    }
    const o = this.featureServiceUrl;
    return r4.forEach((e3, r5) => t3.push({ layerUrl: `${o}/${r5}`, objectIds: e3 })), t3;
  }
  async queryNamedTraceConfigurations(e2, t3) {
    var _a;
    const [{ queryNamedTraceConfigurations: r4 }, { default: o }] = await Promise.all([import("./queryNamedTraceConfigurations-SJK37HBJ.js"), import("./QueryNamedTraceConfigurationsParameters-P4LDCPQX.js")]), s3 = this.networkServiceUrl, i5 = o.from(e2);
    return (_a = await r4(s3, i5, { ...t3 })) == null ? void 0 : _a.namedTraceConfigurations;
  }
  async validateTopology(e2, t3) {
    var _a, _b, _c;
    if (!e2.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    const [{ validateNetworkTopology: r4 }, { default: s3 }] = await Promise.all([import("./validateNetworkTopology-6OM7HJ23.js"), import("./ValidateNetworkTopologyParameters-UPFQ3VZ5.js")]), i5 = s3.from(e2);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (i5.sessionID = t, await i2(this.featureServiceUrl, this.gdbVersion, true)) : i5.sessionID = null, i5.gdbVersion = this.gdbVersion;
    const a5 = this.networkServiceUrl, n6 = this.featureServiceUrl, l5 = c2(n6, null, this.gdbVersion, true), d5 = await r4(a5, i5, { ...t3 });
    if (d5 == null ? void 0 : d5.serviceEdits) {
      const e3 = [];
      for (const t4 of d5.serviceEdits) {
        const { editedFeatures: r5 } = t4, o = (r5 == null ? void 0 : r5.spatialReference) ? new g(r5.spatialReference) : null;
        e3.push({ layerId: t4.layerId, editedFeatures: { adds: ((_a = r5 == null ? void 0 : r5.adds) == null ? void 0 : _a.map((e4) => k(e4, o))) || [], updates: ((_b = r5 == null ? void 0 : r5.updates) == null ? void 0 : _b.map((e4) => ({ original: k(e4[0], o), current: k(e4[1], o) }))) || [], deletes: ((_c = r5 == null ? void 0 : r5.deletes) == null ? void 0 : _c.map((e4) => k(e4, o))) || [], spatialReference: o } });
      }
      l5.resolve({ edits: null, addedFeatures: [], updatedFeatures: [], deletedFeatures: [], addedAttachments: [], updatedAttachments: [], deletedAttachments: [], editedFeatures: e3, exceededTransferLimit: false, historicMoment: d5.moment });
    }
    return d5;
  }
  async submitTopologyValidationJob(e2, t3) {
    let s3 = null;
    if (!e2.validateArea) throw new s("network:undefined-validateArea", "the network must have validateArea defined in the validate network topology parameters.");
    if (!this.gdbVersion) {
      const e3 = this.layerUrl.replace(/\/FeatureServer/i, "/VersionManagementServer").replace(/\/\d*$/, "");
      s3 = (await U(e3, { responseType: "json", query: { f: "json" } })).data.defaultVersionName;
    }
    const [{ submitValidateNetworkTopologyJob: i5 }, { default: a5 }] = await Promise.all([import("./validateNetworkTopology-6OM7HJ23.js"), import("./ValidateNetworkTopologyParameters-UPFQ3VZ5.js")]), n6 = a5.from(e2);
    c(this.featureServiceUrl, this.gdbVersion || null) ? (n6.sessionID = t, await i2(this.featureServiceUrl, this.gdbVersion, true)) : n6.sessionID = null, n6.gdbVersion = this.gdbVersion || s3;
    const l5 = this.networkServiceUrl, d5 = this.featureServiceUrl ? c2(this.featureServiceUrl, null, this.gdbVersion, true) : void 0, u3 = await i5(l5, n6, { ...t3 });
    return new m3({ statusUrl: u3, editsResolver: d5 });
  }
  _traverseNetworkSources(e2, t3, r4, o, s3) {
    for (const i5 of e2) for (const e3 of [i5.edgeSources ?? [], i5.junctionSources ?? []]) for (const i6 of e3) if (i6[r4] === s3) return t3.set(s3, i6[o]), i6[o];
    return -1;
  }
  async _fetchLayerMetaData(e2, t3) {
    const o = await U(e2, { responseType: "json", query: { f: "json" }, ...t3 });
    this.sourceJSON = o.data, this.read(o.data, { origin: "service" });
  }
  async _fetchDataElement(e2, t3, o) {
    if (this.dataElement) return;
    const s3 = await U(`${e2}/queryDataElements`, { responseType: "json", query: { layers: JSON.stringify([t3]), f: "json" }, ...o }).then((e3) => {
      var _a;
      return (_a = e3.data.layerDataElements) == null ? void 0 : _a[0];
    });
    s3 && this.read(s3, { origin: "service" });
  }
};
function k(e2, r4) {
  return new d2({ attributes: e2.attributes, geometry: f2({ ...e2.geometry, spatialReference: r4 }) });
}
r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: true } }, read: false } })], U2.prototype, "id", void 0), r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: true, write: { isRequired: true } }, service: { read: { source: "name" } } }, read: false } })], U2.prototype, "title", void 0), r([m({ type: String, nonNullable: true, json: { origins: { "web-map": { read: { source: "url" }, write: { target: "url", isRequired: true } } }, read: false } })], U2.prototype, "layerUrl", void 0), r([m({ type: Object, json: { origins: { service: { read: true } }, read: false } })], U2.prototype, "dataElement", void 0), r([m({ type: w, json: { origins: { service: { read: { source: "extent" } } }, read: false } })], U2.prototype, "fullExtent", void 0), r([m({ type: g, json: { origins: { service: { read: { source: "extent.spatialReference" } } }, read: false } })], U2.prototype, "spatialReference", void 0), r([m({ type: ["utility", "trace"], readOnly: true, json: { read: false, write: false } })], U2.prototype, "type", void 0), r([m({ readOnly: true })], U2.prototype, "datasetName", null), r([m({ readOnly: true })], U2.prototype, "owner", null), r([m({ readOnly: true })], U2.prototype, "schemaGeneration", null), r([m({ readOnly: true })], U2.prototype, "parsedUrl", null), r([m({ readOnly: true })], U2.prototype, "featureServiceUrl", null), r([m({ readOnly: true })], U2.prototype, "networkServiceUrl", null), r([m({ readOnly: true })], U2.prototype, "layerId", null), r([m()], U2.prototype, "sourceJSON", void 0), r([m({ readOnly: true })], U2.prototype, "networkSystemLayers", null), r([m()], U2.prototype, "gdbVersion", void 0), r([m({ type: Date })], U2.prototype, "historicMoment", void 0), U2 = r([a("esri.networks.Network")], U2);
var N = U2;

// node_modules/@arcgis/core/networks/RulesTable.js
var a3 = class extends u2(m2) {
  constructor(e2) {
    super(e2), this.rulesCategorized = { attachment: [], containment: [], connectivity: [] }, this.request = U;
  }
  initialize() {
  }
  async load(e2) {
    const t3 = this.layer.load(e2).then(() => this._initializeRulesTable());
    return this.addResolvingPromise(t3), this;
  }
  getFeatureSQL(e2, t3) {
    var _a, _b;
    const o = e2.layerId.toString(), s3 = (_a = e2.fieldsIndex) == null ? void 0 : _a.normalizeFieldName("assetGroup"), r4 = (_b = e2.fieldsIndex) == null ? void 0 : _b.normalizeFieldName("assetType"), i5 = s3 ? t3.attributes[s3] : null, n6 = r4 ? t3.attributes[r4] : null, a5 = this.rulesHash[o];
    if (a5) {
      const e3 = a5.assetGroupHash[i5];
      if (e3) {
        return e3.assetTypeHash[n6] || null;
      }
    }
    return null;
  }
  async _initializeRulesTable() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const e2 = {};
    let t3;
    !function(e3) {
      e3[e3.from = 0] = "from", e3[e3.to = 1] = "to", e3[e3.via = 2] = "via";
    }(t3 || (t3 = {}));
    const o = [{ networkSourceId: "fromNetworkSource", assetGroupId: "fromAssetGroup", assetTypeId: "fromAssetType" }, { networkSourceId: "toNetworkSource", assetGroupId: "toAssetGroup", assetTypeId: "toAssetType" }, { networkSourceId: "viaNetworkSource", assetGroupId: "viaAssetGroup", assetTypeId: "viaAssetType" }];
    this.rulesCategorized = { attachment: [], containment: [], connectivity: [] };
    for (const s3 of this.rules) {
      if (s3.ruleType === t2.RTAttachment) {
        this.rulesCategorized.attachment.push(s3);
        continue;
      }
      if (s3.ruleType === t2.RTContainment) {
        this.rulesCategorized.containment.push(s3);
        continue;
      }
      if (s3.ruleType === t2.RTJunctionJunctionConnectivity) {
        this.rulesCategorized.connectivity.push(s3);
        continue;
      }
      this.rulesCategorized.connectivity.push(s3);
      let r4 = [[t3.from, t3.to], [t3.to, t3.from]];
      s3.ruleType === t2.RTEdgeJunctionEdgeConnectivity && (r4 = [[t3.from, t3.via], [t3.via, t3.from], [t3.to, t3.via], [t3.via, t3.to]]);
      for (const i5 of r4) {
        const r5 = i5.shift(), a5 = i5.shift();
        let c5 = false;
        switch (s3.ruleType) {
          case t2.RTEdgeJunctionEdgeConnectivity:
            c5 = r5 === t3.from || r5 === t3.to;
            break;
          case t2.RTJunctionEdgeConnectivity:
            c5 = r5 === t3.to;
        }
        const u3 = o[r5], p4 = ((_a = s3[u3.networkSourceId]) == null ? void 0 : _a.layerId.toString()) ?? "", d5 = (_c = (_b = s3[u3.assetGroupId]) == null ? void 0 : _b.assetGroupCode) == null ? void 0 : _c.toString(), l5 = s3[u3.assetTypeId], y = (_d = l5 == null ? void 0 : l5.assetTypeCode) == null ? void 0 : _d.toString(), m5 = o[a5], h2 = ((_e = s3[m5.networkSourceId]) == null ? void 0 : _e.layerId.toString()) ?? "", f4 = (_g = (_f = s3[m5.assetGroupId]) == null ? void 0 : _f.assetGroupCode) == null ? void 0 : _g.toString(), T2 = s3[m5.assetTypeId], g3 = (_h = T2 == null ? void 0 : T2.assetTypeCode) == null ? void 0 : _h.toString(), v = e2[p4] ?? { assetGroupHash: {} };
        if (!(d5 && y && f4 && g3)) continue;
        const I2 = v.assetGroupHash[d5] ?? { assetTypeHash: {} }, S3 = I2.assetTypeHash[y] ?? {};
        if (S3[h2] = S3[h2] ?? {}, c5) {
          S3[p4] = S3[p4] ?? {};
          const e3 = `(assetgroup = ${d5} AND assettype = ${y})`;
          "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) ? S3[p4].endVertex = ((_i = S3[p4]) == null ? void 0 : _i.endVertex) ? `${S3[p4].endVertex}` : `${e3}` : S3[p4].anyVertex = S3[p4].anyVertex ? `${S3[p4].anyVertex}` : `${e3}`;
        }
        const C = `(assetgroup = ${f4} AND assettype = ${g3})`;
        "esriNECPEndVertex" === (T2 == null ? void 0 : T2.connectivityPolicy) ? S3[h2].endVertex = ((_j = S3[h2]) == null ? void 0 : _j.endVertex) ? `${S3[h2].endVertex} OR ${C}` : `${C}` : S3[h2].anyVertex = ((_k = S3[h2]) == null ? void 0 : _k.anyVertex) ? `${S3[h2].anyVertex} OR ${C}` : `${C}`, I2.assetTypeHash[y] = S3, v.assetGroupHash[d5] = I2, e2[p4] = v;
      }
    }
    this.rulesHash = e2;
  }
};
r([m({ constructOnly: true })], a3.prototype, "layer", void 0), r([m({ constructOnly: true })], a3.prototype, "rules", void 0), r([m()], a3.prototype, "rulesHash", void 0), r([m()], a3.prototype, "rulesCategorized", void 0), r([m({ constructOnly: true })], a3.prototype, "request", void 0), a3 = r([a("esri.networks.RulesTable")], a3);
var c4 = a3;

// node_modules/@arcgis/core/networks/support/NetworkSystemLayers.js
var e = class extends b2 {
  constructor(r4) {
    super(r4), this.rulesTableId = null, this.rulesTableUrl = null, this.subnetworksTableId = null, this.subnetworksTableUrl = null, this.dirtyAreasLayerId = null, this.dirtyAreasLayerUrl = null, this.associationsTableId = null, this.associationsTableUrl = null;
  }
};
r([m({ constructOnly: true })], e.prototype, "rulesTableId", void 0), r([m({ constructOnly: true })], e.prototype, "rulesTableUrl", void 0), r([m({ constructOnly: true })], e.prototype, "subnetworksTableId", void 0), r([m({ constructOnly: true })], e.prototype, "subnetworksTableUrl", void 0), r([m({ constructOnly: true })], e.prototype, "dirtyAreasLayerId", void 0), r([m({ constructOnly: true })], e.prototype, "dirtyAreasLayerUrl", void 0), r([m({ constructOnly: true })], e.prototype, "associationsTableId", void 0), r([m({ constructOnly: true })], e.prototype, "associationsTableUrl", void 0), e = r([a("esri.networks.support.NetworkSystemLayers")], e);
var l4 = e;

// node_modules/@arcgis/core/networks/support/Terminal.js
var s2 = class extends f {
  constructor(r4) {
    super(r4), this.id = null, this.name = null;
  }
};
r([m({ type: Number, json: { read: { source: "terminalId" }, write: { target: "terminalId" } } })], s2.prototype, "id", void 0), r([m({ type: String, json: { read: { source: "terminalName" }, write: { target: "terminalName" } } })], s2.prototype, "name", void 0), r([m({ type: Boolean, json: { write: true } })], s2.prototype, "isUpstreamTerminal", void 0), s2 = r([a("esri.networks.support.Terminal")], s2);
var p = s2;

// node_modules/@arcgis/core/networks/support/TerminalConfiguration.js
var a4 = new n2({ esriUNTMBidirectional: "bidirectional", esriUNTMDirectional: "directional" });
var n4 = class extends f {
  constructor(r4) {
    super(r4), this.defaultConfiguration = null, this.id = null, this.name = null, this.terminals = [], this.traversabilityModel = null;
  }
};
r([m({ type: String, json: { write: true } })], n4.prototype, "defaultConfiguration", void 0), r([m({ type: Number, json: { read: { source: "terminalConfigurationId" }, write: { target: "terminalConfigurationId" } } })], n4.prototype, "id", void 0), r([m({ type: String, json: { read: { source: "terminalConfigurationName" }, write: { target: "terminalConfigurationName" } } })], n4.prototype, "name", void 0), r([m({ type: [p], json: { write: true } })], n4.prototype, "terminals", void 0), r([m({ type: a4.apiValues, json: { type: a4.jsonValues, read: a4.read, write: a4.write } })], n4.prototype, "traversabilityModel", void 0), n4 = r([a("esri.networks.support.TerminalConfiguration")], n4);
var p2 = n4;

// node_modules/@arcgis/core/networks/support/TraceJobInfo.js
var m4 = i()({ Pending: "job-waiting", InProgress: "job-executing", Completed: "job-succeeded" });
var n5 = class extends a2 {
  constructor(t3) {
    super(t3), this.statusUrl = null, this.status = null, this.submissionTime = null, this.lastUpdatedTime = null, this._timer = void 0;
  }
  destroy() {
    clearInterval(this._timer);
  }
  async checkJobStatus(t3) {
    const e2 = { ...t3, query: { f: "json" } }, { data: r4 } = await U(this.statusUrl, e2), o = r4.traceResults ? { ...r4.traceResults, ...r4 } : r4;
    return this.read(o), this;
  }
  async waitForJobCompletion(t3 = {}) {
    const { interval: s3 = 1e3, statusCallback: e2 } = t3;
    return new Promise((t4, o) => {
      this._clearTimer();
      const i5 = setInterval(() => {
        this._timer || o(u()), this.checkJobStatus().then((s4) => {
          const { status: r4 } = s4;
          switch (this.status = r4, r4) {
            case "job-succeeded":
              this._clearTimer(), t4(this);
              break;
            case "job-waiting":
            case "job-executing":
              e2 && e2(this);
          }
        }, (t5) => {
          this._clearTimer(), o(t5);
        });
      }, s3);
      this._timer = i5;
    });
  }
  _clearTimer() {
    clearInterval(this._timer), this._timer = void 0;
  }
};
r([m({ type: String, json: { write: true } })], n5.prototype, "statusUrl", void 0), r([r2(m4)], n5.prototype, "status", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, s3) => {
  s3.submissionTime = t3 ? t3.getTime() : null;
} } } })], n5.prototype, "submissionTime", void 0), r([m({ type: Date, json: { type: Number, write: { writer: (t3, s3) => {
  s3.lastUpdatedTime = t3 ? t3.getTime() : null;
} } } })], n5.prototype, "lastUpdatedTime", void 0), n5 = r([a("esri.networks.support.TraceJobInfo")], n5);
var p3 = n5;

// node_modules/@arcgis/core/networks/UtilityNetwork.js
var f3 = class extends N {
  constructor(e2) {
    super(e2), this.sharedNamedTraceConfigurations = [], this.type = "utility", this._terminalById = /* @__PURE__ */ new Map();
  }
  get serviceTerritoryFeatureLayerId() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.serviceTerritoryFeatureLayerId) ?? null;
  }
  get networkSystemLayers() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return new l4({ rulesTableId: (_a = this.sourceJSON) == null ? void 0 : _a.systemLayers.rulesTableId, rulesTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_b = this.sourceJSON) == null ? void 0 : _b.systemLayers.rulesTableId}` : null, subnetworksTableId: (_c = this.sourceJSON) == null ? void 0 : _c.systemLayers.subnetworksTableId, subnetworksTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_d = this.sourceJSON) == null ? void 0 : _d.systemLayers.subnetworksTableId}` : null, dirtyAreasLayerId: (_e = this.sourceJSON) == null ? void 0 : _e.systemLayers.dirtyAreasLayerId, dirtyAreasLayerUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_f = this.sourceJSON) == null ? void 0 : _f.systemLayers.dirtyAreasLayerId}` : null, associationsTableId: (_g = this.sourceJSON) == null ? void 0 : _g.systemLayers.associationsTableId, associationsTableUrl: this.sourceJSON ? `${this.featureServiceUrl}/${(_h = this.sourceJSON) == null ? void 0 : _h.systemLayers.associationsTableId}` : null });
  }
  get terminalConfigurations() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.terminalConfigurations.map((e2) => p2.fromJSON(e2))) || [];
  }
  get domainNetworkNames() {
    var _a;
    return ((_a = this.dataElement) == null ? void 0 : _a.domainNetworks.map((e2) => e2.domainNetworkName)) || [];
  }
  get _utilityLayerList() {
    var _a, _b;
    const e2 = /* @__PURE__ */ new Set();
    return (_b = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks) == null ? void 0 : _b.map((t3) => {
      t3.edgeSources.map((t4) => {
        e2.add(t4.layerId);
      }), t3.junctionSources.map((t4) => {
        e2.add(t4.layerId);
      });
    }), e2;
  }
  async load(e2) {
    return this.addResolvingPromise(super.load(e2)), this.addResolvingPromise(this._loadNamedTraceConfigurationsFromNetwork(e2)), this;
  }
  getTerminalConfiguration(e2) {
    var _a, _b, _c, _d;
    let t3 = null, r4 = null;
    const o = e2.layer;
    let s3 = null;
    if ("feature" === (o == null ? void 0 : o.type)) {
      if (s3 = o.layerId, null === s3) return null;
    } else {
      if ("subtype-sublayer" !== (o == null ? void 0 : o.type)) return null;
      if (s3 = ((_a = o == null ? void 0 : o.parent) == null ? void 0 : _a.layerId) ?? null, null === s3) return null;
    }
    const a5 = e2.attributes;
    if (null == a5) return null;
    for (const l5 of Object.keys(a5)) "ASSETGROUP" === l5.toUpperCase() && (t3 = e2.getAttribute(l5)), "ASSETTYPE" === l5.toUpperCase() && (r4 = e2.getAttribute(l5));
    if (!this.dataElement) return null;
    let i5 = null;
    const n6 = this.dataElement.domainNetworks;
    for (const l5 of n6) {
      const e3 = (_b = l5.junctionSources) == null ? void 0 : _b.find((e4) => e4.layerId === s3);
      if (e3) {
        const o2 = (_c = e3.assetGroups) == null ? void 0 : _c.find((e4) => e4.assetGroupCode === t3);
        if (o2) {
          const e4 = (_d = o2.assetTypes) == null ? void 0 : _d.find((e5) => e5.assetTypeCode === r4);
          if (e4) {
            i5 = e4.terminalConfigurationId;
            break;
          }
        }
      }
    }
    if (null != i5) {
      const e3 = this.dataElement.terminalConfigurations, t4 = e3 == null ? void 0 : e3.find((e4) => e4.terminalConfigurationId === i5);
      return t4 ? p2.fromJSON(t4) : null;
    }
    return null;
  }
  getTierNames(e2) {
    var _a;
    const t3 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks.find((t4) => t4.domainNetworkName === e2);
    return (t3 == null ? void 0 : t3.tiers.map((e3) => e3.name)) || [];
  }
  async getRulesTable() {
    return this._sharedRulesTable || (this._sharedRulesTable = this._createRulesTable()), await this._sharedRulesTable;
  }
  getTerminalById(e2) {
    if (!this.dataElement || null == e2) return null;
    const t3 = this._terminalById.get(e2);
    return null != t3 ? t3 : (this.terminalConfigurations.forEach((e3) => {
      e3.terminals.forEach((e4) => {
        this._terminalById.set(e4.id, e4);
      });
    }), this._terminalById.get(e2));
  }
  isUtilityLayer(e2) {
    var _a;
    return "layerId" in e2 && (this._utilityLayerList.has(e2.layerId) && (((_a = e2.url) == null ? void 0 : _a.startsWith(this.featureServiceUrl)) ?? false));
  }
  async queryAssociations(e2) {
    const [{ queryAssociations: t3 }, { default: r4 }] = await Promise.all([import("./queryAssociations-Z5SQTA7X.js"), import("./QueryAssociationsParameters-G3XRSQEZ.js")]), o = r4.from(e2);
    o.gdbVersion = this.gdbVersion, o.moment = this.historicMoment;
    return (await t3(this.networkServiceUrl, o)).associations;
  }
  async synthesizeAssociationGeometries(e2) {
    const [{ synthesizeAssociationGeometries: t3 }, { default: r4 }] = await Promise.all([import("./synthesizeAssociationGeometries-53GC7QLS.js"), import("./SynthesizeAssociationGeometriesParameters-XWSDOFDN.js")]), o = r4.from(e2);
    return o.gdbVersion = this.gdbVersion, o.moment = this.historicMoment, t3(this.networkServiceUrl, o);
  }
  async trace(e2) {
    const [{ trace: t3 }, { default: r4 }] = await Promise.all([import("./trace-Z5SXRBB6.js"), import("./TraceParameters-HQ4JI7YC.js")]), o = r4.from(e2);
    return o.gdbVersion = this.gdbVersion, o.moment = this.historicMoment, t3(this.networkServiceUrl, o);
  }
  async submitTraceJob(e2) {
    const [{ submitTraceJob: t3 }, { default: r4 }] = await Promise.all([import("./trace-Z5SXRBB6.js"), import("./TraceParameters-HQ4JI7YC.js")]), o = r4.from(e2);
    o.gdbVersion = this.gdbVersion, o.moment = this.historicMoment;
    const s3 = await t3(this.networkServiceUrl, o);
    return new p3({ statusUrl: s3 });
  }
  async canAddAssociation(e2) {
    const t3 = await this.getRulesTable();
    if (!t3) return false;
    await t3.load();
    const r4 = (e3, t4) => e3 ? 1 === e3.terminalId ? !(t4 == null ? void 0 : t4.terminalId) || (t4 == null ? void 0 : t4.terminalId) === e3.terminalId : e3.terminalId === (t4 == null ? void 0 : t4.terminalId) : !(t4 == null ? void 0 : t4.terminalId), o = (e3, t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      return ((_a = e3.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = t4.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = e3.toNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = t4.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = e3.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = t4.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = e3.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = t4.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = e3.toAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = t4.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = e3.toAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = t4.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r4(e3.fromTerminal, t4.fromNetworkElement) && r4(e3.toTerminal, t4.toNetworkElement);
    };
    if ("containment" === e2.associationType) {
      return t3.rulesCategorized.containment.some((t4) => o(t4, e2));
    }
    if ("attachment" === e2.associationType) {
      return t3.rulesCategorized.attachment.some((t4) => o(t4, e2));
    }
    return t3.rulesCategorized.connectivity.some((t4) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
      return t4.viaNetworkSource ? ((_a = t4.fromNetworkSource) == null ? void 0 : _a.sourceId) === ((_b = e2.fromNetworkElement) == null ? void 0 : _b.networkSourceId) && ((_c = t4.viaNetworkSource) == null ? void 0 : _c.sourceId) === ((_d = e2.toNetworkElement) == null ? void 0 : _d.networkSourceId) && ((_e = t4.fromAssetGroup) == null ? void 0 : _e.assetGroupCode) === ((_f = e2.fromNetworkElement) == null ? void 0 : _f.assetGroupCode) && ((_g = t4.fromAssetType) == null ? void 0 : _g.assetTypeCode) === ((_h = e2.fromNetworkElement) == null ? void 0 : _h.assetTypeCode) && ((_i = t4.viaAssetGroup) == null ? void 0 : _i.assetGroupCode) === ((_j = e2.toNetworkElement) == null ? void 0 : _j.assetGroupCode) && ((_k = t4.viaAssetType) == null ? void 0 : _k.assetTypeCode) === ((_l = e2.toNetworkElement) == null ? void 0 : _l.assetTypeCode) && r4(t4.fromTerminal, e2.fromNetworkElement) && r4(t4.viaTerminal, e2.toNetworkElement) || ((_m = t4.viaNetworkSource) == null ? void 0 : _m.sourceId) === ((_n = e2.fromNetworkElement) == null ? void 0 : _n.networkSourceId) && ((_o = t4.toNetworkSource) == null ? void 0 : _o.sourceId) === ((_p = e2.toNetworkElement) == null ? void 0 : _p.networkSourceId) && ((_q = t4.viaAssetGroup) == null ? void 0 : _q.assetGroupCode) === ((_r = e2.fromNetworkElement) == null ? void 0 : _r.assetGroupCode) && ((_s = t4.viaAssetType) == null ? void 0 : _s.assetTypeCode) === ((_t = e2.fromNetworkElement) == null ? void 0 : _t.assetTypeCode) && ((_u = t4.toAssetGroup) == null ? void 0 : _u.assetGroupCode) === ((_v = e2.toNetworkElement) == null ? void 0 : _v.assetGroupCode) && ((_w = t4.toAssetType) == null ? void 0 : _w.assetTypeCode) === ((_x = e2.toNetworkElement) == null ? void 0 : _x.assetTypeCode) && r4(t4.viaTerminal, e2.fromNetworkElement) && r4(t4.toTerminal, e2.toNetworkElement) : o(t4, e2);
    });
  }
  generateAddAssociations(e2) {
    return { addFeatures: e2.map((e3) => {
      var _a, _b, _c, _d, _e, _f;
      return new d2({ attributes: { fromnetworksourceid: (_a = e3.fromNetworkElement) == null ? void 0 : _a.networkSourceId, fromglobalid: (_b = e3.fromNetworkElement) == null ? void 0 : _b.globalId, fromterminalid: (_c = e3.fromNetworkElement) == null ? void 0 : _c.terminalId, tonetworksourceid: (_d = e3.toNetworkElement) == null ? void 0 : _d.networkSourceId, toglobalid: (_e = e3.toNetworkElement) == null ? void 0 : _e.globalId, toterminalid: (_f = e3.toNetworkElement) == null ? void 0 : _f.terminalId, associationtype: c3[e3.associationType], iscontentvisible: e3.isContentVisible ? 1 : 0, percentalong: e3.percentAlong, globalid: e3.globalId } });
    }), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  generateDeleteAssociations(e2) {
    return { deleteFeatures: e2.map((e3) => ({ globalId: e3.globalId })), id: this.networkSystemLayers.associationsTableId, identifierFields: { globalIdField: "globalid", objectIdField: "objectid" } };
  }
  async _loadNamedTraceConfigurationsFromNetwork(e2) {
    var _a;
    if (0 === ((_a = this.sharedNamedTraceConfigurations) == null ? void 0 : _a.length)) return;
    const t3 = this.sharedNamedTraceConfigurations.map((e3) => e3.globalId), r4 = await this.queryNamedTraceConfigurations({ globalIds: t3 }, e2);
    for (const o of this.sharedNamedTraceConfigurations) {
      const e3 = r4 == null ? void 0 : r4.find((e4) => e4.globalId === o.globalId);
      if (e3) {
        const t4 = e3.write({}, { origin: "service" });
        o.read(t4, { origin: "service" });
      }
    }
  }
  async _createRulesTable() {
    var _a;
    const e2 = this.networkSystemLayers.rulesTableUrl, t3 = new Xe({ url: e2 });
    await t3.load();
    const r4 = (_a = this.dataElement) == null ? void 0 : _a.domainNetworks;
    if (!r4) return null;
    const o = r4.flatMap((e3) => [...e3.edgeSources || [], ...e3.junctionSources || []]), a5 = (await w2(t3)).map((e3) => this._hydrateRuleInfo(t3, o, e3));
    return new c4({ layer: t3, rules: a5 });
  }
  _hydrateRuleInfo(e2, t3, r4) {
    const o = e2.fieldsIndex, s3 = o.get("RULETYPE"), a5 = o.get("CREATIONDATE"), i5 = o.get("FROMNETWORKSOURCEID"), n6 = o.get("FROMASSETGROUP"), l5 = o.get("FROMASSETTYPE"), u3 = o.get("FROMTERMINALID"), m5 = o.get("TONETWORKSOURCEID"), d5 = o.get("TOASSETGROUP"), c5 = o.get("TOASSETTYPE"), y = o.get("TOTERMINALID"), f4 = o.get("VIANETWORKSOURCEID"), w3 = o.get("VIAASSETGROUP"), T2 = o.get("VIAASSETTYPE"), I2 = o.get("VIATERMINALID"), g3 = r4.attributes[s3.name], h2 = new Date(r4.attributes[a5.name]), k2 = [{ networkSourceId: r4.attributes[i5.name], assetGroupId: r4.attributes[n6.name], assetTypeId: r4.attributes[l5.name], terminalId: r4.attributes[u3.name] }, { networkSourceId: r4.attributes[m5.name], assetGroupId: r4.attributes[d5.name], assetTypeId: r4.attributes[c5.name], terminalId: r4.attributes[y.name] }, { networkSourceId: r4.attributes[f4.name], assetGroupId: r4.attributes[w3.name], assetTypeId: r4.attributes[T2.name], terminalId: r4.attributes[I2.name] }];
    let b4;
    !function(e3) {
      e3[e3.from = 0] = "from", e3[e3.to = 1] = "to", e3[e3.via = 2] = "via";
    }(b4 || (b4 = {}));
    const N2 = { ruleType: g3, creationDate: h2 };
    for (const S3 of [b4.from, b4.to, b4.via]) {
      if (g3 !== t2.RTEdgeJunctionEdgeConnectivity && S3 === b4.via) continue;
      const e3 = k2[S3], r5 = t3.find((t4) => t4.sourceId === e3.networkSourceId), o2 = r5 == null ? void 0 : r5.assetGroups.find((t4) => t4.assetGroupCode === e3.assetGroupId), s4 = o2 == null ? void 0 : o2.assetTypes.find((t4) => t4.assetTypeCode === e3.assetTypeId), a6 = this._getTerminal(s4, e3);
      let i6 = "";
      switch (S3) {
        case b4.from:
          i6 = "from";
          break;
        case b4.to:
          i6 = "to";
          break;
        case b4.via:
          i6 = "via";
      }
      N2[`${i6}NetworkSource`] = r5, N2[`${i6}AssetGroup`] = o2, N2[`${i6}AssetType`] = s4, N2[`${i6}Terminal`] = a6 == null ? void 0 : a6.toJSON();
    }
    return N2;
  }
  _getTerminal(e2, t3) {
    var _a, _b;
    const r4 = e2 == null ? void 0 : e2.terminalConfigurationId, o = (_a = this.terminalConfigurations) == null ? void 0 : _a.find((e3) => e3.id === r4);
    return ((_b = o == null ? void 0 : o.terminals) == null ? void 0 : _b.find((e3) => e3.id === t3.terminalId)) ?? null;
  }
};
async function w2(e2) {
  const t3 = new b3({ where: "1=1", outFields: ["*"] });
  return (await r3(e2, t3)).features;
}
r([m({ type: [d3], json: { origins: { "web-map": { read: { source: "traceConfigurations" }, write: { target: "traceConfigurations" } }, service: { read: { source: "traceConfigurations" } } }, read: false } })], f3.prototype, "sharedNamedTraceConfigurations", void 0), r([m({ type: ["utility"], readOnly: true, json: { read: false, write: false } })], f3.prototype, "type", void 0), r([m({ readOnly: true })], f3.prototype, "serviceTerritoryFeatureLayerId", null), r([m({ readOnly: true })], f3.prototype, "networkSystemLayers", null), r([m({ readOnly: true })], f3.prototype, "terminalConfigurations", null), r([m({ readOnly: true })], f3.prototype, "domainNetworkNames", null), f3 = r([a("esri.networks.UtilityNetwork")], f3);
var T = f3;

export {
  T
};
//# sourceMappingURL=chunk-YJ2ZDYJK.js.map
