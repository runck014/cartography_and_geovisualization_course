import {
  M,
  a as a2,
  d3 as d2,
  e as e3,
  e2 as e4,
  h2 as h,
  h3 as h2,
  i,
  i2,
  m,
  m2,
  n2,
  n5 as n3,
  n6 as n4,
  o as o4,
  o3 as o5,
  o4 as o6,
  p,
  t3 as t2,
  t4 as t3,
  t5 as t4,
  u3 as u,
  x
} from "./chunk-DQ6HUSR7.js";
import {
  P,
  a,
  a2 as a3,
  d2 as d,
  f,
  l
} from "./chunk-PFCCTBQ6.js";
import {
  e as e5
} from "./chunk-JW4HK5OB.js";
import {
  o as o7,
  s
} from "./chunk-PVFZLQ5G.js";
import {
  t
} from "./chunk-W3O5CFJ6.js";
import {
  e as e2,
  n
} from "./chunk-HRP7POO2.js";
import {
  o as o3
} from "./chunk-JQJITHTO.js";
import {
  o as o2,
  r
} from "./chunk-6LGJYARD.js";
import {
  e
} from "./chunk-L7OHH2HW.js";
import {
  o
} from "./chunk-CTU2XDPA.js";

// node_modules/@arcgis/core/chunks/RealisticTree.glsl.js
function R(R2) {
  const z2 = new o7(), { vertex: k, fragment: G, varyings: U } = z2, { output: W, offsetBackfaces: H, instancedColor: q, pbrMode: J, snowCover: K, spherical: Q } = R2, X = J === n2.Normal || J === n2.Schematic;
  if (d(k, R2), z2.include(o5), U.add("vpos", "vec3"), z2.include(l, R2), z2.include(M, R2), z2.include(a, R2), W === n.Color && (f(z2.vertex, R2), z2.include(t, R2), z2.include(o6, R2), H && z2.include(e3), q && z2.attributes.add(e.INSTANCECOLOR, "vec4"), U.add("vNormalWorld", "vec3"), U.add("localvpos", "vec3"), R2.terrainDepthTest && U.add("depth", "float"), z2.include(o4, R2), z2.include(n3, R2), z2.include(i, R2), z2.include(e4, R2), k.uniforms.add(new e5("externalColor", (e6) => e6.externalColor)), U.add("vcolorExt", "vec4"), k.main.add(o2`
      forwardNormalizedVertexColor();
      vcolorExt = externalColor;
      ${r(q, "vcolorExt *= instanceColor * 0.003921568627451;")}
      vcolorExt *= vvColor();
      vcolorExt *= getSymbolColor();
      forwardColorMixMode();

      if (vcolorExt.a < ${o2.float(o)}) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      } else {
        vpos = getVertexInLocalOriginSpace();
        localvpos = vpos - view[3].xyz;
        vpos = subtractOrigin(vpos);
        vNormalWorld = dpNormal(vvLocalNormal(normalModel()));
        vpos = addVerticalOffset(vpos, localOrigin);
        gl_Position = transformPosition(proj, view, vpos);
        ${r(H, "gl_Position = offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, cameraPosition);")}
      }
      ${r(R2.terrainDepthTest, "depth = (view * vec4(vpos, 1.0)).z;")}
      forwardLinearDepth();
      forwardTextureCoordinates();`)), W === n.Color) {
    const { hasColorTexture: e6, hasColorTextureTransform: r2, receiveShadows: i3 } = R2;
    z2.include(p, R2), z2.include(t3, R2), z2.include(t2, R2), z2.include(R2.instancedDoublePrecision ? m2 : x, R2), z2.include(a3, R2), z2.include(P, R2), z2.include(d2, R2), f(z2.fragment, R2), t4(G), h2(G), u(G), G.uniforms.add(k.uniforms.get("localOrigin"), k.uniforms.get("view"), new e2("ambient", (e7) => e7.ambient), new e2("diffuse", (e7) => e7.diffuse), new o3("opacity", (e7) => e7.opacity), new o3("layerOpacity", (e7) => e7.layerOpacity)), e6 && G.uniforms.add(new s("tex", (e7) => e7.texture)), z2.include(m, R2), z2.include(n4, R2), G.include(i2), a2(G), G.main.add(o2`
      discardBySlice(vpos);
      ${r(R2.terrainDepthTest, "terrainDepthTest(depth);")}
      vec4 texColor = ${e6 ? `texture(tex, ${r2 ? "colorUV" : "vuv0"})` : " vec4(1.0)"};
      ${r(e6, `${r(R2.textureAlphaPremultiplied, "texColor.rgb /= texColor.a;")}
        discardOrAdjustAlpha(texColor);`)}
      vec3 viewDirection = normalize(vpos - cameraPosition);
      applyPBRFactors();
      float ssao = evaluateAmbientOcclusionInverse();
      ssao *= getBakedOcclusion();

      float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
      vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
      float shadow = ${i3 ? "max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth))" : Q ? "lightingGlobalFactor * (1.0 - additionalAmbientScale)" : "0.0"};
      vec3 matColor = max(ambient, diffuse);
      ${R2.hasVertexColors ? o2`vec3 albedo = mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));` : o2`vec3 albedo = mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));
             float opacity_ = layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));`}
      ${r(K, "albedo = mix(albedo, vec3(1), 0.9);")}
      ${o2`vec3 shadingNormal = normalize(vNormalWorld);
             albedo *= 1.2;
             vec3 viewForward = vec3(view[0][2], view[1][2], view[2][2]);
             float alignmentLightView = clamp(dot(viewForward, -mainLightDirection), 0.0, 1.0);
             float transmittance = 1.0 - clamp(dot(viewForward, shadingNormal), 0.0, 1.0);
             float treeRadialFalloff = vColor.r;
             float backLightFactor = 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);
             additionalLight += backLightFactor * mainLightIntensity;`}
      ${r(X, `vec3 normalGround = ${Q ? "normalize(vpos + localOrigin)" : "vec3(0.0, 0.0, 1.0)"};`)}
      ${X ? o2`float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];
                 ${r(K, o2`mrr = vec3(0.0, 1.0, 0.04);`)}
            vec4 emission = ${K ? "vec4(0.0)" : "getEmissions()"};
            vec3 shadedColor = evaluateSceneLightingPBR(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight, viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);` : o2`vec3 shadedColor = evaluateSceneLighting(shadingNormal, albedo, shadow, 1.0 - ssao, additionalLight);`}
      vec4 finalColor = vec4(shadedColor, opacity_);
      outputColorHighlightOID(finalColor, vpos);`);
  }
  return z2.include(h, R2), z2;
}
var z = Object.freeze(Object.defineProperty({ __proto__: null, build: R }, Symbol.toStringTag, { value: "Module" }));

export {
  R,
  z
};
//# sourceMappingURL=chunk-B6M4BAW6.js.map
