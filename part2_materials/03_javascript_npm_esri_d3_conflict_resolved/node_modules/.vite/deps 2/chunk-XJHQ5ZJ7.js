import {
  t
} from "./chunk-HACIIBEF.js";
import {
  R
} from "./chunk-IJO7BOFI.js";
import {
  f,
  m,
  s as s2,
  y as y2
} from "./chunk-F26LCWNQ.js";
import {
  J,
  N,
  O as O2
} from "./chunk-H4N5QOMX.js";
import {
  l2 as l
} from "./chunk-VNRDIGVF.js";
import {
  d,
  g as g2,
  y
} from "./chunk-A3J7W53Y.js";
import {
  O2 as O,
  P2 as P,
  U,
  ee,
  g,
  s3 as s
} from "./chunk-DRBJFCLQ.js";
import {
  n
} from "./chunk-7O7KFKCG.js";
import {
  L
} from "./chunk-GRW2QIBT.js";
import {
  F
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/layers/graphics/data/projectionSupport.js
var c = [0, 0];
function h(s3, t2) {
  if (!t2) return null;
  if ("x" in t2) {
    const e = { x: 0, y: 0 };
    return [e.x, e.y] = s3(t2.x, t2.y, c), null != t2.z && (e.z = t2.z), null != t2.m && (e.m = t2.m), e;
  }
  if ("xmin" in t2) {
    const e = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 };
    return [e.xmin, e.ymin] = s3(t2.xmin, t2.ymin, c), [e.xmax, e.ymax] = s3(t2.xmax, t2.ymax, c), t2.hasZ && (e.zmin = t2.zmin, e.zmax = t2.zmax, e.hasZ = true), t2.hasM && (e.mmin = t2.mmin, e.mmax = t2.mmax, e.hasM = true), e;
  }
  return "rings" in t2 ? { rings: l2(t2.rings, s3), hasM: t2.hasM, hasZ: t2.hasZ } : "paths" in t2 ? { paths: l2(t2.paths, s3), hasM: t2.hasM, hasZ: t2.hasZ } : "points" in t2 ? { points: f2(t2.points, s3), hasM: t2.hasM, hasZ: t2.hasZ } : null;
}
function l2(s3, t2) {
  const e = [];
  for (const n2 of s3) e.push(f2(n2, t2));
  return e;
}
function f2(s3, t2) {
  const e = [];
  for (const n2 of s3) {
    const s4 = t2(n2[0], n2[1], [0, 0]);
    e.push(s4), n2.length > 2 && s4.push(n2[2]), n2.length > 3 && s4.push(n2[3]);
  }
  return e;
}
async function x(t2, n2) {
  if (!t2 || !n2) return;
  const r = Array.isArray(t2) ? t2.map((s3) => null != s3.geometry ? s3.geometry.spatialReference : null).filter(F) : [t2];
  await N(r.map((s3) => ({ source: s3, dest: n2 })));
}
var y3 = h.bind(null, y);
var g3 = h.bind(null, d);
function j(s3, t2, e, m2) {
  if (!s3) return s3;
  if (e || (e = t2, t2 = s3.spatialReference), !g(t2) || !g(e) || s(t2, e)) return s3;
  if (g2(t2, e)) {
    const t3 = O(e) ? y3(s3) : g3(s3);
    return t3.spatialReference = e, t3;
  }
  return O2(t, [s3], t2, e, null, m2)[0];
}
var _ = class {
  constructor() {
    this._jobs = [], this._timer = null, this._process = this._process.bind(this);
  }
  async push(s3, e, n2, r) {
    if (!(s3 == null ? void 0 : s3.length) || !e || !n2 || s(e, n2)) return s3;
    const i = { geometries: s3, inSpatialReference: e, outSpatialReference: n2, geographicTransformation: r, resolve: L() };
    return this._jobs.push(i), this._timer ?? (this._timer = setTimeout(this._process, 10)), i.resolve.promise;
  }
  _process() {
    this._timer = null;
    const s3 = this._jobs.shift();
    if (!s3) return;
    const { geometries: t2, inSpatialReference: e, outSpatialReference: i, resolve: o, geographicTransformation: m2 } = s3;
    g2(e, i) ? O(i) ? o(t2.map(y3)) : o(t2.map(g3)) : o(O2(t, t2, e, i, m2, null)), this._jobs.length > 0 && (this._timer = setTimeout(this._process, 10));
  }
};
var M = new _();
function b(s3, t2, e, n2) {
  return M.push(s3, t2, e, n2);
}

// node_modules/@arcgis/core/layers/graphics/data/queryUtils.js
var R2 = new n({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
var g4 = Object.freeze({});
async function S(e, t2, i) {
  const { outFields: r, orderByFields: n2, groupByFieldsForStatistics: o, outStatistics: s3 } = e;
  if (r) for (let a = 0; a < r.length; a++) r[a] = r[a].trim();
  if (n2) for (let a = 0; a < n2.length; a++) n2[a] = n2[a].trim();
  if (o) for (let a = 0; a < o.length; a++) o[a] = o[a].trim();
  if (s3) for (let a = 0; a < s3.length; a++) s3[a].onStatisticField && (s3[a].onStatisticField = s3[a].onStatisticField.trim());
  return e.geometry && !e.outSR && (e.outSR = e.geometry.spatialReference), j2(e, t2, i);
}
async function j2(e, t2, i) {
  var _a;
  if (!e) return null;
  let { where: o } = e;
  if (e.where = o = o == null ? void 0 : o.trim(), (!o || /^1 *= *1$/.test(o) || t2 && t2 === o) && (e.where = null), !e.geometry) return e;
  let s3 = await d2(e);
  if (e.distance = 0, e.units = null, "esriSpatialRelEnvelopeIntersects" === e.spatialRel) {
    const { spatialReference: t3 } = e.geometry;
    s3 = l(s3), s3.spatialReference = t3;
  }
  if (s3) {
    await x(s3.spatialReference, i), s3 = x2(s3, i);
    const t3 = (await R(f(s3)))[0];
    if (null == t3) throw g4;
    const r = "quantizationParameters" in e && ((_a = e.quantizationParameters) == null ? void 0 : _a.tolerance) || "maxAllowableOffset" in e && e.maxAllowableOffset || 0, o2 = r && w(s3, i) ? { densificationStep: 8 * r } : void 0, a = t3.toJSON(), m2 = j(a, a.spatialReference, i, o2);
    if (!m2) throw g4;
    m2.spatialReference = i, e.geometry = m2;
  }
  return e;
}
function w(e, t2) {
  if (!e) return false;
  const r = e.spatialReference;
  return (m(e) || y2(e) || s2(e)) && !s(r, t2) && !J(r, t2);
}
function x2(e, t2) {
  const i = e.spatialReference;
  return w(e, t2) && m(e) ? { spatialReference: i, rings: [[[e.xmin, e.ymin], [e.xmin, e.ymax], [e.xmax, e.ymax], [e.xmax, e.ymin], [e.xmin, e.ymin]]] } : e;
}
async function d2(e) {
  const { distance: i, units: r } = e, n2 = e.geometry;
  if (null == i || "vertexAttributes" in n2) return n2;
  const o = n2.spatialReference, s3 = r ? R2.fromJSON(r) : ee(o), a = o && (P(o) || O(o)) ? n2 : await x(o, U).then(() => j(n2, U));
  return (await U2())(a.spatialReference, a, i, s3);
}
async function U2() {
  return (await import("./geometryEngineJSON-T2WTIVKL.js")).geodesicBuffer;
}

export {
  x,
  j,
  b,
  R2 as R,
  g4 as g,
  S,
  j2
};
//# sourceMappingURL=chunk-XJHQ5ZJ7.js.map
