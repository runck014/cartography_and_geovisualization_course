import {
  h as h4,
  i as i4,
  m as m5,
  s as s3,
  x as x2
} from "./chunk-SHWUES4N.js";
import {
  T as T3,
  c as c4,
  h as h5,
  l as l8,
  w as w3,
  y as y5
} from "./chunk-3UU6HCT2.js";
import {
  C,
  D as D3,
  I as I2,
  K,
  V,
  ae,
  ee as ee2,
  ie,
  le,
  te,
  v as v2
} from "./chunk-QOUKS7KN.js";
import {
  E as E2,
  L as L2,
  N,
  U as U4,
  W as W2,
  a as a4,
  c,
  c2,
  c3,
  d as d5,
  ee,
  f2 as f6,
  g as g5,
  l as l7,
  o as o3,
  q as q2,
  t as t2,
  z as z2
} from "./chunk-7ALZJRCW.js";
import {
  a as a5,
  d as d6,
  f as f5,
  g as g3,
  h as h2,
  i as i3,
  o as o2,
  p as p3,
  w as w2
} from "./chunk-KN2F524E.js";
import {
  B2 as B,
  D2,
  F as F2,
  L,
  N as N2,
  P2 as P,
  R as R2,
  U as U3,
  _,
  g as g4,
  h as h3,
  j as j3,
  m2 as m3,
  m3 as m4,
  n2 as n3,
  n3 as n4,
  r as r3,
  r2 as r4
} from "./chunk-3YPKNKEV.js";
import {
  D,
  E,
  R,
  T as T2,
  U as U2,
  W,
  a as a3,
  f2 as f4,
  g as g2,
  l4 as l6,
  s3 as s2,
  u as u2,
  u3
} from "./chunk-OIUY22MH.js";
import "./chunk-IZK3LHO7.js";
import "./chunk-MSYZU3PB.js";
import {
  T
} from "./chunk-LWH57KCM.js";
import "./chunk-VVL7KRSE.js";
import "./chunk-M43YLXNM.js";
import "./chunk-UFFVFTYV.js";
import {
  _ as _2
} from "./chunk-AEKV7TWM.js";
import "./chunk-JUN5XSQC.js";
import "./chunk-MCZMPI2A.js";
import {
  p,
  z
} from "./chunk-5PCP47ZJ.js";
import "./chunk-IYJHGZBJ.js";
import "./chunk-IJO7BOFI.js";
import "./chunk-NGQEHRBA.js";
import {
  l as l4
} from "./chunk-5OE5J4F6.js";
import {
  l as l5
} from "./chunk-EA7CPLTC.js";
import "./chunk-SI5IJ3AZ.js";
import {
  p as p2
} from "./chunk-7ZA6GWGF.js";
import {
  e
} from "./chunk-JU4Z6UVP.js";
import "./chunk-JHXGQ3AW.js";
import "./chunk-MR727DXB.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-GNY4KZ34.js";
import "./chunk-WPERPIJF.js";
import "./chunk-R5BTSPWT.js";
import "./chunk-Z2L6EED4.js";
import "./chunk-43W2AR4R.js";
import "./chunk-X5EOLPIE.js";
import "./chunk-VNPGSD2C.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import {
  d as d4
} from "./chunk-CE7WVJQV.js";
import {
  f as f3
} from "./chunk-LCFK6PEB.js";
import "./chunk-GJTB7YCT.js";
import "./chunk-LQEYS467.js";
import "./chunk-A66MNK5C.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-RCGJPJRB.js";
import "./chunk-5CRXWQ3Y.js";
import {
  A
} from "./chunk-WH2FR6UE.js";
import {
  j as j2
} from "./chunk-F3W2DG3D.js";
import {
  l as l2
} from "./chunk-YMJZWW2N.js";
import "./chunk-7Q4JSL7R.js";
import "./chunk-VBJTBJYL.js";
import {
  t
} from "./chunk-ES2OYM5K.js";
import {
  b
} from "./chunk-JXPOROPE.js";
import {
  d as d3,
  y as y4
} from "./chunk-OPBXQTOC.js";
import "./chunk-DKMSVKV3.js";
import "./chunk-YIIXBP6I.js";
import {
  S
} from "./chunk-LN6VH2LB.js";
import "./chunk-GZFJKWTS.js";
import "./chunk-2DHZIDQK.js";
import "./chunk-SW3IBIJ7.js";
import "./chunk-E54MA7AH.js";
import "./chunk-6TU4HBID.js";
import "./chunk-LPNAPHOF.js";
import {
  y as y2
} from "./chunk-AMH7OVBF.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-LXJGKQ4D.js";
import "./chunk-VILGTHTP.js";
import {
  q
} from "./chunk-ATEWWVHG.js";
import "./chunk-LEOFRCUR.js";
import "./chunk-CP4GPQHD.js";
import "./chunk-IZSNXKMJ.js";
import "./chunk-IOKAACTA.js";
import {
  l as l3
} from "./chunk-VFTH6C2E.js";
import {
  i as i2
} from "./chunk-M5RSIRGD.js";
import "./chunk-D2JPDRZZ.js";
import {
  r as r2
} from "./chunk-UYSPJCCV.js";
import "./chunk-SMFCDOAJ.js";
import {
  f as f2
} from "./chunk-2HEBE37N.js";
import "./chunk-5A4G4OVM.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-44C2A72D.js";
import "./chunk-DIKY6MBW.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-GGCWKF4X.js";
import "./chunk-6D5XULXX.js";
import "./chunk-445IB4DS.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-SW4DFX7N.js";
import "./chunk-2PK57UYA.js";
import "./chunk-F26LCWNQ.js";
import "./chunk-H4N5QOMX.js";
import "./chunk-F2LC36UV.js";
import "./chunk-6Y2LNRVP.js";
import {
  v2 as v
} from "./chunk-VNRDIGVF.js";
import "./chunk-QRJFHPMB.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import {
  y as y3
} from "./chunk-TDZ623HP.js";
import "./chunk-6RLUKSNK.js";
import "./chunk-UN4ISSP7.js";
import "./chunk-E2RPCJOE.js";
import {
  d
} from "./chunk-TKY5RBM3.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-BMGF5ELJ.js";
import "./chunk-JU6MEO4D.js";
import "./chunk-CY5MS6DC.js";
import "./chunk-C6FFJ4QS.js";
import "./chunk-Q4Q32WYV.js";
import {
  j2 as j,
  w
} from "./chunk-A3J7W53Y.js";
import {
  o
} from "./chunk-HLF5XJSV.js";
import {
  g
} from "./chunk-L6D73M4D.js";
import {
  l
} from "./chunk-P5H5PJSC.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import "./chunk-6YWQXXBX.js";
import {
  d as d2,
  k as k2
} from "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import {
  I
} from "./chunk-QS62R4CH.js";
import {
  f
} from "./chunk-VU6O6TFT.js";
import {
  i,
  m
} from "./chunk-GD4XDYZL.js";
import {
  a4 as a,
  h,
  x
} from "./chunk-33ECLFFF.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  a as a2,
  k,
  m as m2,
  u,
  y
} from "./chunk-GRW2QIBT.js";
import {
  n as n2
} from "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F,
  has
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/rasterDatasets/BaseRaster.js
var N3 = 8;
var V2 = 256;
var U5 = 0;
var $ = class extends f {
  constructor() {
    super(...arguments), this._tileFetchQueue = new _2({ concurrency: 32, process: (e3, t5) => this._fetchRawTile(e3.pyramidLevel, e3.row, e3.col, { ...e3.options, signal: t5 }) }), this.datasetName = null, this.datasetFormat = null, this.hasUniqueSourceStorageInfo = true, this.rasterInfo = null, this.ioConfig = { sampling: "closest" };
  }
  normalizeCtorArgs(e3) {
    return (e3 == null ? void 0 : e3.ioConfig) && (e3 = { ...e3, ioConfig: { resolution: null, bandIds: null, sampling: "closest", tileInfo: z.create(), ...e3.ioConfig } }), e3;
  }
  get _isGlobalWrappableSource() {
    const { rasterInfo: e3 } = this, t5 = V(e3.spatialReference);
    return null != t5 && e3.extent.width >= t5 / 2;
  }
  get _hasNoneOrGCSShiftTransform() {
    const { transform: e3 } = this.rasterInfo;
    return null == e3 || "gcs-shift" === e3.type;
  }
  set rasterJobHandler(e3) {
    var _a, _b;
    this._set("rasterJobHandler", e3), "Function" === this.datasetFormat && ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.forEach((t5) => t5.rasterJobHandler = e3));
  }
  get rasterId() {
    return this.url || "rasterId-" + U5++;
  }
  set url(e3) {
    this._set("url", y3(e3, n.getLogger(this)));
  }
  async open(e3) {
    return this._openPromise ?? (this._openPromise = v2().then(() => this._open(e3))), this._openPromise;
  }
  async fetchTile(e3, t5, i7, o6 = {}) {
    const r7 = o6.tileInfo || this.rasterInfo.storageInfo.tileInfo, n7 = this.getTileExtentFromTileInfo(e3, t5, i7, r7);
    return o6 = { noClip: true, ...o6 }, this.fetchPixels(n7, r7.size[0], r7.size[1], o6);
  }
  async identify(e3, t5 = {}) {
    var _a;
    e3 = h(j, e3).clone().normalize();
    const { multidimensionalDefinition: i7, timeExtent: o6 } = t5, { rasterInfo: r7 } = this, { hasMultidimensionalTranspose: n7, multidimensionalInfo: s4 } = r7;
    let { transposedVariableName: a6 } = t5;
    const c7 = null != s4 && n7 && (null != o6 || h2(i7));
    if (c7 && !a6) {
      a6 = null != i7 && i7.length > 0 ? i7[0].variableName ?? void 0 : s4.variables[0].name, t5 = { ...t5, transposedVariableName: a6 };
    }
    t5 = this._getRequestOptionsWithSliceId(t5);
    const { spatialReference: f10, extent: m10 } = r7, { datumTransformation: u9 } = t5;
    let h9 = I2(e3, f10, u9);
    if (!m10.intersects(h9)) return { location: h9, value: null };
    if (null != r7.transform) {
      const e4 = r7.transform.inverseTransform(h9);
      if (!r7.nativeExtent.intersects(e4)) return { location: e4, value: null };
      h9 = e4;
    }
    let p7 = 0;
    const x4 = null != a6 && null != s4 && r7.hasMultidimensionalTranspose;
    if ("Function" === this.datasetFormat) {
      const e4 = this.primaryRasters.rasters[0];
      if (x4) return e4.identify(h9, t5);
      const { pixelSize: o7 } = r7, n8 = 3, s5 = o7.x * n8 / 2, l10 = o7.y * n8 / 2, a7 = new w({ xmin: h9.x - s5, xmax: h9.x + s5, ymin: h9.y - l10, ymax: h9.y + l10, spatialReference: f10 }), c8 = { interpolation: "nearest", multidimensionalDefinition: i7, sliceId: t5.sliceId }, { pixelBlock: m11 } = await e4.fetchPixels(a7, n8, n8, c8), { pixelBlock: u10 } = await this.fetchPixels(a7, n8, n8, c8);
      if (null == m11) return { location: h9, value: null };
      const p8 = Math.floor(n8 * n8 * 0.5), d10 = !m11.mask || m11.mask[p8] ? m11.pixels.map((e5) => e5[p8]) : null;
      let y8;
      return null != u10 && (y8 = !u10.mask || u10.mask[p8] ? u10.pixels.map((e5) => e5[p8]) : void 0), { location: h9, value: d10, processedValue: y8, pyramidLevel: 0 };
    }
    if (!x4) {
      if (t5.srcResolution) {
        p7 = le(t5.srcResolution, r7, this.ioConfig.sampling).pyramidLevel;
      } else if (p7 = await this.computeBestPyramidLevelForLocation(e3, t5), null == p7) return { location: h9, value: null };
    }
    const y7 = this.identifyPixelLocation(h9, p7, null, x4);
    if (null === y7) return { location: h9, value: null };
    const { row: g8, col: S4, rowOffset: k4, colOffset: v5, blockWidth: T4 } = y7, b3 = a6 ?? t5.sliceId, P3 = i4(this.rasterId, b3), B2 = `${p7}/${g8}/${S4}`;
    let _4 = m5(P3, null, B2);
    null == _4 && (_4 = this.fetchRawTile(p7, g8, S4, t5), x2(P3, null, B2, _4));
    const M = await _4;
    if (!((_a = M == null ? void 0 : M.pixels) == null ? void 0 : _a.length)) return { location: h9, value: null };
    const j4 = k4 * T4 + v5;
    return this._processIdentifyResult(M, { srcLocation: h9, position: j4, pyramidLevel: p7, useTransposedTile: !!x4, requestSomeSlices: c7, identifyOptions: t5 });
  }
  async fetchPixels(e3, t5, i7, o6 = {}) {
    e3 = ae(e3), o6 = this._getRequestOptionsWithSliceId(o6);
    const { _hasNoneOrGCSShiftTransform: r7 } = this;
    if (o6.requestRawData && r7) return this._fetchPixels(e3, t5, i7, o6);
    const n7 = V(e3.spatialReference), s4 = ee2(e3);
    if (null == n7 || 0 === s4 || 1 === s4 && this._isGlobalWrappableSource && r7) return this._fetchPixels(e3, t5, i7, o6);
    if (s4 >= 3) return { extent: e3, pixelBlock: null };
    const l10 = [], { xmin: a6, xmax: c7 } = e3, f10 = Math.round(n7 / (c7 - a6) * t5), m10 = f10 - Math.round((n7 / 2 - a6) / (c7 - a6) * t5);
    let u9 = 0;
    const h9 = [];
    for (let y7 = 0; y7 <= s4; y7++) {
      const r8 = new w({ xmin: 0 === y7 ? a6 : -n7 / 2, xmax: y7 === s4 ? c7 - n7 * y7 : n7 / 2, ymin: e3.ymin, ymax: e3.ymax, spatialReference: e3.spatialReference }), p8 = 0 === y7 ? f10 - m10 : y7 === s4 ? t5 - u9 : f10;
      u9 += p8, h9.push(p8);
      const d11 = o6.disableWrapAround && y7 > 0 ? null : this._fetchPixels(r8, p8, i7, o6);
      l10.push(d11);
    }
    const p7 = (await Promise.all(l10)).map((e4) => e4 == null ? void 0 : e4.pixelBlock);
    let d10 = null;
    const x4 = { width: t5, height: i7 };
    if (this.rasterJobHandler) {
      d10 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: p7, srcMosaicSize: x4, destDimension: null, coefs: null, sampleSpacing: null, interpolation: "nearest", alignmentInfo: null, blockWidths: h9 }, o6)).pixelBlock;
    } else d10 = U2(p7, x4, { blockWidths: h9 });
    return { extent: e3, srcExtent: K(e3, this.rasterInfo.spatialReference, o6.datumTransformation), pixelBlock: d10 };
  }
  async fetchRawPixels(e3, t5, i7, o6 = {}) {
    t5 = { x: Math.floor(t5.x), y: Math.floor(t5.y) };
    const r7 = await this._fetchRawTiles(e3, t5, i7, o6), { nativeExtent: n7, nativePixelSize: s4, storageInfo: l10 } = this.rasterInfo, a6 = 2 ** e3, c7 = s4.x * a6, f10 = s4.y * a6, m10 = new w({ xmin: n7.xmin + c7 * t5.x, xmax: n7.xmin + c7 * (t5.x + i7.width - 1), ymin: n7.ymax - f10 * (t5.y + i7.height - 1), ymax: n7.ymax - f10 * t5.y, spatialReference: n7.spatialReference });
    if (!r7) return { extent: m10, srcExtent: m10, pixelBlock: null };
    const { pixelBlocks: u9, mosaicSize: h9 } = r7;
    if (1 === u9.length && null != u9[0] && u9[0].width === i7.width && u9[0].height === i7.height) return { extent: m10, srcExtent: m10, pixelBlock: r7.pixelBlocks[0] };
    const p7 = e3 > 0 ? l10.pyramidBlockWidth : l10.blockWidth, d10 = e3 > 0 ? l10.pyramidBlockHeight : l10.blockHeight, x4 = { x: t5.x % p7, y: t5.y % d10 };
    let y7;
    if (this.rasterJobHandler) {
      y7 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: u9, srcMosaicSize: h9, destDimension: i7, clipOffset: x4, clipSize: i7, coefs: null, sampleSpacing: null, interpolation: o6.interpolation, alignmentInfo: null, blockWidths: null }, o6)).pixelBlock;
    } else y7 = U2(u9, h9, { clipOffset: x4, clipSize: i7 });
    return { extent: m10, srcExtent: m10, pixelBlock: y7 };
  }
  fetchRawTile(e3, t5, o6, r7) {
    throw new s("BaseRaster:read-not-implemented", "fetchRawTile() is not implemented");
  }
  computeExtent(e3) {
    return K(this.rasterInfo.extent, e3);
  }
  decodePixelBlock(e3, t5) {
    return !this.rasterJobHandler || t5.useCanvas ? j3(e3, t5) : this.rasterJobHandler.decode({ data: e3, options: t5 });
  }
  async request(e3, i7, o6 = 0) {
    const { customFetchParameters: r7 } = this.ioConfig, { range: n7, query: s4, headers: l10 } = i7;
    o6 = o6 ?? i7.retryCount ?? this.ioConfig.retryCount;
    const a6 = n7 ? { Range: `bytes=${n7.from}-${n7.to}` } : null;
    try {
      return await U(e3, { ...i7, query: { ...s4, ...r7 }, headers: { ...l10, ...a6 } });
    } catch (c7) {
      if (o6 > 0) return o6--, this.request(e3, i7, o6);
      throw c7;
    }
  }
  getSliceIndex(e3) {
    const { multidimensionalInfo: t5 } = this.rasterInfo;
    return null == t5 || null == e3 || 0 === e3.length ? null : w2(e3, t5);
  }
  getTileExtentFromTileInfo(e3, t5, i7, o6) {
    const r7 = o6.lodAt(e3);
    return this.getTileExtent({ x: r7.resolution, y: r7.resolution }, t5, i7, o6.origin, o6.spatialReference, o6.size);
  }
  updateTileInfo() {
    const { storageInfo: e3, spatialReference: t5, extent: i7, pixelSize: o6 } = this.rasterInfo, { pyramidResolutions: r7 } = e3;
    if (!e3.tileInfo) {
      const n7 = [], s4 = e3.maximumPyramidLevel || 0;
      let l10 = (o6.x + o6.y) / 2, a6 = 1 / 0.0254 * 96 * l10;
      for (let e4 = 0; e4 <= s4 && (n7.unshift(new p({ level: s4 - e4, resolution: l10, scale: a6 })), e4 !== s4); e4++) if (r7) {
        const t6 = (r7[e4].x + r7[e4].y) / 2;
        a6 *= t6 / l10, l10 = t6;
      } else l10 *= 2, a6 *= 2;
      const c7 = new j({ x: i7.xmin, y: i7.ymax, spatialReference: t5 });
      e3.tileInfo = new z({ origin: c7, size: [e3.blockWidth, e3.blockHeight], spatialReference: t5, lods: n7 }), e3.isVirtualTileInfo = true;
    }
  }
  createRemoteDatasetStorageInfo(e3, t5 = 512, i7 = 512, o6) {
    const { width: r7, height: n7, nativeExtent: s4, pixelSize: l10, spatialReference: a6 } = e3, c7 = new j({ x: s4.xmin, y: s4.ymax, spatialReference: a6 });
    null == o6 && (o6 = Math.max(0, Math.round(Math.log(Math.max(r7, n7)) / Math.LN2 - 8)));
    const f10 = this.computeBlockBoundary(s4, 512, 512, { x: s4.xmin, y: s4.ymax }, [l10], o6);
    e3.storageInfo = new n3({ blockWidth: t5, blockHeight: i7, pyramidBlockWidth: t5, pyramidBlockHeight: i7, origin: c7, firstPyramidLevel: 1, maximumPyramidLevel: o6, blockBoundary: f10 });
  }
  async computeBestPyramidLevelForLocation(e3, t5 = {}) {
    return 0;
  }
  computeBlockBoundary(e3, t5, i7, o6, r7, n7 = 0, s4 = 2) {
    if (1 === r7.length && n7 > 0) {
      r7 = [...r7];
      let { x: e4, y: t6 } = r7[0];
      for (let i8 = 0; i8 < n7; i8++) e4 *= s4, t6 *= s4, r7.push({ x: e4, y: t6 });
    }
    const l10 = [], { x: a6, y: c7 } = o6;
    for (let f10 = 0; f10 < r7.length; f10++) {
      const { x: o7, y: n8 } = r7[f10];
      l10.push({ minCol: Math.floor((e3.xmin - a6 + 0.1 * o7) / t5 / o7), maxCol: Math.floor((e3.xmax - a6 - 0.1 * o7) / t5 / o7), minRow: Math.floor((c7 - e3.ymax + 0.1 * n8) / i7 / n8), maxRow: Math.floor((c7 - e3.ymin - 0.1 * n8) / i7 / n8) });
    }
    return l10;
  }
  getPyramidPixelSize(e3) {
    const { nativePixelSize: t5 } = this.rasterInfo, { pyramidResolutions: i7, pyramidScalingFactor: o6 } = this.rasterInfo.storageInfo;
    if (0 === e3) return t5;
    if (null != i7 && i7.length) return i7[e3 - 1];
    const r7 = o6 ** e3;
    return { x: t5.x * r7, y: t5.y * r7 };
  }
  identifyPixelLocation(e3, t5, i7, o6) {
    const { spatialReference: r7, nativeExtent: n7, storageInfo: s4 } = this.rasterInfo, { maximumPyramidLevel: l10, origin: a6, transposeInfo: c7 } = s4, f10 = o6 && null != c7 ? c7.tileSize[0] : s4.blockWidth, m10 = o6 && null != c7 ? c7.tileSize[1] : s4.blockHeight, u9 = I2(e3, r7, i7);
    if (!n7.intersects(u9)) return null;
    if (t5 < 0 || t5 > l10) return null;
    const h9 = this.getPyramidPixelSize(t5), { x: p7, y: d10 } = h9, x4 = (a6.y - u9.y) / d10 / m10, y7 = (u9.x - a6.x) / p7 / f10, g8 = Math.min(m10 - 1, Math.floor((x4 - Math.floor(x4)) * m10)), I5 = Math.min(f10 - 1, Math.floor((y7 - Math.floor(y7)) * f10));
    return { pyramidLevel: t5, row: Math.floor(x4), col: Math.floor(y7), rowOffset: g8, colOffset: I5, blockWidth: f10, srcLocation: u9 };
  }
  getTileExtent(e3, t5, i7, o6, r7, n7) {
    const [s4, l10] = n7, a6 = o6.x + i7 * s4 * e3.x, c7 = a6 + s4 * e3.x, f10 = o6.y - t5 * l10 * e3.y, m10 = f10 - l10 * e3.y;
    return new w({ xmin: a6, xmax: c7, ymin: m10, ymax: f10, spatialReference: r7 });
  }
  getBlockWidthHeight(e3) {
    return { blockWidth: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockWidth : this.rasterInfo.storageInfo.blockWidth, blockHeight: e3 > 0 ? this.rasterInfo.storageInfo.pyramidBlockHeight : this.rasterInfo.storageInfo.blockHeight };
  }
  isBlockOutside(e3, t5, i7) {
    const o6 = this.rasterInfo.storageInfo.blockBoundary[e3];
    return !o6 || o6.maxRow < t5 || o6.maxCol < i7 || o6.minRow > t5 || o6.minCol > i7;
  }
  updateImageSpaceRasterInfo(e3) {
    const { pixelSize: t5 } = e3, { width: i7, height: o6 } = e3, r7 = g.WebMercator;
    e3.spatialReference = r7, e3.extent = e3.nativeExtent = new w({ xmin: -0.5, ymax: 0.5, xmax: i7 - 0.5, ymin: 0.5 - o6, spatialReference: r7 }), e3.isPseudoSpatialReference = true, e3.transform = null, e3.pixelSize = new j({ x: 1, y: 1, spatialReference: r7 });
    const { extent: n7, storageInfo: s4 } = e3;
    if (s4) {
      s4.origin = new j({ x: n7.xmin, y: n7.ymax, spatialReference: r7 });
      const { pyramidResolutions: i8, tileInfo: o7 } = s4;
      if (i8 && i8.forEach((e4) => {
        e4.x /= t5.x, e4.y /= t5.y;
      }), o7) {
        o7.origin = s4.origin;
        const t6 = (e3.nativePixelSize.x + e3.nativePixelSize.y) / 2;
        o7.lods.forEach((e4, i9) => {
          e4.resolution = t6 * 2 ** i9, e4.scale = 96 * e4.resolution / 0.0254;
        });
      }
    }
  }
  async _fetchPixels(e3, t5, i7, o6 = {}) {
    let r7 = ee2(e3);
    if (r7 >= 2) return { extent: e3, pixelBlock: null };
    const n7 = this._getSourceDataInfo(e3, t5, i7, o6), { pyramidLevel: s4, srcResolution: l10, srcExtent: a6, srcWidth: c7, srcHeight: f10, ul: m10 } = n7;
    if (0 === c7 || 0 === f10) return { extent: e3, srcExtent: a6, pixelBlock: null };
    const { rasterInfo: u9 } = this, h9 = u9.transform, p7 = "gcs-shift" === (h9 == null ? void 0 : h9.type), d10 = null != V(e3.spatialReference);
    !p7 && d10 || (r7 = ee2(n7.srcExtent, p7));
    const x4 = await this._fetchRawTiles(s4, m10, { width: c7, height: f10, wrapCount: r7 }, o6);
    if (!x4) return { extent: e3, srcExtent: a6, pixelBlock: null };
    const y7 = u9.storageInfo, g8 = s4 > 0 ? y7.pyramidBlockWidth : y7.blockWidth, I5 = s4 > 0 ? y7.pyramidBlockHeight : y7.blockHeight;
    let { x: R3, y: w5 } = u9.pixelSize;
    if (s4 > 0) {
      const { pyramidResolutions: e4, pyramidScalingFactor: t6 } = y7;
      if (null != e4 && e4[s4 - 1]) ({ x: R3, y: w5 } = e4[s4 - 1]);
      else {
        const e5 = t6 ** s4;
        R3 *= e5, w5 *= e5;
      }
    }
    const S4 = u9.spatialReference, k4 = new j({ x: R3, y: w5, spatialReference: S4 }), v5 = g8 === c7 && I5 === f10 && m10.x % g8 == 0 && m10.y % I5 == 0, T4 = new j({ x: (e3.xmax - e3.xmin) / t5, y: (e3.ymax - e3.ymin) / i7, spatialReference: e3.spatialReference }), C2 = !e3.spatialReference.equals(S4), W3 = S4.isGeographic ? 1e-9 : 1e-4, { datumTransformation: j4 } = o6;
    if (!C2 && v5 && 1 === x4.pixelBlocks.length && g8 === t5 && I5 === i7 && Q(l10, T4, W3)) return { extent: e3, srcExtent: a6, srcTilePixelSize: k4, pixelBlock: x4.pixelBlocks[0] };
    const H = d10 && null != V(a6.spatialReference) && this._hasNoneOrGCSShiftTransform, E3 = o6.requestProjectedLocalDirections && this.rasterInfo.dataType.startsWith("vector");
    E3 && !this.rasterJobHandler && await v2();
    const D5 = this.rasterJobHandler ? await this.rasterJobHandler.getProjectionOffsetGrid({ projectedExtent: e3, srcBufferExtent: x4.extent, pixelSize: T4.toJSON(), datumTransformation: j4, rasterTransform: h9, hasWrapAround: r7 > 0 || H, isAdaptive: false !== this.ioConfig.optimizeProjectionAccuracy, includeGCSGrid: E3 }, o6) : ie({ projectedExtent: e3, srcBufferExtent: x4.extent, pixelSize: T4, datumTransformation: j4, rasterTransform: h9, hasWrapAround: r7 > 0 || H, isAdaptive: false, includeGCSGrid: E3 });
    let O;
    const A2 = !o6.requestRawData, q3 = { rows: D5.spacing[0], cols: D5.spacing[1] }, J2 = this._hasNoneOrGCSShiftTransform ? this._getRasterTileAlignmentInfo(s4, x4.extent.xmin) : void 0, { pixelBlocks: N4, mosaicSize: V3, isPartiallyFilled: U6 } = x4;
    let $2 = null;
    if (this.rasterJobHandler) {
      const e4 = await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: N4, srcMosaicSize: V3, destDimension: A2 ? { width: t5, height: i7 } : null, coefs: A2 ? D5.coefficients : null, sampleSpacing: A2 ? q3 : null, projectDirections: E3, gcsGrid: E3 ? D5.gcsGrid : null, isUV: "vector-uv" === this.rasterInfo.dataType, interpolation: o6.interpolation, alignmentInfo: J2, blockWidths: null }, o6);
      ({ pixelBlock: O, localNorthDirections: $2 } = e4);
    } else {
      const e4 = U2(N4, V3, { alignmentInfo: J2 });
      O = A2 ? D(e4, { width: t5, height: i7 }, D5.coefficients, q3, o6.interpolation) : e4, E3 && D5.gcsGrid && ($2 = R({ width: t5, height: i7 }, D5.gcsGrid), O = u3(O, this.rasterInfo.dataType, $2));
    }
    return o6.requestRawData || E3 ? { extent: e3, srcExtent: a6, srcTilePixelSize: k4, pixelBlock: O, transformGrid: D5, localNorthDirections: $2, isPartiallyFilled: U6 } : { extent: e3, srcExtent: a6, srcTilePixelSize: k4, pixelBlock: O };
  }
  async _fetchRawTiles(e3, t5, i7, o6) {
    const { origin: r7, blockBoundary: n7 } = this.rasterInfo.storageInfo, { blockWidth: s4, blockHeight: l10 } = this.getBlockWidthHeight(e3);
    let { x: a6, y: c7 } = t5, { width: f10, height: m10, wrapCount: u9 } = i7;
    const h9 = this._getRasterTileAlignmentInfo(e3, 0);
    o6.buffer && (a6 -= o6.buffer.cols, c7 -= o6.buffer.rows, f10 += 2 * o6.buffer.cols, m10 += 2 * o6.buffer.rows);
    let p7 = 0, d10 = 0, x4 = 0;
    if (u9 && null != h9) {
      ({ worldColumnCountFromOrigin: d10, originColumnOffset: x4, rightPadding: p7 } = h9);
      d10 * h9.blockWidth - p7 >= a6 + f10 && (p7 = 0);
    }
    const y7 = Math.floor(a6 / s4), g8 = Math.floor(c7 / l10), I5 = Math.floor((a6 + f10 + p7 - 1) / s4), R3 = Math.floor((c7 + m10 + p7 - 1) / l10), w5 = n7[e3];
    if (!w5) return null;
    const { minRow: S4, minCol: k4, maxCol: v5, maxRow: T4 } = w5;
    if (0 === u9 && (R3 < S4 || I5 < k4 || g8 > T4 || y7 > v5)) return null;
    const b3 = new Array();
    let P3 = false;
    const B2 = null == this.ioConfig.allowPartialFill ? o6.allowPartialFill : this.ioConfig.allowPartialFill;
    for (let H = g8; H <= R3; H++) for (let t6 = y7; t6 <= I5; t6++) {
      let i8 = t6;
      if (!o6.disableWrapAround && u9 && null != h9 && d10 <= t6 && (i8 = t6 - d10 - x4), H >= S4 && i8 >= k4 && T4 >= H && v5 >= i8) {
        const t7 = this._tileFetchQueue.push({ pyramidLevel: e3, row: H, col: i8, options: o6 }, { signal: o6.signal });
        B2 ? b3.push(new Promise((e4) => {
          t7.then((t8) => e4(t8)).catch(() => {
            P3 = true, e4(null);
          });
        })) : b3.push(t7);
      } else b3.push(Promise.resolve(null));
    }
    if (0 === b3.length) return null;
    const _4 = await Promise.all(b3), M = { height: (R3 - g8 + 1) * l10, width: (I5 - y7 + 1) * s4 }, { spatialReference: C2 } = this.rasterInfo, W3 = this.getPyramidPixelSize(e3), { x: j4, y: z3 } = W3;
    return { extent: new w({ xmin: r7.x + y7 * s4 * j4, xmax: r7.x + (I5 + 1) * s4 * j4, ymin: r7.y - (R3 + 1) * l10 * z3, ymax: r7.y - g8 * l10 * z3, spatialReference: C2 }), pixelBlocks: _4, mosaicSize: M, isPartiallyFilled: P3 };
  }
  _fetchRawTile(e3, t5, i7, o6) {
    const r7 = this.rasterInfo.storageInfo.blockBoundary[e3];
    if (!r7) return Promise.resolve(null);
    const { minRow: s4, minCol: l10, maxCol: a6, maxRow: c7 } = r7;
    if (t5 < s4 || i7 < l10 || t5 > c7 || i7 > a6) return Promise.resolve(null);
    const f10 = i4(this.rasterId, o6.sliceId), m10 = `${e3}/${t5}/${i7}`;
    let u9 = m5(f10, o6.registryId, m10);
    if (null == u9) {
      const r8 = new AbortController();
      u9 = this.fetchRawTile(e3, t5, i7, { ...o6, signal: r8.signal }), x2(f10, o6.registryId, m10, u9, r8), u9.catch(() => h4(f10, o6.registryId, m10));
    }
    return o6.signal && m2(o6, () => {
      s3(f10, o6.registryId, m10);
    }), u9;
  }
  _computeMagDirValues(e3) {
    var _a;
    const { bandCount: t5, dataType: i7 } = this.rasterInfo;
    if (!(2 === t5 && "vector-magdir" === i7 || "vector-uv" === i7) || 2 !== (e3 == null ? void 0 : e3.length) || !((_a = e3[0]) == null ? void 0 : _a.length)) return null;
    const o6 = e3[0].length;
    if ("vector-magdir" === i7) {
      const t6 = e3[1].map((e4) => (e4 + 360) % 360);
      return [e3[0], t6];
    }
    const [r7, n7] = e3, s4 = [], l10 = [];
    for (let a6 = 0; a6 < o6; a6++) {
      const [e4, t6] = l6([r7[a6], n7[a6]]);
      s4.push(e4), l10.push(t6);
    }
    return [s4, l10];
  }
  _getRasterTileAlignmentInfo(e3, t5) {
    return null == this._rasterTileAlignmentInfo && (this._rasterTileAlignmentInfo = te(this.rasterInfo)), null == this._rasterTileAlignmentInfo.pyramidsInfo ? null : { startX: t5, halfWorldWidth: this._rasterTileAlignmentInfo.halfWorldWidth, hasGCSSShiftTransform: this._rasterTileAlignmentInfo.hasGCSSShiftTransform, ...this._rasterTileAlignmentInfo.pyramidsInfo[e3] };
  }
  _getSourceDataInfo(e3, t5, i7, o6 = {}) {
    const r7 = { datumTransformation: o6.datumTransformation, pyramidLevel: 0, pyramidResolution: null, srcExtent: null, srcHeight: 0, srcResolution: null, srcWidth: 0, ul: { x: 0, y: 0 } };
    o6.srcResolution && (r7.srcResolution = o6.srcResolution, this._updateSourceDataInfo(e3, r7));
    const n7 = this.rasterInfo.storageInfo.maximumPyramidLevel || 0, { srcWidth: s4, srcHeight: l10, pyramidLevel: a6 } = r7, c7 = s4 / t5, f10 = l10 / i7, m10 = a6 < n7 && c7 * f10 >= 16, u9 = a6 === n7 && this._requireTooManySrcTiles(s4, l10, t5, i7);
    if (m10 || u9 || (0 === s4 || 0 === l10)) {
      const s5 = new j({ x: (e3.xmax - e3.xmin) / t5, y: (e3.ymax - e3.ymin) / i7, spatialReference: e3.spatialReference });
      let l11 = C(s5, this.rasterInfo.spatialReference, e3, r7.datumTransformation);
      const u10 = !l11 || o6.srcResolution && l11.x + l11.y < o6.srcResolution.x + o6.srcResolution.y;
      if (m10 && o6.srcResolution && u10) {
        const e4 = Math.round(Math.log(Math.max(c7, f10)) / Math.LN2) - 1;
        if (n7 - a6 + 3 >= e4) {
          const t6 = 2 ** e4;
          l11 = { x: o6.srcResolution.x * t6, y: o6.srcResolution.y * t6 };
        }
      }
      l11 && (r7.srcResolution = l11, this._updateSourceDataInfo(e3, r7));
    }
    return this._requireTooManySrcTiles(r7.srcWidth, r7.srcHeight, t5, i7) && (r7.srcWidth = 0, r7.srcHeight = 0), r7;
  }
  _requireTooManySrcTiles(e3, t5, i7, o6) {
    const { tileInfo: r7 } = this.rasterInfo.storageInfo, n7 = Math.ceil(e3 / r7.size[0]) * Math.ceil(t5 / r7.size[1]), s4 = e3 / i7, l10 = t5 / o6, a6 = Math.max(1, (i7 + o6) / 1024);
    return n7 >= V2 * a6 || s4 > N3 || l10 > N3;
  }
  _updateSourceDataInfo(e3, t5) {
    t5.srcWidth = 0, t5.srcHeight = 0;
    const { rasterInfo: i7 } = this, o6 = i7.spatialReference, { srcResolution: r7, datumTransformation: n7 } = t5, { pyramidLevel: s4, pyramidResolution: l10, excessiveReading: a6 } = le(r7, i7, this.ioConfig.sampling);
    if (a6) return;
    let c7 = t5.srcExtent || K(e3, o6, n7);
    if (null == c7) return;
    const f10 = i7.transform;
    f10 && (c7 = f10.inverseTransform(c7)), t5.srcExtent = c7;
    const { x: m10, y: u9 } = i7.storageInfo.origin, h9 = Math.floor((c7.xmin - m10) / l10.x + 0.1), p7 = Math.floor((u9 - c7.ymax) / l10.y + 0.1), d10 = Math.floor((c7.xmax - m10) / l10.x - 0.1), x4 = Math.floor((u9 - c7.ymin) / l10.y - 0.1), y7 = c7.width < 0.1 * l10.x ? 0 : d10 - h9 + 1, g8 = c7.height < 0.1 * l10.y ? 0 : x4 - p7 + 1;
    t5.pyramidLevel = s4, t5.pyramidResolution = l10, t5.srcWidth = y7, t5.srcHeight = g8, t5.ul = { x: h9, y: p7 };
  }
  _getRequestOptionsWithSliceId(e3) {
    return null != this.rasterInfo.multidimensionalInfo && null == e3.sliceId && (e3 = { ...e3, sliceId: this.getSliceIndex(e3.multidimensionalDefinition) }), e3;
  }
  _processIdentifyResult(e3, t5) {
    const { srcLocation: i7, position: o6, pyramidLevel: r7, useTransposedTile: n7 } = t5, s4 = e3.pixels[0].length / e3.width / e3.height;
    if (!(!e3.mask || e3.mask[o6])) return { location: i7, value: null };
    const { multidimensionalInfo: l10 } = this.rasterInfo;
    if (null == l10 || !n7) {
      const t6 = e3.pixels.map((e4) => e4[o6]), n8 = { location: i7, value: t6, pyramidLevel: r7 }, s5 = this._computeMagDirValues(t6.map((e4) => [e4]));
      return (s5 == null ? void 0 : s5.length) && (n8.magdirValue = s5.map((e4) => e4[0])), n8;
    }
    let a6 = e3.pixels.map((e4) => e4.slice(o6 * s4, o6 * s4 + s4)), c7 = this._computeMagDirValues(a6);
    const { requestSomeSlices: f10, identifyOptions: u9 } = t5;
    let h9 = a5(l10, u9.transposedVariableName);
    if (f10) {
      const e4 = i3(h9, u9.multidimensionalDefinition, u9.timeExtent);
      a6 = a6.map((t6) => e4.map((e5) => t6[e5])), c7 = c7 == null ? void 0 : c7.map((t6) => e4.map((e5) => t6[e5])), h9 = e4.map((e5) => h9[e5]);
    }
    const p7 = e3.noDataValues || this.rasterInfo.noDataValue, d10 = { pixels: a6, pixelType: e3.pixelType };
    let x4;
    null != p7 && (a3(d10, p7), x4 = d10.mask);
    return { location: i7, value: null, dataSeries: h9.map((e4, t6) => {
      const i8 = { value: 0 === (x4 == null ? void 0 : x4[t6]) ? null : a6.map((e5) => e5[t6]), multidimensionalDefinition: e4.multidimensionalDefinition.map((e5) => new p3({ ...e5, isSlice: true })) };
      return (c7 == null ? void 0 : c7.length) && (i8.magdirValue = [c7[0][t6], c7[1][t6]]), i8;
    }), pyramidLevel: r7 };
  }
};
function Q(e3, t5, i7) {
  return Math.abs(e3.x - t5.x) < i7 && Math.abs(e3.y - t5.y) < i7;
}
r([m()], $.prototype, "_rasterTileAlignmentInfo", void 0), r([m()], $.prototype, "_tileFetchQueue", void 0), r([m({ readOnly: true })], $.prototype, "_isGlobalWrappableSource", null), r([m({ readOnly: true })], $.prototype, "_hasNoneOrGCSShiftTransform", null), r([m()], $.prototype, "_openPromise", void 0), r([m()], $.prototype, "rasterJobHandler", null), r([m({ readOnly: true })], $.prototype, "rasterId", null), r([m(y4)], $.prototype, "url", null), r([m({ type: String, json: { write: true } })], $.prototype, "datasetName", void 0), r([m({ type: String, json: { write: true } })], $.prototype, "datasetFormat", void 0), r([m()], $.prototype, "hasUniqueSourceStorageInfo", void 0), r([m()], $.prototype, "rasterInfo", void 0), r([m()], $.prototype, "ioConfig", void 0), r([m()], $.prototype, "sourceJSON", void 0), $ = r([a("esri.layers.support.rasterDatasets.BaseRaster")], $);
var X = $;

// node_modules/@arcgis/core/layers/support/rasterDatasets/FunctionRaster.js
var p4 = 40;
var m6 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "Function", this.tileType = "Raster", this.rasterFunction = null, this._clippingGeometry = /* @__PURE__ */ new Map();
  }
  async fetchPixels(t5, e3, r7, s4 = {}) {
    var _a, _b;
    const { rasters: i7, rasterIds: o6 } = this.primaryRasters;
    let l10 = false;
    const { interpolation: c7 } = s4, p7 = (_a = this.rasterFunction.flatWebGLFunctionChain) == null ? void 0 : _a.hasFocalFunction;
    !s4.requestRawData && p7 && (l10 = 1 === i7.length && !s4.skipRasterFunction, s4 = { ...s4, interpolation: "bilinear", requestRawData: l10 });
    const m10 = i7.map((i8) => i8.fetchPixels(t5, e3, r7, s4)), u9 = await Promise.all(m10), h9 = u9.map((t6) => t6.pixelBlock), f10 = l10 || s4.requestRawData ? u9.map((t6) => t6.srcTilePixelSize) : null;
    if (s4.skipRasterFunction || h9.every((t6) => null == t6)) return u9[0];
    const d10 = ((_b = u9.find((t6) => null != t6.pixelBlock)) == null ? void 0 : _b.extent) ?? t5;
    let y7 = this.rasterJobHandler ? await this.rasterJobHandler.process({ extent: d10, primaryPixelBlocks: h9, primaryPixelSizes: f10, primaryRasterIds: o6 }) : this.rasterFunction.process({ extent: d10, primaryPixelBlocks: h9, primaryPixelSizes: f10, primaryRasterIds: o6 });
    const { transformGrid: g8 } = u9[0];
    if (!l10 || null == y7 || null == g8) {
      const t6 = s4.noClip ? null : this.getClippingGeometry(d10.spatialReference);
      return s4.noClip || s4.requestRawData || null == y7 || !t6 || (y7 = await h5(y7, d10, t6)), { ...u9[0], pixelBlock: y7 };
    }
    const x4 = { rows: g8.spacing[0], cols: g8.spacing[1] };
    let R3;
    if (this.rasterJobHandler) {
      R3 = (await this.rasterJobHandler.mosaicAndTransform({ srcPixelBlocks: [y7], srcMosaicSize: { width: y7.width, height: y7.height }, destDimension: { width: e3, height: r7 }, coefs: g8.coefficients, sampleSpacing: x4, projectDirections: false, gcsGrid: null, isUV: false, interpolation: c7, alignmentInfo: void 0, blockWidths: null }, s4)).pixelBlock;
    } else R3 = D(y7, { width: e3, height: r7 }, g8.coefficients, x4, c7);
    const w5 = s4.noClip ? null : this.getClippingGeometry(t5.spatialReference);
    return s4.noClip || s4.requestRawData || null == R3 || null == w5 || (R3 = await h5(R3, t5, w5)), { extent: t5, srcExtent: u9[0].srcExtent, pixelBlock: R3 };
  }
  getClippingGeometry(t5) {
    const e3 = this._clippingGeometry.get("0");
    if (!t5 || !e3) return e3;
    const r7 = f7(t5);
    let s4 = this._clippingGeometry.get(r7);
    return null != s4 || (s4 = t5.equals(e3.spatialReference) ? e3 : D3(e3, t5), this._clippingGeometry.set(r7, s4)), s4;
  }
  async _open(t5) {
    var _a, _b, _c, _d;
    const { rasterFunction: r7 } = this;
    ((_b = (_a = this.primaryRasters) == null ? void 0 : _a.rasters) == null ? void 0 : _b.length) ? r7.sourceRasters = this.primaryRasters.rasters : (this.primaryRasters = r7.getPrimaryRasters(), this.rasterJobHandler && ((_c = this.primaryRasters.rasters) == null ? void 0 : _c.forEach((t6) => t6.rasterJobHandler = this.rasterJobHandler)));
    const { rasters: s4, rasterIds: i7 } = this.primaryRasters, o6 = s4.map((e3) => e3.rasterInfo ? void 0 : e3.open(t5));
    await Promise.all(o6);
    const n7 = s4.map(({ rasterInfo: t6 }) => t6), a6 = r7.bind({ rasterInfos: n7, rasterIds: i7 });
    if (r7.rawSourceRasterInfos = n7, !a6.success || 0 === n7.length) throw new s("raster-function:open", `cannot bind the function: ${a6.error ?? ""}`);
    const l10 = "Table" === r7.functionName ? r7 : (_d = r7.functionArguments) == null ? void 0 : _d.raster;
    "Table" === (l10 == null ? void 0 : l10.functionName) && (r7.rasterInfo.attributeTable = d4.fromJSON(l10.functionArguments.attributeTableAsRecordSet)), await this.syncJobHandler();
    const p7 = n7[0];
    this.hasUniqueSourceStorageInfo = 1 === n7.length || n7.slice(1).every((t6) => h6(t6, p7)), this.set("sourceJSON", s4[0].sourceJSON), this.set("rasterInfo", r7.rasterInfo), await this._updateClipGeometry();
  }
  async syncJobHandler() {
    var _a;
    return (_a = this.rasterJobHandler) == null ? void 0 : _a.updateRasterFunction(this.rasterFunction);
  }
  async _updateClipGeometry() {
    const t5 = this.rasterFunction.getClippingGeometries()[0];
    let e3 = t5 == null ? void 0 : t5.clippingGeometry;
    if (e3 && "inside" === t5.clippingType) {
      const { extent: t6 } = this.rasterInfo, { difference: r7, densify: s4 } = await import("./geometryEngine-AJ7UTRKV.js");
      let o6 = s4(v.fromExtent(t6), 2 * (t6.width + t6.height) / p4);
      o6 = D3(o6, e3.spatialReference), e3 = r7(o6, e3);
    }
    this._clippingGeometry.clear(), e3 && this._clippingGeometry.set("0", e3);
  }
};
r([m({ type: String, json: { write: true } })], m6.prototype, "datasetFormat", void 0), r([m()], m6.prototype, "tileType", void 0), r([m()], m6.prototype, "rasterFunction", void 0), r([m()], m6.prototype, "primaryRasters", void 0), m6 = r([a("esri.layers.support.rasterDatasets.FunctionRaster")], m6);
var u4 = m6;
function h6(t5, e3) {
  const { storageInfo: r7, pixelSize: s4, spatialReference: i7, extent: o6 } = t5, { storageInfo: n7, pixelSize: a6, spatialReference: l10, extent: c7 } = e3;
  return s4.x === a6.x && s4.y === a6.y && i7.equals(l10) && o6.equals(c7) && r7.blockHeight === n7.blockHeight && r7.blockWidth === n7.blockWidth && r7.maximumPyramidLevel === n7.maximumPyramidLevel;
}
function f7(t5) {
  return String(t5.wkid ?? t5.wkt ?? t5.wkt2);
}

// node_modules/@arcgis/core/layers/mixins/ImageryTileMixin.js
var K2 = (K3) => {
  let Q2 = class extends K3 {
    constructor(...e3) {
      var _a, _b;
      super(...e3), this._isConstructedFromFunctionRaster = false, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this.bandIds = null, this.copyright = null, this.interpolation = null, this.multidimensionalSubset = null, this.raster = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.spatialReference = null, this.symbolizer = null, this._isConstructedFromFunctionRaster = "Function" === ((_b = (_a = e3[0]) == null ? void 0 : _a.raster) == null ? void 0 : _b.datasetFormat);
    }
    get fullExtent() {
      var _a;
      return (_a = this.serviceRasterInfo) == null ? void 0 : _a.extent;
    }
    set multidimensionalDefinition(e3) {
      this._set("multidimensionalDefinition", e3), this.updateRenderer();
    }
    set rasterFunction(e3) {
      var _a;
      "none" === ((_a = e3 == null ? void 0 : e3.functionName) == null ? void 0 : _a.toLowerCase()) && (e3 = void 0), this._set("rasterFunction", e3), this.updateRasterFunction();
    }
    get rasterInfo() {
      return i(n.getLogger(this), "rasterInfo", { replacement: "serviceRasterInfo", version: "4.29", warnOnce: true }), this._get("serviceRasterInfo");
    }
    set url(e3) {
      this._set("url", y3(e3, n.getLogger(this)));
    }
    get renderer() {
      if ("imagery-tile" !== this.type) return this.internalRenderer;
      const { activePresetRendererName: e3, presetRenderers: t5 } = this;
      if (e3) {
        const r7 = t5 == null ? void 0 : t5.find(({ name: t6 }) => t6 === e3);
        return r7 == null ? void 0 : r7.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e3) {
      "imagery-tile" === this.type && (this.activePresetRendererName = null), this.internalRenderer = e3;
    }
    set internalRenderer(e3) {
      null == e3 && null == this.rasterFunction ? this._configDefaultRenderer("override") : (this._set("internalRenderer", e3), this.updateRenderer());
    }
    readRenderer(e3, t5, r7) {
      var _a, _b;
      const n7 = (_b = (_a = t5 == null ? void 0 : t5.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer;
      return c(n7, r7) || void 0;
    }
    async convertVectorFieldData(e3, t5) {
      const { serviceRasterInfo: r7 } = this;
      if (null == e3 || !r7) return null;
      const i7 = this._rasterJobHandler.instance, n7 = r7.dataType;
      return i7 ? i7.convertVectorFieldData({ pixelBlock: e3, dataType: n7 }, t5) : f4(e3, n7);
    }
    async computeStatisticsHistograms(e3, t5) {
      await this.load(t5), e3 = h(g5, e3).clone();
      const { serviceRasterInfo: r7 } = this;
      if (null == r7) throw new s("imagery-tile-mixin:compute-statistics-histograms", "serviceRasterInfo must be specified");
      const { geometry: i7 } = e3;
      if (null == i7) throw new s("imagery-tile-mixin:compute-statistics-histograms", "geometry must be specified");
      let n7 = i7;
      const { spatialReference: s4 } = r7;
      i7.spatialReference.equals(s4) || (await v2(), n7 = "extent" === i7.type ? K(i7, s4) : D3(i7, s4));
      const a6 = e3.pixelSize ?? new j({ x: r7.pixelSize.x, y: r7.pixelSize.y, spatialReference: s4 }), { extent: l10, width: u9, height: d10 } = l8(r7, n7, a6), m10 = await this.fetchPixels(l10, u9, d10, { ...t5, interpolation: "nearest" });
      if (null == m10.pixelBlock) throw new s("imagery-tile-mixin:compute-statistics-histograms", "failed to fetch pixels");
      const h9 = await h5(m10.pixelBlock, l10, n7), p7 = this._rasterJobHandler.instance;
      return p7 ? p7.computeStatisticsHistograms({ pixelBlock: h9 }, t5) : m4(h9);
    }
    async createFlowMesh(e3, t5) {
      const r7 = this._rasterJobHandler.instance;
      return r7 ? r7.createFlowMesh(e3, t5) : s2(e3.meshType, e3.simulationSettings, e3.flowData, null != t5.signal ? t5.signal : new AbortController().signal);
    }
    normalizeRasterFetchOptions(e3) {
      var _a, _b;
      const { multidimensionalInfo: t5 } = this.serviceRasterInfo ?? {};
      if (null == t5) return e3;
      let r7 = e3.multidimensionalDefinition || this.multidimensionalDefinition;
      (r7 == null ? void 0 : r7.length) || (r7 = d6(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset }));
      const i7 = e3.timeExtent || this.timeExtent;
      if (null != r7 && null != i7 && (null != i7.start || null != i7.end)) {
        r7 = r7.map((e4) => e4.clone());
        const n7 = (_b = (_a = t5.variables.find(({ name: e4 }) => e4 === r7[0].variableName)) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find(({ name: e4 }) => "StdTime" === e4), s4 = r7.find(({ dimensionName: e4 }) => "StdTime" === e4);
        if (!n7 || !s4) return { ...e3, multidimensionalDefinition: null };
        const { start: o6, end: a6 } = i7, l10 = null == o6 ? null : o6.getTime(), u9 = null == a6 ? null : a6.getTime(), c7 = l10 ?? u9, d10 = u9 ?? l10;
        if (null != n7.values) {
          const e4 = n7.values.filter((e5) => {
            if (Array.isArray(e5)) {
              if (c7 === d10) return e5[0] <= c7 && e5[1] >= c7;
              const t6 = e5[0] <= c7 && e5[1] > c7 || e5[0] < d10 && e5[1] >= d10, r8 = e5[0] >= c7 && e5[1] <= d10 || e5[0] < c7 && e5[1] > d10;
              return t6 || r8;
            }
            return c7 === d10 ? e5 === c7 : e5 >= c7 && e5 <= d10;
          });
          if (e4.length) {
            const t6 = e4.sort((e5, t7) => {
              const r8 = Array.isArray(e5) ? e5[0] : e5, i8 = Array.isArray(e5) ? e5[1] : e5, n8 = Array.isArray(t7) ? t7[0] : t7, s5 = Array.isArray(t7) ? t7[1] : t7;
              if (c7 === d10) return r8 - n8;
              return Math.abs(i8 - d10) - Math.abs(s5 - d10);
            })[0];
            s4.values = [t6];
          } else r7 = null;
        } else if (n7.hasRegularIntervals && n7.extent) {
          const [e4, t6] = n7.extent;
          c7 > t6 || d10 < e4 ? r7 = null : s4.values = c7 === d10 ? [c7] : [Math.max(e4, c7), Math.min(t6, d10)];
        }
      }
      return null != r7 && o2(r7, this.multidimensionalSubset) ? { ...e3, multidimensionalDefinition: null } : { ...e3, multidimensionalDefinition: r7 };
    }
    async updateRasterFunction() {
      var _a, _b, _c;
      if (!this.loaded || "imagery-tile" !== this.type || !this.rasterFunction && !this._cachedRasterFunctionJson || JSON.stringify(this.rasterFunction) === JSON.stringify(this._cachedRasterFunctionJson)) return;
      if (this._isConstructedFromFunctionRaster && "Function" === this.raster.datasetFormat) {
        const e4 = this.raster.rasterFunction.toJSON();
        return !this.rasterFunction && e4 && this._set("rasterFunction", N.fromJSON(e4)), void (this._cachedRasterFunctionJson = (_a = this.rasterFunction) == null ? void 0 : _a.toJSON());
      }
      let e3, t5 = this.raster, r7 = false;
      "Function" === t5.datasetFormat ? (e3 = t5.primaryRasters.rasters, t5 = e3[0], r7 = true) : e3 = [t5];
      const { rasterFunction: i7 } = this;
      if (i7) {
        const r8 = { raster: t5 };
        e3.length > 1 && e3.forEach((e4) => r8[e4.url] = e4);
        const n8 = T3(((_b = i7.functionDefinition) == null ? void 0 : _b.toJSON()) ?? i7.toJSON(), r8), s5 = new u4({ rasterFunction: n8 });
        s5.rasterJobHandler = this._rasterJobHandler.instance, await s5.open(), this._cachedRasterFunctionJson = (_c = this.rasterFunction) == null ? void 0 : _c.toJSON(), this.raster = s5;
      } else this.raster = t5, this._cachedRasterFunctionJson = null, await t5.open();
      if (this._cachedRendererJson = null, !r7 && !i7) return;
      const { bandIds: n7 } = this, { bandCount: s4 } = this.raster.rasterInfo, o6 = (n7 == null ? void 0 : n7.length) ? n7.some((e4) => e4 >= s4) : s4 >= 3;
      n7 && (o6 || this.renderer && "raster-stretch" !== this.renderer.type) && this._set("bandIds", null), this._configDefaultRenderer("auto");
    }
    async updateRenderer() {
      const { loaded: e3, symbolizer: t5 } = this;
      if (!e3 || !t5 || !this.renderer) return;
      const { rasterInfo: r7 } = this.raster, i7 = f5(r7, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), n7 = i7 == null ? void 0 : i7.name, s4 = ee({ ...this.renderer.toJSON(), variableName: n7 });
      if (JSON.stringify(this._cachedRendererJson) === JSON.stringify(s4)) return;
      const o6 = this._rasterJobHandler.instance;
      o6 && (t5.rasterInfo = W2(r7, n7), t5.rendererJSON = s4, t5.bind(), await o6.updateSymbolizer(t5), this._cachedRendererJson = s4);
    }
    async applyRenderer(e3, t5) {
      const r7 = e3 == null ? void 0 : e3.pixelBlock;
      if (!(null != r7 && r7.pixels && r7.pixels.length > 0)) return null;
      let i7;
      await this.updateRenderer();
      const n7 = this._rasterJobHandler.instance, s4 = this.bandIds ?? [];
      return i7 = n7 ? await n7.symbolize({ ...e3, simpleStretchParams: t5, bandIds: s4 }) : this.symbolizer.symbolize({ ...e3, simpleStretchParams: t5, bandIds: s4 }), i7;
    }
    getTileUrl(e3, t5, r7) {
      return "RasterTileServer" === this.raster.datasetFormat ? `${this.url}/tile/${e3}/${t5}/${r7}` : "";
    }
    getCompatibleTileInfo(e3, t5, r7 = false) {
      if (!this.loaded || null == t5) return null;
      if (r7 && e3.equals(this.spatialReference)) return this.tileInfo;
      const i7 = d2(e3);
      return z.create({ size: 256, spatialReference: e3, origin: i7 ? { x: i7.origin[0], y: i7.origin[1] } : { x: t5.xmin, y: t5.ymax } });
    }
    getCompatibleFullExtent(e3) {
      var _a;
      return this.loaded ? (((_a = this._compatibleFullExtent) == null ? void 0 : _a.spatialReference.equals(e3)) || (this._compatibleFullExtent = this.raster.computeExtent(e3)), this._compatibleFullExtent) : null;
    }
    async fetchTile(e3, t5, r7, i7 = {}) {
      var _a;
      if (X2(this), i7.requestAsImageElement) {
        const s5 = this.getTileUrl(e3, t5, r7);
        return U(s5, { responseType: "image", query: { ...this.refreshParameters, ...this.raster.ioConfig.customFetchParameters }, signal: i7.signal }).then((e4) => e4.data);
      }
      const { serviceRasterInfo: s4 } = this;
      if (null != s4.multidimensionalInfo && null == (i7 = this.normalizeRasterFetchOptions(i7)).multidimensionalDefinition) {
        const n7 = i7.tileInfo || s4.storageInfo.tileInfo;
        return { extent: this.raster.getTileExtentFromTileInfo(e3, t5, r7, n7), pixelBlock: null };
      }
      return await this._initJobHandler(), await this.updateRasterFunction(), "raster-shaded-relief" === ((_a = this.renderer) == null ? void 0 : _a.type) && (i7 = { ...i7, buffer: { cols: 1, rows: 1 } }), this.raster.fetchTile(e3, t5, r7, i7);
    }
    async fetchPixels(e3, t5, r7, i7 = {}) {
      return null != this.serviceRasterInfo.multidimensionalInfo && null == (i7 = this.normalizeRasterFetchOptions(i7)).multidimensionalDefinition ? { extent: e3, pixelBlock: null } : (await this._initJobHandler(), await this.updateRasterFunction(), t5 = Math.round(t5), r7 = Math.round(r7), this.raster.fetchPixels(e3, t5, r7, i7));
    }
    async identify(e3, t5 = {}) {
      var _a;
      await this.load();
      const { raster: r7, serviceRasterInfo: i7 } = this;
      if (null != (i7 == null ? void 0 : i7.multidimensionalInfo)) {
        if (!(i7.hasMultidimensionalTranspose && !!(h2(t5.multidimensionalDefinition) || t5.transposedVariableName || t5.timeExtent)) && null == (t5 = this.normalizeRasterFetchOptions(t5)).multidimensionalDefinition) return { location: e3, value: null };
      }
      const n7 = (_a = this.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
      if (n7 && !n7.contains(e3)) throw new s("imagery-tile-mixin:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      return r7.identify(e3, t5);
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    hasStandardTime() {
      var _a, _b, _c;
      const e3 = (_a = this.serviceRasterInfo) == null ? void 0 : _a.multidimensionalInfo;
      if (null == e3 || "standard-time" !== ((_b = this.serviceRasterInfo) == null ? void 0 : _b.dataType)) return false;
      const t5 = this.multidimensionalDefinition, r7 = (_c = t5 == null ? void 0 : t5[0]) == null ? void 0 : _c.variableName;
      return e3.variables.some((e4) => e4.name === r7 && (!(t5 == null ? void 0 : t5[0].dimensionName) || e4.dimensions.some((e5) => "StdTime" === e5.name)));
    }
    getStandardTimeValue(e3) {
      return new Date(24 * (e3 - 25569) * 3600 * 1e3).toString();
    }
    getMultidimensionalSubsetVariables(e3) {
      var _a;
      const t5 = e3 ?? ((_a = this.serviceRasterInfo) == null ? void 0 : _a.multidimensionalInfo);
      return g3(this.multidimensionalSubset, t5);
    }
    _configDefaultSettings() {
      this._configDefaultInterpolation(), this.multidimensionalDefinition || (this.multidimensionalDefinition = d6(this.raster.rasterInfo, { multidimensionalSubset: this.multidimensionalSubset })), this.rasterFunction && "Function" === this.raster.datasetFormat && (this._cachedRasterFunctionJson = this.rasterFunction.toJSON()), this._configDefaultRenderer();
    }
    _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise) return this._rasterJobHandler.connectionPromise;
      const e3 = new t2();
      return this._rasterJobHandler.connectionPromise = e3.initialize().then(async () => {
        X2(this), this._rasterJobHandler.instance = e3, this.raster.rasterJobHandler = e3, "Function" === this.raster.datasetFormat && this.raster.syncJobHandler(), this.rasterFunction && await this.updateRasterFunction().catch(() => {
        }), this.renderer && this.updateRenderer();
      }).catch(() => {
      }), this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null, this.raster && (this.raster.rasterJobHandler = null);
    }
    _configDefaultInterpolation() {
      var _a;
      if (null == this.interpolation) {
        X2(this);
        const { raster: e3 } = this, t5 = z2(e3.rasterInfo, e3.tileType, (_a = this.sourceJSON) == null ? void 0 : _a.defaultResamplingMethod);
        this._set("interpolation", t5);
      }
    }
    _configDefaultRenderer(e3 = "no") {
      var _a, _b, _c;
      X2(this);
      const { rasterInfo: t5 } = this.raster, r7 = f5(t5, { multidimensionalDefinition: this.multidimensionalDefinition, multidimensionalSubset: this.multidimensionalSubset }), i7 = r7 == null ? void 0 : r7.name, n7 = L2({ variableName: i7, rasterFunctionName: (_a = this.rasterFunction) == null ? void 0 : _a.functionName, presetRenderers: this.presetRenderers });
      if (!this.bandIds && t5.bandCount > 1 && (this.bandIds = (n7 == null ? void 0 : n7.bandIds) ?? U4(t5)), !this.renderer || "override" === e3) {
        const e4 = E2(this.raster), r8 = (n7 == null ? void 0 : n7.renderer) ?? q2(t5, { bandIds: this.bandIds, variableName: i7, rasterFunctionColorRamp: e4 }), s5 = t5.statistics, o7 = s5 && s5.length > 0 ? s5[0] : null, a6 = (o7 == null ? void 0 : o7.max) ?? 0, l11 = (o7 == null ? void 0 : o7.min) ?? 0;
        "WCSServer" === this.raster.datasetFormat && "raster-stretch" === r8.type && (a6 > 1e24 || l11 < -1e24) && (r8.dynamicRangeAdjustment = true, r8.customStatistics = null, "none" === r8.stretchType && (r8.stretchType = "min-max")), this.renderer = r8;
      }
      const s4 = ee({ ...this.renderer.toJSON(), variableName: i7 }), o6 = W2(t5, i7);
      this.symbolizer ? (this.symbolizer.rendererJSON = s4, this.symbolizer.rasterInfo = o6) : this.symbolizer = new _({ rendererJSON: s4, rasterInfo: o6 });
      const l10 = this.symbolizer.bind();
      if (l10.success) {
        if ("auto" === e3) {
          const { colormap: e4 } = this.raster.rasterInfo, t6 = this.renderer;
          if (null != e4 && "raster-colormap" === t6.type) {
            const e5 = q2(this.raster.rasterInfo);
            JSON.stringify(e5) !== JSON.stringify(t6) && this._configDefaultRenderer("override");
          } else if ("raster-stretch" === t6.type) {
            const e5 = (_b = this.bandIds) == null ? void 0 : _b.length, r8 = (_c = t6.customStatistics) == null ? void 0 : _c.length;
            !t6.dynamicRangeAdjustment && r8 && e5 && r8 !== e5 && this._configDefaultRenderer("override");
          }
        }
      } else n.getLogger(this).warn("imagery-tile-mixin", l10.error || "The given renderer is not supported by the layer."), "auto" === e3 && this._configDefaultRenderer("override");
    }
  };
  function X2(e3) {
    if (!e3.raster || !e3.serviceRasterInfo) throw new s("imagery-tile", "no raster");
  }
  return r([m({ clonable: false })], Q2.prototype, "_cachedRendererJson", void 0), r([m({ clonable: false })], Q2.prototype, "_cachedRasterFunctionJson", void 0), r([m({ clonable: false })], Q2.prototype, "_compatibleFullExtent", void 0), r([m({ clonable: false })], Q2.prototype, "_isConstructedFromFunctionRaster", void 0), r([m({ clonable: false })], Q2.prototype, "_rasterJobHandler", void 0), r([m({ type: [x], json: { write: { overridePolicy() {
    var _a;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || "0,1,2" !== ((_a = this.bandIds) == null ? void 0 : _a.join(",")) };
  } } } })], Q2.prototype, "bandIds", void 0), r([m({ json: { origins: { service: { read: { source: "copyrightText" } } } } })], Q2.prototype, "copyright", void 0), r([m({ json: { read: false } })], Q2.prototype, "fullExtent", null), r([m({ json: { write: { overridePolicy() {
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || "bilinear" !== this.interpolation };
  } } } }), r2(a4)], Q2.prototype, "interpolation", void 0), r([m()], Q2.prototype, "ioConfig", void 0), r([m({ type: [p3], json: { write: true } })], Q2.prototype, "multidimensionalDefinition", null), r([m({ type: c2, json: { write: true } })], Q2.prototype, "multidimensionalSubset", void 0), r([m()], Q2.prototype, "raster", void 0), r([m({ type: N, json: { name: "renderingRule", write: true } })], Q2.prototype, "rasterFunction", null), r([m({ readOnly: true })], Q2.prototype, "rasterInfo", null), r([m()], Q2.prototype, "serviceRasterInfo", void 0), r([m()], Q2.prototype, "sourceJSON", void 0), r([m({ readOnly: true, type: g, json: { read: false } })], Q2.prototype, "spatialReference", void 0), r([m({ type: z })], Q2.prototype, "tileInfo", void 0), r([m(y4)], Q2.prototype, "url", null), r([m()], Q2.prototype, "renderer", null), r([m({ types: l7, json: { name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy() {
    var _a;
    const e3 = "raster-stretch" === ((_a = this.renderer) == null ? void 0 : _a.type) && "none" === this.renderer.stretchType && !this.renderer.useGamma;
    return { enabled: !this.loaded || "Raster" === this.raster.tileType || !e3 };
  } }, origins: { "web-scene": { types: d5, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e3) => ({ enabled: e3 && "vector-field" !== e3.type && "flow" !== e3.type }) } } } } })], Q2.prototype, "internalRenderer", null), r([o("internalRenderer")], Q2.prototype, "readRenderer", null), r([m({ clonable: false })], Q2.prototype, "symbolizer", void 0), Q2 = r([a("esri.layers.mixins.ImageryTileMixin")], Q2), Q2;
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/covJSONParser.js
function i5(e3) {
  return ["x", "e", "east", "long", "longitude"].includes(e3.toLowerCase());
}
function r5(e3) {
  return ["y", "n", "west", "lat", "latitude"].includes(e3.toLowerCase());
}
function o4(e3) {
  const { axes: n7 } = e3.domain, l10 = Object.keys(n7), s4 = [], o6 = [];
  let u9 = -1, m10 = -1, c7 = [];
  for (let t5 = 0; t5 < l10.length; t5++) {
    const e4 = l10[t5];
    i5(e4) ? u9 = t5 : r5(e4) && (m10 = t5);
    const a6 = n7[e4], d11 = [];
    if ("values" in a6) {
      a6.values.forEach((e6) => d11.push("string" == typeof e6 ? new Date(e6).getTime() : e6));
      const e5 = d11[1] - d11[0];
      s4.push([d11[0] - 0.5 * e5, d11[d11.length - 1] + 0.5 * e5]), o6.push(e5);
    } else {
      const { start: e5, stop: t6, num: n8 } = a6, l11 = (t6 - e5) / (n8 - 1);
      s4.push([e5 - 0.5 * l11, t6 + 0.5 * l11]), o6.push(l11);
      for (let s5 = 0; s5 < n8; s5++) d11.push(e5 + l11 * s5);
    }
    c7.push({ name: e4, values: d11, extent: [d11[0], d11[d11.length - 1]] });
  }
  u9 > -1 && -1 === m10 ? m10 = 0 === u9 ? 1 : 0 : m10 > -1 && -1 === u9 ? u9 = 0 === m10 ? 1 : 0 : -1 === m10 && -1 === u9 && (u9 = 0, m10 = 1), c7 = c7.filter((e4, t5) => !(t5 === u9 || t5 === m10));
  const { referencing: d10 } = e3.domain, f10 = d10.find((e4) => e4.coordinates.includes(l10[u9])).system.id, p7 = f10 == null ? void 0 : f10.slice(f10.lastIndexOf("/") + 1), h9 = null == p7 || "CRS84" === p7 ? 4326 : Number(p7), g8 = new g({ wkid: h9 }), [b3, y7] = s4[u9], [x4, j4] = s4[m10], v5 = new w({ xmin: b3, xmax: y7, ymin: x4, ymax: j4, spatialReference: g8 });
  return { width: Math.round(v5.width / o6[u9]), height: Math.round(v5.height / o6[m10]), extent: v5, dimensions: c7 };
}
function u5(e3) {
  const t5 = l();
  return t5 ? e3[t5] ?? Object.values(e3)[0] : Object.values(e3)[0];
}
function m7() {
  return Math.round(255 * Math.random());
}
function c5(t5) {
  var _a, _b;
  const n7 = {}, { parameters: l10 } = t5;
  if (!l10) return n7;
  for (const [s4, a6] of Object.entries(l10)) {
    const { type: t6, description: l11, unit: i7, categoryEncoding: r7, observedProperty: o6 } = a6;
    if ("Parameter" === t6 && (n7[s4] = {}, l11 && (n7[s4].description = u5(l11)), i7 && (n7[s4].unit = i7.label ? u5(i7.label) : null, n7[s4].symbol = (_a = i7.symbol) == null ? void 0 : _a.value), r7)) {
      const t7 = Object.entries(r7).map((e3, t8) => ({ OID: t8, Value: Number(e3[1]), ClassName: e3[0].slice(e3[0].lastIndexOf("/") + 1), Count: 1 }));
      let l12 = false;
      ((_b = o6 == null ? void 0 : o6.categories) == null ? void 0 : _b.length) && (o6.categories.forEach((n8) => {
        if (!n8.id) return;
        const s5 = n8.id.slice(n8.id.lastIndexOf("/") + 1), a8 = t7.find((e3) => e3.ClassName === s5);
        if (!a8) return;
        const i8 = n8.label ? u5(n8.label) : null;
        if (a8.Label = i8, n8.preferredColor) {
          const t8 = l3.fromHex(n8.preferredColor);
          t8 && (l12 = true, a8.Red = t8.r, a8.Green = t8.g, a8.Blue = t8.b);
        }
      }), l12 && t7.forEach((e3) => {
        null == e3.Red && (e3.Red = m7(), e3.Green = m7(), e3.Blue = m7());
      }));
      const a7 = { objectIdFieldName: "", fields: [{ name: "OID", type: "esriFieldTypeOID", alias: "OID", domain: null }, { name: "Value", type: "esriFieldTypeInteger", alias: "Value", domain: null }, { name: "Count", type: "esriFieldTypeDouble", alias: "Count", domain: null }, { name: "ClassName", type: "esriFieldTypeString", alias: "ClassName", domain: null, length: 50 }, { name: "Label", type: "esriFieldTypeString", alias: "Label", domain: null, length: 50 }], features: t7.map((e3) => ({ attributes: e3 })) };
      l12 && a7.fields.push({ name: "Red", type: "esriFieldTypeInteger", alias: "Red", domain: null }, { name: "Green", type: "esriFieldTypeInteger", alias: "Green", domain: null }, { name: "Blue", type: "esriFieldTypeInteger", alias: "Blue", domain: null }), n7[s4].attributeTable = a7;
    }
  }
  return n7;
}
function d7(e3) {
  let t5 = Number.MAX_VALUE, n7 = -Number.MAX_VALUE;
  for (let l10 = 0; l10 < e3.length; l10++) {
    const s4 = e3[l10];
    null != s4 && (s4 < t5 && (t5 = s4), s4 > n7 && (n7 = s4));
  }
  return u2(t5, n7);
}
function f8(e3, t5, n7) {
  const l10 = e3.map((e4, n8) => ({ name: e4, count: t5[n8] })).sort((e4, t6) => e4.name > t6.name ? -1 : 1), s4 = (a6 = 1, (e4) => a6 *= e4.count);
  var a6;
  const i7 = [...l10.slice(1), { name: "", count: 1 }].reverse().map(s4).reverse();
  let r7 = 0;
  for (let o6 = e3.length - 1; o6 >= 0; o6--) {
    r7 += i7[l10.findIndex(({ name: t6 }) => t6 === e3[o6])] * (n7 % t5[o6]), n7 = Math.floor(n7 / t5[o6]);
  }
  return r7;
}
function p5(e3) {
  var _a;
  const { width: t5, height: n7, extent: s4, dimensions: a6 } = o4(e3), { ranges: i7 } = e3, r7 = Object.keys(i7).sort((e4, t6) => e4 < t6 ? -1 : 1), u9 = [];
  for (let l10 = 0; l10 < r7.length; l10++) {
    const e4 = r7[l10];
    (a6 == null ? void 0 : a6.length) && u9.push({ name: e4, dimensions: a6 });
  }
  const m10 = c5(e3);
  u9.forEach((e4) => m10[e4.name] && Object.assign(e4, m10[e4.name]));
  const p7 = u9.length ? { variables: u9 } : void 0, h9 = [];
  for (let o6 = 0; o6 < r7.length; o6++) {
    const e4 = r7[o6], { values: s5, dataType: u10, axisNames: m11, shape: c7 } = i7[e4], p8 = c7.length > 2 ? o6 * c7.slice(0, -2).reduce((e5, t6) => e5 * t6) : 0, g9 = m11.slice(0, -2), b3 = c7.slice(0, -2), y7 = "float" === u10 ? "f32" : d7(s5), x4 = t5 * n7, j4 = s5.length / x4;
    for (let i8 = 0; i8 < j4; i8++) {
      const e5 = g2.createEmptyBand(y7, x4), r8 = new Uint8Array(x4).fill(255);
      let u11 = false;
      const m12 = i8 * x4;
      for (let t6 = 0; t6 < x4; t6++) {
        const n8 = s5[m12 + t6];
        null == n8 ? (r8[t6] = 0, u11 = true) : e5[t6] = n8;
      }
      if (0 === o6 || (a6 == null ? void 0 : a6.length)) {
        const s6 = new g2({ width: t5, height: n7, mask: u11 ? r8 : null, pixels: [e5], pixelType: y7 });
        if (s6.updateStatistics(), a6 == null ? void 0 : a6.length) {
          h9[f8(g9, b3, i8) + p8] = s6;
        } else h9.push(s6);
      } else {
        const t6 = h9[i8];
        t6.pixels.push(e5), u11 ? t6.mask && (t6.mask = g2.combineBandMasks([t6.mask, r8])) : t6.mask = u11 ? r8 : null;
      }
    }
  }
  const g8 = (_a = Object.values(m10).find((e4) => e4.attributeTable)) == null ? void 0 : _a.attributeTable;
  return { extent: s4, pixelBlocks: h9, multidimensionalInfo: p7, attributeTable: g8, bandNames: p7 ? void 0 : r7 };
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/InMemoryRaster.js
var f9 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "MEMORY", this.source = null;
  }
  get url() {
    return "";
  }
  fetchRawTile(t5, e3, s4, i7 = {}) {
    if (!this._pixelBlockTiles) {
      const { rasterInfo: r8 } = this, [o6, a6] = r8.storageInfo.tileInfo.size, { sliceId: l10 } = i7, { pixelBlocks: n7 } = this.source, c7 = { pixelBlock: null == l10 ? n7[0] : n7[l10], useBilinear: "thematic" !== r8.dataType, tileSize: { width: o6, height: a6 }, level: t5, row: e3, col: s4 }, p7 = this.rasterJobHandler ? this.rasterJobHandler.clipTile(c7, i7) : E(c7);
      return Promise.resolve(p7);
    }
    const r7 = this._pixelBlockTiles.get(`${t5}/${e3}/${s4}`);
    return Promise.resolve(r7);
  }
  async _open(t5) {
    const e3 = this.source, { pixelBlocks: s4, attributeTable: i7, statistics: r7, histograms: o6, name: l10, nativeExtent: n7, transform: m10 } = e3, c7 = s4[0], { width: p7, height: u9, pixelType: f10 } = c7, g8 = e3.extent ?? new w({ xmin: -0.5, ymin: 0.5, xmax: p7 - 0.5, ymax: u9 - 0.5, spatialReference: new g({ wkid: 3857 }) }), x4 = e3.isPseudoSpatialReference ?? !e3.extent, y7 = { x: g8.width / p7, y: g8.height / u9 }, b3 = { ...e3.keyProperties };
    i7 && (b3.DataType = "Thematic");
    const v5 = new m3({ width: p7, height: u9, pixelType: f10, extent: g8, nativeExtent: n7, attributeTable: i7, transform: m10, pixelSize: y7, spatialReference: g8.spatialReference, bandCount: c7.pixels.length, keyProperties: b3, multidimensionalInfo: e3.multidimensionalInfo, statistics: r7, isPseudoSpatialReference: x4, histograms: o6 });
    this.ioConfig.skipMapInfo && this.updateImageSpaceRasterInfo(v5), this.createRemoteDatasetStorageInfo(v5, 512, 512), this._set("rasterInfo", v5), this.updateTileInfo(), v5.multidimensionalInfo ? await this._buildMDimStats(e3.pixelBlocks, v5.multidimensionalInfo) : await this._buildInMemoryRaster(c7, { width: 512, height: 512 }, t5), v5.multidimensionalInfo || (this.source = null), this.datasetName = l10;
  }
  async _buildInMemoryRaster(t5, i7, r7) {
    var _a, _b;
    const { rasterInfo: o6 } = this, a6 = o6.storageInfo.maximumPyramidLevel ?? 0, l10 = "thematic" !== o6.dataType, n7 = this.rasterJobHandler ? this.rasterJobHandler.split({ pixelBlock: t5, tileSize: i7, maximumPyramidLevel: a6, useBilinear: l10 }, r7) : Promise.resolve(W(t5, i7, a6, l10)), m10 = null != o6.statistics, u9 = null != o6.histograms, h9 = this.ioConfig.skipStatistics || m10 ? Promise.resolve({ statistics: null, histograms: null }) : this.rasterJobHandler ? this.rasterJobHandler.estimateStatisticsHistograms({ pixelBlock: t5 }, r7) : Promise.resolve(h3(t5)), d10 = await y([n7, h9]);
    if (!d10[0].value && d10[1].value) throw new s("inmemory-raster:open", "failed to build in memory raster");
    this._pixelBlockTiles = d10[0].value, m10 || (o6.statistics = (_a = d10[1].value) == null ? void 0 : _a.statistics), u9 || (o6.histograms = (_b = d10[1].value) == null ? void 0 : _b.histograms);
  }
  async _buildMDimStats(t5, e3, s4) {
    for (let i7 = 0; i7 < e3.variables.length; i7++) {
      const r7 = e3.variables[i7];
      if (r7.statistics) continue;
      const a6 = r7.dimensions.map((t6) => {
        var _a, _b;
        return new p3({ variableName: r7.name, dimensionName: t6.name, values: [((_a = t6.values) == null ? void 0 : _a[0]) ?? ((_b = t6.extent) == null ? void 0 : _b[0])], isSlice: true });
      }), l10 = w2(a6, e3), m10 = null == l10 ? null : t5[l10];
      if (null == m10) continue;
      const c7 = this.rasterJobHandler ? await this.rasterJobHandler.computeStatisticsHistograms({ pixelBlock: m10 }, s4) : m4(m10);
      r7.statistics = c7.statistics, r7.histograms || (r7.histograms = c7.histograms);
    }
  }
};
r([m({ type: String, json: { write: true } })], f9.prototype, "datasetFormat", void 0), r([m()], f9.prototype, "source", void 0), r([m()], f9.prototype, "url", null), f9 = r([a("esri.layers.support.rasterDatasets.InMemoryRaster")], f9);
var g6 = f9;

// node_modules/@arcgis/core/layers/support/rasterDatasets/CovJSONRaster.js
var m8 = class extends X {
  constructor() {
    super(...arguments), this.datasetFormat = "CovJSON";
  }
  fetchRawTile(e3, t5, r7, s4 = {}) {
    return this._inMemoryRaster.fetchRawTile(e3, t5, r7, s4);
  }
  async _open(e3) {
    const { extent: t5, pixelBlocks: r7, multidimensionalInfo: s4, attributeTable: a6, bandNames: o6 } = await this._fetchData(e3), { statistics: i7, histograms: n7 } = m4(r7[0]), m10 = o6 == null ? void 0 : o6.map((e4) => ({ BandName: e4 })), h9 = { DataType: a6 ? "Thematic" : s4 ? "Scientific" : "Generic", BandProperties: m10 }, d10 = new g6({ source: { extent: t5, pixelBlocks: r7, attributeTable: a6 ? d4.fromJSON(a6) : null, multidimensionalInfo: s4, statistics: i7, histograms: n7, keyProperties: h9, isPseudoSpatialReference: false } });
    await d10.open(), this._inMemoryRaster = d10;
    const u9 = this.source ? "" : this.url.slice(this.url.lastIndexOf("/") + 1);
    this._set("datasetName", u9.slice(0, u9.indexOf("."))), this._set("rasterInfo", d10.rasterInfo);
  }
  async _fetchData(e3) {
    var _a, _b, _c, _d;
    const r7 = this.source ?? (await this.request(this.url, { signal: e3 == null ? void 0 : e3.signal })).data, s4 = "imagery-tile-layer:open-coverage-json";
    if ("coverage" !== ((_a = r7.type) == null ? void 0 : _a.toLowerCase()) || "grid" !== ((_c = (_b = r7.domain) == null ? void 0 : _b.domainType) == null ? void 0 : _c.toLowerCase())) throw new s(s4, "Only coverage with Grid domain type is supported");
    if (!r7.ranges) throw new s(s4, "Missing ranges in the grid coverage data");
    if (!((_d = r7.domain.referencing) == null ? void 0 : _d.length)) throw new s(s4, "Missing domain referencing in the grid coverage data");
    const a6 = Object.values(r7.ranges);
    for (let n7 = 0; n7 < a6.length; n7++) {
      const { axisNames: e4, shape: r8, type: c7, values: l10 } = a6[n7];
      if (!("ndarray" === c7.toLowerCase() && (l10 == null ? void 0 : l10.length) && (e4 == null ? void 0 : e4.length) && (r8 == null ? void 0 : r8.length))) throw new s(s4, "Only ranges with valid NdArray, axisNames, shape, and inline values are supported");
      if (!(i5(e4[e4.length - 1]) && r5(e4[e4.length - 2]))) throw new s(s4, "Only row-major ordered pixel values are supported. X axis must be the last axis.");
    }
    return p5(r7);
  }
};
r([m({ type: String, json: { write: true } })], m8.prototype, "datasetFormat", void 0), r([m({ constructOnly: true })], m8.prototype, "source", void 0), m8 = r([a("esri.layers.support.rasterDatasets.CovJSONRaster")], m8);
var h7 = m8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/xmlUtilities.js
function n5(e3, t5) {
  if (!e3 || !t5) return [];
  let l10 = t5;
  t5.includes("/") ? (l10 = t5.slice(0, t5.indexOf("/")), t5 = t5.slice(t5.indexOf("/") + 1)) : t5 = "";
  const r7 = [];
  if (t5) {
    const u10 = n5(e3, l10);
    for (let e4 = 0; e4 < u10.length; e4++) {
      n5(u10[e4], t5).forEach((n7) => r7.push(n7));
    }
    return r7;
  }
  const u9 = e3.getElementsByTagNameNS("*", l10);
  if (!u9 || 0 === u9.length) return [];
  for (let n7 = 0; n7 < u9.length; n7++) r7.push(u9[n7] || u9.item(n7));
  return r7;
}
function e2(t5, l10) {
  if (!t5 || !l10) return null;
  let r7 = l10;
  l10.includes("/") ? (r7 = l10.slice(0, l10.indexOf("/")), l10 = l10.slice(l10.indexOf("/") + 1)) : l10 = "";
  const u9 = n5(t5, r7);
  return u9.length > 0 ? l10 ? e2(u9[0], l10) : u9[0] : null;
}
function t3(n7, t5 = null) {
  const l10 = t5 ? e2(n7, t5) : n7;
  let r7;
  return l10 ? (r7 = l10.textContent || l10.nodeValue, r7 ? r7.trim() : null) : null;
}
function l9(e3, t5) {
  const l10 = n5(e3, t5), r7 = [];
  let u9;
  for (let n7 = 0; n7 < l10.length; n7++) u9 = l10[n7].textContent || l10[n7].nodeValue, u9 && (u9 = u9.trim(), "" !== u9 && r7.push(u9));
  return r7;
}
function u6(n7, e3) {
  return l9(n7, e3).map((n8) => Number(n8));
}
function o5(n7, e3) {
  const l10 = t3(n7, e3);
  return Number(l10);
}
function i6(n7, e3) {
  var _a;
  const t5 = (_a = n7 == null ? void 0 : n7.nodeName) == null ? void 0 : _a.toLowerCase(), l10 = e3.toLowerCase();
  return t5.slice(t5.lastIndexOf(":") + 1) === l10;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/pamParser.js
function u7(e3, t5) {
  if (!e3 || !t5) return null;
  const n7 = [];
  for (let r7 = 0; r7 < e3.length; r7++) n7.push(e3[r7]), n7.push(t5[r7]);
  return n7;
}
function c6(e3) {
  const t5 = e2(e3, "GeodataXform"), n7 = d8(o5(t5, "SpatialReference/WKID") || t3(t5, "SpatialReference/WKT"));
  if ("typens:PolynomialXform" !== t5.getAttribute("xsi:type")) return { spatialReference: n7, transform: null };
  const s4 = o5(t5, "PolynomialOrder") ?? 1, f10 = u6(t5, "CoeffX/Double"), c7 = u6(t5, "CoeffY/Double"), m10 = u6(t5, "InverseCoeffX/Double"), p7 = u6(t5, "InverseCoeffY/Double"), S4 = u7(f10, c7), C2 = u7(m10, p7);
  return { spatialReference: n7, transform: S4 && C2 && S4.length && C2.length ? new y5({ spatialReference: n7, polynomialOrder: s4, forwardCoefficients: S4, inverseCoefficients: C2 }) : null };
}
function m9(e3) {
  var _a;
  const t5 = o5(e3, "NoDataValue"), n7 = e2(e3, "Histograms/HistItem"), l10 = o5(n7, "HistMin"), o6 = o5(n7, "HistMax"), f10 = o5(n7, "BucketCount"), u9 = (_a = t3(n7, "HistCounts")) == null ? void 0 : _a.split("|").map((e4) => Number(e4));
  let c7, m10, d10, p7;
  n5(e3, "Metadata/MDI").forEach((e4) => {
    const t6 = Number(e4.textContent ?? e4.nodeValue);
    switch (e4.getAttribute("key").toUpperCase()) {
      case "STATISTICS_MINIMUM":
        c7 = t6;
        break;
      case "STATISTICS_MAXIMUM":
        m10 = t6;
        break;
      case "STATISTICS_MEAN":
        d10 = t6;
        break;
      case "STATISTICS_STDDEV":
        p7 = t6;
    }
  });
  const S4 = o5(e3, "Metadata/SourceBandIndex");
  return { noDataValue: t5, histogram: (u9 == null ? void 0 : u9.length) && null != l10 && null != o6 ? { min: l10, max: o6, size: f10 || u9.length, counts: u9 } : null, sourceBandIndex: S4, statistics: null != c7 && null != m10 ? { min: c7, max: m10, avg: d10, stddev: p7 } : null };
}
function d8(e3) {
  if (!e3) return null;
  let n7 = Number(e3);
  if (!isNaN(n7) && 0 !== n7) return new g({ wkid: n7 });
  if (e3 = String(e3).trim(), k2(e3)) return new g({ wkt2: e3 });
  const r7 = e3.toUpperCase();
  if (r7.startsWith("COMPD_CS")) {
    if (!r7.includes("VERTCS") || !r7.includes("GEOGCS") && !r7.startsWith("PROJCS")) return null;
    const t5 = r7.indexOf("VERTCS"), s4 = r7.indexOf("PROJCS"), a6 = s4 > -1 ? s4 : r7.indexOf("GEOGCS");
    if (-1 === a6) return null;
    const i7 = e3.slice(a6, e3.lastIndexOf("]", t5) + 1).trim(), l10 = e3.slice(t5, e3.lastIndexOf("]")).trim();
    n7 = p6(i7);
    const o6 = new g(n7 ? { wkid: n7 } : { wkt: i7 }), u9 = p6(l10);
    return u9 && (o6.vcsWkid = u9), o6;
  }
  return r7.startsWith("GEOGCS") || r7.startsWith("PROJCS") ? (n7 = p6(e3), new g(0 !== n7 ? { wkid: n7 } : { wkt: e3 })) : null;
}
function p6(e3) {
  var _a;
  const t5 = e3.replaceAll("]", "[").replaceAll('"', "").split("[").map((e4) => e4.trim()).filter((e4) => "" !== e4), n7 = t5[t5.length - 1].split(","), r7 = (_a = n7[0]) == null ? void 0 : _a.toLowerCase();
  if (("epsg" === r7 || "esri" === r7) && e3.endsWith('"]]')) {
    const e4 = Number(n7[1]);
    if (!isNaN(e4) && 0 !== e4) return e4;
  }
  return 0;
}
function S2(t5) {
  var _a;
  if ("pamdataset" !== ((_a = t5 == null ? void 0 : t5.documentElement.tagName) == null ? void 0 : _a.toLowerCase())) return {};
  const a6 = { spatialReference: null, transform: null, metadata: {}, rasterBands: [], statistics: null, histograms: null };
  t5.documentElement.childNodes.forEach((e3) => {
    if (1 === e3.nodeType) {
      if (i6(e3, "SRS")) {
        if (!a6.spatialReference) {
          const t6 = t3(e3);
          a6.spatialReference = d8(t6);
        }
      } else if (i6(e3, "Metadata")) if ("xml:ESRI" === e3.getAttribute("domain")) {
        const { spatialReference: t6, transform: n7 } = c6(e3);
        a6.transform = n7, a6.spatialReference || (a6.spatialReference = t6);
      } else {
        n5(e3, "MDI").forEach((e4) => a6.metadata[e4.getAttribute("key")] = t3(e4));
      }
      else if (i6(e3, "PAMRasterBand")) {
        const t6 = m9(e3);
        null != t6.sourceBandIndex && null == a6.rasterBands[t6.sourceBandIndex] ? a6.rasterBands[t6.sourceBandIndex] = t6 : a6.rasterBands.push(t6);
      }
    }
  });
  const i7 = a6.rasterBands;
  if (i7.length) {
    const t6 = !!i7[0].statistics;
    a6.statistics = t6 ? i7.map((e3) => e3.statistics).filter(F) : null;
    const n7 = !!i7[0].histogram;
    a6.histograms = n7 ? i7.map((e3) => e3.histogram).filter(F) : null;
  }
  return a6;
}

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageAuxRaster.js
var h8 = class extends X {
  fetchRawTile(t5, s4, e3, r7 = {}) {
    return this._inMemoryRaster.fetchRawTile(t5, s4, e3, r7);
  }
  async _open(t5) {
    const s4 = await this._fetchData(t5);
    let { spatialReference: e3, statistics: r7, histograms: o6, transform: a6 } = await this._fetchAuxiliaryData(t5);
    const i7 = !e3;
    i7 && (e3 = new g({ wkid: 3857 })), (o6 == null ? void 0 : o6.length) && null == r7 && (r7 = g4(o6));
    const { width: m10, height: l10 } = s4;
    let c7 = new w({ xmin: -0.5, ymin: 0.5 - l10, xmax: m10 - 0.5, ymax: 0.5, spatialReference: e3 });
    const h9 = a6 ? a6.forwardTransform(c7) : c7;
    let d10 = true;
    if (a6) {
      const t6 = a6.forwardCoefficients;
      d10 = t6 && 0 === t6[1] && 0 === t6[2], d10 && (a6 = null, c7 = h9);
    }
    const g8 = new g6({ source: { extent: h9, nativeExtent: c7, transform: a6, pixelBlocks: [s4], statistics: r7, histograms: o6, keyProperties: { DateType: "Processed" }, isPseudoSpatialReference: i7 }, ioConfig: { sampling: "closest", skipStatistics: true } });
    this.ioConfig.skipMapInfo && (g8.ioConfig.skipMapInfo = true), await g8.open(), g8.source = null, this._set("rasterInfo", g8.rasterInfo), this._inMemoryRaster = g8;
  }
  async _fetchData(t5) {
    const { data: e3 } = await this.request(this.url, { responseType: "array-buffer", signal: t5 == null ? void 0 : t5.signal }), r7 = P(e3).toUpperCase();
    if ("JPG" !== r7 && "PNG" !== r7 && "GIF" !== r7 && "BMP" !== r7) throw new s("image-aux-raster:open", "the data is not a supported format");
    this._set("datasetFormat", r7);
    const o6 = r7.toLowerCase(), a6 = "gif" === o6 || "bmp" === o6 || !has("ios"), i7 = await this.decodePixelBlock(e3, { format: o6, useCanvas: a6, hasNoZlibMask: true });
    if (null == i7) throw new s("image-aux-raster:open", "the data cannot be decoded");
    return i7;
  }
  async _fetchAuxiliaryData(t5) {
    var _a;
    const s4 = t5 == null ? void 0 : t5.signal, { skipExtensions: o6 = [], skipMapInfo: a6 } = this.ioConfig, i7 = a6 || o6.includes("aux.xml") ? null : this.request(this.url + ".aux.xml", { responseType: "xml", signal: s4 }), n7 = this.datasetFormat, l10 = "JPG" === n7 ? "jgw" : "PNG" === n7 ? "pgw" : "BMP" === n7 ? "bpw" : null, p7 = l10 && o6.includes(l10) ? null : this.request(this.url.slice(0, this.url.lastIndexOf(".")) + "." + l10, { responseType: "text", signal: s4 }), f10 = await y([i7, p7]);
    if (s4 == null ? void 0 : s4.aborted) throw u();
    const u9 = S2((_a = f10[0].value) == null ? void 0 : _a.data);
    if (!u9.transform) {
      const t6 = f10[1].value ? f10[1].value.data.split("\n").slice(0, 6).map((t7) => Number(t7)) : null;
      u9.transform = 6 === (t6 == null ? void 0 : t6.length) ? new y5({ forwardCoefficients: [t6[4], t6[5], t6[0], -t6[1], t6[2], -t6[3]] }) : null;
    }
    return u9;
  }
};
r([m({ type: String, json: { write: true } })], h8.prototype, "datasetFormat", void 0), h8 = r([a("esri.layers.support.rasterDatasets.ImageAuxRaster")], h8);
var d9 = h8;

// node_modules/@arcgis/core/layers/support/rasterDatasets/ImageServerRaster.js
var g7 = class extends X {
  constructor() {
    super(...arguments), this._levelOffset = 0, this._tilemapCache = null, this._slices = null, this.datasetFormat = "RasterTileServer", this.tileType = null;
  }
  async fetchRawTile(e3, t5, i7, s4 = {}) {
    const { storageInfo: r7, extent: a6 } = this.rasterInfo, { transposeInfo: l10 } = r7, o6 = null != l10 && !!s4.transposedVariableName;
    if (this._slices && !o6 && null == s4.sliceId) return null;
    const n7 = o6 ? 0 : r7.maximumPyramidLevel - e3 + this._levelOffset, c7 = `${this.url}/tile/${n7}/${t5}/${i7}`, m10 = this._slices ? o6 ? { variable: s4.transposedVariableName } : { sliceId: s4.sliceId || 0 } : null, { data: h9 } = await this.request(c7, { query: m10, responseType: "array-buffer", signal: s4.signal });
    if (!h9) return null;
    const f10 = o6 ? l10.tileSize : r7.tileInfo.size, p7 = await this.decodePixelBlock(h9, { width: f10[0], height: f10[1], planes: null, pixelType: null, isPoint: "Elevation" === this.tileType, returnInterleaved: o6, noDataValue: this.rasterInfo.noDataValue });
    if (null == p7) return null;
    const d10 = r7.blockBoundary[e3];
    if ("jpg" !== r7.compression || i7 > d10.minCol && i7 < d10.maxCol && t5 > d10.minRow && t5 < d10.maxRow) return p7;
    const { origin: y7, blockWidth: x4, blockHeight: g8 } = r7, { x: v5, y: S4 } = this.getPyramidPixelSize(e3), I5 = Math.round((a6.xmin - y7.x) / v5) % x4, w5 = Math.round((a6.xmax - y7.x) / v5) % x4 || x4, j4 = Math.round((y7.y - a6.ymax) / S4) % g8, M = Math.round((y7.y - a6.ymin) / S4) % g8 || g8, b3 = i7 === d10.minCol ? I5 : 0, T4 = t5 === d10.minRow ? j4 : 0, _4 = i7 === d10.maxCol ? w5 : x4, O = t5 === d10.maxRow ? M : g8;
    return T2(p7, { x: b3, y: T4 }, { width: _4 - b3, height: O - T4 }), p7;
  }
  getSliceIndex(e3) {
    if (!this._slices || null == e3 || 0 === e3.length) return null;
    const t5 = e3;
    for (let i7 = 0; i7 < this._slices.length; i7++) {
      const e4 = this._slices[i7].multidimensionalDefinition;
      if (e4.length === t5.length && !e4.some((e5) => {
        const i8 = t5.find((t6) => e5.variableName === t6.variableName && t6.dimensionName === e5.dimensionName);
        if (!i8) return true;
        return (Array.isArray(e5.values[0]) ? `${e5.values[0][0]}-${e5.values[0][1]}` : e5.values[0]) !== (Array.isArray(i8.values[0]) ? `${i8.values[0][0]}-${i8.values[0][1]}` : i8.values[0]);
      })) return i7;
    }
    return null;
  }
  async fetchVariableStatisticsHistograms(e3, t5) {
    var _a, _b, _c;
    const i7 = this.request(this.url + "/statistics", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.statistics;
    }), s4 = this.request(this.url + "/histograms", { query: { variable: e3, f: "json" }, signal: t5 }).then((e4) => {
      var _a2;
      return (_a2 = e4.data) == null ? void 0 : _a2.histograms;
    }), r7 = await Promise.all([i7, s4]);
    return r7[0] && r7[0].forEach((e4) => {
      e4.avg = e4.mean, e4.stddev = e4.standardDeviation;
    }), ((_c = (_b = (_a = r7[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.counts) == null ? void 0 : _c.length) || (r7[1] = null), { statistics: r7[0] || null, histograms: r7[1] || null };
  }
  async computeBestPyramidLevelForLocation(e3, t5 = {}) {
    if (!this._tilemapCache) return 0;
    let i7 = this.identifyPixelLocation(e3, 0, t5.datumTransformation);
    if (null === i7) return null;
    let s4 = 0;
    const { maximumPyramidLevel: r7 } = this.rasterInfo.storageInfo;
    let a6 = r7 - s4 + this._levelOffset;
    const l10 = i7.srcLocation;
    for (; a6 >= 0; ) {
      try {
        if ("available" === await this._tilemapCache.fetchAvailability(a6, i7.row, i7.col, t5)) break;
      } catch {
      }
      if (a6--, s4++, i7 = this.identifyPixelLocation(l10, s4, t5.datumTransformation), null === i7) return null;
    }
    return -1 === a6 || null == i7 ? null : s4;
  }
  async _open(e3) {
    var _a, _b;
    const r7 = e3 == null ? void 0 : e3.signal, a6 = this.sourceJSON ? { data: this.sourceJSON } : await this.request(this.url, { query: { f: "json" }, signal: r7 });
    a6.ssl && (this.url = this.url.replace(/^http:/i, "https:"));
    const l10 = a6.data;
    if (this.sourceJSON = l10, !l10) throw new s("imageserverraster:open", "cannot initialize tiled image service, missing service info");
    if (!l10.tileInfo) throw new s("imageserverraster:open", "use ImageryLayer to open non-tiled image services");
    this._fixScaleInServiceInfo();
    const m10 = ["jpg", "jpeg", "png", "png8", "png24", "png32", "mixed"];
    this.tileType = l10.cacheType, null == this.tileType && (m10.includes(l10.tileInfo.format.toLowerCase()) ? this.tileType = "Map" : "lerc" === l10.tileInfo.format.toLowerCase() ? this.tileType = "Elevation" : this.tileType = "Raster"), this.datasetName = ((_a = l10.name) == null ? void 0 : _a.slice(l10.name.indexOf("/") + 1)) ?? "";
    const u9 = await this._fetchRasterInfo({ signal: r7 });
    if (null == u9) throw new s("image-server-raster:open", "cannot initialize image service");
    c3(u9, l10);
    const h9 = "Map" === this.tileType ? v3(l10.tileInfo, l10) : z.fromJSON(l10.tileInfo);
    n2(h9);
    const [p7, d10] = this._computeMinMaxLOD(u9, h9), { extent: y7, pixelSize: x4 } = u9, g8 = 0.5 / u9.width * x4.x, I5 = Math.max(x4.x, x4.y), { lods: w5 } = h9;
    ("Map" !== this.tileType && 0 !== l10.maxScale || Math.abs(x4.x - x4.y) > g8 || !w5.some((e4) => Math.abs(e4.resolution - I5) < g8)) && (x4.x = x4.y = p7.resolution, u9.width = Math.ceil((y7.xmax - y7.xmin) / x4.x - 0.1), u9.height = Math.ceil((y7.ymax - y7.ymin) / x4.y - 0.1));
    const j4 = p7.level - d10.level, [M, b3] = h9.size, T4 = [], _4 = [];
    w5.forEach((e4, t5) => {
      e4.level >= d10.level && e4.level <= p7.level && T4.push({ x: e4.resolution, y: e4.resolution }), t5 < w5.length - 1 && _4.push(Math.round(10 * e4.resolution / w5[t5 + 1].resolution) / 10);
    }), T4.sort((e4, t5) => e4.x - t5.x);
    const O = this.computeBlockBoundary(y7, M, b3, h9.origin, T4, j4), R3 = T4.length > 1 ? T4.slice(1) : null;
    let z3;
    l10.transposeInfo && (z3 = { tileSize: [l10.transposeInfo.rows, l10.transposeInfo.cols], packetSize: ((_b = u9.keyProperties) == null ? void 0 : _b._yxs.PacketSize) ?? 0 });
    const N4 = _4.length <= 1 || _4.length >= 3 && _4.slice(0, -1).every((e4) => e4 === _4[0]) ? _4[0] ?? 2 : Math.round(10 / (d10.resolution / p7.resolution) ** (-1 / j4)) / 10;
    if (u9.storageInfo = new n3({ blockWidth: h9.size[0], blockHeight: h9.size[1], pyramidBlockWidth: h9.size[0], pyramidBlockHeight: h9.size[1], pyramidResolutions: R3, pyramidScalingFactor: N4, compression: h9.format, origin: h9.origin, firstPyramidLevel: 1, maximumPyramidLevel: j4, tileInfo: h9, transposeInfo: z3, blockBoundary: O }), S3(u9), this._set("rasterInfo", u9), l10.capabilities.toLowerCase().includes("tilemap")) {
      const e4 = { tileInfo: u9.storageInfo.tileInfo, parsedUrl: I(this.url), url: this.url, tileServers: [] };
      this._tilemapCache = new T({ layer: e4 });
    }
  }
  async _fetchRasterInfo(e3) {
    const t5 = this.sourceJSON;
    if ("Map" === this.tileType) {
      const e4 = t5.fullExtent || t5.extent, i8 = Math.ceil((e4.xmax - e4.xmin) / t5.pixelSizeX - 0.1), s5 = Math.ceil((e4.ymax - e4.ymin) / t5.pixelSizeY - 0.1), r8 = g.fromJSON(t5.spatialReference || e4.spatialReference), a7 = new j({ x: t5.pixelSizeX, y: t5.pixelSizeY, spatialReference: r8 });
      return new m3({ width: i8, height: s5, bandCount: 3, extent: w.fromJSON(e4), spatialReference: r8, pixelSize: a7, pixelType: "u8", statistics: null, keyProperties: { DataType: "processed" } });
    }
    const { signal: i7 } = e3, s4 = f6(this.url, this.sourceJSON, { signal: i7, query: this.ioConfig.customFetchParameters }), r7 = t5.hasMultidimensions ? this.request(`${this.url}/slices`, { query: { f: "json" }, signal: i7 }).then((e4) => {
      var _a;
      return (_a = e4.data) == null ? void 0 : _a.slices;
    }).catch(() => null) : null, a6 = await Promise.all([s4, r7]);
    return this._slices = a6[1], a6[0];
  }
  _fixScaleInServiceInfo() {
    const { sourceJSON: e3 } = this;
    e3.minScale && e3.minScale < 0 && (e3.minScale = 0), e3.maxScale && e3.maxScale < 0 && (e3.maxScale = 0);
  }
  _computeMinMaxLOD(e3, t5) {
    const { pixelSize: i7 } = e3, s4 = 0.5 / e3.width * i7.x, { lods: r7 } = t5, a6 = t5.lodAt(Math.max.apply(null, r7.map((e4) => e4.level))), l10 = t5.lodAt(Math.min.apply(null, r7.map((e4) => e4.level))), { tileType: o6 } = this;
    if ("Map" === o6) return this._levelOffset = r7[0].level, [a6, l10];
    if ("Raster" === o6) {
      return [r7.find((e4) => e4.resolution === i7.x) ?? a6, l10];
    }
    const { minScale: n7, maxScale: c7 } = this.sourceJSON;
    let m10 = a6;
    c7 > 0 && (m10 = r7.find((e4) => Math.abs(e4.scale - c7) < s4), m10 || (m10 = r7.filter((e4) => e4.scale > c7).sort((e4, t6) => e4.scale > t6.scale ? 1 : -1)[0] ?? a6));
    let u9 = l10;
    return n7 > 0 && (u9 = r7.find((e4) => Math.abs(e4.scale - n7) < s4) ?? l10, this._levelOffset = u9.level - l10.level), [m10, u9];
  }
};
function v3(e3, t5) {
  if (!e3) return null;
  const { minScale: i7, maxScale: s4, minLOD: r7, maxLOD: a6 } = t5;
  if (null != r7 && null != a6) return z.fromJSON({ ...e3, lods: e3.lods.filter(({ level: e4 }) => null != e4 && e4 >= r7 && e4 <= a6) });
  if (0 !== i7 && 0 !== s4) {
    const t6 = (e4) => Math.round(1e4 * e4) / 1e4, r8 = i7 ? t6(i7) : 1 / 0, a7 = s4 ? t6(s4) : -1 / 0;
    return z.fromJSON({ ...e3, lods: e3.lods.filter((e4) => {
      const i8 = t6(e4.scale);
      return i8 <= r8 && i8 >= a7;
    }) });
  }
  return z.fromJSON(e3);
}
function S3(e3) {
  const { extent: t5, spatialReference: i7 } = e3;
  t5.xmin > -1 && t5.xmax > 181 && (i7 == null ? void 0 : i7.wkid) && i7.isGeographic && (e3.nativeExtent = e3.extent, e3.transform = new c4(), e3.extent = e3.transform.forwardTransform(t5));
}
r([m({ type: String, json: { write: true } })], g7.prototype, "datasetFormat", void 0), r([m()], g7.prototype, "tileType", void 0), g7 = r([a("esri.layers.support.rasterDatasets.ImageServerRaster")], g7);
var I3 = g7;

// node_modules/@arcgis/core/layers/support/rasterDatasets/MRFRaster.js
var y6 = /* @__PURE__ */ new Map();
y6.set("Int8", "s8"), y6.set("UInt8", "u8"), y6.set("Int16", "s16"), y6.set("UInt16", "u16"), y6.set("Int32", "s32"), y6.set("UInt32", "u32"), y6.set("Float32", "f32"), y6.set("Float64", "f32"), y6.set("Double64", "f32");
var x3 = /* @__PURE__ */ new Map();
x3.set("none", { blobExtension: ".til", isOneSegment: true, decoderFormat: "bip" }), x3.set("lerc", { blobExtension: ".lrc", isOneSegment: false, decoderFormat: "lerc" }), x3.set("deflate", { blobExtension: ".pzp", isOneSegment: true, decoderFormat: "deflate" }), x3.set("jpeg", { blobExtension: ".pjg", isOneSegment: true, decoderFormat: "jpg" });
var w4 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._storageIndex = null, this.datasetFormat = "MRF";
  }
  async fetchRawTile(t5, e3, r7, s4 = {}) {
    const { blockWidth: i7, blockHeight: a6, blockBoundary: n7 } = this.rasterInfo.storageInfo, l10 = n7[t5];
    if (!l10 || l10.maxRow < e3 || l10.maxCol < r7 || l10.minRow > e3 || l10.minCol > r7) return null;
    const { bandCount: f10, pixelType: c7 } = this.rasterInfo, { ranges: m10, actualTileWidth: p7, actualTileHeight: h9 } = this._getTileLocation(t5, e3, r7);
    if (!m10 || 0 === m10.length) return null;
    if (0 === m10[0].from && 0 === m10[0].to) {
      const t6 = new Uint8Array(i7 * a6);
      return new g2({ width: i7, height: a6, pixels: void 0, mask: t6, validPixelCount: 0 });
    }
    const { bandIds: u9 } = this.ioConfig, g8 = this._getBandSegmentCount(), d10 = [];
    let y7 = 0;
    for (y7 = 0; y7 < g8; y7++) u9 && !u9.includes(y7) || d10.push(this.request(this._files.data, { range: { from: m10[y7].from, to: m10[y7].to }, responseType: "array-buffer", signal: s4.signal }));
    const w5 = await Promise.all(d10), I5 = w5.map((t6) => t6.data.byteLength).reduce((t6, e4) => t6 + e4), b3 = new Uint8Array(I5), R3 = [];
    let A2 = 0;
    for (y7 = 0; y7 < g8; y7++) R3.push(A2), b3.set(new Uint8Array(w5[y7].data), A2), A2 += w5[y7].data.byteLength;
    const F4 = x3.get(this.rasterInfo.storageInfo.compression).decoderFormat, _4 = await this.decodePixelBlock(b3.buffer, { width: i7, height: a6, format: F4, planes: (u9 == null ? void 0 : u9.length) || f10, offsets: R3, pixelType: c7 });
    if (null == _4) return null;
    let { noDataValue: S4 } = this.rasterInfo;
    if (null != S4 && "lerc" !== F4 && !_4.mask && (S4 = S4[0], null != S4)) {
      const t6 = _4.width * _4.height, e4 = new Uint8Array(t6);
      if (Math.abs(S4) > 1e24) for (y7 = 0; y7 < t6; y7++) Math.abs((_4.pixels[0][y7] - S4) / S4) > 1e-6 && (e4[y7] = 1);
      else for (y7 = 0; y7 < t6; y7++) _4.pixels[0][y7] !== S4 && (e4[y7] = 1);
      _4.mask = e4;
    }
    let k4 = 0, M = 0;
    if (p7 !== i7 || h9 !== a6) {
      let t6 = _4.mask;
      if (t6) for (y7 = 0; y7 < a6; y7++) if (M = y7 * i7, y7 < h9) for (k4 = p7; k4 < i7; k4++) t6[M + k4] = 0;
      else for (k4 = 0; k4 < i7; k4++) t6[M + k4] = 0;
      else for (t6 = new Uint8Array(i7 * a6), _4.mask = t6, y7 = 0; y7 < h9; y7++) for (M = y7 * i7, k4 = 0; k4 < p7; k4++) t6[M + k4] = 1;
    }
    return _4;
  }
  async _open(t5) {
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1);
    const e3 = t5 ? t5.signal : null, r7 = await this.request(this.url, { responseType: "xml", signal: e3 }), { rasterInfo: s4, files: o6 } = this._parseHeader(r7.data), { skipMapInfo: i7, skipExtensions: a6 = [] } = this.ioConfig;
    if (!a6.includes("aux.xml") && !i7) {
      const e4 = await this._fetchAuxiliaryData(t5);
      null != e4 && (s4.statistics = e4.statistics ?? s4.statistics, s4.histograms = e4.histograms, e4.histograms && null == s4.statistics && (s4.statistics = g4(e4.histograms)));
    }
    i7 && this.updateImageSpaceRasterInfo(s4), this._set("rasterInfo", s4), this._files = o6;
    const n7 = await this.request(o6.index, { responseType: "array-buffer", signal: e3 });
    this._storageIndex = I4(n7.data);
    const { blockWidth: l10, blockHeight: f10 } = this.rasterInfo.storageInfo, c7 = this.rasterInfo.storageInfo.pyramidScalingFactor, { width: m10, height: p7 } = this.rasterInfo, u9 = [], g8 = this._getBandSegmentCount();
    let d10 = 0, y7 = -1;
    for (; d10 < this._storageIndex.length; ) {
      y7++;
      const t6 = Math.ceil(m10 / l10 / c7 ** y7) - 1, e4 = Math.ceil(p7 / f10 / c7 ** y7) - 1;
      d10 += (t6 + 1) * (e4 + 1) * g8 * 4, u9.push({ maxRow: e4, maxCol: t6, minCol: 0, minRow: 0 });
    }
    this.rasterInfo.storageInfo.blockBoundary = u9, y7 > 0 && (this.rasterInfo.storageInfo.firstPyramidLevel = 1, this.rasterInfo.storageInfo.maximumPyramidLevel = y7), this.updateTileInfo();
  }
  _getBandSegmentCount() {
    return x3.get(this.rasterInfo.storageInfo.compression).isOneSegment ? 1 : this.rasterInfo.bandCount;
  }
  _getTileLocation(t5, e3, r7) {
    const { blockWidth: s4, blockHeight: o6, pyramidScalingFactor: i7 } = this.rasterInfo.storageInfo, { width: a6, height: n7 } = this.rasterInfo, l10 = this._getBandSegmentCount();
    let f10, c7, m10, p7 = 0, h9 = 0;
    for (m10 = 0; m10 < t5; m10++) h9 = i7 ** m10, f10 = Math.ceil(a6 / s4 / h9), c7 = Math.ceil(n7 / o6 / h9), p7 += f10 * c7;
    h9 = i7 ** t5, f10 = Math.ceil(a6 / s4 / h9), c7 = Math.ceil(n7 / o6 / h9), p7 += e3 * f10 + r7, p7 *= 4 * l10;
    const u9 = this._storageIndex.subarray(p7, p7 + 4 * l10);
    let g8 = 0, d10 = 0;
    const y7 = [];
    for (let x4 = 0; x4 < l10; x4++) g8 = u9[4 * x4] * 2 ** 32 + u9[4 * x4 + 1], d10 = g8 + u9[4 * x4 + 2] * 2 ** 32 + u9[4 * x4 + 3], y7.push({ from: g8, to: d10 });
    return { ranges: y7, actualTileWidth: r7 < f10 - 1 ? s4 : Math.ceil(a6 / h9) - s4 * (f10 - 1), actualTileHeight: e3 < c7 - 1 ? o6 : Math.ceil(n7 / h9) - o6 * (c7 - 1) };
  }
  _parseHeader(t5) {
    const r7 = e2(t5, "MRF_META/Raster");
    if (!r7) throw new s("mrf:open", "not a valid MRF format");
    const s4 = e2(r7, "Size"), o6 = parseInt(s4.getAttribute("x"), 10), n7 = parseInt(s4.getAttribute("y"), 10), f10 = parseInt(s4.getAttribute("c"), 10), p7 = (t3(r7, "Compression") || "none").toLowerCase();
    if (!x3.has(p7)) throw new s("mrf:open", "currently does not support compression " + p7);
    const h9 = t3(r7, "DataType") || "UInt8", w5 = y6.get(h9);
    if (null == w5) throw new s("mrf:open", "currently does not support pixel type " + h9);
    const I5 = e2(r7, "PageSize"), b3 = parseInt(I5.getAttribute("x"), 10), R3 = parseInt(I5.getAttribute("y"), 10), A2 = e2(r7, "DataValues");
    let F4, _4;
    A2 && (_4 = A2.getAttribute("NoData"), null != _4 && (F4 = _4.trim().split(" ").map((t6) => parseFloat(t6))));
    if (e2(t5, "MRF_META/CachedSource")) throw new s("mrf:open", "currently does not support MRF referencing other data files");
    const S4 = e2(t5, "MRF_META/GeoTags"), k4 = e2(S4, "BoundingBox");
    let M, j4 = false;
    if (null != k4) {
      const t6 = parseFloat(k4.getAttribute("minx")), e3 = parseFloat(k4.getAttribute("miny")), r8 = parseFloat(k4.getAttribute("maxx")), s5 = parseFloat(k4.getAttribute("maxy")), o7 = t3(S4, "Projection") || "";
      let i7 = g.WGS84;
      if ("LOCAL_CS[]" !== o7) if (o7.toLowerCase().startsWith("epsg:")) {
        const t7 = Number(o7.slice(5));
        isNaN(t7) || 0 === t7 || (i7 = new g({ wkid: t7 }));
      } else i7 = d8(o7) ?? g.WGS84;
      else j4 = true, i7 = new g({ wkid: 3857 });
      M = new w(t6, e3, r8, s5), M.spatialReference = i7;
    } else j4 = true, M = new w({ xmin: -0.5, ymin: 0.5 - n7, xmax: o6 - 0.5, ymax: 0.5, spatialReference: new g({ wkid: 3857 }) });
    const C2 = e2(t5, "MRF_META/Rsets"), T4 = parseInt((C2 == null ? void 0 : C2.getAttribute("scale")) || "2", 10), L4 = M.spatialReference, U6 = new n3({ origin: new j({ x: M.xmin, y: M.ymax, spatialReference: L4 }), blockWidth: b3, blockHeight: R3, pyramidBlockWidth: b3, pyramidBlockHeight: R3, compression: p7, pyramidScalingFactor: T4 }), B2 = new j({ x: M.width / o6, y: M.height / n7, spatialReference: L4 }), E3 = new m3({ width: o6, height: n7, extent: M, isPseudoSpatialReference: j4, spatialReference: L4, bandCount: f10, pixelType: w5, pixelSize: B2, noDataValue: F4, storageInfo: U6 }), P3 = t3(t5, "datafile"), W3 = t3(t5, "IndexFile");
    return { rasterInfo: E3, files: { mrf: this.url, index: W3 || this.url.replace(".mrf", ".idx"), data: P3 || this.url.replace(".mrf", x3.get(p7).blobExtension) } };
  }
  async _fetchAuxiliaryData(t5) {
    try {
      const { data: e3 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: t5 == null ? void 0 : t5.signal });
      return S2(e3);
    } catch {
      return null;
    }
  }
};
function I4(t5) {
  if (t5.byteLength % 16 > 0) throw new Error("invalid array buffer must be multiples of 16");
  let e3, r7, s4, o6, i7, a6;
  if (r4) {
    for (r7 = new Uint8Array(t5), o6 = new ArrayBuffer(t5.byteLength), s4 = new Uint8Array(o6), i7 = 0; i7 < t5.byteLength / 4; i7++) for (a6 = 0; a6 < 4; a6++) s4[4 * i7 + a6] = r7[4 * i7 + 3 - a6];
    e3 = new Uint32Array(o6);
  } else e3 = new Uint32Array(t5);
  return e3;
}
r([m()], w4.prototype, "_files", void 0), r([m()], w4.prototype, "_storageIndex", void 0), r([m({ type: String, json: { write: true } })], w4.prototype, "datasetFormat", void 0), w4 = r([a("esri.layers.support.rasterDatasets.MRFRaster")], w4);
var b2 = w4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/DBFParser.js
function t4(e3) {
  const t5 = e3.fields, r7 = e3.records, n7 = t5.some((e4) => "oid" === e4.name.toLowerCase()) ? "OBJECTID" : "OID", i7 = [{ name: n7, type: "esriFieldTypeOID", alias: "OID" }].concat(t5.map((e4) => ({ name: e4.name, type: "esriFieldType" + e4.typeName, alias: e4.name }))), a6 = i7.map((e4) => e4.name), s4 = [];
  let o6 = 0, l10 = 0;
  return r7.forEach((e4) => {
    const t6 = {};
    for (t6[n7] = o6++, l10 = 1; l10 < a6.length; l10++) t6[a6[l10]] = e4[l10 - 1];
    s4.push({ attributes: t6 });
  }), { displayFieldName: "", fields: i7, features: s4 };
}
var r6 = class {
  static get supportedVersions() {
    return [5];
  }
  static parse(r7) {
    const n7 = new DataView(r7), i7 = 3 & n7.getUint8(0);
    if (3 !== i7) return { header: { version: i7 }, recordSet: null };
    const a6 = n7.getUint32(4, true), s4 = n7.getUint16(8, true), o6 = n7.getUint16(10, true), l10 = { version: i7, recordCount: a6, headerByteCount: s4, recordByteCount: o6 };
    let p7 = 32;
    const d10 = [], g8 = [];
    let h9;
    if (3 === i7) {
      for (; 13 !== n7.getUint8(p7); ) h9 = String.fromCharCode(n7.getUint8(p7 + 11)).trim(), d10.push({ name: r3(new Uint8Array(r7, p7, 11)), type: h9, typeName: ["String", "Date", "Double", "Boolean", "String", "Integer"][["C", "D", "F", "L", "M", "N"].indexOf(h9)], length: n7.getUint8(p7 + 16) }), p7 += 32;
      if (p7 += 1, d10.length > 0) for (; g8.length < a6 && r7.byteLength - p7 > o6; ) {
        const t5 = [];
        32 === n7.getUint8(p7) ? (p7 += 1, d10.forEach((n8) => {
          if ("C" === n8.type) t5.push(r3(new Uint8Array(r7, p7, n8.length)).trim());
          else if ("N" === n8.type) t5.push(parseInt(String.fromCharCode.apply(null, new Uint8Array(r7, p7, n8.length)).trim(), 10));
          else if ("F" === n8.type) t5.push(parseFloat(String.fromCharCode.apply(null, new Uint8Array(r7, p7, n8.length)).trim()));
          else if ("D" === n8.type) {
            const e3 = String.fromCharCode.apply(null, new Uint8Array(r7, p7, n8.length)).trim();
            t5.push(new Date(parseInt(e3.slice(0, 4), 10), parseInt(e3.slice(4, 6), 10) - 1, parseInt(e3.slice(6, 8), 10)));
          }
          p7 += n8.length;
        }), g8.push(t5)) : p7 += o6;
      }
    }
    return { header: l10, fields: d10, records: g8, recordSet: t4({ fields: d10, records: g8 }) };
  }
};

// node_modules/@arcgis/core/layers/support/rasterDatasets/TIFFRaster.js
var _3 = (e3, t5) => {
  var _a;
  return (_a = e3.get(t5)) == null ? void 0 : _a.values;
};
var F3 = (e3, t5) => {
  var _a, _b;
  return (_b = (_a = e3.get(t5)) == null ? void 0 : _a.values) == null ? void 0 : _b[0];
};
var v4 = class extends X {
  constructor() {
    super(...arguments), this._files = null, this._headerInfo = null, this._bufferSize = 1048576, this.datasetFormat = "TIFF";
  }
  async fetchRawTile(e3, t5, r7, i7 = {}) {
    var _a;
    if (!((_a = this._headerInfo) == null ? void 0 : _a.isSupported) || this.isBlockOutside(e3, t5, r7)) return null;
    const s4 = await this._fetchRawTiffTile(e3, t5, r7, false, i7);
    if (null != s4 && this._headerInfo.hasMaskBand) {
      const a6 = await this._fetchRawTiffTile(e3, t5, r7, true, i7);
      null != a6 && a6.pixels[0] instanceof Uint8Array && (s4.mask = a6.pixels[0]);
    }
    return s4;
  }
  async _open(e3) {
    var _a, _b, _c, _d;
    const t5 = e3 ? e3.signal : null, { data: s4 } = await this.request(this.url, { range: { from: 0, to: this._bufferSize }, responseType: "array-buffer", signal: t5 });
    if (!s4) throw new s("tiffraster:open", "failed to open url " + this.url);
    this.datasetName = this.url.slice(this.url.lastIndexOf("/") + 1, this.url.lastIndexOf("."));
    const { littleEndian: a6, firstIFDPos: n7, isBigTiff: o6 } = F2(s4), f10 = [];
    await this._readIFDs(f10, s4, a6, n7, 0, o6 ? 8 : 4, t5);
    const { imageInfo: l10, rasterInfo: u9 } = k3(f10), p7 = U3(f10), d10 = N2(f10);
    if (this._headerInfo = { littleEndian: a6, isBigTiff: o6, ifds: f10, pyramidIFDs: p7, maskIFDs: d10, ...l10 }, this._set("rasterInfo", u9), !l10.isSupported) throw new s("tiffraster:open", "this tiff is not supported: " + l10.message);
    if (!l10.tileWidth) throw new s("tiffraster:open", "none-tiled tiff is not optimized for access, convert to COG and retry.");
    u9.isPseudoSpatialReference && n.getLogger(this).warn("The spatial reference for this tiff is unsupported. Only EPSG spatial reference codes and Esri WKTs are supported.");
    const y7 = (_b = (_a = f10[0].get("PREDICTOR")) == null ? void 0 : _a.values) == null ? void 0 : _b[0], g8 = (_d = (_c = f10[0].get("SAMPLEFORMAT")) == null ? void 0 : _c.values) == null ? void 0 : _d[0];
    if (3 === g8 && 2 === y7) throw new s("tiffraster:open", "unsupported horizontal difference encoding. Predictor=3 is supported for floating point data");
    const { skipMapInfo: x4, skipExtensions: T4 = [] } = this.ioConfig;
    if (!T4.includes("aux.xml") && !x4) {
      const t6 = await this._fetchAuxiliaryMetaData(e3);
      null != t6 && P2(t6, u9);
    }
    T4.includes("vat.dbf") || 1 !== u9.bandCount || "u8" !== u9.pixelType || x4 || (u9.attributeTable = await this._fetchAuxiliaryTable(e3), null != u9.attributeTable && (u9.keyProperties.DataType = "thematic")), x4 && this.updateImageSpaceRasterInfo(u9), this.updateTileInfo();
  }
  async _readIFDs(e3, t5, r7, i7, s4, a6 = 4, n7) {
    if (!i7) return null;
    if (i7 >= t5.byteLength || i7 < 0) {
      t5 = (await this.request(this.url, { range: { from: i7 + s4, to: i7 + s4 + this._bufferSize }, responseType: "array-buffer", signal: n7 })).data, s4 = i7 + s4, i7 = 0;
    }
    const o6 = await this._readIFD(t5, r7, i7, s4, n4.tiffTags, a6, n7);
    if (e3.push(o6.ifd), !o6.nextIFD) return null;
    await this._readIFDs(e3, t5, r7, o6.nextIFD - s4, s4, a6, n7);
  }
  async _readIFD(e3, r7, i7, s4, a6 = n4.tiffTags, n7 = 4, o6) {
    var _a, _b;
    if (!e3) return null;
    const f10 = B(e3, r7, i7, s4, a6, n7);
    if (f10.success) {
      const i8 = [];
      if ((_a = f10.ifd) == null ? void 0 : _a.forEach((e4) => {
        e4.values || i8.push(e4);
      }), i8.length > 0) {
        const a7 = i8.map((e4) => e4.offlineOffsetSize).filter(F), n8 = Math.min.apply(null, a7.map((e4) => e4[0]));
        if (Math.min.apply(null, a7.map((e4) => e4[0] + e4[1])) - n8 <= this._bufferSize) {
          const { data: t5 } = await this.request(this.url, { range: { from: n8, to: n8 + this._bufferSize }, responseType: "array-buffer", signal: o6 });
          e3 = t5, s4 = n8, i8.forEach((t6) => L(e3, r7, t6, s4));
        }
      }
      if ((_b = f10.ifd) == null ? void 0 : _b.has("GEOKEYDIRECTORY")) {
        const t5 = f10.ifd.get("GEOKEYDIRECTORY"), i9 = t5 == null ? void 0 : t5.values;
        if (i9 && i9.length > 4) {
          const a7 = i9[0] + "." + i9[1] + "." + i9[2], n8 = await this._readIFD(e3, r7, t5.valueOffset + 6 - s4, s4, n4.geoKeys, 2, o6);
          t5.data = n8.ifd, t5.data && t5.data.set("GEOTIFFVersion", { id: 0, type: 2, valueCount: 1, valueOffset: null, values: [a7] });
        }
      }
      return f10;
    }
    if (f10.requiredBufferSize && f10.requiredBufferSize !== e3.byteLength) {
      const t5 = await this.request(this.url, { range: { from: s4, to: s4 + f10.requiredBufferSize + 4 }, responseType: "array-buffer", signal: o6 });
      return (e3 = t5.data).byteLength < f10.requiredBufferSize ? null : this._readIFD(e3, r7, 0, s4, n4.tiffTags, 4, o6);
    }
  }
  async _fetchRawTiffTile(e3, t5, r7, i7, s4 = {}) {
    const a6 = this._getTileLocation(e3, t5, r7, i7);
    if (!a6) return null;
    const { ranges: n7, actualTileWidth: o6, actualTileHeight: f10, ifd: l10 } = a6, u9 = n7.map((e4) => this.request(this.url, { range: e4, responseType: "array-buffer", signal: s4.signal })), p7 = await Promise.all(u9), c7 = p7.map((e4) => e4.data.byteLength).reduce((e4, t6) => e4 + t6), m10 = 1 === p7.length ? p7[0].data : new ArrayBuffer(c7), h9 = [0], d10 = [0];
    if (p7.length > 1) {
      const e4 = new Uint8Array(m10);
      for (let t6 = 0, r8 = 0; t6 < p7.length; t6++) {
        const i8 = p7[t6].data;
        e4.set(new Uint8Array(i8), r8), h9[t6] = r8, r8 += i8.byteLength, d10[t6] = i8.byteLength;
      }
    }
    const { blockWidth: y7, blockHeight: g8 } = this.getBlockWidthHeight(e3), x4 = await this.decodePixelBlock(m10, { format: "tiff", customOptions: { headerInfo: this._headerInfo, ifd: l10, offsets: h9, sizes: d10 }, width: y7, height: g8, planes: null, pixelType: null });
    if (null == x4) return null;
    let T4, I5, w5;
    if (o6 !== y7 || f10 !== g8) {
      let e4 = x4.mask;
      if (e4) for (T4 = 0; T4 < g8; T4++) if (w5 = T4 * y7, T4 < f10) for (I5 = o6; I5 < y7; I5++) e4[w5 + I5] = 0;
      else for (I5 = 0; I5 < y7; I5++) e4[w5 + I5] = 0;
      else for (e4 = new Uint8Array(y7 * g8), x4.mask = e4, T4 = 0; T4 < f10; T4++) for (w5 = T4 * y7, I5 = 0; I5 < o6; I5++) e4[w5 + I5] = 1;
    }
    return x4;
  }
  _getTileLocation(e3, t5, r7, i7 = false) {
    const { firstPyramidLevel: s4, blockBoundary: a6 } = this.rasterInfo.storageInfo, n7 = 0 === e3 ? 0 : e3 - (s4 - 1), { _headerInfo: o6 } = this;
    if (!o6) return null;
    const f10 = i7 ? o6.maskIFDs[n7] : 0 === n7 ? o6 == null ? void 0 : o6.ifds[0] : o6 == null ? void 0 : o6.pyramidIFDs[n7 - 1];
    if (!f10) return null;
    const l10 = D2(f10, o6), u9 = _3(f10, "TILEOFFSETS");
    if (void 0 === u9) return null;
    const p7 = _3(f10, "TILEBYTECOUNTS"), { minRow: c7, minCol: m10, maxRow: h9, maxCol: d10 } = a6[n7];
    if (t5 > h9 || r7 > d10 || t5 < c7 || r7 < m10) return null;
    const y7 = F3(f10, "IMAGEWIDTH"), x4 = F3(f10, "IMAGELENGTH"), T4 = F3(f10, "TILEWIDTH"), I5 = F3(f10, "TILELENGTH"), w5 = [];
    if (l10) {
      const { bandCount: e4 } = this.rasterInfo;
      for (let i8 = 0; i8 < e4; i8++) {
        const e5 = i8 * (h9 + 1) * (d10 + 1) + t5 * (d10 + 1) + r7;
        w5[i8] = { from: u9[e5], to: u9[e5] + p7[e5] - 1 };
      }
    } else {
      const e4 = t5 * (d10 + 1) + r7;
      w5.push({ from: u9[e4], to: u9[e4] + p7[e4] - 1 });
    }
    for (let g8 = 0; g8 < w5.length; g8++) if (null == w5[g8].from || !w5[g8].to || w5[g8].to < 0) return null;
    return { ranges: w5, ifd: f10, actualTileWidth: r7 === d10 && y7 % T4 || T4, actualTileHeight: t5 === h9 && x4 % I5 || I5 };
  }
  async _fetchAuxiliaryMetaData(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".aux.xml", { responseType: "xml", signal: e3 == null ? void 0 : e3.signal });
      return S2(t5);
    } catch {
      return null;
    }
  }
  async _fetchAuxiliaryTable(e3) {
    try {
      const { data: t5 } = await this.request(this.url + ".vat.dbf", { responseType: "array-buffer", signal: e3 == null ? void 0 : e3.signal }), r7 = r6.parse(t5);
      return (r7 == null ? void 0 : r7.recordSet) ? d4.fromJSON(r7.recordSet) : null;
    } catch {
      return null;
    }
  }
};
function k3(e3) {
  var _a, _b;
  const t5 = R2(e3), { width: r7, height: i7, tileWidth: s4, tileHeight: a6, planes: f10, pixelType: l10, compression: u9, firstPyramidLevel: c7, maximumPyramidLevel: m10, pyramidBlockWidth: h9, pyramidBlockHeight: d10, pyramidResolutions: y7, tileBoundary: g8, affine: T4, metadata: I5 } = t5, R3 = ((_a = t5.extent.spatialReference) == null ? void 0 : _a.wkt) || ((_b = t5.extent.spatialReference) == null ? void 0 : _b.wkid);
  let v5 = d8(R3), k4 = !!t5.isPseudoGeographic;
  null == v5 && (k4 = true, v5 = new g({ wkid: 3857 }));
  const P3 = new w({ ...t5.extent, spatialReference: v5 }), D5 = new j(P3 ? { x: P3.xmin, y: P3.ymax, spatialReference: v5 } : { x: 0, y: 0 }), O = new n3({ blockWidth: s4, blockHeight: a6, pyramidBlockWidth: h9, pyramidBlockHeight: d10, compression: u9, origin: D5, firstPyramidLevel: c7, maximumPyramidLevel: m10, pyramidResolutions: y7, blockBoundary: g8 }), L4 = new j({ x: (P3.xmax - P3.xmin) / r7, y: (P3.ymax - P3.ymin) / i7, spatialReference: v5 }), j4 = I5 ? { BandProperties: I5.bandProperties, DataType: I5.dataType } : {};
  let B2 = null;
  const z3 = F3(e3[0], "PHOTOMETRICINTERPRETATION"), A2 = _3(e3[0], "COLORMAP");
  if (z3 <= 3 && (A2 == null ? void 0 : A2.length) > 3 && A2.length % 3 == 0) {
    B2 = [];
    const e4 = A2.length / 3;
    for (let t6 = 0; t6 < e4; t6++) B2.push([t6, A2[t6] >>> 8, A2[t6 + e4] >>> 8, A2[t6 + 2 * e4] >>> 8]);
  }
  const C2 = new m3({ width: r7, height: i7, bandCount: f10, pixelType: l10, pixelSize: L4, storageInfo: O, spatialReference: v5, isPseudoSpatialReference: k4, keyProperties: j4, extent: P3, colormap: B2, statistics: I5 ? I5.statistics : null });
  if ((T4 == null ? void 0 : T4.length) && (C2.nativeExtent = new w({ xmin: -0.5, ymin: 0.5 - i7, xmax: r7 - 0.5, ymax: 0.5, spatialReference: v5 }), C2.transform = new y5({ polynomialOrder: 1, forwardCoefficients: [T4[2] + T4[0] / 2, T4[5] - T4[3] / 2, T4[0], T4[3], -T4[1], -T4[4]] }), C2.extent = C2.transform.forwardTransform(C2.nativeExtent), C2.pixelSize = new j({ x: (P3.xmax - P3.xmin) / r7, y: (P3.ymax - P3.ymin) / i7, spatialReference: v5 }), O.origin.x = -0.5, O.origin.y = 0.5), y7) {
    const { x: e4, y: t6 } = C2.pixelSize;
    y7.forEach((r8) => {
      r8.x *= e4, r8.y *= t6;
    });
  }
  return { imageInfo: t5, rasterInfo: C2 };
}
function P2(e3, t5) {
  if (t5.statistics = e3.statistics ?? t5.statistics, t5.histograms = e3.histograms, e3.histograms && null == t5.statistics && (t5.statistics = g4(e3.histograms)), e3.transform && null == t5.transform) {
    t5.transform = e3.transform, t5.nativeExtent = t5.extent;
    const r7 = t5.transform.forwardTransform(t5.nativeExtent);
    t5.pixelSize = new j({ x: (r7.xmax - r7.xmin) / t5.width, y: (r7.ymax - r7.ymin) / t5.height, spatialReference: t5.spatialReference }), t5.extent = r7;
  }
  t5.isPseudoSpatialReference && e3.spatialReference && (t5.spatialReference = e3.spatialReference, t5.extent.spatialReference = t5.nativeExtent.spatialReference = t5.storageInfo.origin.spatialReference = t5.spatialReference);
}
r([m()], v4.prototype, "_files", void 0), r([m()], v4.prototype, "_headerInfo", void 0), r([m()], v4.prototype, "_bufferSize", void 0), r([m({ type: String, json: { write: true } })], v4.prototype, "datasetFormat", void 0), v4 = r([a("esri.layers.support.rasterDatasets.TIFFRaster")], v4);
var D4 = v4;

// node_modules/@arcgis/core/layers/support/rasterDatasets/RasterFactory.js
var n6 = /* @__PURE__ */ new Map();
n6.set("MRF", { desc: "Meta Raster Format", constructor: b2 }), n6.set("TIFF", { desc: "GeoTIFF", constructor: D4 }), n6.set("RasterTileServer", { desc: "Raster Tile Server", constructor: I3 }), n6.set("JPG", { desc: "JPG Raster Format", constructor: d9 }), n6.set("PNG", { desc: "PNG Raster Format", constructor: d9 }), n6.set("GIF", { desc: "GIF Raster Format", constructor: d9 }), n6.set("BMP", { desc: "BMP Raster Format", constructor: d9 }), n6.set("CovJSON", { desc: "COVJSON Raster Format", constructor: h7 }), n6.set("MEMORY", { desc: "In Memory Raster Format", constructor: g6 });
var u8 = class {
  static get supportedFormats() {
    const t5 = /* @__PURE__ */ new Set();
    return n6.forEach((r7, e3) => t5.add(e3)), t5;
  }
  static async open(r7) {
    var _a;
    const { url: e3, ioConfig: s4, source: o6, sourceJSON: a6 } = r7;
    let c7 = r7.datasetFormat ?? (s4 == null ? void 0 : s4.datasetFormat);
    null == c7 && (e3.includes(".") ? c7 = e3.slice(e3.lastIndexOf(".") + 1).toUpperCase() : "coverage" === ((_a = o6 == null ? void 0 : o6.type) == null ? void 0 : _a.toLowerCase()) ? c7 = "CovJSON" : (o6 == null ? void 0 : o6.extent) && o6.pixelblocks && (c7 = "MEMORY")), "OVR" === c7 || "TIF" === c7 ? c7 = "TIFF" : "JPG" === c7 || "JPEG" === c7 || "JFIF" === c7 ? c7 = "JPG" : "COVJSON" === c7 && (c7 = "CovJSON"), e3.toLowerCase().includes("/imageserver") && !e3.toLowerCase().includes("/wcsserver") && (c7 = "RasterTileServer");
    const u9 = { url: e3, source: o6, sourceJSON: a6, datasetFormat: c7, ioConfig: s4 ?? { bandIds: null, sampling: null } };
    if (Object.keys(u9).forEach((t5) => {
      null == u9[t5] && delete u9[t5];
    }), c7) {
      if (!this.supportedFormats.has(c7)) throw new s("rasterfactory:open", "not a supported format " + c7);
      if ("CRF" === c7) throw new s("rasterfactory:open", `cannot open raster: ${e3}`);
      const s5 = new (0, n6.get(c7).constructor)(u9);
      return await s5.open({ signal: r7.signal }), s5;
    }
    const i7 = Array.from(n6.keys()).filter((t5) => "CovJSON" !== t5 && "Memory" !== t5);
    let l10 = 0;
    const m10 = () => {
      if (c7 = i7[l10++], !c7) return null;
      if ("CRF" === c7) return null;
      const t5 = new (0, n6.get(c7).constructor)(u9);
      return t5.open({ signal: r7.signal }).then(() => t5).catch(() => m10());
    };
    return m10();
  }
  static register(t5, r7, e3) {
    n6.has(t5.toUpperCase()) || n6.set(t5.toUpperCase(), { desc: r7, constructor: e3 });
  }
};

// node_modules/@arcgis/core/layers/ImageryTileLayer.js
var L3 = class extends l2(t(b(j2(o3(e(K2(l5(l4(f3(S(i2(f2)))))))))))) {
  constructor(...e3) {
    super(...e3), this._primaryRasters = [], this.legendEnabled = true, this.isReference = null, this.listMode = "show", this.sourceJSON = null, this.version = null, this.type = "imagery-tile", this.operationalLayerType = "ArcGISTiledImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.fields = null, this.source = void 0, this._debouncedSaveOperations = k(async (e4, t5, r7) => {
      const { save: s4, saveAs: i7 } = await import("./imageryUtils-L4XFDLI3.js");
      switch (e4) {
        case A.SAVE:
          return s4(this, t5);
        case A.SAVE_AS:
          return i7(this, r7, t5);
      }
    });
  }
  normalizeCtorArgs(e3, t5) {
    return "string" == typeof e3 ? { url: e3, ...t5 } : e3;
  }
  load(e3) {
    const t5 = null != e3 ? e3.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e3).catch(a2).then(() => this._openRaster(t5))), Promise.resolve(this);
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get rasterFields() {
    var _a, _b;
    const e3 = [new y2({ name: "Raster.ServicePixelValue", alias: "Pixel Value", domain: null, editable: false, length: 50, type: "string" }), new y2({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Pixel Value", domain: null, editable: false, length: 50, type: "string" })], t5 = ((_a = this.raster) == null ? void 0 : _a.rasterInfo) ?? this.serviceRasterInfo, r7 = t5 == null ? void 0 : t5.attributeTable, s4 = null != r7 ? r7.fields : null, i7 = "Raster.";
    if (s4) {
      const t6 = s4.filter((e4) => "oid" !== e4.type && "value" !== e4.name.toLowerCase()).map((e4) => {
        const t7 = e4.clone();
        return t7.name = i7 + e4.name, t7;
      });
      e3.push(...t6);
    }
    const o6 = t5 == null ? void 0 : t5.dataType, a6 = t5 == null ? void 0 : t5.multidimensionalInfo;
    if (("vector-magdir" === o6 || "vector-uv" === o6) && null != a6) {
      const t6 = (_b = a6.variables[0].unit) == null ? void 0 : _b.trim(), r8 = "Magnitude" + (t6 ? ` (${t6})` : "");
      e3.push(new y2({ name: "Raster.Magnitude", alias: r8, domain: null, editable: false, type: "double" })), e3.push(new y2({ name: "Raster.Direction", alias: "Direction ()", domain: null, editable: false, type: "double" }));
    }
    return e3;
  }
  createPopupTemplate(e3) {
    const { rasterFields: t5 } = this, r7 = (e3 == null ? void 0 : e3.visibleFieldNames) ?? new Set(t5.map(({ name: e4 }) => e4).filter((e4) => "raster.servicepixelvalue.raw" !== e4.toLowerCase())), s4 = p2({ fields: t5, title: this.title }, { ...e3, visibleFieldNames: r7 }), { rasterInfo: i7 } = this.raster;
    return (s4 == null ? void 0 : s4.fieldInfos) && (i7 == null ? void 0 : i7.pixelType.startsWith("f")) && s4.fieldInfos.forEach(({ format: e4, fieldName: t6 }) => {
      e4 && t6 && /^raster\.(item|service)pixelvalue/i.test(t6) && (e4.places = 2);
    }), s4;
  }
  async generateRasterInfo(e3, t5) {
    var _a;
    if (e3 = h(N, e3), await this.load(), !e3 || "none" === ((_a = e3.functionName) == null ? void 0 : _a.toLowerCase())) return this.serviceRasterInfo;
    try {
      const { rasterInfo: r7 } = await this._openFunctionRaster(e3, t5);
      return r7;
    } catch (r7) {
      if (r7 instanceof s) throw r7;
      throw new s("imagery-tile-layer", "the given raster function is not supported");
    }
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, t5) {
    return this._debouncedSaveOperations(A.SAVE_AS, t5, e3);
  }
  write(e3, t5) {
    const r7 = this._primaryRasters[0] ?? this.raster;
    if (this.loaded ? "RasterTileServer" === r7.datasetFormat && ("Raster" === r7.tileType || "Map" === r7.tileType) : this.url && /\/ImageServer(\/|\/?$)/i.test(this.url)) return super.write(e3, t5);
    if (t5 == null ? void 0 : t5.messages) {
      const e4 = `${t5.origin}/${t5.layerContainerType || "operational-layers"}`;
      t5.messages.push(new s("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e4}'`, { layer: this }));
    }
    return null;
  }
  async _openRaster(e3) {
    var _a;
    let t5 = false;
    if (this.raster) await this._openFromRaster(this.raster, e3), t5 = "Function" === this.raster.datasetFormat, !t5 && this.rasterFunction && (this._primaryRasters = [this.raster], await this._initializeWithFunctionRaster(this.rasterFunction));
    else {
      const { url: t6, rasterFunction: r8, source: i7 } = this;
      if (!t6 && !i7) throw new s("imagery-tile-layer:open", "missing url or source parameter");
      i7 ? await this._openFromSource(i7, e3) : r8 ? await this._openFromUrlWithRasterFunction(t6, r8, e3) : await this._openFromUrl(t6, e3);
    }
    const r7 = this.raster.rasterInfo;
    if (!r7) throw new s("imagery-tile-layer:load", "cannot load resources on " + this.url);
    if (this._set("serviceRasterInfo", t5 ? r7 : this._primaryRasters[0].rasterInfo), this._set("spatialReference", r7.spatialReference), this.sourceJSON = this.sourceJSON || this.raster.sourceJSON, null != this.sourceJSON) {
      const e4 = "Map" === this.raster.tileType && null != this.sourceJSON.minLOD && null != this.sourceJSON.maxLOD ? this.sourceJSON : { ...this.sourceJSON, minScale: 0, maxScale: 0 };
      this.read(e4, { origin: "service" });
    } else this.read({ tileInfo: (_a = this.serviceRasterInfo) == null ? void 0 : _a.storageInfo.tileInfo.toJSON() }, { origin: "service" });
    this.title || (this.title = this.raster.datasetName), "Map" === this.raster.tileType && (this.popupEnabled = false), this._configDefaultSettings(), this.addHandles(d(() => this.customParameters, (e4) => {
      this.raster && (this.raster.ioConfig.customFetchParameters = e4);
    }));
  }
  async _openFromRaster(e3, t5) {
    e3.rasterInfo || await e3.open({ signal: t5 }), this._primaryRasters = "Function" === e3.datasetFormat ? e3.primaryRasters.rasters : [e3], this.url || (this.url = this._primaryRasters[0].url);
  }
  async _openFromUrlWithRasterFunction(e3, t5, r7) {
    const i7 = [e3];
    t5 && w3(t5.toJSON(), i7);
    const o6 = await Promise.all(i7.map((e4) => u8.open({ url: e4, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: r7 }))), a6 = o6.findIndex((e4) => null == e4);
    if (a6 > -1) throw new s("imagery-tile-layer:open", `cannot open raster: ${i7[a6]}`);
    return this._primaryRasters = o6, this._initializeWithFunctionRaster(t5);
  }
  async _openFromUrl(e3, t5) {
    const r7 = await u8.open({ url: e3, sourceJSON: this.sourceJSON, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == r7) throw new s("imagery-tile-layer:open", `cannot open raster: ${e3}`);
    this._primaryRasters = [r7], this.raster = r7;
  }
  async _openFromSource(e3, t5) {
    var _a;
    const r7 = "the tiled imagery data source is not supported", i7 = "coverage" === ((_a = e3.type) == null ? void 0 : _a.toLowerCase()) ? "CovJSON" : e3.extent && e3.pixelBlock ? "MEMORY" : null;
    if (!i7) throw new s("imagery-tile-layer:open", r7);
    "MEMORY" === i7 && (e3 = { ...e3, pixelBlock: void 0, pixelBlocks: [e3.pixelBlock] });
    const o6 = await u8.open({ url: "", source: e3, datasetFormat: i7, ioConfig: { sampling: "closest", ...this.ioConfig, customFetchParameters: this.customParameters }, signal: t5 });
    if (null == o6) throw new s("imagery-tile-layer:open", r7);
    this._primaryRasters = [o6], this.rasterFunction ? await this._initializeWithFunctionRaster(this.rasterFunction) : this.raster = o6;
  }
  async _openFunctionRaster(e3, t5) {
    var _a;
    const r7 = { raster: this._primaryRasters[0] };
    this._primaryRasters.length > 1 && this._primaryRasters.forEach((e4) => r7[e4.url] = e4);
    const s4 = T3(((_a = e3.functionDefinition) == null ? void 0 : _a.toJSON()) ?? e3.toJSON(), r7), i7 = new u4({ rasterFunction: s4 });
    return await i7.open(t5), i7;
  }
  async _initializeWithFunctionRaster(e3, t5) {
    try {
      this.raster = await this._openFunctionRaster(e3, t5);
    } catch (r7) {
      r7 instanceof s && n.getLogger(this).error("imagery-tile-layer:open", r7.message), n.getLogger(this).warn("imagery-tile-layer:open", "the raster function cannot be applied and is removed"), this._set("rasterFunction", null), this.raster = this._primaryRasters[0];
    }
  }
};
r([m({ clonable: false })], L3.prototype, "_primaryRasters", void 0), r([m(d3)], L3.prototype, "legendEnabled", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], L3.prototype, "isReference", void 0), r([m({ type: ["show", "hide"] })], L3.prototype, "listMode", void 0), r([m({ json: { read: true, write: true } })], L3.prototype, "blendMode", void 0), r([m()], L3.prototype, "sourceJSON", void 0), r([m({ readOnly: true, json: { origins: { service: { read: { source: "currentVersion" } } } } })], L3.prototype, "version", void 0), r([m({ readOnly: true, json: { read: false } })], L3.prototype, "type", void 0), r([m({ type: ["ArcGISTiledImageServiceLayer"] })], L3.prototype, "operationalLayerType", void 0), r([m({ type: Boolean, value: true, json: { read: { source: "disablePopup", reader: (e3, t5) => !t5.disablePopup }, write: { target: "disablePopup", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
}, writer(e3, t5, r7) {
  t5[r7] = !e3;
} } } })], L3.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo", overridePolicy() {
  return { enabled: !this.loaded || "Raster" === this.raster.tileType };
} } } })], L3.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], L3.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, type: [y2] })], L3.prototype, "fields", void 0), r([m({ readOnly: true, type: [y2] })], L3.prototype, "rasterFields", null), r([m({ constructOnly: true })], L3.prototype, "source", void 0), L3 = r([a("esri.layers.ImageryTileLayer")], L3);
var J = L3;
export {
  J as default
};
//# sourceMappingURL=ImageryTileLayer-QQFRBCZL.js.map
