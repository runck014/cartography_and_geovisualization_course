import {
  B2 as B,
  C,
  p
} from "./chunk-6Y3EYMFI.js";
import "./chunk-IUDC3IP2.js";
import {
  t as t7
} from "./chunk-VNGYZRZ7.js";
import {
  t as t6
} from "./chunk-MNEG3JYG.js";
import {
  t as t5
} from "./chunk-H5UVFCWF.js";
import "./chunk-B6M4BAW6.js";
import "./chunk-NC54UIQU.js";
import {
  n as n8,
  o2 as o4,
  s as s3,
  t as t8
} from "./chunk-DQ6HUSR7.js";
import "./chunk-5CHZW6XY.js";
import "./chunk-BOYBHWD5.js";
import "./chunk-PFCCTBQ6.js";
import "./chunk-P5FRKGMR.js";
import "./chunk-BIXAM2NQ.js";
import "./chunk-ZVUCWHFM.js";
import "./chunk-DXUZMPT2.js";
import "./chunk-JW4HK5OB.js";
import "./chunk-4TH6XK6A.js";
import "./chunk-PVFZLQ5G.js";
import "./chunk-C2RS46RL.js";
import "./chunk-CQ5ECUDF.js";
import {
  t as t4
} from "./chunk-374X2AXO.js";
import {
  a as a3
} from "./chunk-W3O5CFJ6.js";
import "./chunk-HRP7POO2.js";
import "./chunk-JVGNMUKK.js";
import "./chunk-X2UYZD2B.js";
import "./chunk-JQJITHTO.js";
import "./chunk-6LGJYARD.js";
import "./chunk-N42IF4WX.js";
import {
  e as e6
} from "./chunk-L7OHH2HW.js";
import {
  n as n5,
  n2 as n6,
  o2,
  o3,
  t as t2,
  t2 as t3
} from "./chunk-QUNX5MWD.js";
import "./chunk-URK2P56F.js";
import {
  r as r3
} from "./chunk-HLELEQS5.js";
import {
  e as e5,
  i as i4,
  n as n7
} from "./chunk-MA2KDKKH.js";
import "./chunk-I2OLSNCI.js";
import {
  l as l2
} from "./chunk-2KYWMOKS.js";
import {
  n as n4,
  s as s2
} from "./chunk-U5TYWISK.js";
import {
  e as e4,
  f,
  l as l4,
  o
} from "./chunk-QYBCLVRN.js";
import "./chunk-VMQKPMJK.js";
import "./chunk-A7PB2PTS.js";
import {
  E as E2,
  L,
  O,
  c as c2,
  i as i3,
  x
} from "./chunk-RFXYK5PV.js";
import "./chunk-LTCEJX6G.js";
import "./chunk-L6HI4BLZ.js";
import {
  e as e2
} from "./chunk-5FROWG6B.js";
import {
  e as e3,
  t
} from "./chunk-NW7VXBHZ.js";
import {
  a as a2
} from "./chunk-XTI4SH5M.js";
import {
  f as f2,
  i as i5
} from "./chunk-EHD5KM2T.js";
import "./chunk-QJXYURT2.js";
import "./chunk-BOSRS73G.js";
import {
  D
} from "./chunk-KV3S4QI2.js";
import {
  l as l3
} from "./chunk-ECMDQ4LS.js";
import {
  i as i2,
  j,
  n as n3
} from "./chunk-D6FJTDNK.js";
import "./chunk-LP6TMAPE.js";
import {
  A as A2,
  E,
  I,
  c,
  i,
  r as r2
} from "./chunk-RENLZYKC.js";
import "./chunk-CTU2XDPA.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-GZFJKWTS.js";
import {
  r
} from "./chunk-XQH2QDB2.js";
import "./chunk-LPNAPHOF.js";
import {
  l,
  q
} from "./chunk-IOKAACTA.js";
import {
  h
} from "./chunk-GNWAZIVF.js";
import "./chunk-2TEGRXBS.js";
import {
  n as n2,
  u
} from "./chunk-6Y2LNRVP.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-Z2DWZ5IF.js";
import "./chunk-TKY5RBM3.js";
import "./chunk-SIQNRYEG.js";
import "./chunk-TTDEVHSF.js";
import {
  _
} from "./chunk-QSRFVAIF.js";
import "./chunk-X6JBJVM2.js";
import "./chunk-A3J7W53Y.js";
import "./chunk-HLF5XJSV.js";
import "./chunk-L6D73M4D.js";
import "./chunk-H6RIEXAG.js";
import "./chunk-Y6AYXNMP.js";
import {
  A
} from "./chunk-6YWQXXBX.js";
import "./chunk-DRBJFCLQ.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-E2X3OBBC.js";
import {
  U
} from "./chunk-X7VTUWCX.js";
import "./chunk-QS62R4CH.js";
import "./chunk-VU6O6TFT.js";
import "./chunk-GD4XDYZL.js";
import "./chunk-33ECLFFF.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-L6CCOEVE.js";
import {
  a
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  e2 as e
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/views/3d/glTF/internal/TextureTransformUtils.js
function s4(s6) {
  if (null == s6) return null;
  const a4 = null != s6.offset ? s6.offset : i5, n9 = null != s6.rotation ? s6.rotation : 0, e7 = null != s6.scale ? s6.scale : f2, f3 = t(1, 0, 0, 0, 1, 0, a4[0], a4[1], 1), c3 = t(Math.cos(n9), -Math.sin(n9), 0, Math.sin(n9), Math.cos(n9), 0, 0, 0, 1), m = t(e7[0], 0, 0, 0, e7[1], 0, 0, 0, 1), u2 = e3();
  return i2(u2, c3, m), i2(u2, f3, u2), u2;
}

// node_modules/@arcgis/core/views/3d/layers/graphics/ProcessedObjectResource.js
var s5 = class {
  constructor() {
    this.geometries = new Array(), this.materials = new Array(), this.textures = new Array();
  }
};
var t9 = class {
  constructor(t10, e7, r4) {
    this.name = t10, this.lodThreshold = e7, this.pivotOffset = r4, this.stageResources = new s5(), this.numberOfVertices = 0;
  }
};

// node_modules/@arcgis/core/views/3d/layers/graphics/wosrLoader.js
var v = () => n.getLogger("esri.views.3d.layers.graphics.objectResourceUtils");
async function A3(e7, t10) {
  const n9 = await j2(e7, t10), s6 = await E3(n9.textureDefinitions ?? {}, t10);
  let a4 = 0;
  for (const r4 in s6) if (s6.hasOwnProperty(r4)) {
    const e8 = s6[r4];
    a4 += (e8 == null ? void 0 : e8.image) ? e8.image.width * e8.image.height * 4 : 0;
  }
  return { resource: n9, textures: s6, size: a4 + e(n9) };
}
async function j2(r4, n9) {
  const s6 = n9 == null ? void 0 : n9.streamDataRequester;
  if (s6) return I2(r4, s6, n9);
  const a4 = await _(U(r4, n9));
  if (true === a4.ok) return a4.value.data;
  a(a4.error), P(a4.error);
}
async function I2(e7, r4, n9) {
  const s6 = await _(r4.request(e7, "json", n9));
  if (true === s6.ok) return s6.value;
  a(s6.error), P(s6.error.details.url);
}
function P(e7) {
  throw new s("", `Request for object resource failed: ${e7}`);
}
function M(e7) {
  const t10 = e7.params, r4 = t10.topology;
  let n9 = true;
  switch (t10.vertexAttributes || (v().warn("Geometry must specify vertex attributes"), n9 = false), t10.topology) {
    case "PerAttributeArray":
      break;
    case "Indexed":
    case null:
    case void 0: {
      const e8 = t10.faces;
      if (e8) {
        if (t10.vertexAttributes) for (const r5 in t10.vertexAttributes) {
          const t11 = e8[r5];
          (t11 == null ? void 0 : t11.values) ? (null != t11.valueType && "UInt32" !== t11.valueType && (v().warn(`Unsupported indexed geometry indices type '${t11.valueType}', only UInt32 is currently supported`), n9 = false), null != t11.valuesPerElement && 1 !== t11.valuesPerElement && (v().warn(`Unsupported indexed geometry values per element '${t11.valuesPerElement}', only 1 is currently supported`), n9 = false)) : (v().warn(`Indexed geometry does not specify face indices for '${r5}' attribute`), n9 = false);
        }
      } else v().warn("Indexed geometries must specify faces"), n9 = false;
      break;
    }
    default:
      v().warn(`Unsupported topology '${r4}'`), n9 = false;
  }
  e7.params.material || (v().warn("Geometry requires material"), n9 = false);
  const s6 = e7.params.vertexAttributes;
  for (const a4 in s6) {
    s6[a4].values || (v().warn("Geometries with externally defined attributes are not yet supported"), n9 = false);
  }
  return n9;
}
function T(e7, t10) {
  var _a, _b;
  const r4 = new Array(), n9 = new Array(), s6 = new Array(), o5 = new t6(), u2 = e7.resource, c3 = r.parse(u2.version || "1.0", "wosr");
  q2.validate(c3);
  const p2 = u2.model.name, g = u2.model.geometries, h2 = u2.materialDefinitions ?? {}, v2 = e7.textures;
  let A4 = 0;
  const j3 = /* @__PURE__ */ new Map();
  for (let a4 = 0; a4 < g.length; a4++) {
    const e8 = g[a4];
    if (!M(e8)) continue;
    const i6 = k(e8), u3 = e8.params.vertexAttributes, c4 = [], p3 = (t11) => {
      if ("PerAttributeArray" === e8.params.topology) return null;
      const r5 = e8.params.faces;
      for (const e9 in r5) if (e9 === t11) return r5[e9].values;
      return null;
    }, I3 = u3[e6.POSITION], P2 = I3.values.length / I3.valuesPerElement;
    for (const t11 in u3) {
      const e9 = u3[t11], r5 = e9.values, n10 = p3(t11) ?? l2(P2);
      c4.push([t11, new t4(r5, n10, e9.valuesPerElement, true)]);
    }
    const T2 = i6.texture, U3 = v2 && v2[T2];
    if (U3 && !j3.has(T2)) {
      const { image: e9, parameters: t11 } = U3, r5 = new C(e9, t11);
      n9.push(r5), j3.set(T2, r5);
    }
    const E4 = j3.get(T2), q3 = E4 ? E4.id : void 0, R = i6.material;
    let B2 = o5.get(R, T2);
    if (null == B2) {
      const e9 = h2[R.slice(R.lastIndexOf("/") + 1)].params;
      1 === e9.transparency && (e9.transparency = 0);
      const r5 = U3 && U3.alphaChannelUsage, n10 = e9.transparency > 0 || "transparency" === r5 || "maskAndTransparency" === r5, s7 = U3 ? O2(U3.alphaChannelUsage) : void 0, a5 = { ambient: u(e9.diffuse), diffuse: u(e9.diffuse), opacity: 1 - (e9.transparency || 0), transparent: n10, textureAlphaMode: s7, textureAlphaCutoff: 0.33, textureId: q3, initTextureTransparent: true, doubleSided: true, cullFace: e5.None, colorMixMode: e9.externalColorMixMode || "tint", textureAlphaPremultiplied: (U3 == null ? void 0 : U3.parameters.preMultiplyAlpha) ?? false };
      (t10 == null ? void 0 : t10.materialParameters) && Object.assign(a5, t10.materialParameters), B2 = new B(a5, t10), o5.set(R, T2, B2);
    }
    s6.push(B2);
    const C2 = new p(B2, c4);
    A4 += ((_b = (_a = c4.find((e9) => e9[0] === e6.POSITION)) == null ? void 0 : _a[1]) == null ? void 0 : _b.indices.length) ?? 0, r4.push(C2);
  }
  return { engineResources: [{ name: p2, stageResources: { textures: n9, materials: s6, geometries: r4 }, pivotOffset: u2.model.pivotOffset, numberOfVertices: A4, lodThreshold: null }], referenceBoundingBox: U2(r4) };
}
function U2(e7) {
  const t10 = q();
  return e7.forEach((e8) => {
    const r4 = e8.boundingInfo;
    null != r4 && (l(t10, r4.bbMin), l(t10, r4.bbMax));
  }), t10;
}
async function E3(e7, t10) {
  const r4 = new Array();
  for (const a4 in e7) {
    const n10 = e7[a4], s7 = n10.images[0].data;
    if (!s7) {
      v().warn("Externally referenced texture data is not yet supported");
      continue;
    }
    const o5 = n10.encoding + ";base64," + s7, i6 = "/textureDefinitions/" + a4, l5 = "rgba" === n10.channels ? n10.alphaChannelUsage || "transparency" : "none", u2 = { noUnpackFlip: true, wrap: { s: D.REPEAT, t: D.REPEAT }, preMultiplyAlpha: O2(l5) !== i4.Opaque }, c3 = (t10 == null ? void 0 : t10.disableTextures) ? Promise.resolve(null) : t7(o5, t10);
    r4.push(c3.then((e8) => ({ refId: i6, image: e8, parameters: u2, alphaChannelUsage: l5 })));
  }
  const n9 = await Promise.all(r4), s6 = {};
  for (const a4 of n9) s6[a4.refId] = a4;
  return s6;
}
function O2(e7) {
  switch (e7) {
    case "mask":
      return i4.Mask;
    case "maskAndTransparency":
      return i4.MaskBlend;
    case "none":
      return i4.Opaque;
    default:
      return i4.Blend;
  }
}
function k(e7) {
  const t10 = e7.params;
  return { id: 1, material: t10.material, texture: t10.texture, region: t10.texture };
}
var q2 = new r(1, 2, "wosr");

// node_modules/@arcgis/core/views/3d/layers/graphics/objectResourceUtils.js
async function ee(t10, r4) {
  var _a;
  const o5 = te(a2(t10));
  if ("wosr" === o5.fileType) {
    const e7 = await (r4.cache ? r4.cache.loadWOSR(o5.url, r4) : A3(o5.url, r4)), { engineResources: t11, referenceBoundingBox: s7 } = T(e7, r4);
    return { lods: t11, referenceBoundingBox: s7, isEsriSymbolResource: false, isWosr: true };
  }
  let s6;
  if (r4.cache) s6 = await r4.cache.loadGLTF(o5.url, r4, !!r4.usePBR);
  else {
    const { loadGLTF: e7 } = await import("./loader-AEW3CTDX.js");
    s6 = await e7(new n6(r4.streamDataRequester), o5.url, r4, r4.usePBR);
  }
  const i6 = (_a = s6.model.meta) == null ? void 0 : _a.ESRI_proxyEllipsoid, n9 = s6.meta.isEsriSymbolResource && null != i6 && "EsriRealisticTreesStyle" === s6.meta.ESRI_webstyle;
  n9 && !s6.customMeta.esriTreeRendering && (s6.customMeta.esriTreeRendering = true, ae(s6, i6));
  const a4 = !!r4.usePBR, l5 = s6.meta.isEsriSymbolResource ? { usePBR: a4, isSchematic: false, treeRendering: n9, mrrFactors: s3 } : { usePBR: a4, isSchematic: false, treeRendering: false, mrrFactors: t8 }, u2 = { ...r4.materialParameters, treeRendering: n9 }, { engineResources: c3, referenceBoundingBox: m } = re(s6, l5, u2, r4, o5.specifiedLodIndex);
  return { lods: c3, referenceBoundingBox: m, isEsriSymbolResource: s6.meta.isEsriSymbolResource, isWosr: false };
}
function te(e7) {
  const t10 = e7.match(/(.*\.(gltf|glb))(\?lod=([0-9]+))?$/);
  if (t10) return { fileType: "gltf", url: t10[1], specifiedLodIndex: null != t10[4] ? Number(t10[4]) : null };
  return e7.match(/(.*\.(json|json\.gz))$/) ? { fileType: "wosr", url: e7, specifiedLodIndex: null } : { fileType: "unknown", url: e7, specifiedLodIndex: null };
}
function re(e7, t10, r4, o5, s6) {
  const i6 = e7.model, n9 = new Array(), a4 = /* @__PURE__ */ new Map(), l5 = /* @__PURE__ */ new Map(), u2 = i6.lods.length, c3 = q();
  return i6.lods.forEach((e8, m) => {
    const f3 = true === o5.skipHighLods && (u2 > 1 && 0 === m || u2 > 3 && 1 === m) || false === o5.skipHighLods && null != s6 && m !== s6;
    if (f3 && 0 !== m) return;
    const d = new t9(e8.name, e8.lodThreshold, [0, 0, 0]);
    e8.parts.forEach((e9) => {
      const s7 = f3 ? new B({}, o5) : oe(i6, e9, d, t10, r4, a4, l5, o5), { geometry: n10, vertexCount: u3 } = se(e9, s7 ?? new B({}, o5)), p2 = n10.boundingInfo;
      null != p2 && 0 === m && (l(c3, p2.bbMin), l(c3, p2.bbMax)), null != s7 && (d.stageResources.geometries.push(n10), d.numberOfVertices += u3);
    }), f3 || n9.push(d);
  }), { engineResources: n9, referenceBoundingBox: c3 };
}
function oe(e7, t10, r4, o5, s6, i6, n9, l5) {
  var _a, _b;
  const u2 = t10.material + (t10.attributes.normal ? "_normal" : "") + (t10.attributes.color ? "_color" : "") + (t10.attributes.texCoord0 ? "_texCoord0" : "") + (t10.attributes.tangent ? "_tangent" : ""), c3 = e7.materials.get(t10.material), m = null != t10.attributes.texCoord0, f3 = null != t10.attributes.normal;
  if (null == c3) return null;
  const d = ne(c3.alphaMode);
  if (!i6.has(u2)) {
    if (m) {
      const t11 = (t12, r6 = false) => {
        if (null != t12 && !n9.has(t12)) {
          const o6 = e7.textures.get(t12);
          if (null != o6) {
            const e8 = o6.data;
            n9.set(t12, new C(r3(e8) ? e8.data : e8, { ...o6.parameters, preMultiplyAlpha: !r3(e8) && r6, encoding: r3(e8) && null != e8.encoding ? e8.encoding : void 0 }));
          }
        }
      };
      t11(c3.textureColor, d !== i4.Opaque), t11(c3.textureNormal), t11(c3.textureOcclusion), t11(c3.textureEmissive), t11(c3.textureMetallicRoughness);
    }
    const r5 = c3.color[0] ** (1 / o3), p3 = c3.color[1] ** (1 / o3), g = c3.color[2] ** (1 / o3), x2 = c3.emissiveFactor[0] ** (1 / o3), b = c3.emissiveFactor[1] ** (1 / o3), h2 = c3.emissiveFactor[2] ** (1 / o3), T2 = null != c3.textureColor && m ? n9.get(c3.textureColor) : null, y = n8({ normalTexture: c3.textureNormal, metallicRoughnessTexture: c3.textureMetallicRoughness, metallicFactor: c3.metallicFactor, roughnessFactor: c3.roughnessFactor, emissiveTexture: c3.textureEmissive, emissiveFactor: c3.emissiveFactor, occlusionTexture: c3.textureOcclusion }), w = null != ((_a = c3.normalTextureTransform) == null ? void 0 : _a.scale) ? (_b = c3.normalTextureTransform) == null ? void 0 : _b.scale : l3;
    i6.set(u2, new B({ ...o5, transparent: d === i4.Blend, customDepthTest: n7.Lequal, textureAlphaMode: d, textureAlphaCutoff: c3.alphaCutoff, diffuse: [r5, p3, g], ambient: [r5, p3, g], opacity: c3.opacity, doubleSided: c3.doubleSided, doubleSidedType: "winding-order", cullFace: c3.doubleSided ? e5.None : e5.Back, hasVertexColors: !!t10.attributes.color, hasVertexTangents: !!t10.attributes.tangent, normalType: f3 ? a3.Attribute : a3.ScreenDerivative, castShadows: true, receiveShadows: c3.receiveShadows, receiveAmbientOcclusion: c3.receiveAmbientOcclustion, textureId: null != T2 ? T2.id : void 0, colorMixMode: c3.colorMixMode, normalTextureId: null != c3.textureNormal && m ? n9.get(c3.textureNormal).id : void 0, textureAlphaPremultiplied: null != T2 && !!T2.parameters.preMultiplyAlpha, occlusionTextureId: null != c3.textureOcclusion && m ? n9.get(c3.textureOcclusion).id : void 0, emissiveTextureId: null != c3.textureEmissive && m ? n9.get(c3.textureEmissive).id : void 0, metallicRoughnessTextureId: null != c3.textureMetallicRoughness && m ? n9.get(c3.textureMetallicRoughness).id : void 0, emissiveFactor: [x2, b, h2], mrrFactors: y ? o4 : [c3.metallicFactor, c3.roughnessFactor, o5.mrrFactors[2]], isSchematic: y, colorTextureTransformMatrix: s4(c3.colorTextureTransform), normalTextureTransformMatrix: s4(c3.normalTextureTransform), scale: [w[0], w[1]], occlusionTextureTransformMatrix: s4(c3.occlusionTextureTransform), emissiveTextureTransformMatrix: s4(c3.emissiveTextureTransform), metallicRoughnessTextureTransformMatrix: s4(c3.metallicRoughnessTextureTransform), ...s6 }, l5));
  }
  const p2 = i6.get(u2);
  if (r4.stageResources.materials.push(p2), m) {
    const e8 = (e9) => {
      null != e9 && r4.stageResources.textures.push(n9.get(e9));
    };
    e8(c3.textureColor), e8(c3.textureNormal), e8(c3.textureOcclusion), e8(c3.textureEmissive), e8(c3.textureMetallicRoughness);
  }
  return p2;
}
function se(e7, s6) {
  const i6 = e7.attributes.position.count, n9 = o2(e7.indices || i6, e7.primitiveType), a4 = t5(3 * i6), { typedBuffer: l5, typedBufferStride: u2 } = e7.attributes.position;
  e4(a4, l5, e7.transform, 3, u2);
  const c3 = [[e6.POSITION, new t4(a4, n9, 3, true)]];
  if (null != e7.attributes.normal) {
    const o5 = t5(3 * i6), { typedBuffer: s7, typedBufferStride: a5 } = e7.attributes.normal;
    j(ie, e7.transform), f(o5, s7, ie, 3, a5), A(ie) && l4(o5, o5), c3.push([e6.NORMAL, new t4(o5, n9, 3, true)]);
  }
  if (null != e7.attributes.tangent) {
    const r4 = t5(4 * i6), { typedBuffer: s7, typedBufferStride: a5 } = e7.attributes.tangent;
    n3(ie, e7.transform), n4(r4, s7, ie, 4, a5), A(ie) && l4(r4, r4, 4), c3.push([e6.TANGENT, new t4(r4, n9, 4, true)]);
  }
  if (null != e7.attributes.texCoord0) {
    const t10 = t5(2 * i6), { typedBuffer: r4, typedBufferStride: o5 } = e7.attributes.texCoord0;
    n5(t10, r4, 2, o5), c3.push([e6.UV0, new t4(t10, n9, 2, true)]);
  }
  const m = e7.attributes.color;
  if (null != m) {
    const t10 = new Uint8Array(4 * i6);
    4 === m.elementCount ? m instanceof c2 ? s2(t10, m, 255) : m instanceof x ? t3(t10, m) : m instanceof L && s2(t10, m, 1 / 256) : (t10.fill(255), m instanceof i3 ? o(t10, m.typedBuffer, 255, 4, m.typedBufferStride) : e7.attributes.color instanceof O ? t2(t10, m.typedBuffer, 4, e7.attributes.color.typedBufferStride) : e7.attributes.color instanceof E2 && o(t10, m.typedBuffer, 1 / 256, 4, m.typedBufferStride)), c3.push([e6.COLOR, new t4(t10, n9, 4, true)]);
  }
  return { geometry: new p(s6, c3), vertexCount: i6 };
}
var ie = e3();
function ne(e7) {
  switch (e7) {
    case "BLEND":
      return i4.Blend;
    case "MASK":
      return i4.Mask;
    case "OPAQUE":
    case null:
    case void 0:
      return i4.Opaque;
  }
}
function ae(e7, t10) {
  for (let r4 = 0; r4 < e7.model.lods.length; ++r4) {
    const o5 = e7.model.lods[r4];
    for (const s6 of o5.parts) {
      const o6 = s6.attributes.normal;
      if (null == o6) return;
      const a4 = s6.attributes.position, g = a4.count, x2 = n2(), b = n2(), h2 = n2(), y = new Uint8Array(4 * g), v2 = new Float64Array(3 * g), R = h(e2(), s6.transform);
      let j3 = 0, B2 = 0;
      for (let i6 = 0; i6 < g; i6++) {
        a4.getVec(i6, b), o6.getVec(i6, x2), E(b, b, s6.transform), c(h2, b, t10.center), i(h2, h2, t10.radius);
        const n9 = h2[2], p2 = r2(h2), g2 = Math.min(0.45 + 0.55 * p2 * p2, 1);
        i(h2, h2, t10.radius), null !== R && E(h2, h2, R), A2(h2, h2), r4 + 1 !== e7.model.lods.length && e7.model.lods.length > 1 && I(h2, h2, x2, n9 > -1 ? 0.2 : Math.min(-4 * n9 - 3.8, 1)), v2[j3] = h2[0], v2[j3 + 1] = h2[1], v2[j3 + 2] = h2[2], j3 += 3, y[B2] = 255 * g2, y[B2 + 1] = 255 * g2, y[B2 + 2] = 255 * g2, y[B2 + 3] = 255, B2 += 4;
      }
      s6.attributes.normal = new i3(v2), s6.attributes.color = new x(y);
    }
  }
}
export {
  ee as fetch,
  te as parseUrl
};
//# sourceMappingURL=objectResourceUtils-OUXN62SK.js.map
