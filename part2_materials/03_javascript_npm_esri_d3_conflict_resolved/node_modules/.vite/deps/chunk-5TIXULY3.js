import {
  d as d2,
  i,
  t
} from "./chunk-J6GHQIZ2.js";
import {
  d,
  v2 as v
} from "./chunk-VUJERGGB.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  I2 as I,
  O2 as O,
  P2 as P
} from "./chunk-E2I7HYXQ.js";
import {
  h
} from "./chunk-7LJCT7EA.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/geometry/support/geodesicUtils.js
function u(e) {
  if (!e) return null;
  const t2 = e.wkid;
  if (t2) return d2[t2];
  const n = e.wkt2 ?? e.wkt;
  return n ? m(n) : null;
}
function m(e) {
  const t2 = t.exec(e);
  if (!t2 || 2 !== t2.length) return null;
  const n = t2[1].split(",");
  if (!n || n.length < 3) return null;
  const s3 = parseFloat(n[1]), i2 = parseFloat(n[2]);
  if (isNaN(s3) || isNaN(i2)) return null;
  return { a: s3, f: 0 === i2 ? 0 : 1 / i2 };
}
function d3(e) {
  const t2 = u(e);
  if (g2(t2)) return t2;
  const n = t2.a * (1 - t2.f);
  return Object.assign(t2, { b: n, eSq: 1 - (n / t2.a) ** 2, radius: (2 * t2.a + n) / 3, densificationRatio: 1e4 / ((2 * t2.a + n) / 3) });
}
function g2(e) {
  return null != e && "b" in e && "eSq" in e && "radius" in e;
}
function w(e, t2, n) {
  const { a: i2, eSq: r } = d3(n), a = Math.sqrt(r), o = Math.sin(t2[1] * i), c = i2 * t2[0] * i;
  let h2;
  if (r > 0) {
    h2 = i2 * ((1 - r) * (o / (1 - r * (o * o)) - 1 / (2 * a) * Math.log((1 - a * o) / (1 + a * o)))) * 0.5;
  } else h2 = i2 * o;
  return e[0] = c, e[1] = h2, e;
}
function y(e) {
  return P(e) && !!u(e);
}
function v2(n, s3 = "square-meters") {
  if (n.some((e) => !y(e.spatialReference))) throw new s("geodesic-areas:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const i2 = [];
  for (let e = 0; e < n.length; e++) {
    const t2 = n[e], s4 = t2.spatialReference, { radius: r2, densificationRatio: a2 } = d3(s4), o2 = r2 * a2;
    i2.push(z(t2, o2));
  }
  const r = [], a = [0, 0], o = [0, 0];
  for (let e = 0; e < i2.length; e++) {
    const { rings: n2, spatialReference: c } = i2[e];
    let h2 = 0;
    for (let e2 = 0; e2 < n2.length; e2++) {
      const t2 = n2[e2];
      w(a, t2[0], c), w(o, t2[t2.length - 1], c);
      let s4 = o[0] * a[1] - a[0] * o[1];
      for (let e3 = 0; e3 < t2.length - 1; e3++) w(a, t2[e3 + 1], c), w(o, t2[e3], c), s4 += o[0] * a[1] - a[0] * o[1];
      h2 += s4;
    }
    h2 = I(h2, "square-meters", s3), r.push(h2 / -2);
  }
  return r;
}
function R(n, s3 = "meters") {
  if (!n) throw new s("geodesic-lengths:invalid-geometries", "the input geometries type is not supported");
  if (n.some((e) => !y(e.spatialReference))) throw new s("geodesic-lengths:invalid-spatial-reference", "the input geometries spatial reference is not supported");
  const i2 = [];
  for (let e = 0; e < n.length; e++) {
    const r = n[e], { spatialReference: a } = r, o = "polyline" === r.type ? r.paths : r.rings;
    let c = 0;
    for (let e2 = 0; e2 < o.length; e2++) {
      const t2 = o[e2];
      let n2 = 0;
      for (let e3 = 1; e3 < t2.length; e3++) {
        const s4 = t2[e3 - 1][0], i3 = t2[e3][0], r2 = t2[e3 - 1][1], o2 = t2[e3][1];
        if (r2 !== o2 || s4 !== i3) {
          const e4 = new b();
          q(e4, [s4, r2], [i3, o2], a), n2 += e4.distance;
        }
      }
      c += n2;
    }
    c = I(c, "meters", s3), i2.push(c);
  }
  return i2;
}
function z(t2, s3) {
  if ("polyline" !== t2.type && "polygon" !== t2.type) throw new s("geodesic-densify:invalid-geometry", "the input geometry is neither polyline nor polygon");
  const { spatialReference: i2 } = t2;
  if (!y(i2)) throw new s("geodesic-densify:invalid-spatial-reference", "the input geometry spatial reference is not supported");
  const r = "polyline" === t2.type ? t2.paths : t2.rings, a = [], o = [0, 0], c = new b();
  for (const e of r) {
    const t3 = [];
    a.push(t3), t3.push([e[0][0], e[0][1]]);
    let n, r2, h2 = e[0][0], l = e[0][1];
    for (let a2 = 0; a2 < e.length - 1; a2++) {
      if (n = e[a2 + 1][0], r2 = e[a2 + 1][1], h2 === n && l === r2) continue;
      const p = [h2, l];
      q(c, [h2, l], [n, r2], i2);
      const { azimuth: f2, distance: u2 } = c, m2 = u2 / s3;
      if (m2 > 1) {
        for (let e2 = 1; e2 <= m2 - 1; e2++) {
          j2(o, p, f2, e2 * s3, i2), t3.push(o.slice());
        }
        j2(o, p, f2, (u2 + Math.floor(m2 - 1) * s3) / 2, i2), t3.push(o.slice());
      }
      j2(o, p, f2, u2, i2), t3.push(o.slice()), h2 = o[0], l = o[1];
    }
  }
  const f = h(g, i2);
  return "polyline" === t2.type ? new d({ paths: a, spatialReference: f }) : new v({ rings: a, spatialReference: f });
}
var b = class {
  constructor(e = 0, t2 = void 0, n = void 0) {
    this.distance = e, this.azimuth = t2, this.reverseAzimuth = n;
  }
};
function j2(e, t2, n, i2, r) {
  const a = t2[0], o = t2[1], c = a * i, h2 = o * i, l = (n ?? 0) * i, { a: p, b: f, f: u2 } = d3(r), m2 = Math.sin(l), g3 = Math.cos(l), M = (1 - u2) * Math.tan(h2), w2 = 1 / Math.sqrt(1 + M * M), y2 = M * w2, v3 = Math.atan2(M, g3), R2 = w2 * m2, z2 = R2 * R2, b2 = 1 - z2, j3 = b2 * (p * p - f * f) / (f * f), q2 = 1 + j3 / 16384 * (4096 + j3 * (j3 * (320 - 175 * j3) - 768)), x = j3 / 1024 * (256 + j3 * (j3 * (74 - 47 * j3) - 128));
  let A, N2, S, P2, k = i2 / (f * q2), F = 2 * Math.PI;
  for (; Math.abs(k - F) > 1e-12; ) S = Math.cos(2 * v3 + k), A = Math.sin(k), N2 = Math.cos(k), P2 = x * A * (S + x / 4 * (N2 * (2 * S * S - 1) - x / 6 * S * (4 * A * A - 3) * (4 * S * S - 3))), F = k, k = i2 / (f * q2) + P2;
  const U = y2 * A - w2 * N2 * g3, C = Math.atan2(y2 * N2 + w2 * A * g3, (1 - u2) * Math.sqrt(z2 + U * U)), E = Math.atan2(A * m2, w2 * N2 - y2 * A * g3), G = u2 / 16 * b2 * (4 + u2 * (4 - 3 * b2)), I2 = C / i, O2 = (c + (E - (1 - G) * u2 * R2 * (k + G * A * (S + G * N2 * (2 * S * S - 1))))) / i;
  return e[0] = O2, e[1] = I2, e;
}
function q(e, t2, n, i2) {
  const r = t2[0] * i, a = t2[1] * i, o = n[0] * i, c = n[1] * i, { a: h2, b: l, f: p, radius: f } = d3(i2), u2 = o - r, m2 = Math.atan((1 - p) * Math.tan(a)), g3 = Math.atan((1 - p) * Math.tan(c)), M = Math.sin(m2), w2 = Math.cos(m2), y2 = Math.sin(g3), v3 = Math.cos(g3);
  let R2, z2, b2, j3, q2, x, A, N2, S, P2, k = 1e3, F = u2;
  do {
    if (A = Math.sin(F), N2 = Math.cos(F), b2 = Math.sqrt(v3 * A * (v3 * A) + (w2 * y2 - M * v3 * N2) * (w2 * y2 - M * v3 * N2)), 0 === b2) return e.distance = 0, e.azimuth = void 0, e.reverseAzimuth = void 0, e;
    q2 = M * y2 + w2 * v3 * N2, x = Math.atan2(b2, q2), S = w2 * v3 * A / b2, z2 = 1 - S * S, j3 = q2 - 2 * M * y2 / z2, isNaN(j3) && (j3 = 0), P2 = p / 16 * z2 * (4 + p * (4 - 3 * z2)), R2 = F, F = u2 + (1 - P2) * p * S * (x + P2 * b2 * (j3 + P2 * q2 * (2 * j3 * j3 - 1)));
  } while (Math.abs(F - R2) > 1e-12 && --k > 0);
  if (0 === k) {
    const t3 = f, n2 = Math.acos(Math.sin(a) * Math.sin(c) + Math.cos(a) * Math.cos(c) * Math.cos(o - r)) * t3, i3 = o - r, h3 = Math.sin(i3) * Math.cos(c), l2 = Math.cos(a) * Math.sin(c) - Math.sin(a) * Math.cos(c) * Math.cos(i3), p2 = Math.atan2(h3, l2);
    return e.azimuth = p2 / i, e.distance = n2, e.reverseAzimuth = void 0, e;
  }
  const U = z2 * (h2 * h2 - l * l) / (l * l), C = U / 1024 * (256 + U * (U * (74 - 47 * U) - 128)), E = l * (1 + U / 16384 * (4096 + U * (U * (320 - 175 * U) - 768))) * (x - C * b2 * (j3 + C / 4 * (q2 * (2 * j3 * j3 - 1) - C / 6 * j3 * (4 * b2 * b2 - 3) * (4 * j3 * j3 - 3)))), G = Math.atan2(v3 * Math.sin(F), w2 * y2 - M * v3 * Math.cos(F)), I2 = Math.atan2(w2 * Math.sin(F), w2 * y2 * Math.cos(F) - M * v3);
  return e.azimuth = G / i, e.distance = E, e.reverseAzimuth = I2 / i, e;
}
function N(e) {
  return y(e) ? e : O(e) ? g.WGS84 : null;
}

export {
  y,
  v2 as v,
  R,
  b,
  j2 as j,
  q,
  N
};
//# sourceMappingURL=chunk-5TIXULY3.js.map
