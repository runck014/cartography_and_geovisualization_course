import {
  l
} from "./chunk-ILNUTCMB.js";
import {
  l as l2
} from "./chunk-WXDWH77C.js";
import {
  t as t2
} from "./chunk-JKRG5WGH.js";
import {
  B,
  E as E2,
  L,
  M,
  N as N2,
  O as O2,
  R,
  T,
  a as a2,
  a2 as a3,
  b,
  c,
  e,
  f,
  k,
  q
} from "./chunk-YVV4HFCX.js";
import "./chunk-QV2O4XK2.js";
import {
  O,
  u
} from "./chunk-WS6USPRQ.js";
import {
  D
} from "./chunk-CTOH6SLG.js";
import {
  N
} from "./chunk-2HV3NVV7.js";
import {
  Be,
  E,
  J,
  Je,
  K,
  P,
  Se,
  U,
  V,
  W,
  X,
  Y,
  a,
  be,
  de,
  ee,
  he,
  ie,
  ne,
  r,
  te,
  v
} from "./chunk-6ZMDPECL.js";
import {
  y as y2
} from "./chunk-KSR45ZRP.js";
import {
  t
} from "./chunk-Q4J5AN2X.js";
import "./chunk-V256VJ5J.js";
import "./chunk-OJRG2YGM.js";
import "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import {
  Z
} from "./chunk-2BVPGUC2.js";
import {
  m
} from "./chunk-BN24XFSK.js";
import {
  Xe
} from "./chunk-NWZXTYBZ.js";
import "./chunk-UK4PA5E2.js";
import "./chunk-D4XQN7BI.js";
import "./chunk-C5QEEP7V.js";
import "./chunk-XECP56E2.js";
import "./chunk-ZTENQQ25.js";
import "./chunk-TGFVKJXH.js";
import "./chunk-ZZTUJWOP.js";
import "./chunk-SVRTKGNR.js";
import "./chunk-JED7FM2Q.js";
import "./chunk-FFUKJAFO.js";
import "./chunk-H4E2VVPD.js";
import "./chunk-CQFC4JO6.js";
import "./chunk-VS5MKM3H.js";
import "./chunk-CQTV4C3X.js";
import "./chunk-764E6KTP.js";
import "./chunk-GEPD6W23.js";
import "./chunk-QSIT7EPR.js";
import "./chunk-TP6LRQ42.js";
import "./chunk-ZE6OS33V.js";
import "./chunk-MWZJIOOL.js";
import "./chunk-ULSRCITK.js";
import "./chunk-FLUE3DMC.js";
import "./chunk-5GQ62KHN.js";
import "./chunk-YAGJS3MX.js";
import "./chunk-43KBLSS3.js";
import "./chunk-WH2FR6UE.js";
import "./chunk-RG7AMCT5.js";
import "./chunk-PV3ZZQOV.js";
import "./chunk-SM2VXWMT.js";
import "./chunk-WYO25WZZ.js";
import "./chunk-OC7D2HR4.js";
import "./chunk-IGMG7ERK.js";
import "./chunk-V47ZBW5W.js";
import "./chunk-HKYICNT2.js";
import "./chunk-VGUQMPM6.js";
import "./chunk-CTU2XDPA.js";
import "./chunk-KKH7HGO3.js";
import "./chunk-SUBGY5CE.js";
import "./chunk-Z3NV3VCK.js";
import "./chunk-7VNQKVOW.js";
import "./chunk-PNVXSHN2.js";
import "./chunk-3DVL3O3F.js";
import "./chunk-RN66FJAW.js";
import "./chunk-QYSQ6XPQ.js";
import "./chunk-2RIHQI4N.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-NXGNMEHZ.js";
import "./chunk-TWYDW6LU.js";
import "./chunk-PVHAAI32.js";
import "./chunk-MLATPUII.js";
import "./chunk-NVFQGMP6.js";
import "./chunk-P2IB5HBH.js";
import "./chunk-XX37BOHH.js";
import "./chunk-5CRXWQ3Y.js";
import "./chunk-4RFCLPAF.js";
import "./chunk-U3JQIAF6.js";
import "./chunk-BHQS42D6.js";
import "./chunk-4ISVH4NS.js";
import "./chunk-NIWINVGG.js";
import "./chunk-DOENTAA7.js";
import "./chunk-CVI4GL5M.js";
import "./chunk-CGSFKZP2.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-WPERPIJF.js";
import "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-BVHISPUT.js";
import "./chunk-QMGMKWTA.js";
import "./chunk-2EGO74J5.js";
import "./chunk-4SUK447J.js";
import "./chunk-2X7T37AY.js";
import "./chunk-XQH2QDB2.js";
import "./chunk-6Q7GN2CW.js";
import "./chunk-MYUZZ3A3.js";
import "./chunk-2IGXKE5P.js";
import "./chunk-JFI4ESYU.js";
import "./chunk-4X2UADDH.js";
import "./chunk-ZICJB3ML.js";
import "./chunk-AVBIV2K3.js";
import "./chunk-4NJWIUZG.js";
import "./chunk-F3NUC2RS.js";
import "./chunk-LE3YW4Y3.js";
import "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import "./chunk-P3GRQ2CH.js";
import "./chunk-NYLBGE62.js";
import "./chunk-LPNAPHOF.js";
import {
  y
} from "./chunk-QCBTLG25.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import "./chunk-VEUN2EF3.js";
import "./chunk-W6D3ECTZ.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-SEUZ3J6J.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-RCLWOQNR.js";
import "./chunk-DOTSJZHK.js";
import "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import {
  b as b2
} from "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import "./chunk-2WXAPZBK.js";
import "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import "./chunk-H77COA2S.js";
import "./chunk-7LJCT7EA.js";
import "./chunk-MV5XBD6C.js";
import {
  S
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function X2(e2) {
  if (1 === e2.length) {
    if (E(e2[0])) return l("distinct", e2[0], -1);
    if (X(e2[0])) return l("distinct", e2[0].toArray(), -1);
  }
  return l("distinct", e2, -1);
}
async function ee2(e2, t3, n) {
  const i = e2.getVariables();
  if (i.length > 0) {
    const a4 = [];
    for (let e3 = 0; e3 < i.length; e3++) {
      const r3 = { name: i[e3] };
      a4.push(await t3.evaluateIdentifier(n, r3));
    }
    const r2 = {};
    for (let e3 = 0; e3 < i.length; e3++) r2[i[e3]] = a4[e3];
    return e2.parameters = r2, e2;
  }
  return e2;
}
function te2(e2, t3, n = null) {
  for (const i in e2) if (i.toLowerCase() === t3.toLowerCase()) return e2[i];
  return n;
}
function ne2(e2) {
  if (null === e2) return null;
  const t3 = { type: te2(e2, "type", ""), name: te2(e2, "name", "") };
  if ("range" === t3.type) t3.range = te2(e2, "range", []);
  else {
    t3.codedValues = [];
    for (const n of te2(e2, "codedValues", [])) t3.codedValues.push({ name: te2(n, "name", ""), code: te2(n, "code", null) });
  }
  return t3;
}
function ie2(e2) {
  if (null === e2) return null;
  const t3 = {}, n = te2(e2, "wkt");
  null !== n && (t3.wkt = n);
  const i = te2(e2, "wkid");
  return null !== i && (t3.wkid = i), t3;
}
function ae(e2) {
  if (null === e2) return null;
  const t3 = { hasZ: te2(e2, "hasz", false), hasM: te2(e2, "hasm", false) }, n = te2(e2, "spatialreference");
  null != n && (t3.spatialReference = ie2(n));
  const i = te2(e2, "x", null);
  if (null !== i) return t3.x = i, t3.y = te2(e2, "y", null), t3.hasZ && (t3.z = te2(e2, "z", null)), t3.hasM && (t3.m = te2(e2, "m", null)), t3;
  const a4 = te2(e2, "rings", null);
  if (null !== a4) return t3.rings = a4, t3;
  const r2 = te2(e2, "paths", null);
  if (null !== r2) return t3.paths = r2, t3;
  const s = te2(e2, "points", null);
  if (null !== s) return t3.points = s, t3;
  for (const o of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n2 = te2(e2, o, null);
    null !== n2 && (t3[o] = n2);
  }
  return t3;
}
function re(e2, t3) {
  for (const n of t3) if (n === e2) return true;
  return false;
}
function se(e2) {
  return !!e2.layerDefinition && (!!e2.featureSet && (false !== re(e2.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== E(e2.layerDefinition.fields) && false !== E(e2.featureSet.features))));
}
function oe(e2) {
  return "utc" === (e2 == null ? void 0 : e2.toLowerCase()) ? "UTC" : "unknown" === (e2 == null ? void 0 : e2.toLowerCase()) ? "Unknown" : e2;
}
function le(q2) {
  "async" === q2.mode && (q2.functions.timezone = function(t3, r2) {
    return q2.standardFunctionAsync(t3, r2, async (s, o, l3) => {
      var _a, _b;
      if (ie(l3, 1, 2, t3, r2), ne(l3[0])) return "Unknown";
      if (te(l3[0])) return "Unknown";
      if (K(l3[0])) {
        if (await l3[0].load(), 1 === l3.length || null === l3[1]) return l3[0].datesInUnknownTimezone ? oe("unknown") : oe(l3[0].dateFieldsTimeZone);
        if (!(l3[1] instanceof N) || false === l3[1].hasField("type")) throw new a(t3, r.InvalidParameter, r2);
        const e2 = l3[1].field("type");
        if (false === P(e2)) throw new a(t3, r.InvalidParameter, r2);
        switch (de(e2).toLowerCase()) {
          case "preferredtimezone":
            return oe(l3[0].preferredTimeZone);
          case "editfieldsinfo":
            return oe(((_a = l3[0].editFieldsInfo) == null ? void 0 : _a.timeZone) ?? null);
          case "timeinfo":
            return oe(((_b = l3[0].timeInfo) == null ? void 0 : _b.timeZone) ?? null);
          case "field":
            if (l3[1].hasField("fieldname") && P(l3[1].field("fieldname"))) return oe(l3[0].fieldTimeZone(de(l3[1].field("fieldname"))));
        }
        throw new a(t3, r.InvalidParameter, r2);
      }
      const f2 = be(l3[0], Be(t3));
      if (null === f2) return null;
      const d = f2.timeZone;
      return "system" === d ? m.systemTimeZoneCanonicalName : "utc" === d.toLowerCase() ? "UTC" : "unknown" === d.toLowerCase() ? "Unknown" : d;
    });
  }, q2.functions.sqltimestamp = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      ie(s, 1, 3, e2, t3);
      const o = s[0];
      if (ee(o)) {
        if (1 === s.length) return o.toSQLWithKeyword();
        if (2 === s.length) return o.changeTimeZone(de(s[1])).toSQLWithKeyword();
        throw new a(e2, r.InvalidParameter, t3);
      }
      if (te(o)) return o.toSQLWithKeyword();
      if (K(o)) {
        if (3 !== s.length) throw new a(e2, r.InvalidParameter, t3);
        await o.load();
        const n2 = de(s[1]);
        if (te(s[2])) return s[2].toSQLWithKeyword();
        if (false === ee(s[2])) throw new a(e2, r.InvalidParameter, t3);
        const r3 = o.fieldTimeZone(n2);
        return null === r3 ? s[2].toSQLWithKeyword() : s[2].changeTimeZone(r3).toSQLWithKeyword();
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), q2.functions.featuresetbyid = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, (n, r2, s) => {
      if (ie(s, 2, 4, e2, t3), W(s[0])) {
        const n2 = de(s[1]);
        let r3 = Y(s[2], null);
        const o = Se(Y(s[3], true));
        if (null === r3 && (r3 = ["*"]), false === E(r3)) throw new a(e2, r.InvalidParameter, t3);
        return s[0].featureSetById(n2, o, r3);
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), q2.functions.getfeatureset = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, o) => {
      if (ie(o, 1, 2, e2, t3), U(o[0])) {
        let t4 = Y(o[1], "datasource");
        return null === t4 && (t4 = "datasource"), t4 = de(t4).toLowerCase(), M(o[0].fullSchema(), t4, e2.lrucache, e2.interceptor, e2.spatialReference ?? null);
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), q2.functions.featuresetbyportalitem = function(e2, n) {
    return q2.standardFunctionAsync(e2, n, (r2, s, l3) => {
      var _a, _b;
      if (ie(l3, 2, 5, e2, n), null === l3[0]) throw new a(e2, r.PortalRequired, n);
      if (l3[0] instanceof t2) {
        const t3 = de(l3[1]), r3 = de(l3[2]);
        let s2 = Y(l3[3], null);
        const f3 = Se(Y(l3[4], true));
        if (null === s2 && (s2 = ["*"]), false === E(s2)) throw new a(e2, r.InvalidParameter, n);
        let d2;
        return d2 = ((_a = e2.services) == null ? void 0 : _a.portal) ? e2.services.portal : b2.getDefault(), d2 = l2(l3[0], d2), q(t3, r3, e2.spatialReference ?? null, s2, f3, d2, e2.lrucache, e2.interceptor);
      }
      if (false === P(l3[0])) throw new a(e2, r.PortalRequired, n);
      const f2 = de(l3[0]), d = de(l3[1]);
      let u2 = Y(l3[2], null);
      const c2 = Se(Y(l3[3], true));
      if (null === u2 && (u2 = ["*"]), false === E(u2)) throw new a(e2, r.InvalidParameter, n);
      return q(f2, d, e2.spatialReference ?? null, u2, c2, ((_b = e2.services) == null ? void 0 : _b.portal) ?? b2.getDefault(), e2.lrucache, e2.interceptor);
    });
  }, q2.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), q2.functions.featuresetbyname = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, (n, r2, s) => {
      if (ie(s, 2, 4, e2, t3), W(s[0])) {
        const n2 = de(s[1]);
        let r3 = Y(s[2], null);
        const o = Se(Y(s[3], true));
        if (null === r3 && (r3 = ["*"]), false === E(r3)) throw new a(e2, r.InvalidParameter, t3);
        return s[0].featureSetByName(n2, o, r3);
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), q2.functions.featureset = function(e2, t3) {
    return q2.standardFunction(e2, t3, (r2, s, o) => {
      ie(o, 1, 1, e2, t3);
      const l3 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", hasM: false, hasZ: false, fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (P(o[0])) {
        const e3 = JSON.parse(o[0]);
        void 0 !== e3.layerDefinition ? (l3.layerDefinition = e3.layerDefinition, l3.featureSet = e3.featureSet, e3.layerDefinition.spatialReference && (l3.layerDefinition.spatialReference = e3.layerDefinition.spatialReference)) : (l3.featureSet.features = e3.features, l3.featureSet.geometryType = e3.geometryType, l3.layerDefinition.geometryType = l3.featureSet.geometryType, l3.layerDefinition.objectIdField = e3.objectIdFieldName ?? "", l3.layerDefinition.typeIdField = e3.typeIdFieldName, l3.layerDefinition.globalIdField = e3.globalIdFieldName, l3.layerDefinition.fields = e3.fields, e3.spatialReference && (l3.layerDefinition.spatialReference = e3.spatialReference));
      } else {
        if (!(o[0] instanceof N)) throw new a(e2, r.InvalidParameter, t3);
        {
          const n = JSON.parse(o[0].castToText(true)), r3 = te2(n, "layerdefinition");
          if (null !== r3) {
            l3.layerDefinition.geometryType = te2(r3, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.globalIdField = te2(r3, "globalidfield", ""), l3.layerDefinition.objectIdField = te2(r3, "objectidfield", ""), l3.layerDefinition.typeIdField = te2(r3, "typeidfield", ""), l3.layerDefinition.hasZ = true === te2(r3, "hasz", false), l3.layerDefinition.hasM = true === te2(r3, "hasm", false);
            const e3 = te2(r3, "spatialreference");
            e3 && (l3.layerDefinition.spatialReference = ie2(e3));
            const t4 = [];
            for (const n2 of te2(r3, "fields", [])) {
              const e4 = { name: te2(n2, "name", ""), alias: te2(n2, "alias", ""), type: te2(n2, "type", ""), nullable: te2(n2, "nullable", true), editable: te2(n2, "editable", true), length: te2(n2, "length", null), domain: ne2(te2(n2, "domain")) };
              t4.push(e4);
            }
            l3.layerDefinition.fields = t4;
            const i = te2(n, "featureset");
            if (i) {
              const e4 = {};
              for (const n2 of t4) e4[n2.name.toLowerCase()] = n2.name;
              for (const t5 of te2(i, "features", [])) {
                const n2 = {}, i2 = te2(t5, "attributes", {});
                for (const t6 in i2) n2[e4[t6.toLowerCase()]] = i2[t6];
                l3.featureSet.features.push({ attributes: n2, geometry: ae(te2(t5, "geometry")) });
              }
            }
          } else {
            l3.layerDefinition.hasZ = true === te2(n, "hasz", false), l3.layerDefinition.hasM = true === te2(n, "hasm", false), l3.layerDefinition.geometryType = te2(n, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.objectIdField = te2(n, "objectidfieldname", ""), l3.layerDefinition.typeIdField = te2(n, "typeidfieldname", "");
            const r4 = te2(n, "spatialreference");
            r4 && (l3.layerDefinition.spatialReference = ie2(r4));
            const s2 = [], o2 = te2(n, "fields", null);
            if (!E(o2)) throw new a(e2, r.InvalidParameter, t3);
            for (const e3 of o2) {
              const t4 = { name: te2(e3, "name", ""), alias: te2(e3, "alias", ""), type: te2(e3, "type", ""), nullable: te2(e3, "nullable", true), editable: te2(e3, "editable", true), length: te2(e3, "length", null), domain: ne2(te2(e3, "domain")) };
              s2.push(t4);
            }
            l3.layerDefinition.fields = s2;
            const f2 = {};
            for (const e3 of s2) f2[e3.name.toLowerCase()] = e3.name;
            let d = te2(n, "features", null);
            if (E(d)) for (const e3 of d) {
              const t4 = {}, n2 = te2(e3, "attributes", {});
              for (const e4 in n2) t4[f2[e4.toLowerCase()]] = n2[e4];
              l3.featureSet.features.push({ attributes: t4, geometry: ae(te2(e3, "geometry", null)) });
            }
            else d = null, l3.featureSet.features = d;
          }
        }
      }
      if (false === se(l3)) throw new a(e2, r.InvalidParameter, t3);
      return l3.layerDefinition.geometryType || (l3.layerDefinition.geometryType = "esriGeometryNull"), f.create(l3, e2.spatialReference);
    });
  }, q2.signatures.push({ name: "featureset", min: 1, max: 1 }), q2.functions.filter = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      if (ie(s, 2, 2, e2, t3), E(s[0]) || X(s[0])) {
        const n2 = [];
        let r3, o = s[0];
        if (o instanceof t && (o = o.toArray()), !v(s[1])) throw new a(e2, r.InvalidParameter, t3);
        r3 = s[1].createFunction(e2);
        for (const e3 of o) {
          const t4 = r3(e3);
          S(t4) ? true === await t4 && n2.push(e3) : true === t4 && n2.push(e3);
        }
        return n2;
      }
      if (K(s[0])) {
        const t4 = await s[0].load(), n2 = Z.create(s[1], { fieldsIndex: t4.getFieldsIndex(), timeZone: t4.dateFieldsTimeZoneDefaultUTC }), i = n2.getVariables();
        if (i.length > 0) {
          const t5 = [];
          for (let n3 = 0; n3 < i.length; n3++) {
            const a5 = { name: i[n3] };
            t5.push(await q2.evaluateIdentifier(e2, a5));
          }
          const a4 = {};
          for (let e3 = 0; e3 < i.length; e3++) a4[i[e3]] = t5[e3];
          return n2.parameters = a4, new c({ parentfeatureset: s[0], whereclause: n2 });
        }
        return new c({ parentfeatureset: s[0], whereclause: n2 });
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "filter", min: 2, max: 2 }), q2.functions.orderby = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      if (ie(s, 2, 2, e2, t3), K(s[0])) {
        const e3 = new e(s[1]);
        return new a2({ parentfeatureset: s[0], orderbyclause: e3 });
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "orderby", min: 2, max: 2 }), q2.functions.top = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      if (ie(s, 2, 2, e2, t3), K(s[0])) return new a3({ parentfeatureset: s[0], topnum: s[1] });
      if (E(s[0])) return he(s[1]) >= s[0].length ? s[0].slice() : s[0].slice(0, he(s[1]));
      if (X(s[0])) return he(s[1]) >= s[0].length() ? s[0].slice() : s[0].slice(0, he(s[1]));
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "top", min: 2, max: 2 }), q2.functions.first = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, i, a4) => {
      if (ie(a4, 1, 1, e2, t3), K(a4[0])) {
        const t4 = await a4[0].first(n.abortSignal);
        if (null !== t4) {
          const n2 = D.createFromGraphicLikeObject(t4.geometry, t4.attributes, a4[0], e2.timeZone);
          return n2._underlyingGraphic = t4, n2;
        }
        return t4;
      }
      return E(a4[0]) ? 0 === a4[0].length ? null : a4[0][0] : X(a4[0]) ? 0 === a4[0].length() ? null : a4[0].get(0) : null;
    });
  }, q2.signatures.push({ name: "first", min: 1, max: 1 }), q2.functions.attachments = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (r2, s, o) => {
      ie(o, 1, 2, e2, t3);
      const f2 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (o.length > 1) {
        if (o[1] instanceof N) {
          if (o[1].hasField("minsize") && (f2.minsize = he(o[1].field("minsize"))), o[1].hasField("metadata") && (f2.returnMetadata = Se(o[1].field("metadata"))), o[1].hasField("maxsize") && (f2.maxsize = he(o[1].field("maxsize"))), o[1].hasField("types")) {
            const e3 = Je(o[1].field("types"), false);
            e3.length > 0 && (f2.types = e3);
          }
        } else if (null !== o[1]) throw new a(e2, r.InvalidParameter, t3);
      }
      if (U(o[0])) {
        let t4 = o[0]._layer;
        return t4 instanceof Xe && (t4 = T(t4, e2.spatialReference, ["*"], true, e2.lrucache, e2.interceptor)), null === t4 ? [] : false === K(t4) ? [] : (await t4.load(), t4.queryAttachments(o[0].field(t4.objectIdField), f2.minsize, f2.maxsize, f2.types, f2.returnMetadata));
      }
      if (null === o[0]) return [];
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "attachments", min: 1, max: 2 }), q2.functions.featuresetbyrelationshipname = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      ie(s, 2, 4, e2, t3);
      const o = s[0], u2 = de(s[1]);
      let c2 = Y(s[2], null);
      const p = Se(Y(s[3], true));
      if (null === c2 && (c2 = ["*"]), false === E(c2)) throw new a(e2, r.InvalidParameter, t3);
      if (null === s[0]) return null;
      if (!U(s[0])) throw new a(e2, r.InvalidParameter, t3);
      let y3 = o._layer;
      if (y3 instanceof Xe && (y3 = T(y3, e2.spatialReference, ["*"], true, e2.lrucache, e2.interceptor)), null === y3) return null;
      if (false === K(y3)) return null;
      y3 = await y3.load();
      const h = y3.relationshipMetaData().filter((e3) => e3.name === u2);
      if (0 === h.length) return null;
      if (void 0 !== h[0].relationshipTableId && null !== h[0].relationshipTableId && h[0].relationshipTableId > -1) return E2(y3, h[0], o.field(y3.objectIdField), y3.spatialReference, c2, p, e2.lrucache, e2.interceptor);
      let g = y3.serviceUrl();
      if (!g) return null;
      g = "/" === g.charAt(g.length - 1) ? g + h[0].relatedTableId.toString() : g + "/" + h[0].relatedTableId.toString();
      const F = await N2(g, y3.spatialReference, c2, p, e2.lrucache, e2.interceptor);
      await F.load();
      let D2 = F.relationshipMetaData();
      if (D2 = D2.filter((e3) => e3.id === h[0].id), false === o.hasField(h[0].keyField) || null === o.field(h[0].keyField)) {
        const e3 = await y3.getFeatureByObjectId(o.field(y3.objectIdField), [h[0].keyField]);
        if (e3) {
          const t4 = Z.create(D2[0].keyField + "= @id", { fieldsIndex: F.getFieldsIndex(), timeZone: F.dateFieldsTimeZoneDefaultUTC });
          return t4.parameters = { id: e3.attributes[h[0].keyField] }, F.filter(t4);
        }
        return new u({ parentfeatureset: F });
      }
      const T2 = Z.create(D2[0].keyField + "= @id", { fieldsIndex: F.getFieldsIndex(), timeZone: F.dateFieldsTimeZoneDefaultUTC });
      return T2.parameters = { id: o.field(h[0].keyField) }, F.filter(T2);
    });
  }, q2.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), q2.functions.featuresetbyassociation = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      ie(s, 2, 3, e2, t3);
      const o = s[0], f2 = de(Y(s[1], "")).toLowerCase(), d = P(s[2]) ? de(s[2]) : null;
      if (null === s[0]) return null;
      if (!U(s[0])) throw new a(e2, r.InvalidParameter, t3);
      let c2 = o._layer;
      if (c2 instanceof Xe && (c2 = T(c2, e2.spatialReference, ["*"], true, e2.lrucache, e2.interceptor)), null === c2) return null;
      if (false === K(c2)) return null;
      await c2.load();
      const p = c2.serviceUrl(), y3 = await O2(p, e2.spatialReference);
      let g = null, F = null, D2 = false;
      if (null !== d && "" !== d && void 0 !== d) {
        for (const e3 of y3.terminals) e3.terminalName === d && (F = e3.terminalId);
        null === F && (D2 = true);
      }
      const T2 = y3.associations.getFieldsIndex(), b3 = T2.get("TOGLOBALID").name, E3 = T2.get("FROMGLOBALID").name, N3 = T2.get("TOTERMINALID").name, L2 = T2.get("FROMTERMINALID").name, S2 = T2.get("FROMNETWORKSOURCEID").name, C = T2.get("TONETWORKSOURCEID").name, $ = T2.get("ASSOCIATIONTYPE").name, v2 = T2.get("ISCONTENTVISIBLE").name, k2 = T2.get("OBJECTID").name;
      for (const e3 of c2.fields) if ("global-id" === e3.type) {
        g = o.field(e3.name);
        break;
      }
      let O3 = null, z = new L(new y({ name: "percentalong", alias: "percentalong", type: "double" }), Z.create("0", { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC })), W2 = new L(new y({ name: "side", alias: "side", type: "string" }), Z.create("''", { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC }));
      const H = "globalid", G = "globalId", K2 = {};
      for (const e3 in y3.lkp) K2[e3] = y3.lkp[e3].sourceId;
      const q3 = new B(new y({ name: "classname", alias: "classname", type: "string" }), null, K2);
      let B2 = "";
      switch (f2) {
        case "midspan": {
          B2 = `((${b3}='${g}') OR ( ${E3}='${g}')) AND (${$} IN (5))`, q3.codefield = Z.create(`CASE WHEN (${b3}='${g}') THEN ${S2} ELSE ${C} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC });
          const e3 = y2(R.findField(y3.associations.fields, E3));
          e3.name = H, e3.alias = H, O3 = new L(e3, Z.create(`CASE WHEN (${E3}='${g}') THEN ${b3} ELSE ${E3} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC })), z = y3.unVersion >= 4 ? new k(R.findField(y3.associations.fields, T2.get("PERCENTALONG").name)) : new L(new y({ name: "percentalong", alias: "percentalong", type: "double" }), Z.create("0", { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "junctionedge": {
          B2 = `((${b3}='${g}') OR ( ${E3}='${g}')) AND (${$} IN (4,6))`, q3.codefield = Z.create(`CASE WHEN (${b3}='${g}') THEN ${S2} ELSE ${C} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC });
          const e3 = y2(R.findField(y3.associations.fields, E3));
          e3.name = H, e3.alias = H, O3 = new L(e3, Z.create(`CASE WHEN (${E3}='${g}') THEN ${b3} ELSE ${E3} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC })), W2 = new L(new y({ name: "side", alias: "side", type: "string" }), Z.create(`CASE WHEN (${$}=4) THEN 'from' ELSE 'to' END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "connected": {
          let e3 = `${b3}='@T'`, t4 = `${E3}='@T'`;
          null !== F && (e3 += ` AND ${N3}=@A`, t4 += ` AND ${L2}=@A`), B2 = "((" + e3 + ") OR (" + t4 + "))", B2 = J(B2, "@T", g ?? ""), e3 = J(e3, "@T", g ?? ""), null !== F && (e3 = J(e3, "@A", F.toString()), B2 = J(B2, "@A", F.toString())), q3.codefield = Z.create("CASE WHEN " + e3 + ` THEN ${S2} ELSE ${C} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC });
          const n2 = y2(R.findField(y3.associations.fields, E3));
          n2.name = H, n2.alias = H, O3 = new L(n2, Z.create("CASE WHEN " + e3 + ` THEN ${E3} ELSE ${b3} END`, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "container":
          B2 = `${b3}='${g}' AND ${$} = 2`, null !== F && (B2 += ` AND ${N3} = ` + F.toString()), q3.codefield = S2, B2 = "( " + B2 + " )", O3 = new b(R.findField(y3.associations.fields, E3), H, H);
          break;
        case "content":
          B2 = `(${E3}='${g}' AND ${$} = 2)`, null !== F && (B2 += ` AND ${L2} = ` + F.toString()), q3.codefield = C, B2 = "( " + B2 + " )", O3 = new b(R.findField(y3.associations.fields, b3), H, H);
          break;
        case "structure":
          B2 = `(${b3}='${g}' AND ${$} = 3)`, null !== F && (B2 += ` AND ${N3} = ` + F.toString()), q3.codefield = S2, B2 = "( " + B2 + " )", O3 = new b(R.findField(y3.associations.fields, E3), H, G);
          break;
        case "attached":
          B2 = `(${E3}='${g}' AND ${$} = 3)`, null !== F && (B2 += ` AND ${L2} = ` + F.toString()), q3.codefield = C, B2 = "( " + B2 + " )", O3 = new b(R.findField(y3.associations.fields, b3), H, G);
          break;
        default:
          throw new a(e2, r.InvalidParameter, t3);
      }
      D2 && (B2 = "1 <> 1");
      return new R({ parentfeatureset: y3.associations, adaptedFields: [new k(R.findField(y3.associations.fields, k2)), new k(R.findField(y3.associations.fields, v2)), O3, W2, q3, z], extraFilter: B2 ? Z.create(B2, { fieldsIndex: y3.associations.getFieldsIndex(), timeZone: y3.associations.dateFieldsTimeZoneDefaultUTC }) : null });
    });
  }, q2.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), q2.functions.groupby = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (r2, s, o) => {
      if (ie(o, 3, 3, e2, t3), !K(o[0])) throw new a(e2, r.InvalidParameter, t3);
      const l3 = await o[0].load(), f2 = [], d = [];
      let u2 = false, c2 = [];
      if (P(o[1])) c2.push(o[1]);
      else if (o[1] instanceof N) c2.push(o[1]);
      else if (E(o[1])) c2 = o[1];
      else {
        if (!X(o[1])) throw new a(e2, r.InvalidParameter, t3);
        c2 = o[1].toArray();
      }
      for (const m2 of c2) if (P(m2)) {
        const e3 = Z.create(de(m2), { fieldsIndex: l3.getFieldsIndex(), timeZone: l3.dateFieldsTimeZoneDefaultUTC }), t4 = true === O(e3) ? de(m2) : "%%%%FIELDNAME";
        f2.push({ name: t4, expression: e3 }), "%%%%FIELDNAME" === t4 && (u2 = true);
      } else {
        if (!(m2 instanceof N)) throw new a(e2, r.InvalidParameter, t3);
        {
          const n = m2.hasField("name") ? m2.field("name") : "%%%%FIELDNAME", r3 = m2.hasField("expression") ? m2.field("expression") : "";
          if ("%%%%FIELDNAME" === n && (u2 = true), !n) throw new a(e2, r.InvalidParameter, t3);
          f2.push({ name: n, expression: Z.create(r3 || n, { fieldsIndex: l3.getFieldsIndex(), timeZone: l3.dateFieldsTimeZoneDefaultUTC }) });
        }
      }
      if (c2 = [], P(o[2])) c2.push(o[2]);
      else if (E(o[2])) c2 = o[2];
      else if (X(o[2])) c2 = o[2].toArray();
      else {
        if (!(o[2] instanceof N)) throw new a(e2, r.InvalidParameter, t3);
        c2.push(o[2]);
      }
      for (const m2 of c2) {
        if (!(m2 instanceof N)) throw new a(e2, r.InvalidParameter, t3);
        {
          const n = m2.hasField("name") ? m2.field("name") : "", r3 = m2.hasField("statistic") ? m2.field("statistic") : "", s2 = m2.hasField("expression") ? m2.field("expression") : "";
          if (!n || !r3 || !s2) throw new a(e2, r.InvalidParameter, t3);
          d.push({ name: n, statistic: r3.toLowerCase(), expression: Z.create(s2, { fieldsIndex: l3.getFieldsIndex(), timeZone: l3.dateFieldsTimeZoneDefaultUTC }) });
        }
      }
      if (u2) {
        const e3 = {};
        for (const n of l3.fields) e3[n.name.toLowerCase()] = 1;
        for (const n of f2) "%%%%FIELDNAME" !== n.name && (e3[n.name.toLowerCase()] = 1);
        for (const n of d) "%%%%FIELDNAME" !== n.name && (e3[n.name.toLowerCase()] = 1);
        let t4 = 0;
        for (const n of f2) if ("%%%%FIELDNAME" === n.name) {
          for (; 1 === e3["field_" + t4.toString()]; ) t4++;
          e3["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
        }
      }
      for (const t4 of f2) await ee2(t4.expression, q2, e2);
      for (const t4 of d) await ee2(t4.expression, q2, e2);
      return o[0].groupby(f2, d);
    });
  }, q2.signatures.push({ name: "groupby", min: 3, max: 3 }), q2.functions.distinct = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (r2, s, o) => {
      if (K(o[0])) {
        ie(o, 2, 2, e2, t3);
        const r3 = await o[0].load(), s2 = [];
        let l3 = [];
        if (P(o[1])) l3.push(o[1]);
        else if (o[1] instanceof N) l3.push(o[1]);
        else if (E(o[1])) l3 = o[1];
        else {
          if (!X(o[1])) throw new a(e2, r.InvalidParameter, t3);
          l3 = o[1].toArray();
        }
        let f2 = false;
        for (const o2 of l3) if (P(o2)) {
          const e3 = Z.create(de(o2), { fieldsIndex: r3.getFieldsIndex(), timeZone: r3.dateFieldsTimeZoneDefaultUTC }), t4 = true === O(e3) ? de(o2) : "%%%%FIELDNAME";
          s2.push({ name: t4, expression: e3 }), "%%%%FIELDNAME" === t4 && (f2 = true);
        } else {
          if (!(o2 instanceof N)) throw new a(e2, r.InvalidParameter, t3);
          {
            const n = o2.hasField("name") ? o2.field("name") : "%%%%FIELDNAME", l4 = o2.hasField("expression") ? o2.field("expression") : "";
            if ("%%%%FIELDNAME" === n && (f2 = true), !n) throw new a(e2, r.InvalidParameter, t3);
            s2.push({ name: n, expression: Z.create(l4 || n, { fieldsIndex: r3.getFieldsIndex(), timeZone: r3.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (f2) {
          const e3 = {};
          for (const n of r3.fields) e3[n.name.toLowerCase()] = 1;
          for (const n of s2) "%%%%FIELDNAME" !== n.name && (e3[n.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n of s2) if ("%%%%FIELDNAME" === n.name) {
            for (; 1 === e3["field_" + t4.toString()]; ) t4++;
            e3["field_" + t4.toString()] = 1, n.name = "FIELD_" + t4.toString();
          }
        }
        for (const t4 of s2) await ee2(t4.expression, q2, e2);
        return o[0].groupby(s2, []);
      }
      return X2(o);
    });
  }, q2.functions.getfeaturesetinfo = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (i, a4, r2) => {
      if (ie(r2, 1, 1, e2, t3), !K(r2[0])) return null;
      const s = await r2[0].getFeatureSetInfo();
      return s ? N.convertObjectToArcadeDictionary({ layerId: s.layerId, layerName: s.layerName, itemId: s.itemId, serviceLayerUrl: s.serviceLayerUrl, webMapLayerId: s.webMapLayerId ?? null, webMapLayerTitle: s.webMapLayerTitle ?? null, className: null, objectClassId: null }, Be(e2), false, false) : null;
    });
  }, q2.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 }), q2.functions.filterbysubtypecode = function(e2, t3) {
    return q2.standardFunctionAsync(e2, t3, async (n, r2, s) => {
      if (ie(s, 2, 2, e2, t3), K(s[0])) {
        const n2 = await s[0].load(), r3 = s[1];
        if (!V(r3)) throw new a(e2, r.InvalidParameter, t3);
        if (n2.subtypeField) {
          const e3 = Z.create(`${n2.subtypeField}= ${s[1]}`, { fieldsIndex: n2.getFieldsIndex(), timeZone: n2.dateFieldsTimeZoneDefaultUTC });
          return new c({ parentfeatureset: s[0], whereclause: e3 });
        }
        if (null === n2.typeIdField || "" === n2.typeIdField) throw new a(e2, r.FeatureSetDoesNotHaveSubtypes, t3);
        const o = Z.create(`${n2.typeIdField}= ${s[1]}`, { fieldsIndex: n2.getFieldsIndex(), timeZone: n2.dateFieldsTimeZoneDefaultUTC });
        return new c({ parentfeatureset: s[0], whereclause: o });
      }
      throw new a(e2, r.InvalidParameter, t3);
    });
  }, q2.signatures.push({ name: "filterbysubtypecode", min: 2, max: 2 }));
}
export {
  le as registerFunctions
};
//# sourceMappingURL=featuresetbase-5O2M6CJF.js.map
