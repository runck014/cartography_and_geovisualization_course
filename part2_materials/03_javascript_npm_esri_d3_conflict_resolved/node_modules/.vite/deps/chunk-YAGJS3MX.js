import {
  c as c2
} from "./chunk-KKH7HGO3.js";
import {
  B as B2,
  U,
  W,
  a as a2,
  c,
  v,
  z
} from "./chunk-2RIHQI4N.js";
import {
  B,
  C,
  D,
  H
} from "./chunk-2U5JYYSG.js";
import {
  l
} from "./chunk-4NJWIUZG.js";
import {
  o
} from "./chunk-BWTCR2DR.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithFeature.js
function s2(e, t, o2, n2, a3) {
  if (null == e) return null;
  const s3 = e.referencesGeometry() && a3 ? i(t, n2, a3) : t, u2 = e.repurposeFeature(s3);
  try {
    return e.evaluate({ ...o2, $feature: u2 }, e.services);
  } catch (c4) {
    return n.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", c4), null;
  }
}
var u = /* @__PURE__ */ new Map();
function i(e, r, t) {
  const { transform: o2, hasZ: n2, hasM: a3 } = t;
  u.has(r) || u.set(r, c3(r));
  const s3 = u.get(r)(e.geometry, o2, n2, a3);
  return { ...e, geometry: s3 };
}
function c3(s3) {
  const u2 = {};
  switch (s3) {
    case "esriGeometryPoint":
      return (e, r, t, o2) => C(r, u2, e, t, o2);
    case "esriGeometryPolygon":
      return (e, r, t, o2) => D(r, u2, e, t, o2);
    case "esriGeometryPolyline":
      return (e, r, t, n2) => H(r, u2, e, t, n2);
    case "esriGeometryMultipoint":
      return (e, r, o2, n2) => B(r, u2, e, o2, n2);
    default:
      return n.getLogger("esri.views.2d.support.arcadeOnDemand").error(new s("mapview-arcade", `Unable to handle geometryType: ${s3}`)), (e) => e;
  }
}

// node_modules/@arcgis/core/symbols/cim/OverrideHelper.js
var m = (e) => {
  if (!e) return [0, 0, 0, 0];
  const { r, g: i2, b: t, a: s3 } = e;
  return [r, i2, t, 255 * s3];
};
var y = class _y {
  static findApplicableOverrides(e, r, i2) {
    if (e && r) {
      if (e.primitiveName) {
        let t = false;
        for (const r2 of i2) if (r2.primitiveName === e.primitiveName) {
          t = true;
          break;
        }
        if (!t) for (const s3 of r) s3.primitiveName === e.primitiveName && i2.push(s3);
      }
      switch (e.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          if (e.effects) for (const t of e.effects) _y.findApplicableOverrides(t, r, i2);
          if (e.symbolLayers) for (const t of e.symbolLayers) _y.findApplicableOverrides(t, r, i2);
          break;
        case "CIMTextSymbol":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke":
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
        case "CIMVectorMarker":
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
          if (e.effects) for (const t of e.effects) _y.findApplicableOverrides(t, r, i2);
          if (e.markerPlacement && _y.findApplicableOverrides(e.markerPlacement, r, i2), "CIMVectorMarker" === e.type) {
            if (e.markerGraphics) for (const t of e.markerGraphics) _y.findApplicableOverrides(t, r, i2), _y.findApplicableOverrides(t.symbol, r, i2);
          } else "CIMCharacterMarker" === e.type ? _y.findApplicableOverrides(e.symbol, r, i2) : "CIMHatchFill" === e.type ? _y.findApplicableOverrides(e.lineSymbol, r, i2) : "CIMPictureMarker" === e.type && _y.findApplicableOverrides(e.animatedSymbolProperties, r, i2);
      }
    }
  }
  static findEffectOverrides(e, r) {
    if (!e) return null;
    if ("CIMGeometricEffectDashes" === e.type && B2(e), !r || !e.primitiveName) return { type: "cim-effect-param", effect: e, overrides: [] };
    const i2 = W(e), t = e.primitiveName, c4 = [];
    for (const s3 of r) s3.primitiveName === t && c4.push(W(s3));
    return { type: "cim-effect-param", effect: i2, overrides: U(c4) };
  }
  static async resolveSymbolOverrides(e, r, t, s3, o2, a3, l2) {
    if (!(e == null ? void 0 : e.symbol)) return null;
    let { symbol: n2, primitiveOverrides: p } = e;
    const f = !!p;
    if (!f && !s3) return n2;
    n2 = a(n2), p = a(p);
    let m2 = true;
    if (r || (r = { attributes: {} }, m2 = false), f) {
      if (m2 || (p = p.filter((e2) => {
        var _a;
        return !((_a = e2.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$feature"));
      })), l2 || (p = p.filter((e2) => {
        var _a;
        return !((_a = e2.valueExpressionInfo) == null ? void 0 : _a.expression.includes("$view"));
      })), p.length > 0) {
        const e2 = { spatialReference: t, fields: v(r.attributes), geometryType: o2 };
        await _y.createRenderExpressions(p, e2), _y.evaluateOverrides(p, r, o2 ?? "esriGeometryPoint", a3, l2);
      }
      _y.applyOverrides(n2, p);
    }
    return s3 && _y.applyDictionaryTextOverrides(n2, r, s3, null), n2;
  }
  static async createRenderExpressions(e, r) {
    const i2 = [];
    for (const s3 of e) {
      const e2 = s3.valueExpressionInfo;
      if (!e2 || _y._expressionToRenderExpression.has(e2.expression)) continue;
      const o2 = o(e2.expression, r.spatialReference, r.fields);
      i2.push(o2), o2.then((r2) => _y._expressionToRenderExpression.set(e2.expression, r2));
    }
    i2.length > 0 && await Promise.all(i2);
  }
  static evaluateOverrides(e, i2, t, s3, o2) {
    const a3 = { $view: { scale: o2 == null ? void 0 : o2.scale } };
    for (const c4 of e) {
      c4.value && "object" == typeof c4.value && c2(c4.value) && ("Color" === c4.propertyName || "StrokeColor" === c4.propertyName) && (c4.value = m(c4.value));
      const e2 = c4.valueExpressionInfo;
      if (!e2) continue;
      const o3 = _y._expressionToRenderExpression.get(e2.expression);
      o3 && (c4.value = s2(o3, i2, a3, t, s3));
    }
  }
  static applyDictionaryTextOverrides(e, r, i2, t, s3 = "Normal") {
    if (e == null ? void 0 : e.type) switch (e.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
      case "CIMTextSymbol":
        {
          const o2 = e.symbolLayers;
          if (!o2) return;
          for (const a3 of o2) a3 && "CIMVectorMarker" === a3.type && _y.applyDictionaryTextOverrides(a3, r, i2, t, "CIMTextSymbol" === e.type ? e.textCase : s3);
        }
        break;
      case "CIMVectorMarker":
        {
          const s4 = e.markerGraphics;
          if (!s4) return;
          for (const e2 of s4) e2 && _y.applyDictionaryTextOverrides(e2, r, i2, t);
        }
        break;
      case "CIMMarkerGraphic": {
        const o2 = e.textString;
        if (o2 && o2.includes("[")) {
          const a3 = a2(o2, i2);
          e.textString = c(r, a3, t, s3);
        }
      }
    }
  }
  static applyOverrides(e, r, i2, t) {
    if (e.primitiveName) {
      for (const s3 of r) if (s3.primitiveName === e.primitiveName) {
        const r2 = z(s3.propertyName);
        if (t && t.push({ cim: e, nocapPropertyName: r2, value: e[r2] }), i2) {
          let r3 = false;
          for (const t2 of i2) t2.primitiveName === e.primitiveName && (r3 = true);
          r3 || i2.push(s3);
        }
        null != s3.value && (e[r2] = s3.value);
      }
    }
    switch (e.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        if (e.effects) for (const s3 of e.effects) _y.applyOverrides(s3, r, i2, t);
        if (e.symbolLayers) for (const s3 of e.symbolLayers) _y.applyOverrides(s3, r, i2, t);
        break;
      case "CIMTextSymbol":
        break;
      case "CIMSolidStroke":
      case "CIMSolidFill":
      case "CIMVectorMarker":
        if (e.effects) for (const s3 of e.effects) _y.applyOverrides(s3, r, i2, t);
        if ("CIMVectorMarker" === e.type && e.markerGraphics) for (const s3 of e.markerGraphics) _y.applyOverrides(s3, r, i2, t), _y.applyOverrides(s3.symbol, r, i2, t);
    }
  }
  static restoreOverrides(e) {
    for (const r of e) r.cim[r.nocapPropertyName] = r.value;
  }
  static buildOverrideKey(e) {
    let r = "";
    for (const i2 of e) void 0 !== i2.value && (r += `${i2.primitiveName}${i2.propertyName}${JSON.stringify(i2.value)}`);
    return r;
  }
  static toValue(r, i2) {
    if ("DashTemplate" === r) return i2.split(" ").map((e) => Number(e));
    if ("Color" === r) {
      const r2 = new l(i2).toRgba();
      return r2[3] *= 255, r2;
    }
    return i2;
  }
};
y._expressionToRenderExpression = /* @__PURE__ */ new Map();

export {
  y
};
//# sourceMappingURL=chunk-YAGJS3MX.js.map
