import {
  o as o2
} from "./chunk-DLJHW32W.js";
import {
  c,
  o,
  t
} from "./chunk-J3GKRP7Y.js";
import {
  i
} from "./chunk-6YWQXXBX.js";

// node_modules/@arcgis/core/symbols/cim/rasterizingUtils.js
var n = (o3) => "vertical" === o3 || "horizontal" === o3 || "cross" === o3 || "esriSFSCross" === o3 || "esriSFSVertical" === o3 || "esriSFSHorizontal" === o3;
function s(o3, r, a) {
  const e = r.style, s2 = i(Math.ceil(a)), i3 = n(e) ? 8 * s2 : 16 * s2, l2 = 2 * s2;
  o3.width = i3, o3.height = i3;
  const h = o3.getContext("2d");
  h.strokeStyle = "#ffffff", h.lineWidth = s2, h.beginPath(), "vertical" !== e && "cross" !== e && "esriSFSCross" !== e && "esriSFSVertical" !== e || (h.moveTo(i3 / 2, -l2), h.lineTo(i3 / 2, i3 + l2)), "horizontal" !== e && "cross" !== e && "esriSFSCross" !== e && "esriSFSHorizontal" !== e || (h.moveTo(-l2, i3 / 2), h.lineTo(i3 + l2, i3 / 2)), "backward-diagonal" !== e && "diagonal-cross" !== e && "esriSFSDiagonalCross" !== e && "esriSFSBackwardDiagonal" !== e || (h.moveTo(-l2, -l2), h.lineTo(i3 + l2, i3 + l2), h.moveTo(i3 - l2, -l2), h.lineTo(i3 + l2, l2), h.moveTo(-l2, i3 - l2), h.lineTo(l2, i3 + l2)), "forward-diagonal" !== e && "diagonal-cross" !== e && "esriSFSForwardDiagonal" !== e && "esriSFSDiagonalCross" !== e || (h.moveTo(i3 + l2, -l2), h.lineTo(-l2, i3 + l2), h.moveTo(l2, -l2), h.lineTo(-l2, l2), h.moveTo(i3 + l2, i3 - l2), h.lineTo(i3 - l2, i3 + l2)), h.stroke();
  const c2 = h.getImageData(0, 0, o3.width, o3.height), m = new Uint8Array(c2.data);
  let f;
  for (let t2 = 0; t2 < m.length; t2 += 4) f = m[t2 + 3] / 255, m[t2] = m[t2] * f, m[t2 + 1] = m[t2 + 1] * f, m[t2 + 2] = m[t2 + 2] * f;
  return [m, o3.width, o3.height, s2];
}
function i2(t2) {
  t2.length % 2 == 1 && (t2 = [...t2, ...t2]);
  const e = t2.reduce((o3, t3) => o3 + t3, 0), n2 = Math.round(e * t), s2 = 1, i3 = new Float32Array(n2 * s2);
  let l2 = 0, h = 0, c2 = 0.5, m = true;
  for (const o3 of t2) {
    for (l2 = h, h += o3 * t; c2 <= h; ) {
      const o4 = c2 - 0.5, t3 = Math.min(Math.abs(c2 - l2), Math.abs(c2 - h));
      i3[o4] = m ? -t3 : t3, c2++;
    }
    m = !m;
  }
  const f = i3.length, S = new Uint8Array(4 * f);
  for (let g = 0; g < f; ++g) {
    const t3 = i3[g] / t;
    o2(t3 / c * 0.5 + 0.5, S, 4 * g);
  }
  return [S, n2, s2];
}
function l(t2, r) {
  null == t2 && (t2 = []);
  const a = "Butt" === r, n2 = "Square" === r, s2 = !a && !n2;
  t2.length % 2 == 1 && (t2 = [...t2, ...t2]);
  const i3 = o, l2 = 2 * i3;
  let h = 0;
  for (const o3 of t2) h += o3;
  const c2 = Math.round(h * i3), m = new Float32Array(c2 * l2), f = 0.5 * i3;
  let S = 0, g = 0, M = 0.5, d = true;
  for (const o3 of t2) {
    for (S = g, g += o3 * i3; M <= g; ) {
      let o4 = 0.5;
      for (; o4 < l2; ) {
        const t3 = (o4 - 0.5) * c2 + M - 0.5, r2 = s2 ? (o4 - i3) * (o4 - i3) : Math.abs(o4 - i3);
        m[t3] = d ? a ? Math.max(Math.max(S + f - M, r2), Math.max(M - g + f, r2)) : r2 : s2 ? Math.min((M - S) * (M - S) + r2, (M - g) * (M - g) + r2) : n2 ? Math.min(Math.max(M - S, r2), Math.max(g - M, r2)) : Math.min(Math.max(M - S + f, r2), Math.max(g + f - M, r2)), o4++;
      }
      M++;
    }
    d = !d;
  }
  const T = m.length, F = new Uint8Array(4 * T);
  for (let e = 0; e < T; ++e) {
    const t3 = (s2 ? Math.sqrt(m[e]) : m[e]) / i3;
    o2(t3, F, 4 * e);
  }
  return [F, c2, l2];
}

export {
  s,
  i2 as i,
  l
};
//# sourceMappingURL=chunk-UKNTO5OD.js.map
