import {
  j
} from "./chunk-CFLZHE4P.js";
import {
  s as s4
} from "./chunk-LTKYSPF4.js";
import {
  A as A3
} from "./chunk-ZWM63JM7.js";
import {
  N
} from "./chunk-4SD3BG5E.js";
import {
  A as A2,
  I
} from "./chunk-B25ZRON6.js";
import {
  M
} from "./chunk-F3IC5LHL.js";
import {
  a as a4
} from "./chunk-CKKQRCEC.js";
import {
  a as a3
} from "./chunk-2HAJDS7Q.js";
import {
  u
} from "./chunk-2L7UGRIC.js";
import {
  i
} from "./chunk-SUBGY5CE.js";
import {
  J as J2
} from "./chunk-Z3NV3VCK.js";
import {
  c,
  i as i2,
  o,
  t
} from "./chunk-U3JQIAF6.js";
import {
  d as d2
} from "./chunk-6Q7GN2CW.js";
import {
  b
} from "./chunk-F3NUC2RS.js";
import {
  p
} from "./chunk-TA32QX7Z.js";
import {
  g as g2
} from "./chunk-P3GRQ2CH.js";
import {
  J,
  L,
  Q
} from "./chunk-XGYM66XX.js";
import {
  r as r2
} from "./chunk-VEUN2EF3.js";
import {
  d
} from "./chunk-W6D3ECTZ.js";
import {
  f
} from "./chunk-3L2AYCZY.js";
import {
  m as m2
} from "./chunk-B6VE32RA.js";
import {
  w
} from "./chunk-FG3XOAFD.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  V as V2,
  s3
} from "./chunk-E2I7HYXQ.js";
import {
  n as n2
} from "./chunk-7O7KFKCG.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  V,
  Wt
} from "./chunk-YFGQMO6E.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  A,
  a,
  k
} from "./chunk-GRW2QIBT.js";
import {
  e,
  n2 as n,
  s,
  s2
} from "./chunk-PKLD5YJF.js";
import {
  C,
  F,
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/layers/graphics/applyEditsUtils.js
async function m3(t2, e2, r3) {
  const { geometry: o2 } = e2, i3 = { ...e2.attributes };
  if (null != r3 && "mesh" === (o2 == null ? void 0 : o2.type)) {
    const { transformFieldRoles: e3 } = r3, { origin: c2, spatialReference: p2, vertexSpace: m4 } = o2, f3 = o2.transform ?? new N(), g4 = "local" === m4.type, b3 = t2.spatialReference, y2 = b3.isGeographic, R2 = s3(b3, p2), h2 = L(p2, b3) && J(p2, b3);
    if (!(g4 && y2 && h2 || !g4 && !y2 && R2)) return null;
    const I3 = Q(c2, p2, b3);
    if (null == I3) return null;
    if (i3[e3.originX] = I3.x, i3[e3.originY] = I3.y, i3[e3.originZ] = I3.z ?? 0, null != f3) {
      const { translation: t3, scale: r4, rotation: o3 } = f3, s5 = g4 ? 1 : V2(p2) / V2(b3);
      i3[e3.translationX] = t3[0] * s5, i3[e3.translationY] = t3[2] * s5, i3[e3.translationZ] = -t3[1] * s5, i3[e3.scaleX] = r4[0], i3[e3.scaleY] = r4[2], i3[e3.scaleZ] = r4[1], i3[e3.rotationX] = o3[0], i3[e3.rotationY] = o3[2], i3[e3.rotationZ] = -o3[1], i3[e3.rotationDeg] = o3[3];
    }
    return { attributes: i3 };
  }
  return null == o2 ? { attributes: i3 } : "mesh" === o2.type || "extent" === o2.type ? null : { geometry: o2.toJSON(), attributes: i3 };
}
async function f2(t2, e2) {
  const r3 = await Promise.all((e2.addAttachments ?? []).map((e3) => g3(t2, e3))), a5 = await Promise.all((e2.updateAttachments ?? []).map((e3) => g3(t2, e3))), o2 = e2.deleteAttachments ?? [];
  return r3.length || a5.length || o2.length ? { adds: r3, updates: a5, deletes: [...o2] } : null;
}
async function g3(t2, e2) {
  var _a;
  const { feature: r3, attachment: a5 } = e2, { globalId: s5, name: n3, contentType: l, data: i3, uploadId: u2 } = a5, d3 = { globalId: s5 };
  if (r3 && ("attributes" in r3 ? d3.parentGlobalId = (_a = r3.attributes) == null ? void 0 : _a[t2.globalIdField] : r3.globalId && (d3.parentGlobalId = r3.globalId)), u2) d3.uploadId = u2;
  else if (i3) {
    const t3 = await Wt(i3);
    t3 && (d3.contentType = t3.mediaType, d3.data = t3.data), i3 instanceof File && (d3.name = i3.name);
  }
  return n3 && (d3.name = n3), l && (d3.contentType = l), d3;
}
function b2(t2, e2, r3) {
  if (!e2 || 0 === e2.length) return [];
  if (r3 && I(e2)) return e2.map((t3) => t3.globalId);
  if (A2(e2)) return e2.map((t3) => t3.objectId);
  const a5 = r3 ? t2.globalIdField : t2.objectIdField;
  return a5 ? e2.map((t3) => t3.getAttribute(a5)) : [];
}
function y(t2) {
  var _a, _b, _c;
  const e2 = t2 == null ? void 0 : t2.assetMaps;
  if (e2) {
    for (const t3 of e2.addResults) t3.success || n.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${t3.globalId}.`);
    for (const t3 of e2.updateResults) t3.success || n.getLogger("esri.layers.graphics.sources.support.sourceUtils").error(`Failed to map asset to feature with globalId ${t3.globalId}.`);
  }
  const a5 = t2 == null ? void 0 : t2.attachments, o2 = { addFeatureResults: ((_a = t2 == null ? void 0 : t2.addResults) == null ? void 0 : _a.map(R)) ?? [], updateFeatureResults: ((_b = t2 == null ? void 0 : t2.updateResults) == null ? void 0 : _b.map(R)) ?? [], deleteFeatureResults: ((_c = t2 == null ? void 0 : t2.deleteResults) == null ? void 0 : _c.map(R)) ?? [], addAttachmentResults: (a5 == null ? void 0 : a5.addResults) ? a5.addResults.map(R) : [], updateAttachmentResults: (a5 == null ? void 0 : a5.updateResults) ? a5.updateResults.map(R) : [], deleteAttachmentResults: (a5 == null ? void 0 : a5.deleteResults) ? a5.deleteResults.map(R) : [] };
  return (t2 == null ? void 0 : t2.editMoment) && (o2.editMoment = t2.editMoment), o2;
}
function R(t2) {
  const r3 = true === t2.success ? null : t2.error || { code: void 0, description: void 0 };
  return { objectId: t2.objectId, globalId: t2.globalId, error: r3 ? new s2("feature-layer-source:edit-failure", r3.description, { code: r3.code }) : null };
}
function h(e2, r3) {
  return new d2({ attributes: e2.attributes, geometry: f({ ...e2.geometry, spatialReference: r3 }) });
}
function I2(t2, e2) {
  var _a, _b, _c;
  return { adds: ((_a = t2 == null ? void 0 : t2.adds) == null ? void 0 : _a.map((t3) => h(t3, e2))) || [], updates: ((_b = t2 == null ? void 0 : t2.updates) == null ? void 0 : _b.map((t3) => ({ original: h(t3[0], e2), current: h(t3[1], e2) }))) || [], deletes: ((_c = t2 == null ? void 0 : t2.deletes) == null ? void 0 : _c.map((t3) => h(t3, e2))) || [], spatialReference: e2 };
}
function j2(t2) {
  const e2 = t2.details.raw, r3 = +e2.code, a5 = +e2.extendedCode;
  return 500 === r3 && (-2147217144 === a5 || -2147467261 === a5);
}

// node_modules/@arcgis/core/layers/graphics/sources/FeatureLayerSource.js
var V3 = new n2({ originalAndCurrentFeatures: "original-and-current-features", none: "none" });
var $ = new n2({ Started: "published", Publishing: "publishing", Stopped: "unavailable" });
var G = class extends m2 {
  constructor(e2) {
    super(e2), this.type = "feature-layer", this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.refresh = k(async () => {
      var _a, _b;
      await this.load();
      const e3 = (_a = this.sourceJSON.editingInfo) == null ? void 0 : _a.lastEditDate;
      if (null == e3) return { dataChanged: true, updates: {} };
      try {
        await this._fetchService(null);
      } catch {
        return { dataChanged: true, updates: {} };
      }
      const t2 = e3 !== ((_b = this.sourceJSON.editingInfo) == null ? void 0 : _b.lastEditDate);
      return { dataChanged: t2, updates: t2 ? { editingInfo: this.sourceJSON.editingInfo, extent: this.sourceJSON.extent } : null };
    }), this._ongoingAssetUploads = /* @__PURE__ */ new Map();
  }
  load(e2) {
    const t2 = this.layer.sourceJSON, r3 = this._fetchService(t2, { ...e2 }).then(() => this.layer.setUserPrivileges(this.sourceJSON.serviceItemId, e2)).then(() => this._ensureLatestMetadata(e2));
    return this.addResolvingPromise(r3), Promise.resolve(this);
  }
  initialize() {
    this.addHandles([d(() => {
      const e2 = this.layer;
      return e2 && "lastEditsEventDate" in e2 ? e2.lastEditsEventDate : null;
    }, (e2) => this._handleLastEditsEventChange(e2))]);
  }
  destroy() {
    this._removeEditInterceptor();
  }
  get queryTask() {
    var _a;
    const { capabilities: e2, parsedUrl: t2, gdbVersion: r3, spatialReference: s5, fieldsIndex: a5 } = this.layer, i3 = "infoFor3D" in this.layer ? this.layer.infoFor3D : null, n3 = "dynamicDataSource" in this.layer ? this.layer.dynamicDataSource : null, o2 = has("featurelayer-pbf") && (e2 == null ? void 0 : e2.query.supportsFormatPBF) && null == i3, u2 = ((_a = e2 == null ? void 0 : e2.operations) == null ? void 0 : _a.supportsQueryAttachments) ?? false;
    return new j({ url: t2.path, pbfSupported: o2, fieldsIndex: a5, infoFor3D: i3, dynamicDataSource: n3, gdbVersion: r3, sourceSpatialReference: s5, queryAttachmentsSupported: u2 });
  }
  async addAttachment(e2, t2) {
    await this.load();
    const { layer: s5 } = this;
    await J2(s5, "editing");
    const a5 = e2.attributes[s5.objectIdField], i3 = s5.parsedUrl.path + "/" + a5 + "/addAttachment", n3 = this._getLayerRequestOptions(), o2 = this._getFormDataForAttachment(t2, n3.query);
    try {
      const e3 = await U(i3, { body: o2 });
      return R(e3.data.addAttachmentResult);
    } catch (u2) {
      throw this._createAttachmentErrorResult(a5, u2);
    }
  }
  async updateAttachment(e2, t2, s5) {
    await this.load();
    const { layer: a5 } = this;
    await J2(a5, "editing");
    const i3 = e2.attributes[a5.objectIdField], n3 = a5.parsedUrl.path + "/" + i3 + "/updateAttachment", o2 = this._getLayerRequestOptions({ query: { attachmentId: t2 } }), u2 = this._getFormDataForAttachment(s5, o2.query);
    try {
      const e3 = await U(n3, { body: u2 });
      return R(e3.data.updateAttachmentResult);
    } catch (l) {
      throw this._createAttachmentErrorResult(i3, l);
    }
  }
  async applyEdits(e2, t2) {
    var _a, _b;
    await this.load();
    const { layer: a5 } = this;
    await J2(a5, "editing");
    const n3 = "infoFor3D" in a5 ? a5.infoFor3D : null, o2 = null != n3, u2 = o2 || ((t2 == null ? void 0 : t2.globalIdUsed) ?? false), l = o2 ? await this._uploadMeshesAndGetAssetMapEditsJSON(e2) : null, c2 = ((_a = e2.addFeatures) == null ? void 0 : _a.map((e3) => m3(this.layer, e3, n3))) ?? [], d3 = (await Promise.all(c2)).filter(F), p2 = ((_b = e2.updateFeatures) == null ? void 0 : _b.map((e3) => m3(this.layer, e3, n3))) ?? [], y2 = (await Promise.all(p2)).filter(F), h2 = b2(this.layer, e2.deleteFeatures, u2);
    i(d3, y2, a5.spatialReference);
    const m4 = await f2(this.layer, e2), f3 = a5.capabilities.editing.supportsAsyncApplyEdits && o2, g4 = (t2 == null ? void 0 : t2.gdbVersion) || a5.gdbVersion, w2 = { gdbVersion: g4, rollbackOnFailure: t2 == null ? void 0 : t2.rollbackOnFailureEnabled, useGlobalIds: u2, returnEditMoment: t2 == null ? void 0 : t2.returnEditMoment, usePreviousEditMoment: t2 == null ? void 0 : t2.usePreviousEditMoment, async: f3 };
    await i2(this.layer.url, g4, true);
    const q = c(this.layer.url, g4 || null);
    if (await o(a5.url, g4, a5.historicMoment)) throw new s2("feature-layer-source:historic-version", "Editing a historic version is not allowed");
    (t2 == null ? void 0 : t2.returnServiceEditsOption) ? (w2.edits = JSON.stringify([{ id: a5.layerId, adds: d3.length ? d3 : null, updates: y2.length ? y2 : null, deletes: h2.length ? h2 : null, attachments: m4, assetMaps: l }]), w2.returnServiceEditsOption = V3.toJSON(t2 == null ? void 0 : t2.returnServiceEditsOption), w2.returnServiceEditsInSourceSR = t2 == null ? void 0 : t2.returnServiceEditsInSourceSR) : (w2.adds = d3.length ? JSON.stringify(d3) : null, w2.updates = y2.length ? JSON.stringify(y2) : null, w2.deletes = h2.length ? u2 ? JSON.stringify(h2) : h2.join(",") : null, w2.attachments = m4 && JSON.stringify(m4), w2.assetMaps = null != l ? JSON.stringify(l) : void 0);
    const S = this._getLayerRequestOptions({ method: "post", query: w2 });
    q && (S.authMode = "immediate", S.query.returnEditMoment = true, S.query.sessionId = t);
    const E = (t2 == null ? void 0 : t2.returnServiceEditsOption) ? a5.url : a5.parsedUrl.path;
    let O;
    try {
      O = f3 ? await this._asyncApplyEdits(E + "/applyEdits", S) : await U(E + "/applyEdits", S);
    } catch (F2) {
      if (!j2(F2)) throw F2;
      S.authMode = "immediate", O = f3 ? await this._asyncApplyEdits(E + "/applyEdits", S) : await U(E + "/applyEdits", S);
    }
    return this._createEditsResult(O);
  }
  async deleteAttachments(e2, t2) {
    await this.load();
    const { layer: s5 } = this;
    await J2(s5, "editing");
    const a5 = e2.attributes[s5.objectIdField], i3 = s5.parsedUrl.path + "/" + a5 + "/deleteAttachments";
    try {
      return (await U(i3, this._getLayerRequestOptions({ query: { attachmentIds: t2.join(",") }, method: "post" }))).data.deleteAttachmentResults.map(R);
    } catch (n3) {
      throw this._createAttachmentErrorResult(a5, n3);
    }
  }
  fetchRecomputedExtents(e2 = {}) {
    const t2 = e2.signal;
    return this.load({ signal: t2 }).then(async () => {
      const t3 = this._getLayerRequestOptions({ ...e2, query: { returnUpdates: true } }), { layerId: s5, url: a5 } = this.layer, { data: i3 } = await U(`${a5}/${s5}`, t3), { id: n3, extent: o2, fullExtent: u2, timeExtent: l } = i3, c2 = o2 || u2;
      return { id: n3, fullExtent: c2 && w.fromJSON(c2), timeExtent: l && p.fromJSON({ start: l[0], end: l[1] }) };
    });
  }
  async queryAttachments(e2, t2 = {}) {
    await this.load();
    const r3 = this._getLayerRequestOptions(t2);
    return this.queryTask.executeAttachmentQuery(e2, r3);
  }
  async queryFeatures(e2, t2) {
    var _a;
    await this.load();
    const r3 = await this.queryTask.execute(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
    return ((_a = e2.outStatistics) == null ? void 0 : _a.length) && r3.features.length && r3.features.forEach((t3) => {
      var _a2;
      const r4 = t3.attributes;
      (_a2 = e2.outStatistics) == null ? void 0 : _a2.forEach(({ outStatisticFieldName: e3 }) => {
        if (e3) {
          const t4 = e3.toLowerCase();
          t4 && t4 in r4 && e3 !== t4 && (r4[e3] = r4[t4], delete r4[t4]);
        }
      });
    }), r3;
  }
  async queryFeaturesJSON(e2, t2) {
    return await this.load(), this.queryTask.executeJSON(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryObjectIds(e2, t2) {
    return await this.load(), this.queryTask.executeForIds(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryFeatureCount(e2, t2) {
    return await this.load(), this.queryTask.executeForCount(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryExtent(e2, t2) {
    return await this.load(), this.queryTask.executeForExtent(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryRelatedFeatures(e2, t2) {
    return await this.load(), this.queryTask.executeRelationshipQuery(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryRelatedFeaturesCount(e2, t2) {
    return await this.load(), this.queryTask.executeRelationshipQueryForCount(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopFeatures(e2, t2) {
    return await this.load(), this.queryTask.executeTopFeaturesQuery(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryBins(e2, t2) {
    return await this.load(), this.queryTask.executeBinsQuery(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopObjectIds(e2, t2) {
    return await this.load(), this.queryTask.executeForTopIds(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopExtents(e2, t2) {
    return await this.load(), this.queryTask.executeForTopExtents(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async queryTopCount(e2, t2) {
    return await this.load(), this.queryTask.executeForTopCount(e2, { ...t2, query: this._createRequestQueryOptions(t2) });
  }
  async fetchPublishingStatus() {
    if (!g2(this.layer.url)) return "unavailable";
    const e2 = V(this.layer.url, "status"), t2 = await U(e2, { query: { f: "json" } });
    return $.fromJSON(t2.data.status);
  }
  async uploadAssets(e2, t2) {
    const { uploadAssets: r3 } = await import("./uploadAssets-I6U674DW.js");
    return r3(e2, { layer: this.layer, ongoingUploads: this._ongoingAssetUploads }, t2);
  }
  _handleLastEditsEventChange(e2) {
    var _a, _b, _c, _d;
    const t2 = this.layer;
    if (null == e2 || !("capabilities" in t2) || !("effectiveCapabilities" in t2)) return;
    if (!(!((_b = (_a = t2.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsEditing) && ((_d = (_c = t2.effectiveCapabilities) == null ? void 0 : _c.operations) == null ? void 0 : _d.supportsEditing))) return;
    const r3 = t2.url;
    if (null == r3) return;
    "layerId" in t2 && V(r3, t2.layerId.toString());
    this._getOrCreateEditInterceptor(r3).before = (t3) => {
      const r4 = t3.requestOptions.method ?? "auto";
      if ("auto" === r4 || "head" === r4) {
        const r5 = t3.requestOptions.query ?? {};
        r5._ts = e2.getTime(), t3.requestOptions.query = r5;
      }
    };
  }
  _getOrCreateEditInterceptor(e2) {
    return null == this._editInterceptor && (this._editInterceptor = { urls: e2 }, s.request.internalInterceptors.push(this._editInterceptor)), this._editInterceptor;
  }
  _removeEditInterceptor() {
    null != this._editInterceptor && (C(s.request.internalInterceptors, this._editInterceptor), this._editInterceptor = null);
  }
  async _asyncApplyEdits(e2, t2) {
    const s5 = (await U(e2, t2)).data.statusUrl;
    for (; ; ) {
      const e3 = (await U(s5, { query: { f: "json" }, responseType: "json" })).data;
      switch (e3.status) {
        case "Completed":
          return U(e3.resultUrl, { query: { f: "json" }, responseType: "json" });
        case "CompletedWithErrors":
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed.");
        case "Failed ImportChanges":
        case "InProgress":
        case "Pending":
        case "ExportAttachments":
        case "ExportChanges":
        case "ExportingData":
        case "ExportingSnapshot":
        case "ImportAttachments":
        case "ProvisioningReplica":
        case "UnRegisteringReplica":
          break;
        default:
          throw new s2("async-applyEdits-failed", "asynchronous applyEdits call failed (undefined response status)");
      }
      await A(H);
    }
  }
  _createRequestQueryOptions(e2) {
    const t2 = { ...this.layer.customParameters, token: this.layer.apiKey, ...e2 == null ? void 0 : e2.query };
    return this.layer.datesInUnknownTimezone && (t2.timeReferenceUnknownClient = true), t2;
  }
  async _fetchService(e2, t2) {
    if (!e2) {
      const s6 = {};
      has("featurelayer-advanced-symbols") && (s6.returnAdvancedSymbols = true), (t2 == null ? void 0 : t2.cacheBust) && (s6._ts = Date.now());
      const { data: a5 } = await U(this.layer.parsedUrl.path, this._getLayerRequestOptions({ query: s6, signal: t2 == null ? void 0 : t2.signal }));
      e2 = a5;
    }
    this.sourceJSON = await this._patchServiceJSON(e2, t2 == null ? void 0 : t2.signal);
    const s5 = e2.type;
    if (!this.supportedSourceTypes.has(s5)) throw new s2("feature-layer-source:unsupported-type", `Source type "${s5}" is not supported`);
  }
  async _patchServiceJSON(e2, t2) {
    var _a;
    if ("Table" !== e2.type && e2.geometryType && !((_a = e2 == null ? void 0 : e2.drawingInfo) == null ? void 0 : _a.renderer) && !e2.defaultSymbol) {
      const t3 = u(e2.geometryType).renderer;
      e("drawingInfo.renderer", t3, e2);
    }
    if ("esriGeometryMultiPatch" === e2.geometryType && e2.infoFor3D && (e2.geometryType = "mesh"), null == e2.extent) try {
      const { data: s5 } = await U(this.layer.url, this._getLayerRequestOptions({ signal: t2 }));
      s5.spatialReference && (e2.extent = { xmin: 0, ymin: 0, xmax: 0, ymax: 0, spatialReference: s5.spatialReference });
    } catch (s5) {
      a(s5);
    }
    return e2;
  }
  async _ensureLatestMetadata(e2) {
    if (this.layer.userHasUpdateItemPrivileges && this.sourceJSON.cacheMaxAge > 0) return this._fetchService(null, { ...e2, cacheBust: true });
  }
  async _uploadMeshesAndGetAssetMapEditsJSON(e2) {
    const { addAssetFeatures: t2 } = e2;
    if (!(t2 == null ? void 0 : t2.length)) return null;
    if (await this._areAllAssetsAlreadyMapped(t2)) return null;
    const r3 = e2.addFeatures.filter((e3) => e3.geometry);
    if (t2.length !== r3.length + e2.updateFeatures.length) throw new s2("feature-layer-source:unsupported-mesh-edits", "Mixing attribute only edits with mesh geometry edits is not currently supported");
    const s5 = new Array(), a5 = /* @__PURE__ */ new Map();
    for (const i3 of t2) {
      const { geometry: e3 } = i3, { vertexSpace: t3 } = e3;
      if (a4(t3)) s5.push(e3);
      else {
        const t4 = e3.origin, { convertMeshVertexSpace: r4 } = await import("./convertMeshVertexSpace-N3WYIQOE.js"), n3 = await r4(e3, new a3({ origin: [t4.x, t4.y, t4.z ?? 0] }));
        a5.set(n3, e3), i3.geometry = n3, s5.push(n3);
      }
    }
    await this.uploadAssets(s5);
    for (const [i3, n3] of a5) n3.addExternalSources(i3.metadata.externalSources.items);
    return { adds: this._getAssetMapEditsJSON(t2), updates: [], deletes: [] };
  }
  _getAssetMapEditsJSON(e2) {
    const t2 = new Array(), r3 = this.layer.globalIdField, s5 = this.layer.parsedUrl;
    for (const a5 of e2) {
      const e3 = a5.geometry, { metadata: i3 } = e3, n3 = i3.getExternalSourcesOnService(s5), o2 = a5.getAttribute(r3);
      if (0 === n3.length) {
        n.getLogger(this).error(`Skipping feature ${o2}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);
        continue;
      }
      const { source: l } = n3.find(A3) ?? n3[0];
      for (const r4 of l) 1 === r4.parts.length ? t2.push({ globalId: r2(), parentGlobalId: o2, assetName: r4.assetName, assetHash: r4.parts[0].partHash, flags: [] }) : n.getLogger(this).error(`Skipping asset ${r4.assetName}. It does not have exactly one part, so we cannot map it to a feature.`);
    }
    return t2;
  }
  _createEditsResult(e2) {
    const t2 = e2.data, { layerId: r3 } = this.layer, s5 = [];
    let a5 = null;
    if (Array.isArray(t2)) for (const n3 of t2) s5.push({ id: n3.id, editedFeatures: n3.editedFeatures }), n3.id === r3 && (a5 = { addResults: n3.addResults ?? [], updateResults: n3.updateResults ?? [], deleteResults: n3.deleteResults ?? [], attachments: n3.attachments, editMoment: n3.editMoment });
    else a5 = t2;
    const i3 = y(a5);
    if (s5.length > 0) {
      i3.editedFeatureResults = [];
      for (const e3 of s5) {
        const { editedFeatures: t3 } = e3, r4 = (t3 == null ? void 0 : t3.spatialReference) ? new g(t3.spatialReference) : null;
        i3.editedFeatureResults.push({ layerId: e3.id, editedFeatures: I2(t3, r4) });
      }
    }
    return i3;
  }
  _createAttachmentErrorResult(e2, t2) {
    var _a;
    const r3 = ((_a = t2.details.messages) == null ? void 0 : _a[0]) || t2.message, s5 = t2.details.httpStatus || t2.details.messageCode;
    return { objectId: e2, globalId: null, error: new s2("feature-layer-source:attachment-failure", r3, { code: s5 }) };
  }
  _getFormDataForAttachment(e2, t2) {
    const r3 = e2 instanceof FormData ? e2 : e2 && e2.elements ? new FormData(e2) : null;
    if (r3) for (const s5 in t2) {
      const e3 = t2[s5];
      null != e3 && (r3.set ? r3.set(s5, e3) : r3.append(s5, e3));
    }
    return r3;
  }
  _getLayerRequestOptions(e2 = {}) {
    const { layer: t2, layer: { parsedUrl: r3, gdbVersion: s5 } } = this;
    return { ...e2, query: { gdbVersion: s5, layer: "dynamicDataSource" in t2 && t2.dynamicDataSource ? JSON.stringify({ source: t2.dynamicDataSource }) : void 0, ...r3.query, f: "json", ...this._createRequestQueryOptions(e2) }, responseType: "json" };
  }
  async _areAllAssetsAlreadyMapped(e2) {
    const { layer: t2 } = this, { globalIdField: r3, parsedUrl: a5 } = t2, i3 = "infoFor3D" in t2 ? t2.infoFor3D : null;
    if (null == i3 || null == r3) return false;
    const n3 = M(i3);
    if (null == n3) return false;
    const o2 = V(a5.path, `../${n3.id}`), u2 = new Array();
    for (const s5 of e2) {
      if (!(s5.geometry.metadata.getExternalSourcesOnService(a5).length > 0)) return false;
      u2.push(s5);
    }
    const l = u2.map((e3) => e3.getAttribute(r3)).filter(F);
    if (0 === l.length) return false;
    const { assetMapFieldRoles: { parentGlobalId: c2, assetHash: d3 } } = i3, p2 = new b({ where: `${c2} IN (${l.map((e3) => `'${e3}'`)})`, outFields: [d3, c2], returnGeometry: false }), y2 = await s4(o2, p2), { features: m4 } = y2;
    return 0 !== m4.length && !u2.some((e3) => {
      const t3 = e3.getAttribute(r3);
      if (!t3) return true;
      const { metadata: s5 } = e3.geometry, i4 = m4.filter((e4) => e4.getAttribute(c2) === t3);
      if (0 === i4.length) return true;
      const n4 = i4.map((e4) => e4.getAttribute(d3));
      return s5.getExternalSourcesOnService(a5).flatMap(({ source: e4 }) => e4.flatMap((e5) => e5.parts.map((e6) => e6.partHash))).some((e4) => n4.every((t4) => e4 !== t4));
    });
  }
};
r([m()], G.prototype, "type", void 0), r([m({ constructOnly: true })], G.prototype, "layer", void 0), r([m({ constructOnly: true })], G.prototype, "supportedSourceTypes", void 0), r([m({ readOnly: true })], G.prototype, "queryTask", null), G = r([a2("esri.layers.graphics.sources.FeatureLayerSource")], G);
var H = 1e3;
var B = G;

export {
  B
};
//# sourceMappingURL=chunk-BAANCITL.js.map
