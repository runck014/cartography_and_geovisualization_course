import {
  c
} from "./chunk-OJRG2YGM.js";
import {
  e as e2,
  n as n2
} from "./chunk-5PXF5FL6.js";
import {
  a,
  u
} from "./chunk-2L7UGRIC.js";
import "./chunk-E6IUAXXM.js";
import {
  m
} from "./chunk-NJKQE6C5.js";
import "./chunk-ENHHZ2WV.js";
import "./chunk-HKWBRI3V.js";
import {
  V
} from "./chunk-NW6OWOSJ.js";
import "./chunk-EVK6ZSVY.js";
import "./chunk-MSUBZ5BW.js";
import {
  x
} from "./chunk-YEDSTDY4.js";
import "./chunk-P4TUSPKE.js";
import "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import {
  e
} from "./chunk-CH3XVKUV.js";
import {
  s as s3
} from "./chunk-KI5F6KDS.js";
import {
  t
} from "./chunk-HACIIBEF.js";
import "./chunk-2BVPGUC2.js";
import "./chunk-BN24XFSK.js";
import "./chunk-547Z5YIS.js";
import "./chunk-4WB72ND2.js";
import "./chunk-LIUBAYCM.js";
import "./chunk-BLYF375M.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-WPERPIJF.js";
import {
  Z
} from "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-T6QS4ZNU.js";
import "./chunk-D3FSVA7H.js";
import "./chunk-6B4OMNPA.js";
import "./chunk-3GQ4PJDJ.js";
import "./chunk-QEJMJI2R.js";
import "./chunk-ECCHNTW6.js";
import "./chunk-WWNVF22O.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import {
  O as O2
} from "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import "./chunk-W6D3ECTZ.js";
import "./chunk-PJNOPBRY.js";
import "./chunk-23TJP3F6.js";
import "./chunk-EMVTPRQK.js";
import "./chunk-EDGKOPSL.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-SEUZ3J6J.js";
import {
  H,
  K,
  c as c2
} from "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import {
  i
} from "./chunk-JS7R723S.js";
import "./chunk-RCLWOQNR.js";
import "./chunk-DOTSJZHK.js";
import {
  d
} from "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  y
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  O2 as O,
  U as U2,
  s3 as s2
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  I,
  qt
} from "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import "./chunk-H77COA2S.js";
import "./chunk-7LJCT7EA.js";
import "./chunk-MV5XBD6C.js";
import {
  b
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/locationUtils.js
function n3(n4, d3, i2) {
  var _a, _b;
  d3 = (_a = c2(d3)) == null ? void 0 : _a.toLowerCase(), i2 = (_b = c2(i2)) == null ? void 0 : _b.toLowerCase();
  const o2 = n4.map((e3) => e3.toLowerCase()), a3 = d3 ? n4[o2.indexOf(d3)] : null, u3 = i2 ? n4[o2.indexOf(i2)] : null;
  return { longitudeFieldName: a3 || n4[o2.indexOf(t2.find((e3) => o2.includes(e3)))], latitudeFieldName: u3 || n4[o2.indexOf(l.find((e3) => o2.includes(e3)))] };
}
var l = ["lat", "lat83", "latitude", "latitude83", "latdecdeg", "lat_dd", "y", "ycenter", "point_y"];
var t2 = ["lon", "lng", "lng83", "long", "long83", "longitude", "longitude83", "longdecdeg", "long_dd", "x", "xcenter", "point_x"];

// node_modules/@arcgis/core/layers/graphics/sources/csv/csv.js
var o = /^\s*"([\S\s]*)"\s*$/;
var l2 = /""/g;
var s4 = "\n";
var u2 = [",", " ", ";", "|", "	"];
function* c3(e3, t3, n4) {
  let r = 0;
  for (; r <= e3.length; ) {
    const i2 = e3.indexOf(t3, r), o2 = e3.slice(r, i2 > -1 ? i2 : void 0);
    r += o2.length + t3.length, n4 && !o2.trim() || (yield o2);
  }
}
function f(e3) {
  const t3 = e3.includes("\r\n") ? "\r\n" : s4;
  return c3(e3, t3, true);
}
function a2(e3, t3) {
  return c3(e3, t3, false);
}
function d2(e3, t3, n4) {
  e3 = e3.trim(), t3 = t3 == null ? void 0 : t3.trim();
  const r = [], o2 = Array.from(/* @__PURE__ */ new Set([n4 == null ? void 0 : n4.delimiter, ...u2])).filter((e4) => null != e4);
  for (const i2 of o2) {
    const n5 = g2(e3, i2).length, o3 = g2(t3, i2).length ?? n5;
    n5 > 1 && r.push({ weight: Math.min(n5, o3), delimiter: i2 });
  }
  const l3 = r.sort(({ weight: e4 }, { weight: t4 }) => t4 - e4).map(({ delimiter: e4 }) => e4);
  for (const s5 of l3) {
    const t4 = m2(e3, s5).names, r2 = n3(t4, n4 == null ? void 0 : n4.longitudeField, n4 == null ? void 0 : n4.latitudeField);
    if (r2.longitudeFieldName && r2.latitudeFieldName) return { delimiter: s5, locationInfo: r2 };
  }
  return { delimiter: l3[0], locationInfo: null };
}
function* p(e3, t3, n4, r = () => /* @__PURE__ */ Object.create(null)) {
  const i2 = f(e3);
  i2.next();
  let u3 = "", c4 = "", d3 = 0, p2 = r(), m3 = 0;
  e: for (const f2 of i2) {
    const e4 = a2(f2, n4);
    for (const i3 of e4) if (u3 += c4 + i3, c4 = "", d3 += h(i3), d3 % 2 == 0) {
      if (d3 > 0) {
        const e5 = o.exec(u3);
        if (!e5) {
          p2 = r(), m3 = 0, u3 = "", d3 = 0;
          continue e;
        }
        p2[t3[m3]] = e5[1].replaceAll(l2, '"'), m3++;
      } else p2[t3[m3]] = u3, m3++;
      u3 = "", d3 = 0;
    } else c4 = n4;
    0 === d3 ? (yield p2, p2 = r(), m3 = 0) : c4 = s4;
  }
}
function m2(e3, t3) {
  const r = g2(e3, t3).filter((e4) => null != e4), i2 = r.map((e4) => c2(e4));
  for (let n4 = i2.length - 1; n4 >= 0; n4--) i2[n4] || (i2.splice(n4, 1), r.splice(n4, 1));
  return { names: i2, aliases: r };
}
function g2(e3, t3) {
  if (!(e3 == null ? void 0 : e3.length)) return [];
  const n4 = [];
  let r = "", i2 = "", s5 = 0;
  const u3 = a2(e3, t3);
  for (const c4 of u3) if (r += i2 + c4, i2 = "", s5 += h(c4), s5 % 2 == 0) {
    if (s5 > 0) {
      const e4 = o.exec(r);
      e4 && n4.push(e4[1].replaceAll(l2, '"'));
    } else n4.push(r);
    r = "", s5 = 0;
  } else i2 = t3;
  return n4;
}
function h(e3) {
  let t3 = 0, n4 = 0;
  for (n4 = e3.indexOf('"', n4); n4 >= 0; ) t3++, n4 = e3.indexOf('"', n4 + 1);
  return t3;
}
function N(e3, t3, n4, i2, o2) {
  const l3 = [], s5 = p(e3, n4, t3), u3 = [];
  for (const r of s5) {
    if (10 === u3.length) break;
    u3.push(r);
  }
  for (let c4 = 0; c4 < n4.length; c4++) {
    const e4 = n4[c4], t4 = i2[c4];
    if (e4 === o2.longitudeFieldName || e4 === o2.latitudeFieldName) l3.push({ name: e4, type: "esriFieldTypeDouble", alias: t4 });
    else {
      let n5;
      switch (b2(u3.map((t5) => t5[e4]))) {
        case "integer":
          n5 = "esriFieldTypeInteger";
          break;
        case "double":
          n5 = "esriFieldTypeDouble";
          break;
        case "date":
          n5 = "esriFieldTypeDate";
          break;
        default:
          n5 = "esriFieldTypeString";
      }
      l3.push({ name: e4, type: n5, alias: t4, length: K(n5) });
    }
  }
  return l3;
}
function b2(t3) {
  if (!t3.length) return "string";
  const n4 = /[^+\-.,0-9]/;
  return t3.map((t4) => {
    if ("" !== t4) {
      if (!n4.test(t4)) {
        let e3 = x2(t4);
        if (!isNaN(e3)) return /[.,]/.test(t4) || !Number.isInteger(e3) || e3 > 214783647 || e3 < -214783648 ? "double" : "integer";
        if (t4.includes("E")) {
          if (e3 = Number(t4), !Number.isNaN(e3)) return "double";
          if (t4.includes(",") && (t4 = t4.replace(",", "."), e3 = Number(t4), !Number.isNaN(e3))) return "double";
        }
      }
      return e2(t4) ? "date" : "string";
    }
  }).reduce((e3, t4) => void 0 === e3 ? t4 : void 0 === t4 ? e3 : e3 === t4 ? t4 : "string" === e3 || "string" === t4 ? "string" : "double" === e3 || "double" === t4 ? "double" : void 0);
}
var x2 = function() {
  const e3 = c(), n4 = new RegExp("^" + e3.regexp + "$"), r = new RegExp("[" + e3.group + "\\s\\xa0]", "g"), i2 = e3.factor;
  return (t3) => {
    const o2 = n4.exec(t3);
    if (e3.factor = i2, !o2) return NaN;
    let l3 = o2[1];
    if (!o2[1]) {
      if (!o2[2]) return NaN;
      l3 = o2[2], e3.factor *= -1;
    }
    return l3 = l3.replace(r, "").replace(e3.decimal, "."), +l3 * e3.factor;
  };
}();
function y2(e3) {
  return JSON.parse(JSON.stringify(e3));
}

// node_modules/@arcgis/core/layers/graphics/sources/support/CSVSourceWorker.js
var v = u("esriGeometryPoint");
var D = ["csv"];
var k = [0, 0];
var P = class {
  constructor(e3, t3) {
    this.x = e3, this.y = t3;
  }
};
var R = class {
  constructor() {
    this._queryEngine = null, this._snapshotFeatures = async (e3) => {
      const t3 = await this._fetch(e3);
      return this._createFeatures(t3);
    };
  }
  destroy() {
    var _a;
    (_a = this._queryEngine) == null ? void 0 : _a.destroy(), this._queryEngine = null;
  }
  async load(e3, t3 = {}) {
    var _a;
    this._loadOptions = e3;
    const [i2] = await Promise.all([this._fetch(t3.signal), this._checkProjection((_a = e3 == null ? void 0 : e3.parsingOptions) == null ? void 0 : _a.spatialReference)]), n4 = V2(i2, e3);
    this._locationInfo = n4.locationInfo, this._delimiter = n4.delimiter, this._queryEngine = this._createQueryEngine(n4);
    const r = await this._createFeatures(i2);
    this._queryEngine.featureStore.addMany(r);
    const { fullExtent: s5, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    if (n4.layerDefinition.extent = s5, o2) {
      const { start: e4, end: t4 } = o2;
      n4.layerDefinition.timeInfo.timeExtent = [e4, t4];
    }
    return n4;
  }
  async applyEdits() {
    throw new s("csv-layer:editing-not-supported", "applyEdits() is not supported on CSVLayer");
  }
  async queryFeatures(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQuery(e3, t3.signal);
  }
  async queryFeatureCount(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForCount(e3, t3.signal);
  }
  async queryObjectIds(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForIds(e3, t3.signal);
  }
  async queryExtent(e3 = {}, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForExtent(e3, t3.signal);
  }
  async querySnapping(e3, t3 = {}) {
    return await this._waitSnapshotComplete(), this._queryEngine.executeQueryForSnapping(e3, t3.signal);
  }
  async refresh(e3) {
    var _a;
    this._loadOptions.customParameters = e3, (_a = this._snapshotTask) == null ? void 0 : _a.abort(), this._snapshotTask = d(this._snapshotFeatures), this._snapshotTask.promise.then((e4) => {
      this._queryEngine.featureStore.clear(), e4 && this._queryEngine.featureStore.addMany(e4);
    }, (e4) => {
      this._queryEngine.featureStore.clear(), b(e4) || n.getLogger("esri.layers.CSVLayer").error(new s("csv-layer:refresh", "An error occurred during refresh", { error: e4 }));
    }), await this._waitSnapshotComplete();
    const { fullExtent: i2, timeExtent: o2 } = await this._queryEngine.fetchRecomputedExtents();
    return { extent: i2, timeExtent: o2 };
  }
  async _waitSnapshotComplete() {
    if (this._snapshotTask && !this._snapshotTask.finished) {
      try {
        await this._snapshotTask.promise;
      } catch {
      }
      return this._waitSnapshotComplete();
    }
  }
  async _fetch(t3) {
    const { url: i2, customParameters: r } = this._loadOptions;
    if (!i2) throw new s("csv-layer:invalid-source", "url not defined");
    const s5 = I(i2);
    return (await U(s5.path, { query: { ...s5.query, ...r }, responseType: "text", signal: t3 })).data;
  }
  _createQueryEngine(e3) {
    const { objectIdField: t3, fields: i2, extent: n4, timeInfo: r } = e3.layerDefinition, s5 = new m({ geometryType: "esriGeometryPoint", hasM: false, hasZ: false });
    return new V({ fieldsIndex: Z.fromLayerJSON({ fields: i2, dateFieldsTimeReference: { timeZoneIANA: i } }), geometryType: "esriGeometryPoint", hasM: false, hasZ: false, timeInfo: r, objectIdField: t3, spatialReference: n4.spatialReference || { wkid: 4326 }, featureStore: s5 });
  }
  async _createFeatures(e3) {
    const { latitudeFieldName: t3, longitudeFieldName: n4 } = this._locationInfo, { objectIdField: r, fieldsIndex: s5, spatialReference: o2 } = this._queryEngine;
    let a3 = [];
    const u3 = [], h2 = s5.fields.filter((e4) => e4.name !== r).map((e4) => e4.name);
    let g3 = 0;
    const I2 = {};
    for (const i2 of s5.fields) if ("esriFieldTypeOID" !== i2.type && "esriFieldTypeGlobalID" !== i2.type) {
      const e4 = H(i2);
      void 0 !== e4 && (I2[i2.name] = e4);
    }
    const E = p(e3, h2, this._delimiter, a(I2, r));
    for (const l3 of E) {
      const e4 = this._parseCoordinateValue(l3[t3]), o3 = this._parseCoordinateValue(l3[n4]);
      if (null != o3 && null != e4 && !isNaN(e4) && !isNaN(o3)) {
        l3[t3] = e4, l3[n4] = o3;
        for (const e5 in l3) if (e5 !== t3 && e5 !== n4) if (s5.isDateField(e5)) l3[e5] = n2(l3[e5]);
        else if (s5.isNumericField(e5)) {
          const t4 = x2(l3[e5]);
          isNaN(t4) ? l3[e5] = null : l3[e5] = t4;
        } else null != l3[e5] && (l3[e5] = y2(l3[e5]));
        l3[r] = g3, g3++, a3.push(new P(o3, e4)), u3.push(l3);
      }
    }
    if (!s2({ wkid: 4326 }, o2)) if (O(o2)) for (const i2 of a3) [i2.x, i2.y] = y(i2.x, i2.y, k);
    else a3 = O2(t, a3, g.WGS84, o2, null, null);
    const j = [];
    for (let i2 = 0; i2 < a3.length; i2++) {
      const { x: e4, y: t4 } = a3[i2], n5 = u3[i2];
      n5[r] = i2 + 1, j.push(new e(new s3([], [e4, t4]), n5, null, n5[r]));
    }
    return j;
  }
  _parseCoordinateValue(e3) {
    if (null == e3 || "" === e3) return null;
    let t3 = x2(e3);
    return (isNaN(t3) || Math.abs(t3) > 181) && (t3 = parseFloat(e3)), t3;
  }
  async _checkProjection(e3) {
    try {
      await x(U2, e3);
    } catch {
      throw new s("csv-layer:projection-not-supported", "Projection not supported");
    }
  }
};
function V2(e3, t3) {
  var _a, _b, _c;
  const i2 = t3.parsingOptions || {}, r = { delimiter: i2.delimiter, layerDefinition: null, locationInfo: { latitudeFieldName: i2.latitudeField, longitudeFieldName: i2.longitudeField } }, s5 = r.layerDefinition = { name: qt(t3.url, D) || "csv", dateFieldsTimeReference: { timeZoneIANA: i }, drawingInfo: v, geometryType: "esriGeometryPoint", objectIdField: null, fields: [], timeInfo: i2.timeInfo, extent: { xmin: Number.POSITIVE_INFINITY, ymin: Number.POSITIVE_INFINITY, xmax: Number.NEGATIVE_INFINITY, ymax: Number.NEGATIVE_INFINITY, spatialReference: i2.spatialReference || { wkid: 4326 } } }, o2 = f(e3), l3 = (_a = o2.next().value) == null ? void 0 : _a.trim(), m3 = (_b = o2.next().value) == null ? void 0 : _b.trim();
  if (!l3) throw new s("csv-layer:empty-csv", "CSV is empty", { csv: e3 });
  const { delimiter: c4, locationInfo: d3 } = d2(l3, m3, i2);
  if (!c4) throw new s("csv-layer:invalid-delimiter", "Unable to detect the delimiter from CSV", { firstLine: l3, secondLine: m3, parsingOptions: i2 });
  if (!d3) throw new s("csv-layer:location-fields-not-found", "Unable to identify latitude and longitude fields from the CSV file", { firstLine: l3, secondLine: m3, parsingOptions: i2 });
  r.locationInfo = d3, r.delimiter = c4;
  const { names: u3, aliases: f2 } = m2(l3, c4), p2 = N(e3, r.delimiter, u3, f2, r.locationInfo);
  if ((_c = i2.fields) == null ? void 0 : _c.length) {
    const e4 = new Z(i2.fields);
    for (const t4 of p2) {
      const i3 = e4.get(t4.name);
      i3 && Object.assign(t4, i3);
    }
  }
  if (!p2.some((e4) => "esriFieldTypeOID" === e4.type && (s5.objectIdField = e4.name, true))) {
    const e4 = { name: "__OBJECTID", alias: "__OBJECTID", type: "esriFieldTypeOID", editable: false, nullable: false };
    s5.objectIdField = e4.name, p2.unshift(e4);
  }
  s5.fields = p2;
  const y3 = new Z(s5.fields);
  if (r.locationInfo && (r.locationInfo.latitudeFieldName = y3.get(r.locationInfo.latitudeFieldName).name, r.locationInfo.longitudeFieldName = y3.get(r.locationInfo.longitudeFieldName).name), s5.timeInfo) {
    const e4 = s5.timeInfo;
    if (e4.startTimeField) {
      const t4 = y3.get(e4.startTimeField);
      t4 ? (e4.startTimeField = t4.name, t4.type = "esriFieldTypeDate") : e4.startTimeField = null;
    }
    if (e4.endTimeField) {
      const t4 = y3.get(e4.endTimeField);
      t4 ? (e4.endTimeField = t4.name, t4.type = "esriFieldTypeDate") : e4.endTimeField = null;
    }
    if (e4.trackIdField) {
      const t4 = y3.get(e4.trackIdField);
      e4.trackIdField = t4 ? t4.name : null;
    }
    e4.startTimeField || e4.endTimeField || (s5.timeInfo = null);
  }
  return r;
}
export {
  R as default
};
//# sourceMappingURL=CSVSourceWorker-ICD7SDPI.js.map
