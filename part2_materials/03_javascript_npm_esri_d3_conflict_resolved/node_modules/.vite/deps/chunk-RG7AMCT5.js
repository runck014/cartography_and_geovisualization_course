import {
  E
} from "./chunk-4ISVH4NS.js";
import {
  x
} from "./chunk-7FJIOZSE.js";
import {
  _
} from "./chunk-UCO66LNK.js";
import {
  S
} from "./chunk-RD2BBQYN.js";
import {
  b as b2,
  p
} from "./chunk-SEG3PRUR.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  U,
  i
} from "./chunk-CRH37WFF.js";
import {
  K,
  N,
  W
} from "./chunk-YFGQMO6E.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  b,
  s as s3
} from "./chunk-GRW2QIBT.js";
import {
  u
} from "./chunk-R2PAF6JT.js";
import {
  n2 as n,
  s,
  s2
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/layers/mixins/PortalLayer.js
var j = (j2) => {
  let _2 = class extends j2 {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = true, this.userHasFullEditingPrivileges = false, this.userHasUpdateItemPrivileges = false;
    }
    destroy() {
      this.portalItem = u(this.portalItem), this.resourceReferences.portalItem = null, this.resourceReferences.paths.length = 0;
    }
    set portalItem(t) {
      t !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", t));
    }
    readPortalItem(t, e, r3) {
      if (e.itemId) return new S({ id: e.itemId, portal: r3 == null ? void 0 : r3.portal });
    }
    writePortalItem(t, e) {
      (t == null ? void 0 : t.id) && (e.itemId = t.id);
    }
    async loadFromPortal(t, e) {
      var _a;
      if ((_a = this.portalItem) == null ? void 0 : _a.id) try {
        const { load: r3 } = await import("./layersLoader-5STFESGM.js");
        return s3(e), await r3({ instance: this, supportedTypes: t.supportedTypes, validateItem: t.validateItem, supportsData: t.supportsData, layerModuleTypeMap: t.layerModuleTypeMap }, e);
      } catch (r3) {
        throw b(r3) || n.getLogger(this).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${r3}`), r3;
      }
    }
    async finishLoadEditablePortalLayer(t) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(t).catch((t2) => (a(t2), true)));
    }
    async setUserPrivileges(t, r3) {
      if (!s.userPrivilegesApplied) return this.finishLoadEditablePortalLayer(r3);
      if (this.url) try {
        const { features: { edit: e, fullEdit: s4 }, content: { updateItem: i2 } } = await this._fetchUserPrivileges(t, r3);
        this._set("userHasEditingPrivileges", e), this._set("userHasFullEditingPrivileges", s4), this._set("userHasUpdateItemPrivileges", i2);
      } catch (s4) {
        a(s4);
      }
    }
    async _fetchUserPrivileges(t, e) {
      var _a;
      let s4 = this.portalItem;
      if (!t || !s4 || !s4.loaded || s4.sourceUrl) return this._fetchFallbackUserPrivileges(e);
      const i2 = t === s4.id;
      if (i2 && s4.portal.user) return E(s4);
      let o2, a3;
      if (i2) o2 = s4.portal.url;
      else try {
        o2 = await x(this.url, e);
      } catch (d) {
        a(d);
      }
      if (!o2 || !W(o2, s4.portal.url)) return this._fetchFallbackUserPrivileges(e);
      try {
        const t2 = null != e ? e.signal : null;
        a3 = await ((_a = i) == null ? void 0 : _a.getCredential(`${o2}/sharing`, { prompt: false, signal: t2 }));
      } catch (d) {
        a(d);
      }
      const l = true, n2 = false, p2 = false;
      if (!a3) return { features: { edit: l, fullEdit: n2 }, content: { updateItem: p2 } };
      try {
        if (i2 ? await s4.reload() : (s4 = new S({ id: t, portal: { url: o2 } }), await s4.load(e)), s4.portal.user) return E(s4);
      } catch (d) {
        a(d);
      }
      return { features: { edit: l, fullEdit: n2 }, content: { updateItem: p2 } };
    }
    async _fetchFallbackUserPrivileges(t) {
      let e = true;
      try {
        e = await this._fetchUserHasEditingPrivileges(t);
      } catch (r3) {
        a(r3);
      }
      return { features: { edit: e, fullEdit: false }, content: { updateItem: false } };
    }
    async _fetchUserHasEditingPrivileges(t) {
      var _a;
      const e = this.url ? (_a = i) == null ? void 0 : _a.findCredential(this.url) : null;
      if (!e) return true;
      const s4 = E2.credential === e ? E2.user : await this._fetchEditingUser(t);
      return E2.credential = e, E2.user = s4, null == (s4 == null ? void 0 : s4.privileges) || s4.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(t) {
      var _a, _b, _c;
      const e = (_b = (_a = this.portalItem) == null ? void 0 : _a.portal) == null ? void 0 : _b.user;
      if (e) return e;
      const o2 = (_c = i) == null ? void 0 : _c.findServerInfo(this.url ?? "");
      if (!(o2 == null ? void 0 : o2.owningSystemUrl)) return null;
      const a3 = `${o2.owningSystemUrl}/sharing/rest`, l = b2.getDefault();
      if (l && l.loaded && K(l.restUrl) === K(a3)) return l.user;
      const n2 = `${a3}/community/self`, p2 = null != t ? t.signal : null, u2 = await _(U(n2, { authMode: "no-prompt", query: { f: "json" }, signal: p2 }));
      return u2.ok ? p.fromJSON(u2.value.data) : null;
    }
    read(t, e) {
      e && (e.layer = this), super.read(t, e);
    }
    write(t, e) {
      var _a;
      const r3 = e == null ? void 0 : e.portal, s4 = ((_a = this.portalItem) == null ? void 0 : _a.id) && (this.portalItem.portal || b2.getDefault());
      return r3 && s4 && !N(s4.restUrl, r3.restUrl) ? (e.messages && e.messages.push(new s2("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(t, { ...e, layer: this });
    }
  };
  return r([m({ type: S })], _2.prototype, "portalItem", null), r([o("web-document", "portalItem", ["itemId"])], _2.prototype, "readPortalItem", null), r([r2("web-document", "portalItem", { itemId: { type: String } })], _2.prototype, "writePortalItem", null), r([m({ clonable: false })], _2.prototype, "resourceReferences", void 0), r([m({ type: Boolean, readOnly: true })], _2.prototype, "userHasEditingPrivileges", void 0), r([m({ type: Boolean, readOnly: true })], _2.prototype, "userHasFullEditingPrivileges", void 0), r([m({ type: Boolean, readOnly: true })], _2.prototype, "userHasUpdateItemPrivileges", void 0), _2 = r([a2("esri.layers.mixins.PortalLayer")], _2), _2;
};
var E2 = { credential: null, user: null };

export {
  j
};
//# sourceMappingURL=chunk-RG7AMCT5.js.map
