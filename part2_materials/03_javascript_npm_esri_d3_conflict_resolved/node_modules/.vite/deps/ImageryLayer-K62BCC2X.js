import {
  B as B2,
  L,
  N,
  U as U2,
  a as a5,
  c as c3,
  c2 as c4,
  c3 as c5,
  d as d5,
  ee,
  f as f6,
  f2 as f7,
  g as g4,
  i as i4,
  l as l6,
  n as n6,
  o as o2,
  p as p5,
  q as q2,
  t as t4
} from "./chunk-MXQ2OMUY.js";
import {
  d as d6,
  g as g3,
  m as m3,
  p as p4
} from "./chunk-MCIWLF5F.js";
import "./chunk-5OJUBUJF.js";
import "./chunk-OZQVNYO5.js";
import {
  t as t2
} from "./chunk-LFMMBYIR.js";
import {
  A as A2,
  B2 as B,
  P,
  P2,
  _,
  c2,
  j as j3,
  m as m2,
  n2 as n4,
  n4 as n5
} from "./chunk-5XQEH26Y.js";
import {
  g as g2,
  l4,
  s as s7,
  s3 as s8
} from "./chunk-7PP3YNSG.js";
import {
  s as s4,
  s2 as s5
} from "./chunk-5TUUVC6K.js";
import {
  s as s6
} from "./chunk-LTKYSPF4.js";
import "./chunk-X3DAAXDC.js";
import "./chunk-A3GASGJZ.js";
import "./chunk-RH3RAT7T.js";
import "./chunk-556C3V64.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import "./chunk-UFFVFTYV.js";
import "./chunk-BLYF375M.js";
import {
  t as t3
} from "./chunk-TGFVKJXH.js";
import {
  l as l2
} from "./chunk-SVRTKGNR.js";
import {
  l as l3
} from "./chunk-ZE6OS33V.js";
import "./chunk-MWZJIOOL.js";
import {
  p as p3
} from "./chunk-ULSRCITK.js";
import {
  e
} from "./chunk-FLUE3DMC.js";
import "./chunk-43KBLSS3.js";
import {
  A
} from "./chunk-WH2FR6UE.js";
import {
  j as j2
} from "./chunk-RG7AMCT5.js";
import {
  f as f3
} from "./chunk-PV3ZZQOV.js";
import {
  l
} from "./chunk-SM2VXWMT.js";
import "./chunk-WYO25WZZ.js";
import "./chunk-OC7D2HR4.js";
import {
  t
} from "./chunk-IGMG7ERK.js";
import {
  b as b3
} from "./chunk-V47ZBW5W.js";
import {
  d as d4,
  f2 as f5,
  l as l5,
  y as y2
} from "./chunk-HKYICNT2.js";
import {
  S
} from "./chunk-VGUQMPM6.js";
import "./chunk-KKH7HGO3.js";
import {
  b as b2
} from "./chunk-PNVXSHN2.js";
import "./chunk-3DVL3O3F.js";
import "./chunk-RN66FJAW.js";
import "./chunk-2RIHQI4N.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-NXGNMEHZ.js";
import "./chunk-TWYDW6LU.js";
import {
  d as d3
} from "./chunk-PVHAAI32.js";
import "./chunk-MLATPUII.js";
import "./chunk-NVFQGMP6.js";
import "./chunk-P2IB5HBH.js";
import "./chunk-XX37BOHH.js";
import "./chunk-5CRXWQ3Y.js";
import "./chunk-4ISVH4NS.js";
import "./chunk-NIWINVGG.js";
import "./chunk-DOENTAA7.js";
import "./chunk-CVI4GL5M.js";
import "./chunk-CGSFKZP2.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-WPERPIJF.js";
import {
  Z
} from "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import {
  R
} from "./chunk-6B4OMNPA.js";
import "./chunk-3GQ4PJDJ.js";
import {
  f as f8
} from "./chunk-QMGMKWTA.js";
import "./chunk-2EGO74J5.js";
import "./chunk-4SUK447J.js";
import "./chunk-2X7T37AY.js";
import {
  d as d2
} from "./chunk-6Q7GN2CW.js";
import {
  q
} from "./chunk-MYUZZ3A3.js";
import "./chunk-2IGXKE5P.js";
import "./chunk-JFI4ESYU.js";
import "./chunk-4X2UADDH.js";
import "./chunk-ZICJB3ML.js";
import "./chunk-AVBIV2K3.js";
import "./chunk-4NJWIUZG.js";
import {
  b
} from "./chunk-F3NUC2RS.js";
import {
  s as s2
} from "./chunk-LE3YW4Y3.js";
import {
  p as p2
} from "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import "./chunk-P3GRQ2CH.js";
import {
  i as i2
} from "./chunk-NYLBGE62.js";
import "./chunk-LPNAPHOF.js";
import {
  y
} from "./chunk-QCBTLG25.js";
import "./chunk-ECCHNTW6.js";
import {
  f as f4,
  i as i3,
  s as s3
} from "./chunk-WWNVF22O.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import {
  d
} from "./chunk-W6D3ECTZ.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-SEUZ3J6J.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import {
  n as n3
} from "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import {
  f as f2,
  p
} from "./chunk-3L2AYCZY.js";
import {
  r as r3
} from "./chunk-TSVUPARM.js";
import {
  u,
  v2 as v
} from "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-RCLWOQNR.js";
import "./chunk-DOTSJZHK.js";
import "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  j2 as j,
  w
} from "./chunk-FG3XOAFD.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  g,
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  Ue,
  c,
  de,
  fe
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import {
  n as n2
} from "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  I
} from "./chunk-YFGQMO6E.js";
import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a2 as a3,
  a4,
  h,
  i2 as i,
  x
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a as a2,
  k
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  a,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionSchema.js
var e2 = { StretchFunction: { arguments: { ComputeGamma: { isDataset: false, isPublic: false, name: "ComputeGamma", type: "RasterFunctionVariable", value: false }, DRA: { isDataset: false, isPublic: false, name: "DRA", type: "RasterFunctionVariable", value: false }, EstimateStatsHistogram: { isDataset: false, isPublic: false, name: "EstimateStatsHistogram", type: "RasterFunctionVariable", value: false }, Gamma: { displayName: "Gamma", isDataset: false, isPublic: false, name: "Gamma", type: "RasterFunctionVariable" }, Histograms: { isDataset: false, isPublic: false, name: "Histograms", type: "RasterFunctionVariable" }, Max: { isDataset: false, isPublic: false, name: "Max", type: "RasterFunctionVariable", value: 255 }, MaxPercent: { isDataset: false, isPublic: false, name: "MaxPercent", type: "RasterFunctionVariable", value: 0.5 }, Min: { isDataset: false, isPublic: false, name: "Min", type: "RasterFunctionVariable", value: 0 }, MinPercent: { isDataset: false, isPublic: false, name: "MinPercent", type: "RasterFunctionVariable", value: 0.25 }, NumberOfStandardDeviations: { isDataset: false, isPublic: false, name: "NumberOfStandardDeviation", type: "RasterFunctionVariable", value: 2 }, Raster: { isDataset: true, isPublic: false, name: "Raster", type: "RasterFunctionVariable" }, SigmoidStrengthLevel: { isDataset: false, isPublic: false, name: "SigmoidStrengthLevel", type: "RasterFunctionVariable", value: 2 }, Statistics: { isDataset: false, isPublic: false, name: "Statistics", type: "RasterFunctionVariable" }, StretchType: { isDataset: false, isPublic: false, name: "StretchType", type: "RasterFunctionVariable", value: 0 }, type: "StretchFunctionArguments", UseGamma: { isDataset: false, isPublic: false, name: "UseGamma", type: "RasterFunctionVariable", value: false } }, description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", function: { description: "Enhances an image by adjusting the range of values displayed. This does not alter the underlying pixel values. If a pixel has a value outside of the specified range, it will appear as either the minimum or maximum value.", name: "Stretch", pixelType: "UNKNOWN", type: "StretchFunction" }, functionType: 0, name: "Stretch", thumbnail: "" }, RemapFunction: { name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table.", function: { type: "RemapFunction", pixelType: "UNKNOWN", name: "Remap", description: "Changes pixel values by assigning new values to ranges of pixel values or using an external table." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, UseTable: { name: "UseTable", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, InputRanges: { name: "InputRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Input Ranges" }, OutputValues: { name: "OutputValues", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "Output Values" }, NoDataRanges: { name: "NoDataRanges", isPublic: false, isDataset: false, type: "RasterFunctionVariable", displayName: "NoData Ranges" }, Table: { name: "Table", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputField: { name: "InputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, OutputField: { name: "OutputField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, InputMaxField: { name: "InputMaxField", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, RemapTableType: { name: "RemapTableType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, AllowUnmatched: { name: "AllowUnmatched", isPublic: false, isDataset: false, value: true, type: "RasterFunctionVariable" }, type: "RemapFunctionArguments" }, functionType: 0, thumbnail: "" }, ColormapFunction: { name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp.", function: { type: "ColormapFunction", pixelType: "UNKNOWN", name: "Colormap", description: "Changes pixel values to display the raster data as either a grayscale or a red, green, blue (RGB) image, based on a colormap or a color ramp." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, ColormapName: { name: "ColormapName", isPublic: false, isDataset: false, value: "Gray", type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, type: "ColormapFunctionArguments" }, functionType: 0, thumbnail: "" }, ShadedReliefFunction: { name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image.", function: { type: "ShadedReliefFunction", pixelType: "UNKNOWN", name: "Shaded Relief", description: "Creates a multiband, color coded, 3D representation of the surface, with the sun's relative position taken into account for shading the image." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ColorSchemeType: { name: "ColorSchemeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ColorRamp: { name: "ColorRamp", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Colormap: { name: "Colormap", isPublic: false, isDataset: false, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "ShadedReliefFunctionArguments" }, functionType: 0, thumbnail: "" }, HillshadeFunction: { name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image", function: { type: "HillshadeFunction", pixelType: "UNKNOWN", name: "Hillshade", description: "Creates a 3D representation of the surface, with the sun's relative position taken into account for shading the image" }, arguments: { DEM: { name: "DEM", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, HillshadeType: { name: "HillshadeType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, Azimuth: { name: "Azimuth", isPublic: false, isDataset: false, value: 315, type: "RasterFunctionVariable" }, Altitude: { name: "Altitude", isPublic: false, isDataset: false, value: 45, type: "RasterFunctionVariable" }, SlopeType: { name: "SlopeType", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, ZFactor: { name: "ZFactor", isPublic: false, isDataset: false, value: 1, type: "RasterFunctionVariable" }, PSPower: { name: "PSPower", isPublic: false, isDataset: false, value: 0.664, type: "RasterFunctionVariable" }, PSZFactor: { name: "PSZFactor", isPublic: false, isDataset: false, value: 0.024, type: "RasterFunctionVariable" }, RemoveEdgeEffect: { name: "RemoveEdgeEffect", isPublic: false, isDataset: false, value: false, type: "RasterFunctionVariable" }, type: "HillshadeFunctionArguments" }, functionType: 0, thumbnail: "" }, ResampleFunction: { name: "Resample", description: "Changes the cell size of a raster.", function: { type: "ResampleFunction", pixelType: "UNKNOWN", name: "Resample", description: "Changes the cell size of a raster." }, arguments: { Raster: { name: "Raster", isPublic: false, isDataset: true, type: "RasterFunctionVariable" }, ResamplingType: { name: "ResamplingType", isPublic: false, isDataset: false, value: 0, type: "RasterFunctionVariable" }, InputCellSize: { name: "InputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, OutputCellSize: { name: "OutputCellsize", isPublic: false, isDataset: false, value: { x: 0, y: 0 }, type: "RasterFunctionVariable" }, type: "ResampleFunctionArguments" }, functionType: 0, thumbnail: "" } };

// node_modules/@arcgis/core/layers/support/imageryRendererUtils.js
var c6 = /* @__PURE__ */ new Set(["u1", "u2", "u4", "u8", "s8", "u16", "s16"]);
var m4 = { simple_scalar: "Simple Scalar", wind_barb: "Wind Barb", single_arrow: "Single Arrow", beaufort_kn: "Beaufort Wind (Knots)", beaufort_m: "Beaufort Wind (MetersPerSecond)", ocean_current_m: "Ocean Current (MetersPerSecond)", ocean_current_kn: "Ocean Current (Knots)" };
var f9 = /* @__PURE__ */ new Set(["raster-stretch", "unique-value", "class-breaks", "raster-shaded-relief", "vector-field", "raster-colormap"]);
function p6(e4) {
  return f9.has(e4.type);
}
function g5(n14, t6) {
  var _a;
  if (!n14 || !t6) return a(n14 || t6);
  const r4 = a(n14);
  if (r4.functionDefinition && t6.rasterFunctionDefinition) {
    const e4 = t6.rasterFunctionDefinition;
    (e4.thumbnail || e4.thumbnailEx) && (e4.thumbnail = e4.thumbnailEx = void 0), d7(r4.functionDefinition.arguments, t6), r4.rasterFunctionDefinition = r4.functionDefinition.toJSON();
  } else if ("none" !== ((_a = t6.functionName) == null ? void 0 : _a.toLowerCase())) {
    b4(r4.functionArguments).Raster = t6;
  }
  return r4;
}
function d7(e4, n14) {
  for (const t6 in e4) "raster" === t6.toLowerCase() && ("RasterFunctionVariable" === e4[t6].type ? (e4[t6] = n14.rasterFunctionDefinition, e4[t6].type = "RasterFunctionTemplate") : "RasterFunctionTemplate" === e4[t6].type && d7(e4[t6].arguments, n14));
}
function h2(n14) {
  const t6 = a(e2[n14.functionName + "Function"]), o3 = n14.functionArguments;
  for (const e4 in o3) "raster" === e4.toLowerCase() ? (t6.arguments[e4] = h2(o3[e4]), t6.arguments[e4].type = "RasterFunctionTemplate") : "colormap" === e4.toLowerCase() ? (t6.arguments[e4].value = V(o3[e4]), t6.arguments.ColorSchemeType.value = 0) : t6.arguments[e4].value = o3[e4];
  return t6;
}
function y3(e4, n14) {
  switch (n14 = n14 || {}, e4.type) {
    case "raster-stretch":
      return S2(e4, n14);
    case "class-breaks":
      return w2(e4, n14);
    case "unique-value":
      return F(e4, n14);
    case "raster-colormap":
      return N2(e4, n14);
    case "vector-field":
      return T(e4, n14);
    case "raster-shaded-relief":
      return v2(e4, n14);
    case "flow":
      throw new Error("Unsupported rendering rule.");
  }
}
function b4(e4) {
  const n14 = (e4 == null ? void 0 : e4.Raster) ?? (e4 == null ? void 0 : e4.raster);
  return n14 && "esri.layers.support.RasterFunction" === n14.declaredClass ? b4(n14.functionArguments) : e4;
}
var R2 = { none: 0, standardDeviation: 3, histogramEqualization: 4, minMax: 5, percentClip: 6, sigmoid: 9 };
function T(e4, t6) {
  const r4 = new N();
  r4.functionName = "VectorFieldRenderer";
  const { dataType: o3, bandNames: a14 } = t6, i11 = "vector-uv" === o3;
  let s10, u6;
  if (a14 && 2 === a14.length) {
    const e5 = a14.map((e6) => e6.toLowerCase());
    s10 = e5.indexOf("magnitude"), u6 = e5.indexOf("direction");
  }
  -1 !== s10 && null !== s10 || (s10 = 0, u6 = 1);
  const c24 = "arithmetic" === e4.rotationType ? 1 : 2, f10 = "flow-from" === e4.flowRepresentation ? 0 : 1, p21 = e4.visualVariables ? e4.visualVariables.find((e5) => "Magnitude" === e5.field) : new b2(), g6 = { magnitudeBandID: s10, directionBandID: u6, isUVComponents: i11, referenceSystem: c24, massFlowAngleRepresentation: f10, symbolTileSize: 50, symbolTileSizeUnits: 100, calculationMethod: "Vector Average", symbologyName: m4[e4.style.toLowerCase().replace("-", "_")], minimumMagnitude: p21.minDataValue, maximumMagnitude: p21.maxDataValue, minimumSymbolSize: p21.minSize, maximumSymbolSize: p21.maxSize };
  r4.functionArguments = g6;
  const d10 = h2(r4);
  return t6.convertToRFT ? N.fromJSON({ rasterFunctionDefinition: d10 }) : r4;
}
function v2(e4, t6) {
  const r4 = t6.convertToRFT;
  if ("elevation" !== t6.dataType && ("generic" !== t6.dataType || 1 !== t6.bandCount || "s16" !== t6.pixelType && "s32" !== t6.pixelType && "f32" !== t6.pixelType && "f64" !== t6.pixelType)) return new N();
  const i11 = new N();
  i11.functionName = "Hillshade";
  const s10 = "traditional" === e4.hillshadeType ? 0 : 1, u6 = "none" === e4.scalingType ? 1 : 3, l14 = { HillshadeType: s10, SlopeType: u6, ZFactor: e4.zFactor };
  return 0 === s10 && (l14.Azimuth = e4.azimuth, l14.Altitude = e4.altitude), 3 === u6 && (l14.PSPower = e4.pixelSizePower, l14.PSZFactor = e4.pixelSizeFactor), i11.functionArguments = l14, i11.variableName = "Raster", e4.colorRamp && (i11.functionName = "ShadedRelief", r4 ? l14.ColorRamp = A2(e4.colorRamp) : l14.Colormap = B(e4.colorRamp)), r4 ? new N({ rasterFunctionDefinition: h2(i11) }) : i11;
}
function S2(e4, t6) {
  var _a, _b;
  const r4 = t6.convertToRFT, s10 = new N();
  s10.functionName = "Stretch";
  const l14 = R2[n5.toJSON(e4.stretchType)], c24 = "u8", m14 = (_a = e4.customStatistics) == null ? void 0 : _a.map((e5) => [e5.min, e5.max, e5.avg ?? 0, e5.stddev ?? 1]), f10 = { StretchType: l14, Statistics: m14, DRA: e4.dynamicRangeAdjustment, UseGamma: e4.useGamma, Gamma: e4.gamma, ComputeGamma: e4.computeGamma };
  if (null != e4.outputMin && (f10.Min = e4.outputMin), null != e4.outputMax && (f10.Max = e4.outputMax), l14 === R2.standardDeviation ? (f10.NumberOfStandardDeviations = e4.numberOfStandardDeviations, s10.outputPixelType = c24) : l14 === R2.percentClip ? (f10.MinPercent = e4.minPercent, f10.MaxPercent = e4.maxPercent, s10.outputPixelType = c24) : l14 === R2.minMax ? s10.outputPixelType = c24 : l14 === R2.sigmoid && (f10.SigmoidStrengthLevel = e4.sigmoidStrengthLevel), s10.functionArguments = f10, s10.variableName = "Raster", e4.colorRamp) {
    const u6 = e4.colorRamp, l15 = new N();
    if (r4) l15.functionArguments = { ColorRamp: A2(u6) };
    else {
      const n14 = c2(u6, true);
      if (n14) l15.functionArguments = { colorRampName: n14 };
      else if (!t6.convertColorRampToColormap || "algorithmic" !== u6.type && "multipart" !== u6.type) {
        const n15 = e4.colorRamp.toJSON();
        "algorithmic" === n15.type ? n15.algorithm = n15.algorithm || "esriCIELabAlgorithm" : "multipart" === n15.type && ((_b = n15.colorRamps) == null ? void 0 : _b.length) && n15.colorRamps.forEach((e5) => e5.algorithm = e5.algorithm || "esriCIELabAlgorithm"), l15.functionArguments = { colorRamp: n15 };
      } else l15.functionArguments = { Colormap: B(u6) };
    }
    return l15.variableName = "Raster", l15.functionName = "Colormap", l15.functionArguments.Raster = s10, r4 ? new N({ rasterFunctionDefinition: h2(l15) }) : l15;
  }
  return r4 ? new N({ rasterFunctionDefinition: h2(s10) }) : s10;
}
function w2(e4, t6) {
  const r4 = [], o3 = [], a14 = [], i11 = [], s10 = 1e-4, { pixelType: u6, rasterAttributeTable: l14 } = t6, c24 = null == l14 ? null : l14.features, m14 = C(l14);
  if (m14 && c24 && Array.isArray(c24) && e4.classBreakInfos) {
    e4.classBreakInfos.forEach((n14, t7) => {
      var _a;
      const r6 = (_a = n14.symbol) == null ? void 0 : _a.color;
      let o5;
      (r6 == null ? void 0 : r6.a) && null != n14.minValue && null != n14.maxValue && c24.forEach((a15) => {
        null != n14.minValue && null != n14.maxValue && (o5 = a15.attributes[e4.field], (o5 >= n14.minValue && o5 < n14.maxValue || t7 === e4.classBreakInfos.length - 1 && o5 >= n14.minValue) && i11.push([a15.attributes[m14], r6.r, r6.g, r6.b]));
      });
    });
    const r5 = u6 ? x2(i11, u6) : i11, o4 = new N();
    return o4.functionName = "Colormap", o4.functionArguments = {}, o4.functionArguments.Colormap = r5, o4.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(o4) }) : o4;
  }
  e4.classBreakInfos.forEach((e5, n14) => {
    if (null == e5.minValue || null == e5.maxValue) return;
    const t7 = e5.symbol && e5.symbol.color;
    (t7 == null ? void 0 : t7.a) ? (0 === n14 ? r4.push(e5.minValue, e5.maxValue + s10) : r4.push(e5.minValue + s10, e5.maxValue + s10), o3.push(n14), i11.push([n14, t7.r, t7.g, t7.b])) : a14.push(e5.minValue, e5.maxValue);
  });
  const f10 = u6 ? x2(i11, u6) : i11, p21 = new N();
  p21.functionName = "Remap", p21.functionArguments = { InputRanges: r4, OutputValues: o3, NoDataRanges: a14 }, p21.variableName = "Raster";
  const g6 = new N();
  return g6.functionName = "Colormap", g6.functionArguments = { Colormap: f10, Raster: p21 }, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(g6) }) : g6;
}
function x2(e4, n14) {
  const r4 = c6.has(n14) ? s7(n14) : null;
  return r4 && e4.push([Math.floor(r4[0] - 1), 0, 0, 0], [Math.ceil(r4[1] + 1), 0, 0, 0]), e4;
}
function C(e4) {
  if (null == e4) return;
  const { fields: n14 } = e4, t6 = n14 == null ? void 0 : n14.find((e5) => (e5 == null ? void 0 : e5.name) && "value" === e5.name.toLowerCase());
  return t6 == null ? void 0 : t6.name;
}
function F(e4, t6) {
  var _a, _b;
  const r4 = [], { pixelType: o3, rasterAttributeTable: a14 } = t6, i11 = null == a14 ? null : a14.features, s10 = C(a14), u6 = (_b = (_a = e4.defaultSymbol) == null ? void 0 : _a.color) == null ? void 0 : _b.toRgb(), l14 = e4.uniqueValueInfos;
  if (l14) if (i11) {
    if (s10) {
      const n14 = /* @__PURE__ */ new Map();
      l14.forEach((e5) => {
        const t8 = e5.value, r5 = A3(e5);
        null != t8 && (r5 == null ? void 0 : r5.a) && n14.set(String(t8), r5.toRgb());
      });
      const t7 = e4.field;
      t7 && i11.forEach(({ attributes: e5 }) => {
        const o4 = String(e5[t7]), a15 = e5[s10], i12 = n14.get(o4);
        i12 ? r4.push([a15, ...i12]) : u6 && r4.push([a15, ...u6]);
      });
    }
  } else for (let n14 = 0; n14 < l14.length; n14++) {
    const e5 = l14[n14], t7 = A3(e5), o4 = +e5.value;
    if (t7 == null ? void 0 : t7.a) {
      if (isNaN(o4)) return null;
      r4.push([o4, t7.r, t7.g, t7.b]);
    }
  }
  const c24 = o3 ? x2(r4, o3) : r4, m14 = new N();
  return m14.functionName = "Colormap", m14.functionArguments = {}, m14.functionArguments.Colormap = c24, m14.variableName = "Raster", t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(m14) }) : m14;
}
function A3(e4) {
  var _a, _b, _c, _d, _e;
  return "polygon-3d" === ((_a = e4.symbol) == null ? void 0 : _a.type) ? (_d = (_c = (_b = e4.symbol.symbolLayers) == null ? void 0 : _b.find((e5) => "fill" === e5.type)) == null ? void 0 : _c.material) == null ? void 0 : _d.color : (_e = e4.symbol) == null ? void 0 : _e.color;
}
function N2(e4, t6) {
  const r4 = e4.extractColormap();
  if (!r4 || 0 === r4.length) return null;
  const { pixelType: o3 } = t6, a14 = o3 ? x2(r4, o3) : r4, i11 = new N();
  return i11.functionName = "Colormap", i11.functionArguments = {}, i11.functionArguments.Colormap = a14, t6.convertToRFT ? new N({ rasterFunctionDefinition: h2(i11) }) : i11;
}
function V(e4) {
  const n14 = [], t6 = [];
  return e4.forEach((e5) => {
    n14.push(e5[0]), t6.push(P2([...e5.slice(1), 255]));
  }), { type: "RasterColormap", values: n14, colors: t6 };
}

// node_modules/@arcgis/core/layers/support/ExportImageServiceParameters.js
var y4 = class extends f {
  constructor() {
    super(...arguments), this.layer = null, this.compression = void 0, this.pixelType = void 0, this.lercVersion = 2;
  }
  get adjustAspectRatio() {
    return this.layer.adjustAspectRatio;
  }
  writeAdjustAspectRatio(e4, t6, r4) {
    this.layer.version < 10.3 || (t6[r4] = e4);
  }
  get bandIds() {
    return this.layer.bandIds;
  }
  get compressionQuality() {
    return this.layer.compressionQuality;
  }
  writeCompressionQuality(e4, t6, r4) {
    this.format && this.format.toLowerCase().includes("jpg") && null != e4 && (t6[r4] = e4);
  }
  get compressionTolerance() {
    return this.layer.compressionTolerance;
  }
  writeCompressionTolerance(e4, t6, r4) {
    "lerc" === this.format && null != e4 && (t6[r4] = e4);
  }
  get format() {
    var _a;
    return "vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type) ? "lerc" : this.layer.format;
  }
  get interpolation() {
    return this.layer.interpolation;
  }
  get noData() {
    return this.layer.noData;
  }
  get noDataInterpretation() {
    return this.layer.noDataInterpretation;
  }
  writeLercVersion(e4, t6, r4) {
    "lerc" === this.format && this.layer.version >= 10.5 && (t6[r4] = e4);
  }
  get version() {
    const e4 = this.layer;
    return e4.commitProperty("bandIds"), e4.commitProperty("format"), e4.commitProperty("compressionQuality"), e4.commitProperty("compressionTolerance"), e4.commitProperty("interpolation"), e4.commitProperty("noData"), e4.commitProperty("noDataInterpretation"), e4.commitProperty("mosaicRule"), e4.commitProperty("rasterFunction"), e4.commitProperty("adjustAspectRatio"), e4.commitProperty("pixelFilter"), e4.commitProperty("definitionExpression"), e4.commitProperty("multidimensionalSubset"), (this._get("version") || 0) + 1;
  }
  set version(e4) {
    this._set("version", e4);
  }
  get mosaicRule() {
    const e4 = this.layer;
    let t6 = e4.mosaicRule;
    const r4 = e4.definitionExpression;
    return t6 ? r4 && r4 !== t6.where && (t6 = t6.clone(), t6.where = r4) : r4 && (t6 = new f6({ where: r4 })), t6;
  }
  get rasterFunction() {
    var _a, _b;
    const e4 = this.layer;
    let { rasterFunction: t6 } = e4;
    const r4 = e4.pixelFilter, o3 = !e4.format || e4.format.includes("jpg") || e4.format.includes("png");
    t6 = this._addResampleRasterFunction(t6);
    const i11 = (_a = e4.multidimensionalSubset) == null ? void 0 : _a.areaOfInterest;
    return i11 && (t6 = d8(t6, i11)), o3 && !r4 && "vector-field" !== ((_b = e4.renderer) == null ? void 0 : _b.type) && (t6 = this.combineRendererWithRenderingRule(t6)), t6;
  }
  combineRendererWithRenderingRule(e4) {
    const t6 = this.layer, { rasterInfo: r4, renderer: o3 } = t6;
    if (e4 = e4 || t6.rasterFunction, !o3 || !p6(o3)) return e4;
    return g5(y3(o3, { rasterAttributeTable: r4.attributeTable, pixelType: r4.pixelType, dataType: r4.dataType, bandNames: r4.bandInfos.map(({ name: e5 }) => e5), convertColorRampToColormap: t6.version < 10.6, convertToRFT: !!(e4 == null ? void 0 : e4.rasterFunctionDefinition), bandCount: r4.bandCount }), e4);
  }
  _addResampleRasterFunction(e4) {
    var _a;
    if (!("vector-field" === ((_a = this.layer.renderer) == null ? void 0 : _a.type)) || "Resample" === (e4 == null ? void 0 : e4.functionName)) return e4;
    const t6 = "esriImageServiceDataTypeVector-UV" === this.layer.serviceDataType ? 7 : 10, r4 = this.layer.serviceRasterInfo.pixelSize;
    let o3 = new N({ functionName: "Resample", functionArguments: { ResamplingType: t6, InputCellSize: r4 } });
    return o3 = (e4 == null ? void 0 : e4.rasterFunctionDefinition) ? new N({ rasterFunctionDefinition: h2(o3) }) : o3, g5(o3, e4);
  }
};
function d8(e4, t6) {
  const r4 = new N({ functionName: "Clip", functionArguments: { ClippingGeometry: t6.toJSON(), ClippingType: 1 } });
  return g5(r4, e4);
}
r([m()], y4.prototype, "layer", void 0), r([m({ json: { write: true } })], y4.prototype, "adjustAspectRatio", null), r([r2("adjustAspectRatio")], y4.prototype, "writeAdjustAspectRatio", null), r([m({ json: { write: true } })], y4.prototype, "bandIds", null), r([m({ json: { write: true } })], y4.prototype, "compression", void 0), r([m({ json: { write: true } })], y4.prototype, "compressionQuality", null), r([r2("compressionQuality")], y4.prototype, "writeCompressionQuality", null), r([m({ json: { write: true } })], y4.prototype, "compressionTolerance", null), r([r2("compressionTolerance")], y4.prototype, "writeCompressionTolerance", null), r([m({ json: { write: true } })], y4.prototype, "format", null), r([m({ type: String, json: { read: { reader: a5.read }, write: { writer: a5.write } } })], y4.prototype, "interpolation", null), r([m({ json: { write: true } })], y4.prototype, "noData", null), r([m({ type: String, json: { read: { reader: i4.read }, write: { writer: i4.write } } })], y4.prototype, "noDataInterpretation", null), r([m({ json: { write: true } })], y4.prototype, "pixelType", void 0), r([m({ json: { write: true } })], y4.prototype, "lercVersion", void 0), r([r2("lercVersion")], y4.prototype, "writeLercVersion", null), r([m({ type: Number })], y4.prototype, "version", null), r([m({ json: { write: true } })], y4.prototype, "mosaicRule", null), r([m({ json: { write: true, name: "renderingRule" } })], y4.prototype, "rasterFunction", null), y4 = r([a4("esri.layers.support.ExportImageServiceParameters")], y4);

// node_modules/@arcgis/core/rest/support/FindImagesParameters.js
var i5 = class extends i2(f) {
  constructor() {
    super(...arguments), this.fromGeometry = null, this.toGeometry = null, this.objectIds = null, this.where = null, this.maxCount = null;
  }
};
r([m({ type: j, json: { read: true } })], i5.prototype, "fromGeometry", void 0), r([m({ type: j, json: { read: true, write: true } })], i5.prototype, "toGeometry", void 0), r([m({ json: { write: true } })], i5.prototype, "objectIds", void 0), r([m({ type: String, json: { write: true } })], i5.prototype, "where", void 0), r([m({ type: Number, json: { write: true } })], i5.prototype, "maxCount", void 0), i5 = r([a4("esri.rest.support.FindImagesParameters")], i5);
var m5 = i5;

// node_modules/@arcgis/core/rest/support/CameraInfoMixin.js
var s9 = (s10) => {
  let e4 = class extends s10 {
    constructor() {
      super(...arguments), this.make = null, this.model = null, this.focalLength = null, this.pixelSize = null, this.rows = null, this.cols = null;
    }
  };
  return r([m({ json: { write: true } })], e4.prototype, "make", void 0), r([m({ json: { write: true } })], e4.prototype, "model", void 0), r([m({ json: { write: true } })], e4.prototype, "focalLength", void 0), r([m({ json: { write: true } })], e4.prototype, "pixelSize", void 0), r([m({ json: { write: true } })], e4.prototype, "rows", void 0), r([m({ json: { write: true } })], e4.prototype, "cols", void 0), e4 = r([a4("esri.rest.support.CameraInfoMixin")], e4), e4;
};

// node_modules/@arcgis/core/rest/support/ImageInspectionInfo.js
var n7 = class extends s9(f) {
  constructor() {
    super(...arguments), this.id = null, this.referenceUri = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.perspectiveCenter = null, this.orientation = null;
  }
  writeAcquisitionDate(t6, o3) {
    o3.acquisitionDate = t6 == null ? void 0 : t6.getTime();
  }
};
r([m({ json: { write: true } })], n7.prototype, "id", void 0), r([m({ json: { name: "uri", write: true } })], n7.prototype, "referenceUri", void 0), r([m({ type: Date, json: { write: true } })], n7.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], n7.prototype, "writeAcquisitionDate", null), r([m({ json: { write: true } })], n7.prototype, "cameraID", void 0), r([m({ type: j, json: { write: true } })], n7.prototype, "center", void 0), r([m({ type: j, json: { write: true } })], n7.prototype, "perspectiveCenter", void 0), r([m({ json: { write: true } })], n7.prototype, "orientation", void 0), n7 = r([a4("esri.rest.support.ImageInspectionInfo")], n7);
var c7 = n7;

// node_modules/@arcgis/core/rest/support/FindImagesResult.js
var p7 = class extends f {
  constructor() {
    super(...arguments), this.images = null;
  }
};
r([m({ type: [c7], json: { write: true } })], p7.prototype, "images", void 0), p7 = r([a4("esri.rest.support.FindImagesResult")], p7);
var c8 = p7;

// node_modules/@arcgis/core/rest/support/ImageAngleParameters.js
var n8;
var m6 = n8 = class extends f {
  constructor(e4) {
    super(e4), this.angleNames = null, this.point = null, this.spatialReference = null, this.rasterId = null;
  }
  clone() {
    return new n8(a({ angleNames: this.angleNames, point: this.point, spatialReference: this.spatialReference, rasterId: this.rasterId }));
  }
};
r([m({ type: [String], json: { name: "angleName", write: true } })], m6.prototype, "angleNames", void 0), r([m({ type: j, json: { write: true } })], m6.prototype, "point", void 0), r([m({ type: g, json: { write: true } })], m6.prototype, "spatialReference", void 0), r([m({ type: x, json: { write: true } })], m6.prototype, "rasterId", void 0), m6 = n8 = r([a4("esri.rest.support.ImageAngleParameters")], m6);
var l7 = m6;

// node_modules/@arcgis/core/rest/support/ImageAngleResult.js
var p8 = class extends f {
  constructor(r4) {
    super(r4), this.north = null, this.up = null, this.spatialReference = null;
  }
};
r([m({ type: Number, json: { write: true } })], p8.prototype, "north", void 0), r([m({ type: Number, json: { write: true } })], p8.prototype, "up", void 0), r([m({ type: g, json: { write: true } })], p8.prototype, "spatialReference", void 0), p8 = r([a4("esri.rest.support.ImageAngleResult")], p8);
var i6 = p8;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureParameters.js
var a6 = new n2({ esriMensurationPoint: "point", esriMensurationCentroid: "centroid", esriMensurationDistanceAndAngle: "distance-and-angle", esriMensurationAreaAndPerimeter: "area-and-perimeter", esriMensurationHeightFromBaseAndTop: "base-and-top", esriMensurationHeightFromBaseAndTopShadow: "base-and-top-shadow", esriMensurationHeightFromTopAndTopShadow: "top-and-top-shadow", esriMensurationPoint3D: "point-3D", esriMensurationCentroid3D: "centroid-3D", esriMensurationDistanceAndAngle3D: "distance-and-angle-3D", esriMensurationAreaAndPerimeter3D: "area-and-perimeter-3D" });
var p9 = class extends f {
  constructor() {
    super(...arguments), this.type = null, this.measureOperation = null, this.mosaicRule = null, this.pixelSize = null, this.raster = void 0;
  }
};
r([m()], p9.prototype, "type", void 0), r([m({ type: a6.apiValues, json: { read: a6.read, write: a6.write } })], p9.prototype, "measureOperation", void 0), r([m({ type: f6, json: { write: true } })], p9.prototype, "mosaicRule", void 0), r([m({ type: j, json: { write: true } })], p9.prototype, "pixelSize", void 0), r([m({ json: { write: true } })], p9.prototype, "raster", void 0), p9 = r([a4("esri.rest.support.BaseImageMeasureParameters")], p9);

// node_modules/@arcgis/core/rest/support/ImageAreaParameters.js
var c9;
var u2 = c9 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "area-perimeter", this.geometry = null, this.is3D = false, this.linearUnit = "meters", this.areaUnit = "square-meters";
  }
  writeGeometry(e4, r4, t6) {
    null != e4 && (r4.geometryType = p(e4), r4[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "area-and-perimeter-3D" : "area-and-perimeter";
  }
  clone() {
    return new c9(a({ geometry: this.geometry, is3D: this.is3D, linearUnit: this.linearUnit, areaUnit: this.areaUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ types: n3, json: { name: "fromGeometry", read: true, write: true } })], u2.prototype, "geometry", void 0), r([r2("geometry")], u2.prototype, "writeGeometry", null), r([m({ type: a6.apiValues, json: { write: a6.write } })], u2.prototype, "measureOperation", null), r([m({ json: { read: true } })], u2.prototype, "is3D", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], u2.prototype, "linearUnit", void 0), r([m({ type: String, json: { read: fe.read, write: fe.write } })], u2.prototype, "areaUnit", void 0), u2 = c9 = r([a4("esri.rest.support.ImageAreaParameters")], u2);
var y5 = u2;

// node_modules/@arcgis/core/rest/support/BaseImageMeasureResult.js
var i7 = class extends f {
  constructor() {
    super(...arguments), this.value = null, this.displayValue = null, this.uncertainty = null;
  }
};
r([m({ type: Number, json: { read: true, write: true } })], i7.prototype, "value", void 0), r([m({ type: String, json: { read: true, write: true } })], i7.prototype, "displayValue", void 0), r([m({ type: Number, json: { read: true, write: true } })], i7.prototype, "uncertainty", void 0), i7 = r([a4("esri.rest.support.BaseImageMeasureResult.BaseImageMeasureResultValue")], i7);
var p10 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], p10.prototype, "unit", void 0), p10 = r([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultLengthValue")], p10);
var n9 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: fe.read, write: fe.write } })], n9.prototype, "unit", void 0), n9 = r([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAreaValue")], n9);
var l8 = class extends i7 {
  constructor() {
    super(...arguments), this.unit = null;
  }
};
r([m({ type: String, json: { read: de.read, write: de.write } })], l8.prototype, "unit", void 0), l8 = r([a4("esri.rest.support.BaseImageMeasureResult.ImageMeasureResultAngleValue")], l8);
var c10 = class extends f {
  constructor() {
    super(...arguments), this.name = null, this.sensorName = null;
  }
};
r([m({ type: String, json: { read: true, write: true } })], c10.prototype, "name", void 0), r([m({ type: String, json: { read: true, write: true } })], c10.prototype, "sensorName", void 0), c10 = r([a4("esri.rest.support.BaseImageMeasureResult")], c10);

// node_modules/@arcgis/core/rest/support/ImageAreaResult.js
var a7 = class extends c10 {
  constructor() {
    super(...arguments), this.area = null, this.perimeter = null;
  }
};
r([m({ type: n9, json: { read: true, write: true } })], a7.prototype, "area", void 0), r([m({ type: p10, json: { read: true, write: true } })], a7.prototype, "perimeter", void 0), a7 = r([a4("esri.rest.support.ImageAreaResult")], a7);
var c11 = a7;

// node_modules/@arcgis/core/rest/support/ImageBoundaryParameters.js
var a8 = class extends i2(f) {
  constructor() {
    super(...arguments), this.outSpatialReference = null;
  }
};
r([m({ type: g, json: { name: "outSR", write: true } })], a8.prototype, "outSpatialReference", void 0), a8 = r([a4("esri.rest.support.ImageBoundaryParameters")], a8);
var c12 = a8;

// node_modules/@arcgis/core/rest/support/ImageBoundaryResult.js
var a9 = class extends f {
  constructor() {
    super(...arguments), this.area = null, this.geometry = null;
  }
  readGeometry(r4, o3) {
    return null == r4 ? null : r4.rings ? v.fromJSON(r4) : w.fromJSON(r4);
  }
};
r([m({ type: Number, json: { write: true } })], a9.prototype, "area", void 0), r([m({ json: { name: "shape", write: true } })], a9.prototype, "geometry", void 0), r([o("geometry")], a9.prototype, "readGeometry", null), a9 = r([a4("esri.rest.support.ImageBoundaryResult")], a9);
var c13 = a9;

// node_modules/@arcgis/core/rest/support/ImageDistanceParameters.js
var y6;
var c14 = y6 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "distance-angle", this.fromGeometry = null, this.toGeometry = null, this.is3D = false, this.linearUnit = "meters", this.angularUnit = "degrees";
  }
  writeFromGeometry(e4, r4, t6) {
    null != e4 && (r4.geometryType = p(e4), r4[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.is3D ? "distance-and-angle-3D" : "distance-and-angle";
  }
  clone() {
    return new y6(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, is3D: this.is3D, linearUnit: this.linearUnit, angularUnit: this.angularUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ type: j, json: { read: true, write: true } })], c14.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], c14.prototype, "writeFromGeometry", null), r([m({ type: j, json: { read: true, write: true } })], c14.prototype, "toGeometry", void 0), r([m({ type: a6.apiValues, json: { write: a6.write } })], c14.prototype, "measureOperation", null), r([m({ json: { read: true } })], c14.prototype, "is3D", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], c14.prototype, "linearUnit", void 0), r([m({ type: String, json: { read: de.read, write: de.write } })], c14.prototype, "angularUnit", void 0), c14 = y6 = r([a4("esri.rest.support.ImageDistanceParameters")], c14);
var u3 = c14;

// node_modules/@arcgis/core/rest/support/ImageDistanceResult.js
var a10 = class extends c10 {
  constructor() {
    super(...arguments), this.distance = null, this.azimuthAngle = null, this.elevationAngle = null;
  }
};
r([m({ type: p10, json: { read: true, write: true } })], a10.prototype, "distance", void 0), r([m({ type: l8, json: { read: true, write: true } })], a10.prototype, "azimuthAngle", void 0), r([m({ type: l8, json: { read: true, write: true } })], a10.prototype, "elevationAngle", void 0), a10 = r([a4("esri.rest.support.ImageDistanceResult")], a10);
var i8 = a10;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoParameters.js
var j4 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.objectIds = null, this.spatialRelationship = "intersects", this.timeExtent = null, this.where = null;
  }
  writeGeometry(o3, t6, r4) {
    null != o3 && (t6.geometryType = p(o3), t6[r4] = JSON.stringify(o3.toJSON()));
  }
};
r([m({ types: n3, json: { read: f2, write: true } })], j4.prototype, "geometry", void 0), r([r2("geometry")], j4.prototype, "writeGeometry", null), r([m({ json: { write: true } })], j4.prototype, "objectIds", void 0), r([r3(s2, { ignoreUnknown: false, name: "spatialRel" })], j4.prototype, "spatialRelationship", void 0), r([m({ type: p2, json: { name: "time", write: true } })], j4.prototype, "timeExtent", void 0), r([m({ type: String, json: { write: true } })], j4.prototype, "where", void 0), j4 = r([a4("esri.rest.support.ImageGPSInfoParameters")], j4);
var y7 = j4;

// node_modules/@arcgis/core/rest/support/CameraInfo.js
var p11 = class extends s9(f) {
  constructor() {
    super(...arguments), this.id = null;
  }
};
r([m({ json: { write: true } })], p11.prototype, "id", void 0), p11 = r([a4("esri.rest.support.CameraInfo")], p11);
var c15 = p11;

// node_modules/@arcgis/core/rest/support/ImageGPSInfo.js
var p12 = class extends f {
  constructor() {
    super(...arguments), this.id = null, this.name = null, this.acquisitionDate = null, this.cameraID = null, this.center = null, this.gps = null, this.orientation = null;
  }
  writeAcquisitionDate(o3, t6) {
    t6.acquisitionDate = o3 == null ? void 0 : o3.getTime();
  }
};
r([m({ json: { write: true } })], p12.prototype, "id", void 0), r([m({ json: { write: true } })], p12.prototype, "name", void 0), r([m({ type: Date, json: { write: true } })], p12.prototype, "acquisitionDate", void 0), r([r2("acquisitionDate")], p12.prototype, "writeAcquisitionDate", null), r([m({ json: { write: true } })], p12.prototype, "cameraID", void 0), r([m({ type: j, json: { write: true } })], p12.prototype, "center", void 0), r([m({ json: { write: true } })], p12.prototype, "gps", void 0), r([m({ json: { write: true } })], p12.prototype, "orientation", void 0), p12 = r([a4("esri.rest.support.ImageGPSInfo")], p12);
var n10 = p12;

// node_modules/@arcgis/core/rest/support/ImageGPSInfoResult.js
var m7 = class extends f {
  constructor() {
    super(...arguments), this.images = null, this.cameras = null;
  }
};
r([m({ type: [n10], json: { write: true } })], m7.prototype, "images", void 0), r([m({ type: [c15], json: { write: true } })], m7.prototype, "cameras", void 0), m7 = r([a4("esri.rest.support.ImageGPSInfoResult")], m7);
var a11 = m7;

// node_modules/@arcgis/core/rest/support/ImageHeightParameters.js
var y8;
var l9 = y8 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "height", this.fromGeometry = null, this.toGeometry = null, this.operationType = "base-and-top", this.linearUnit = "meters";
  }
  writeFromGeometry(e4, r4, t6) {
    null != e4 && (r4.geometryType = p(e4), r4[t6] = e4.toJSON());
  }
  get measureOperation() {
    return this.operationType;
  }
  clone() {
    return new y8(a({ fromGeometry: this.fromGeometry, toGeometry: this.toGeometry, operationType: this.operationType, linearUnit: this.linearUnit, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ type: j, json: { read: true } })], l9.prototype, "fromGeometry", void 0), r([r2("fromGeometry")], l9.prototype, "writeFromGeometry", null), r([m({ type: j, json: { read: true, write: true } })], l9.prototype, "toGeometry", void 0), r([m({ type: a6.apiValues, json: { write: a6.write } })], l9.prototype, "measureOperation", null), r([m({ json: { read: true } })], l9.prototype, "operationType", void 0), r([m({ type: String, json: { read: Ue.read, write: Ue.write } })], l9.prototype, "linearUnit", void 0), l9 = y8 = r([a4("esri.rest.support.ImageHeightParameters")], l9);
var c16 = l9;

// node_modules/@arcgis/core/rest/support/ImageHeightResult.js
var p13 = class extends c10 {
  constructor() {
    super(...arguments), this.height = null;
  }
};
r([m({ type: p10, json: { read: true, write: true } })], p13.prototype, "height", void 0), p13 = r([a4("esri.rest.support.ImageHeightResult")], p13);
var c17 = p13;

// node_modules/@arcgis/core/rest/support/ImageIdentifyParameters.js
var m8;
var c18 = m8 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterFunctions = null, this.pixelSize = null, this.returnGeometry = true, this.returnCatalogItems = true, this.returnPixelValues = true, this.maxItemCount = null, this.timeExtent = null, this.raster = void 0, this.viewId = void 0, this.processAsMultidimensional = false;
  }
  writeGeometry(t6, e4, r4) {
    null != t6 && (e4.geometryType = p(t6), e4[r4] = JSON.stringify(t6.toJSON()));
  }
  set mosaicRule(t6) {
    let e4 = t6;
    (e4 == null ? void 0 : e4.mosaicMethod) && (e4 = f6.fromJSON({ ...e4.toJSON(), mosaicMethod: e4.mosaicMethod, mosaicOperation: e4.mosaicOperation })), this._set("mosaicRule", e4);
  }
  writeMosaicRule(t6, e4, r4) {
    null != t6 && (e4[r4] = JSON.stringify(t6.toJSON()));
  }
  set rasterFunction(t6) {
    let e4 = t6;
    (e4 == null ? void 0 : e4.rasterFunction) && (e4 = N.fromJSON({ ...e4.toJSON(), rasterFunction: e4.rasterFunction, rasterFunctionArguments: e4.rasterFunctionArguments })), this._set("rasterFunction", e4);
  }
  writeRasterFunction(t6, e4, r4) {
    null != t6 && (e4[r4] = JSON.stringify(t6.toJSON())), t6.rasterFunctionDefinition && (e4[r4] = JSON.stringify(t6.rasterFunctionDefinition));
  }
  writeRasterFunctions(t6, e4, r4) {
    null != t6 && (e4[r4] = JSON.stringify(t6.map((t7) => t7.rasterFunctionDefinition || t7.toJSON())));
  }
  writePixelSize(t6, e4, r4) {
    null != t6 && (e4[r4] = JSON.stringify(t6));
  }
  writeTimeExtent(t6, e4, r4) {
    if (null != t6) {
      const o3 = null != t6.start ? t6.start.getTime() : null, i11 = null != t6.end ? t6.end.getTime() : null;
      e4[r4] = null != o3 ? null != i11 ? `${o3},${i11}` : `${o3}` : null;
    }
  }
  clone() {
    return new m8(a({ geometry: this.geometry, mosaicRule: this.mosaicRule, rasterFunction: this.rasterFunction, rasterFunctions: this.rasterFunctions, pixelSize: this.pixelSize, returnGeometry: this.returnGeometry, returnCatalogItems: this.returnCatalogItems, returnPixelValues: this.returnPixelValues, maxItemCount: this.maxItemCount, processAsMultidimensional: this.processAsMultidimensional, raster: this.raster, viewId: this.viewId, timeExtent: this.timeExtent }));
  }
};
r([m({ json: { write: true } })], c18.prototype, "geometry", void 0), r([r2("geometry")], c18.prototype, "writeGeometry", null), r([m({ type: f6, json: { write: true } })], c18.prototype, "mosaicRule", null), r([r2("mosaicRule")], c18.prototype, "writeMosaicRule", null), r([m({ type: N, json: { write: true, name: "renderingRule" } })], c18.prototype, "rasterFunction", null), r([r2("rasterFunction")], c18.prototype, "writeRasterFunction", null), r([m({ type: [N], json: { write: true, name: "renderingRules" } })], c18.prototype, "rasterFunctions", void 0), r([r2("rasterFunctions")], c18.prototype, "writeRasterFunctions", null), r([m({ type: j, json: { write: true } })], c18.prototype, "pixelSize", void 0), r([r2("pixelSize")], c18.prototype, "writePixelSize", null), r([m({ type: Boolean, json: { write: true } })], c18.prototype, "returnGeometry", void 0), r([m({ type: Boolean, json: { write: true } })], c18.prototype, "returnCatalogItems", void 0), r([m({ type: Boolean, json: { write: true } })], c18.prototype, "returnPixelValues", void 0), r([m({ type: Number, json: { write: true } })], c18.prototype, "maxItemCount", void 0), r([m({ type: p2, json: { write: { target: "time" } } })], c18.prototype, "timeExtent", void 0), r([r2("timeExtent")], c18.prototype, "writeTimeExtent", null), r([m({ json: { write: true } })], c18.prototype, "raster", void 0), r([m({ json: { write: true } })], c18.prototype, "viewId", void 0), r([m({ type: Boolean, json: { write: true } })], c18.prototype, "processAsMultidimensional", void 0), c18 = m8 = r([a4("esri.rest.support.ImageIdentifyParameters")], c18);
var y9 = c18;

// node_modules/@arcgis/core/rest/support/ImageIdentifyResult.js
var p14 = class extends f {
  constructor() {
    super(...arguments), this.catalogItemVisibilities = null, this.catalogItems = null, this.location = null, this.name = null, this.objectId = null, this.processedValues = null, this.properties = null, this.value = null;
  }
};
r([m({ json: { write: true } })], p14.prototype, "catalogItemVisibilities", void 0), r([m({ type: d3, json: { write: true } })], p14.prototype, "catalogItems", void 0), r([m({ type: j, json: { write: true } })], p14.prototype, "location", void 0), r([m({ json: { write: true } })], p14.prototype, "name", void 0), r([m({ json: { write: true } })], p14.prototype, "objectId", void 0), r([m({ json: { write: true } })], p14.prototype, "processedValues", void 0), r([m({ json: { write: true } })], p14.prototype, "properties", void 0), r([m({ json: { write: true } })], p14.prototype, "value", void 0), p14 = r([a4("esri.rest.support.ImageIdentifyResult")], p14);
var l10 = p14;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationParameters.js
var m9;
var c19 = m9 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null, this.rasterId = null;
  }
  writeGeometry(r4, e4, o3) {
    e4.geometries = { geometryType: "esriGeometryPoint", geometries: r4.map((r5) => r5.toJSON()) };
  }
  clone() {
    var _a;
    return new m9({ geometries: ((_a = this.geometries) == null ? void 0 : _a.map((r4) => r4.clone())) ?? [], rasterId: this.rasterId });
  }
};
r([m({ type: [j], json: { write: true } })], c19.prototype, "geometries", void 0), r([r2("geometries")], c19.prototype, "writeGeometry", null), r([m({ type: x, json: { write: true } })], c19.prototype, "rasterId", void 0), c19 = m9 = r([a4("esri.rest.support.ImagePixelLocationParameters")], c19);
var a12 = c19;

// node_modules/@arcgis/core/rest/support/ImagePixelLocationResult.js
var t5 = class extends f {
  constructor() {
    super(...arguments), this.geometries = null;
  }
};
r([m({ json: { write: true } })], t5.prototype, "geometries", void 0), t5 = r([a4("esri.rest.support.ImagePixelLocationResult")], t5);
var p15 = t5;

// node_modules/@arcgis/core/rest/support/ImagePointParameters.js
var c20;
var u4 = c20 = class extends p9 {
  constructor() {
    super(...arguments), this.type = "point", this.geometry = null, this.is3D = false;
  }
  writeGeometry(e4, r4, o3) {
    null != e4 && (r4.geometryType = p(e4), r4[o3] = e4.toJSON());
  }
  get measureOperation() {
    const { is3D: e4, geometry: r4 } = this;
    return "point" === r4.type ? e4 ? "point-3D" : "point" : e4 ? "centroid-3D" : "centroid";
  }
  clone() {
    return new c20(a({ geometry: this.geometry, is3D: this.is3D, mosaicRule: this.mosaicRule, pixelSize: this.pixelSize, raster: this.raster }));
  }
};
r([m({ types: n3, json: { name: "fromGeometry", read: f2 } })], u4.prototype, "geometry", void 0), r([r2("geometry")], u4.prototype, "writeGeometry", null), r([m({ type: a6.apiValues, json: { read: a6.read, write: a6.write } })], u4.prototype, "measureOperation", null), r([m({ json: { read: true } })], u4.prototype, "is3D", void 0), u4 = c20 = r([a4("esri.rest.support.ImagePointParameters")], u4);
var y10 = u4;

// node_modules/@arcgis/core/rest/support/ImagePointResult.js
var p16 = class extends c10 {
  constructor() {
    super(...arguments), this.point = null;
  }
};
r([m({ type: j, json: { name: "point.value", read: true, write: true } })], p16.prototype, "point", void 0), p16 = r([a4("esri.rest.support.ImagePointResult")], p16);
var m10 = p16;

// node_modules/@arcgis/core/rest/support/ImageSampleParameters.js
var d9;
var j5 = d9 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.interpolation = "nearest", this.mosaicRule = null, this.outFields = null, this.pixelSize = null, this.returnFirstValueOnly = true, this.sampleDistance = null, this.sampleCount = null, this.sliceId = null, this.timeExtent = null;
  }
  writeGeometry(t6, e4, o3) {
    null != t6 && (e4.geometryType = p(t6), e4[o3] = t6.toJSON());
  }
  set locations(t6) {
    if (t6 == null ? void 0 : t6.length) {
      const e4 = new u({ spatialReference: t6[0].spatialReference, points: t6.map(({ x: t7, y: e5 }) => [t7, e5]) });
      this._set("locations", t6), this.geometry = e4;
    }
  }
  clone() {
    return new d9(a({ geometry: this.geometry, locations: this.locations, interpolation: this.interpolation, mosaicRule: this.mosaicRule, outFields: this.outFields, raster: this.raster, returnFirstValueOnly: this.returnFirstValueOnly, sampleDistance: this.sampleDistance, sampleCount: this.sampleCount, sliceId: this.sliceId, pixelSize: this.pixelSize, timeExtent: this.timeExtent }));
  }
};
r([m({ types: n3, json: { read: f2 } })], j5.prototype, "geometry", void 0), r([r2("geometry")], j5.prototype, "writeGeometry", null), r([m()], j5.prototype, "locations", null), r([m({ type: String, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], j5.prototype, "interpolation", void 0), r([m({ type: f6, json: { write: true } })], j5.prototype, "mosaicRule", void 0), r([m({ type: [String], json: { write: true } })], j5.prototype, "outFields", void 0), r([m({ type: j, json: { write: true } })], j5.prototype, "pixelSize", void 0), r([m({ type: String, json: { write: true } })], j5.prototype, "raster", void 0), r([m({ type: Boolean, json: { write: true } })], j5.prototype, "returnFirstValueOnly", void 0), r([m({ type: Number, json: { write: true } })], j5.prototype, "sampleDistance", void 0), r([m({ type: Number, json: { write: true } })], j5.prototype, "sampleCount", void 0), r([m({ type: Number, json: { write: true } })], j5.prototype, "sliceId", void 0), r([m({ type: p2, json: { read: { source: "time" }, write: { target: "time" } } })], j5.prototype, "timeExtent", void 0), j5 = d9 = r([a4("esri.rest.support.ImageSampleParameters")], j5);
var h3 = j5;

// node_modules/@arcgis/core/rest/support/ImageSample.js
var i9 = class extends f {
  constructor() {
    super(...arguments), this.attributes = null, this.location = null, this.locationId = null, this.rasterId = null, this.resolution = null, this.pixelValue = null;
  }
};
r([m({ json: { write: true } })], i9.prototype, "attributes", void 0), r([m({ type: j, json: { write: true } })], i9.prototype, "location", void 0), r([m({ json: { write: true } })], i9.prototype, "locationId", void 0), r([m({ json: { write: true } })], i9.prototype, "rasterId", void 0), r([m({ json: { write: true } })], i9.prototype, "resolution", void 0), r([m({ json: { write: true } })], i9.prototype, "pixelValue", void 0), i9 = r([a4("esri.rest.support.ImageSample")], i9);
var p17 = i9;

// node_modules/@arcgis/core/rest/support/ImageSampleResult.js
var p18 = class extends f {
  constructor() {
    super(...arguments), this.samples = null;
  }
};
r([m({ type: [p17], json: { write: true } })], p18.prototype, "samples", void 0), p18 = r([a4("esri.rest.support.ImageSampleResult")], p18);
var m11 = p18;

// node_modules/@arcgis/core/rest/support/ImageToMapMultirayParameters.js
var l11 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometries = [], this.rasterIds = null, this.outSpatialReference = null;
  }
  writeGeometries(e4, r4, o3) {
    r4.geometries = (e4 == null ? void 0 : e4.length) ? { geometryType: p(e4[0]), geometries: e4.map((e5) => ({ ...e5.toJSON(), spatialReference: void 0 })) } : null;
  }
};
r([m({ types: [n3] })], l11.prototype, "geometries", void 0), r([r2("geometries")], l11.prototype, "writeGeometries", null), r([m({ type: [x], json: { write: true } })], l11.prototype, "rasterIds", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], l11.prototype, "outSpatialReference", void 0), l11 = r([a4("esri.rest.support.ImageToMapMultirayParameters")], l11);
var u5 = l11;

// node_modules/@arcgis/core/rest/support/ImageToMapParameters.js
var n11 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.outSpatialReference = null, this.depthOffset = 0, this.adjust = false;
  }
  writeGeometry(o3, e4, r4) {
    null != o3 && (e4.geometryType = p(o3), e4[r4] = { ...o3.toJSON(), spatialReference: void 0 });
  }
};
r([m({ types: n3, json: { read: f2, write: true } })], n11.prototype, "geometry", void 0), r([r2("geometry")], n11.prototype, "writeGeometry", null), r([m({ json: { write: true } })], n11.prototype, "rasterId", void 0), r([m({ type: g, json: { name: "outSR", write: true } })], n11.prototype, "outSpatialReference", void 0), r([m({ json: { name: "options.DOff", write: true } })], n11.prototype, "depthOffset", void 0), r([m({ json: { name: "options.Adjust", write: true } })], n11.prototype, "adjust", void 0), n11 = r([a4("esri.rest.support.ImageToMapParameters")], n11);
var l12 = n11;

// node_modules/@arcgis/core/rest/support/ImageUrlParameters.js
var p19 = class extends i2(f) {
  constructor() {
    super(...arguments), this.referenceUri = null, this.rasterId = null;
  }
};
r([m({ type: String, json: { name: "uri", write: true } })], p19.prototype, "referenceUri", void 0), r([m({ type: Number, json: { write: true } })], p19.prototype, "rasterId", void 0), p19 = r([a4("esri.rest.support.ImageUrlParameters")], p19);
var c21 = p19;

// node_modules/@arcgis/core/rest/support/ImageUrlResult.js
var e3 = class extends f {
  constructor() {
    super(...arguments), this.url = null;
  }
};
r([m({ json: { name: "imageURL", write: true } })], e3.prototype, "url", void 0), e3 = r([a4("esri.rest.support.ImageUrlResult")], e3);
var p20 = e3;

// node_modules/@arcgis/core/rest/support/MapToImageParameters.js
var a13 = class extends i2(f) {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = null, this.visibleOnly = false;
  }
  writeGeometry(r4, o3, e4) {
    null != r4 && (o3.geometryType = p(r4), o3[e4] = JSON.stringify(r4));
  }
};
r([m({ types: n3, json: { read: f2, write: true } })], a13.prototype, "geometry", void 0), r([r2("geometry")], a13.prototype, "writeGeometry", null), r([m({ json: { write: true } })], a13.prototype, "rasterId", void 0), r([m({ json: { name: "options.VisibleOnly", write: true } })], a13.prototype, "visibleOnly", void 0), a13 = r([a4("esri.rest.support.MapToImageParameters")], a13);
var l13 = a13;

// node_modules/@arcgis/core/rest/support/MeasureAreaFromImageResult.js
var m12 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null, this.area = null, this.center = null;
  }
  readCenter(e4, r4) {
    return e4.spatialReference || (e4 = { ...e4, spatialReference: r4.Shape.spatialReference }), j.fromJSON(e4);
  }
};
r([m({ types: n3, json: { name: "Shape", read: f2, write: true } })], m12.prototype, "geometry", void 0), r([m({ json: { name: "Length", write: true } })], m12.prototype, "length", void 0), r([m({ json: { name: "Area", write: true } })], m12.prototype, "area", void 0), r([m({ json: { name: "Center", write: true } })], m12.prototype, "center", void 0), r([o("center")], m12.prototype, "readCenter", null), m12 = r([a4("esri.rest.support.MeasureAreaFromImageResult")], m12);
var i10 = m12;

// node_modules/@arcgis/core/rest/support/MeasureFromImageParameters.js
var c22;
var n12 = c22 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.rasterId = void 0;
  }
  writeGeometry(r4, o3, e4) {
    null != r4 && (o3.geometryType = p(r4), o3[e4] = { ...r4.toJSON(), spatialReference: void 0 });
  }
  clone() {
    const r4 = a({ geometry: this.geometry, rasterId: this.rasterId });
    return new c22(r4);
  }
};
r([m({ types: n3, json: { name: "fromGeometry", read: f2, write: true } })], n12.prototype, "geometry", void 0), r([r2("geometry")], n12.prototype, "writeGeometry", null), r([m({ json: { write: true } })], n12.prototype, "rasterId", void 0), n12 = c22 = r([a4("esri.rest.support.MeasureFromImageParameters")], n12);
var y11 = n12;

// node_modules/@arcgis/core/rest/support/MeasureLengthFromImageResult.js
var m13 = class extends f {
  constructor() {
    super(...arguments), this.geometry = null, this.length = null;
  }
};
r([m({ types: n3, json: { name: "Shape", read: f2, write: true } })], m13.prototype, "geometry", void 0), r([m({ json: { name: "Length", write: true } })], m13.prototype, "length", void 0), m13 = r([a4("esri.rest.support.MeasureLengthFromImageResult")], m13);
var c23 = m13;

// node_modules/@arcgis/core/rest/imageService.js
function H(t6) {
  const e4 = t6 == null ? void 0 : t6.time;
  if (e4 && (null != e4.start || null != e4.end)) {
    const r4 = [];
    null != e4.start && r4.push(e4.start), null == e4.end || r4.includes(e4.end) || r4.push(e4.end), t6.time = r4.join(",");
  }
}
async function B3(t6, o3, m14) {
  o3 = h(g4, o3);
  const i11 = f4(t6), p21 = o3.geometry ? [o3.geometry] : [], u6 = await R(p21), c24 = o3.toJSON();
  H(c24);
  const f10 = u6 == null ? void 0 : u6[0];
  null != f10 && (c24.geometry = rt(f10));
  const l14 = s3({ ...i11.query, f: "json", ...c24 });
  return i3(l14, m14);
}
async function D(r4, o3, m14) {
  var _a, _b, _c;
  const i11 = (o3 = h(l7, o3)).toJSON();
  null != i11.angleName && (i11.angleName = i11.angleName.join(",")), ((_b = (_a = o3 == null ? void 0 : o3.point) == null ? void 0 : _a.spatialReference) == null ? void 0 : _b.imageCoordinateSystem) && (i11.point.spatialReference = ot(o3.point.spatialReference)), ((_c = o3 == null ? void 0 : o3.spatialReference) == null ? void 0 : _c.imageCoordinateSystem) && (i11.spatialReference = at(o3.spatialReference));
  const c24 = f4(r4), f10 = s3({ ...c24.query, f: "json", ...i11 }), l14 = i3(f10, m14), { data: g6 } = await U(`${c24.path}/computeAngles`, l14);
  return g6.spatialReference = g6.spatialReference ? null != g6.spatialReference.geodataXform ? new g({ wkid: 0, imageCoordinateSystem: g6.spatialReference }) : g.fromJSON(g6.spatialReference) : null, "NaN" === g6.north && (g6.north = null), "NaN" === g6.up && (g6.up = null), new i6(g6);
}
async function k2(r4, o3, m14) {
  var _a;
  const i11 = (o3 = h(a12, o3)).toJSON(), { geometries: p21 } = o3;
  if (p21) for (let t6 = 0; t6 < p21.length; t6++) ((_a = p21[t6].spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (i11.geometries.geometries[t6].spatialReference = ot(p21[t6].spatialReference));
  const u6 = f4(r4), c24 = s3({ ...u6.query, f: "json", ...i11 }), f10 = i3(c24, m14), { data: l14 } = await U(`${u6.path}/computePixelLocation`, f10);
  return p15.fromJSON(l14);
}
async function z(e4, r4, o3) {
  const s10 = await B3(e4, r4, o3), n14 = f4(e4), { data: m14 } = await U(`${n14.path}/computeStatisticsHistograms`, s10), { statistics: i11 } = m14;
  return (i11 == null ? void 0 : i11.length) && i11.forEach((t6) => {
    t6.avg = t6.mean, t6.stddev = t6.standardDeviation;
  }), { statistics: i11, histograms: m14.histograms };
}
async function E(e4, r4, o3) {
  const s10 = await B3(e4, r4, o3), n14 = f4(e4), { data: m14 } = await U(`${n14.path}/computeHistograms`, s10);
  return { histograms: m14.histograms };
}
async function V2(o3, m14, i11) {
  var _a, _b;
  const p21 = (m14 = h(h3, m14)).toJSON();
  H(p21), ((_a = p21.outFields) == null ? void 0 : _a.length) && (p21.outFields = p21.outFields.join(","));
  const u6 = await R(m14.geometry), c24 = u6 == null ? void 0 : u6[0];
  null != c24 && (p21.geometry = rt(c24));
  const f10 = f4(o3), l14 = s3({ ...f10.query, f: "json", ...p21 }), g6 = i3(l14, i11), { data: y12 } = await U(`${f10.path}/getSamples`, g6), j6 = (_b = y12 == null ? void 0 : y12.samples) == null ? void 0 : _b.map((t6) => {
    const e4 = "NaN" === t6.value || "" === t6.value ? null : t6.value.split(" ").map((t7) => Number(t7));
    return { ...t6, pixelValue: e4 };
  });
  return m11.fromJSON({ samples: j6 });
}
async function X(o3, m14, i11) {
  m14 = h(y9, m14);
  const p21 = f4(o3), u6 = m14.geometry ? [m14.geometry] : [];
  return R(u6).then((e4) => {
    const r4 = m14.toJSON(), o4 = e4 == null ? void 0 : e4[0];
    null != o4 && (r4.geometry = JSON.stringify(rt(o4)));
    const a14 = s3({ ...p21.query, f: "json", ...r4 }), u7 = i3(a14, i11);
    return U(p21.path + "/identify", u7);
  }).then((t6) => l10.fromJSON(t6.data));
}
async function K(t6, r4, o3) {
  r4 = h(c16, r4);
  const a14 = await Z2(t6, r4, [r4.fromGeometry, r4.toGeometry], o3);
  return c17.fromJSON(a14);
}
async function Q(t6, r4, o3) {
  r4 = h(y5, r4);
  const a14 = await Z2(t6, r4, [r4.geometry], o3);
  return c11.fromJSON(a14);
}
async function W(t6, r4, o3) {
  r4 = h(y10, r4);
  const a14 = await Z2(t6, r4, [r4.geometry], o3);
  return m10.fromJSON(a14);
}
async function Y(t6, r4, o3) {
  r4 = h(u3, r4);
  const a14 = await Z2(t6, r4, [r4.fromGeometry, r4.toGeometry], o3);
  return i8.fromJSON(a14);
}
async function Z2(e4, o3, m14, i11) {
  const p21 = f4(e4), u6 = await R(m14), c24 = o3.toJSON();
  null != u6[0] && (c24.fromGeometry = JSON.stringify(rt(u6[0]))), null != u6[1] && (c24.toGeometry = JSON.stringify(rt(u6[1])));
  const f10 = s3({ ...p21.query, f: "json", ...c24 }), l14 = i3(f10, i11), { data: g6 } = await U(p21.path + "/measure", l14);
  return g6;
}
async function _2(t6, e4, r4) {
  const o3 = await et(t6, e4, r4);
  return c23.fromJSON(o3);
}
async function tt(t6, e4, r4) {
  const o3 = await et(t6, e4, r4);
  return i10.fromJSON(o3);
}
async function et(r4, o3, m14) {
  o3 = h(y11, o3);
  const i11 = f4(r4), p21 = o3.toJSON(), u6 = s3({ ...i11.query, f: "json", ...p21 }), c24 = i3(u6, m14), { data: f10 } = await U(i11.path + "/measureFromImage", c24);
  return f10;
}
function rt(t6) {
  var _a;
  const e4 = t6.toJSON();
  return ((_a = t6.spatialReference) == null ? void 0 : _a.imageCoordinateSystem) && (e4.spatialReference = ot(t6.spatialReference)), e4;
}
function ot(t6) {
  const { imageCoordinateSystem: e4 } = t6;
  if (e4) {
    const { id: t7, referenceServiceName: r4 } = e4;
    return null != t7 ? r4 ? { icsid: t7, icsns: r4 } : { icsid: t7 } : { ics: e4 };
  }
  return t6.toJSON();
}
function at(t6, e4) {
  if (!t6.imageCoordinateSystem) return c(t6);
  const r4 = ot(t6), { icsid: a14, icsns: s10 } = r4;
  return null == a14 || null != s10 && !(e4 == null ? void 0 : e4.toLowerCase().includes("/" + s10.toLowerCase() + "/")) ? JSON.stringify(r4) : `0:${a14}`;
}
async function st(r4, o3, m14) {
  o3 = h(c12, o3);
  const i11 = f4(r4), p21 = o3.toJSON();
  o3.outSpatialReference && (p21.outSR = at(o3.outSpatialReference));
  const u6 = s3({ ...i11.query, f: "json", ...p21 }), c24 = i3(u6, m14), { data: f10 } = await U(i11.path + "/queryBoundary", c24);
  return c13.fromJSON(f10);
}
async function nt(o3, m14, i11) {
  var _a, _b;
  const p21 = (m14 = h(y7, m14)).toJSON();
  H(p21), ((_a = p21.objectIds) == null ? void 0 : _a.length) && (p21.objectIds = p21.objectIds.join(",")), p21.geometry || p21.objectIds || p21.time || p21.where || (p21.where = "1=1");
  const u6 = await R(m14.geometry), c24 = u6 == null ? void 0 : u6[0];
  null != c24 && (p21.geometry = rt(c24));
  const f10 = (c24 == null ? void 0 : c24.spatialReference) ?? ((_b = m14.geometry) == null ? void 0 : _b.spatialReference);
  f10 && (p21.inSR = at(f10));
  const l14 = f4(o3), g6 = s3({ ...l14.query, f: "json", ...p21 }), y12 = i3(g6, i11), { data: j6 } = await U(`${l14.path}/queryGPSInfo`, y12);
  return a11.fromJSON(j6);
}
async function mt(r4, o3, m14) {
  const i11 = (o3 = h(l12, o3)).toJSON();
  o3.geometry.spatialReference.imageCoordinateSystem && (i11.geometry = rt(o3.geometry)), o3.depthOffset && o3.adjust || delete i11.options;
  const p21 = f4(r4), u6 = s3({ ...p21.query, f: "json", ...i11 }), c24 = i3(u6, m14), { data: f10 } = await U(`${p21.path}/imageToMap`, c24);
  return f2(f10);
}
async function it(r4, o3, m14) {
  var _a;
  const i11 = (o3 = h(u5, o3)).toJSON();
  ((_a = o3.rasterIds) == null ? void 0 : _a.length) && (i11.rasterIds = o3.rasterIds.join(","));
  const p21 = f4(r4), u6 = s3({ ...p21.query, f: "json", ...i11 }), c24 = i3(u6, m14), { data: f10 } = await U(`${p21.path}/imageToMapMultiray`, c24);
  return f2(f10);
}
async function pt(o3, m14, i11) {
  var _a;
  const p21 = (m14 = h(l13, m14)).toJSON(), u6 = await R(m14.geometry), c24 = u6 == null ? void 0 : u6[0];
  null != c24 && (p21.geometry = rt(c24)), m14.visibleOnly || delete p21.options;
  const f10 = (c24 == null ? void 0 : c24.spatialReference) ?? ((_a = m14.geometry) == null ? void 0 : _a.spatialReference);
  f10 && (p21.inSR = at(f10));
  const l14 = f4(o3), g6 = s3({ ...l14.query, f: "json", ...p21 }), y12 = i3(g6, i11), { data: j6 } = await U(`${l14.path}/mapToImage`, y12);
  return f2(j6);
}
async function ut(r4, o3, m14) {
  const i11 = (o3 = h(c21, o3)).toJSON(), p21 = f4(r4), u6 = s3({ ...p21.query, f: "json", ...i11 }), c24 = i3(u6, m14), { data: f10 } = await U(`${p21.path}/getImageUrl`, c24);
  return p20.fromJSON(f10);
}
async function ct(o3, p21, u6) {
  var _a;
  const c24 = (p21 = h(m5, p21)).toJSON(), f10 = await R([p21.fromGeometry, p21.toGeometry]);
  null != f10[0] && (c24.fromGeometry = rt(f10[0]), f10[0].spatialReference && (c24.inSR = at(f10[0].spatialReference))), null != f10[1] && (c24.toGeometry = rt(f10[1])), ((_a = p21.objectIds) == null ? void 0 : _a.length) && (c24.objectIds = c24.objectIds.join(","));
  const l14 = f4(o3), g6 = s3({ ...l14.query, f: "json", ...c24 }), y12 = i3(g6, u6), { data: j6 } = await U(`${l14.path}/find`, y12);
  return c8.fromJSON(j6);
}

// node_modules/@arcgis/core/rest/imageService/getCatalogItemRasterInfo.js
async function n13(n14, m14, p21) {
  var _a, _b;
  const f10 = f4(n14), u6 = s3({ ...f10 == null ? void 0 : f10.query, f: "json" }), h4 = i3(u6, p21), d10 = `${f10 == null ? void 0 : f10.path}/${m14}/info`, c24 = U(`${d10}`, h4), g6 = U(`${d10}/keyProperties`, h4), x4 = await Promise.allSettled([c24, g6]), y12 = "fulfilled" === x4[0].status ? x4[0].value.data : null, v3 = "fulfilled" === x4[1].status ? x4[1].value.data : null;
  let P4 = null;
  ((_a = y12.statistics) == null ? void 0 : _a.length) && (P4 = y12.statistics.map((e4) => ({ min: e4[0], max: e4[1], avg: e4[2], stddev: e4[3] })));
  const S3 = w.fromJSON(y12.extent), j6 = Math.ceil(S3.width / y12.pixelSizeX - 0.1), w3 = Math.ceil(S3.height / y12.pixelSizeY - 0.1), b5 = S3.spatialReference, k3 = new j({ x: y12.pixelSizeX, y: y12.pixelSizeY, spatialReference: b5 }), z2 = ((_b = y12.histograms) == null ? void 0 : _b.length) ? y12.histograms : null, L2 = new n4({ origin: y12.origin, blockWidth: y12.blockWidth, blockHeight: y12.blockHeight, firstPyramidLevel: y12.firstPyramidLevel, maximumPyramidLevel: y12.maxPyramidLevel });
  return new m2({ width: j6, height: w3, bandCount: y12.bandCount, extent: S3, spatialReference: b5, pixelSize: k3, pixelType: y12.pixelType.toLowerCase(), statistics: P4, histograms: z2, keyProperties: v3, storageInfo: L2 });
}

// node_modules/@arcgis/core/layers/mixins/ArcGISImageService.js
var Oe = /* @__PURE__ */ new Set(["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff"]);
var Pe = i(a3, { min: 0, max: 255 });
function Ce(e4) {
  const t6 = JSON.stringify(e4), i11 = t6.includes('"rasterFunctionDefinition":{'), r4 = i11 ? t6.match(/"type":"(.*?FunctionArguments")/gi) : t6.match(/"rasterFunction":"(.*?")/gi), s10 = r4 == null ? void 0 : r4.map((e5) => i11 ? e5.slice(8, -18) : e5.slice(18, -1));
  return s10 ? s10.join("/") : null;
}
var Me = (h4) => {
  let f10 = class extends h4 {
    constructor() {
      super(...arguments), this._functionRasterInfos = {}, this._rasterJobHandler = { instance: null, refCount: 0, connectionPromise: null }, this._cachedRendererJson = null, this._serviceSupportsMosaicRule = null, this._rasterAttributeTableFieldPrefix = "Raster.", this.adjustAspectRatio = null, this.bandIds = void 0, this.capabilities = null, this.compressionQuality = void 0, this.compressionTolerance = 0.01, this.copyright = null, this.defaultMosaicRule = null, this.definitionExpression = null, this.exportImageServiceParameters = null, this.rasterInfo = null, this.fields = null, this.fullExtent = null, this.hasMultidimensions = false, this.imageMaxHeight = 4100, this.imageMaxWidth = 4100, this.interpolation = void 0, this.minScale = 0, this.maxScale = 0, this.multidimensionalInfo = null, this.multidimensionalSubset = null, this.noData = null, this.noDataInterpretation = void 0, this.objectIdField = null, this.geometryType = "polygon", this.typeIdField = null, this.types = [], this.pixelFilter = null, this.raster = void 0, this.sourceType = null, this.viewId = void 0, this.symbolizer = null, this.rasterFunctionInfos = null, this.serviceDataType = null, this.spatialReference = null, this.pixelType = null, this.serviceRasterInfo = null, this.sourceJSON = null, this.url = null, this.version = void 0;
    }
    initialize() {
      this._set("exportImageServiceParameters", new y4({ layer: this }));
    }
    readServiceSupportsMosaicRule(e4, t6) {
      return this._isMosaicRuleSupported(t6);
    }
    get _rasterFunctionNamesIndex() {
      const e4 = /* @__PURE__ */ new Map();
      return !this.rasterFunctionInfos || null != this.rasterFunctionInfos && this.rasterFunctionInfos.length < 1 || null != this.rasterFunctionInfos && this.rasterFunctionInfos.forEach((t6) => {
        e4.set(t6.name.toLowerCase().replaceAll(/ /gi, "_"), t6.name);
      }), e4;
    }
    readBandIds(e4, t6) {
      if (Array.isArray(e4) && e4.length > 0 && e4.every((e5) => "number" == typeof e5)) return e4;
    }
    readCapabilities(e4, t6) {
      return this._readCapabilities(t6);
    }
    writeCompressionQuality(e4, t6, i11) {
      null != e4 && "lerc" !== this.format && (t6[i11] = e4);
    }
    writeCompressionTolerance(e4, t6, i11) {
      "lerc" === this.format && null != e4 && (t6[i11] = e4);
    }
    readDefaultMosaicRule(e4, t6) {
      return this._serviceSupportsMosaicRule ? f6.fromJSON(t6) : null;
    }
    get fieldsIndex() {
      return this.fields ? new Z(this.fields) : null;
    }
    set format(e4) {
      e4 && Oe.has(e4.toLowerCase()) && this._set("format", e4.toLowerCase());
    }
    readFormat(e4, t6) {
      return "esriImageServiceDataTypeVector-UV" === t6.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === t6.serviceDataType || null != this.pixelFilter ? "lerc" : "jpgpng";
    }
    readMinScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    readMaxScale(e4, t6) {
      return null != t6.minLOD && null != t6.maxLOD ? e4 : 0;
    }
    set mosaicRule(e4) {
      let t6 = e4;
      (t6 == null ? void 0 : t6.mosaicMethod) && (t6 = f6.fromJSON({ ...t6.toJSON(), mosaicMethod: t6.mosaicMethod, mosaicOperation: t6.mosaicOperation })), this._set("mosaicRule", t6);
    }
    readMosaicRule(e4, t6) {
      const i11 = e4 || t6.mosaicRule;
      return i11 ? f6.fromJSON(i11) : this._isMosaicRuleSupported(t6) ? f6.fromJSON(t6) : null;
    }
    writeMosaicRule(e4, t6, i11) {
      let r4 = this.mosaicRule;
      const s10 = this.definitionExpression;
      r4 ? s10 && s10 !== r4.where && (r4 = r4.clone(), r4.where = s10) : s10 && (r4 = new f6({ where: s10 })), this._isValidCustomizedMosaicRule(r4) && (t6[i11] = r4.toJSON());
    }
    writeNoData(e4, t6, i11) {
      null != e4 && "number" == typeof e4 && (t6[i11] = Pe(e4));
    }
    readObjectIdField(e4, t6) {
      if (!e4) {
        const i11 = t6.fields.find((e5) => "esriFieldTypeOID" === e5.type || "oid" === e5.type);
        e4 = i11 == null ? void 0 : i11.name;
      }
      return e4;
    }
    get parsedUrl() {
      return I(this.url);
    }
    readSourceType(e4, t6) {
      return this._isMosaicDataset(t6) ? "mosaic-dataset" : "raster-dataset";
    }
    get renderer() {
      const { activePresetRendererName: e4, presetRenderers: t6 } = this;
      if (e4) {
        const i11 = t6 == null ? void 0 : t6.find(({ name: t7 }) => t7 === e4);
        return i11 == null ? void 0 : i11.renderer.clone();
      }
      return this.internalRenderer;
    }
    set renderer(e4) {
      this.activePresetRendererName = null, this.internalRenderer = e4;
    }
    set internalRenderer(e4) {
      this.loaded && (e4 = this._configRenderer(e4)), this._set("internalRenderer", e4);
    }
    readRenderer(e4, t6, i11) {
      var _a, _b;
      const r4 = (_b = (_a = t6 == null ? void 0 : t6.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer, n14 = c3(r4, i11);
      return null == n14 ? null : ("vector-field" === n14.type && t6.symbolTileSize && !r4.symbolTileSize && (n14.symbolTileSize = t6.symbolTileSize), p6(n14) || n.getLogger(this).warn("ArcGISImageService", "Imagery layer doesn't support given renderer type."), n14);
    }
    writeRenderer(e4, t6, i11) {
      t6.layerDefinition = t6.layerDefinition || {}, t6.layerDefinition.drawingInfo = t6.layerDefinition.drawingInfo || {}, t6.layerDefinition.drawingInfo.renderer = e4.toJSON(), "vector-field" === e4.type && (t6.symbolTileSize = e4.symbolTileSize);
    }
    get rasterFields() {
      var _a;
      const e4 = this._rasterAttributeTableFieldPrefix, t6 = new y({ name: "Raster.ItemPixelValue", alias: "Item Pixel Value", domain: null, editable: false, length: 50, type: "string" }), i11 = new y({ name: "Raster.ServicePixelValue", alias: "Service Pixel Value", domain: null, editable: false, length: 50, type: "string" }), r4 = new y({ name: "Raster.ServicePixelValue.Raw", alias: "Raw Service Pixel Value", domain: null, editable: false, length: 50, type: "string" });
      let s10 = this.fields ? a(this.fields) : [];
      s10.push(i11), ((_a = this.capabilities) == null ? void 0 : _a.operations.supportsQuery) && this.fields && this.fields.length > 0 && s10.push(t6), this.version >= 10.4 && null != this.rasterFunctionInfos && this.rasterFunctionInfos.some((e5) => "none" === e5.name.toLowerCase()) && s10.push(r4), null != this.rasterFunctionInfos && this.rasterFunctionInfos.filter((e5) => "none" !== e5.name.toLowerCase()).forEach((e5) => {
        s10.push(new y({ name: "Raster.ServicePixelValue." + e5.name, alias: e5.name, domain: null, editable: false, length: 50, type: "string" }));
      }), this._isVectorDataSet() && (s10.push(new y({ name: "Raster.Magnitude", alias: "Magnitude", domain: null, editable: false, type: "double" })), s10.push(new y({ name: "Raster.Direction", alias: "Direction", domain: null, editable: false, type: "double" })));
      const { attributeTable: n14 } = this.rasterInfo ?? {};
      if (null != n14) {
        const t7 = n14.fields.filter((e5) => "esriFieldTypeOID" !== e5.type && "value" !== e5.name.toLowerCase()).map((t8) => {
          const i12 = a(t8);
          return i12.name = e4 + t8.name, i12;
        });
        s10 = s10.concat(t7);
      }
      return s10;
    }
    set rasterFunction(e4) {
      let t6 = e4;
      (t6 == null ? void 0 : t6.rasterFunction) && (t6 = N.fromJSON({ ...t6.toJSON(), rasterFunction: t6.rasterFunction, rasterFunctionArguments: t6.rasterFunctionArguments })), this._set("rasterFunction", t6);
    }
    readRasterFunction(e4, t6) {
      const i11 = t6.rasterFunctionInfos;
      return t6.renderingRule || (i11 == null ? void 0 : i11.length) && "None" !== i11[0].name ? this._isRFTJson(t6.renderingRule) ? N.fromJSON({ rasterFunctionDefinition: t6.renderingRule }) : N.fromJSON(t6.renderingRule || { rasterFunctionInfos: t6.rasterFunctionInfos }) : null;
    }
    readSpatialReference(e4, t6) {
      const i11 = e4 || t6.extent.spatialReference;
      return i11 ? g.fromJSON(i11) : null;
    }
    readPixelType(e4) {
      return n6.fromJSON(e4) || e4;
    }
    writePixelType(e4, t6, i11) {
      null != this.serviceRasterInfo && this.pixelType === this.serviceRasterInfo.pixelType || (t6[i11] = n6.toJSON(e4));
    }
    readVersion(e4, t6) {
      let i11 = t6.currentVersion;
      return i11 || (i11 = t6.hasOwnProperty("fields") || t6.hasOwnProperty("timeInfo") ? 10 : 9.3), i11;
    }
    applyFilter(e4) {
      let t6 = e4;
      return this.pixelFilter && (t6 = this._clonePixelData(e4), this.pixelFilter(t6)), t6;
    }
    async applyRenderer(e4, t6) {
      let i11 = e4;
      const { renderer: r4, symbolizer: s10, pixelFilter: n14, bandIds: a14 } = this;
      if (!this._isPicture() && r4 && s10 && !n14) {
        const n15 = JSON.stringify(this._cachedRendererJson) !== JSON.stringify(r4.toJSON()), o3 = this._rasterJobHandler.instance;
        if (o3) {
          n15 && (s10.bind(), await o3.updateSymbolizer(s10, t6), this._cachedRendererJson = r4.toJSON());
          const l14 = await o3.symbolize({ bandIds: a14, ...e4 }, t6);
          i11 = { extent: e4.extent, pixelBlock: l14 };
        } else i11 = { extent: e4.extent, pixelBlock: s10.symbolize({ bandIds: a14, ...e4 }) };
      }
      return i11;
    }
    destroy() {
      this._shutdownJobHandler();
    }
    increaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount++;
    }
    decreaseRasterJobHandlerUsage() {
      this._rasterJobHandler.refCount--, this._rasterJobHandler.refCount <= 0 && this._shutdownJobHandler();
    }
    async computeAngles(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeAngles) throw new s("imagery-layer:compute-angles", "this operation is not supported on the input image service");
      return D(this.url, e4, this._getRequestOptions(t6));
    }
    async computePixelSpaceLocations(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputePixelLocation) throw new s("imagery-layer:compute-pixel-space-locations", "this operation is not supported on the input image service");
      return k2(this.url, e4, this._getRequestOptions(t6));
    }
    async computeHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeHistograms) throw new s("imagery-layer:compute-histograms", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), E(this.url, e4, this._getRequestOptions(t6));
    }
    async computeStatisticsHistograms(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsComputeStatisticsHistograms) throw new s("imagery-layer:compute-statistics-histograms", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), z(this.url, e4, this._getRequestOptions(t6));
    }
    async measureHeight(e4, t6) {
      const i11 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!("base-and-top" === e4.operationType ? i11.mensuration.supportsHeightFromBaseAndTop : "base-and-top-shadow" === e4.operationType ? i11.mensuration.supportsHeightFromBaseAndTopShadow : i11.mensuration.supportsHeightFromTopAndTopShadow)) throw new s("imagery-layer:measure-height", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), K(this.url, e4, this._getRequestOptions(t6));
    }
    async measureAreaAndPerimeter(e4, t6) {
      const i11 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(i11.mensuration.supportsAreaAndPerimeter && (!e4.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-area-and-perimeter", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), Q(this.url, e4, this._getRequestOptions(t6));
    }
    async measureDistanceAndAngle(e4, t6) {
      const i11 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(i11.mensuration.supportsDistanceAndAngle && (!e4.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-distance-and-angle", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), Y(this.url, e4, this._getRequestOptions(t6));
    }
    async measurePointOrCentroid(e4, t6) {
      const i11 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(i11.mensuration.supportsPointOrCentroid && (!e4.is3D || i11.mensuration.supports3D))) throw new s("imagery-layer:measure-point-or-centroid", "this operation is not supported on the input image service");
      return e4 = a(e4), this._applyMosaicAndRenderingRules(e4), W(this.url, e4, this._getRequestOptions(t6));
    }
    async measureLengthFromImage(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-length-from-image", "this operation is not supported on the input image service");
      if ("polyline" !== e4.geometry.type) throw new s("imagery-layer:measure-length-from-image", "this input geometry must be a polyline");
      return _2(this.url, e4, this._getRequestOptions(t6));
    }
    async measureAreaFromImage(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsMeasureFromImage) throw new s("imagery-layer:measure-area-from-image", "this operation is not supported on the input image service");
      if ("polygon" !== e4.geometry.type) throw new s("imagery-layer:measure-area-from-image", "this input geometry must be a polygon");
      return tt(this.url, e4, this._getRequestOptions(t6));
    }
    getField(e4) {
      const { fieldsIndex: t6 } = this;
      return null != t6 ? t6.get(e4) : void 0;
    }
    getFieldDomain(e4, t6) {
      const i11 = this.getField(e4);
      return i11 ? i11.domain : null;
    }
    async fetchImage(e4, t6, i11, r4 = {}) {
      if (null == e4 || null == t6 || null == i11) throw new s("imagery-layer:fetch-image", "Insufficient parameters for requesting an image. A valid extent, width and height values are required.");
      if (this.renderer || this.symbolizer) {
        const e5 = await this._generateRasterInfo(this.rasterFunction, { signal: r4.signal });
        e5 && (this.rasterInfo = e5);
      }
      const s10 = this.getExportImageServiceParameters(e4, t6, i11, r4.timeExtent);
      if (null == s10) {
        if (r4.requestAsImageElement && this._canRequestImageElement(this.format)) {
          const e5 = document.createElement("canvas");
          if (e5.width = t6, e5.height = i11, r4.returnImageBitmap) {
            return { imageBitmap: await t2(e5, `${Me2(this.parsedUrl)}/exportImage`, r4.signal) };
          }
          return { imageOrCanvasElement: e5 };
        }
        const { bandIds: s11, rasterInfo: n15 } = this, a14 = ((s11 == null ? void 0 : s11.length) || n15.bandCount) ?? 0, o4 = t6 * i11, l15 = n15.pixelType, u6 = [];
        for (let e5 = 0; e5 < a14; e5++) u6.push(g2.createEmptyBand(l15, o4));
        return { pixelData: { pixelBlock: new g2({ width: t6, height: i11, pixels: u6, mask: new Uint8Array(o4), pixelType: l15 }), extent: e4 } };
      }
      const n14 = !!r4.requestAsImageElement && !this.pixelFilter, o3 = n14 && !!r4.returnImageBitmap, l14 = { imageServiceParameters: s10, imageProps: { extent: e4, width: t6, height: i11, format: this.format }, requestAsImageElement: n14, returnImageBitmap: o3, signal: r4.signal };
      return this._requestArrayBuffer(l14);
    }
    fetchKeyProperties(e4) {
      return U(Me2(this.parsedUrl) + "/keyProperties", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => e5.data);
    }
    fetchRasterAttributeTable(e4) {
      return this.version < 10.1 ? Promise.reject(new s("#fetchRasterAttributeTable()", "Failed to get rasterAttributeTable")) : U(Me2(this.parsedUrl) + "/rasterAttributeTable", { query: this._getQueryParams({ renderingRule: this.version >= 10.3 ? e4 == null ? void 0 : e4.rasterFunction : null }) }).then((e5) => d3.fromJSON(e5.data));
    }
    getCatalogItemRasterInfo(e4, t6) {
      const i11 = { ...t6, query: this._getQueryParams() };
      return n13(Me2(this.parsedUrl), e4, i11);
    }
    async getCatalogItemICSInfo(e4, t6) {
      var _a, _b, _c, _d, _e;
      const { data: i11 } = await U(Me2(this.parsedUrl) + "/" + e4 + "/info/ics", { query: this._getQueryParams(), ...t6 }), r4 = i11 == null ? void 0 : i11.ics;
      if (!r4) return;
      let s10 = null;
      try {
        s10 = (await U(Me2(this.parsedUrl) + "/" + e4 + "/info", { query: this._getQueryParams(), ...t6 })).data.extent;
      } catch {
      }
      if (!(s10 == null ? void 0 : s10.spatialReference)) return { ics: r4, icsToPixelTransform: null, icsExtent: null, northDirection: null };
      const a14 = this.version >= 10.7 ? U(Me2(this.parsedUrl) + "/" + e4 + "/info/icstopixel", { query: this._getQueryParams(), ...t6 }).then((e5) => e5.data).catch(() => ({})) : {}, o3 = s10.spatialReference, l14 = { geometries: JSON.stringify({ geometryType: "esriGeometryEnvelope", geometries: [s10] }), inSR: c(o3), outSR: "0:" + e4 }, u6 = U(Me2(this.parsedUrl) + "/project", { query: this._getQueryParams(l14), ...t6 }).then((e5) => e5.data).catch(() => ({})), p21 = 5, c24 = (s10.xmin + s10.xmax) / 2, m14 = (s10.ymax - s10.ymin) / (p21 + 1), d10 = s10.ymin + m14, h5 = [];
      for (let n14 = 0; n14 < p21; n14++) h5.push({ x: c24, y: d10 + m14 * n14 });
      const f11 = { geometries: JSON.stringify({ geometryType: "esriGeometryPoint", geometries: h5 }), inSR: c(o3), outSR: "0:" + e4 }, y12 = U(Me2(this.parsedUrl) + "/project", { query: this._getQueryParams(f11), ...t6 }).then((e5) => e5.data).catch(() => ({})), g6 = await Promise.all([a14, u6, y12]);
      let R3 = g6[0].ipxf;
      if (null == R3) {
        const e5 = (_a = r4.geodataXform) == null ? void 0 : _a.xf_0;
        "topup" === ((_b = e5 == null ? void 0 : e5.name) == null ? void 0 : _b.toLowerCase()) && 6 === ((_c = e5 == null ? void 0 : e5.coefficients) == null ? void 0 : _c.length) && (R3 = { affine: { name: "ics [sensor: Frame] to pixel (column, row) transformation", coefficients: e5.coefficients, cellsizeRatio: 0, type: "GeometricXform" } });
      }
      const w3 = w.fromJSON((_e = (_d = g6[1]) == null ? void 0 : _d.geometries) == null ? void 0 : _e[0]);
      w3 && (w3.spatialReference = new g({ wkid: 0, imageCoordinateSystem: r4 }));
      const v3 = g6[2].geometries ? g6[2].geometries.filter((e5) => null != (e5 == null ? void 0 : e5.x) && null != e5.y && "NaN" !== e5.x && "NaN" !== e5.y) : [], I2 = v3.length;
      if (I2 < 3) return { ics: r4, icsToPixelTransform: R3, icsExtent: w3, northDirection: null };
      let S3 = 0, x4 = 0, _3 = 0, F2 = 0;
      for (let n14 = 0; n14 < I2; n14++) S3 += v3[n14].x, x4 += v3[n14].y, _3 += v3[n14].x * v3[n14].x, F2 += v3[n14].x * v3[n14].y;
      const D2 = (I2 * F2 - S3 * x4) / (I2 * _3 - S3 * S3);
      let T2 = 0;
      const O = v3[p21 - 1].x > v3[0].x, P4 = v3[p21 - 1].y > v3[0].y;
      return D2 === 1 / 0 ? T2 = P4 ? 90 : 270 : 0 === D2 ? T2 = O ? 0 : 180 : D2 > 0 ? T2 = O ? 180 * Math.atan(D2) / Math.PI : 180 * Math.atan(D2) / Math.PI + 180 : D2 < 0 && (T2 = P4 ? 180 + 180 * Math.atan(D2) / Math.PI : 360 + 180 * Math.atan(D2) / Math.PI), { ics: r4, icsToPixelTransform: R3, icsExtent: w3, northDirection: T2 };
    }
    async generateRasterInfo(e4, t6) {
      var _a;
      e4 = h(N, e4);
      const i11 = { ...t6, query: this._getQueryParams() };
      if (!e4 || "none" === ((_a = e4.functionName) == null ? void 0 : _a.toLowerCase()) || this._isVectorFieldResampleFunction(e4)) return this.serviceRasterInfo ?? f7(Me2(this.parsedUrl), this.sourceJSON, i11);
      const r4 = Ce(e4);
      if (!r4) throw new s("imagery-layer:generate-raster-info", "the rendering rule is not supported");
      if (this._functionRasterInfos[r4]) return this._functionRasterInfos[r4];
      const s10 = p5(Me2(this.parsedUrl), e4, i11);
      this._functionRasterInfos[r4] = s10;
      try {
        return await s10;
      } catch (n14) {
        throw this._functionRasterInfos[r4] = null, n14;
      }
    }
    getExportImageServiceParameters(e4, t6, i11, r4) {
      var _a, _b;
      e4 = e4.clone().shiftCentralMeridian();
      const s10 = at(e4.spatialReference, Me2(this.parsedUrl));
      this.pixelType !== this.serviceRasterInfo.pixelType && (this.exportImageServiceParameters.pixelType = this.pixelType);
      const n14 = this.exportImageServiceParameters.toJSON(), { bandIds: a14, noData: o3 } = n14;
      let { renderingRule: l14 } = n14;
      const u6 = (_a = this.rasterFunction) == null ? void 0 : _a.rasterFunctionDefinition, p21 = (_b = this.renderer) == null ? void 0 : _b.type, c24 = !p21 || "raster-stretch" === p21 || "raster-colormap" === p21 || "unique-value" === p21 || "class-breaks" === p21 || "raster-shaded-relief" === p21;
      if ((a14 == null ? void 0 : a14.length) && this._hasRasterFunction(this.rasterFunction) && !u6 && c24) {
        const e5 = { rasterFunction: "ExtractBand", rasterFunctionArguments: { BandIds: a14 } };
        if ("Stretch" === l14.rasterFunction) e5.rasterFunctionArguments.Raster = l14.rasterFunctionArguments.Raster, l14.rasterFunctionArguments.Raster = e5;
        else if ("Colormap" === l14.rasterFunction) {
          const t7 = l14.rasterFunctionArguments.Raster;
          "Stretch" === (t7 == null ? void 0 : t7.rasterFunction) ? (e5.rasterFunctionArguments.Raster = t7.rasterFunctionArguments.Raster, t7.rasterFunctionArguments.Raster = e5) : (e5.rasterFunctionArguments.Raster = t7, l14.rasterFunctionArguments.Raster = e5);
        } else e5.rasterFunctionArguments.Raster = l14, l14 = e5;
        n14.bandIds = void 0;
      } else n14.bandIds = a14 == null ? void 0 : a14.join(",");
      Array.isArray(o3) && o3.length > 0 && (n14.noData = o3.join(","));
      const m14 = this._processMultidimensionalIntersection(null, r4, this.exportImageServiceParameters.mosaicRule);
      if (m14.isOutSide) return null;
      n14.mosaicRule = null != m14.mosaicRule ? JSON.stringify(m14.mosaicRule) : null, r4 = m14.timeExtent, n14.renderingRule = this._getRenderingRuleString(N.fromJSON(l14));
      const d10 = {};
      if (null != r4) {
        const { start: e5, end: t7 } = r4.toJSON();
        e5 && t7 && e5 === t7 ? d10.time = "" + e5 : null == e5 && null == t7 || (d10.time = `${e5 ?? "null"},${t7 ?? "null"}`);
      }
      return { bbox: e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax, bboxSR: s10, imageSR: s10, size: t6 + "," + i11, ...n14, ...d10 };
    }
    async getSamples(e4, t6) {
      const i11 = await this._fetchCapabilities(t6 == null ? void 0 : t6.signal);
      if (!(i11 == null ? void 0 : i11.operations.supportsGetSamples)) throw new s("imagery-layer:get-samples", "getSamples operation is not supported on the input image service");
      e4 = a(e4);
      const { raster: r4 } = this;
      return r4 && null == e4.raster && (e4.raster = r4), V2(this.url, e4, this._getRequestOptions(t6));
    }
    async identify(e4, t6) {
      var _a;
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsIdentify) throw new s("imagery-layer:identify", "identify operation is not supported on the input image service");
      e4 = a(e4), this.version < 10.91 && "extent" === ((_a = e4.geometry) == null ? void 0 : _a.type) && (e4.geometry = v.fromExtent(e4.geometry));
      const i11 = this._processMultidimensionalIntersection(e4.geometry, e4.timeExtent, e4.mosaicRule || this.mosaicRule);
      if (i11.isOutSide) throw new s("imagery-layer:identify", "the request cannot be fulfilled when falling outside of the multidimensional subset");
      e4.timeExtent = i11.timeExtent, e4.mosaicRule = i11.mosaicRule;
      const { raster: r4, rasterFunction: s10 } = this;
      return s10 && null == e4.rasterFunction && (e4.rasterFunction = s10), r4 && null == e4.raster && (e4.raster = r4), X(this.url, e4, this._getRequestOptions(t6));
    }
    async imageToMap(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsImageToMap) throw new s("imagery-layer:image-to-map", "imageToMap operation is not supported on the input image service");
      return mt(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async imageToMapMultiray(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsImageToMapMultiray) throw new s("imagery-layer:image-to-map-multiray", "imageToMapMultiray operation is not supported on the input image service");
      return it(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async mapToImage(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsMapToImage) throw new s("imagery-layer:map-to-image", "mapToImage operation is not supported on the input image service");
      return pt(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async findImages(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsFindImages) throw new s("imagery-layer:find-images", "findImages operation is not supported on the input image service");
      return ct(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async getImageUrl(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsGetImageUrl) throw new s("imagery-layer:get-image-url", "getImageUrl operation is not supported on the input image service");
      return ut(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    createQuery() {
      return new b({ outFields: ["*"], returnGeometry: true, where: this.definitionExpression || "1=1" });
    }
    async queryBoundary(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsQueryBoundary) throw new s("imagery-layer:query-boundary", "queryBoundary operation is not supported on the input image service");
      return e4 = e4 ?? { outSpatialReference: this.spatialReference }, st(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async queryRasters(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s6(this.url, e4, t6);
    }
    async queryObjectIds(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s5(this.url, e4, t6);
    }
    async queryGPSInfo(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsQueryGPSInfo) throw new s("imagery-layer:query-gps-info", "queryGPSInfo operation is not supported on the input image service");
      return e4 = e4 ?? { where: "1=1" }, nt(Me2(this.parsedUrl), e4, this._getRequestOptions(t6));
    }
    async queryRasterCount(e4, t6) {
      return { query: e4, requestOptions: t6 } = await this._prepareForQuery(e4, t6), s4(this.url, e4, t6);
    }
    async queryVisibleRasters(e4, t6) {
      var _a, _b, _c, _d;
      if (!e4) throw new s("imagery-layer: query-visible-rasters", "missing query parameter");
      await this.load();
      const { pixelSize: i11, returnDomainValues: r4, returnTopmostRaster: s10, showNoDataRecords: n14 } = t6 || { pixelSize: null, returnDomainValues: false, returnTopmostRaster: false, showNoDataRecords: false };
      let o3 = false, l14 = null, u6 = null;
      const p21 = "raster.servicepixelvalue", c24 = this._rasterFunctionNamesIndex;
      if (null != e4.outFields && (o3 = e4.outFields.some((e5) => !e5.toLowerCase().includes(p21)), this.version >= 10.4)) {
        const t7 = e4.outFields.filter((e5) => e5.toLowerCase().includes(p21) && e5.length > p21.length).map((e5) => {
          const t8 = e5.slice(p21.length + 1);
          return [this._updateRenderingRulesFunctionName(t8, c24), t8];
        });
        l14 = t7.map((e5) => new N({ functionName: e5[0] })), u6 = t7.map((e5) => e5[1]);
        const { rasterFunction: i12 } = this;
        0 === l14.length ? (i12 == null ? void 0 : i12.functionName) ? (l14.push(i12), u6.push(i12.functionName)) : l14 = null : (i12 == null ? void 0 : i12.functionName) && !l14.some((e5) => e5.functionName === i12.functionName) && (l14.push(i12), u6.push(i12.functionName));
      }
      const m14 = null == e4.outSpatialReference || e4.outSpatialReference.equals(this.spatialReference), { multidimensionalSubset: d10 } = this;
      let h5 = e4.timeExtent || this.timeExtent;
      if (d10) {
        const { isOutside: t7, intersection: i12 } = m3(d10, { geometry: e4.geometry, timeExtent: e4.timeExtent, multidimensionalDefinition: (_a = this.exportImageServiceParameters.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition });
        if (t7) throw new s("imagery-layer:query-visible-rasters", "the request cannot be fulfilled when falling outside of the multidimensional subset");
        null != (i12 == null ? void 0 : i12.timeExtent) && (h5 = i12.timeExtent);
      }
      const f11 = this._combineMosaicRuleWithTimeExtent(this.exportImageServiceParameters.mosaicRule, h5);
      let y12 = e4.geometry;
      this.version < 10.91 && "extent" === (y12 == null ? void 0 : y12.type) && (y12 = v.fromExtent(y12));
      const g6 = this._getQueryParams({ geometry: y12, timeExtent: h5, mosaicRule: f11, rasterFunction: this.version < 10.4 ? this.rasterFunction : null, rasterFunctions: l14, pixelSize: i11, returnCatalogItems: o3, returnGeometry: m14, raster: this.raster, maxItemCount: s10 ? 1 : null });
      delete g6.f;
      const R3 = new y9(g6);
      try {
        await this._generateRasterInfo(this.rasterFunction);
        const i12 = await X(this.url, R3, { signal: t6 == null ? void 0 : t6.signal, query: { ...this.customParameters } }), s11 = e4.outFields, a14 = null != i12.value && i12.value.toLowerCase().includes("nodata");
        if (!(o3 && !m14 && ((_b = i12 == null ? void 0 : i12.catalogItems) == null ? void 0 : _b.features.length) && (n14 || !a14))) return this._processVisibleRastersResponse(i12, { returnDomainValues: r4, templateRRFunctionNames: u6, showNoDataRecords: n14, templateFields: s11 });
        const l15 = this.objectIdField || "ObjectId", p22 = ((_c = i12.catalogItems) == null ? void 0 : _c.features) ?? [], c25 = p22.map((e5) => {
          var _a2;
          return (_a2 = e5.attributes) == null ? void 0 : _a2[l15];
        }), d11 = new b({ objectIds: c25, returnGeometry: true, outSpatialReference: e4.outSpatialReference, outFields: [l15] }), h6 = await this.queryRasters(d11);
        return ((_d = h6 == null ? void 0 : h6.features) == null ? void 0 : _d.length) && h6.features.forEach((t7) => {
          p22.forEach((i13) => {
            i13.attributes[l15] === t7.attributes[l15] && t7.geometry && (i13.geometry = t7.geometry.clone(), null != e4.outSpatialReference && (i13.geometry.spatialReference = e4.outSpatialReference));
          });
        }), this._processVisibleRastersResponse(i12, { returnDomainValues: r4, templateRRFunctionNames: u6, showNoDataRecords: n14, templateFields: s11 });
      } catch {
        throw new s("imagery-layer:query-visible-rasters", "encountered error when querying visible rasters");
      }
    }
    async fetchVariableStatisticsHistograms(e4, t6) {
      const i11 = U(Me2(this.parsedUrl) + "/statistics", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.statistics;
      }), r4 = U(Me2(this.parsedUrl) + "/histograms", { query: this._getQueryParams({ variable: e4 }), signal: t6 }).then((e5) => {
        var _a;
        return (_a = e5.data) == null ? void 0 : _a.histograms;
      }), s10 = await Promise.all([i11, r4]);
      return s10[0] && s10[0].forEach((e5) => {
        e5.avg = e5.mean, e5.stddev = e5.standardDeviation;
      }), { statistics: s10[0] || null, histograms: s10[1] || null };
    }
    async createFlowMesh(e4, t6) {
      const i11 = this._rasterJobHandler.instance;
      return i11 ? i11.createFlowMesh(e4, t6) : s8(e4.meshType, e4.simulationSettings, e4.flowData, null != t6.signal ? t6.signal : new AbortController().signal);
    }
    getMultidimensionalSubsetVariables(e4) {
      const t6 = e4 ?? this.serviceRasterInfo.multidimensionalInfo;
      return g3(this.multidimensionalSubset, t6);
    }
    async _fetchService(e4) {
      await this._fetchServiceInfo(e4), this.rasterInfo || (this.rasterInfo = this.serviceRasterInfo);
      const t6 = this.sourceJSON, i11 = null != this.serviceRasterInfo ? Promise.resolve(this.serviceRasterInfo) : f7(Me2(this.parsedUrl), t6, { signal: e4, query: this._getQueryParams() }).then((e5) => (this._set("serviceRasterInfo", e5), this._set("multidimensionalInfo", e5.multidimensionalInfo), c5(e5, t6), e5)), r4 = this._hasRasterFunction(this.rasterFunction) ? this._generateRasterInfo(this.rasterFunction, { signal: e4 }) : null, s10 = this._getRasterFunctionInfos();
      return Promise.all([i11, r4, s10]).then((e5) => {
        e5[1] ? this._set("rasterInfo", e5[1]) : this._set("rasterInfo", e5[0]), e5[2] && this._set("rasterFunctionInfos", e5[2]), this.internalRenderer && !this._isSupportedRenderer(this.internalRenderer) && (this._set("internalRenderer", null), n.getLogger(this).warn("ArcGISImageService", "Switching to the default renderer. Renderer applied is not valid for this Imagery Layer")), this._set("internalRenderer", this._configRenderer(this.renderer)), this.addHandles([d(() => this.rasterFunction, (e6) => {
          (this.renderer || this.symbolizer || this.popupEnabled && this.popupTemplate) && this._generateRasterInfo(e6).then((e7) => {
            e7 && (this.rasterInfo = e7);
          });
        })]);
        const { serviceRasterInfo: t7 } = this;
        null != t7.multidimensionalInfo && this._updateMultidimensionalDefinition(t7);
      });
    }
    _combineMosaicRuleWithTimeExtent(e4, t6) {
      var _a;
      const i11 = this.timeInfo, { multidimensionalInfo: r4 } = this.serviceRasterInfo;
      if (null == e4 || null == r4 || null == t6 || null == (i11 == null ? void 0 : i11.startField)) return e4;
      const { startField: s10 } = i11, n14 = r4.variables.some((e5) => e5.dimensions.some((e6) => e6.name === s10)) ? s10 : "StdTime";
      if (e4 = e4.clone(), "mosaic-dataset" === this.sourceType) return e4.multidimensionalDefinition = (_a = e4.multidimensionalDefinition) == null ? void 0 : _a.filter((e5) => e5.dimensionName !== n14), this._cleanupMultidimensionalDefinition(e4);
      e4.multidimensionalDefinition = e4.multidimensionalDefinition || [];
      const a14 = e4.multidimensionalDefinition.filter((e5) => e5.dimensionName === n14), o3 = null != t6.start ? t6.start.getTime() : null, l14 = null != t6.end ? t6.end.getTime() : null, u6 = null == o3 || null == l14 || o3 === l14, p21 = u6 ? [o3 || l14] : [[o3, l14]], c24 = this.version >= 10.8;
      if (a14.length) a14.forEach((e5) => {
        e5.dimensionName === n14 && (c24 ? (e5.dimensionName = null, e5.isSlice = false, e5.values = []) : (e5.isSlice = u6, e5.values = p21));
      });
      else if (!c24) {
        const t7 = e4.multidimensionalDefinition.filter((e5) => null != e5.variableName && null == e5.dimensionName);
        t7.length ? t7.forEach((e5) => {
          e5.dimensionName = n14, e5.isSlice = u6, e5.values = p21;
        }) : e4.multidimensionalDefinition.push(new p4({ variableName: "", dimensionName: n14, isSlice: u6, values: p21 }));
      }
      return this._cleanupMultidimensionalDefinition(e4);
    }
    _cleanupMultidimensionalDefinition(e4) {
      return null == e4 ? null : (e4.multidimensionalDefinition && (e4.multidimensionalDefinition = e4.multidimensionalDefinition.filter((e5) => !(!e5.variableName && !e5.dimensionName)), 0 === e4.multidimensionalDefinition.length && (e4.multidimensionalDefinition = null)), "mosaic-dataset" !== this.sourceType && null == e4.multidimensionalDefinition ? null : e4);
    }
    async _prepareForQuery(e4, t6) {
      if (!(await this._fetchCapabilities(t6 == null ? void 0 : t6.signal)).operations.supportsQuery) throw new s("imagery-layer:query-rasters", "query operation is not supported on the input image service");
      return e4 = null != e4 ? h(b, e4) : this.createQuery(), t6 = this._getRequestOptions(t6), this.raster && (t6.query = { ...t6.query, raster: this.raster }), { query: e4, requestOptions: t6 };
    }
    async _initJobHandler() {
      if (null != this._rasterJobHandler.connectionPromise) return this._rasterJobHandler.connectionPromise;
      const e4 = new t4();
      this._rasterJobHandler.connectionPromise = e4.initialize().then(() => {
        this._rasterJobHandler.instance = e4;
      }, () => {
      }), await this._rasterJobHandler.connectionPromise;
    }
    _shutdownJobHandler() {
      this._rasterJobHandler.instance && this._rasterJobHandler.instance.destroy(), this._rasterJobHandler.instance = null, this._rasterJobHandler.connectionPromise = null, this._rasterJobHandler.refCount = 0, this._cachedRendererJson = null;
    }
    _isSupportedRenderer(e4) {
      const { rasterInfo: t6, rasterFunction: i11 } = this;
      return "unique-value" === e4.type && this._hasRasterFunction(i11) && 1 === (t6 == null ? void 0 : t6.bandCount) && ["u8", "s8"].includes(t6.pixelType) || null != t6 && null != e4 && B2(t6).includes(e4.type);
    }
    async _fetchCapabilities(e4) {
      return this.capabilities || await this._fetchServiceInfo(e4), this.capabilities;
    }
    async _fetchServiceInfo(e4) {
      var _a;
      let t6 = this.sourceJSON;
      if (!t6) {
        const { data: i11, ssl: r4 } = await U(Me2(this.parsedUrl), { query: this._getQueryParams(), signal: e4 });
        t6 = i11, this.sourceJSON = t6, r4 && (this.url = this.url.replace(/^http:/i, "https:"));
      }
      if (((_a = t6.capabilities) == null ? void 0 : _a.toLowerCase().split(",").map((e5) => e5.trim()).indexOf("tilesonly")) > -1) throw new s("imagery-layer:fetch-service-info", "use ImageryTileLayer to open tiles-only image services");
      this.read(t6, { origin: "service", url: this.parsedUrl });
    }
    _isMosaicDataset(e4) {
      var _a;
      return e4.serviceSourceType ? "esriImageServiceSourceTypeMosaicDataset" === e4.serviceSourceType : ((_a = e4.fields) == null ? void 0 : _a.length) > 0;
    }
    _isMosaicRuleSupported(e4) {
      var _a;
      if (!e4) return false;
      const t6 = this._isMosaicDataset(e4), i11 = e4.currentVersion >= 10.71 && e4.hasMultidimensions && !(((_a = e4.fields) == null ? void 0 : _a.length) > 1);
      return t6 || i11;
    }
    _isVectorFieldResampleFunction(e4) {
      if (null == e4) return false;
      const { functionName: t6, functionArguments: i11 } = e4, r4 = "resample" === (t6 == null ? void 0 : t6.toLowerCase()), s10 = (i11 == null ? void 0 : i11.ResampleType) || (i11 == null ? void 0 : i11.resampleType);
      return r4 && (7 === s10 || 10 === s10);
    }
    _isPicture() {
      return !this.format || this.format.includes("jpg") || this.format.includes("png");
    }
    _configRenderer(e4) {
      var _a, _b, _c;
      const t6 = this._isPicture(), { rasterInfo: i11 } = this;
      if (!t6 && !this.pixelFilter || this._isVectorDataSet()) {
        const t7 = (_b = (_a = this.mosaicRule) == null ? void 0 : _a.multidimensionalDefinition) == null ? void 0 : _b[0].variableName, r4 = L({ variableName: t7, rasterFunctionName: (_c = this.rasterFunction) == null ? void 0 : _c.functionName, presetRenderers: this.presetRenderers });
        if (!this.bandIds && i11.bandCount >= 3) {
          const e5 = (r4 == null ? void 0 : r4.bandIds) ?? U2(i11);
          !e5 || 3 === i11.bandCount && 0 === e5[0] && 1 === e5[1] && 2 === e5[2] || (this.bandIds = e5);
        }
        e4 || (e4 = (r4 == null ? void 0 : r4.renderer) ?? q2(i11, { bandIds: this.bandIds, variableName: this.rasterFunction ? null : t7 }));
        const s10 = ee(e4.toJSON());
        this.symbolizer ? (this.symbolizer.rendererJSON = s10, this.symbolizer.rasterInfo = i11) : this.symbolizer = new _({ rendererJSON: s10, rasterInfo: i11 }), this.symbolizer.bind().success || (this.symbolizer = null);
      }
      return e4;
    }
    _clonePixelData(e4) {
      return null == e4 ? e4 : { extent: e4.extent && e4.extent.clone(), pixelBlock: null != e4.pixelBlock ? e4.pixelBlock.clone() : null };
    }
    _getQueryParams(e4) {
      null != (e4 == null ? void 0 : e4.renderingRule) && "string" != typeof e4.renderingRule && (e4.renderingRule = this._getRenderingRuleString(e4.renderingRule));
      const { raster: t6, viewId: i11 } = this;
      return { raster: t6, viewId: i11, f: "json", ...e4, ...this.customParameters };
    }
    _getRequestOptions(e4) {
      return { ...e4, query: { ...e4 == null ? void 0 : e4.query, ...this.customParameters } };
    }
    _decodePixelBlock(e4, t6, i11) {
      return this._rasterJobHandler.instance ? this._rasterJobHandler.instance.decode({ data: e4, options: t6 }) : j3(e4, t6, i11);
    }
    async _getRasterFunctionInfos(e4) {
      var _a;
      const t6 = this.sourceJSON.rasterFunctionInfos;
      if (this.loaded) return t6;
      if (t6 && this.version >= 10.3) {
        if (1 === t6.length && "none" === t6[0].name.toLowerCase()) return t6;
        const i11 = await U(Me2(this.parsedUrl) + "/rasterFunctionInfos", { query: this._getQueryParams(), signal: e4 });
        return (_a = i11.data) == null ? void 0 : _a.rasterFunctionInfos;
      }
      return null;
    }
    _canRequestImageElement(e4) {
      return !this.pixelFilter && (!e4 || e4.includes("png"));
    }
    async _requestArrayBuffer(e4) {
      const { imageProps: t6, requestAsImageElement: i11, returnImageBitmap: r4, signal: s10 } = e4;
      if (i11 && this._canRequestImageElement(t6.format)) {
        const i12 = `${Me2(this.parsedUrl)}/exportImage`, { data: a14 } = await U(i12, { responseType: r4 ? "blob" : "image", query: this._getQueryParams({ f: "image", ...this.refreshParameters, ...e4.imageServiceParameters }), signal: s10 });
        if (a14 instanceof Blob) {
          return { imageBitmap: await t2(a14, i12, s10), params: t6 };
        }
        return { imageOrCanvasElement: a14, params: t6 };
      }
      const o3 = this._initJobHandler(), l14 = U(Me2(this.parsedUrl) + "/exportImage", { responseType: "array-buffer", query: this._getQueryParams({ f: "image", ...e4.imageServiceParameters }), signal: s10 }), u6 = (await Promise.all([l14, o3]))[0].data, p21 = t6.format || "jpgpng";
      let c24 = p21;
      if ("bsq" !== c24 && "bip" !== c24 && (c24 = P(u6)), !c24) throw new s("imagery-layer:fetch-image", "unsupported format signature " + String.fromCharCode.apply(null, new Uint8Array(u6)));
      const m14 = { signal: s10 }, d10 = "gif" === p21 || "bmp" === p21 || p21.includes("png") && ("png" === c24 || "jpg" === c24) ? j3(u6, { useCanvas: true, ...t6 }, m14) : this._decodePixelBlock(u6, { width: t6.width, height: t6.height, planes: null, pixelType: null, noDataValue: null, format: p21 }, m14);
      return { pixelData: { pixelBlock: await d10, extent: t6.extent }, params: t6 };
    }
    _generateRasterInfo(e4, t6) {
      return this.generateRasterInfo(e4, t6).catch(() => null);
    }
    _isValidCustomizedMosaicRule(e4) {
      var _a;
      return e4 && JSON.stringify(e4.toJSON()) !== JSON.stringify((_a = this.defaultMosaicRule) == null ? void 0 : _a.toJSON());
    }
    _updateMultidimensionalDefinition(e4) {
      var _a;
      if (this._isValidCustomizedMosaicRule(this.mosaicRule)) return;
      let t6 = d6(e4, { multidimensionalSubset: this.multidimensionalSubset });
      if (null != t6 && t6.length > 0) {
        this.mosaicRule = this.mosaicRule || new f6();
        const e5 = this.mosaicRule.multidimensionalDefinition;
        !this.sourceJSON.defaultVariableName && this.rasterFunction && "none" !== ((_a = this.rasterFunction.functionName) == null ? void 0 : _a.toLowerCase()) && t6.forEach((e6) => e6.variableName = ""), t6 = t6.filter(({ variableName: e6, dimensionName: t7 }) => e6 && "*" !== e6 || t7), !(e5 == null ? void 0 : e5.length) && t6.length && (this.mosaicRule.multidimensionalDefinition = t6);
      }
    }
    _processVisibleRastersResponse(e4, i11) {
      var _a, _b, _c;
      i11 = i11 || {};
      const r4 = e4.value, { templateRRFunctionNames: s10, showNoDataRecords: n14, returnDomainValues: a14, templateFields: o3 } = i11, l14 = e4.processedValues;
      let u6 = (_a = e4.catalogItems) == null ? void 0 : _a.features, p21 = ((_c = (_b = e4.properties) == null ? void 0 : _b.Values) == null ? void 0 : _c.map((e5) => e5.replaceAll(/ /gi, ", "))) || [];
      const c24 = this.objectIdField || "ObjectId", m14 = "string" == typeof r4 && r4.toLowerCase().includes("nodata"), d10 = [];
      if (r4 && !u6 && !m14) {
        const e5 = {};
        e5[c24] = 0;
        p21 = [r4], u6 = [new d2({ geometry: this.fullExtent, attributes: e5 })];
      }
      if (!u6) return [];
      let h5, f11, y12;
      this._updateResponseFieldNames(u6, o3), m14 && !n14 && (u6 = []);
      for (let t6 = 0; t6 < u6.length; t6++) {
        if (h5 = u6[t6], null != r4) {
          if (f11 = p21[t6], y12 = this.rasterFunction && l14 && l14.length > 0 && s10 && s10.length > 0 && s10.includes(this.rasterFunction.functionName) ? l14[s10.indexOf(this.rasterFunction.functionName)] : r4, "nodata" === f11.toLowerCase() && !n14) continue;
          const e5 = "Raster.ItemPixelValue", i12 = "Raster.ServicePixelValue";
          h5.attributes[e5] = f11, h5.attributes[i12] = y12, this._updateFeatureWithMagDirValues(h5, f11);
          const a15 = this.fields && this.fields.length > 0;
          let o4 = this.rasterFunction && null != this.serviceRasterInfo.attributeTable ? a15 ? f11 : r4 : y12;
          this.rasterFunction || (o4 = a15 ? f11 : r4), this._updateFeatureWithRasterAttributeTableValues(h5, o4);
        }
        if (h5.sourceLayer = h5.layer = this, a14 && this._updateFeatureWithDomainValues(h5), s10 && l14 && s10.length === l14.length) for (let e5 = 0; e5 < s10.length; e5++) {
          const t7 = "Raster.ServicePixelValue." + s10[e5];
          h5.attributes[t7] = l14[e5];
        }
        d10.push(u6[t6]);
      }
      return d10;
    }
    _processMultidimensionalIntersection(e4, t6, i11) {
      const { multidimensionalSubset: r4 } = this;
      if (!r4) return { isOutSide: false, timeExtent: t6, mosaicRule: i11 = this._combineMosaicRuleWithTimeExtent(i11, t6) };
      if (r4) {
        const { isOutside: i12, intersection: s10 } = m3(r4, { geometry: e4, timeExtent: t6 });
        if (i12) return { isOutSide: true, timeExtent: null, mosaicRule: null };
        null != (s10 == null ? void 0 : s10.timeExtent) && (t6 = s10.timeExtent);
      }
      if (i11 = this._combineMosaicRuleWithTimeExtent(i11, t6), i11 == null ? void 0 : i11.multidimensionalDefinition) {
        const { isOutside: e5 } = m3(r4, { multidimensionalDefinition: i11.multidimensionalDefinition });
        if (e5) return { isOutSide: true, timeExtent: null, mosaicRule: null };
      }
      return { isOutSide: false, timeExtent: t6, mosaicRule: i11 };
    }
    _updateFeatureWithRasterAttributeTableValues(e4, t6) {
      const i11 = this.rasterInfo.attributeTable || this.serviceRasterInfo.attributeTable;
      if (null == i11) return;
      const { features: r4, fields: s10 } = i11, n14 = s10.map((e5) => e5.name).find((e5) => "value" === e5.toLowerCase());
      if (!n14) return;
      const a14 = r4.filter((e5) => e5.attributes[n14] === (null != t6 ? parseInt(t6, 10) : null));
      a14 && a14[0] && s10.forEach((t7) => {
        const i12 = this._rasterAttributeTableFieldPrefix + t7.name;
        e4.attributes[i12] = a14[0].attributes[t7.name];
      });
    }
    _updateFeatureWithMagDirValues(e4, t6) {
      if (!this._isVectorDataSet()) return;
      const i11 = t6.split(/,\s*/).map((e5) => parseFloat(e5)), r4 = i11.map((e5) => [e5]), s10 = i11.map((e5) => ({ minValue: e5, maxValue: e5, noDataValue: null })), n14 = new g2({ height: 1, width: 1, pixelType: "f32", pixels: r4, statistics: s10 });
      null != this.pixelFilter && this.pixelFilter({ pixelBlock: n14, extent: new w(0, 0, 0, 0, this.spatialReference) });
      const a14 = "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType ? [n14.pixels[0][0], n14.pixels[1][0]] : l4([n14.pixels[0][0], n14.pixels[1][0]]);
      e4.attributes["Raster.Magnitude"] = a14[0], e4.attributes["Raster.Direction"] = a14[1];
    }
    _updateFeatureWithDomainValues(e4) {
      const t6 = this.fields && this.fields.filter((e5) => e5.domain && "coded-value" === e5.domain.type);
      null != t6 && t6.forEach((t7) => {
        const i11 = e4.attributes[t7.name];
        if (null != i11) {
          const r4 = t7.domain.codedValues.find((e5) => e5.code === i11);
          r4 && (e4.attributes[t7.name] = r4.name);
        }
      });
    }
    _updateResponseFieldNames(e4, t6) {
      if (!t6 || t6.length < 1) return;
      const i11 = this.fieldsIndex;
      null != i11 && e4.forEach((e5) => {
        var _a;
        if (e5 == null ? void 0 : e5.attributes) for (const r4 of t6) {
          const t7 = (_a = i11.get(r4)) == null ? void 0 : _a.name;
          t7 && t7 !== r4 && (e5.attributes[r4] = e5.attributes[t7], delete e5.attributes[t7]);
        }
      });
    }
    _getRenderingRuleString(e4) {
      if (e4) {
        let t6 = e4.toJSON();
        return t6 = t6.rasterFunctionDefinition ?? t6, (t6.thumbnail || t6.thumbnailEx) && (t6.thumbnail = t6.thumbnailEx = null), JSON.stringify(t6);
      }
      return null;
    }
    _hasRasterFunction(e4) {
      return null != (e4 == null ? void 0 : e4.functionName) && "none" !== e4.functionName.toLowerCase();
    }
    _updateRenderingRulesFunctionName(e4, t6) {
      if (!e4 || e4.length < 1) return;
      if ("Raw" === e4) return e4.replace("Raw", "None");
      const i11 = e4.toLowerCase().replaceAll(/ /gi, "_");
      return t6.has(i11) ? t6.get(i11) : e4;
    }
    _isRFTJson(e4) {
      return (e4 == null ? void 0 : e4.name) && e4.arguments && e4.function && e4.hasOwnProperty("functionType");
    }
    _isVectorDataSet() {
      return "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType;
    }
    _applyMosaicAndRenderingRules(e4) {
      const { raster: t6, mosaicRule: i11, rasterFunction: r4 } = this;
      r4 && "rasterFunction" in e4 && null == e4.rasterFunction && (e4.rasterFunction = r4), i11 && null == e4.mosaicRule && (e4.mosaicRule = i11), t6 && null == e4.raster && (e4.raster = t6);
    }
    _readCapabilities(e4) {
      var _a;
      const t6 = e4.capabilities ? e4.capabilities.toLowerCase().split(",").map((e5) => e5.trim()) : ["image", "catalog"], { currentVersion: i11, advancedQueryCapabilities: r4, maxRecordCount: s10 } = e4, n14 = t6.includes("image"), a14 = "esriImageServiceDataTypeElevation" === e4.serviceDataType, o3 = !(!e4.spatialReference && !((_a = e4.extent) == null ? void 0 : _a.spatialReference)), l14 = t6.includes("edit"), u6 = t6.includes("mensuration") && o3, p21 = null == e4.mensurationCapabilities ? [] : e4.mensurationCapabilities.toLowerCase().split(",").map((e5) => e5.trim()), c24 = u6 && p21.includes("basic"), m14 = this._isMosaicDataset(e4) && t6.includes("catalog"), d10 = t6.includes("download");
      return { data: { supportsAttachment: false }, operations: { supportsComputeHistograms: n14, supportsExportImage: n14, supportsIdentify: n14, supportsImageToMap: i11 >= 11.2 && m14, supportsImageToMapMultiray: i11 >= 11.2 && m14, supportsMapToImage: i11 >= 11.2 && m14, supportsFindImages: i11 >= 11.2 && m14, supportsGetImageUrl: i11 >= 11.3 && d10, supportsMeasure: u6, supportsMeasureFromImage: i11 >= 11.2, supportsDownload: d10, supportsQuery: m14 && e4.fields && e4.fields.length > 0, supportsGetSamples: i11 >= 10.2 && n14, supportsProject: i11 >= 10.3 && n14, supportsComputeStatisticsHistograms: i11 >= 10.4 && n14, supportsQueryBoundary: i11 >= 10.6 && n14, supportsCalculateVolume: i11 >= 10.7 && a14, supportsComputePixelLocation: i11 >= 10.7 && m14, supportsComputeAngles: i11 >= 10.91, supportsQueryGPSInfo: i11 >= 11.2 && m14, supportsAdd: l14, supportsDelete: l14, supportsEditing: l14, supportsUpdate: l14, supportsCalculate: false, supportsTruncate: false, supportsValidateSql: false, supportsChangeTracking: false, supportsQueryAttachments: false, supportsResizeAttachments: false, supportsSync: false, supportsExceedsLimitStatistics: false, supportsQueryAnalytics: false, supportsQueryBins: false, supportsQueryTopFeatures: false, supportsAsyncConvert3D: false }, query: { maxRecordCount: s10, maxRecordCountFactor: void 0, supportsStatistics: !!(r4 == null ? void 0 : r4.supportsStatistics), supportsOrderBy: !!(r4 == null ? void 0 : r4.supportsOrderBy), supportsDistinct: !!(r4 == null ? void 0 : r4.supportsDistinct), supportsPagination: !!(r4 == null ? void 0 : r4.supportsPagination), supportsStandardizedQueriesOnly: !!(r4 == null ? void 0 : r4.useStandardizedQueries), supportsPercentileStatistics: !!(r4 == null ? void 0 : r4.supportsPercentileStatistics), supportsCentroid: !!(r4 == null ? void 0 : r4.supportsReturningGeometryCentroid), supportsDistance: !!(r4 == null ? void 0 : r4.supportsQueryWithDistance), supportsExtent: !!(r4 == null ? void 0 : r4.supportsReturningQueryExtent), supportsGeometryProperties: !!(r4 == null ? void 0 : r4.supportsReturningGeometryProperties), supportsHavingClause: !!(r4 == null ? void 0 : r4.supportsHavingClause), supportsQuantization: false, supportsQuantizationEditMode: false, supportsQueryGeometry: false, supportsResultType: false, supportsMaxRecordCountFactor: false, supportsSqlExpression: false, supportsTopFeaturesQuery: false, supportsQueryByAnonymous: false, supportsQueryByOthers: false, supportsHistoricMoment: false, supportsFormatPBF: false, supportsDisjointSpatialRelationship: false, supportsCacheHint: false, supportsSpatialAggregationStatistics: false, supportedSpatialAggregationStatistics: { envelope: false, centroid: false, convexHull: false }, supportsDefaultSpatialReference: !!(r4 == null ? void 0 : r4.supportsDefaultSR), supportsFullTextSearch: false, supportsCompactGeometry: false, standardMaxRecordCount: void 0, tileMaxRecordCount: void 0 }, mensuration: { supportsDistanceAndAngle: c24, supportsAreaAndPerimeter: c24, supportsPointOrCentroid: c24, supportsHeightFromBaseAndTop: u6 && p21.includes("base-top height"), supportsHeightFromBaseAndTopShadow: u6 && p21.includes("base-top shadow height"), supportsHeightFromTopAndTopShadow: u6 && p21.includes("top-top shadow height"), supports3D: u6 && p21.includes("3d") } };
    }
  };
  function Me2(e4) {
    return (e4 == null ? void 0 : e4.path) ?? "";
  }
  return r([m({ clonable: false })], f10.prototype, "_functionRasterInfos", void 0), r([m({ clonable: false })], f10.prototype, "_rasterJobHandler", void 0), r([m({ clonable: false })], f10.prototype, "_cachedRendererJson", void 0), r([m({ readOnly: true })], f10.prototype, "_serviceSupportsMosaicRule", void 0), r([o("_serviceSupportsMosaicRule", ["currentVersion", "fields"])], f10.prototype, "readServiceSupportsMosaicRule", null), r([m({ readOnly: true })], f10.prototype, "_rasterAttributeTableFieldPrefix", void 0), r([m({ readOnly: true })], f10.prototype, "_rasterFunctionNamesIndex", null), r([m()], f10.prototype, "adjustAspectRatio", void 0), r([m({ type: [x], json: { write: true } })], f10.prototype, "bandIds", void 0), r([o("bandIds")], f10.prototype, "readBandIds", null), r([m({ readOnly: true, json: { read: false } })], f10.prototype, "capabilities", void 0), r([o("service", "capabilities", ["capabilities", "currentVersion", "serviceDataType"])], f10.prototype, "readCapabilities", null), r([m({ type: Number })], f10.prototype, "compressionQuality", void 0), r([r2("compressionQuality")], f10.prototype, "writeCompressionQuality", null), r([m({ type: Number })], f10.prototype, "compressionTolerance", void 0), r([r2("compressionTolerance")], f10.prototype, "writeCompressionTolerance", null), r([m({ json: { read: { source: "copyrightText" } } })], f10.prototype, "copyright", void 0), r([m({ readOnly: true, dependsOn: ["_serviceSupportsMosaicRule"] })], f10.prototype, "defaultMosaicRule", void 0), r([o("defaultMosaicRule", ["defaultMosaicMethod"])], f10.prototype, "readDefaultMosaicRule", null), r([m({ type: String, json: { name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], f10.prototype, "definitionExpression", void 0), r([m({ readOnly: true, constructOnly: true })], f10.prototype, "exportImageServiceParameters", void 0), r([m()], f10.prototype, "rasterInfo", void 0), r([m({ readOnly: true, type: [y] })], f10.prototype, "fields", void 0), r([m({ readOnly: true })], f10.prototype, "fieldsIndex", null), r([m({ type: ["png", "png8", "png24", "png32", "jpg", "bmp", "gif", "jpgpng", "lerc", "tiff", "bip", "bsq"], json: { write: true } })], f10.prototype, "format", null), r([o("service", "format", ["serviceDataType"])], f10.prototype, "readFormat", null), r([m({ type: w })], f10.prototype, "fullExtent", void 0), r([m({ readOnly: true })], f10.prototype, "hasMultidimensions", void 0), r([m({ json: { read: { source: "maxImageHeight" } } })], f10.prototype, "imageMaxHeight", void 0), r([m({ json: { read: { source: "maxImageWidth" } } })], f10.prototype, "imageMaxWidth", void 0), r([m({ type: String, json: { type: a5.jsonValues, read: a5.read, write: a5.write } })], f10.prototype, "interpolation", void 0), r([m()], f10.prototype, "minScale", void 0), r([o("service", "minScale")], f10.prototype, "readMinScale", null), r([m()], f10.prototype, "maxScale", void 0), r([o("service", "maxScale")], f10.prototype, "readMaxScale", null), r([m({ type: f6 })], f10.prototype, "mosaicRule", null), r([o("mosaicRule", ["mosaicRule", "defaultMosaicMethod"])], f10.prototype, "readMosaicRule", null), r([r2("mosaicRule")], f10.prototype, "writeMosaicRule", null), r([m()], f10.prototype, "multidimensionalInfo", void 0), r([m({ type: c4, json: { write: true } })], f10.prototype, "multidimensionalSubset", void 0), r([m({ json: { type: x } })], f10.prototype, "noData", void 0), r([r2("noData")], f10.prototype, "writeNoData", null), r([m({ type: String, json: { type: i4.jsonValues, read: i4.read, write: i4.write } })], f10.prototype, "noDataInterpretation", void 0), r([m({ type: String, readOnly: true, json: { read: { source: ["fields"] } } })], f10.prototype, "objectIdField", void 0), r([o("objectIdField")], f10.prototype, "readObjectIdField", null), r([m({ readOnly: true })], f10.prototype, "geometryType", void 0), r([m({})], f10.prototype, "typeIdField", void 0), r([m({})], f10.prototype, "types", void 0), r([m({ readOnly: true })], f10.prototype, "parsedUrl", null), r([m({ type: Function })], f10.prototype, "pixelFilter", void 0), r([m()], f10.prototype, "raster", void 0), r([m({ readOnly: true })], f10.prototype, "sourceType", void 0), r([o("sourceType", ["serviceSourceType", "fields"])], f10.prototype, "readSourceType", null), r([m()], f10.prototype, "viewId", void 0), r([m()], f10.prototype, "renderer", null), r([m({ types: l6, json: { name: "layerDefinition.drawingInfo.renderer", origins: { "web-scene": { types: d5, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e4) => ({ enabled: e4 && "vector-field" !== e4.type && "flow" !== e4.type }) } } } } })], f10.prototype, "internalRenderer", null), r([o("internalRenderer")], f10.prototype, "readRenderer", null), r([r2("internalRenderer")], f10.prototype, "writeRenderer", null), r([m({ clonable: false })], f10.prototype, "symbolizer", void 0), r([m(f5)], f10.prototype, "opacity", void 0), r([m({ readOnly: true })], f10.prototype, "rasterFields", null), r([m({ constructOnly: true })], f10.prototype, "rasterFunctionInfos", void 0), r([m({ type: N, json: { name: "renderingRule" } })], f10.prototype, "rasterFunction", null), r([o("rasterFunction", ["renderingRule", "rasterFunctionInfos"])], f10.prototype, "readRasterFunction", null), r([m({ readOnly: true })], f10.prototype, "serviceDataType", void 0), r([m({ readOnly: true, type: g })], f10.prototype, "spatialReference", void 0), r([o("spatialReference", ["spatialReference", "extent"])], f10.prototype, "readSpatialReference", null), r([m({ json: { type: n6.jsonValues } })], f10.prototype, "pixelType", void 0), r([o("pixelType")], f10.prototype, "readPixelType", null), r([r2("pixelType")], f10.prototype, "writePixelType", null), r([m({ constructOnly: true, type: m2 })], f10.prototype, "serviceRasterInfo", void 0), r([m()], f10.prototype, "sourceJSON", void 0), r([m(y2)], f10.prototype, "url", void 0), r([m({ readOnly: true })], f10.prototype, "version", void 0), r([o("version", ["currentVersion", "fields", "timeInfo"])], f10.prototype, "readVersion", null), f10 = r([a4("esri.layers.mixins.ArcGISImageService")], f10), f10;
};

// node_modules/@arcgis/core/layers/ImageryLayer.js
var x3 = class extends l(l3(t(b3(j2(o2(Me(f3(e(l2(S(i2(f8)))))))))))) {
  constructor(...e4) {
    super(...e4), this.isReference = null, this.operationalLayerType = "ArcGISImageServiceLayer", this.popupEnabled = true, this.popupTemplate = null, this.type = "imagery", this._debouncedSaveOperations = k(async (e5, r4, t6) => {
      const { save: s10, saveAs: i11 } = await import("./imageryUtils-OKAHYXKJ.js");
      switch (e5) {
        case A.SAVE:
          return s10(this, r4);
        case A.SAVE_AS:
          return i11(this, t6, r4);
      }
    });
  }
  normalizeCtorArgs(e4, r4) {
    return "string" == typeof e4 ? { url: e4, ...r4 } : e4;
  }
  load(e4) {
    const r4 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Image Service"] }, e4).catch(a2).then(() => this._fetchService(r4))), Promise.resolve(this);
  }
  get legendEnabled() {
    return !this._isPreviewLayer && (this._get("legendEnabled") ?? true);
  }
  set legendEnabled(e4) {
    this._set("legendEnabled", e4);
  }
  get listMode() {
    return this._isPreviewLayer ? "hide" : this._get("listMode");
  }
  set listMode(e4) {
    this._set("listMode", e4);
  }
  writeOperationalLayerType(e4, r4, t6) {
    var _a;
    const s10 = "vector-field" === ((_a = this.renderer) == null ? void 0 : _a.type);
    r4[t6] = s10 ? "ArcGISImageServiceVectorLayer" : "ArcGISImageServiceLayer";
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get _isPreviewLayer() {
    var _a;
    return !(!this.raster || !((_a = this.url) == null ? void 0 : _a.toLowerCase().includes("/rasterrendering/imageserver")));
  }
  createPopupTemplate(e4) {
    var _a;
    const r4 = this.rasterFields, t6 = this.title, s10 = /* @__PURE__ */ new Set();
    let i11 = false, o3 = false;
    this.capabilities && (i11 = this.capabilities.operations.supportsQuery && this.fields && this.fields.length > 0, o3 = "esriImageServiceDataTypeVector-UV" === this.serviceDataType || "esriImageServiceDataTypeVector-MagDir" === this.serviceDataType);
    const a14 = /* @__PURE__ */ new Set();
    i11 && a14.add("raster.itempixelvalue");
    for (const n14 of r4) {
      const e5 = n14.name.toLowerCase();
      a14.has(e5) || e5.includes("raster.servicepixelvalue.") || s10.add(n14.name);
    }
    o3 && s10.add("raster.magnitude").add("raster.direction");
    const p21 = p3({ fields: r4, title: t6 }, { ...e4, visibleFieldNames: s10 });
    return (p21 == null ? void 0 : p21.fieldInfos) && ((_a = this.rasterInfo) == null ? void 0 : _a.pixelType.startsWith("f")) && p21.fieldInfos.forEach(({ format: e5, fieldName: r5 }) => {
      e5 && r5 && /^raster\.(item|service)pixelvalue/i.test(r5) && (e5.places = 2);
    }), p21;
  }
  queryFeatures(e4, r4) {
    return this.queryRasters(e4, r4).then((e5) => {
      if (e5 == null ? void 0 : e5.features) for (const r5 of e5.features) r5.layer = r5.sourceLayer = this;
      return e5;
    });
  }
  queryFeatureCount(e4, r4) {
    return this.queryRasterCount(e4, r4);
  }
  redraw() {
    this.emit("redraw");
  }
  async save(e4) {
    return this._debouncedSaveOperations(A.SAVE, e4);
  }
  async saveAs(e4, r4) {
    return this._debouncedSaveOperations(A.SAVE_AS, r4, e4);
  }
  serviceSupportsSpatialReference(e4) {
    return t3(this, e4);
  }
  write(e4, r4) {
    if (!this._isPreviewLayer) return super.write(e4, r4);
    if (r4 == null ? void 0 : r4.messages) {
      const e5 = `${r4.origin}/${r4.layerContainerType || "operational-layers"}`;
      r4.messages.push(new s("layer:unsupported", `Imagery preview layer (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e5}'`, { layer: this }));
    }
    return null;
  }
};
r([m(d4)], x3.prototype, "legendEnabled", null), r([m({ type: ["show", "hide"] })], x3.prototype, "listMode", null), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], x3.prototype, "isReference", void 0), r([m({ type: ["ArcGISImageServiceLayer"], json: { origins: { "web-map": { type: ["ArcGISImageServiceLayer", "ArcGISImageServiceVectorLayer"], read: false, write: { target: "layerType", ignoreOrigin: true } } } } })], x3.prototype, "operationalLayerType", void 0), r([r2("web-map", "operationalLayerType")], x3.prototype, "writeOperationalLayerType", null), r([m(l5)], x3.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], x3.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], x3.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, json: { read: false } })], x3.prototype, "type", void 0), r([m({ readOnly: true })], x3.prototype, "_isPreviewLayer", null), x3 = r([a4("esri.layers.ImageryLayer")], x3);
var P3 = x3;
export {
  P3 as default
};
//# sourceMappingURL=ImageryLayer-K62BCC2X.js.map
