import {
  j as j3,
  m as m4,
  p as p4
} from "./chunk-KJHFQUQ3.js";
import "./chunk-QLTGZ6EP.js";
import {
  p as p3
} from "./chunk-4CLN3LZB.js";
import {
  e as e2,
  t as t2
} from "./chunk-NW7VXBHZ.js";
import {
  o as o4
} from "./chunk-ENHHZ2WV.js";
import "./chunk-P4TUSPKE.js";
import {
  A
} from "./chunk-WH2FR6UE.js";
import {
  j as j2
} from "./chunk-RG7AMCT5.js";
import {
  l
} from "./chunk-SM2VXWMT.js";
import "./chunk-WYO25WZZ.js";
import "./chunk-OC7D2HR4.js";
import {
  t
} from "./chunk-IGMG7ERK.js";
import {
  b
} from "./chunk-V47ZBW5W.js";
import "./chunk-HKYICNT2.js";
import {
  S as S2
} from "./chunk-VGUQMPM6.js";
import "./chunk-4ISVH4NS.js";
import "./chunk-NIWINVGG.js";
import "./chunk-DOENTAA7.js";
import "./chunk-CGSFKZP2.js";
import {
  p as p2
} from "./chunk-WC6QRPBL.js";
import {
  s as s5
} from "./chunk-D6FJTDNK.js";
import "./chunk-3GQ4PJDJ.js";
import "./chunk-QEJMJI2R.js";
import {
  n as n6,
  r as r3
} from "./chunk-ECMDQ4LS.js";
import {
  I,
  _ as _2,
  o as o5
} from "./chunk-LP6TMAPE.js";
import "./chunk-RENLZYKC.js";
import {
  f as f2
} from "./chunk-QMGMKWTA.js";
import {
  i
} from "./chunk-2IGXKE5P.js";
import "./chunk-ZICJB3ML.js";
import "./chunk-TA32QX7Z.js";
import {
  l as l2
} from "./chunk-NYLBGE62.js";
import {
  K,
  N,
  V as V3
} from "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import {
  n as n4
} from "./chunk-VEUN2EF3.js";
import {
  d
} from "./chunk-W6D3ECTZ.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import {
  n as n5
} from "./chunk-SEUZ3J6J.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import {
  c as c3
} from "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import {
  v2 as v
} from "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import {
  o as o3
} from "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import {
  u as u2
} from "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import {
  V as V2
} from "./chunk-RCLWOQNR.js";
import {
  o
} from "./chunk-DOTSJZHK.js";
import "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import "./chunk-SEG3PRUR.js";
import {
  m as m2
} from "./chunk-B6VE32RA.js";
import {
  U as U2,
  m as m3,
  p,
  y
} from "./chunk-AIYFWM42.js";
import {
  n as n3
} from "./chunk-2M53HYNY.js";
import {
  M,
  c as c2
} from "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  j2 as j,
  w,
  x
} from "./chunk-FG3XOAFD.js";
import {
  o as o2
} from "./chunk-GN5RE63N.js";
import {
  g,
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  s3 as s4
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import {
  s as s3
} from "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  S,
  T,
  V,
  Y,
  Z,
  _,
  tt,
  ut
} from "./chunk-YFGQMO6E.js";
import {
  f,
  u2 as u
} from "./chunk-HAF6QJ32.js";
import {
  e,
  m,
  n2
} from "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  c,
  k,
  s as s2
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/GeoreferenceBase.js
var c4 = class extends l2 {
  projectOrWarn(e3, r4) {
    if (null == e3) return e3;
    const { geometry: t3, pending: c5 } = V3(e3, r4);
    return c5 ? null : c5 || t3 ? t3 : (n.getLogger(this).warn("geometry could not be projected to the spatial reference", { georeference: this, geometry: e3, sourceSpatialReference: e3.spatialReference, targetSpatialReference: r4 }), null);
  }
};
c4 = r([a("esri.layers.support.GeoreferenceBase")], c4);
var a2 = c4;

// node_modules/@arcgis/core/layers/support/ControlPointsGeoreference.js
var S3 = e2();
var N2 = n6();
var T2 = class extends f {
};
r([m({ type: Number, json: { write: true } })], T2.prototype, "x", void 0), r([m({ type: Number, json: { write: true } })], T2.prototype, "y", void 0), T2 = r([a("esri.layers.support.ControlPointsGeoreference.ControlPointJSONType")], T2);
var _3 = class extends l2 {
  constructor() {
    super(...arguments), this.sourcePoint = null, this.mapPoint = null;
  }
};
r([m()], _3.prototype, "sourcePoint", void 0), r([m({ type: j })], _3.prototype, "mapPoint", void 0), _3 = r([a("esri.layers.support.ControlPointsGeoreference.ControlPoint")], _3);
var O = class extends u(a2) {
  constructor(t3) {
    super(t3), this.controlPoints = null, this.height = 0, this.type = "control-points", this.width = 0;
  }
  readControlPoints(t3, o6) {
    const e3 = g.fromJSON(o6.spatialReference), r4 = t2(...o6.coefficients, 1);
    return t3.map((t4) => (o5(N2, t4.x, t4.y), p4(N2, N2, r4), { sourcePoint: t4, mapPoint: new j({ x: N2[0], y: N2[1], spatialReference: e3 }) }));
  }
  writeControlPoints(t3, o6, r4, n7) {
    if (null != this.transform) null != t3 && M2(t3[0]) && (o6.controlPoints = t3.map((t4) => {
      const o7 = t4.sourcePoint;
      return { x: o7.x, y: o7.y };
    }), o6.spatialReference = t3[0].mapPoint.spatialReference.toJSON(), o6.coefficients = this.transform.slice(0, 8));
    else {
      const t4 = new s("web-document-write:invalid-georeference", "Invalid 'controlPoints', 'width', 'height' configuration. Make sure the parent media element is loaded i.e. the ImageElement or VideoElement set as 'MediaLayer.source'.", { layer: n7 == null ? void 0 : n7.layer, georeference: this });
      (n7 == null ? void 0 : n7.messages) ? n7.messages.push(t4) : n.getLogger(this).error(t4.name, t4.message);
    }
  }
  get coords() {
    if (null == this.controlPoints) return null;
    const t3 = this._updateTransform(S3);
    if (null == t3 || !M2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return Q(t3, this.width, this.height, o6);
  }
  set coords(t3) {
    if (null == this.controlPoints || !M2(this.controlPoints[0])) return;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, o6))) return;
    const { width: e3, height: r4 } = this, { rings: [[n7, i2, l3, a3]] } = t3, p6 = { sourcePoint: c3(0, r4), mapPoint: new j({ x: n7[0], y: n7[1], spatialReference: o6 }) }, u7 = { sourcePoint: c3(0, 0), mapPoint: new j({ x: i2[0], y: i2[1], spatialReference: o6 }) }, m5 = { sourcePoint: c3(e3, 0), mapPoint: new j({ x: l3[0], y: l3[1], spatialReference: o6 }) }, f4 = { sourcePoint: c3(e3, r4), mapPoint: new j({ x: a3[0], y: a3[1], spatialReference: o6 }) };
    M2(p6) && M2(u7) && M2(m5) && M2(f4) && (W(S3, p6, u7, m5, f4), this.controlPoints = this.controlPoints.map(({ sourcePoint: t4 }) => (o5(N2, t4.x, t4.y), p4(N2, N2, S3), { sourcePoint: t4, mapPoint: new j({ x: N2[0], y: N2[1], spatialReference: o6 }) })));
  }
  get inverseTransform() {
    return null == this.transform ? null : s5(e2(), this.transform);
  }
  get transform() {
    return this._updateTransform();
  }
  toMap(t3) {
    if (null == t3 || null == this.transform || null == this.controlPoints || !M2(this.controlPoints[0])) return null;
    o5(N2, t3.x, t3.y);
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return p4(N2, N2, this.transform), new j({ x: N2[0], y: N2[1], spatialReference: o6 });
  }
  toSource(t3) {
    if (null == t3 || null == this.inverseTransform || null == this.controlPoints || !M2(this.controlPoints[0])) return null;
    const o6 = this.controlPoints[0].mapPoint.spatialReference;
    return t3 = t3.normalize(), null == (t3 = V3(t3, o6).geometry) ? null : (o5(N2, t3.x, t3.y), p4(N2, N2, this.inverseTransform), c3(N2[0], N2[1]));
  }
  toSourceNormalized(t3) {
    const o6 = this.toSource(t3);
    return null != o6 && (o6.x /= this.width, o6.y /= this.height), o6;
  }
  _updateTransform(t3) {
    const { controlPoints: o6, width: e3, height: r4 } = this;
    if (!(null != o6 && e3 > 0 && r4 > 0)) return null;
    const [n7, i2, s6, l3] = o6;
    if (!M2(n7)) return null;
    const c5 = n7.mapPoint.spatialReference, a3 = this._projectControlPoint(i2, c5), p6 = this._projectControlPoint(s6, c5), u7 = this._projectControlPoint(l3, c5);
    if (!a3.valid || !p6.valid || !u7.valid) return null;
    if (!M2(a3.controlPoint)) return null;
    null == t3 && (t3 = e2());
    let m5 = null;
    return m5 = M2(p6.controlPoint) && M2(u7.controlPoint) ? W(t3, n7, a3.controlPoint, p6.controlPoint, u7.controlPoint) : M2(p6.controlPoint) ? B(t3, n7, a3.controlPoint, p6.controlPoint) : q(t3, n7, a3.controlPoint), m5.every((t4) => 0 === t4) ? null : m5;
  }
  _projectControlPoint(t3, o6) {
    if (!M2(t3)) return { valid: true, controlPoint: t3 };
    const { sourcePoint: e3, mapPoint: r4 } = t3, { geometry: n7, pending: s6 } = V3(r4, o6);
    return s6 ? { valid: false, controlPoint: null } : s6 || n7 ? { valid: true, controlPoint: { sourcePoint: e3, mapPoint: n7 } } : (n.getLogger(this).warn("map point could not be projected to the spatial reference", { georeference: this, controlPoint: t3, sourceSpatialReference: r4.spatialReference, targetSpatialReference: o6 }), { valid: false, controlPoint: null });
  }
};
function M2(t3) {
  return null != (t3 == null ? void 0 : t3.sourcePoint) && null != t3.mapPoint;
}
r([m({ type: [_3], json: { write: { allowNull: false, isRequired: true, target: { controlPoints: { type: [T2] }, coefficients: { type: [Number] }, spatialReference: { type: g } } } } })], O.prototype, "controlPoints", void 0), r([o2("controlPoints")], O.prototype, "readControlPoints", null), r([r2("controlPoints")], O.prototype, "writeControlPoints", null), r([m({ clonable: false })], O.prototype, "coords", null), r([m({ type: Number, nonNullable: true, json: { write: true } })], O.prototype, "height", void 0), r([m({ readOnly: true })], O.prototype, "inverseTransform", null), r([m({ readOnly: true })], O.prototype, "transform", null), r([m({ type: Number, nonNullable: true, json: { write: true } })], O.prototype, "width", void 0), O = r([a("esri.layers.support.ControlPointsGeoreference")], O);
var G = n6();
var I2 = n6();
var L = n6();
var J = n6();
var E = n6();
var k2 = n6();
var z = n6();
var A2 = n6();
var U3 = Math.PI / 2;
function V4(t3, o6, e3) {
  o5(t3, e3.sourcePoint.x, e3.sourcePoint.y), o5(o6, e3.mapPoint.x, e3.mapPoint.y);
}
function q(t3, o6, e3) {
  return V4(G, E, o6), V4(I2, k2, e3), I(L, I2, G, U3), I(J, G, I2, U3), I(z, k2, E, -U3), I(A2, E, k2, -U3), K2(t3, G, I2, L, J, E, k2, z, A2);
}
function B(t3, o6, e3, r4) {
  return V4(G, E, o6), V4(I2, k2, e3), V4(L, z, r4), _2(J, G, I2, 0.5), I(J, L, J, Math.PI), _2(A2, E, k2, 0.5), I(A2, z, A2, Math.PI), K2(t3, G, I2, L, J, E, k2, z, A2);
}
function W(t3, o6, e3, r4, n7) {
  return V4(G, E, o6), V4(I2, k2, e3), V4(L, z, r4), V4(J, A2, n7), K2(t3, G, I2, L, J, E, k2, z, A2);
}
var D = new Array(8).fill(0);
var F = new Array(8).fill(0);
function H(t3, o6, e3, r4, n7) {
  return t3[0] = o6[0], t3[1] = o6[1], t3[2] = e3[0], t3[3] = e3[1], t3[4] = r4[0], t3[5] = r4[1], t3[6] = n7[0], t3[7] = n7[1], t3;
}
function K2(t3, o6, e3, r4, n7, i2, s6, c5, a3) {
  return j3(t3, H(D, o6, e3, r4, n7), H(F, i2, s6, c5, a3));
}
function Q(t3, o6, e3, r4) {
  const n7 = r3(0, e3), i2 = r3(0, 0), l3 = r3(o6, 0), c5 = r3(o6, e3);
  return p4(n7, n7, t3), p4(i2, i2, t3), p4(l3, l3, t3), p4(c5, c5, t3), new v({ rings: [[n7, i2, l3, c5, n7]], spatialReference: r4 });
}
var X = O;

// node_modules/@arcgis/core/layers/support/CornersGeoreference.js
var u3 = n6();
var y2 = class extends a2 {
  constructor(t3) {
    super(t3), this.bottomLeft = null, this.bottomRight = null, this.topLeft = null, this.topRight = null, this.type = "corners";
  }
  get coords() {
    let { topLeft: t3, topRight: o6, bottomLeft: e3, bottomRight: r4 } = this;
    if (null == t3 || null == o6 || null == e3 || null == r4) return null;
    const s6 = t3.spatialReference;
    return o6 = this.projectOrWarn(o6, s6), e3 = this.projectOrWarn(e3, s6), r4 = this.projectOrWarn(r4, s6), null == o6 || null == e3 || null == r4 ? null : new v({ rings: [[[e3.x, e3.y], [t3.x, t3.y], [o6.x, o6.y], [r4.x, r4.y], [e3.x, e3.y]]], spatialReference: s6 });
  }
  set coords(t3) {
    const { topLeft: o6 } = this;
    if (null == o6) return;
    const e3 = o6.spatialReference;
    if (null == (t3 = this.projectOrWarn(t3, e3))) return;
    const { rings: [[r4, s6, i2, l3]] } = t3;
    this.bottomLeft = new j({ x: r4[0], y: r4[1], spatialReference: e3 }), this.topLeft = new j({ x: s6[0], y: s6[1], spatialReference: e3 }), this.topRight = new j({ x: i2[0], y: i2[1], spatialReference: e3 }), this.bottomRight = new j({ x: l3[0], y: l3[1], spatialReference: e3 });
  }
  toSourceNormalized(t3) {
    const { topLeft: s6, topRight: i2, bottomRight: p6, bottomLeft: c5 } = this;
    if (null == t3 || null == s6 || null == i2 || null == p6 || null == c5) return null;
    const m5 = s6.spatialReference;
    t3 = t3.normalize();
    const f4 = V3(t3, m5).geometry;
    if (null == f4) return null;
    o5(u3, f4.x, f4.y);
    const y3 = j3(e2(), [s6.x, s6.y, c5.x, c5.y, i2.x, i2.y, p6.x, p6.y], [0, 0, 0, 1, 1, 0, 1, 1]);
    return p4(u3, u3, y3), c3(u3[0], u3[1]);
  }
};
r([m({ clonable: false })], y2.prototype, "coords", null), r([m({ type: j })], y2.prototype, "bottomLeft", void 0), r([m({ type: j })], y2.prototype, "bottomRight", void 0), r([m({ type: j })], y2.prototype, "topLeft", void 0), r([m({ type: j })], y2.prototype, "topRight", void 0), y2 = r([a("esri.layers.support.CornersGeoreference")], y2);
var h = y2;

// node_modules/@arcgis/core/layers/support/ExtentAndRotationGeoreference.js
var p5 = class extends a2 {
  constructor(t3) {
    super(t3), this.extent = null, this.rotation = 0, this.type = "extent-and-rotation";
  }
  get coords() {
    if (null == this.extent) return null;
    const { xmin: t3, ymin: e3, xmax: r4, ymax: o6, spatialReference: n7 } = this.extent;
    let s6;
    if (this.rotation) {
      const { x: n8, y: i2 } = this.extent.center, a3 = x2(n8, i2, this.rotation);
      s6 = [a3(t3, e3), a3(t3, o6), a3(r4, o6), a3(r4, e3)], s6.push(s6[0]);
    } else s6 = [[t3, e3], [t3, o6], [r4, o6], [r4, e3], [t3, e3]];
    return new v({ rings: [s6], spatialReference: n7 });
  }
  set coords(t3) {
    if (null == t3 || null == this.extent) return;
    const r4 = this.extent.spatialReference;
    if (t3 = this.projectOrWarn(t3, r4), null == (t3 == null ? void 0 : t3.extent)) return;
    const { rings: [[o6, n7, s6]], extent: { center: { x: i2, y: c5 } } } = t3, m5 = M(Math.PI / 2 - Math.atan2(n7[1] - o6[1], n7[0] - o6[0])), l3 = x2(i2, c5, -m5), [p6, u7] = l3(o6[0], o6[1]), [f4, h3] = l3(s6[0], s6[1]);
    this.extent = new w({ xmin: p6, ymin: u7, xmax: f4, ymax: h3, spatialReference: r4 }), this.rotation = m5;
  }
  toSourceNormalized(t3) {
    const { extent: e3, rotation: n7 } = this;
    if (null == t3 || null == e3) return null;
    const { xmin: s6, ymin: i2, xmax: a3, ymax: c5, center: l3, spatialReference: p6 } = e3;
    t3 = t3.normalize();
    const u7 = V3(t3, p6).geometry;
    if (null == u7) return null;
    let f4 = u7.x, h3 = u7.y;
    return n7 && ([f4, h3] = x2(l3.x, l3.y, -n7)(f4, h3)), c3(c2(f4, s6, a3, 0, 1), c2(h3, c5, i2, 0, 1));
  }
};
function x2(t3, e3, r4) {
  const o6 = u2(r4), n7 = Math.cos(o6), s6 = Math.sin(o6);
  return (r5, o7) => [n7 * (r5 - t3) + s6 * (o7 - e3) + t3, n7 * (o7 - e3) - s6 * (r5 - t3) + e3];
}
r([m({ clonable: false })], p5.prototype, "coords", null), r([m({ type: w })], p5.prototype, "extent", void 0), r([m({ type: Number })], p5.prototype, "rotation", void 0), p5 = r([a("esri.layers.support.ExtentAndRotationGeoreference")], p5);
var u4 = p5;

// node_modules/@arcgis/core/layers/support/mediaUtils.js
function u5(e3) {
  return "media" === (e3 == null ? void 0 : e3.type);
}
function P(e3, o6) {
  const r4 = n2(o6);
  return u5(e3) && !!e3.portalItem && null != r4 && r4 > e.PORTAL_ITEM;
}
function d3(t3, n7, o6) {
  var _a;
  if (!t3 || "control-points" === t3.type) return t3;
  const { coords: i2 } = t3;
  if (5 !== ((_a = i2 == null ? void 0 : i2.rings[0]) == null ? void 0 : _a.length)) return null;
  const [s6, a3, c5, l3] = i2.rings[0], { spatialReference: y3 } = i2;
  return new X({ controlPoints: [{ mapPoint: new j({ x: s6[0], y: s6[1], spatialReference: y3 }), sourcePoint: c3(0, o6) }, { mapPoint: new j({ x: a3[0], y: a3[1], spatialReference: y3 }), sourcePoint: c3(0, 0) }, { mapPoint: new j({ x: c5[0], y: c5[1], spatialReference: y3 }), sourcePoint: c3(n7, 0) }, { mapPoint: new j({ x: l3[0], y: l3[1], spatialReference: y3 }), sourcePoint: c3(n7, o6) }], width: n7, height: o6 });
}
function x3(e3, t3, n7) {
  return { enabled: !P(n7 == null ? void 0 : n7.layer, n7 == null ? void 0 : n7.origin), ignoreOrigin: true };
}
var w2 = { json: { name: "url", type: String, write: { overridePolicy: x3 } } };
var g2 = { readOnly: true, json: { read: false, write: { target: "mediaType", overridePolicy: x3 } } };
var h2 = { types: { key: "type", base: a2, typeMap: { "control-points": X, corners: h, "extent-and-rotation": u4 } }, json: { types: { key: "type", base: a2, typeMap: { "control-points": X } }, write: { overridePolicy: () => ({ enabled: true, ignoreOrigin: true }) } } };

// node_modules/@arcgis/core/layers/support/MediaElementBase.js
var u6 = class extends i(S2(m2)) {
  constructor(e3) {
    super(e3), this.georeference = null, this.opacity = 1;
  }
  readGeoreference(e3) {
    return X.fromJSON(e3);
  }
  writeGeoreference(e3, o6, t3, n7) {
    var _a;
    const i2 = (_a = n7 == null ? void 0 : n7.resources) == null ? void 0 : _a.pendingOperations, c5 = () => {
      var _a2;
      const i3 = d3(this.georeference, this.contentWidth, this.contentHeight);
      if (i3) {
        if ("control-points" !== e3.type && n.getLogger(this).warn(`only georeference of type 'control-points' may be persisted. The georeference of type '${e3.type}' has been automatically converted.`), 4 !== ((_a2 = i3.controlPoints) == null ? void 0 : _a2.length) && (n7 == null ? void 0 : n7.messages)) return void n7.messages.push(new s("property:unsupported", "only 'control-points' georeference with 4 control points may be persisted."));
        o6[t3] = i3.write({}, n7);
      }
    };
    if ("control-points" !== e3.type && !this.loaded && i2) return o6[t3] = {}, void i2.push(this.load().then(c5));
    c5();
  }
  get contentWidth() {
    return 0;
  }
  get contentHeight() {
    return 0;
  }
  toSource(e3) {
    const { georeference: r4, contentWidth: o6, contentHeight: t3 } = this;
    if (null == e3 || null == r4 || 0 === o6 || 0 === t3) return null;
    const s6 = r4.toSourceNormalized(e3);
    return null == s6 ? null : (s6.x *= o6, s6.y *= t3, s6);
  }
};
r([m(h2)], u6.prototype, "georeference", void 0), r([o2("georeference")], u6.prototype, "readGeoreference", null), r([r2("georeference")], u6.prototype, "writeGeoreference", null), r([m({ json: { read: false, write: false } })], u6.prototype, "opacity", void 0), u6 = r([a("esri.layers.support.MediaElementBase")], u6);
var d4 = u6;

// node_modules/@arcgis/core/layers/support/ImageElement.js
var w3 = class extends d4 {
  constructor(t3) {
    super(t3), this.animationOptions = null, this.content = null, this.image = null, this.type = "image", this.image = null;
  }
  load() {
    const t3 = this.image;
    if ("string" == typeof t3) {
      const e3 = p2(t3).then((t4) => {
        this._set("content", t4);
      });
      this.addResolvingPromise(e3);
    } else if (t3 instanceof HTMLImageElement) {
      const e3 = t3.decode().then(() => {
        this._set("content", t3);
      });
      this.addResolvingPromise(e3);
    } else t3 ? this._set("content", t3) : this.addResolvingPromise(Promise.reject(new s("image-element:invalid-image-type", "Invalid image type", { image: t3 })));
    return Promise.resolve(this);
  }
  get contentWidth() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalWidth : this.content.width;
  }
  get contentHeight() {
    return null == this.content ? 0 : this.content instanceof HTMLImageElement ? this.content.naturalHeight : this.content.height;
  }
  readImage(t3, e3, o6) {
    return p(e3.url, o6);
  }
  writeImage(t3, e3, o6, r4) {
    if (null == t3) return;
    const i2 = r4 == null ? void 0 : r4.portalItem, s6 = r4 == null ? void 0 : r4.resources;
    if (!i2 || !s6) return void ("string" == typeof t3 && (e3[o6] = m3(t3, r4)));
    const a3 = H2(t3) ? t3 : null;
    if (a3) {
      if (null == U2(a3)) return void (e3[o6] = a3);
      const t4 = m3(a3, { ...r4, verifyItemRelativeUrls: (r4 == null ? void 0 : r4.verifyItemRelativeUrls) ? { writtenUrls: r4.verifyItemRelativeUrls.writtenUrls, rootPath: void 0 } : void 0 }, y.NO);
      if (i2 && t4 && !Y(t4)) return s6.toKeep.push({ resource: i2.resourceFromPath(t4), compress: false }), void (e3[o6] = t4);
    }
    e3[o6] = "<pending>", s6.pendingOperations.push(U4(t3).then((t4) => {
      const r5 = M3(t4, i2);
      e3[o6] = r5.itemRelativeUrl, s6.toAdd.push({ resource: r5, content: { type: "blob", blob: t4 }, compress: false, finish: (t5) => {
        this.image = t5.url;
      } });
    }));
  }
};
r([m()], w3.prototype, "animationOptions", void 0), r([m({ readOnly: true })], w3.prototype, "content", void 0), r([m({ readOnly: true })], w3.prototype, "contentWidth", null), r([m({ readOnly: true })], w3.prototype, "contentHeight", null), r([m(w2)], w3.prototype, "image", void 0), r([o2("image", ["url"])], w3.prototype, "readImage", null), r([r2("image")], w3.prototype, "writeImage", null), r([m(g2)], w3.prototype, "type", void 0), w3 = r([a("esri.layers.support.ImageElement")], w3);
var E2 = w3;
function H2(t3) {
  return "string" == typeof t3 && !tt(t3) && !Z(t3);
}
async function U4(t3) {
  if ("string" == typeof t3) {
    if (tt(t3)) return ut(t3);
    return (await U(t3, { responseType: "blob" })).data;
  }
  return new Promise((e3) => L2(t3).toBlob(e3));
}
function L2(t3) {
  if (t3 instanceof HTMLCanvasElement) return t3;
  const e3 = t3 instanceof HTMLImageElement ? t3.naturalWidth : t3.width, o6 = t3 instanceof HTMLImageElement ? t3.naturalHeight : t3.height, r4 = document.createElement("canvas"), n7 = r4.getContext("2d");
  return r4.width = e3, r4.height = o6, t3 instanceof HTMLImageElement ? n7.drawImage(t3, 0, 0, t3.width, t3.height) : t3 instanceof ImageData && n7.putImageData(t3, 0, 0), r4;
}
function M3(t3, e3) {
  const o6 = n4(), r4 = `${V("media", o6)}.${p3({ type: "blob", blob: t3 })}`;
  return e3.resourceFromPath(r4);
}

// node_modules/@arcgis/core/layers/support/VideoElement.js
var f3 = class extends d4 {
  constructor(e3) {
    super(e3), this.autoplay = true, this.content = null, this.type = "video";
  }
  load() {
    const e3 = this.video;
    return "string" == typeof e3 ? this.addResolvingPromise(this._preProcessVideoUrl(e3).then((e4) => {
      const o6 = document.createElement("video");
      return o6.src = e4, o6.crossOrigin = "anonymous", o6.autoplay = true, o6.muted = true, o6.loop = true, o6.playsInline = true, this._loadVideo(o6).then(() => {
        this._set("content", o6);
      });
    })) : e3 instanceof HTMLVideoElement ? this.addResolvingPromise(this._loadVideo(e3).then(() => {
      this._set("content", e3);
    })) : this.addResolvingPromise(Promise.reject(new s("video-element:invalid-video-type", "Invalid video type", { video: e3 }))), Promise.resolve(this);
  }
  get contentWidth() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoWidth) ?? 0;
  }
  get contentHeight() {
    var _a;
    return ((_a = this.content) == null ? void 0 : _a.videoHeight) ?? 0;
  }
  set video(e3) {
    "not-loaded" === this.loadStatus ? this._set("video", e3) : n.getLogger(this).error("#video", "video cannot be changed after the element is loaded.");
  }
  writeVideo(e3, o6, s6, r4) {
    if (!e3) return void ((r4 == null ? void 0 : r4.messages) && r4.messages.push(new s("video-element:unsupported-video", "video source is missing")));
    const d5 = b2(e3) ? e3 : null;
    if (!d5) return void ((r4 == null ? void 0 : r4.messages) && r4.messages.push(new s("video-element:unsupported-video", "video source must be an absolute url")));
    !Y(d5) && (r4 == null ? void 0 : r4.blockedRelativeUrls) && r4.blockedRelativeUrls.push(d5);
    const a3 = _(d5);
    !U2(a3) ? o6[s6] = a3 : (r4 == null ? void 0 : r4.messages) && r4.messages.push(new s("video-element:unsupported-video", "video source cannot be an item resource"));
  }
  async _preProcessVideoUrl(e3) {
    if (T(e3)) return S(e3);
    try {
      return await U(e3, { method: "head" }), e3;
    } catch {
      return S(e3, true);
    }
  }
  _loadVideo(e3) {
    return new Promise((o6, t3) => {
      const r4 = c(e3, "canplay", () => {
        this.removeHandles("canplay"), this.autoplay ? e3.play().then(o6, t3) : o6();
      });
      this.addHandles(r4, "canplay"), "anonymous" !== e3.crossOrigin && (e3.crossOrigin = "anonymous", Z(e3.src) || (e3.src = e3.src));
    });
  }
};
r([m()], f3.prototype, "autoplay", void 0), r([m({ readOnly: true })], f3.prototype, "content", void 0), r([m({ readOnly: true })], f3.prototype, "contentWidth", null), r([m({ readOnly: true })], f3.prototype, "contentHeight", null), r([m(w2)], f3.prototype, "video", null), r([r2("video")], f3.prototype, "writeVideo", null), r([m(g2)], f3.prototype, "type", void 0), f3 = r([a("esri.layers.support.VideoElement")], f3);
var j4 = f3;
function b2(e3) {
  return "string" == typeof e3 && !tt(e3) && !Z(e3);
}

// node_modules/@arcgis/core/layers/support/LocalMediaElementSource.js
var w4 = { key: "type", defaultKeyValue: "image", base: d4, typeMap: { image: E2, video: j4 } };
var M4 = V2.ofType(w4);
var I3 = class extends m2.LoadableMixin(n3(o.EventedAccessor)) {
  constructor(e3) {
    super(e3), this._index = new o4(), this._elementViewsMap = /* @__PURE__ */ new Map(), this._elementsIndexes = /* @__PURE__ */ new Map(), this._elementsChangedHandler = (e4) => {
      for (const s6 of e4.removed) {
        const e5 = this._elementViewsMap.get(s6);
        this._elementViewsMap.delete(s6), this._index.delete(e5), this.removeHandles(e5), e5.destroy(), this.notifyChange("fullExtent");
      }
      const { spatialReference: t3 } = this;
      for (const s6 of e4.added) {
        if (this._elementViewsMap.get(s6)) continue;
        const e5 = new m4({ spatialReference: t3, element: s6 });
        this._elementViewsMap.set(s6, e5);
        const r4 = d(() => e5.coords, () => this._updateIndexForElement(e5, false));
        this._updateIndexForElement(e5, true), this.addHandles(r4, e5);
      }
      this._elementsIndexes.clear(), this.elements.forEach((e5, t4) => this._elementsIndexes.set(e5, t4)), this.emit("refresh");
    }, this.elements = new M4();
  }
  async load(e3) {
    if (s2(e3), !this.spatialReference) {
      const e4 = this.elements.find((e5) => {
        var _a;
        return null != ((_a = e5.georeference) == null ? void 0 : _a.coords);
      });
      this._set("spatialReference", e4 ? e4.georeference.coords.spatialReference : g.WGS84);
    }
    return this._elementsChangedHandler({ added: this.elements.items, removed: [] }), this.addHandles(this.elements.on("change", this._elementsChangedHandler)), this;
  }
  destroy() {
    this._index.clear(), this._elementViewsMap.clear(), this._elementsIndexes.clear();
  }
  set elements(e3) {
    this._set("elements", n5(e3, this._get("elements"), M4));
  }
  get fullExtent() {
    if ("not-loaded" === this.loadStatus) return null;
    const e3 = this._index.fullBounds;
    return null == e3 ? null : new w({ xmin: e3[0], ymin: e3[1], xmax: e3[2], ymax: e3[3], spatialReference: this.spatialReference });
  }
  set spatialReference(e3) {
    "not-loaded" === this.loadStatus ? this._set("spatialReference", e3) : n.getLogger(this).error("#spatialReference", "spatialReference cannot be changed after the source is loaded.");
  }
  async queryElements(e3, t3) {
    await this.load(), await N(e3.spatialReference, this.spatialReference, null, t3);
    const s6 = s4(e3.spatialReference, this.spatialReference) ? e3 : K(e3, this.spatialReference);
    if (!s6) return [];
    const r4 = s6.normalize(), o6 = [];
    for (const n7 of r4) this._index.forEachInBounds(o3(n7), ({ normalizedCoords: e4, element: t4 }) => {
      null != e4 && x(n7, e4) && o6.push(t4);
    });
    return o6.sort((e4, t4) => this._elementsIndexes.get(e4) - this._elementsIndexes.get(t4)), o6;
  }
  hasElement(e3) {
    return this.elements.includes(e3);
  }
  _updateIndexForElement(e3, t3) {
    const s6 = e3.normalizedBounds, r4 = this._index.has(e3), o6 = null != s6;
    this._index.delete(e3), o6 && this._index.set(e3, s6), this.notifyChange("fullExtent"), t3 || (r4 !== o6 ? this.emit("refresh") : this.emit("change", { element: e3.element }));
  }
};
r([m()], I3.prototype, "elements", null), r([m({ readOnly: true })], I3.prototype, "fullExtent", null), r([m()], I3.prototype, "spatialReference", null), I3 = r([a("esri.layers.support.LocalMediaElementSource")], I3);
var V5 = I3;

// node_modules/@arcgis/core/layers/MediaLayer.js
function b3(e3) {
  return "object" == typeof e3 && null != e3 && "type" in e3;
}
function L3(e3) {
  return b3(e3) && ("image" === e3.type || "video" === e3.type);
}
var E3 = class extends l(t(b(j2(S2(f2))))) {
  constructor(e3) {
    super(e3), this.effectiveSource = null, this.georeference = null, this.copyright = null, this.operationalLayerType = "MediaLayer", this.spatialReference = null, this.type = "media", this._debouncedSaveOperations = k(async (e4, r4, o6) => {
      const { save: t3, saveAs: s6 } = await import("./mediaLayerUtils-24DNU34Y.js");
      switch (e4) {
        case A.SAVE:
          return t3(this, r4);
        case A.SAVE_AS:
          return s6(this, o6, r4);
      }
    }), this.source = new V5();
  }
  load(e3) {
    return this.addResolvingPromise(this._doLoad(e3)), Promise.resolve(this);
  }
  async _doLoad(e3) {
    await this.loadFromPortal({ supportedTypes: ["Media Layer"] }, e3);
    let t3 = this.source;
    if (!t3) throw new s("media-layer:source-missing", "Set 'MediaLayer.source' before loading the layer.");
    const s6 = this._getSourceOverride(t3, this.georeference);
    s6 && (this.setAtOrigin("source", s6, "web-map"), this.setAtOrigin("source", s6, "web-scene"), t3 = s6);
    const i2 = b3(t3) ? new V5({ elements: new V2([t3]) }) : t3;
    this._set("effectiveSource", i2), this.spatialReference && (i2.spatialReference = this.spatialReference), await i2.load(e3), this.spatialReference = i2.spatialReference;
  }
  destroy() {
    var _a, _b;
    (_a = this.effectiveSource) == null ? void 0 : _a.destroy(), this.effectiveSource !== this.source && ((_b = this.source) == null ? void 0 : _b.destroy());
  }
  readGeoreference(e3, r4) {
    return e3 && "itemId" in r4 && r4.itemId ? e3 : void 0;
  }
  get fullExtent() {
    return this.loaded ? this.effectiveSource.fullExtent : null;
  }
  set source(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("source", e3) : n.getLogger(this).error("#source", "source cannot be changed after the layer is loaded.");
  }
  castSource(e3) {
    return e3 ? Array.isArray(e3) ? new V5({ elements: new V2(e3) }) : e3 instanceof V2 ? new V5({ elements: e3 }) : e3 : null;
  }
  readSource(e3, r4, o6) {
    if ("itemId" in r4 && r4.itemId) return;
    const t3 = this._createSource(r4);
    return t3 == null ? void 0 : t3.read(r4, o6), t3;
  }
  writeSource(e3, r4, t3, s6) {
    if (e3 && e3 instanceof V5) {
      const r5 = e3.elements.length;
      if (1 !== r5) return void ((s6 == null ? void 0 : s6.messages) && s6.messages.push(new s("media-layer:unsupported-source", `local media element source can only be persisted if it contains exactly one ImageElement, but it has ${r5}.`)));
      e3 = e3.elements.at(0);
    }
    L3(e3) ? e3.write(r4, s6) : (s6 == null ? void 0 : s6.messages) && (e3 ? s6.messages.push(new s("media-layer:unsupported-source", "only media elements of type 'ImageElement' or 'VideoElement' can be persisted")) : s6.messages.push(new s("media-layer:unsupported-source", "the media layer is missing a source")));
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, r4) {
    return this._debouncedSaveOperations(A.SAVE_AS, r4, e3);
  }
  _createSource(e3) {
    if ("mediaType" in e3) switch (e3.mediaType) {
      case "image":
        return new E2();
      case "video":
        return new j4();
    }
    return null;
  }
  _getSourceOverride(e3, r4) {
    if (b3(e3) && this.originIdOf("source") === e.PORTAL_ITEM && r4 && (this.originIdOf("georeference") === e.WEB_MAP || this.originIdOf("georeference") === e.WEB_SCENE)) {
      const o6 = e3.toJSON(), t3 = this._createSource(o6);
      return t3.read({ ...o6 }, { origin: "portal-item" }), t3.read({ georeference: r4 }, { origin: "web-map" }), t3.read({ georeference: r4 }, { origin: "web-scene" }), t3;
    }
    return null;
  }
};
r([m({ readOnly: true })], E3.prototype, "effectiveSource", void 0), r([m({ readOnly: true, json: { read: false, write: false, origins: { "web-document": { read: true } } } })], E3.prototype, "georeference", void 0), r([o2("web-document", "georeference")], E3.prototype, "readGeoreference", null), r([m({ type: String })], E3.prototype, "copyright", void 0), r([m({ readOnly: true })], E3.prototype, "fullExtent", null), r([m({ type: ["MediaLayer"] })], E3.prototype, "operationalLayerType", void 0), r([m({ type: ["show", "hide"] })], E3.prototype, "listMode", void 0), r([m({ nonNullable: true, json: { write: { enabled: true, allowNull: false, target: { url: { type: String }, mediaType: { type: ["image", "video"] }, georeference: { type: X } }, overridePolicy(e3, r4, o6) {
  return { enabled: true, allowNull: false, ignoreOrigin: P(this, o6 == null ? void 0 : o6.origin) && L3(e3) && !!e3.georeference && e3.originIdOf("georeference") > e.PORTAL_ITEM };
} } } })], E3.prototype, "source", null), r([s3("source")], E3.prototype, "castSource", null), r([o2("source", ["url"])], E3.prototype, "readSource", null), r([r2("source")], E3.prototype, "writeSource", null), r([m()], E3.prototype, "spatialReference", void 0), r([m({ readOnly: true })], E3.prototype, "type", void 0), E3 = r([a("esri.layers.MediaLayer")], E3);
var _4 = E3;
export {
  _4 as default
};
//# sourceMappingURL=MediaLayer-3KFWEI22.js.map
