import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  B,
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a
} from "./chunk-PKLD5YJF.js";
import {
  F
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/layers/support/DimensionalDefinition.js
var a3;
var n = a3 = class extends f {
  constructor(e) {
    super(e), this.variableName = null, this.dimensionName = null, this.values = [], this.isSlice = false;
  }
  clone() {
    return new a3({ variableName: this.variableName, dimensionName: this.dimensionName, values: a(this.values), isSlice: this.isSlice });
  }
};
r([m({ type: String, json: { write: true } })], n.prototype, "variableName", void 0), r([m({ type: String, json: { write: true } })], n.prototype, "dimensionName", void 0), r([m({ type: B.array(B.oneOf([B.native(Number), B.array(B.native(Number))])), json: { write: true } })], n.prototype, "values", void 0), r([m({ type: Boolean, json: { write: true } })], n.prototype, "isSlice", void 0), n = a3 = r([a2("esri.layers.support.DimensionalDefinition")], n);
var p = n;

// node_modules/@arcgis/core/layers/support/rasterDatasets/multidimensionalUtils.js
function t(e, n2, a5) {
  var _a;
  const i2 = n2.shift();
  if (0 === a5.length) {
    const e2 = [];
    a5.push({ sliceId: -1, multidimensionalDefinition: e2 });
  }
  const s2 = a5.length;
  for (let t2 = 0; t2 < s2; t2++) {
    const n3 = a5.shift().multidimensionalDefinition;
    (_a = i2.values) == null ? void 0 : _a.forEach((t3) => {
      a5.push({ sliceId: -1, multidimensionalDefinition: [...n3, { variableName: e, dimensionName: i2.name, values: [t3] }] });
    });
  }
  n2.length && t(e, n2, a5);
}
function a4(e, n2) {
  const a5 = [];
  let i2 = 0;
  return (n2 ? e.variables.filter((e2) => e2.name.toLowerCase() === n2.toLowerCase()) : [...e.variables].sort((e2, n3) => e2.name > n3.name ? 1 : -1)).forEach((e2) => {
    const n3 = [], s2 = [...e2.dimensions].sort((e3, n4) => e3.name > n4.name ? -1 : 1);
    t(e2.name, s2, n3), n3.forEach((e3) => {
      a5.push({ ...e3, sliceId: i2++ });
    });
  }), a5;
}
function i(e, n2, t2) {
  let a5 = e;
  if (n2 && (n2 = [...n2].sort((e2, n3) => e2.dimensionName < n3.dimensionName ? -1 : 1)).forEach(({ dimensionName: e2, values: n3, isSlice: t3 }) => {
    n3.length && (a5 = a5.filter((a6) => {
      const i2 = a6.multidimensionalDefinition.find((n4) => n4.dimensionName === e2);
      if (null == i2) return false;
      const s2 = i2.values[0];
      return "number" == typeof s2 ? "number" == typeof n3[0] ? n3.includes(s2) : n3.some((e3) => e3[0] <= s2 && e3[1] >= s2) : "number" == typeof n3[0] ? n3.some((e3) => s2[0] <= e3 && s2[1] >= e3) : t3 ? n3.some((e3) => e3[0] === s2[0] && e3[0] === s2[1]) : n3.some((e3) => e3[0] >= s2[0] && e3[0] <= s2[1] || e3[1] >= s2[0] && e3[1] <= s2[1] || e3[0] < s2[0] && e3[1] > s2[1]);
    }));
  }), a5.length && null != (t2 == null ? void 0 : t2.start) && null != t2.end) {
    const e2 = t2.start.getTime(), n3 = t2.end.getTime(), i2 = a5[0].multidimensionalDefinition.findIndex((e3) => "StdTime" === e3.dimensionName);
    i2 > -1 && (a5 = a5.filter((t3) => {
      const a6 = t3.multidimensionalDefinition[i2].values[0];
      return e2 <= a6 && n3 >= a6;
    }));
  }
  return a5.map((e2) => e2.sliceId);
}
function s(e, n2) {
  return Array.isArray(e) ? n2[0] === n2[1] ? e[0] === n2[0] || e[1] === n2[0] : e[0] >= n2[0] && e[0] <= n2[1] && e[1] >= n2[0] && e[1] <= n2[1] : e >= n2[0] && e <= n2[1];
}
function r2(e, n2) {
  return e[0] <= n2[0] && e[1] >= n2[0] || e[0] <= n2[1] && e[1] >= n2[1] || e[0] >= n2[0] && e[1] <= n2[1];
}
function l(e) {
  return 1 === e.length ? [e[0], e[0]] : [e[0], e[e.length - 1]];
}
function u(e, n2, t2) {
  var _a, _b;
  if (!((_a = n2 == null ? void 0 : n2.subsetDefinitions) == null ? void 0 : _a.length)) return e;
  let a5;
  if (t2) {
    const { variables: i3 } = n2;
    if (i3.length && !i3.includes(t2)) return null;
    const s2 = n2.subsetDefinitions.find((n3) => n3.dimensionName === e.name && n3.variableName === t2);
    if (!((_b = s2 == null ? void 0 : s2.values) == null ? void 0 : _b.length)) return e;
    a5 = l(s2.values);
  } else {
    const t3 = n2.dimensions.find(({ name: n3 }) => n3 === e.name);
    a5 = t3 == null ? void 0 : t3.extent;
  }
  const i2 = a5;
  if (!(i2 == null ? void 0 : i2.length)) return e;
  const r3 = e.values.filter((e2) => s(e2, i2));
  return { ...e, extent: [...i2], values: r3 };
}
function o(e, n2, t2) {
  var _a;
  if (!((_a = n2 == null ? void 0 : n2.subsetDefinitions) == null ? void 0 : _a.length)) return false;
  const { variables: a5 } = n2;
  if (a5.length && e.some(({ variableName: e2 }) => e2 && !a5.includes(e2))) return true;
  for (let i2 = 0; i2 < e.length; i2++) {
    const a6 = e[i2], u2 = n2.subsetDefinitions.find((e2) => ("" === a6.variableName || e2.variableName === a6.variableName) && e2.dimensionName === a6.dimensionName);
    if (u2 == null ? void 0 : u2.values.length) {
      const e2 = l(u2.values);
      if (!a6.isSlice && 2 === a6.values.length && !Array.isArray(a6.values[0]) && a6.values[0] !== a6.values[1] && t2) {
        if (!r2(a6.values, e2)) return true;
      } else if (a6.values.some((n3) => !s(n3, e2))) return true;
    }
  }
  return false;
}
function m2(e, n2) {
  if (null == e) return { isOutside: false };
  const { geometry: t2, timeExtent: a5, multidimensionalDefinition: i2 } = n2;
  let s2 = null;
  if (null != a5 && (s2 = c(e, a5), null == s2)) return { isOutside: true };
  const { areaOfInterest: r3 } = e;
  if (r3 && t2) {
    const e2 = "point" === t2.type ? t2 : "extent" === t2.type ? t2.center : "polygon" === t2.type ? t2.centroid : null;
    if (e2 && !r3.contains(e2)) return { isOutside: true };
  }
  return null != i2 && i2.length && o(i2, e, true) ? { isOutside: true } : { isOutside: false, intersection: { geometry: t2, timeExtent: s2, multidimensionalDefinition: i2 } };
}
function c(e, t2) {
  const a5 = e.dimensions.find(({ name: e2 }) => "StdTime" === e2);
  if (null == a5 || null == t2.start && null == t2.end) return t2;
  t2 = t2.clone();
  const { start: i2, end: s2 } = t2.toJSON(), r3 = i2 === s2 ? [i2] : null != i2 && null != s2 ? [i2, s2] : [i2 ?? s2];
  if (2 === r3.length && (a5 == null ? void 0 : a5.extent.length) && (r3[0] = Math.max(r3[0], a5.extent[0]), r3[1] = Math.min(r3[1], a5.extent[1] ?? a5.extent[0]), r3[1] < r3[0])) return null;
  return o([new p({ variableName: "", dimensionName: "StdTime", isSlice: 1 === r3.length, values: r3 })], e, true) ? null : (t2.start = new Date(r3[0]), t2.end = new Date(r3[1] ?? r3[0]), t2);
}
function f2(e, n2 = {}) {
  var _a, _b;
  const { multidimensionalInfo: t2, keyProperties: a5 } = e;
  if (null == t2) return null;
  const { variableName: i2, multidimensionalSubset: s2, multidimensionalDefinition: r3 } = n2, l2 = null != r3 ? (_a = r3[0]) == null ? void 0 : _a.variableName : null, u2 = i2 || l2 || (a5 == null ? void 0 : a5.DefaultVariable);
  let { variables: o2 } = t2;
  ((_b = s2 == null ? void 0 : s2.variables) == null ? void 0 : _b.length) && (o2 = o2.filter(({ name: e2 }) => s2.variables.includes(e2)));
  return u2 ? o2.find(({ name: e2 }) => e2 === u2) ?? o2[0] : o2[0];
}
function d(e, t2 = {}) {
  const a5 = f2(e, t2);
  if (!a5) return null;
  const i2 = [], { dimensions: s2, name: r3 } = a5;
  if (0 === s2.length) return [new p({ variableName: r3, dimensionName: "", values: [], isSlice: true })];
  for (let l2 = 0; l2 < s2.length; l2++) {
    const e2 = u(s2[l2], t2.multidimensionalSubset, r3);
    if (!e2) return null;
    const { values: a6, extent: o2 } = e2;
    let m3 = (a6 == null ? void 0 : a6[0]) ?? (o2 == null ? void 0 : o2[0]);
    "stdz" === e2.name.toLowerCase() && !e2.hasRanges && o2 && Math.abs(o2[1]) <= Math.abs(o2[0]) && (m3 = (a6 == null ? void 0 : a6.length) ? a6[a6.length - 1] : o2[1]), i2.push(new p({ variableName: r3, dimensionName: e2.name, values: [m3], isSlice: !t2.useRangeForRangedDimensionInfo || !!e2.hasRanges }));
  }
  return i2;
}
function h(e) {
  return !!(e == null ? void 0 : e.length) && e.some((e2) => {
    if (null == e2.values) return true;
    const n2 = e2.values.length;
    return 0 === n2 || n2 > 1 || !e2.isSlice && Array.isArray(e2.values[0]);
  });
}
function g(n2, t2) {
  var _a;
  if (null == t2 || null == n2) return null;
  let a5 = t2.variables.map((e) => ({ ...e }));
  return ((_a = n2 == null ? void 0 : n2.variables) == null ? void 0 : _a.length) && (a5 = a5.filter(({ name: e }) => n2.variables.includes(e)), a5.forEach((t3) => {
    t3.dimensions = t3.dimensions.map((e) => u(e, n2, t3.name)).filter(F);
  })), a5;
}
function v(e, n2) {
  var _a;
  const { values: t2 } = n2;
  if (t2 == null ? void 0 : t2.length) {
    const n3 = Array.isArray(t2[0]), a6 = Array.isArray(e);
    return n3 !== a6 ? -1 : n3 && a6 ? t2.findIndex((n4) => n4[0] === e[0] && n4[1] === e[1]) : t2.indexOf(e);
  }
  const { extent: a5 } = n2;
  if (Array.isArray(e) || !a5 || e < a5[0] || e > a5[1]) return -1;
  const i2 = n2.interval || 1;
  if ("ISO8601" !== n2.unit) return Math.round((e - a5[0]) / i2);
  const s2 = a5[0];
  let r3 = -1;
  switch (((_a = n2.intervalUnit) == null ? void 0 : _a.toLowerCase()) || "days") {
    case "seconds":
      r3 = Math.round((e - s2) / 1e3 / i2);
      break;
    case "minutes":
      r3 = Math.round((e - s2) / 6e4 / i2);
      break;
    case "hours":
      r3 = Math.round((e - s2) / 36e5 / i2);
      break;
    case "days":
      r3 = Math.round((e - s2) / 864e5 / i2);
      break;
    case "months":
      {
        const n3 = new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear(), t3 = new Date(s2).getUTCMonth(), a6 = new Date(e).getUTCMonth();
        r3 = 0 === n3 ? a6 - t3 : a6 + 11 - t3 + 12 * (n3 - 1);
      }
      break;
    case "years":
      r3 = Math.round((new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear()) / i2);
      break;
    case "decades":
      r3 = Math.round((new Date(e).getUTCFullYear() - new Date(s2).getUTCFullYear()) / 10 / i2);
  }
  return r3;
}
function b(e) {
  var _a, _b;
  let n2 = (_a = e.values) == null ? void 0 : _a.length;
  if (n2) return n2;
  const { extent: t2, unit: a5 } = e, i2 = e.interval || 1, s2 = t2 ? t2[1] - t2[0] : 0;
  if ("ISO8601" !== a5) return Math.round(s2 / i2);
  switch (((_b = e.intervalUnit) == null ? void 0 : _b.toLowerCase()) ?? "seconds") {
    case "seconds":
      n2 = Math.round(s2 / 1e3 / i2);
      break;
    case "minutes":
      n2 = Math.round(s2 / 6e4 / i2);
      break;
    case "hours":
      n2 = Math.round(s2 / 36e5 / i2);
      break;
    case "days":
      n2 = Math.round(s2 / 864e5 / i2);
      break;
    case "months":
      if (t2) {
        const e2 = new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear(), a6 = new Date(t2[0]).getUTCMonth(), i3 = new Date(t2[1]).getUTCMonth();
        n2 = 0 === e2 ? i3 - a6 + 1 : i3 + 11 - a6 + 12 * (e2 - 1) + 1;
      } else n2 = 0;
      break;
    case "years":
      n2 = t2 ? Math.round((new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear()) / i2) : 0;
      break;
    case "decades":
      n2 = t2 ? Math.round((new Date(t2[1]).getUTCFullYear() - new Date(t2[0]).getUTCFullYear()) / 10 / i2) : 0;
      break;
    default:
      n2 = 0;
  }
  return n2;
}
function w(e, n2) {
  let t2 = 0;
  const a5 = e[0].variableName, i2 = [...n2.variables].sort((e2, n3) => e2.name > n3.name ? 1 : -1);
  for (let s2 = 0; s2 < i2.length; s2++) {
    const n3 = i2[s2], r3 = [...n3.dimensions].sort((e2, n4) => e2.name > n4.name ? -1 : 1);
    if (n3.name !== a5) {
      t2 += r3.map((e2) => b(e2)).reduce((e2, n4) => e2 * n4);
      continue;
    }
    const l2 = r3.map((e2) => b(e2)), u2 = r3.length;
    for (let a6 = 0; a6 < u2; a6++) {
      const n4 = e.find((e2) => e2.dimensionName === r3[a6].name);
      if (null == n4) return null;
      const i3 = v(n4.values[0], r3[a6]);
      if (-1 === i3) return null;
      l2.shift(), t2 += a6 === u2 - 1 ? i3 : i3 * l2.reduce((e2, n5) => e2 * n5);
    }
    break;
  }
  return t2;
}

export {
  p,
  a4 as a,
  i,
  o,
  m2 as m,
  f2 as f,
  d,
  h,
  g,
  w
};
//# sourceMappingURL=chunk-MCIWLF5F.js.map
