import {
  s
} from "./chunk-YGTM4JUB.js";
import {
  e
} from "./chunk-2IVHP3HQ.js";
import {
  _
} from "./chunk-G6LMYOSA.js";
import {
  b as b2,
  m as m2
} from "./chunk-LP6TMAPE.js";
import {
  R,
  u as u2
} from "./chunk-ZCHZRNUG.js";
import {
  b2 as b,
  m,
  n3 as n
} from "./chunk-H77COA2S.js";
import {
  a4 as a,
  r2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  u
} from "./chunk-R2PAF6JT.js";

// node_modules/@arcgis/core/views/2d/tiling/TileQueue.js
var l = [0, 0];
var h = class extends b {
  constructor(e2) {
    super(e2), this._keyToItem = /* @__PURE__ */ new Map(), this._tilesByScale = /* @__PURE__ */ new Map(), this.concurrency = 6;
  }
  initialize() {
    const { concurrency: e2, process: t2, scheduler: s2, priority: o2 } = this;
    this._queue = new _({ concurrency: e2, scheduler: s2, priority: o2, process: (e3, s3) => {
      const o3 = this._keyToItem.get(e3);
      return t2(o3, { signal: s3 });
    }, peeker: (e3) => this._peek(e3) });
  }
  destroy() {
    this.clear(), this._queue = u(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  abort(e2) {
    const t2 = "string" == typeof e2 ? e2 : e2.id;
    this._queue.abort(t2);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this._tilesByScale.clear();
  }
  has(e2) {
    return "string" == typeof e2 ? this._keyToItem.has(e2) : this._keyToItem.has(e2.id);
  }
  pause() {
    this._queue.pause();
  }
  push(e2) {
    const t2 = e2.key.id;
    if (this._queue.has(t2)) return this._queue.get(t2);
    const o2 = this._queue.push(t2), r4 = this.tileInfoView.getTileScale(e2.key), i2 = r2(this._tilesByScale, r4, () => /* @__PURE__ */ new Set()), c2 = () => {
      i2.delete(e2.key), 0 === i2.size && this._tilesByScale.delete(r4), this._keyToItem.delete(t2);
    };
    return i2.add(e2.key), this._keyToItem.set(t2, e2), o2.then(c2, c2), o2;
  }
  reset() {
    this._queue.reset();
  }
  resume() {
    this._queue.resume();
  }
  _peek(e2) {
    if (!this.state) return e2.values().next().value;
    const t2 = /* @__PURE__ */ new Set();
    for (const r4 of e2) t2.add(this._keyToItem.get(r4).key);
    const s2 = this.state.scale;
    let o2, i2 = Number.POSITIVE_INFINITY;
    for (const [c2, u3] of this._tilesByScale) {
      if (n(u3, (e3) => t2.has(e3))) {
        const e3 = Math.abs(c2 - s2);
        e3 < i2 && (o2 = u3, i2 = e3);
      }
    }
    return this._getClosestTileKey(o2, e2).id;
  }
  _getClosestTileKey(e2, t2) {
    const s2 = this.tileInfoView, o2 = this.state.center;
    let r4, i2 = Number.POSITIVE_INFINITY;
    for (const c2 of e2) if (t2.has(c2.id)) {
      s2.getTileCoords(l, c2);
      const e3 = m2(l, o2);
      e3 < i2 && (i2 = e3, r4 = c2);
    }
    return r4;
  }
};
r([m({ constructOnly: true })], h.prototype, "concurrency", void 0), r([m({ constructOnly: true })], h.prototype, "priority", void 0), r([m({ constructOnly: true })], h.prototype, "process", void 0), r([m({ constructOnly: true })], h.prototype, "scheduler", void 0), r([m()], h.prototype, "state", void 0), r([m({ constructOnly: true })], h.prototype, "tileInfoView", void 0), h = r([a("esri.views.2d.tiling.TileQueue")], h);
var p = h;

// node_modules/@arcgis/core/views/2d/tiling/TileCache.js
var t = class {
  constructor(e2, t2, i2) {
    this.maxSize = e2, this._tileInfoView = t2, this._removedFunc = i2, this._tilePerId = /* @__PURE__ */ new Map(), this._tileKeysPerLevel = [];
  }
  clear() {
    this._tilePerId.clear(), this._tileKeysPerLevel = [];
  }
  has(e2) {
    return this._tilePerId.has(e2);
  }
  get(e2) {
    return this._tilePerId.get(e2);
  }
  pop(e2) {
    const t2 = this._tilePerId.get(e2);
    if (!t2) return;
    const r4 = t2.key.level, s2 = this._tileKeysPerLevel[r4];
    i(this._tilePerId, e2);
    for (let i2 = 0; i2 < s2.length; i2++) if (s2[i2].id === e2) {
      s2.splice(i2, 1);
      break;
    }
    return t2.visible = true, t2;
  }
  add(e2) {
    e2.visible = false;
    const t2 = e2.key, i2 = t2.id;
    if (this._tilePerId.has(i2)) return;
    this._tilePerId.set(i2, e2);
    const r4 = t2.level;
    this._tileKeysPerLevel[r4] || (this._tileKeysPerLevel[r4] = []), this._tileKeysPerLevel[r4].push(t2);
  }
  prune(e2, t2, i2) {
    let r4 = this._tilePerId.size;
    if (r4 <= this.maxSize) return;
    let s2 = this._tileKeysPerLevel.length - 1;
    for (; r4 > this.maxSize && s2 >= 0; ) s2 !== e2 && (r4 = this._pruneAroundCenterTile(r4, t2, i2, s2)), s2--;
    r4 > this.maxSize && (r4 = this._pruneAroundCenterTile(r4, t2, i2, e2));
  }
  _pruneAroundCenterTile(t2, i2, r4, s2) {
    const l2 = this._tileKeysPerLevel[s2];
    if (!l2 || 0 === l2.length) return t2;
    const { size: h3, origin: n2 } = this._tileInfoView.tileInfo, o2 = r4 * h3[0], _2 = r4 * h3[1], d = [0, 0], c2 = [0, 0];
    for (l2.sort((t3, r5) => (d[0] = n2.x + o2 * (t3.col + 0.5), d[1] = n2.y - _2 * (t3.row + 0.5), c2[0] = n2.x + o2 * (r5.col + 0.5), c2[1] = n2.y - _2 * (r5.row + 0.5), b2(d, i2) - b2(c2, i2))); l2.length > 0; ) {
      const e2 = l2.pop();
      if (this._removeTile(e2.id), --t2 === this.maxSize) break;
    }
    return t2;
  }
  _removeTile(e2) {
    const t2 = this._tilePerId.get(e2);
    this._removedFunc && t2 && this._removedFunc(t2), i(this._tilePerId, e2);
  }
};
function i(e2, t2) {
  e2.delete(t2);
}

// node_modules/@arcgis/core/views/2d/tiling/TileStrategy.js
var o = new e(0, 0, 0, 0);
var a2 = /* @__PURE__ */ new Map();
var h2 = [];
var c = [];
var r3 = class {
  constructor(e2) {
    this._previousScale = Number.POSITIVE_INFINITY, this.cachePolicy = "keep", this.coveragePolicy = "closest", this.resampling = true, this.tileIndex = /* @__PURE__ */ new Map(), this.tiles = [], this.buffer = 192, this.acquireTile = e2.acquireTile, this.releaseTile = e2.releaseTile, this.tileInfoView = e2.tileInfoView, null != e2.resampling && (this.resampling = e2.resampling), e2.cachePolicy && (this.cachePolicy = e2.cachePolicy), e2.coveragePolicy && (this.coveragePolicy = e2.coveragePolicy), null != e2.buffer && (this.buffer = e2.buffer), e2.cacheSize && (this._tileCache = new t(e2.cacheSize, this.tileInfoView, (e3) => {
      this.releaseTile(e3);
    }));
  }
  destroy() {
    this.tileIndex.clear();
  }
  update(e2) {
    var _a, _b;
    const { resampling: i2, tileIndex: t2 } = this, { scale: l2, center: r4, resolution: n2 } = e2.state, { minScale: f, maxScale: d } = this.tileInfoView, u3 = !e2.stationary && l2 > this._previousScale;
    if (this._previousScale = l2, !i2 && (l2 > f || l2 < d)) return this.tiles.length = 0, void this.clear();
    const p2 = this.tileInfoView.getTileCoverage(e2.state, this.buffer, this.resampling, this.coveragePolicy);
    if (!p2) return this.tiles.length = 0, void this.clear();
    const { spans: y, lodInfo: g } = p2, { level: I } = g;
    this.tiles.length = 0, t2.forEach((e3) => e3.visible = true);
    let v = 0, m3 = 0;
    if (y.length > 0) for (const { row: s2, colFrom: h3, colTo: c2 } of y) for (let e3 = h3; e3 <= c2; e3++) {
      v++;
      const i3 = o.set(I, s2, g.normalizeCol(e3), g.getWorldForColumn(e3)).id;
      let l3 = t2.get(i3);
      if (l3) l3.isReady ? (a2.set(i3, l3), m3++) : u3 || this._addParentTile(i3, a2);
      else {
        if ((_a = this._tileCache) == null ? void 0 : _a.has(i3)) {
          if (l3 = this._tileCache.pop(i3), this.tileIndex.set(i3, l3), l3.isReady) {
            a2.set(i3, l3), m3++;
            continue;
          }
        } else l3 = this.acquireTile(o), this.tileIndex.set(i3, l3);
        u3 || this._addParentTile(i3, a2);
      }
    }
    const T = m3 === v;
    for (const [s2, _2] of t2) {
      if (a2.has(s2)) continue;
      o.set(s2);
      const e3 = this.tileInfoView.intersects(p2, o), i3 = "purge" === this.cachePolicy ? o.level !== I : o.level > I;
      !e3 || !u3 && T ? !i3 && e3 || h2.push(_2) : _2.isReady ? i3 && "purge" === this.cachePolicy && this._hasReadyAncestor(o, I) ? h2.push(_2) : c.push(_2) : i3 && h2.push(_2);
    }
    for (const s2 of c) s2.isReady && a2.set(s2.key.id, s2);
    for (const s2 of h2) this._tileCache ? this._tileCache.add(s2) : this.releaseTile(s2), t2.delete(s2.key.id);
    for (const s2 of a2.values()) this.tiles.push(s2);
    for (const s2 of t2.values()) a2.has(s2.key.id) || (s2.visible = false);
    (_b = this._tileCache) == null ? void 0 : _b.prune(I, r4, n2), s.pool.release(p2), c.length = 0, h2.length = 0, a2.clear();
  }
  clear() {
    const { tileIndex: e2 } = this;
    for (const i2 of e2.values()) this.releaseTile(i2);
    e2.clear();
  }
  refresh(e2) {
    var _a;
    for (const i2 of this.tileIndex.values()) e2(i2);
    (_a = this._tileCache) == null ? void 0 : _a.clear();
  }
  updateCacheSize(e2) {
    this._tileCache && (this._tileCache.maxSize = e2);
  }
  _addParentTile(e2, i2) {
    var _a;
    let t2 = e2, s2 = null;
    for (; t2 = this.tileInfoView.getTileParentId(t2), t2; ) if (this.tileIndex.has(t2)) {
      if (s2 = this.tileIndex.get(t2), s2 == null ? void 0 : s2.isReady) {
        i2.has(s2.key.id) || i2.set(s2.key.id, s2);
        break;
      }
    } else if (((_a = this._tileCache) == null ? void 0 : _a.has(t2)) && (s2 = this._tileCache.pop(t2), this.tileIndex.set(t2, s2), s2 == null ? void 0 : s2.isReady)) {
      i2.has(s2.key.id) || i2.set(s2.key.id, s2);
      break;
    }
  }
  _hasReadyAncestor(t2, s2) {
    const l2 = u2();
    this.tileInfoView.getTileBounds(l2, t2, true);
    for (const o2 of this.tileIndex.values()) if (o2.isReady && o2.key.level >= s2 && o2.key.level < t2.level) {
      const t3 = u2();
      if (this.tileInfoView.getTileBounds(t3, o2.key, true), R(t3, l2)) return true;
    }
    return false;
  }
};

export {
  p,
  r3 as r
};
//# sourceMappingURL=chunk-3MXRSVIZ.js.map
