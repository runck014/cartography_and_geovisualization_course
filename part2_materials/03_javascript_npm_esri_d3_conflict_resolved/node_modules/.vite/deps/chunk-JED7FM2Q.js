import {
  p as p2,
  t
} from "./chunk-FFUKJAFO.js";
import {
  x
} from "./chunk-H4E2VVPD.js";
import {
  C as C2
} from "./chunk-TP6LRQ42.js";
import {
  m as m2,
  o as o3
} from "./chunk-5GQ62KHN.js";
import {
  a as a4,
  l,
  p as p3
} from "./chunk-HKYICNT2.js";
import {
  z
} from "./chunk-Z3NV3VCK.js";
import {
  p
} from "./chunk-7VNQKVOW.js";
import {
  b,
  j
} from "./chunk-PNVXSHN2.js";
import {
  a as a5
} from "./chunk-3DVL3O3F.js";
import {
  q
} from "./chunk-MYUZZ3A3.js";
import {
  M
} from "./chunk-JFI4ESYU.js";
import {
  y
} from "./chunk-AVBIV2K3.js";
import {
  i
} from "./chunk-NYLBGE62.js";
import {
  C,
  d
} from "./chunk-W6D3ECTZ.js";
import {
  o as o2
} from "./chunk-YVSEBNS4.js";
import {
  r as r3
} from "./chunk-TSVUPARM.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a2,
  a4 as a3
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  e,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/layers/support/ExpressionInfo.js
var p4 = class extends i(f) {
  constructor(r4) {
    super(r4), this.expression = null, this.title = null, this.returnType = null;
  }
};
r([m({ type: String, json: { write: true } })], p4.prototype, "expression", void 0), r([m({ type: String, json: { write: true } })], p4.prototype, "title", void 0), r([m({ type: String, json: { write: true } })], p4.prototype, "returnType", void 0), p4 = r([a3("esri.layers.support.ExpressionInfo")], p4);
var i2 = p4;

// node_modules/@arcgis/core/layers/support/AggregateField.js
var p5;
var n2 = p5 = class extends f {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p5({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: a(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
r([m({ type: Boolean, json: { write: true } })], n2.prototype, "isAutoGenerated", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "name", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "alias", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "onStatisticField", void 0), r([m({ type: i2, json: { write: true } })], n2.prototype, "onStatisticExpression", void 0), r([m({ type: String, json: { write: true } })], n2.prototype, "statisticType", void 0), n2 = p5 = r([a3("esri.layers.support.AggregateField")], n2);
var a6 = n2;

// node_modules/@arcgis/core/layers/support/FeatureReductionBinning.js
var g;
var v = g = class extends t {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = null, this.labelingInfo = null, this.labelsVisible = true, this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.size = o2("12px"), this.fields = [], this.renderer = null;
  }
  writeFields(e2, r4, o5) {
    const t2 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(o5, t2, r4);
  }
  readRenderer(e2, r4, t2) {
    var _a;
    const s2 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    return s2 ? o3(s2, r4, t2) ?? void 0 : z(r4, t2);
  }
  clone() {
    return new g({ fields: a(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, maxScale: this.maxScale, popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate), renderer: a(this.renderer), binType: a(this.binType), size: this.size });
  }
};
r([r3({ binning: "binning" })], v.prototype, "type", void 0), r([r3({ geohash: "geohash", square: "square" }), m({ type: ["geohash", "square"] })], v.prototype, "binType", void 0), r([m({ type: Number, json: { write: true } })], v.prototype, "fixedBinLevel", void 0), r([m({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], v.prototype, "labelingInfo", void 0), r([m(p3)], v.prototype, "labelsVisible", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], v.prototype, "maxScale", void 0), r([m(l)], v.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], v.prototype, "popupTemplate", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)) })], v.prototype, "size", void 0), r([m({ type: [a6], json: { write: true } })], v.prototype, "fields", void 0), r([r2("fields")], v.prototype, "writeFields", null), r([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], v.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], v.prototype, "readRenderer", null), v = g = r([a3("esri.layers.support.FeatureReductionBinning")], v);
var w = v;

// node_modules/@arcgis/core/layers/support/FeatureReductionCluster.js
var S;
function w2(e2) {
  var _a;
  return "simple" === e2.type && !((_a = e2.visualVariables) == null ? void 0 : _a.length);
}
var I = S = class extends f {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o2("80px"), this.clusterMinSize = o2("12px"), this.clusterMaxSize = o2("50px"), this.maxScale = 0, this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = [];
  }
  readRenderer(e2, r4, t2) {
    var _a, _b;
    const s2 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    return ((_b = s2 == null ? void 0 : s2.authoringInfo) == null ? void 0 : _b.isAutoGenerated) ? null : s2 ? w2(s2) ? null : o3(s2, r4, t2) ?? void 0 : z(r4, t2);
  }
  readSymbol(e2, r4, t2) {
    var _a, _b;
    const s2 = (_a = r4.drawingInfo) == null ? void 0 : _a.renderer;
    if ((_b = s2 == null ? void 0 : s2.authoringInfo) == null ? void 0 : _b.isAutoGenerated) return null;
    if (s2 && w2(s2)) {
      const e3 = o3(s2, r4, t2);
      return e3 == null ? void 0 : e3.symbol;
    }
    return null;
  }
  writeSymbol(e2, r4, o5, s2) {
    var _a, _b;
    const i3 = (_b = (_a = this.renderer) == null ? void 0 : _a.authoringInfo) == null ? void 0 : _b.isAutoGenerated;
    if (!this.renderer || i3) {
      const o6 = new p({ symbol: e2 });
      r4.drawingInfo = { renderer: o6.write({}, s2) };
    }
  }
  writeFields(e2, r4, t2) {
    const o5 = e2.filter((e3) => "avg_angle" !== e3.statisticType).map((e3) => e3.toJSON());
    e(t2, o5, r4);
  }
  readFields(e2, r4, t2) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => a6.fromJSON(e3));
  }
  clone() {
    return new S({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: a(this.labelingInfo), labelsVisible: this.labelsVisible, fields: a(this.fields), maxScale: this.maxScale, renderer: a(this.renderer), symbol: a(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: a(this.popupTemplate) });
  }
};
r([m({ type: ["cluster"], readOnly: true, json: { write: true } })], I.prototype, "type", void 0), r([m({ cast: (e2) => "auto" === e2 ? e2 : a2(o2(e2)), json: { write: true } })], I.prototype, "clusterRadius", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMinSize", void 0), r([m({ type: Number, cast: o2, json: { write: true } })], I.prototype, "clusterMaxSize", void 0), r([m({ type: Number, json: { default: 0, name: "visibilityInfo.maxScale" } })], I.prototype, "maxScale", void 0), r([m(l)], I.prototype, "popupEnabled", void 0), r([m({ type: q, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], I.prototype, "popupTemplate", void 0), r([m({ types: m2, json: { write: { target: "drawingInfo.renderer" } } })], I.prototype, "renderer", void 0), r([o("renderer", ["drawingInfo.renderer"])], I.prototype, "readRenderer", null), r([m({ types: M })], I.prototype, "symbol", void 0), r([o("symbol", ["drawingInfo.renderer"])], I.prototype, "readSymbol", null), r([r2("symbol")], I.prototype, "writeSymbol", null), r([m({ type: [C2], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], I.prototype, "labelingInfo", void 0), r([m(p3)], I.prototype, "labelsVisible", void 0), r([m({ type: [a6], json: { write: true } })], I.prototype, "fields", void 0), r([r2("fields")], I.prototype, "writeFields", null), r([o("fields")], I.prototype, "readFields", null), I = S = r([a3("esri.layers.support.FeatureReductionCluster")], I);
var v2 = I;

// node_modules/@arcgis/core/layers/support/featureReductionUtils.js
var o4 = { key: "type", base: t, typeMap: { cluster: v2, binning: w } };
var p6 = { types: { key: "type", base: t, typeMap: { selection: p2, cluster: v2, binning: w } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o4 }, "portal-item": { types: o4 }, "web-scene": { types: { key: "type", base: t, typeMap: { selection: p2 } }, name: "layerDefinition.featureReduction", write: { layerContainerTypes: a4 } } } } };

// node_modules/@arcgis/core/views/2d/layers/support/clusterUtils.js
var l2 = () => n.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
var u = has("esri-cluster-arcade-enabled");
var p7 = /* @__PURE__ */ new Set(["simple-line", "simple-fill", "picture-fill"]);
function d2(r4, s2) {
  let i3 = s2.clone();
  if (!f2(i3)) return i3;
  if (s2.getSymbols().some((e2) => p7.has(e2.type)) && (i3 = new p({ symbol: new y() })), i3.authoringInfo || (i3.authoringInfo = new j()), i3.authoringInfo.isAutoGenerated = true, "visualVariables" in i3) {
    const e2 = (i3.visualVariables || []).filter((e3) => "$view.scale" !== e3.valueExpression);
    e2.forEach((e3) => {
      "rotation" === e3.type ? e3.field ? e3.field = g2(r4, e3.field, "avg_angle", "number") : e3.valueExpression && (e3.field = b2(r4, e3.valueExpression, "avg_angle", "number"), e3.valueExpression = null) : e3.normalizationField ? (e3.field = g2(r4, e3.field, "avg_norm", "number", e3.normalizationField), e3.normalizationField = null) : e3.field ? e3.field = g2(r4, e3.field, "avg", "number") : e3.valueExpression && (e3.field = b2(r4, e3.valueExpression, "avg", "number"), e3.valueExpression = null);
    }), i3.visualVariables = e2;
  }
  switch (i3.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const e2 of i3.attributes) e2.field ? e2.field = g2(r4, e2.field, "sum", "number") : e2.valueExpression && (e2.field = b2(r4, e2.valueExpression, "sum", "number"), e2.valueExpression = null);
      break;
    case "unique-value":
      i3.field ? i3.field = g2(r4, i3.field, "mode", "string") : i3.valueExpression && (i3.field = b2(r4, i3.valueExpression, "mode", "string"), i3.valueExpression = null);
      break;
    case "class-breaks":
      i3.normalizationField ? (i3.field = g2(r4, i3.field, "avg_norm", "number", i3.normalizationField), i3.normalizationField = null) : i3.field ? i3.field = g2(r4, i3.field, "avg", "number") : i3.valueExpression && (i3.field = b2(r4, i3.valueExpression, "avg", "number"), i3.valueExpression = null);
  }
  return i3;
}
var f2 = (e2) => {
  const r4 = (r5) => l2().error(new s("Unsupported-renderer", r5, { renderer: e2 }));
  if (!e2) return false;
  switch (e2.type) {
    case "unique-value":
      if (e2.field2 || e2.field3) return r4("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (e2.normalizationField) {
        const s2 = e2.normalizationType;
        if ("field" !== s2) return r4(`FeatureReductionCluster does not support a normalizationType of ${s2}`), false;
      }
      break;
    case "simple":
    case "pie-chart":
      break;
    default:
      return r4(`FeatureReductionCluster does not support renderers of type ${e2.type}`), false;
  }
  if (!u) {
    if ("valueExpression" in e2 && e2.valueExpression) return r4("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in e2 && e2.visualVariables || []).some((e3) => !(!("valueExpression" in e3) || !e3.valueExpression))) return r4("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function v3(e2, r4, s2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r4}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r4}`;
    case "mode":
      return `cluster_type_${r4}`;
    case "avg_norm": {
      const e3 = s2, n3 = "field", t2 = r4.toLowerCase() + ",norm:" + n3 + "," + e3.toLowerCase();
      return "cluster_avg_" + x(t2);
    }
  }
}
function b2(e2, r4, s2, o5) {
  const a7 = x(r4), l3 = "mode" === s2 ? `cluster_type_${a7}` : "sum" === s2 ? `cluster_sum_${a7}` : `cluster_avg_${a7}`;
  return e2.some((e3) => e3.name === l3) || e2.push(new a6({ name: l3, isAutoGenerated: true, onStatisticExpression: new i2({ expression: r4, returnType: o5 }), statisticType: s2 })), l3;
}
function g2(e2, r4, s2, i3, o5) {
  if ("cluster_count" === r4 || e2.some((e3) => e3.name === r4)) return r4;
  const a7 = v3(s2, r4, o5);
  return e2.some((e3) => e3.name === a7) || ("avg_norm" === s2 ? e2.push(new a6({ name: a7, isAutoGenerated: true, onStatisticExpression: new i2({ expression: `$feature.${r4} / $feature.${o5}`, returnType: i3 }), statisticType: "avg" })) : e2.push(new a6({ name: a7, isAutoGenerated: true, onStatisticField: r4, statisticType: s2 }))), a7;
}

// node_modules/@arcgis/core/layers/mixins/FeatureReductionLayer.js
var c = (c2) => {
  let p8 = class extends c2 {
    constructor(...e2) {
      super(...e2), this.addHandles(d(() => this.renderer, () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, C));
    }
    set featureReduction(e2) {
      const r4 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r4);
    }
    set renderer(e2) {
    }
    _withClusterVariable(e2, r4, s2) {
      const t2 = e2.clone();
      if ("visualVariables" in t2) {
        t2.visualVariables || (t2.visualVariables = []);
        t2.visualVariables.some((e3) => "size" === e3.type) || t2.visualVariables.push(new b({ field: "cluster_count", stops: [new a5({ value: 1 }), new a5({ useMinValue: true, size: r4 }), new a5({ useMaxValue: true, size: s2 })] }));
      }
      return t2;
    }
    _normalizeFeatureReduction(e2) {
      var _a;
      if ("cluster" !== (e2 == null ? void 0 : e2.type)) return e2;
      const s2 = e2.clone(), t2 = [new a6({ name: "cluster_count", alias: "cluster_count", isAutoGenerated: true, statisticType: "count" })], i3 = (s2.fields ?? []).filter((e3) => !e3.isAutoGenerated), n3 = e2.renderer && !((_a = e2.renderer.authoringInfo) == null ? void 0 : _a.isAutoGenerated), { clusterMinSize: a7, clusterMaxSize: u2 } = s2;
      if (n3) {
        s2.fields = [...t2, ...i3];
        const e3 = this._withClusterVariable(s2.renderer, a7, u2);
        return s2.effectiveFeatureRenderer = e3, s2.effectiveClusterRenderer = e3, s2;
      }
      if (e2.symbol) {
        if (s2.fields = [...t2, ...i3], s2.renderer = null, !this.renderer) return s2.effectiveFeatureRenderer = null, s2.effectiveClusterRenderer = null, s2;
        const n4 = d2(t2, this.renderer), o5 = this._withClusterVariable(n4, a7, u2), l4 = "visualVariables" in o5 && o5.visualVariables ? o5.visualVariables : [], c4 = new p({ symbol: e2.symbol, visualVariables: l4 });
        return s2.fields = [...t2, ...i3], s2.effectiveFeatureRenderer = o5, s2.effectiveClusterRenderer = c4, s2;
      }
      if (!this.renderer) return e2;
      const l3 = d2(t2, this.renderer);
      s2.fields = [...t2, ...i3], s2.renderer = l3;
      const c3 = this._withClusterVariable(l3, a7, u2);
      return s2.effectiveFeatureRenderer = c3, s2.effectiveClusterRenderer = c3, s2;
    }
  };
  return r([m(p6)], p8.prototype, "featureReduction", null), p8 = r([a3("esri.layers.mixins.FeatureReductionLayer")], p8), p8;
};

export {
  p6 as p,
  c
};
//# sourceMappingURL=chunk-JED7FM2Q.js.map
