import {
  E
} from "./chunk-U6IFI7EK.js";
import {
  a,
  c,
  e,
  m,
  u2 as u
} from "./chunk-QJXYURT2.js";
import {
  A,
  B,
  F,
  G,
  H,
  M,
  U,
  V,
  X,
  n as n2,
  t
} from "./chunk-KV3S4QI2.js";
import {
  r
} from "./chunk-R2PAF6JT.js";
import {
  n2 as n
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/views/webgl/RenderbufferDescriptor.js
var i = class {
  constructor(t2, i3, h4 = i3) {
    this.internalFormat = t2, this.width = i3, this.height = h4, this.multisampled = false, this.samples = 1;
  }
};
function h(i3) {
  return i3.width <= 0 || i3.height <= 0 || null == i3.internalFormat ? 0 : i3.width * i3.height * u(i3.internalFormat);
}

// node_modules/@arcgis/core/views/webgl/Renderbuffer.js
var s = class {
  constructor(r3, s4) {
    this._context = r3, this._descriptor = s4, this.type = e.RenderBuffer, this._context.instanceCounter.increment(V.Renderbuffer, this);
    const i3 = this._context.gl;
    this.glName = i3.createRenderbuffer(), this._context.bindRenderbuffer(this);
    const { width: n4, height: o3, internalFormat: h4, multisampled: d2 } = s4;
    d2 ? i3.renderbufferStorageMultisample(i3.RENDERBUFFER, this.samples, h4, n4, o3) : i3.renderbufferStorage(i3.RENDERBUFFER, h4, n4, o3), this._context.bindRenderbuffer(null);
  }
  get descriptor() {
    return this._descriptor;
  }
  get samples() {
    const e4 = this._descriptor.samples, t2 = this._context.parameters.maxSamples;
    return e4 ? Math.min(e4, t2) : t2;
  }
  get usedMemory() {
    return h(this._descriptor);
  }
  resize(e4, t2) {
    const r3 = this._descriptor;
    if (r3.width === e4 && r3.height === t2) return;
    r3.width = e4, r3.height = t2;
    const s4 = this._context.gl;
    this._context.bindRenderbuffer(this), r3.multisampled ? s4.renderbufferStorageMultisample(s4.RENDERBUFFER, this.samples, r3.internalFormat, r3.width, r3.height) : s4.renderbufferStorage(s4.RENDERBUFFER, r3.internalFormat, r3.width, r3.height), this._context.bindRenderbuffer(null);
  }
  dispose() {
    this._context && (this._context.gl.deleteRenderbuffer(this.glName), this._context.instanceCounter.decrement(V.Renderbuffer, this), this._context = null);
  }
};

// node_modules/@arcgis/core/views/webgl/FramebufferObject.js
var p = () => n.getLogger("esri.views.webgl.FramebufferObject");
var x = class _x {
  constructor(t2, e4, i3 = null) {
    this._context = t2, this._glName = null, this._colorAttachments = /* @__PURE__ */ new Map(), this._depthStencilBuffer = null, this._depthStencilTexture = null, this._initialized = false, t2.instanceCounter.increment(V.FramebufferObject, this);
    const r3 = E2(e4) ? e4 : new m(this._context, e4);
    if (this._colorAttachments.set(X.COLOR_ATTACHMENT0, r3), this._validateTextureDescriptor(r3.descriptor), this._validateColorAttachmentPoint(X.COLOR_ATTACHMENT0), null != i3) if (b(i3)) this._depthStencilTexture = E2(i3) ? i3 : new m(this._context, i3), this._validateTextureDescriptor(this._depthStencilTexture.descriptor);
    else {
      const t3 = g(i3) ? i3 : new s(this._context, i3);
      this._depthStencilBuffer = t3, this._validateRenderBufferDescriptor(t3.descriptor);
    }
  }
  dispose() {
    var _a, _b;
    if (0 === this._colorAttachments.size && !this._glName) return;
    const t2 = this._context.getBoundFramebufferObject();
    if (this._colorAttachments.forEach((t3, e4) => {
      var _a2;
      return (_a2 = this.detachColorTexture(e4)) == null ? void 0 : _a2.dispose();
    }), (_a = this.detachDepthStencilBuffer()) == null ? void 0 : _a.dispose(), (_b = this.detachDepthStencilTexture()) == null ? void 0 : _b.dispose(), this._glName) {
      this._context.gl.deleteFramebuffer(this._glName), this._glName = null;
    }
    this._context.bindFramebuffer(t2), this._context.instanceCounter.decrement(V.FramebufferObject, this);
  }
  get glName() {
    return this._glName;
  }
  get colorTexture() {
    return this._colorAttachments.get(X.COLOR_ATTACHMENT0);
  }
  get depthStencil() {
    return this._depthStencilTexture || this._depthStencilBuffer;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get width() {
    var _a;
    const t2 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t2 == null ? void 0 : t2.descriptor) == null ? void 0 : _a.width) ?? 0;
  }
  get height() {
    var _a;
    const t2 = this._colorAttachments.get(X.COLOR_ATTACHMENT0);
    return ((_a = t2 == null ? void 0 : t2.descriptor) == null ? void 0 : _a.height) ?? 0;
  }
  get usedMemory() {
    var _a;
    return [...this._colorAttachments].reduce((t2, [e4, i3]) => t2 + i3.usedMemory, ((_a = this.depthStencil) == null ? void 0 : _a.usedMemory) ?? 0);
  }
  getColorTexture(t2) {
    const e4 = this._colorAttachments.get(t2);
    return e4 && E2(e4) ? e4 : null;
  }
  get colorAttachments() {
    return [...this._colorAttachments.keys()];
  }
  attachColorTexture(t2, e4 = X.COLOR_ATTACHMENT0) {
    var _a;
    if (!t2) return;
    this._validateColorAttachmentPoint(e4);
    const i3 = t2.descriptor;
    this._validateTextureDescriptor(i3), (_a = this.detachColorTexture(e4)) == null ? void 0 : _a.dispose(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t2.glName, e4)), this._colorAttachments.set(e4, t2);
  }
  detachColorTexture(t2 = X.COLOR_ATTACHMENT0) {
    const e4 = this._colorAttachments.get(t2);
    if (e4) {
      if (this._initialized) {
        const e5 = this._context.getBoundFramebufferObject();
        this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t2), this._context.bindFramebuffer(e5);
      }
      return this._colorAttachments.delete(t2), e4;
    }
  }
  setColorTextureTarget(t2, e4 = X.COLOR_ATTACHMENT0) {
    const i3 = this._colorAttachments.get(e4);
    i3 && this._framebufferTexture2D(i3.glName, e4, t2);
  }
  attachDepthStencil(t2) {
    if (t2) switch (t2.type) {
      case e.Texture:
        return this._attachDepthStencilTexture(t2);
      case e.RenderBuffer:
        return this._attachDepthStencilBuffer(t2);
    }
  }
  _attachDepthStencilTexture(t2) {
    var _a;
    if (null == t2) return;
    const e4 = t2.descriptor;
    e4.pixelFormat !== G.DEPTH_STENCIL && e4.pixelFormat !== G.DEPTH24_STENCIL8 && console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"), e4.dataType !== U.UNSIGNED_INT_24_8 && console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8!"), this._validateTextureDescriptor(e4), this._disposeDepthStencilAttachments(), this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(t2.glName, t)), (_a = this._depthStencilTexture) == null ? void 0 : _a.dispose(), this._depthStencilTexture = t2;
  }
  detachDepthStencilTexture() {
    const t2 = this._depthStencilTexture;
    if (t2 && this._initialized) {
      const t3 = this._context.getBoundFramebufferObject();
      this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t), this._context.bindFramebuffer(t3);
    }
    return this._depthStencilTexture = null, t2;
  }
  _attachDepthStencilBuffer(t2) {
    if (null == t2) return;
    const e4 = t2.descriptor;
    if (this._validateRenderBufferDescriptor(e4), this._disposeDepthStencilAttachments(), this._initialized) {
      this._context.bindFramebuffer(this);
      const i3 = this._context.gl, r3 = this._getGLAttachmentPoint(e4);
      i3.framebufferRenderbuffer(n2.FRAMEBUFFER, r3, i3.RENDERBUFFER, t2.glName);
    }
    this._depthStencilBuffer = t2;
  }
  detachDepthStencilBuffer() {
    const t2 = this._depthStencilBuffer;
    if (t2 && this._initialized) {
      const e4 = this._context.getBoundFramebufferObject();
      this._context.bindFramebuffer(this);
      const i3 = this._context.gl, r3 = this._getGLAttachmentPoint(t2.descriptor);
      i3.framebufferRenderbuffer(n2.FRAMEBUFFER, r3, i3.RENDERBUFFER, null), this._context.bindFramebuffer(e4);
    }
    return this._depthStencilBuffer = null, t2;
  }
  copyToTexture(t2, e4, i3, r3, s4, n4, h4) {
    (t2 < 0 || e4 < 0 || s4 < 0 || n4 < 0) && console.error("Offsets cannot be negative!"), (i3 <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!");
    const o3 = h4.descriptor;
    h4.descriptor.target !== M.TEXTURE_2D && console.error("Texture target must be TEXTURE_2D!"), (null == (o3 == null ? void 0 : o3.width) || null == (o3 == null ? void 0 : o3.height) || t2 + i3 > this.width || e4 + r3 > this.height || s4 + i3 > o3.width || n4 + r3 > o3.height) && console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");
    const c3 = this._context, a4 = c3.bindTexture(h4, m.TEXTURE_UNIT_FOR_UPDATES);
    c3.setActiveTexture(m.TEXTURE_UNIT_FOR_UPDATES), c3.bindFramebuffer(this), c3.gl.copyTexSubImage2D(M.TEXTURE_2D, 0, s4, n4, t2, e4, i3, r3), c3.bindTexture(a4, m.TEXTURE_UNIT_FOR_UPDATES);
  }
  readPixels(t2, e4, i3, r3, s4, n4, h4) {
    (i3 <= 0 || r3 <= 0) && console.error("Copy width and height must be greater than zero!"), h4 || console.error("Target memory is not initialized!"), this._context.bindFramebuffer(this), this._context.gl.readPixels(t2, e4, i3, r3, s4, n4, h4);
  }
  async readPixelsAsync(t2, e4, r3, s4, n4, h4, o3) {
    const { gl: c3 } = this._context, a4 = E.createPixelPack(this._context, F.STREAM_READ, o3.byteLength);
    this._context.bindBuffer(a4);
    const u3 = this._context.getBoundFramebufferObject();
    this._context.bindFramebuffer(this), c3.readPixels(t2, e4, r3, s4, n4, h4, 0), this._context.unbindBuffer(A.PIXEL_PACK_BUFFER), this._context.bindFramebuffer(u3), await a4.getSubDataAsync(o3), a4.dispose();
  }
  resize(t2, e4) {
    var _a, _b;
    if (this.width === t2 && this.height === e4) return;
    const i3 = { width: t2, height: e4 };
    A2(i3, this._context.parameters.maxTextureSize), this._colorAttachments.forEach((t3) => t3.resize(i3.width, i3.height)), (_a = this._depthStencilTexture) == null ? void 0 : _a.resize(i3.width, i3.height), this._initialized && (A2(i3, this._context.parameters.maxRenderbufferSize), (_b = this._depthStencilBuffer) == null ? void 0 : _b.resize(i3.width, i3.height), this._context.getBoundFramebufferObject() === this && this._context.bindFramebuffer(null), this._initialized = false);
  }
  initializeAndBind(t2 = n2.FRAMEBUFFER) {
    const e4 = this._context.gl;
    if (this._initialized) return void e4.bindFramebuffer(t2, this.glName);
    this._glName && e4.deleteFramebuffer(this._glName);
    const i3 = e4.createFramebuffer();
    if (e4.bindFramebuffer(t2, i3), this._colorAttachments.forEach((e5, i4) => this._framebufferTexture2D(e5.glName, i4, S(e5), t2)), this._depthStencilBuffer) {
      const i4 = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
      e4.framebufferRenderbuffer(t2, i4, e4.RENDERBUFFER, this._depthStencilBuffer.glName);
    } else this._depthStencilTexture && this._framebufferTexture2D(this._depthStencilTexture.glName, e4.DEPTH_STENCIL_ATTACHMENT, S(this._depthStencilTexture), t2);
    if (a()) {
      e4.checkFramebufferStatus(t2) !== e4.FRAMEBUFFER_COMPLETE && console.error("Framebuffer is incomplete!");
    }
    this._glName = i3, this._initialized = true;
  }
  _framebufferTexture2D(t2, e4 = X.COLOR_ATTACHMENT0, i3 = M.TEXTURE_2D, r3 = n2.FRAMEBUFFER, s4 = 0) {
    this._context.gl.framebufferTexture2D(r3, e4, i3, t2, s4);
  }
  _disposeDepthStencilAttachments() {
    const t2 = this._context.gl;
    if (this._depthStencilBuffer) {
      if (this._initialized) {
        this._context.bindFramebuffer(this);
        const e4 = this._getGLAttachmentPoint(this._depthStencilBuffer.descriptor);
        t2.framebufferRenderbuffer(n2.FRAMEBUFFER, e4, t2.RENDERBUFFER, null);
      }
      this._depthStencilBuffer = r(this._depthStencilBuffer);
    }
    this._depthStencilTexture && (this._initialized && (this._context.bindFramebuffer(this), this._framebufferTexture2D(null, t2.DEPTH_STENCIL_ATTACHMENT)), this._depthStencilTexture = r(this._depthStencilTexture));
  }
  _validateTextureDescriptor(t2) {
    t2.target !== M.TEXTURE_2D && t2.target !== M.TEXTURE_CUBE_MAP && console.error("Texture type must be TEXTURE_2D or TEXTURE_CUBE_MAP!"), A2(t2, this._context.parameters.maxTextureSize), this._validateBufferDimensions(t2);
  }
  _validateRenderBufferDescriptor(t2) {
    A2(t2, this._context.parameters.maxRenderbufferSize), this._validateBufferDimensions(t2);
  }
  _validateBufferDimensions(t2) {
    t2.width <= 0 && (t2.width = this.width), t2.height <= 0 && (t2.height = this.height), this.width > 0 && this.height > 0 && (this.width === t2.width && this.height === t2.height || console.error("Attachment size must match framebuffer size!"));
  }
  _getGLAttachmentPoint(t2) {
    switch (t2.internalFormat) {
      case B.DEPTH_COMPONENT16:
      case B.DEPTH_COMPONENT24:
      case B.DEPTH_COMPONENT32F:
        return this._context.gl.DEPTH_ATTACHMENT;
      case B.DEPTH24_STENCIL8:
      case B.DEPTH32F_STENCIL8:
      case B.DEPTH_STENCIL:
        return this._context.gl.DEPTH_STENCIL_ATTACHMENT;
      case B.STENCIL_INDEX8:
        return this._context.gl.STENCIL_ATTACHMENT;
    }
  }
  _validateColorAttachmentPoint(e4) {
    if (-1 === _x._MAX_COLOR_ATTACHMENTS) {
      const { gl: t2 } = this._context;
      _x._MAX_COLOR_ATTACHMENTS = t2.getParameter(t2.MAX_COLOR_ATTACHMENTS);
    }
    const i3 = e4 - X.COLOR_ATTACHMENT0;
    i3 + 1 > _x._MAX_COLOR_ATTACHMENTS && n.getLogger("esri.views.webgl.FrameBufferObject").error("esri.FrameBufferObject", `illegal attachment point for color attachment: ${i3 + 1}. Implementation supports up to ${_x._MAX_COLOR_ATTACHMENTS} color attachments`);
  }
};
function E2(t2) {
  return null != t2 && "type" in t2 && t2.type === e.Texture;
}
function g(t2) {
  return null != t2 && "type" in t2 && t2.type === e.RenderBuffer;
}
function b(t2) {
  return E2(t2) || null != t2 && "pixelFormat" in t2;
}
function A2(t2, e4) {
  const i3 = Math.max(t2.width, t2.height);
  if (i3 > e4) {
    p().warn(`Resizing FBO attachment size ${t2.width}x${t2.height} to device limit ${e4}`);
    const r3 = e4 / i3;
    return t2.width = Math.round(t2.width * r3), t2.height = Math.round(t2.height * r3), false;
  }
  return true;
}
function S(t2) {
  return t2.descriptor.target === M.TEXTURE_CUBE_MAP ? M.TEXTURE_CUBE_MAP_POSITIVE_X : M.TEXTURE_2D;
}
x._MAX_COLOR_ATTACHMENTS = -1;

// node_modules/@arcgis/core/views/webgl/reservedWordsGLSL3.js
var e2 = ["layout", "centroid", "smooth", "case", "mat2x2", "mat2x3", "mat2x4", "mat3x2", "mat3x3", "mat3x4", "mat4x2", "mat4x3", "mat4x4", "uint", "uvec2", "uvec3", "uvec4", "samplerCubeShadow", "sampler2DArray", "sampler2DArrayShadow", "isampler2D", "isampler3D", "isamplerCube", "isampler2DArray", "usampler2D", "usampler3D", "usamplerCube", "usampler2DArray", "coherent", "restrict", "readonly", "writeonly", "resource", "atomic_uint", "noperspective", "patch", "sample", "subroutine", "common", "partition", "active", "filter", "image1D", "image2D", "image3D", "imageCube", "iimage1D", "iimage2D", "iimage3D", "iimageCube", "uimage1D", "uimage2D", "uimage3D", "uimageCube", "image1DArray", "image2DArray", "iimage1DArray", "iimage2DArray", "uimage1DArray", "uimage2DArray", "image1DShadow", "image2DShadow", "image1DArrayShadow", "image2DArrayShadow", "imageBuffer", "iimageBuffer", "uimageBuffer", "sampler1DArray", "sampler1DArrayShadow", "isampler1D", "isampler1DArray", "usampler1D", "usampler1DArray", "isampler2DRect", "usampler2DRect", "samplerBuffer", "isamplerBuffer", "usamplerBuffer", "sampler2DMS", "isampler2DMS", "usampler2DMS", "sampler2DMSArray", "isampler2DMSArray", "usampler2DMSArray", "trunc", "round", "roundEven", "isnan", "isinf", "floatBitsToInt", "floatBitsToUint", "intBitsToFloat", "uintBitsToFloat", "packSnorm2x16", "unpackSnorm2x16", "packUnorm2x16", "unpackUnorm2x16", "packHalf2x16", "unpackHalf2x16", "outerProduct", "transpose", "determinant", "inverse", "texture", "textureSize", "textureProj", "textureLod", "textureOffset", "texelFetch", "texelFetchOffset", "textureProjOffset", "textureLodOffset", "textureProjLod", "textureProjLodOffset", "textureGrad", "textureGradOffset", "textureProjGrad", "textureProjGradOffset"];

// node_modules/@arcgis/core/views/webgl/testUtils.js
var e3 = { enableCache: false };

// node_modules/@arcgis/core/views/webgl/ShaderTranspiler.js
var a2 = ["precision", "highp", "mediump", "lowp", "attribute", "const", "uniform", "varying", "break", "continue", "do", "for", "while", "if", "else", "in", "out", "inout", "float", "int", "void", "bool", "true", "false", "discard", "return", "mat2", "mat3", "mat4", "vec2", "vec3", "vec4", "ivec2", "ivec3", "ivec4", "bvec2", "bvec3", "bvec4", "sampler1D", "sampler2D", "sampler3D", "samplerCube", "sampler1DShadow", "sampler2DShadow", "struct", "asm", "class", "union", "enum", "typedef", "template", "this", "packed", "goto", "switch", "default", "inline", "noinline", "volatile", "public", "static", "extern", "external", "interface", "long", "short", "double", "half", "fixed", "unsigned", "input", "output", "hvec2", "hvec3", "hvec4", "dvec2", "dvec3", "dvec4", "fvec2", "fvec3", "fvec4", "sampler2DRect", "sampler3DRect", "sampler2DRectShadow", "sizeof", "cast", "namespace", "using"];
var o = ["<<=", ">>=", "++", "--", "<<", ">>", "<=", ">=", "==", "!=", "&&", "||", "+=", "-=", "*=", "/=", "%=", "&=", "^^", "^=", "|=", "(", ")", "[", "]", ".", "!", "~", "*", "/", "%", "+", "-", "<", ">", "&", "^", "|", "?", ":", "=", ",", ";", "{", "}"];
var n3 = ["abs", "acos", "all", "any", "asin", "atan", "ceil", "clamp", "cos", "cross", "dFdx", "dFdy", "degrees", "distance", "dot", "equal", "exp", "exp2", "faceforward", "floor", "fract", "gl_BackColor", "gl_BackLightModelProduct", "gl_BackLightProduct", "gl_BackMaterial", "gl_BackSecondaryColor", "gl_ClipPlane", "gl_ClipVertex", "gl_Color", "gl_DepthRange", "gl_DepthRangeParameters", "gl_EyePlaneQ", "gl_EyePlaneR", "gl_EyePlaneS", "gl_EyePlaneT", "gl_Fog", "gl_FogCoord", "gl_FogFragCoord", "gl_FogParameters", "gl_FragColor", "gl_FragCoord", "gl_FragData", "gl_FragDepth", "gl_FragDepthEXT", "gl_FrontColor", "gl_FrontFacing", "gl_FrontLightModelProduct", "gl_FrontLightProduct", "gl_FrontMaterial", "gl_FrontSecondaryColor", "gl_LightModel", "gl_LightModelParameters", "gl_LightModelProducts", "gl_LightProducts", "gl_LightSource", "gl_LightSourceParameters", "gl_MaterialParameters", "gl_MaxClipPlanes", "gl_MaxCombinedTextureImageUnits", "gl_MaxDrawBuffers", "gl_MaxFragmentUniformComponents", "gl_MaxLights", "gl_MaxTextureCoords", "gl_MaxTextureImageUnits", "gl_MaxTextureUnits", "gl_MaxVaryingFloats", "gl_MaxVertexAttribs", "gl_MaxVertexTextureImageUnits", "gl_MaxVertexUniformComponents", "gl_ModelViewMatrix", "gl_ModelViewMatrixInverse", "gl_ModelViewMatrixInverseTranspose", "gl_ModelViewMatrixTranspose", "gl_ModelViewProjectionMatrix", "gl_ModelViewProjectionMatrixInverse", "gl_ModelViewProjectionMatrixInverseTranspose", "gl_ModelViewProjectionMatrixTranspose", "gl_MultiTexCoord0", "gl_MultiTexCoord1", "gl_MultiTexCoord2", "gl_MultiTexCoord3", "gl_MultiTexCoord4", "gl_MultiTexCoord5", "gl_MultiTexCoord6", "gl_MultiTexCoord7", "gl_Normal", "gl_NormalMatrix", "gl_NormalScale", "gl_ObjectPlaneQ", "gl_ObjectPlaneR", "gl_ObjectPlaneS", "gl_ObjectPlaneT", "gl_Point", "gl_PointCoord", "gl_PointParameters", "gl_PointSize", "gl_Position", "gl_ProjectionMatrix", "gl_ProjectionMatrixInverse", "gl_ProjectionMatrixInverseTranspose", "gl_ProjectionMatrixTranspose", "gl_SecondaryColor", "gl_TexCoord", "gl_TextureEnvColor", "gl_TextureMatrix", "gl_TextureMatrixInverse", "gl_TextureMatrixInverseTranspose", "gl_TextureMatrixTranspose", "gl_Vertex", "greaterThan", "greaterThanEqual", "inversesqrt", "length", "lessThan", "lessThanEqual", "log", "log2", "matrixCompMult", "max", "min", "mix", "mod", "normalize", "not", "notEqual", "pow", "radians", "reflect", "refract", "sign", "sin", "smoothstep", "sqrt", "step", "tan", "texture2D", "texture2DLod", "texture2DProj", "texture2DProjLod", "textureCube", "textureCubeLod", "texture2DLodEXT", "texture2DProjLodEXT", "textureCubeLodEXT", "texture2DGradEXT", "texture2DProjGradEXT", "textureCubeGradEXT", "textureSize", "texelFetch"];
var i2 = 999;
var l = 9999;
var s2 = 0;
var c2 = 1;
var d = 2;
var u2 = 3;
var g2 = 4;
var p2 = 5;
var f = 6;
var _ = 7;
var h2 = 8;
var x2 = 9;
var m2 = 10;
var y = 11;
var w = ["block-comment", "line-comment", "preprocessor", "operator", "integer", "float", "ident", "builtin", "keyword", "whitespace", "eof", "integer"];
function M2() {
  var e4, t2, r3, M3 = 0, v2 = 0, T2 = i2, b3 = [], P2 = [], E4 = 1, C2 = 0, k2 = 0, D2 = false, j2 = false, F3 = "";
  return function(e5) {
    return P2 = [], null !== e5 ? S3(e5.replace ? e5.replace(/\r\n/g, "\n") : e5) : R2();
  };
  function L2(e5) {
    e5.length && P2.push({ type: w[T2], data: e5, position: k2, line: E4, column: C2 });
  }
  function S3(t3) {
    var a4;
    for (M3 = 0, r3 = (F3 += t3).length; e4 = F3[M3], M3 < r3; ) {
      switch (a4 = M3, T2) {
        case s2:
          M3 = I();
          break;
        case c2:
          M3 = G2();
          break;
        case d:
          M3 = A3();
          break;
        case u2:
          M3 = O();
          break;
        case g2:
          M3 = B2();
          break;
        case y:
          M3 = q();
          break;
        case p2:
          M3 = H2();
          break;
        case l:
          M3 = N();
          break;
        case x2:
          M3 = X3();
          break;
        case i2:
          M3 = V3();
      }
      if (a4 !== M3) if ("\n" === F3[a4]) C2 = 0, ++E4;
      else ++C2;
    }
    return v2 += M3, F3 = F3.slice(M3), P2;
  }
  function R2(e5) {
    return b3.length && L2(b3.join("")), T2 = m2, L2("(eof)"), P2;
  }
  function V3() {
    return b3 = b3.length ? [] : b3, "/" === t2 && "*" === e4 ? (k2 = v2 + M3 - 1, T2 = s2, t2 = e4, M3 + 1) : "/" === t2 && "/" === e4 ? (k2 = v2 + M3 - 1, T2 = c2, t2 = e4, M3 + 1) : "#" === e4 ? (T2 = d, k2 = v2 + M3, M3) : /\s/.test(e4) ? (T2 = x2, k2 = v2 + M3, M3) : (D2 = /\d/.test(e4), j2 = /[^\w_]/.test(e4), k2 = v2 + M3, T2 = D2 ? g2 : j2 ? u2 : l, M3);
  }
  function X3() {
    return /[^\s]/g.test(e4) ? (L2(b3.join("")), T2 = i2, M3) : (b3.push(e4), t2 = e4, M3 + 1);
  }
  function A3() {
    return "\r" !== e4 && "\n" !== e4 || "\\" === t2 ? (b3.push(e4), t2 = e4, M3 + 1) : (L2(b3.join("")), T2 = i2, M3);
  }
  function G2() {
    return A3();
  }
  function I() {
    return "/" === e4 && "*" === t2 ? (b3.push(e4), L2(b3.join("")), T2 = i2, M3 + 1) : (b3.push(e4), t2 = e4, M3 + 1);
  }
  function O() {
    if ("." === t2 && /\d/.test(e4)) return T2 = p2, M3;
    if ("/" === t2 && "*" === e4) return T2 = s2, M3;
    if ("/" === t2 && "/" === e4) return T2 = c2, M3;
    if ("." === e4 && b3.length) {
      for (; U2(b3); ) ;
      return T2 = p2, M3;
    }
    if (";" === e4 || ")" === e4 || "(" === e4) {
      if (b3.length) for (; U2(b3); ) ;
      return L2(e4), T2 = i2, M3 + 1;
    }
    var r4 = 2 === b3.length && "=" !== e4;
    if (/[\w_\d\s]/.test(e4) || r4) {
      for (; U2(b3); ) ;
      return T2 = i2, M3;
    }
    return b3.push(e4), t2 = e4, M3 + 1;
  }
  function U2(e5) {
    for (var t3, r4, a4 = 0; ; ) {
      if (t3 = o.indexOf(e5.slice(0, e5.length + a4).join("")), r4 = o[t3], -1 === t3) {
        if (a4-- + e5.length > 0) continue;
        r4 = e5.slice(0, 1).join("");
      }
      return L2(r4), k2 += r4.length, (b3 = b3.slice(r4.length)).length;
    }
  }
  function q() {
    return /[^a-fA-F0-9]/.test(e4) ? (L2(b3.join("")), T2 = i2, M3) : (b3.push(e4), t2 = e4, M3 + 1);
  }
  function B2() {
    return "." === e4 || /[eE]/.test(e4) ? (b3.push(e4), T2 = p2, t2 = e4, M3 + 1) : "x" === e4 && 1 === b3.length && "0" === b3[0] ? (T2 = y, b3.push(e4), t2 = e4, M3 + 1) : /[^\d]/.test(e4) ? (L2(b3.join("")), T2 = i2, M3) : (b3.push(e4), t2 = e4, M3 + 1);
  }
  function H2() {
    return "f" === e4 && (b3.push(e4), t2 = e4, M3 += 1), /[eE]/.test(e4) || "-" === e4 && /[eE]/.test(t2) ? (b3.push(e4), t2 = e4, M3 + 1) : /[^\d]/.test(e4) ? (L2(b3.join("")), T2 = i2, M3) : (b3.push(e4), t2 = e4, M3 + 1);
  }
  function N() {
    if (/[^\d\w_]/.test(e4)) {
      var r4 = b3.join("");
      return T2 = a2.indexOf(r4) > -1 ? h2 : n3.indexOf(r4) > -1 ? _ : f, L2(b3.join("")), T2 = i2, M3;
    }
    return b3.push(e4), t2 = e4, M3 + 1;
  }
}
function v(e4) {
  var t2 = M2(), r3 = [];
  return r3 = (r3 = r3.concat(t2(e4))).concat(t2(null));
}
function T(e4) {
  return v(e4);
}
function b2(e4) {
  return e4.map((e5) => "eof" !== e5.type ? e5.data : "").join("");
}
var P = /* @__PURE__ */ new Set(["GL_OES_standard_derivatives", "GL_EXT_frag_depth", "GL_EXT_draw_buffers", "GL_EXT_shader_texture_lod"]);
function E3(e4, t2 = "100", r3 = "300 es") {
  const a4 = /^\s*#version\s+([0-9]+(\s+[a-zA-Z]+)?)\s*/;
  for (const o3 of e4) if ("preprocessor" === o3.type) {
    const e5 = a4.exec(o3.data);
    if (e5) {
      const a5 = e5[1].replaceAll(/\s{2,}/g, " ");
      if (a5 === r3) return a5;
      if (a5 === t2) return o3.data = "#version " + r3, t2;
      throw new Error("unknown glsl version: " + a5);
    }
  }
  return e4.splice(0, 0, { type: "preprocessor", data: "#version " + r3 }, { type: "whitespace", data: "\n" }), null;
}
function C(e4, t2) {
  for (let r3 = t2 - 1; r3 >= 0; r3--) {
    const t3 = e4[r3];
    if ("whitespace" !== t3.type && "block-comment" !== t3.type) {
      if ("keyword" !== t3.type) break;
      if ("attribute" === t3.data || "in" === t3.data) return true;
    }
  }
  return false;
}
function k(e4, t2, r3, a4) {
  a4 = a4 || r3;
  for (const o3 of e4) if ("ident" === o3.type && o3.data === r3) {
    a4 in t2 ? t2[a4]++ : t2[a4] = 0;
    return k(e4, t2, a4 + "_" + t2[a4], a4);
  }
  return r3;
}
function D(e4, t2, r3 = "afterVersion") {
  function a4(e5, t3) {
    for (let r4 = t3; r4 < e5.length; r4++) {
      const t4 = e5[r4];
      if ("operator" === t4.type && ";" === t4.data) return r4;
    }
    return null;
  }
  function o3(e5) {
    let t3 = -1, o4 = 0, n5 = -1;
    for (let i4 = 0; i4 < e5.length; i4++) {
      const l3 = e5[i4];
      if ("preprocessor" === l3.type && (/#(if|ifdef|ifndef)\s+.+/.test(l3.data) ? ++o4 : /#endif\s*.*/.test(l3.data) && --o4), "afterVersion" !== r3 && "afterPrecision" !== r3 || "preprocessor" === l3.type && l3.data.startsWith("#version") && (n5 = Math.max(n5, i4)), "afterPrecision" === r3 && "keyword" === l3.type && "precision" === l3.data) {
        const t4 = a4(e5, i4);
        if (null === t4) throw new Error("precision statement not followed by any semicolons!");
        n5 = Math.max(n5, t4);
      }
      t3 < n5 && 0 === o4 && (t3 = i4);
    }
    return t3 + 1;
  }
  const n4 = { data: "\n", type: "whitespace" }, i3 = (t3) => t3 < e4.length && /[^\r\n]$/.test(e4[t3].data);
  let l2 = o3(e4);
  i3(l2 - 1) && e4.splice(l2++, 0, n4);
  for (const s4 of t2) e4.splice(l2++, 0, s4);
  i3(l2 - 1) && i3(l2) && e4.splice(l2, 0, n4);
}
function j(e4, t2, r3, a4 = "lowp") {
  D(e4, [{ type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: a4 }, { type: "whitespace", data: " " }, { type: "keyword", data: r3 }, { type: "whitespace", data: " " }, { type: "ident", data: t2 }, { type: "operator", data: ";" }], "afterPrecision");
}
function F2(e4, t2, r3, a4, o3 = "lowp") {
  D(e4, [{ type: "keyword", data: "layout" }, { type: "operator", data: "(" }, { type: "keyword", data: "location" }, { type: "whitespace", data: " " }, { type: "operator", data: "=" }, { type: "whitespace", data: " " }, { type: "integer", data: a4.toString() }, { type: "operator", data: ")" }, { type: "whitespace", data: " " }, { type: "keyword", data: "out" }, { type: "whitespace", data: " " }, { type: "keyword", data: o3 }, { type: "whitespace", data: " " }, { type: "keyword", data: r3 }, { type: "whitespace", data: " " }, { type: "ident", data: t2 }, { type: "operator", data: ";" }], "afterPrecision");
}
function L(e4, t2) {
  let r3, a4, o3 = -1;
  for (let n4 = t2; n4 < e4.length; n4++) {
    const t3 = e4[n4];
    if ("operator" === t3.type && ("[" === t3.data && (r3 = n4), "]" === t3.data)) {
      a4 = n4;
      break;
    }
    "integer" === t3.type && (o3 = parseInt(t3.data, 10));
  }
  return r3 && a4 && e4.splice(r3, a4 - r3 + 1), o3;
}
function S2(r3, a4) {
  if (r3.startsWith("#version 300")) return r3;
  const o3 = V2(r3);
  if (null != o3) return o3;
  const n4 = T(r3);
  if ("300 es" === E3(n4, "100", "300 es")) return r3;
  let i3 = null, l2 = null;
  const s4 = {}, c3 = {};
  for (let d2 = 0; d2 < n4.length; ++d2) {
    const r4 = n4[d2];
    switch (r4.type) {
      case "keyword":
        a4 === H.VERTEX_SHADER && "attribute" === r4.data ? r4.data = "in" : "varying" === r4.data && (r4.data = a4 === H.VERTEX_SHADER ? "out" : "in");
        break;
      case "builtin":
        if (/^texture(2D|Cube)(Proj)?(Lod|Grad)?(EXT)?$/.test(r4.data.trim()) && (r4.data = r4.data.replaceAll(/(2D|Cube|EXT)/g, "")), a4 === H.FRAGMENT_SHADER && "gl_FragColor" === r4.data && (i3 || (i3 = k(n4, s4, "fragColor"), j(n4, i3, "vec4")), r4.data = i3), a4 === H.FRAGMENT_SHADER && "gl_FragData" === r4.data) {
          const e4 = L(n4, d2 + 1), t2 = k(n4, s4, "fragData");
          F2(n4, t2, "vec4", e4, "mediump"), r4.data = t2;
        } else a4 === H.FRAGMENT_SHADER && "gl_FragDepthEXT" === r4.data && (l2 || (l2 = k(n4, s4, "gl_FragDepth")), r4.data = l2);
        break;
      case "ident":
        if (e2.includes(r4.data)) {
          if (a4 === H.VERTEX_SHADER && C(n4, d2)) throw new Error("attribute in vertex shader uses a name that is a reserved word in glsl 300 es");
          r4.data in c3 || (c3[r4.data] = k(n4, s4, r4.data)), r4.data = c3[r4.data];
        }
    }
  }
  for (let e4 = n4.length - 1; e4 >= 0; --e4) {
    const t2 = n4[e4];
    if ("preprocessor" === t2.type) {
      const r4 = t2.data.match(/#extension\s+(.*):/);
      if ((r4 == null ? void 0 : r4[1]) && P.has(r4[1].trim())) {
        const t3 = n4[e4 + 1];
        n4.splice(e4, t3 && "whitespace" === t3.type ? 2 : 1);
      }
      const a5 = t2.data.match(/#ifdef\s+(.*)/);
      (a5 == null ? void 0 : a5[1]) && P.has(a5[1].trim()) && (t2.data = "#if 1");
      const o4 = t2.data.match(/#ifndef\s+(.*)/);
      (o4 == null ? void 0 : o4[1]) && P.has(o4[1].trim()) && (t2.data = "#if 0");
    }
  }
  return X2(r3, b2(n4));
}
var R = /* @__PURE__ */ new Map();
function V2(e4) {
  return e3.enableCache ? R.get(e4) : null;
}
function X2(e4, t2) {
  return e3.enableCache && R.set(e4, t2), t2;
}

// node_modules/@arcgis/core/views/webgl/Program.js
var o2 = 4294967295;
var r2 = class {
  constructor(r3, a4, h4, m4, c3 = /* @__PURE__ */ new Map(), _2 = []) {
    var _a;
    this._context = r3, this._locations = m4, this._uniformBlockBindings = c3, this._transformFeedbackVaryings = _2, this._refCount = 1, this._compiled = false, this._linesOfCode = 0, this._nameToUniformLocation = /* @__PURE__ */ new Map(), this._nameToUniform1 = /* @__PURE__ */ new Map(), this._nameToUniform1v = /* @__PURE__ */ new Map(), this._nameToUniform2 = /* @__PURE__ */ new Map(), this._nameToUniform3 = /* @__PURE__ */ new Map(), this._nameToUniform4 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix3 = /* @__PURE__ */ new Map(), this._nameToUniformMatrix4 = /* @__PURE__ */ new Map(), r3 || console.error("RenderingContext isn't initialized!"), 0 === a4.length && console.error("Shaders source should not be empty!"), a4 = S2(a4, H.VERTEX_SHADER), h4 = S2(h4, H.FRAGMENT_SHADER), this._vShader = s3(this._context, H.VERTEX_SHADER, a4), this._fShader = s3(this._context, H.FRAGMENT_SHADER, h4), f2.enabled && (this._linesOfCode = a4.match(/\n/g).length + h4.match(/\n/g).length + 2, this._context.instanceCounter.increment(V.LinesOfCode, this._vShader, this._linesOfCode)), this._vShader && this._fShader || console.error("Error loading shaders!"), this._context.instanceCounter.increment(V.Shader, this), c() && (this.vertexShader = a4, this.fragmentShader = h4), this.usedMemory = a4.length + h4.length;
    const l2 = this._context.gl, g3 = l2.createProgram();
    l2.attachShader(g3, this._vShader), l2.attachShader(g3, this._fShader), this._locations.forEach((t2, e4) => l2.bindAttribLocation(g3, t2, e4)), ((_a = this._transformFeedbackVaryings) == null ? void 0 : _a.length) && l2.transformFeedbackVaryings(g3, this._transformFeedbackVaryings, l2.SEPARATE_ATTRIBS), l2.linkProgram(g3), c() && !l2.getProgramParameter(g3, l2.LINK_STATUS) && console.error(`Could not link shader
validated: ${l2.getProgramParameter(g3, l2.VALIDATE_STATUS)}, gl error ${l2.getError()}, vertex: ${l2.getShaderParameter(this._vShader, l2.COMPILE_STATUS)}, fragment: ${l2.getShaderParameter(this._fShader, l2.COMPILE_STATUS)}, info log: ${l2.getProgramInfoLog(g3)}, vertex source: ${this.vertexShader}, fragment source: ${this.fragmentShader}`);
    for (const [t2, e4] of this._uniformBlockBindings) {
      const n4 = l2.getUniformBlockIndex(g3, t2);
      n4 < o2 && l2.uniformBlockBinding(g3, n4, e4);
    }
    this._glName = g3, this._context.instanceCounter.increment(V.Program, this);
  }
  get glName() {
    return this._glName;
  }
  get hasGLName() {
    return null != this._glName;
  }
  get hasTransformFeedbackVaryings() {
    var _a;
    return !!((_a = this._transformFeedbackVaryings) == null ? void 0 : _a.length);
  }
  get compiled() {
    if (this._compiled) return true;
    const t2 = this._context.gl.getExtension("KHR_parallel_shader_compile");
    return null == t2 || null == this.glName ? (this._compiled = true, true) : (this._compiled = !!this._context.gl.getProgramParameter(this.glName, t2.COMPLETION_STATUS_KHR), this._compiled);
  }
  dispose() {
    if (--this._refCount > 0) return;
    const t2 = this._context.gl, e4 = this._context.instanceCounter;
    this._nameToUniformLocation.forEach((t3) => t3 && e4.decrement(V.Uniform, t3)), this._nameToUniformLocation.clear(), this._vShader && (this._linesOfCode > 0 && (e4.decrement(V.LinesOfCode, this._vShader, this._linesOfCode), this._linesOfCode = 0), t2.deleteShader(this._vShader), this._vShader = null, e4.decrement(V.Shader, this)), this._fShader && (t2.deleteShader(this._fShader), this._fShader = null), this._glName && (t2.deleteProgram(this._glName), this._glName = null, e4.decrement(V.Program, this));
  }
  ref() {
    ++this._refCount;
  }
  _getUniformLocation(t2) {
    const e4 = this._nameToUniformLocation.get(t2);
    if (void 0 !== e4) return e4;
    if (this.glName) {
      const e5 = this._context.gl.getUniformLocation(this.glName, t2);
      return this._nameToUniformLocation.set(t2, e5), e5 && this._context.instanceCounter.increment(V.Uniform, e5), e5;
    }
    return null;
  }
  hasUniform(t2) {
    return null != this._getUniformLocation(t2);
  }
  setUniform1i(t2, e4) {
    const n4 = this._nameToUniform1.get(t2);
    void 0 !== n4 && e4 === n4 || (this._context.gl.uniform1i(this._getUniformLocation(t2), e4), this._nameToUniform1.set(t2, e4));
  }
  setUniform1iv(t2, e4) {
    m3(this._nameToUniform1v, t2, e4) && this._context.gl.uniform1iv(this._getUniformLocation(t2), e4);
  }
  setUniform2iv(t2, e4) {
    m3(this._nameToUniform2, t2, e4) && this._context.gl.uniform2iv(this._getUniformLocation(t2), e4);
  }
  setUniform3iv(t2, e4) {
    m3(this._nameToUniform3, t2, e4) && this._context.gl.uniform3iv(this._getUniformLocation(t2), e4);
  }
  setUniform4iv(t2, e4) {
    m3(this._nameToUniform4, t2, e4) && this._context.gl.uniform4iv(this._getUniformLocation(t2), e4);
  }
  setUniform1f(t2, e4) {
    const n4 = this._nameToUniform1.get(t2);
    void 0 !== n4 && e4 === n4 || (this._context.gl.uniform1f(this._getUniformLocation(t2), e4), this._nameToUniform1.set(t2, e4));
  }
  setUniform1fv(t2, e4) {
    m3(this._nameToUniform1v, t2, e4) && this._context.gl.uniform1fv(this._getUniformLocation(t2), e4);
  }
  setUniform2f(t2, e4, n4) {
    const i3 = this._nameToUniform2.get(t2);
    void 0 === i3 ? (this._context.gl.uniform2f(this._getUniformLocation(t2), e4, n4), this._nameToUniform2.set(t2, [e4, n4])) : e4 === i3[0] && n4 === i3[1] || (this._context.gl.uniform2f(this._getUniformLocation(t2), e4, n4), i3[0] = e4, i3[1] = n4);
  }
  setUniform2fv(t2, e4) {
    m3(this._nameToUniform2, t2, e4) && this._context.gl.uniform2fv(this._getUniformLocation(t2), e4);
  }
  setUniform3f(t2, e4, n4, i3) {
    const o3 = this._nameToUniform3.get(t2);
    void 0 === o3 ? (this._context.gl.uniform3f(this._getUniformLocation(t2), e4, n4, i3), this._nameToUniform3.set(t2, [e4, n4, i3])) : e4 === o3[0] && n4 === o3[1] && i3 === o3[2] || (this._context.gl.uniform3f(this._getUniformLocation(t2), e4, n4, i3), o3[0] = e4, o3[1] = n4, o3[2] = i3);
  }
  setUniform3fv(t2, e4) {
    const n4 = this._getUniformLocation(t2);
    null != n4 && m3(this._nameToUniform3, t2, e4) && this._context.gl.uniform3fv(n4, e4);
  }
  setUniform4f(t2, e4, n4, i3, o3) {
    const r3 = this._nameToUniform4.get(t2);
    void 0 === r3 ? (this._context.gl.uniform4f(this._getUniformLocation(t2), e4, n4, i3, o3), this._nameToUniform4.set(t2, [e4, n4, i3, o3])) : void 0 !== r3 && e4 === r3[0] && n4 === r3[1] && i3 === r3[2] && o3 === r3[3] || (this._context.gl.uniform4f(this._getUniformLocation(t2), e4, n4, i3, o3), r3[0] = e4, r3[1] = n4, r3[2] = i3, r3[3] = o3);
  }
  setUniform4fv(t2, e4) {
    const n4 = this._getUniformLocation(t2);
    null != n4 && m3(this._nameToUniform4, t2, e4) && this._context.gl.uniform4fv(n4, e4);
  }
  setUniformMatrix3fv(t2, e4, n4 = false) {
    const i3 = this._getUniformLocation(t2);
    null != i3 && m3(this._nameToUniformMatrix3, t2, e4) && this._context.gl.uniformMatrix3fv(i3, n4, e4);
  }
  setUniformMatrix4fv(t2, e4, n4 = false) {
    const i3 = this._getUniformLocation(t2);
    null != i3 && m3(this._nameToUniformMatrix4, t2, e4) && this._context.gl.uniformMatrix4fv(i3, n4, e4);
  }
  stop() {
  }
};
function s3(n4, i3, o3) {
  const r3 = n4.gl, s4 = r3.createShader(i3);
  return r3.shaderSource(s4, o3), r3.compileShader(s4), c() && !r3.getShaderParameter(s4, r3.COMPILE_STATUS) && (console.error("Compile error in ".concat(i3 === H.VERTEX_SHADER ? "vertex" : "fragment", " shader")), console.error(r3.getShaderInfoLog(s4)), console.error(a3(o3))), s4;
}
function a3(t2) {
  let e4 = 2;
  return t2.replaceAll("\n", () => "\n" + h3(e4++) + ":");
}
function h3(t2) {
  return t2 >= 1e3 ? t2.toString() : ("  " + t2).slice(-3);
}
function m3(t2, e4, n4) {
  const i3 = t2.get(e4);
  if (!i3) return t2.set(e4, Array.from(n4)), true;
  const o3 = n4.length;
  if (i3.length !== o3) return t2.set(e4, Array.from(n4)), true;
  for (let r3 = 0; r3 < o3; ++r3) {
    const t3 = n4[r3];
    if (i3[r3] !== t3) {
      for (i3[r3] = t3; r3 < o3; ++r3) i3[r3] = n4[r3];
      return true;
    }
  }
  return false;
}
var f2 = { enabled: false };

export {
  i,
  s,
  x,
  r2 as r
};
//# sourceMappingURL=chunk-DPVSO6BH.js.map
