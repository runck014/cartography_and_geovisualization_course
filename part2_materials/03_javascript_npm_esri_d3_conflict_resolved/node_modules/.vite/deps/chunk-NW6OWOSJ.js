import {
  I as I2,
  P as P2,
  a as a5,
  h,
  n2 as n,
  t as t2,
  v as v3,
  y as y2
} from "./chunk-EVK6ZSVY.js";
import {
  t
} from "./chunk-MSUBZ5BW.js";
import {
  S,
  b,
  g as g3,
  j,
  j2,
  x as x2
} from "./chunk-YEDSTDY4.js";
import {
  ot
} from "./chunk-OMMWWGIU.js";
import {
  Z
} from "./chunk-2BVPGUC2.js";
import {
  I
} from "./chunk-547Z5YIS.js";
import {
  $,
  B,
  C,
  E,
  P,
  U,
  d as d2,
  f as f2,
  g as g2,
  k,
  m as m2,
  p,
  v as v2
} from "./chunk-LIUBAYCM.js";
import {
  e
} from "./chunk-WPERPIJF.js";
import {
  Z as Z2
} from "./chunk-RXJCBLN2.js";
import {
  s as s4
} from "./chunk-2U5JYYSG.js";
import {
  C as C2
} from "./chunk-T6QS4ZNU.js";
import {
  R
} from "./chunk-6B4OMNPA.js";
import {
  i
} from "./chunk-SUZN3TAH.js";
import {
  K,
  M as M2,
  d,
  u as u3
} from "./chunk-K5RYAJV4.js";
import {
  Y
} from "./chunk-XGYM66XX.js";
import {
  Fe,
  Ie,
  be,
  ge,
  i as i2,
  ye
} from "./chunk-BWTCR2DR.js";
import {
  f,
  m,
  y
} from "./chunk-3L2AYCZY.js";
import {
  a as a4,
  l as l3,
  l2 as l4,
  r,
  v
} from "./chunk-VUJERGGB.js";
import {
  a as a3,
  u as u2
} from "./chunk-ZCHZRNUG.js";
import {
  g,
  s3,
  z
} from "./chunk-E2I7HYXQ.js";
import {
  a as a2
} from "./chunk-HAF6QJ32.js";
import {
  l2,
  s as s2
} from "./chunk-GRW2QIBT.js";
import {
  l,
  u
} from "./chunk-R2PAF6JT.js";
import {
  a,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  M,
  x
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/core/sql/WhereClauseCache.js
var r2 = class {
  constructor(e4, r4) {
    this._cache = new e(e4), this._invalidCache = new e(r4);
  }
  get(t6, r4) {
    const i3 = `${r4.uid}:${t6}`, c4 = this._cache.get(i3);
    if (c4) return c4;
    if (null != this._invalidCache.get(i3)) return null;
    try {
      const c5 = Z.create(t6, { fieldsIndex: r4 });
      return this._cache.put(i3, c5), c5;
    } catch (n3) {
      return this._invalidCache.put(i3, n3), null;
    }
  }
  getError(t6, e4) {
    const r4 = `${e4.uid}:${t6}`;
    return this._invalidCache.get(r4) ?? null;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/attributeSupport.js
var s5 = new r2(50, 500);
var t3 = "unsupported-query";
var n2 = " as ";
var o = /* @__PURE__ */ new Set(["esriFieldTypeOID", "esriFieldTypeSmallInteger", "esriFieldTypeBigInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeLong"]);
var a6 = /* @__PURE__ */ new Set(["esriFieldTypeDate", "esriFieldTypeDateOnly", "esriFieldTypeTimeOnly", "esriFieldTypeTimestampOffset"]);
var l5 = /* @__PURE__ */ new Set(["esriFieldTypeString", "esriFieldTypeGUID", "esriFieldTypeGlobalID", ...o, ...a6]);
function d3(i3, r4, n3 = {}) {
  const o2 = c(r4, i3);
  if (!o2) {
    const n4 = s5.getError(r4, i3);
    throw new s(t3, "invalid SQL expression", { expression: r4, error: n4 });
  }
  const a7 = n3.expressionName || "expression";
  if (n3.validateStandardized && !o2.isStandardized) throw new s(t3, `${a7} is not standard`, { expression: r4 });
  if (n3.validateAggregate && !o2.isAggregate) throw new s(t3, `${a7} does not contain a valid aggregate function`, { expression: r4 });
  return o2.fieldNames;
}
function p2(e4, i3, r4, s7) {
  if (!r4) return true;
  const t6 = "where clause";
  return g4(e4, i3, d3(e4, r4, { validateStandardized: true, expressionName: t6 }), { expressionName: t6, query: s7 }), true;
}
function f3(i3, r4, s7, n3, o2) {
  if (!s7) return true;
  const a7 = "having clause", l6 = d3(i3, s7, { validateAggregate: true, expressionName: a7 });
  g4(i3, r4, l6, { expressionName: a7, query: o2 });
  const p4 = c(s7, i3), f5 = p4 == null ? void 0 : p4.getExpressions().every((e4) => {
    var _a;
    const { aggregateType: r5, field: s8 } = e4, t6 = (_a = i3.get(s8)) == null ? void 0 : _a.name;
    return n3.some((e5) => {
      var _a2;
      const { onStatisticField: s9, statisticType: n4 } = e5, o3 = (_a2 = i3.get(s9)) == null ? void 0 : _a2.name;
      return o3 === t6 && n4.toLowerCase().trim() === r5;
    });
  });
  if (!f5) throw new s(t3, "expressions in having clause should also exist in outStatistics", { having: s7 });
  return true;
}
function c(e4, i3) {
  return e4 ? s5.get(e4, i3) : null;
}
function u4(e4) {
  return /\((.*?)\)/.test(e4) ? e4 : e4.split(n2)[0];
}
function y3(e4) {
  return e4.split(n2)[1];
}
function g4(i3, r4, s7, n3 = {}) {
  const o2 = /* @__PURE__ */ new Map();
  if (m3(o2, i3, r4, n3.allowedFieldTypes ?? l5, s7), o2.size) {
    const i4 = n3.expressionName ?? "expression";
    throw new s(t3, `${i4} contains invalid or missing fields`, { errors: Array.from(o2.values()), query: n3.query });
  }
}
function m3(e4, i3, r4, s7, t6) {
  const n3 = t6.includes("*") ? [...r4, ...t6.filter((e5) => "*" !== e5)] : t6;
  for (const a7 of n3) {
    if (i3.get(a7)) T(e4, i3, r4, s7, a7);
    else try {
      const t7 = d3(i3, u4(a7), { validateStandardized: true });
      for (const n4 of t7) T(e4, i3, r4, s7, n4);
    } catch (o2) {
      e4.set(a7, { type: "expression-error", expression: a7, error: o2 });
    }
  }
}
function T(e4, i3, s7, t6, n3) {
  const o2 = i3.get(n3);
  o2 ? s7.has(o2.name) ? "all" !== t6 && false === (t6 == null ? void 0 : t6.has(o2.type)) && e4.set(n3, { type: "invalid-type", fieldName: o2.name, fieldType: i.fromJSON(o2.type), allowedFieldTypes: Array.from(t6, (e5) => i.fromJSON(e5)) }) : e4.set(n3, { type: "missing-field", fieldName: o2.name }) : e4.set(n3, { type: "invalid-field", fieldName: n3 });
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineCache.js
var e2 = 5;
var t4 = class {
  constructor() {
    this._storage = /* @__PURE__ */ new Map(), this._purgeInterval = e2, this._sweep = () => {
      if (this._timer = void 0, !this._storage) return;
      const e4 = 1e3 * this._purgeInterval, t6 = performance.now() - e4;
      for (const [s7, r4] of this._storage) {
        if (!(r4.time < t6)) return void (this._storage.size > 0 && (this._timer = setTimeout(this._sweep, e4)));
        this._storage.delete(s7);
      }
    };
  }
  destroy() {
    var _a;
    (_a = this._storage) == null ? void 0 : _a.clear(), this._storage = null, clearTimeout(this._timer);
  }
  get size() {
    var _a;
    return ((_a = this._storage) == null ? void 0 : _a.size) ?? 0;
  }
  put(e4, t6) {
    var _a;
    (_a = this._storage) == null ? void 0 : _a.set(e4, new r3(t6)), this._scheduleSweep();
  }
  get(e4) {
    var _a, _b, _c;
    if (!this._storage) return;
    const t6 = (_a = this._storage) == null ? void 0 : _a.get(e4);
    return t6 ? ((_b = this._storage) == null ? void 0 : _b.delete(e4), t6.time = performance.now(), (_c = this._storage) == null ? void 0 : _c.set(e4, t6), t6.items) : void 0;
  }
  clear() {
    var _a;
    (_a = this._storage) == null ? void 0 : _a.clear();
  }
  _scheduleSweep() {
    this._storage && (this._timer ?? (this._timer = setTimeout(this._sweep, 1e3 * this._purgeInterval)));
  }
};
var s6 = 0;
var r3 = class {
  constructor(e4) {
    this.items = e4, this.time = performance.now(), this.id = s6++;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/AttributesBuilder.js
var c2 = class {
  constructor(s7, a7, l6) {
    this._fieldDataCache = /* @__PURE__ */ new Map(), this._returnDistinctMap = /* @__PURE__ */ new Map(), this.returnDistinctValues = s7.returnDistinctValues ?? false, this.fieldsIndex = l6, this.featureAdapter = a7;
    const r4 = s7.outFields;
    if (r4 && !r4.includes("*")) {
      this.outFields = r4;
      let s8 = 0;
      for (const a8 of r4) {
        const r5 = u4(a8), n3 = this.fieldsIndex.get(r5), u6 = n3 ? null : c(r5, l6), o2 = n3 ? n3.name : y3(a8) || "FIELD_EXP_" + s8++;
        this._fieldDataCache.set(a8, { alias: o2, clause: u6 });
      }
    }
  }
  countDistinctValues(t6) {
    return this.returnDistinctValues ? (t6.forEach((t7) => this.getAttributes(t7)), this._returnDistinctMap.size) : t6.length;
  }
  getAttributes(t6) {
    const e4 = this._processAttributesForOutFields(t6);
    return this._processAttributesForDistinctValues(e4);
  }
  getFieldValue(t6, i3, s7) {
    var _a;
    const a7 = s7 ? s7.name : i3;
    let l6 = null;
    return this._fieldDataCache.has(a7) ? l6 = (_a = this._fieldDataCache.get(a7)) == null ? void 0 : _a.clause : s7 || (l6 = c(i3, this.fieldsIndex), this._fieldDataCache.set(a7, { alias: a7, clause: l6 })), s7 ? this.featureAdapter.getAttribute(t6, a7) : l6 == null ? void 0 : l6.calculateValue(t6, this.featureAdapter);
  }
  getDataValues(t6, e4, i3 = true) {
    const s7 = e4.normalizationType, d5 = e4.normalizationTotal, c4 = this.fieldsIndex.get(e4.field), h3 = Fe(c4) || Ie(c4), f5 = be(c4);
    return t6.map((t7) => {
      let a7 = e4.field && this.getFieldValue(t7, e4.field, this.fieldsIndex.get(e4.field));
      if (e4.field2 ? (a7 = `${m2(a7)}${e4.fieldDelimiter}${m2(this.getFieldValue(t7, e4.field2, this.fieldsIndex.get(e4.field2)))}`, e4.field3 && (a7 = `${a7}${e4.fieldDelimiter}${m2(this.getFieldValue(t7, e4.field3, this.fieldsIndex.get(e4.field3)))}`)) : "string" == typeof a7 && i3 && (h3 ? a7 = a7 ? new Date(a7).getTime() : null : f5 && (a7 = a7 ? I(a7) : null)), s7 && Number.isFinite(a7)) {
        const i4 = "field" === s7 && e4.normalizationField ? this.getFieldValue(t7, e4.normalizationField, this.fieldsIndex.get(e4.normalizationField)) : null;
        a7 = B(a7, s7, i4, d5);
      }
      return a7;
    });
  }
  async getExpressionValues(t6, e4, i3, a7, l6) {
    const { arcadeUtils: r4 } = await i2(), n3 = r4.hasGeometryOperations(e4);
    n3 && await r4.enableGeometryOperations();
    const u6 = r4.createFunction(e4), o2 = r4.getViewInfo(i3), c4 = { fields: this.fieldsIndex.fields };
    return t6.map((t7) => {
      const e5 = { attributes: this.featureAdapter.getAttributes(t7), layer: c4, geometry: n3 ? { ...a5(a7.geometryType, a7.hasZ, a7.hasM, this.featureAdapter.getGeometry(t7)), spatialReference: i3 == null ? void 0 : i3.spatialReference } : null }, d5 = r4.createExecContext(e5, o2, l6);
      return r4.executeFunction(u6, d5);
    });
  }
  validateItem(t6, i3) {
    var _a, _b;
    return this._fieldDataCache.has(i3) || this._fieldDataCache.set(i3, { alias: i3, clause: c(i3, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i3)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testFeature(t6, this.featureAdapter)) ?? false;
  }
  validateItems(t6, i3) {
    var _a, _b;
    return this._fieldDataCache.has(i3) || this._fieldDataCache.set(i3, { alias: i3, clause: c(i3, this.fieldsIndex) }), ((_b = (_a = this._fieldDataCache.get(i3)) == null ? void 0 : _a.clause) == null ? void 0 : _b.testSet(t6, this.featureAdapter)) ?? false;
  }
  _processAttributesForOutFields(t6) {
    const e4 = this.outFields;
    if (!(e4 == null ? void 0 : e4.length)) return this.featureAdapter.getAttributes(t6);
    const i3 = {};
    for (const s7 of e4) {
      const { alias: e5, clause: a7 } = this._fieldDataCache.get(s7);
      i3[e5] = a7 ? a7.calculateValue(t6, this.featureAdapter) : this.featureAdapter.getAttribute(t6, e5);
    }
    return i3;
  }
  _processAttributesForDistinctValues(t6) {
    if (null == t6 || !this.returnDistinctValues) return t6;
    const e4 = this.outFields, i3 = [];
    if (e4) for (const l6 of e4) {
      const { alias: e5 } = this._fieldDataCache.get(l6);
      i3.push(t6[e5]);
    }
    else for (const l6 in t6) i3.push(t6[l6]);
    const s7 = `${(e4 || ["*"]).join(",")}=${i3.join(",")}`;
    let a7 = this._returnDistinctMap.get(s7) || 0;
    return this._returnDistinctMap.set(s7, ++a7), a7 > 1 ? null : t6;
  }
};

// node_modules/@arcgis/core/layers/graphics/data/SnappingCandidate.js
function t5(t6, e4, r4) {
  return { objectId: t6, target: e4, distance: r4, type: "vertex" };
}
function e3(t6, e4, r4, n3, d5, a7 = false) {
  return { objectId: t6, target: e4, distance: r4, type: "edge", start: n3, end: d5, draped: a7 };
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngineResult.js
var q = class {
  constructor(e4, t6, s7) {
    this.items = e4, this.query = t6, this.geometryType = s7.geometryType, this.hasM = s7.hasM, this.hasZ = s7.hasZ, this.fieldsIndex = s7.fieldsIndex, this.objectIdField = s7.objectIdField, this.spatialReference = s7.spatialReference, this.featureAdapter = s7.featureAdapter;
  }
  get size() {
    return this.items.length;
  }
  createQueryResponseForCount() {
    const e4 = new c2(this.query, this.featureAdapter, this.fieldsIndex);
    if (!this.query.outStatistics) return e4.countDistinctValues(this.items);
    const { groupByFieldsForStatistics: t6, having: s7, outStatistics: i3 } = this.query, a7 = t6 == null ? void 0 : t6.length;
    if (!!!a7) return 1;
    const r4 = /* @__PURE__ */ new Map(), n3 = /* @__PURE__ */ new Map(), o2 = /* @__PURE__ */ new Set();
    for (const l6 of i3) {
      const { statisticType: i4 } = l6, a8 = "exceedslimit" !== i4 ? l6.onStatisticField : void 0;
      if (!n3.has(a8)) {
        const s8 = [];
        for (const i5 of t6) {
          const t7 = this._getAttributeValues(e4, i5, r4);
          s8.push(t7);
        }
        n3.set(a8, this._calculateUniqueValues(s8, e4.returnDistinctValues));
      }
      const u6 = n3.get(a8);
      for (const t7 in u6) {
        const { data: i5, items: a9 } = u6[t7], r5 = i5.join(",");
        s7 && !e4.validateItems(a9, s7) || o2.add(r5);
      }
    }
    return o2.size;
  }
  async createQueryResponse() {
    let e4;
    if (this.query.outStatistics) {
      e4 = this.query.outStatistics.some((e5) => "exceedslimit" === e5.statisticType) ? this._createExceedsLimitQueryResponse(this.query) : await this._createStatisticsQueryResponse(this.query);
    } else e4 = this._createFeatureQueryResponse(this.query);
    if (this.query.returnQueryGeometry) {
      const t6 = this.query.geometry;
      g(this.query.outSR) && !s3(t6.spatialReference, this.query.outSR) ? e4.queryGeometry = h({ spatialReference: this.query.outSR, ...j(t6, t6.spatialReference, this.query.outSR) }) : e4.queryGeometry = h({ spatialReference: this.query.outSR, ...t6 });
    }
    return e4;
  }
  createSnappingResponse(e4, t6) {
    const s7 = this.featureAdapter, i3 = C3(this.hasZ, this.hasM), { point: a7, mode: r4 } = e4, n3 = "number" == typeof e4.distance ? e4.distance : e4.distance.x, o2 = "number" == typeof e4.distance ? e4.distance : e4.distance.y, l6 = { candidates: [] }, u6 = "esriGeometryPolygon" === this.geometryType, c4 = this._getPointCreator(r4, this.spatialReference, t6), d5 = new G(null, 0), m5 = new G(null, 0), p4 = { x: 0, y: 0, z: 0 };
    for (const f5 of this.items) {
      const t7 = s7.getGeometry(f5);
      if (null == t7) continue;
      const { coords: r5, lengths: y5 } = t7;
      if (d5.coords = r5, m5.coords = r5, e4.returnEdge) {
        let e5 = 0;
        for (let t8 = 0; t8 < y5.length; t8++) {
          const r6 = y5[t8];
          for (let t9 = 0; t9 < r6; t9++, e5 += i3) {
            const u7 = d5;
            if (u7.coordsIndex = e5, t9 !== r6 - 1) {
              const t10 = m5;
              t10.coordsIndex = e5 + i3;
              const r7 = p4;
              N(p4, a7, u7, t10);
              const d6 = (a7.x - r7.x) / n3, g5 = (a7.y - r7.y) / o2, y6 = d6 * d6 + g5 * g5;
              y6 <= 1 && l6.candidates.push(e3(s7.getObjectId(f5), c4(r7), Math.sqrt(y6), c4(u7), c4(t10)));
            }
          }
        }
      }
      if ("none" !== e4.vertexMode) {
        const t8 = u6 ? r5.length - i3 : r5.length;
        if ("all" === e4.vertexMode) for (let e5 = 0; e5 < t8; e5 += i3) {
          const t9 = d5;
          t9.coordsIndex = e5;
          const i4 = (a7.x - t9.x) / n3, r6 = (a7.y - t9.y) / o2, u7 = i4 * i4 + r6 * r6;
          u7 <= 1 && l6.candidates.push(t5(s7.getObjectId(f5), c4(t9), Math.sqrt(u7)));
        }
        else if ("ends" === e4.vertexMode) {
          const e5 = [0];
          u6 || e5.push(r5.length - i3);
          for (const t9 of e5) {
            const e6 = d5;
            e6.coordsIndex = t9;
            const i4 = (a7.x - e6.x) / n3, r6 = (a7.y - e6.y) / o2, u7 = i4 * i4 + r6 * r6;
            u7 <= 1 && l6.candidates.push(t5(s7.getObjectId(f5), c4(e6), Math.sqrt(u7)));
          }
        }
      }
    }
    return l6.candidates.sort((e5, t7) => e5.distance - t7.distance), l6;
  }
  _getPointCreator(e4, t6, s7) {
    const i3 = null == s7 || s3(t6, s7) ? (e5) => e5 : (e5) => j(e5, t6, s7), { hasZ: a7 } = this, r4 = 0;
    return "3d" === e4 ? a7 ? ({ x: e5, y: t7, z: s8 }) => i3({ x: e5, y: t7, z: s8 }) : ({ x: e5, y: t7 }) => i3({ x: e5, y: t7, z: r4 }) : ({ x: e5, y: t7 }) => i3({ x: e5, y: t7 });
  }
  async createSummaryStatisticsResponse(e4) {
    const { field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, minValue: n3, maxValue: o2, scale: l6, timeZone: u6, outStatisticTypes: c4 } = e4, d5 = this.fieldsIndex.get(t6), m5 = ge(d5) || Fe(d5) || Ie(d5), h3 = await this._getDataValues({ field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, scale: l6, timeZone: u6 }), g5 = d2({ normalizationType: a7, normalizationField: i3, minValue: n3, maxValue: o2 }), I3 = { value: 0.5, fieldType: d5 == null ? void 0 : d5.type }, _ = ye(d5) ? f2({ values: h3, supportsNullCount: g5, percentileParams: I3, outStatisticTypes: c4 }) : p({ values: h3, minValue: n3, maxValue: o2, useSampleStdDev: !a7, supportsNullCount: g5, percentileParams: I3, outStatisticTypes: c4 });
    return C(_, c4, m5);
  }
  async createUniqueValuesResponse(e4) {
    const { field: t6, valueExpression: s7, domains: i3, returnAllCodedValues: a7, scale: r4, timeZone: n3 } = e4, o2 = await this._getDataValues({ field: t6, field2: e4.field2, field3: e4.field3, fieldDelimiter: e4.fieldDelimiter, valueExpression: s7, scale: r4, timeZone: n3 }, false), l6 = k(o2);
    return $(l6, i3, a7, e4.fieldDelimiter);
  }
  async createClassBreaksResponse(e4) {
    const { field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, classificationMethod: n3, standardDeviationInterval: o2, minValue: l6, maxValue: u6, numClasses: c4, scale: d5, timeZone: m5 } = e4, h3 = await this._getDataValues({ field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, scale: d5, timeZone: m5 }), g5 = E(h3, { field: t6, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, classificationMethod: n3, standardDeviationInterval: o2, minValue: l6, maxValue: u6, numClasses: c4 });
    return P(g5, n3);
  }
  async createHistogramResponse(e4) {
    const { field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, classificationMethod: n3, standardDeviationInterval: o2, minValue: l6, maxValue: u6, numBins: c4, scale: d5, timeZone: m5 } = e4, h3 = await this._getDataValues({ field: t6, valueExpression: s7, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, scale: d5, timeZone: m5 });
    return U(h3, { field: t6, normalizationField: i3, normalizationType: a7, normalizationTotal: r4, classificationMethod: n3, standardDeviationInterval: o2, minValue: l6, maxValue: u6, numBins: c4 });
  }
  _sortFeatures(e4, t6, s7) {
    if (e4.length > 1 && (t6 == null ? void 0 : t6.length)) for (const i3 of t6.reverse()) {
      const t7 = i3.split(" "), a7 = t7[0], r4 = this.fieldsIndex.get(a7), n3 = !!t7[1] && "desc" === t7[1].toLowerCase(), o2 = g2(r4 == null ? void 0 : r4.type, n3);
      e4.sort((e5, t8) => {
        const i4 = s7(e5, a7, r4), n4 = s7(t8, a7, r4);
        return o2(i4, n4);
      });
    }
  }
  _createFeatureQueryResponse(e4) {
    const t6 = this.items, { geometryType: s7, hasM: i3, hasZ: a7, objectIdField: n3, spatialReference: o2 } = this, { outFields: l6, outSR: c4, quantizationParameters: d5, resultRecordCount: m5, resultOffset: h3, returnZ: g5, returnM: p4 } = e4, f5 = null != m5 && t6.length > (h3 || 0) + m5, y5 = l6 && (l6.includes("*") ? [...this.fieldsIndex.fields] : l6.map((e5) => this.fieldsIndex.get(e5)));
    return { exceededTransferLimit: f5, features: this._createFeatures(e4, t6), fields: y5, geometryType: s7, hasM: i3 && p4, hasZ: a7 && g5, objectIdFieldName: n3, spatialReference: h(c4 || o2), transform: d5 && s4(d5) || null };
  }
  _createFeatures(e4, t6) {
    const s7 = new c2(e4, this.featureAdapter, this.fieldsIndex), { hasM: i3, hasZ: a7 } = this, { orderByFields: n3, quantizationParameters: o2, returnGeometry: u6, returnCentroid: m5, maxAllowableOffset: h3, resultOffset: g5, resultRecordCount: p4, returnZ: f5 = false, returnM: y5 = false } = e4, x3 = a7 && f5, I3 = i3 && y5;
    let T2 = [], V2 = 0;
    const F = [...t6];
    if (this._sortFeatures(F, n3, (e5, t7, i4) => s7.getFieldValue(e5, t7, i4)), this.geometryType && (u6 || m5)) {
      const e5 = s4(o2) ?? void 0, t7 = "esriGeometryPolygon" === this.geometryType || "esriGeometryPolyline" === this.geometryType;
      if (u6 && !m5) for (const i4 of F) {
        const a8 = this.featureAdapter.getGeometry(i4), r4 = { attributes: s7.getAttributes(i4), geometry: a5(this.geometryType, this.hasZ, this.hasM, a8, h3, e5, x3, I3) };
        t7 && a8 && !r4.geometry && (r4.centroid = y2(this, this.featureAdapter.getCentroid(i4, this), e5)), T2[V2++] = r4;
      }
      else if (!u6 && m5) for (const i4 of F) T2[V2++] = { attributes: s7.getAttributes(i4), centroid: y2(this, this.featureAdapter.getCentroid(i4, this), e5) };
      else for (const i4 of F) T2[V2++] = { attributes: s7.getAttributes(i4), centroid: y2(this, this.featureAdapter.getCentroid(i4, this), e5), geometry: a5(this.geometryType, this.hasZ, this.hasM, this.featureAdapter.getGeometry(i4), h3, e5, x3, I3) };
    } else for (const r4 of F) {
      const e5 = s7.getAttributes(r4);
      e5 && (T2[V2++] = { attributes: e5 });
    }
    const S2 = g5 || 0;
    if (null != p4) {
      const e5 = S2 + p4;
      T2 = T2.slice(S2, Math.min(T2.length, e5));
    }
    return T2;
  }
  _createExceedsLimitQueryResponse(e4) {
    let t6 = false, s7 = Number.POSITIVE_INFINITY, i3 = Number.POSITIVE_INFINITY, a7 = Number.POSITIVE_INFINITY;
    for (const r4 of e4.outStatistics ?? []) if ("exceedslimit" === r4.statisticType) {
      s7 = null != r4.maxPointCount ? r4.maxPointCount : Number.POSITIVE_INFINITY, i3 = null != r4.maxRecordCount ? r4.maxRecordCount : Number.POSITIVE_INFINITY, a7 = null != r4.maxVertexCount ? r4.maxVertexCount : Number.POSITIVE_INFINITY;
      break;
    }
    if ("esriGeometryPoint" === this.geometryType) t6 = this.items.length > s7;
    else if (this.items.length > i3) t6 = true;
    else {
      const e5 = C3(this.hasZ, this.hasM), s8 = this.featureAdapter;
      t6 = this.items.reduce((e6, t7) => {
        const i4 = s8.getGeometry(t7);
        return e6 + (null != i4 && i4.coords.length || 0);
      }, 0) / e5 > a7;
    }
    return { fields: [{ name: "exceedslimit", type: "esriFieldTypeInteger", alias: "exceedslimit", sqlType: "sqlTypeInteger", domain: null, defaultValue: null }], features: [{ attributes: { exceedslimit: Number(t6) } }] };
  }
  async _createStatisticsQueryResponse(e4) {
    var _a;
    const t6 = { attributes: {} }, s7 = [], i3 = /* @__PURE__ */ new Map(), a7 = /* @__PURE__ */ new Map(), r4 = /* @__PURE__ */ new Map(), n3 = /* @__PURE__ */ new Map(), o2 = new c2(e4, this.featureAdapter, this.fieldsIndex), u6 = e4.outStatistics, { groupByFieldsForStatistics: c4, having: d5, orderByFields: m5, resultRecordCount: h3 } = e4, g5 = c4 == null ? void 0 : c4.length, p4 = !!g5, f5 = p4 ? c4[0] : null, y5 = p4 && !this.fieldsIndex.get(f5);
    for (const l6 of u6 ?? []) {
      const { outStatisticFieldName: e5, statisticType: u7 } = l6, m6 = l6, h4 = "exceedslimit" !== u7 ? l6.onStatisticField : void 0, I4 = "percentile_disc" === u7 || "percentile_cont" === u7, T2 = "EnvelopeAggregate" === u7 || "CentroidAggregate" === u7 || "ConvexHullAggregate" === u7, V2 = p4 && 1 === g5 && (h4 === f5 || y5) && "count" === u7;
      if (p4) {
        if (!r4.has(h4)) {
          const e6 = [];
          for (const t8 of c4) {
            const s9 = this._getAttributeValues(o2, t8, i3);
            e6.push(s9);
          }
          r4.set(h4, this._calculateUniqueValues(e6, !T2 && o2.returnDistinctValues));
        }
        const t7 = r4.get(h4);
        if (!t7) continue;
        const s8 = Object.keys(t7);
        for (const a8 of s8) {
          const { count: s9, data: r5, items: l7, itemPositions: u8 } = t7[a8], g6 = r5.join(",");
          if (!d5 || o2.validateItems(l7, d5)) {
            const t8 = n3.get(g6) || { attributes: {} };
            if (T2) {
              t8.aggregateGeometries || (t8.aggregateGeometries = {});
              const { aggregateGeometries: e6, outStatisticFieldName: s10 } = await this._getAggregateGeometry(m6, l7);
              t8.aggregateGeometries[s10] = e6;
            } else {
              let a10 = null;
              if (V2) a10 = s9;
              else {
                const e6 = this._getAttributeValues(o2, h4, i3), t9 = u8.map((t10) => e6[t10]);
                a10 = I4 && "statisticParameters" in m6 ? this._getPercentileValue(m6, t9) : this._getStatisticValue(m6, t9, null, o2.returnDistinctValues);
              }
              t8.attributes[e5] = a10;
            }
            let a9 = 0;
            c4.forEach((e6, s10) => t8.attributes[this.fieldsIndex.get(e6) ? e6 : "EXPR_" + ++a9] = r5[s10]), n3.set(g6, t8);
          }
        }
      } else if (T2) {
        t6.aggregateGeometries || (t6.aggregateGeometries = {});
        const { aggregateGeometries: e6, outStatisticFieldName: s8 } = await this._getAggregateGeometry(m6, this.items);
        t6.aggregateGeometries[s8] = e6;
      } else {
        const s8 = this._getAttributeValues(o2, h4, i3);
        t6.attributes[e5] = I4 && "statisticParameters" in m6 ? this._getPercentileValue(m6, s8) : this._getStatisticValue(m6, s8, a7, o2.returnDistinctValues);
      }
      const F = "min" !== u7 && "max" !== u7 || !ye(this.fieldsIndex.get(h4)) && !this._isAnyDateField(h4) ? null : (_a = this.fieldsIndex.get(h4)) == null ? void 0 : _a.type;
      s7.push({ name: e5, alias: e5, type: F || "esriFieldTypeDouble" });
    }
    const I3 = p4 ? Array.from(n3.values()) : [t6];
    return this._sortFeatures(I3, m5, (e5, t7) => e5.attributes[t7]), h3 && (I3.length = Math.min(h3, I3.length)), { fields: s7, features: I3 };
  }
  _isAnyDateField(e4) {
    const t6 = this.fieldsIndex.get(e4);
    return ge(t6) || Fe(t6) || Ie(t6) || be(t6);
  }
  async _getAggregateGeometry(e4, r4) {
    const { convexHull: n3, union: o2 } = await import("./geometryEngineJSON-2KDFHAXE.js"), { statisticType: l6, outStatisticFieldName: u6 } = e4, { featureAdapter: d5, spatialReference: m5, geometryType: h3, hasZ: g5, hasM: p4 } = this, f5 = r4.map((e5) => a5(h3, g5, p4, d5.getGeometry(e5))), y5 = n3(m5, f5, true)[0], x3 = { aggregateGeometries: null, outStatisticFieldName: null };
    if ("EnvelopeAggregate" === l6) {
      const e5 = y5 ? v(y5) : l4(o2(m5, f5));
      x3.aggregateGeometries = { ...e5, spatialReference: m5 }, x3.outStatisticFieldName = u6 || "extent";
    } else if ("CentroidAggregate" === l6) {
      const e5 = y5 ? l3(y5) : r(l4(o2(m5, f5)));
      x3.aggregateGeometries = { x: e5[0], y: e5[1], spatialReference: m5 }, x3.outStatisticFieldName = u6 || "centroid";
    } else "ConvexHullAggregate" === l6 && (x3.aggregateGeometries = y5, x3.outStatisticFieldName = u6 || "convexHull");
    return x3;
  }
  _getStatisticValue(e4, t6, s7, i3) {
    const { onStatisticField: a7, statisticType: r4 } = e4;
    let n3 = null;
    n3 = (s7 == null ? void 0 : s7.has(a7)) ? s7.get(a7) : ye(this.fieldsIndex.get(a7)) || this._isAnyDateField(a7) ? f2({ values: t6, returnDistinct: i3 }) : p({ values: i3 ? [...new Set(t6)] : t6, minValue: null, maxValue: null, useSampleStdDev: true }), s7 && s7.set(a7, n3);
    return n3["var" === r4 ? "variance" : r4];
  }
  _getPercentileValue(e4, t6) {
    const { onStatisticField: s7, statisticParameters: i3, statisticType: a7 } = e4, { value: r4, orderBy: n3 } = i3, o2 = this.fieldsIndex.get(s7);
    return v2(t6, { value: r4, orderBy: n3, fieldType: o2 == null ? void 0 : o2.type, isDiscrete: "percentile_disc" === a7 });
  }
  _getAttributeValues(e4, t6, s7) {
    if (s7.has(t6)) return s7.get(t6);
    const i3 = this.fieldsIndex.get(t6), a7 = this.items.map((s8) => e4.getFieldValue(s8, t6, i3));
    return s7.set(t6, a7), a7;
  }
  _calculateUniqueValues(e4, t6) {
    const s7 = {}, i3 = this.items, a7 = i3.length;
    for (let r4 = 0; r4 < a7; r4++) {
      const a8 = i3[r4], n3 = [];
      for (const t7 of e4) n3.push(t7[r4]);
      const o2 = n3.join(",");
      null == s7[o2] ? s7[o2] = { count: 1, data: n3, items: [a8], itemPositions: [r4] } : (t6 || s7[o2].count++, s7[o2].items.push(a8), s7[o2].itemPositions.push(r4));
    }
    return s7;
  }
  async _getDataValues(t6, s7 = true) {
    const i3 = new c2(this.query, this.featureAdapter, this.fieldsIndex), { valueExpression: a7, scale: r4, timeZone: n3 } = t6;
    return a7 ? i3.getExpressionValues(this.items, a7, { viewingMode: "map", scale: r4, spatialReference: this.query.outSR || this.spatialReference }, { geometryType: this.geometryType, hasZ: this.hasZ, hasM: this.hasM }, n3) : i3.getDataValues(this.items, a(t6), s7);
  }
};
function N(e4, t6, s7, i3) {
  const a7 = i3.x - s7.x, r4 = i3.y - s7.y, n3 = a7 * a7 + r4 * r4, o2 = (t6.x - s7.x) * a7 + (t6.y - s7.y) * r4, l6 = Math.min(1, Math.max(0, o2 / n3));
  e4.x = s7.x + a7 * l6, e4.y = s7.y + r4 * l6;
}
function C3(e4, t6) {
  return e4 ? t6 ? 4 : 3 : t6 ? 3 : 2;
}
var G = class {
  constructor(e4, t6) {
    this.coords = e4, this.coordsIndex = t6;
  }
  get x() {
    return this.coords[this.coordsIndex];
  }
  get y() {
    return this.coords[this.coordsIndex + 1];
  }
  get z() {
    return this.coords[this.coordsIndex + 2];
  }
};

// node_modules/@arcgis/core/layers/graphics/data/queryValidationUtils.js
var u5 = "unsupported-query";
async function p3(t6, { fieldsIndex: i3, geometryType: s7, spatialReference: r4, availableFields: o2 }) {
  if ((t6.distance ?? 0) < 0 || null != t6.geometryPrecision || t6.multipatchOption && "xyFootprint" !== t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text) throw new s(u5, "Unsupported query options", { query: t6 });
  return c3(i3, o2, t6), f4(i3, o2, t6), Promise.all([v3(t6, s7, r4), x2(r4, t6.outSR)]).then(() => t6);
}
function c3(t6, i3, o2) {
  const { outFields: n3, orderByFields: a7, returnDistinctValues: l6, outStatistics: p4 } = o2, c4 = p4 ? p4.map((e4) => e4.outStatisticFieldName && e4.outStatisticFieldName.toLowerCase()).filter(Boolean) : [];
  if (a7 && a7.length > 0) {
    const e4 = " asc", r4 = " desc", n4 = a7.map((t7) => {
      const i4 = t7.toLowerCase();
      return i4.includes(e4) ? i4.split(e4)[0] : i4.includes(r4) ? i4.split(r4)[0] : t7;
    }).filter((e5) => !c4.includes(e5));
    g4(t6, i3, n4, { expressionName: "orderByFields", query: o2 });
  }
  if (n3 && n3.length > 0) g4(t6, i3, n3, { expressionName: "outFields", query: o2, allowedFieldTypes: "all" });
  else if (l6) throw new s(u5, "outFields should be specified for returnDistinctValues", { query: o2 });
  p2(t6, i3, o2.where, o2);
}
var d4 = /* @__PURE__ */ new Set([...o, ...a6]);
function f4(t6, i3, r4) {
  const { outStatistics: n3, groupByFieldsForStatistics: a7, having: l6 } = r4, p4 = a7 == null ? void 0 : a7.length, c4 = n3 == null ? void 0 : n3.length;
  if (l6) {
    if (!p4 || !c4) throw new s(u5, "outStatistics and groupByFieldsForStatistics should be specified with having", { query: r4 });
    f3(t6, i3, l6, n3, r4);
  }
  if (c4) {
    if (!h2(n3)) return;
    const o2 = n3.map((e4) => e4.onStatisticField).filter(Boolean);
    g4(t6, i3, o2, { expressionName: "onStatisticFields", query: r4 }), p4 && g4(t6, i3, a7, { expressionName: "groupByFieldsForStatistics", query: r4 });
    for (const a8 of n3) {
      const { onStatisticField: o3, statisticType: n4 } = a8;
      if (("percentile_disc" === n4 || "percentile_cont" === n4) && "statisticParameters" in a8) {
        const { statisticParameters: t7 } = a8;
        if (!t7) throw new s(u5, "statisticParameters should be set for percentile type", { definition: a8, query: r4 });
      } else t6.get(o3) && "count" !== n4 && "min" !== n4 && "max" !== n4 && g4(t6, i3, [o3], { expressionName: `outStatistics with '${n4}' statistic type`, allowedFieldTypes: d4, query: r4 });
    }
  }
}
async function m4(t6, i3, { fieldsIndex: s7, geometryType: r4, spatialReference: o2, availableFields: l6 }) {
  if ((t6.distance ?? 0) < 0 || null != t6.geometryPrecision || t6.multipatchOption || t6.pixelSize || t6.relationParam || t6.text || t6.outStatistics || t6.groupByFieldsForStatistics || t6.having || t6.orderByFields) throw new s(u5, "Unsupported query options", { query: t6 });
  return c3(s7, l6, t6), Promise.all([y4(s7, l6, i3, t6), v3(t6, r4, o2), x2(o2, t6.outSR)]).then(() => t6);
}
async function y4(t6, i3, r4, o2) {
  let n3 = [];
  if (r4.valueExpression) {
    const { arcadeUtils: e4 } = await i2();
    n3 = e4.extractFieldNames(r4.valueExpression);
  }
  if (r4.field && n3.push(r4.field), r4.field2 && n3.push(r4.field2), r4.field3 && n3.push(r4.field3), r4.normalizationField && n3.push(r4.normalizationField), !n3.length && !r4.valueExpression) throw new s(u5, "field or valueExpression is required", { params: r4 });
  g4(t6, i3, n3, { expressionName: "statistics", query: o2 });
}
function h2(e4) {
  return null != e4 && e4.every((e5) => "exceedslimit" !== e5.statisticType);
}

// node_modules/@arcgis/core/layers/graphics/data/QueryEngine.js
var N2 = "unsupported-query";
var V = class {
  constructor(e4) {
    this._cache = new t4(), this._changeHandle = null, this.capabilities = { query: t }, this.geometryType = e4.geometryType, this.hasM = !!e4.hasM, this.hasZ = !!e4.hasZ, this.objectIdField = e4.objectIdField, this.spatialReference = e4.spatialReference, this.definitionExpression = e4.definitionExpression, this.featureStore = e4.featureStore, this.aggregateAdapter = e4.aggregateAdapter, this._changeHandle = this.featureStore.events.on("changed", () => this.clearCache()), this.timeInfo = e4.timeInfo, this.fieldsIndex = a2(e4.fieldsIndex) ? e4.fieldsIndex : Z2.fromJSON(e4.fieldsIndex), !e4.availableFields || 1 === e4.availableFields.length && "*" === e4.availableFields[0] ? this.availableFields = new Set(this.fieldsIndex.fields.map((e5) => e5.name)) : this.availableFields = new Set(e4.availableFields.map((e5) => {
      var _a;
      return (_a = this.fieldsIndex.get(e5)) == null ? void 0 : _a.name;
    }).filter((e5) => null != e5)), e4.scheduler && e4.priority && (this._frameTask = e4.scheduler.registerTask(e4.priority));
  }
  destroy() {
    this._frameTask = l(this._frameTask), this.clearCache(), u(this._cache), this._changeHandle = l(this._changeHandle);
  }
  get featureAdapter() {
    return this.featureStore.featureAdapter;
  }
  clearCache() {
    this._cache.clear(), this._allFeaturesPromise = null, this._timeExtentPromise = null, this._fullExtentPromise = null;
  }
  async executeQuery(e4, t6) {
    const i3 = l2(t6);
    try {
      const t7 = await this._executeQuery(e4, {}, i3);
      return await t7.createQueryResponse();
    } catch (s7) {
      if (s7 !== g3) throw s7;
      return new q([], e4, this).createQueryResponse();
    }
  }
  async executeQueryForCount(e4 = {}, t6) {
    const i3 = l2(t6);
    try {
      return (await this._executeQuery(e4, { returnGeometry: false, returnCentroid: false, outSR: null }, i3)).createQueryResponseForCount();
    } catch (s7) {
      if (s7 !== g3) throw s7;
      return 0;
    }
  }
  async executeQueryForExtent(e4, t6) {
    const i3 = l2(t6), s7 = e4.outSR;
    try {
      const t7 = await this._executeQuery(e4, { returnGeometry: true, returnCentroid: false, outSR: null }, i3), r4 = t7.size;
      if (!r4) return { count: 0, extent: null };
      return { count: r4, extent: await this._getBounds(t7.items, t7.spatialReference, s7 || this.spatialReference) };
    } catch (r4) {
      if (r4 === g3) return { count: 0, extent: null };
      throw r4;
    }
  }
  async executeQueryForIds(e4, t6) {
    return this.executeQueryForIdSet(e4, t6).then((e5) => Array.from(e5));
  }
  async executeQueryForIdSet(e4, t6) {
    const i3 = l2(t6);
    try {
      const t7 = await this._executeQuery(e4, { returnGeometry: true, returnCentroid: false, outSR: null }, i3), s7 = t7.items, r4 = /* @__PURE__ */ new Set();
      return await this._reschedule(() => {
        for (const e5 of s7) r4.add(t7.featureAdapter.getObjectId(e5));
      }, i3), r4;
    } catch (s7) {
      if (s7 === g3) return /* @__PURE__ */ new Set();
      throw s7;
    }
  }
  async executeQueryForSnapping(e4, t6) {
    const i3 = l2(t6), { point: s7, distance: a7, returnEdge: n3, vertexMode: u6 } = e4;
    if (!n3 && "none" === u6) return { candidates: [] };
    let o2 = a(e4.query);
    o2 = await this._schedule(() => j2(o2, this.definitionExpression, this.spatialReference), i3), o2 = await this._reschedule(() => p3(o2, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i3);
    const h3 = !s3(s7.spatialReference, this.spatialReference);
    h3 && await x2(s7.spatialReference, this.spatialReference);
    const c4 = "number" == typeof a7 ? a7 : a7.x, m5 = "number" == typeof a7 ? a7 : a7.y, f5 = { xmin: s7.x - c4, xmax: s7.x + c4, ymin: s7.y - m5, ymax: s7.y + m5, spatialReference: s7.spatialReference }, d5 = h3 ? j(f5, this.spatialReference) : f5;
    if (!d5) return { candidates: [] };
    const y5 = (await R(f(s7), null, { signal: i3 }))[0], p4 = (await R(f(d5), null, { signal: i3 }))[0];
    if (null == y5 || null == p4) return { candidates: [] };
    const g5 = new q(await this._reschedule(() => this._searchFeatures(D(p4.toJSON())), i3), o2, this);
    await this._reschedule(() => this._executeObjectIdsQuery(g5), i3), await this._reschedule(() => this._executeTimeQuery(g5), i3), await this._reschedule(() => this._executeAttributesQuery(g5), i3), await this._reschedule(() => this._executeGeometryQueryForSnapping(g5, i3), i3);
    const _ = y5.toJSON(), w = h3 ? j(_, this.spatialReference) : _, R2 = h3 ? Math.max(d5.xmax - d5.xmin, d5.ymax - d5.ymin) / 2 : a7;
    return g5.createSnappingResponse({ ...e4, point: w, distance: R2 }, s7.spatialReference);
  }
  async executeQueryForLatestObservations(e4, t6) {
    var _a;
    const s7 = l2(t6);
    if (!((_a = this.timeInfo) == null ? void 0 : _a.trackIdField)) throw new s(N2, "Missing timeInfo or timeInfo.trackIdField", { query: e4, timeInfo: this.timeInfo });
    try {
      const t7 = await this._executeQuery(e4, {}, s7);
      return await this._reschedule(() => this._filterLatest(t7), s7), await t7.createQueryResponse();
    } catch (r4) {
      if (r4 !== g3) throw r4;
      return new q([], e4, this).createQueryResponse();
    }
  }
  async executeQueryForSummaryStatistics(e4 = {}, t6, i3) {
    const s7 = l2(i3), { field: r4, normalizationField: a7, valueExpression: n3 } = t6;
    return (await this._executeQueryForStatistics(e4, { field: r4, normalizationField: a7, valueExpression: n3 }, s7)).createSummaryStatisticsResponse(t6);
  }
  async executeQueryForUniqueValues(e4 = {}, t6, i3) {
    const s7 = l2(i3), { field: r4, field2: a7, field3: n3, valueExpression: u6 } = t6;
    return (await this._executeQueryForStatistics(e4, { field: r4, field2: a7, field3: n3, valueExpression: u6 }, s7)).createUniqueValuesResponse(t6);
  }
  async executeQueryForClassBreaks(e4 = {}, t6, i3) {
    const s7 = l2(i3), { field: r4, normalizationField: a7, valueExpression: n3 } = t6;
    return (await this._executeQueryForStatistics(e4, { field: r4, normalizationField: a7, valueExpression: n3 }, s7)).createClassBreaksResponse(t6);
  }
  async executeQueryForHistogram(e4 = {}, t6, i3) {
    const s7 = l2(i3), { field: r4, normalizationField: a7, valueExpression: n3 } = t6;
    return (await this._executeQueryForStatistics(e4, { field: r4, normalizationField: a7, valueExpression: n3 }, s7)).createHistogramResponse(t6);
  }
  async fetchRecomputedExtents(e4) {
    const t6 = l2(e4);
    this._timeExtentPromise || (this._timeExtentPromise = n(this.timeInfo, this.featureStore));
    const [i3, s7] = await Promise.all([this._getFullExtent(), this._timeExtentPromise]);
    return s2(t6), { fullExtent: i3, timeExtent: s7 };
  }
  async _getBounds(e4, t6, i3) {
    const s7 = d(u3(), K);
    await this.featureStore.forEachBounds(e4, (e5) => M2(s7, e5));
    const r4 = { xmin: s7[0], ymin: s7[1], xmax: s7[3], ymax: s7[4], spatialReference: h(this.spatialReference) };
    this.hasZ && isFinite(s7[2]) && isFinite(s7[5]) && (r4.zmin = s7[2], r4.zmax = s7[5], r4.hasZ = true);
    const a7 = j(r4, t6, i3);
    if (a7.spatialReference = h(i3), a7.xmax - a7.xmin == 0) {
      const e5 = z(a7.spatialReference);
      a7.xmin -= e5, a7.xmax += e5;
    }
    if (a7.ymax - a7.ymin == 0) {
      const e5 = z(a7.spatialReference);
      a7.ymin -= e5, a7.ymax += e5;
    }
    if (this.hasZ && null != a7.zmin && null != a7.zmax && a7.zmax - a7.zmin == 0) {
      const e5 = z(a7.spatialReference);
      a7.zmin -= e5, a7.zmax += e5;
    }
    return a7;
  }
  _getFullExtent() {
    return this._fullExtentPromise || (this._fullExtentPromise = "getFullExtent" in this.featureStore && this.featureStore.getFullExtent ? Promise.resolve(this.featureStore.getFullExtent(this.spatialReference)) : this._getAllFeatures().then((e4) => this._getBounds(e4, this.spatialReference, this.spatialReference))), this._fullExtentPromise;
  }
  async _schedule(e4, t6) {
    return null != this._frameTask ? this._frameTask.schedule(e4, t6) : e4(C2);
  }
  async _reschedule(e4, t6) {
    return null != this._frameTask ? this._frameTask.reschedule(e4, t6) : e4(C2);
  }
  async _getAllFeaturesQueryEngineResult(e4) {
    return new q(await this._getAllFeatures(), e4, this);
  }
  async _getAllFeatures() {
    if (null == this._allFeaturesPromise) {
      const e5 = [];
      this._allFeaturesPromise = (async () => {
        await this.featureStore.forEach((t7) => e5.push(t7));
      })().then(() => e5);
    }
    const e4 = this._allFeaturesPromise, t6 = await e4;
    return e4 === this._allFeaturesPromise ? t6.slice() : this._getAllFeatures();
  }
  async _executeQuery(e4, t6, i3) {
    e4 = a(e4), e4 = await this._schedule(() => S(e4, this.definitionExpression, this.spatialReference), i3), e4 = await this._reschedule(() => p3(e4, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i3), e4 = { ...e4, ...t6 };
    const s7 = await this._reschedule(() => this._executeSceneFilterQuery(e4, i3), i3), a7 = await this._reschedule(() => this._executeGeometryQuery(e4, s7, i3), i3);
    return await this._reschedule(() => this._executeAggregateIdsQuery(a7), i3), await this._reschedule(() => this._executeObjectIdsQuery(a7), i3), await this._reschedule(() => this._executeTimeQuery(a7), i3), await this._reschedule(() => this._executeAttributesQuery(a7), i3), a7;
  }
  async _executeSceneFilterQuery(e4, t6) {
    if (null == e4.sceneFilter) return null;
    const { outSR: i3, returnGeometry: s7, returnCentroid: r4 } = e4, a7 = this.featureStore.featureSpatialReference, n3 = e4.sceneFilter.geometry, l6 = null == a7 || s3(a7, n3.spatialReference) ? n3 : j(n3, a7);
    if (!l6) return null;
    const u6 = s7 || r4, o2 = g(i3) && !s3(this.spatialReference, i3) && u6 ? async (e5) => this._project(e5, i3) : (e5) => e5, h3 = this.featureAdapter, c4 = await this._reschedule(() => this._searchFeatures(D(l6)), t6);
    if ("disjoint" === e4.sceneFilter.spatialRelationship) {
      if (!c4.length) return null;
      const i4 = /* @__PURE__ */ new Set();
      for (const e5 of c4) i4.add(h3.getObjectId(e5));
      const s8 = await this._reschedule(() => this._getAllFeatures(), t6), r5 = await this._reschedule(async () => {
        const r6 = await P2("esriSpatialRelDisjoint", l6, this.geometryType, this.hasZ, this.hasM), a8 = (e5) => !i4.has(h3.getObjectId(e5)) || r6(h3.getGeometry(e5)), n4 = await this._runSpatialFilter(s8, a8, t6);
        return new q(n4, e4, this);
      }, t6);
      return o2(r5);
    }
    if (!c4.length) return new q([], e4, this);
    if (this._canExecuteSinglePass(l6, e4)) return o2(new q(c4, e4, this));
    const m5 = await P2("esriSpatialRelContains", l6, this.geometryType, this.hasZ, this.hasM), f5 = await this._runSpatialFilter(c4, (e5) => m5(h3.getGeometry(e5)), t6);
    return o2(new q(f5, e4, this));
  }
  async _executeGeometryQuery(i3, s7, r4) {
    if (null != s7 && 0 === s7.items.length) return s7;
    i3 = null != s7 ? s7.query : i3;
    const { geometry: a7, outSR: n3, spatialRel: l6, returnGeometry: u6, returnCentroid: o2 } = i3, h3 = this.featureStore.featureSpatialReference, c4 = !a7 || null == h3 || s3(h3, a7.spatialReference) ? a7 : j(a7, h3), m5 = u6 || o2, f5 = g(n3) && !s3(this.spatialReference, n3), d5 = null == s7 ? this._getCacheKey(i3) : null, y5 = d5 ? this._cache.get(d5) : null;
    if (null != y5) return new q(y5, i3, this);
    const p4 = async (e4) => (f5 && m5 && await this._project(e4, n3), d5 && this._cache.put(d5, e4.items), e4);
    if (!c4) return p4(null != s7 ? s7 : await this._getAllFeaturesQueryEngineResult(i3));
    const g5 = this.featureAdapter;
    let x3 = await this._reschedule(() => this._searchFeatures(D(a7)), r4);
    if ("esriSpatialRelDisjoint" === l6) {
      if (!x3.length) return p4(null != s7 ? s7 : await this._getAllFeaturesQueryEngineResult(i3));
      const e4 = /* @__PURE__ */ new Set();
      for (const i4 of x3) e4.add(g5.getObjectId(i4));
      const t6 = null != s7 ? s7.items : await this._reschedule(() => this._getAllFeatures(), r4), a8 = await this._reschedule(async () => {
        const s8 = await P2(l6, c4, this.geometryType, this.hasZ, this.hasM), a9 = (t7) => !e4.has(g5.getObjectId(t7)) || s8(g5.getGeometry(t7)), n4 = await this._runSpatialFilter(t6, a9, r4);
        return new q(n4, i3, this);
      }, r4);
      return p4(a8);
    }
    if (null != s7) {
      const i4 = new M();
      x3 = x3.filter((t6) => x(s7.items, t6, s7.items.length, i4) >= 0);
    }
    if (!x3.length) {
      const e4 = new q([], i3, this);
      return d5 && this._cache.put(d5, e4.items), e4;
    }
    if (this._canExecuteSinglePass(c4, i3)) return p4(new q(x3, i3, this));
    const _ = await P2(l6, c4, this.geometryType, this.hasZ, this.hasM), w = await this._runSpatialFilter(x3, (e4) => _(g5.getGeometry(e4)), r4);
    return p4(new q(w, i3, this));
  }
  async _executeGeometryQueryForSnapping(e4, t6) {
    var _a;
    const { query: i3 } = e4, { spatialRel: s7 } = i3;
    if (!((_a = e4 == null ? void 0 : e4.items) == null ? void 0 : _a.length) || !i3.geometry || !s7) return;
    const r4 = await P2(s7, i3.geometry, this.geometryType, this.hasZ, this.hasM), a7 = await this._runSpatialFilter(e4.items, (e5) => r4(e5.geometry), t6);
    e4.items = a7;
  }
  _executeAggregateIdsQuery(e4) {
    var _a;
    if (0 === e4.items.length || !((_a = e4.query.aggregateIds) == null ? void 0 : _a.length) || null == this.aggregateAdapter) return;
    const t6 = /* @__PURE__ */ new Set();
    for (const s7 of e4.query.aggregateIds) {
      this.aggregateAdapter.getFeatureObjectIds(s7).forEach((e5) => t6.add(e5));
    }
    const i3 = this.featureAdapter.getObjectId;
    e4.items = e4.items.filter((e5) => t6.has(i3(e5)));
  }
  _executeObjectIdsQuery(e4) {
    var _a;
    if (0 === e4.items.length || !((_a = e4.query.objectIds) == null ? void 0 : _a.length)) return;
    const t6 = new Set(e4.query.objectIds), i3 = this.featureAdapter.getObjectId;
    e4.items = e4.items.filter((e5) => t6.has(i3(e5)));
  }
  _executeTimeQuery(e4) {
    if (0 === e4.items.length) return;
    const t6 = t2(this.timeInfo, e4.query.timeExtent, this.featureAdapter);
    null != t6 && (e4.items = e4.items.filter(t6));
  }
  _executeAttributesQuery(e4) {
    if (0 === e4.items.length) return;
    const t6 = c(e4.query.where, this.fieldsIndex);
    if (t6) {
      if (!t6.isStandardized) throw new TypeError("Where clause is not standardized");
      e4.items = e4.items.filter((e5) => t6.testFeature(e5, this.featureAdapter));
    }
  }
  async _runSpatialFilter(e4, t6, i3) {
    if (!t6) return e4;
    if (null == this._frameTask) return e4.filter((e5) => t6(e5));
    let s7 = 0;
    const r4 = new Array(), a7 = async (n3) => {
      for (; s7 < e4.length; ) {
        const l6 = e4[s7++];
        t6(l6) && (r4.push(l6), n3.madeProgress()), n3.done && await this._reschedule((e5) => a7(e5), i3);
      }
    };
    return this._reschedule((e5) => a7(e5), i3).then(() => r4);
  }
  _filterLatest(e4) {
    const { trackIdField: t6, startTimeField: i3, endTimeField: s7 } = this.timeInfo, r4 = s7 || i3, a7 = /* @__PURE__ */ new Map(), n3 = this.featureAdapter.getAttribute;
    for (const l6 of e4.items) {
      const e5 = n3(l6, t6), i4 = n3(l6, r4), s8 = a7.get(e5);
      (!s8 || i4 > n3(s8, r4)) && a7.set(e5, l6);
    }
    e4.items = Array.from(a7.values());
  }
  _getCacheKey(e4) {
    const { geometry: t6, spatialRel: i3, returnGeometry: s7, returnCentroid: r4, outSR: a7, resultType: n3, cacheHint: l6 } = e4;
    if ("tile" !== n3 && !l6) return null;
    const u6 = s7 || r4;
    return g(a7) && !s3(this.spatialReference, a7) && u6 ? JSON.stringify([t6, i3, a7]) : JSON.stringify([t6, i3]);
  }
  _canExecuteSinglePass(e4, t6) {
    const { spatialRel: i3 } = t6;
    return I2(e4) && ("esriSpatialRelEnvelopeIntersects" === i3 || "esriGeometryPoint" === this.geometryType && ("esriSpatialRelIntersects" === i3 || "esriSpatialRelContains" === i3));
  }
  async _project(e4, t6) {
    if (!t6 || s3(this.spatialReference, t6)) return e4;
    const i3 = this.featureAdapter;
    let s7;
    try {
      const e5 = await this._getFullExtent();
      s7 = Y(this.spatialReference, t6, e5);
    } catch {
    }
    const r4 = await b(e4.items.map((e5) => a5(this.geometryType, this.hasZ, this.hasM, i3.getGeometry(e5))), this.spatialReference, t6, s7);
    return e4.items = r4.map((t7, s8) => i3.cloneWithGeometry(e4.items[s8], ot(t7, this.hasZ, this.hasM))), e4;
  }
  async _searchFeatures(e4) {
    const t6 = /* @__PURE__ */ new Set();
    await Promise.all(e4.map((e5) => this.featureStore.forEachInBounds(e5, (e6) => t6.add(e6))));
    const i3 = Array.from(t6.values());
    return t6.clear(), i3;
  }
  async _executeQueryForStatistics(e4, t6, i3) {
    e4 = a(e4);
    try {
      e4 = await this._schedule(() => S(e4, this.definitionExpression, this.spatialReference), i3), e4 = await this._reschedule(() => m4(e4, t6, { availableFields: this.availableFields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, spatialReference: this.spatialReference }), i3);
      const s7 = await this._reschedule(() => this._executeSceneFilterQuery(e4, i3), i3), r4 = await this._reschedule(() => this._executeGeometryQuery(e4, s7, i3), i3);
      return await this._reschedule(() => this._executeAggregateIdsQuery(r4), i3), await this._reschedule(() => this._executeObjectIdsQuery(r4), i3), await this._reschedule(() => this._executeTimeQuery(r4), i3), await this._reschedule(() => this._executeAttributesQuery(r4), i3), r4;
    } catch (s7) {
      if (s7 !== g3) throw s7;
      return new q([], e4, this);
    }
  }
};
function D(e4) {
  if (I2(e4)) {
    if (m(e4)) return [a3(Math.min(e4.xmin, e4.xmax), Math.min(e4.ymin, e4.ymax), Math.max(e4.xmin, e4.xmax), Math.max(e4.ymin, e4.ymax))];
    if (y(e4)) return e4.rings.map((e5) => a3(Math.min(e5[0][0], e5[2][0]), Math.min(e5[0][1], e5[2][1]), Math.max(e5[0][0], e5[2][0]), Math.max(e5[0][1], e5[2][1])));
  }
  return [a4(u2(), e4)];
}

export {
  V
};
//# sourceMappingURL=chunk-NW6OWOSJ.js.map
