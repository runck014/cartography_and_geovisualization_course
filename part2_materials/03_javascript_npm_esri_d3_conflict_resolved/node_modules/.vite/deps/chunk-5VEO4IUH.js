import {
  i as i5
} from "./chunk-2XVRGGEF.js";
import {
  t as t3
} from "./chunk-6TRZLPPJ.js";
import {
  C as C2
} from "./chunk-MCHNAU6L.js";
import {
  t as t4
} from "./chunk-MYNRH67A.js";
import {
  e as e3,
  i as i2,
  r as r2
} from "./chunk-VAGIPHHR.js";
import {
  s as s2
} from "./chunk-KI5F6KDS.js";
import {
  A as A2,
  B as B2,
  C,
  F,
  G as G3,
  H,
  L,
  N as N2,
  P as P2,
  S as S2,
  T as T2,
  g as g2,
  i as i3,
  k,
  p,
  w as w2,
  x
} from "./chunk-2RIHQI4N.js";
import {
  B,
  E,
  K,
  N,
  P,
  Q,
  R,
  T,
  U,
  Y as Y2,
  Z,
  a as a4,
  b,
  ie,
  l as l3,
  m as m2,
  oe,
  r,
  te,
  u as u4,
  w,
  y as y2
} from "./chunk-VLKWWBLY.js";
import {
  u as u5
} from "./chunk-P2IB5HBH.js";
import {
  a as a5,
  n as n3
} from "./chunk-73FHIZIF.js";
import {
  M,
  e as e4,
  i as i4,
  s as s4
} from "./chunk-ICIPRMPO.js";
import {
  n as n4
} from "./chunk-EHD5KM2T.js";
import {
  A,
  G as G2,
  X,
  Y,
  si,
  yi,
  zi
} from "./chunk-CGJUTDVJ.js";
import {
  S,
  o
} from "./chunk-LP6TMAPE.js";
import {
  m2 as m3,
  s as s3
} from "./chunk-AVBIV2K3.js";
import {
  e as e2,
  u as u3
} from "./chunk-YVSEBNS4.js";
import {
  l as l2,
  m,
  s,
  u as u2,
  y
} from "./chunk-3L2AYCZY.js";
import {
  a as a3,
  c,
  f as f2,
  f2 as f4,
  i,
  l,
  n as n2,
  t as t2,
  v2 as v
} from "./chunk-VUJERGGB.js";
import {
  f,
  h
} from "./chunk-NTI2OCVI.js";
import {
  a as a2,
  f as f3,
  u
} from "./chunk-ZCHZRNUG.js";
import {
  G
} from "./chunk-FG3XOAFD.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  e2 as e
} from "./chunk-7LJCT7EA.js";
import {
  a,
  n2 as n
} from "./chunk-PKLD5YJF.js";
import {
  has,
  t
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/symbols/cim/effects/EffectAddControlPoints.js
var e5 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e13, s13, n18, i16, o8) {
    return new t5(e13, s13, n18);
  }
};
e5.instance = null;
var t5 = class {
  constructor(e13, t15, s13) {
    this._inputGeometries = e13, this._angleTolerance = void 0 !== t15.angleTolerance ? t15.angleTolerance : 120, this._maxCosAngle = Math.cos((1 - Math.abs(this._angleTolerance) / 180) * Math.PI);
  }
  next() {
    let e13 = this._inputGeometries.next();
    for (; e13; ) {
      if ("esriGeometryPolygon" === e13.geometryType) this._isClosed = true;
      else if ("esriGeometryPolyline" === e13.geometryType) this._isClosed = false;
      else {
        if ("esriGeometryEnvelope" !== e13.geometryType) {
          e13 = this._inputGeometries.next();
          continue;
        }
        if (this._maxCosAngle) return e13;
        this._isClosed = true;
      }
      for (; e13.nextPath(); ) this._processPath(e13);
      return e13.reset(), e13;
    }
    return null;
  }
  _processPath(e13) {
    if (e13.nextPoint()) {
      const t15 = e13.x, s13 = e13.y;
      let n18 = t15, i16 = s13, o8 = e13.pathSize, l12 = 0, r18 = 0, a12 = 0, h8 = 0, c5 = 0, _6 = 0;
      this._isClosed && ++o8;
      for (let u13 = 1; e13.nextPoint() || u13 < o8; ++u13) {
        let x4, m7;
        this._isClosed && u13 === o8 - 1 ? (x4 = t15, m7 = s13) : (x4 = e13.x, m7 = e13.y);
        const y6 = x4 - n18, g5 = m7 - i16, C4 = Math.sqrt(y6 * y6 + g5 * g5);
        if (u13 > 1 && C4 > 0 && a12 > 0) {
          (l12 * y6 + r18 * g5) / C4 / a12 <= this._maxCosAngle && e13.setControlPointAt(u13 - 1);
        }
        1 === u13 && (h8 = y6, c5 = g5, _6 = C4), C4 > 0 && (n18 = x4, i16 = m7, l12 = y6, r18 = g5, a12 = C4);
      }
      if (this._isClosed && a12 > 0 && _6 > 0) {
        (l12 * h8 + r18 * c5) / _6 / a12 <= this._maxCosAngle && e13.setControlPointAt(0);
      }
    }
  }
};

// node_modules/@arcgis/core/geometry/GeometryCursor.js
var a6 = class {
  static fromOptimized(t15, e13, s13 = false, i16 = false, h8 = 1) {
    return new p2().initialize(t15, e13, s13, i16, h8);
  }
  static fromJSON(t15, e13 = false, s13 = false) {
    const [i16, h8] = u6(t15);
    return new c2().initialize(i16, h8, e13, s13, 1);
  }
  static fromOptimizedCIM(t15, e13, s13 = false, i16 = false, h8 = 1) {
    return new y3().initialize(t15, e13, s13, i16, h8);
  }
  static fromJSONCIM(t15, e13 = false, s13 = false, i16 = 1) {
    const [h8, r18] = u6(t15);
    return new m4().initialize(h8, r18, e13, s13, i16);
  }
  static fromFeatureSetReader(t15) {
    const e13 = t15.readGeometryForDisplay(), s13 = t15.geometryType;
    return e13 && s13 ? this.fromOptimized(e13, s13) : null;
  }
  static fromFeatureSetReaderCIM(t15) {
    const e13 = t15.readGeometryForDisplay(), s13 = t15.geometryType;
    return e13 && s13 ? this.fromOptimizedCIM(e13, s13) : null;
  }
  static createEmptyOptimized(t15, e13 = false, s13 = false, i16 = 1) {
    return new p2().initialize(new s2(), t15, e13, s13, i16);
  }
  static createEmptyJSON(t15, e13 = false, s13 = false) {
    return new c2().initialize([], t15, e13, s13, 1);
  }
  static createEmptyOptimizedCIM(t15, e13 = false, s13 = false, i16 = 1) {
    return new y3().initialize(new s2(), t15, e13, s13, i16);
  }
  static createEmptyJSONCIM(t15, e13 = false, s13 = false, i16 = 1) {
    return new m4().initialize([], t15, e13, s13, i16);
  }
  asJSON() {
    const t15 = t2(this);
    return "esriGeometryEnvelope" === this.geometryType ? { xmin: t15[0][0][0], ymin: t15[0][0][1], xmax: t15[0][2][0], ymax: t15[0][2][1] } : "esriGeometryMultipoint" === this.geometryType ? { points: t15.flat() } : "esriGeometryPoint" === this.geometryType ? { x: t15[0][0][0], y: t15[0][0][1] } : "esriGeometryPolygon" === this.geometryType ? { rings: t15 } : { paths: t15 };
  }
  getCurrentRingArea() {
    if (this.pathSize < 3) return 0;
    let t15, e13, s13 = 0;
    if (this.seekPathStart(), !this.nextPoint()) return 0;
    t15 = this.x, e13 = this.y;
    const i16 = t15, h8 = e13;
    for (; this.nextPoint(); ) s13 += (t15 - this.x) * (e13 + this.y), t15 = this.x, e13 = this.y;
    return s13 += (t15 - i16) * (e13 + h8), -0.5 * s13;
  }
  invertY() {
    this.yFactor *= -1;
  }
};
var p2 = class _p extends a6 {
  constructor() {
    super(...arguments), this._end = -1;
  }
  initialize(t15, e13, s13, i16, h8) {
    return this.hasZ = s13, this.hasM = i16, this.geometryType = e13, this._stride = 2 + Number(s13) + Number(i16), this._geometry = t15, this._pathIndex = -1, this._pathOffset = 0, this._pointOffset = -this._stride, this._end = -1, this.yFactor = h8, this;
  }
  reset() {
    this.initialize(this._geometry, this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  seekPath(t15) {
    if (t15 >= 0 && t15 < this.totalSize) {
      if (this._pathIndex < t15) for (; this._pathIndex < t15 && this.nextPath(); ) ;
      else if (this._pathIndex > t15) for (; this._pathIndex > t15 && this.prevPath(); ) ;
      return true;
    }
    return false;
  }
  seekPathStart() {
    this._pointOffset = this._pathOffset - this._stride;
  }
  seekPathEnd() {
    this._pointOffset = this._end;
  }
  seekInPath(t15) {
    const e13 = this._pathOffset + t15 * this._stride;
    return e13 >= 0 && e13 < this._end && (this._pointOffset = e13, true);
  }
  nextPoint() {
    return (this._pointOffset += this._stride) < this._end;
  }
  prevPoint() {
    return (this._pointOffset -= this._stride) >= this._pathOffset;
  }
  nextPath() {
    return !(this.pathIndex >= this.totalSize - 1) && (this._pathIndex >= 0 && (this._pathOffset += this._stride * this.pathSize), this._pathIndex++, this._pointOffset = this._pathOffset - this._stride, this._end = this._pointOffset + this._stride + this._stride * this.pathSize, true);
  }
  prevPath() {
    return !(this.pathIndex <= 0) && (this._pathIndex--, this._end = this._pathOffset, this._pathOffset -= this._stride * this.pathSize, this._pointOffset = this._pathOffset - this._stride, true);
  }
  getCurrentPath() {
    const t15 = this._end, e13 = this._geometry.coords, s13 = this._pathOffset;
    return new _p().initialize(new s2([this.pathSize], e13.slice(s13, t15)), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  pathLength() {
    const t15 = this._end, e13 = this._stride, s13 = this._geometry.coords;
    let i16 = 0;
    for (let h8 = this._pathOffset + e13; h8 < t15; h8 += e13) {
      const t16 = s13[h8 - e13], r18 = s13[h8 - e13 + 1], n18 = s13[h8] - t16, o8 = s13[h8 + 1] - r18;
      i16 += Math.sqrt(n18 * n18 + o8 * o8);
    }
    return i16;
  }
  startPath() {
    this._geometry.lengths.push(0);
  }
  pushPath(t15) {
    this.startPath(), this.pushPoints(t15);
  }
  pushPoint(t15) {
    for (let e13 = 0; e13 < this._stride; ++e13) this._geometry.coords.push(t15[e13]);
    this._geometry.lengths[this.totalSize - 1]++;
  }
  pushXY(t15, e13) {
    this._geometry.coords.push(t15, e13), this._geometry.lengths[this.totalSize - 1]++;
  }
  pushPoints(t15) {
    for (const e13 of t15) for (let t16 = 0; t16 < this._stride; ++t16) this._geometry.coords.push(e13[t16]);
    this._geometry.lengths[this.totalSize - 1] += t15.length;
  }
  pushCursor(t15) {
    const e13 = t15.asOptimized();
    this._geometry.coords.push(...e13.coords), this._geometry.lengths.push(...e13.lengths);
  }
  asOptimized() {
    const t15 = this._geometry.clone();
    if (1 !== this.yFactor) for (let e13 = 1; e13 < t15.coords.length; e13 += this._stride) t15.coords[e13] *= this.yFactor;
    return "esriGeometryPoint" === this.geometryType && (t15.lengths.length = 0), t15;
  }
  isClosed() {
    const t15 = this._geometry.coords, e13 = this._pathOffset, s13 = this._end - this._stride;
    for (let i16 = 0; i16 < this._stride; i16++) if (t15[e13 + i16] !== t15[s13 + i16]) return false;
    return true;
  }
  clone() {
    return new _p().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._geometry.isPoint ? 1 : this._geometry.lengths.reduce((t15, e13) => t15 + e13);
  }
  get pathSize() {
    const { lengths: t15 } = this._geometry;
    return this._geometry.isPoint ? 1 : this._pathIndex < 0 || this._pathIndex > t15.length - 1 ? 0 : t15[this._pathIndex];
  }
  get totalSize() {
    return this._geometry.isPoint ? 1 : this._geometry.lengths.length;
  }
  get x() {
    return this._geometry.coords[this._pointOffset];
  }
  set x(t15) {
    this._geometry.coords[this._pointOffset] = t15;
  }
  get y() {
    return this.yFactor * this._geometry.coords[this._pointOffset + 1];
  }
  set y(t15) {
    this._geometry.coords[this._pointOffset + 1] = this.yFactor * t15;
  }
  get z() {
    return this._geometry.coords[this._pointOffset + 2];
  }
  set z(t15) {
    this._geometry.coords[this._pointOffset + 2] = t15;
  }
  get m() {
    const t15 = this.hasZ ? 3 : 2;
    return this._geometry.coords[this._pointOffset + t15];
  }
  set m(t15) {
    this._geometry.coords[this._pointOffset + 3] = t15;
  }
  get pathIndex() {
    return this._pathIndex;
  }
  get _coordIndex() {
    return this._pointOffset / this._stride;
  }
};
function _(t15) {
  const e13 = [t15.x, t15.y];
  return t15.z && e13.push(t15.z), t15.m && e13.push(t15.m), e13;
}
function u6(t15) {
  return y(t15) ? [t15.rings, "esriGeometryPolygon"] : s(t15) ? [t15.paths, "esriGeometryPolyline"] : l2(t15) ? [[t15.points], "esriGeometryMultipoint"] : m(t15) ? [[[[t15.xmin, t15.ymin], [t15.xmin, t15.ymax], [t15.xmax, t15.ymax], [t15.xmax, t15.ymin], [t15.xmin, t15.ymin]]], "esriGeometryEnvelope"] : u2(t15) ? [[[_(t15)]], "esriGeometryPoint"] : [[], "esriGeometryPolyline"];
}
var c2 = class _c extends a6 {
  initialize(t15, e13, s13, i16, h8) {
    return this._paths = t15, this.geometryType = e13, this.hasZ = s13, this.hasM = i16, this._pathIndex = this._pointIndex = -1, this.yFactor = h8, this._mIndex = this.hasZ ? 3 : 2, this;
  }
  reset() {
    this._pathIndex = this._pointIndex = -1;
  }
  seekPath(t15) {
    return this._pathIndex = t15, this._pointIndex = -1, t15 >= 0 && t15 < this.totalSize && (this._currentPath = this._paths[t15], true);
  }
  seekPathStart() {
    this._pointIndex = -1;
  }
  seekPathEnd() {
    this._pointIndex = this._currentPath.length;
  }
  seekInPath(t15) {
    return t15 >= 0 && t15 < this._currentPath.length && (this._pointIndex = t15, this._currentPoint = this._currentPath[this._pointIndex], true);
  }
  nextPoint() {
    return this._currentPoint = this._currentPath[++this._pointIndex], this._pointIndex < this._currentPath.length;
  }
  prevPoint() {
    return this._currentPoint = this._currentPath[--this._pointIndex], this._pointIndex >= 0;
  }
  nextPath() {
    return this._pointIndex = -1, this._currentPath = this._paths[++this._pathIndex], this._pathIndex < this.totalSize;
  }
  prevPath() {
    return this.pathIndex > 0 && (this._pointIndex = -1, this._pathIndex--, this._currentPath = this._paths[this._pathIndex], true);
  }
  pathLength() {
    const t15 = this._currentPath.length, e13 = this._currentPath;
    let s13 = 0;
    for (let i16 = 1; i16 < t15; i16++) {
      const t16 = e13[i16 - 1], h8 = e13[i16], r18 = t16[0], n18 = t16[1], o8 = h8[0] - r18, a12 = h8[1] - n18;
      s13 += Math.sqrt(o8 * o8 + a12 * a12);
    }
    return s13;
  }
  startPath() {
    this._paths.push([]);
  }
  getCurrentPath() {
    return new _c().initialize([this._currentPath], this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  pushPath(t15) {
    this._paths.push(t15);
  }
  pushPoint(t15) {
    this._paths[this.totalSize - 1].push(t15);
  }
  pushXY(t15, e13) {
    this._paths[this.totalSize - 1].push([t15, e13]);
  }
  pushPoints(t15) {
    this._paths[this.totalSize - 1].push(...t15);
  }
  pushCursor(t15) {
    const s13 = t2(t15);
    for (const e13 of s13) this.pushPath(e13);
  }
  asOptimized() {
    const t15 = new s2();
    if ("esriGeometryPoint" === this.geometryType) t15.coords.push(...this._paths[0][0]), t15.lengths.length = 0;
    else for (const e13 of this._paths) {
      for (const s13 of e13) t15.coords.push(s13[0]), t15.coords.push(s13[1] * this.yFactor), this.hasZ && t15.coords.push(s13[2]), this.hasM && t15.coords.push(s13[this._mIndex]);
      t15.lengths.push(e13.length);
    }
    return t15;
  }
  isClosed() {
    const t15 = this._currentPath[0], e13 = this._currentPath[this._currentPath.length - 1];
    for (let s13 = 0; s13 < t15.length; s13++) if (t15[s13] !== e13[s13]) return false;
    return true;
  }
  clone() {
    return new _c().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  get totalPoints() {
    return this._paths.map((t15) => t15.length).reduce((t15, e13) => t15 + e13);
  }
  get pathSize() {
    return this._pathIndex < 0 || this._pathIndex > this.totalSize - 1 ? -1 : this._paths[this._pathIndex].length;
  }
  get totalSize() {
    return this._paths.length;
  }
  get x() {
    return this._currentPoint[0];
  }
  set x(t15) {
    this._currentPoint[0] = t15;
  }
  get y() {
    return this.yFactor * this._currentPoint[1];
  }
  set y(t15) {
    this._currentPoint[1] = this.yFactor * t15;
  }
  get z() {
    return this._currentPoint[2];
  }
  set z(t15) {
    this._currentPoint[2] = t15;
  }
  get m() {
    return this._currentPoint[this._mIndex];
  }
  set m(t15) {
    this._currentPoint[this._mIndex] = t15;
  }
  get pathIndex() {
    return this._pathIndex;
  }
};
var d = 4;
var l4 = 1;
var y3 = class _y extends p2 {
  initialize(t15, e13, s13, i16, h8) {
    return super.initialize(t15, e13, s13, i16, h8), this._controlPoints || (this._controlPoints = this._controlPoints = new Array(this.totalSize).fill(void 0).map((t16) => /* @__PURE__ */ new Set())), this;
  }
  startPath() {
    super.startPath(), this._controlPoints.push(/* @__PURE__ */ new Set());
  }
  clone() {
    const t15 = new _y().initialize(this._geometry.clone(), this.geometryType, this.hasZ, this.hasM, this.yFactor);
    return t15._controlPoints = this._controlPoints, t15;
  }
  setControlPoint() {
    this._controlPoints[this.pathIndex].add(this._coordIndex);
  }
  getControlPoint() {
    return this._controlPoints[this.pathIndex].has(this._coordIndex);
  }
  setControlPointAt(t15) {
    this._controlPoints[this.pathIndex].add(t15);
  }
  getControlPointAt(t15) {
    return this._controlPoints[this.pathIndex].has(t15);
  }
};
var m4 = class _m extends c2 {
  initialize(t15, e13, s13, i16, h8) {
    return super.initialize(t15, e13, s13, i16, h8);
  }
  clone() {
    return new _m().initialize(a(this._paths), this.geometryType, this.hasZ, this.hasM, this.yFactor);
  }
  setControlPoint() {
    this._paths[this.pathIndex][this._pointIndex][d] = l4;
  }
  getControlPoint() {
    return this._paths[this.pathIndex][this._pointIndex][d] === l4;
  }
  setControlPointAt(t15) {
    this._paths[this.pathIndex][t15][d] = l4;
  }
  getControlPointAt(t15) {
    return this._paths[this.pathIndex][t15][d] === l4;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMPlacements.js
var t6 = class {
  constructor() {
    this.setIdentity();
  }
  getAngle() {
    return (null == this.rz || 0 === this.rz && 1 !== this.rzCos && 0 !== this.rzSin) && (this.rz = Math.atan2(this.rzSin, this.rzCos)), this.rz;
  }
  setIdentity() {
    this.tx = 0, this.ty = 0, this.tz = 0, this.s = 1, this.rx = 0, this.ry = 0, this.rz = 0, this.rzCos = 1, this.rzSin = 0;
  }
  setTranslate(t15, s13) {
    this.tx = t15, this.ty = s13;
  }
  setTranslateZ(t15) {
    this.tz = t15;
  }
  setRotateCS(t15, s13) {
    this.rz = void 0, this.rzCos = t15, this.rzSin = s13;
  }
  setRotate(t15) {
    this.rz = t15, this.rzCos = void 0, this.rzSin = void 0;
  }
  setRotateY(t15) {
    this.ry = t15;
  }
  setScale(t15) {
    this.s = t15;
  }
  setMeasure(t15) {
    this.m = t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMCursor.js
function i6(t15, e13) {
  t15[4] = e13;
}
var r3 = class {
  constructor(e13, i16 = true, r18 = true, s13 = 0) {
    this.isClosed = false, this.geometryCursor = null, this.geometryCursor = !i16 && "esriGeometryPolygon" === e13.geometryType || !r18 && "esriGeometryPolyline" === e13.geometryType ? null : e13, this.geomUnitsPerPoint = s13, this.iterateMultiPath = false, this.iteratePath = false, this.internalPlacement = new t6();
  }
  next() {
    if (!this.geometryCursor) return null;
    const t15 = this.processMultiPath(this.geometryCursor);
    return this.iterateMultiPath && t15 || (this.geometryCursor = null), t15;
  }
  processMultiPath(t15) {
    for (; this.iteratePath || t15.pathIndex < t15.totalSize - 1; ) {
      this.iteratePath || t15.nextPath(), this.iterateMultiPath = true;
      const e13 = this.processPath(t15);
      if (e13) return e13;
    }
    return this.iterateMultiPath = false, null;
  }
};
var s5 = class {
  constructor(t15, e13, i16, r18 = 0) {
    this.isClosed = false, this.inputGeometries = t15, this.acceptPolygon = e13, this.acceptPolyline = i16, this.geomUnitsPerPoint = r18, this.iteratePath = false, this.multiPathCursor = null;
  }
  next() {
    for (; ; ) {
      if (!this.multiPathCursor) {
        let t15 = this.inputGeometries.next();
        for (; t15 && (this.isClosed = this.acceptPolygon && "esriGeometryPolygon" === t15.geometryType || "esriGeometryEnvelope" === t15.geometryType, this.multiPathCursor = t15, !this.multiPathCursor); ) t15 = this.inputGeometries.next();
        if (!this.multiPathCursor) return null;
      }
      for (; this.iteratePath || this.multiPathCursor.nextPath(); ) {
        this.multiPathCursor.seekPathStart();
        const t15 = this.processPath(this.multiPathCursor);
        if (t15) return t15;
      }
      this.multiPathCursor = null;
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/CurveHelper.js
var n5 = 0.03;
var s6 = class {
  constructor(t15 = 0, e13 = false) {
  }
  isEmpty(t15) {
    if (!t15.nextPoint()) return true;
    let e13, n18, s13, r18;
    for (e13 = t15.x, n18 = t15.y; t15.nextPoint(); e13 = n18, n18 = r18) if (s13 = t15.x, r18 = t15.y, s13 !== e13 || r18 !== n18) return t15.seekPathStart(), false;
    return t15.seekPathStart(), true;
  }
  normalize(t15) {
    const e13 = Math.sqrt(t15[0] * t15[0] + t15[1] * t15[1]);
    0 !== e13 && (t15[0] /= e13, t15[1] /= e13);
  }
  getLength(t15, e13, n18, s13) {
    const r18 = n18 - t15, o8 = s13 - e13;
    return Math.sqrt(r18 * r18 + o8 * o8);
  }
  getSegLength(t15) {
    const [[e13, n18], [s13, r18]] = t15;
    return this.getLength(e13, n18, s13, r18);
  }
  getCoord2D(t15, e13, n18, s13, r18) {
    return [t15 + (n18 - t15) * r18, e13 + (s13 - e13) * r18];
  }
  getSegCoord2D(t15, e13) {
    const [[n18, s13], [r18, o8]] = t15;
    return this.getCoord2D(n18, s13, r18, o8, e13);
  }
  getAngle(t15, e13, n18, s13, r18) {
    const o8 = n18 - t15, i16 = s13 - e13;
    return Math.atan2(i16, o8);
  }
  getAngleCS(t15, e13, n18, s13, r18) {
    const o8 = n18 - t15, i16 = s13 - e13, u13 = Math.sqrt(o8 * o8 + i16 * i16);
    return u13 > 0 ? [o8 / u13, i16 / u13] : [1, 0];
  }
  getSegAngleCS(t15, e13) {
    const [[n18, s13], [r18, o8]] = t15;
    return this.getAngleCS(n18, s13, r18, o8, e13);
  }
  cut(t15, e13, n18, s13, r18, o8) {
    return [r18 <= 0 ? [t15, e13] : this.getCoord2D(t15, e13, n18, s13, r18), o8 >= 1 ? [n18, s13] : this.getCoord2D(t15, e13, n18, s13, o8)];
  }
  getSubCurve(e13, n18, s13) {
    const r18 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    return this.appendSubCurve(r18, e13, n18, s13) ? r18 : null;
  }
  appendSubCurve(t15, e13, n18, s13) {
    t15.startPath(), e13.seekPathStart();
    let r18 = 0, o8 = true;
    if (!e13.nextPoint()) return false;
    let i16 = e13.x, u13 = e13.y;
    for (; e13.nextPoint(); ) {
      const h8 = this.getLength(i16, u13, e13.x, e13.y);
      if (0 !== h8) {
        if (o8) {
          if (r18 + h8 > n18) {
            const l12 = (n18 - r18) / h8;
            let a12 = 1, c5 = false;
            r18 + h8 >= s13 && (a12 = (s13 - r18) / h8, c5 = true);
            const f7 = this.cut(i16, u13, e13.x, e13.y, l12, a12);
            if (f7 && t15.pushPoints(f7), c5) break;
            o8 = false;
          }
        } else {
          if (r18 + h8 > s13) {
            const n19 = this.cut(i16, u13, e13.x, e13.y, 0, (s13 - r18) / h8);
            n19 && t15.pushPoint(n19[1]);
            break;
          }
          t15.pushXY(e13.x, e13.y);
        }
        r18 += h8, i16 = e13.x, u13 = e13.y;
      } else i16 = e13.x, u13 = e13.y;
    }
    return true;
  }
  getCIMPointAlong(t15, e13) {
    if (!t15.nextPoint()) return null;
    let n18, s13, r18, o8, i16 = 0;
    for (n18 = t15.x, s13 = t15.y; t15.nextPoint(); n18 = r18, s13 = o8) {
      r18 = t15.x, o8 = t15.y;
      const u13 = this.getLength(n18, s13, r18, o8);
      if (0 !== u13) {
        if (i16 + u13 > e13) {
          const t16 = (e13 - i16) / u13;
          return this.getCoord2D(n18, s13, r18, o8, t16);
        }
        i16 += u13;
      }
    }
    return null;
  }
  offset(t15, n18, s13, r18, o8) {
    if (!t15 || t15.length < 2) return null;
    let i16 = 0, u13 = t15[i16++], h8 = i16;
    for (; i16 < t15.length; ) {
      const e13 = t15[i16];
      e13[0] === u13[0] && e13[1] === u13[1] || (i16 !== h8 && (t15[h8] = t15[i16]), u13 = t15[h8++]), i16++;
    }
    const l12 = t15[0][0] === t15[h8 - 1][0] && t15[0][1] === t15[h8 - 1][1];
    if (l12 && --h8, h8 < (l12 ? 3 : 2)) return null;
    const a12 = [];
    u13 = l12 ? t15[h8 - 1] : null;
    let c5 = t15[0];
    for (let f7 = 0; f7 < h8; f7++) {
      const o9 = f7 === h8 - 1 ? l12 ? t15[0] : null : t15[f7 + 1];
      if (u13) if (o9) {
        const t16 = [o9[0] - c5[0], o9[1] - c5[1]];
        this.normalize(t16);
        const i17 = [c5[0] - u13[0], c5[1] - u13[1]];
        this.normalize(i17);
        const h9 = i17[0] * t16[1] - i17[1] * t16[0], l13 = i17[0] * t16[0] + i17[1] * t16[1];
        if (0 === h9 && 1 === l13) {
          c5 = o9;
          continue;
        }
        if (h9 >= 0 == n18 <= 0) {
          if (l13 < 1) {
            const e13 = [t16[0] - i17[0], t16[1] - i17[1]];
            this.normalize(e13);
            const s14 = Math.sqrt((1 + l13) / 2);
            if (s14 > 1 / r18) {
              const t17 = -Math.abs(n18) / s14;
              a12.push([c5[0] - e13[0] * t17, c5[1] - e13[1] * t17]);
            }
          }
        } else switch (s13) {
          case N.Mitered: {
            const e13 = Math.sqrt((1 + l13) / 2);
            if (e13 > 0 && 1 / e13 < r18) {
              const s14 = [t16[0] - i17[0], t16[1] - i17[1]];
              this.normalize(s14);
              const r19 = Math.abs(n18) / e13;
              a12.push([c5[0] - s14[0] * r19, c5[1] - s14[1] * r19]);
              break;
            }
          }
          case N.Bevelled:
            a12.push([c5[0] + i17[1] * n18, c5[1] - i17[0] * n18]), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
            break;
          case N.Rounded:
            if (l13 < 1) {
              a12.push([c5[0] + i17[1] * n18, c5[1] - i17[0] * n18]);
              const e13 = Math.floor(2.5 * (1 - l13));
              if (e13 > 0) {
                const s14 = 1 / e13;
                let r19 = s14;
                for (let o10 = 1; o10 < e13; o10++, r19 += s14) {
                  const e14 = [i17[1] * (1 - r19) + t16[1] * r19, -i17[0] * (1 - r19) - t16[0] * r19];
                  this.normalize(e14), a12.push([c5[0] + e14[0] * n18, c5[1] + e14[1] * n18]);
                }
              }
              a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
            }
            break;
          case N.Square:
          default:
            if (h9 < 0) a12.push([c5[0] + (i17[1] + i17[0]) * n18, c5[1] + (i17[1] - i17[0]) * n18]), a12.push([c5[0] + (t16[1] - t16[0]) * n18, c5[1] - (t16[0] + t16[1]) * n18]);
            else {
              const e13 = Math.sqrt((1 + Math.abs(l13)) / 2), s14 = [t16[0] - i17[0], t16[1] - i17[1]];
              this.normalize(s14);
              const r19 = n18 / e13;
              a12.push([c5[0] - s14[0] * r19, c5[1] - s14[1] * r19]);
            }
        }
      } else {
        const t16 = [c5[0] - u13[0], c5[1] - u13[1]];
        this.normalize(t16), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
      }
      else {
        const t16 = [o9[0] - c5[0], o9[1] - c5[1]];
        this.normalize(t16), a12.push([c5[0] + t16[1] * n18, c5[1] - t16[0] * n18]);
      }
      u13 = c5, c5 = o9;
    }
    return a12.length < (l12 ? 3 : 2) ? null : (l12 && a12.push([a12[0][0], a12[0][1]]), a12);
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectArrow.js
var c3 = 1.7320508075688772;
var u7 = 5;
var h2 = P.OpenEnded;
var p3 = class _p {
  static local() {
    return null === _p.instance && (_p.instance = new _p()), _p.instance;
  }
  execute(t15, e13, r18, n18, o8) {
    return new P3(t15, e13, r18);
  }
};
p3.instance = null;
var P3 = class extends s5 {
  constructor(t15, e13, r18) {
    super(t15, false, true), this._curveHelper = new s6(), this._width = (void 0 !== e13.width ? e13.width : u7) * r18, this._arrowType = void 0 !== e13.geometricEffectArrowType ? e13.geometricEffectArrowType : void 0 !== e13.arrowType ? e13.arrowType : h2, this._offsetFlattenError = n5 * r18;
  }
  processPath(e13) {
    const r18 = a6.createEmptyOptimizedCIM(e13.geometryType);
    switch (this._arrowType) {
      case P.OpenEnded:
      default:
        this._constructSimpleArrow(r18, e13, true);
        break;
      case P.Block:
        this._constructSimpleArrow(r18, e13, false);
        break;
      case P.Crossed:
        this._constructCrossedArrow(r18, e13);
    }
    return r18;
  }
  _constructSimpleArrow(t15, r18, n18) {
    const o8 = r18.pathLength();
    let s13 = this._width;
    o8 < 2 * s13 && (s13 = o8 / 2);
    const i16 = this._curveHelper.getSubCurve(r18, 0, o8 - s13);
    if (!i16 || !i16.nextPath()) return;
    i16.seekPathStart();
    const c5 = s13 / 2;
    if (this._curveHelper.isEmpty(i16)) return;
    const u13 = n2(i16), h8 = this._constructOffset(u13, -c5);
    if (!h8) return;
    const p7 = this._constructOffset(u13, c5);
    if (!p7) return;
    const P5 = this._constructArrowBasePoint(h8, -c5 / 2);
    if (!P5) return;
    const l12 = this._constructArrowBasePoint(p7, c5 / 2);
    if (!l12) return;
    r18.seekInPath(r18.pathSize - 1);
    const f7 = [r18.x, r18.y];
    t15.pushPath(p7), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(l12), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(f7), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(P5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(h8.reverse()), t15.setControlPoint(), n18 || (t15.setControlPointAt(0), t15.setControlPointAt(t15.pathSize - 1), t15.pushPoint(p7[0])), t15.reset();
  }
  _constructCrossedArrow(t15, r18) {
    const n18 = r18.pathLength();
    let o8 = this._width;
    n18 < o8 * (1 + c3 + 1) && (o8 = n18 / (1 + c3 + 1)), r18.seekPathStart();
    const s13 = this._curveHelper.getSubCurve(r18, 0, n18 - o8 * (1 + c3));
    if (!s13) return;
    s13.nextPath();
    const i16 = o8 / 2;
    if (this._curveHelper.isEmpty(s13)) return;
    const u13 = n2(s13), h8 = this._constructOffset(u13, i16);
    if (!h8) return;
    const p7 = this._constructOffset(u13, -i16);
    if (!p7) return;
    const P5 = this._curveHelper.getSubCurve(r18, 0, n18 - o8);
    if (!P5) return;
    if (P5.nextPath(), this._curveHelper.isEmpty(P5)) return;
    const l12 = n2(P5), f7 = this._constructOffset(l12, i16);
    if (!f7) return;
    const a12 = this._constructOffset(l12, -i16);
    if (!a12) return;
    const _6 = f7[f7.length - 1], m7 = this._constructArrowBasePoint(f7, i16 / 2);
    if (!m7) return;
    const C4 = a12[a12.length - 1], w5 = this._constructArrowBasePoint(a12, -i16 / 2);
    if (!w5) return;
    r18.seekInPath(r18.pathSize - 1);
    const x4 = [r18.x, r18.y];
    t15.pushPath(h8), t15.nextPath(), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(C4), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(w5), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(x4), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(m7), t15.nextPoint(), t15.setControlPoint(), t15.pushPoint(_6), t15.nextPoint(), t15.setControlPoint(), t15.pushPoints(p7.reverse()), t15.nextPoint(), t15.setControlPoint(), t15.reset();
  }
  _constructOffset(t15, e13) {
    return this._curveHelper.offset(t15, e13, N.Rounded, 4, this._offsetFlattenError);
  }
  _constructArrowBasePoint(t15, e13) {
    if (!t15 || t15.length < 2) return null;
    const r18 = t15[t15.length - 2], n18 = t15[t15.length - 1], o8 = [n18[0] - r18[0], n18[1] - r18[1]];
    return this._curveHelper.normalize(o8), [n18[0] + o8[1] * e13, n18[1] - o8[0] * e13];
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMEffects.js
var r4 = 512;
var n6;
var s7 = class {
  constructor(t15) {
    this._geometry = t15;
  }
  next() {
    const t15 = this._geometry;
    return this._geometry = null, t15;
  }
};
function i7(s13, i16) {
  n6 || (n6 = new e3(0, 0, 0, 1));
  const y6 = "esriGeometryPolygon" === s13.geometryType, m7 = y6 ? i2.Polygon : i2.LineString, l12 = y6 ? 3 : 2;
  let c5, p7;
  for (n6.reset(m7), n6.setPixelMargin(i16 + 1), n6.setExtent(r4); s13.nextPath(); ) if (!(s13.pathSize < l12)) {
    for (s13.nextPoint(), c5 = s13.x, p7 = -s13.y, n6.moveTo(c5, p7); s13.nextPoint(); ) c5 = s13.x, p7 = -s13.y, n6.lineTo(c5, p7);
    y6 && n6.close();
  }
  const f7 = n6.result(false);
  if (f7) {
    const e13 = a6.createEmptyOptimizedCIM(s13.geometryType);
    for (const t15 of f7) {
      e13.startPath();
      for (const o8 of t15) e13.pushXY(o8.x, -o8.y);
    }
    return e13.reset(), e13;
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectBuffer.js
var m5 = class _m {
  static local() {
    return null === _m.instance && (_m.instance = new _m()), _m.instance;
  }
  execute(e13, t15, i16, s13, r18, n18) {
    return new l5(e13, t15, i16, s13, r18, n18);
  }
};
m5.instance = null;
var l5 = class {
  constructor(e13, t15, i16, n18, o8, m7) {
    this._inputGeometries = e13, this._tileKey = n18, this._geometryEngine = o8, this._curveHelper = new s6(), this._size = (void 0 !== t15.size ? t15.size : 1) * i16, this._maxInflateSize = m7 * i16, this._offsetFlattenError = n5 * i16;
  }
  next() {
    let s13;
    for (; s13 = this._inputGeometries.next(); ) {
      if (0 === this._size) return s13;
      if ("esriGeometryEnvelope" === s13.geometryType) {
        if (this._size > 0) {
          const i16 = a6.createEmptyOptimizedCIM(s13.geometryType), r19 = t2(s13)[0], o8 = this._curveHelper.offset(r19, this._size, N.Rounded, 4, this._offsetFlattenError);
          if (o8) return i16.pushPath(o8), i16;
        } else if (this._size < 0) {
          const t15 = s13.asJSON();
          if (Math.min(t15.xmax - t15.xmin, t15.ymax - t15.ymin) + 2 * this._size > 0) return a6.fromJSONCIM({ xmin: t15.xmin - this._size, xmax: t15.xmax + this._size, ymin: t15.ymin - this._size, ymax: t15.ymax + this._size });
        }
      }
      const r18 = this._geometryEngine;
      if (null == r18) return null;
      const m7 = this._tileKey ? i7(s13, this._maxInflateSize) : s13;
      if (!m7) continue;
      const l12 = r18.buffer(g.WebMercator, m7.asJSON(), this._size, 1);
      return l12 ? a6.fromJSONCIM(l12) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectControlMeasureLine.js
var r5 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(s13, t15, i16, h8, e13) {
    return new _2(s13, t15, i16);
  }
};
r5.instance = null;
var _2 = class {
  constructor(s13, t15, i16) {
    this._defaultPointSize = 20, this._inputGeometries = s13, this._geomUnitsPerPoint = i16, this._rule = t15.rule ?? R.FullGeometry, this._defaultSize = this._defaultPointSize * i16;
  }
  next() {
    let i16;
    for (; i16 = this._inputGeometries.next(); ) {
      const h8 = this._processGeom(t2(i16));
      if (h8 == null ? void 0 : h8.length) return a6.fromJSONCIM({ paths: h8 });
    }
    return null;
  }
  _clone(s13) {
    return [s13[0], s13[1]];
  }
  _mid(s13, t15) {
    return [(s13[0] + t15[0]) / 2, (s13[1] + t15[1]) / 2];
  }
  _mix(s13, t15, i16, h8) {
    return [s13[0] * t15 + i16[0] * h8, s13[1] * t15 + i16[1] * h8];
  }
  _add(s13, t15) {
    return [s13[0] + t15[0], s13[1] + t15[1]];
  }
  _add2(s13, t15, i16) {
    return [s13[0] + t15, s13[1] + i16];
  }
  _sub(s13, t15) {
    return [s13[0] - t15[0], s13[1] - t15[1]];
  }
  _dist(s13, t15) {
    return Math.sqrt((s13[0] - t15[0]) * (s13[0] - t15[0]) + (s13[1] - t15[1]) * (s13[1] - t15[1]));
  }
  _norm(s13) {
    return Math.sqrt(s13[0] * s13[0] + s13[1] * s13[1]);
  }
  _normalize(s13, t15 = 1) {
    const i16 = t15 / this._norm(s13);
    s13[0] *= i16, s13[1] *= i16;
  }
  _leftPerpendicular(s13) {
    const t15 = -s13[1], i16 = s13[0];
    s13[0] = t15, s13[1] = i16;
  }
  _leftPerp(s13) {
    return [-s13[1], s13[0]];
  }
  _rightPerpendicular(s13) {
    const t15 = s13[1], i16 = -s13[0];
    s13[0] = t15, s13[1] = i16;
  }
  _rightPerp(s13) {
    return [s13[1], -s13[0]];
  }
  _dotProduct(s13, t15) {
    return s13[0] * t15[0] + s13[1] * t15[1];
  }
  _crossProduct(s13, t15) {
    return s13[0] * t15[1] - s13[1] * t15[0];
  }
  _rotateDirect(s13, t15, i16) {
    const h8 = s13[0] * t15 - s13[1] * i16, e13 = s13[0] * i16 + s13[1] * t15;
    s13[0] = h8, s13[1] = e13;
  }
  _makeCtrlPt(s13) {
    const t15 = [s13[0], s13[1]];
    return i6(t15, 1), t15;
  }
  _addAngledTicks(s13, t15, i16, h8) {
    const e13 = this._sub(i16, t15);
    this._normalize(e13);
    const r18 = this._crossProduct(e13, this._sub(h8, t15));
    let _6;
    _6 = r18 > 0 ? this._rightPerp(e13) : this._leftPerp(e13);
    const c5 = Math.abs(r18) / 2, u13 = [];
    u13.push([t15[0] + (_6[0] - e13[0]) * c5, t15[1] + (_6[1] - e13[1]) * c5]), u13.push(t15), u13.push(i16), u13.push([i16[0] + (_6[0] + e13[0]) * c5, i16[1] + (_6[1] + e13[1]) * c5]), s13.push(u13);
  }
  _addBezier2(s13, t15, i16, h8, e13) {
    if (0 == e13--) return void s13.push(h8);
    const r18 = this._mid(t15, i16), _6 = this._mid(i16, h8), c5 = this._mid(r18, _6);
    this._addBezier2(s13, t15, r18, c5, e13), this._addBezier2(s13, c5, _6, h8, e13);
  }
  _addBezier3(s13, t15, i16, h8, e13, r18) {
    if (0 == r18--) return void s13.push(e13);
    const _6 = this._mid(t15, i16), c5 = this._mid(i16, h8), u13 = this._mid(h8, e13), o8 = this._mid(_6, c5), a12 = this._mid(c5, u13), n18 = this._mid(o8, a12);
    this._addBezier3(s13, t15, _6, o8, n18, r18), this._addBezier3(s13, n18, a12, u13, e13, r18);
  }
  _add90DegArc(s13, t15, i16, h8, e13) {
    const r18 = e13 ?? this._crossProduct(this._sub(i16, t15), this._sub(h8, t15)) > 0, _6 = this._mid(t15, i16), c5 = this._sub(_6, t15);
    r18 ? this._leftPerpendicular(c5) : this._rightPerpendicular(c5), _6[0] += c5[0], _6[1] += c5[1], this._addBezier3(s13, t15, this._mix(t15, 0.33333, _6, 0.66667), this._mix(i16, 0.33333, _6, 0.66667), i16, 4);
  }
  _addArrow(s13, t15, i16) {
    const h8 = t15[0], e13 = t15[1], r18 = t15[t15.length - 1], _6 = this._sub(h8, e13), c5 = this._norm(_6);
    this._normalize(_6);
    const u13 = Math.abs(this._crossProduct(_6, this._sub(r18, e13)));
    let o8 = this._dotProduct(_6, this._sub(r18, e13));
    o8 < 0.05 * c5 ? o8 = 0.05 * c5 : o8 > 0.95 * c5 && (o8 = 0.95 * c5);
    const a12 = 0.5 * u13, n18 = this._leftPerp(_6), p7 = [e13[0] + _6[0] * o8, e13[1] + _6[1] * o8], d4 = t15.length - 1, l12 = [];
    l12.push(i16 ? [-n18[0], -n18[1]] : n18);
    let b4 = [-_6[0], -_6[1]];
    for (let P5 = 1; P5 < d4 - 1; P5++) {
      const s14 = this._sub(t15[P5 + 1], t15[P5]);
      this._normalize(s14);
      const i17 = this._dotProduct(s14, b4), h9 = this._crossProduct(s14, b4), e14 = Math.sqrt((1 + i17) / 2), r19 = this._sub(s14, b4);
      this._normalize(r19), r19[0] /= e14, r19[1] /= e14, l12.push(h9 < 0 ? [-r19[0], -r19[1]] : r19), b4 = s14;
    }
    l12.push(this._rightPerp(b4));
    for (let P5 = l12.length - 1; P5 > 0; P5--) s13.push([t15[P5][0] + l12[P5][0] * a12, t15[P5][1] + l12[P5][1] * a12]);
    s13.push([p7[0] + l12[0][0] * a12, p7[1] + l12[0][1] * a12]), s13.push([p7[0] + l12[0][0] * u13, p7[1] + l12[0][1] * u13]), s13.push(h8), s13.push([p7[0] - l12[0][0] * u13, p7[1] - l12[0][1] * u13]), s13.push([p7[0] - l12[0][0] * a12, p7[1] - l12[0][1] * a12]);
    for (let P5 = 1; P5 < l12.length; P5++) s13.push([t15[P5][0] - l12[P5][0] * a12, t15[P5][1] - l12[P5][1] * a12]);
  }
  _addDash(s13, t15, i16) {
    const h8 = this._norm(i16) / 7;
    this._normalize(i16);
    let e13 = [];
    for (let r18 = 0; r18 <= 7; r18++) e13.push([t15[0] + i16[0] * r18 * h8, t15[1] + i16[1] * r18 * h8]), 1 & r18 && (s13.push(e13), e13 = []);
  }
  _cp2(s13, t15, i16) {
    return s13.length >= 2 ? s13[1] : this._add2(s13[0], t15 * this._defaultSize, i16 * this._defaultSize);
  }
  _cp3(s13, t15, i16, h8) {
    if (s13.length >= 3) return s13[2];
    const e13 = this._mix(s13[0], 1 - i16, t15, i16), r18 = this._sub(t15, s13[0]);
    return this._normalize(r18), this._rightPerpendicular(r18), [e13[0] + r18[0] * h8 * this._defaultSize, e13[1] + r18[1] * h8 * this._defaultSize];
  }
  _arrowPath(s13) {
    if (s13.length > 2) return s13;
    const t15 = s13[0], i16 = this._cp2(s13, -4, 0), h8 = this._sub(t15, i16);
    this._normalize(h8);
    const e13 = this._rightPerp(h8);
    return [t15, i16, [t15[0] + (e13[0] - h8[0]) * this._defaultSize, t15[1] + (e13[1] - h8[1]) * this._defaultSize]];
  }
  _arrowLastSeg(s13) {
    const t15 = s13[0], i16 = this._cp2(s13, -4, 0);
    let h8;
    if (s13.length >= 3) h8 = s13[s13.length - 1];
    else {
      const s14 = this._sub(t15, i16);
      this._normalize(s14);
      const e13 = this._rightPerp(s14);
      h8 = [t15[0] + (e13[0] - s14[0]) * this._defaultSize, t15[1] + (e13[1] - s14[1]) * this._defaultSize];
    }
    return [i16, h8];
  }
  _processGeom(s13) {
    if (!s13) return null;
    const t15 = [];
    for (const r18 of s13) {
      const s14 = r18.length > 1 && h(r18) < this._defaultSize;
      if (!r18 || 0 === r18.length || s14) continue;
      const _6 = r18.length;
      let c5 = r18[0];
      switch (this._rule) {
        case R.PerpendicularFromFirstSegment: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 4), h8 = [];
          h8.push(i16), h8.push(this._mid(c5, s15)), t15.push(h8);
          break;
        }
        case R.ReversedFirstSegment: {
          const s15 = this._cp2(r18, 0, -1);
          t15.push([s15, c5]);
          break;
        }
        case R.PerpendicularToSecondSegment: {
          if (r18.length < 3) return [];
          const s15 = this._cp2(r18, -4, 1), i16 = this._cp3(r18, s15, 0.882353, -1.94), h8 = [];
          h8.push(this._mid(s15, i16)), h8.push(c5), t15.push(h8);
          break;
        }
        case R.SecondSegmentWithTicks: {
          if (r18.length < 3) return [];
          const s15 = this._cp2(r18, -4, 1), i16 = this._cp3(r18, s15, 0.882353, -1.94), h8 = this._sub(i16, s15);
          let e13;
          e13 = this._crossProduct(h8, this._sub(c5, s15)) > 0 ? this._rightPerp(h8) : this._leftPerp(h8);
          const _7 = [];
          _7.push([s15[0] + (e13[0] - h8[0]) / 3, s15[1] + (e13[1] - h8[1]) / 3]), _7.push(s15), _7.push(i16), _7.push([i16[0] + (e13[0] + h8[0]) / 3, i16[1] + (e13[1] + h8[1]) / 3]), t15.push(_7);
          break;
        }
        case R.DoublePerpendicular: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 3), h8 = this._mid(c5, s15), e13 = this._sub(h8, i16);
          this._normalize(e13);
          const _7 = this._crossProduct(e13, this._sub(c5, i16));
          this._leftPerpendicular(e13);
          const u13 = [];
          u13.push(c5), u13.push([i16[0] + e13[0] * _7, i16[1] + e13[1] * _7]), t15.push(u13);
          const o8 = [];
          o8.push([i16[0] - e13[0] * _7, i16[1] - e13[1] * _7]), o8.push(s15), t15.push(o8);
          break;
        }
        case R.OppositeToFirstSegment: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 3), h8 = this._mid(c5, s15), e13 = this._sub(h8, i16);
          this._normalize(e13);
          const _7 = this._crossProduct(e13, this._sub(c5, i16));
          this._leftPerpendicular(e13);
          const u13 = [];
          u13.push([i16[0] + e13[0] * _7, i16[1] + e13[1] * _7]), u13.push([i16[0] - e13[0] * _7, i16[1] - e13[1] * _7]), t15.push(u13);
          break;
        }
        case R.TriplePerpendicular: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 4), h8 = this._mid(c5, s15), e13 = this._sub(h8, i16);
          this._normalize(e13);
          const _7 = this._crossProduct(e13, this._sub(c5, i16));
          this._leftPerpendicular(e13);
          const u13 = [];
          u13.push([i16[0] + e13[0] * _7 * 0.8, i16[1] + e13[1] * _7 * 0.8]), u13.push([h8[0] + 0.8 * (c5[0] - h8[0]), h8[1] + 0.8 * (c5[1] - h8[1])]), t15.push(u13), t15.push([i16, h8]);
          const o8 = [];
          o8.push([i16[0] - e13[0] * _7 * 0.8, i16[1] - e13[1] * _7 * 0.8]), o8.push([h8[0] + 0.8 * (s15[0] - h8[0]), h8[1] + 0.8 * (s15[1] - h8[1])]), t15.push(o8);
          break;
        }
        case R.HalfCircleFirstSegment: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 4), h8 = this._mid(c5, s15);
          let e13 = this._sub(s15, c5);
          const _7 = Math.cos(Math.PI / 18), u13 = Math.sin(Math.PI / 18), o8 = Math.sqrt((1 + _7) / 2), a12 = Math.sqrt((1 - _7) / 2), n18 = [];
          let p7;
          this._crossProduct(e13, this._sub(i16, c5)) > 0 ? (n18.push(c5), e13 = this._sub(c5, h8), p7 = s15) : (n18.push(s15), e13 = this._sub(s15, h8), p7 = c5), this._rotateDirect(e13, o8, a12), e13[0] /= o8, e13[1] /= o8;
          for (let t16 = 1; t16 <= 18; t16++) n18.push(this._add(h8, e13)), this._rotateDirect(e13, _7, u13);
          n18.push(p7), t15.push(n18);
          break;
        }
        case R.HalfCircleSecondSegment: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 1, -1);
          let h8 = this._sub(c5, s15);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, s15)) / 2;
          this._leftPerpendicular(h8);
          const _7 = [s15[0] + h8[0] * e13, s15[1] + h8[1] * e13];
          h8 = this._sub(s15, _7);
          const u13 = Math.cos(Math.PI / 18);
          let o8 = Math.sin(Math.PI / 18);
          e13 > 0 && (o8 = -o8);
          const a12 = [s15];
          for (let t16 = 1; t16 <= 18; t16++) this._rotateDirect(h8, u13, o8), a12.push(this._add(_7, h8));
          t15.push(a12);
          break;
        }
        case R.HalfCircleExtended: {
          const s15 = this._cp2(r18, 0, -2), i16 = this._cp3(r18, s15, 1, -1);
          let h8;
          if (_6 >= 4) h8 = r18[3];
          else {
            const t16 = this._sub(c5, s15);
            h8 = this._add(i16, t16);
          }
          const e13 = this._dist(s15, i16) / 2 / 0.75, u13 = this._sub(s15, c5);
          this._normalize(u13, e13);
          const o8 = this._sub(i16, h8);
          this._normalize(o8, e13);
          const a12 = [h8, i16];
          t15.push(a12);
          const n18 = [this._clone(i16)];
          this._addBezier3(n18, i16, this._add(i16, o8), this._add(s15, u13), s15, 4), n18.push(c5), t15.push(n18);
          break;
        }
        case R.OpenCircle: {
          const s15 = this._cp2(r18, -2, 0), i16 = this._sub(s15, c5), h8 = Math.cos(Math.PI / 18), e13 = -Math.sin(Math.PI / 18), _7 = [s15];
          for (let t16 = 1; t16 <= 33; t16++) this._rotateDirect(i16, h8, e13), _7.push(this._add(c5, i16));
          t15.push(_7);
          break;
        }
        case R.CoverageEdgesWithTicks: {
          const s15 = this._cp2(r18, 0, -1);
          let i16, h8;
          if (_6 >= 3) i16 = r18[2];
          else {
            const t16 = this._sub(s15, c5), h9 = this._leftPerp(t16);
            i16 = [c5[0] + h9[0] - 0.25 * t16[0], c5[1] + h9[1] - 0.25 * t16[1]];
          }
          if (_6 >= 4) h8 = r18[3];
          else {
            const t16 = this._mid(c5, s15), e14 = this._sub(c5, s15);
            this._normalize(e14), this._leftPerpendicular(e14);
            const r19 = this._crossProduct(e14, this._sub(i16, t16));
            this._rightPerpendicular(e14), h8 = [i16[0] + e14[0] * r19 * 2, i16[1] + e14[1] * r19 * 2];
          }
          const e13 = this._sub(s15, c5);
          let u13, o8;
          u13 = this._crossProduct(e13, this._sub(i16, c5)) > 0 ? this._rightPerp(e13) : this._leftPerp(e13), o8 = [], o8.push(i16), o8.push(c5), o8.push([c5[0] + (u13[0] - e13[0]) / 3, c5[1] + (u13[1] - e13[1]) / 3]), t15.push(o8), u13 = this._crossProduct(e13, this._sub(h8, s15)) > 0 ? this._rightPerp(e13) : this._leftPerp(e13), o8 = [], o8.push([s15[0] + (u13[0] + e13[0]) / 3, s15[1] + (u13[1] + e13[1]) / 3]), o8.push(s15), o8.push(h8), t15.push(o8);
          break;
        }
        case R.GapExtentWithDoubleTicks: {
          const s15 = this._cp2(r18, 0, 2), i16 = this._cp3(r18, s15, 0, 1);
          let h8;
          if (_6 >= 4) h8 = r18[3];
          else {
            const t16 = this._sub(s15, c5);
            h8 = this._add(i16, t16);
          }
          this._addAngledTicks(t15, c5, s15, this._mid(i16, h8)), this._addAngledTicks(t15, i16, h8, this._mid(c5, s15));
          break;
        }
        case R.GapExtentMidline: {
          const s15 = this._cp2(r18, 2, 0), i16 = this._cp3(r18, s15, 0, 1);
          let h8;
          if (_6 >= 4) h8 = r18[3];
          else {
            const t16 = this._sub(s15, c5);
            h8 = this._add(i16, t16);
          }
          const e13 = [];
          e13.push(this._mid(c5, i16)), e13.push(this._mid(s15, h8)), t15.push(e13);
          break;
        }
        case R.Chevron: {
          const s15 = this._cp2(r18, -1, -1);
          let i16;
          if (_6 >= 3) i16 = r18[2];
          else {
            const t16 = this._sub(s15, c5);
            this._leftPerpendicular(t16), i16 = this._add(c5, t16);
          }
          t15.push([s15, this._makeCtrlPt(c5), i16]);
          break;
        }
        case R.PerpendicularWithArc: {
          const s15 = this._cp2(r18, 0, -2), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(s15, c5), e13 = this._norm(h8);
          h8[0] /= e13, h8[1] /= e13;
          const u13 = this._crossProduct(h8, this._sub(i16, c5));
          let o8 = this._dotProduct(h8, this._sub(i16, c5));
          o8 < 0.05 * e13 ? o8 = 0.05 * e13 : o8 > 0.95 * e13 && (o8 = 0.95 * e13);
          const a12 = [c5[0] + h8[0] * o8, c5[1] + h8[1] * o8];
          let n18 = this._leftPerp(h8), p7 = [];
          if (p7.push([a12[0] - n18[0] * u13, a12[1] - n18[1] * u13]), p7.push([a12[0] + n18[0] * u13, a12[1] + n18[1] * u13]), t15.push(p7), _6 >= 4) {
            const s16 = r18[3];
            let i17 = this._dotProduct(h8, this._sub(s16, c5));
            i17 < 0.1 * e13 ? i17 = 0.1 * e13 : i17 > 0.9 * e13 && (i17 = 0.9 * e13);
            const _7 = [c5[0] + h8[0] * i17, c5[1] + h8[1] * i17], u14 = this._crossProduct(h8, this._sub(s16, c5)), o9 = [];
            o9.push([_7[0] - n18[0] * u14, _7[1] - n18[1] * u14]), o9.push([_7[0] + n18[0] * u14, _7[1] + n18[1] * u14]), t15.push(o9);
          }
          const d4 = [s15[0] + n18[0] * u13, s15[1] + n18[1] * u13];
          n18 = this._sub(s15, d4);
          const l12 = Math.cos(Math.PI / 18);
          let b4 = Math.sin(Math.PI / 18);
          u13 < 0 && (b4 = -b4), p7 = [c5, s15];
          for (let t16 = 1; t16 <= 9; t16++) this._rotateDirect(n18, l12, b4), p7.push(this._add(d4, n18));
          t15.push(p7);
          break;
        }
        case R.ClosedHalfCircle: {
          const s15 = this._cp2(r18, 2, 0), i16 = this._mid(c5, s15), h8 = this._sub(s15, i16), e13 = Math.cos(Math.PI / 18), _7 = Math.sin(Math.PI / 18), u13 = [c5, s15];
          for (let t16 = 1; t16 <= 18; t16++) this._rotateDirect(h8, e13, _7), u13.push(this._add(i16, h8));
          t15.push(u13);
          break;
        }
        case R.TripleParallelExtended: {
          const s15 = this._cp2(r18, 0, -2), i16 = this._cp3(r18, s15, 1, -2), e13 = this._mid(c5, s15), _7 = this._sub(i16, s15);
          this._normalize(_7);
          const u13 = Math.abs(this._crossProduct(_7, this._sub(e13, s15))) / 2, o8 = this._dist(s15, i16), a12 = [s15, c5];
          a12.push([c5[0] + _7[0] * o8 * 0.5, c5[1] + _7[1] * o8 * 0.5]), t15.push(a12);
          const n18 = [];
          n18.push([e13[0] - _7[0] * u13, e13[1] - _7[1] * u13]), n18.push([e13[0] + _7[0] * o8 * 0.375, e13[1] + _7[1] * o8 * 0.375]), i6(n18[n18.length - 1], 1), n18.push([e13[0] + _7[0] * o8 * 0.75, e13[1] + _7[1] * o8 * 0.75]), t15.push(n18);
          const p7 = [s15, i16];
          t15.push(p7);
          break;
        }
        case R.ParallelWithTicks: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(i16, s15);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, c5));
          this._leftPerpendicular(h8), this._addAngledTicks(t15, c5, s15, i16), this._addAngledTicks(t15, this._mix(c5, 1, h8, e13), this._mix(s15, 1, h8, e13), this._mid(c5, s15));
          break;
        }
        case R.Parallel: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(s15, c5);
          this._normalize(h8);
          const e13 = this._leftPerp(h8), _7 = this._crossProduct(h8, this._sub(i16, c5));
          let u13 = [c5, s15];
          t15.push(u13), u13 = [], u13.push([c5[0] + e13[0] * _7, c5[1] + e13[1] * _7]), u13.push([s15[0] + e13[0] * _7, s15[1] + e13[1] * _7]), t15.push(u13);
          break;
        }
        case R.PerpendicularToFirstSegment: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._mid(c5, s15), e13 = this._sub(s15, c5);
          this._normalize(e13);
          const _7 = this._crossProduct(e13, this._sub(i16, c5));
          this._leftPerpendicular(e13);
          const u13 = [];
          u13.push([h8[0] - e13[0] * _7 * 0.25, h8[1] - e13[1] * _7 * 0.25]), u13.push([h8[0] + e13[0] * _7 * 1.25, h8[1] + e13[1] * _7 * 1.25]), t15.push(u13);
          break;
        }
        case R.ParallelOffset: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(s15, c5);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, c5));
          this._leftPerpendicular(h8);
          const _7 = [];
          _7.push([c5[0] - h8[0] * e13, c5[1] - h8[1] * e13]), _7.push([s15[0] - h8[0] * e13, s15[1] - h8[1] * e13]), t15.push(_7);
          const u13 = [];
          u13.push([c5[0] + h8[0] * e13, c5[1] + h8[1] * e13]), u13.push([s15[0] + h8[0] * e13, s15[1] + h8[1] * e13]), t15.push(u13);
          break;
        }
        case R.OffsetOpposite: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(s15, c5);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, c5));
          this._leftPerpendicular(h8);
          const _7 = [];
          _7.push([c5[0] - h8[0] * e13, c5[1] - h8[1] * e13]), _7.push([s15[0] - h8[0] * e13, s15[1] - h8[1] * e13]), t15.push(_7);
          break;
        }
        case R.OffsetSame: {
          const s15 = this._cp2(r18, 3, 0), i16 = this._cp3(r18, s15, 0.5, -1), h8 = this._sub(s15, c5);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, c5));
          this._leftPerpendicular(h8);
          const _7 = [];
          _7.push([c5[0] + h8[0] * e13, c5[1] + h8[1] * e13]), _7.push([s15[0] + h8[0] * e13, s15[1] + h8[1] * e13]), t15.push(_7);
          break;
        }
        case R.CircleWithArc: {
          let s15 = this._cp2(r18, 3, 0);
          const i16 = this._cp3(r18, s15, 0.5, -1);
          let e13, u13;
          if (_6 >= 4) e13 = r18[3], u13 = this._crossProduct(this._sub(e13, s15), this._sub(i16, s15)) > 0;
          else {
            e13 = s15, u13 = this._crossProduct(this._sub(e13, c5), this._sub(i16, c5)) > 0;
            const t16 = 24 * this._geomUnitsPerPoint, h8 = this._sub(e13, c5);
            this._normalize(h8, t16);
            const r19 = Math.sqrt(2) / 2;
            this._rotateDirect(h8, r19, u13 ? r19 : -r19), s15 = this._add(c5, h8);
          }
          const o8 = this._sub(s15, c5), a12 = Math.cos(Math.PI / 18), n18 = Math.sin(Math.PI / 18), p7 = [s15];
          for (let t16 = 1; t16 <= 36; t16++) this._rotateDirect(o8, a12, n18), p7.push(this._add(c5, o8));
          this._add90DegArc(p7, s15, e13, i16, u13), i6(p7[p7.length - 8], 1), t15.push(p7);
          break;
        }
        case R.DoubleJog: {
          let s15, i16 = this._cp2(r18, -3, 1), h8 = this._cp3(r18, i16, -1, -0.5);
          if (_6 >= 4) s15 = r18[3];
          else {
            const t16 = c5;
            c5 = i16, s15 = h8;
            const e14 = this._dist(c5, t16), r19 = this._dist(s15, t16);
            let _7 = 30 * this._geomUnitsPerPoint;
            0.5 * e14 < _7 && (_7 = 0.5 * e14), 0.5 * r19 < _7 && (_7 = 0.5 * r19), i16 = this._mix(c5, _7 / e14, t16, (e14 - _7) / e14), h8 = this._mix(s15, _7 / r19, t16, (r19 - _7) / r19);
          }
          const e13 = this._mid(c5, i16), u13 = this._mid(s15, h8), o8 = this._dist(c5, i16), a12 = this._dist(h8, s15);
          let n18 = Math.min(o8, a12) / 8;
          n18 = Math.min(n18, 24 * this._geomUnitsPerPoint);
          const p7 = Math.cos(Math.PI / 4);
          let d4 = this._sub(c5, i16);
          this._normalize(d4, n18), this._crossProduct(d4, this._sub(s15, i16)) > 0 ? this._rotateDirect(d4, p7, -p7) : this._rotateDirect(d4, p7, p7);
          let l12 = [];
          l12.push(i16), l12.push(this._add(e13, d4)), l12.push(this._sub(e13, d4)), l12.push(c5), t15.push(l12), d4 = this._sub(s15, h8), this._normalize(d4, n18), this._crossProduct(d4, this._sub(c5, h8)) < 0 ? this._rotateDirect(d4, p7, p7) : this._rotateDirect(d4, p7, -p7), l12 = [], l12.push(h8), l12.push(this._add(u13, d4)), l12.push(this._sub(u13, d4)), l12.push(s15), t15.push(l12);
          break;
        }
        case R.PerpendicularOffset: {
          const s15 = this._cp2(r18, -4, 1), i16 = this._cp3(r18, s15, 0.882353, -1.94), h8 = this._sub(i16, s15);
          this._crossProduct(h8, this._sub(c5, s15)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const e13 = [h8[0] / 8, h8[1] / 8], _7 = this._sub(this._mid(s15, i16), e13);
          t15.push([_7, c5]);
          break;
        }
        case R.LineExcludingLastSegment: {
          const s15 = this._arrowPath(r18), i16 = [];
          let h8 = s15.length - 2;
          for (; h8--; ) i16.push(s15[h8]);
          t15.push(i16);
          break;
        }
        case R.MultivertexArrow: {
          const s15 = this._arrowPath(r18), i16 = [];
          this._addArrow(i16, s15, false), t15.push(i16);
          break;
        }
        case R.CrossedArrow: {
          const s15 = this._arrowPath(r18), i16 = [];
          this._addArrow(i16, s15, true), t15.push(i16);
          break;
        }
        case R.ChevronArrow: {
          const [s15, i16] = this._arrowLastSeg(r18), h8 = 10 * this._geomUnitsPerPoint, e13 = this._sub(c5, s15), _7 = this._norm(e13);
          this._normalize(e13);
          const u13 = this._crossProduct(e13, this._sub(i16, s15));
          let o8 = this._dotProduct(e13, this._sub(i16, s15));
          o8 < 0.05 * _7 ? o8 = 0.05 * _7 : o8 > 0.95 * _7 - h8 && (o8 = 0.95 * _7 - h8);
          const a12 = [s15[0] + e13[0] * o8, s15[1] + e13[1] * o8], n18 = this._leftPerp(e13), p7 = [];
          p7.push([a12[0] + n18[0] * u13 + e13[0] * h8, a12[1] + n18[1] * u13 + e13[1] * h8]), p7.push(c5), p7.push([a12[0] - n18[0] * u13 + e13[0] * h8, a12[1] - n18[1] * u13 + e13[1] * h8]), t15.push(p7);
          break;
        }
        case R.ChevronArrowOffset: {
          const [s15, i16] = this._arrowLastSeg(r18), h8 = this._sub(c5, s15), e13 = this._norm(h8);
          this._normalize(h8);
          const _7 = this._crossProduct(h8, this._sub(i16, s15));
          let u13 = this._dotProduct(h8, this._sub(i16, s15));
          u13 < 0.05 * e13 ? u13 = 0.05 * e13 : u13 > 0.95 * e13 && (u13 = 0.95 * e13);
          const o8 = [s15[0] + h8[0] * u13, s15[1] + h8[1] * u13];
          this._leftPerpendicular(h8);
          const a12 = [];
          a12.push([o8[0] + h8[0] * _7 * 0.5, o8[1] + h8[1] * _7 * 0.5]), a12.push(this._mid(o8, c5)), a12.push([o8[0] - h8[0] * _7 * 0.5, o8[1] - h8[1] * _7 * 0.5]), t15.push(a12);
          break;
        }
        case R.PartialFirstSegment: {
          const [s15, i16] = this._arrowLastSeg(r18), h8 = this._sub(c5, s15), e13 = this._norm(h8);
          this._normalize(h8);
          let _7 = this._dotProduct(h8, this._sub(i16, s15));
          _7 < 0.05 * e13 ? _7 = 0.05 * e13 : _7 > 0.95 * e13 && (_7 = 0.95 * e13);
          const u13 = [s15[0] + h8[0] * _7, s15[1] + h8[1] * _7];
          t15.push([s15, u13]);
          break;
        }
        case R.Arch: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 1), h8 = this._sub(c5, s15), e13 = this._mix(i16, 1, h8, 0.55), _7 = this._mix(i16, 1, h8, -0.55), u13 = [c5];
          this._addBezier2(u13, c5, e13, i16, 4), this._addBezier2(u13, i16, _7, s15, 4), t15.push(u13);
          break;
        }
        case R.CurvedParallelTicks: {
          const s15 = this._cp2(r18, -4, 1), i16 = this._cp3(r18, s15, 0.882353, -1.94), h8 = this._sub(i16, s15);
          this._crossProduct(h8, this._sub(c5, s15)) > 0 ? this._rightPerpendicular(h8) : this._leftPerpendicular(h8);
          const e13 = [h8[0] / 8, h8[1] / 8], _7 = this._sub(this._mid(s15, i16), e13), u13 = this._sub(this._mix(s15, 0.75, i16, 0.25), e13), o8 = this._sub(this._mix(s15, 0.25, i16, 0.75), e13), a12 = [s15];
          this._addBezier2(a12, s15, u13, _7, 3), this._addBezier2(a12, _7, o8, i16, 3), t15.push(a12);
          for (let r19 = 0; r19 < 8; r19++) {
            const s16 = a12[2 * r19 + 1], i17 = [this._clone(s16)];
            i17.push(this._add(s16, [h8[0] / 4, h8[1] / 4])), t15.push(i17);
          }
          break;
        }
        case R.Arc90Degrees: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 1), h8 = [s15];
          this._add90DegArc(h8, s15, c5, i16), t15.push(h8);
          break;
        }
        case R.TipWithPerpendicularAndTicks: {
          const [s15, i16] = this._arrowLastSeg(r18), h8 = 10 * this._geomUnitsPerPoint, e13 = this._sub(c5, s15), _7 = this._norm(e13);
          this._normalize(e13);
          let u13 = this._crossProduct(e13, this._sub(i16, s15)), o8 = this._dotProduct(e13, this._sub(i16, s15));
          o8 < 0.05 * _7 ? o8 = 0.05 * _7 : o8 > 0.95 * _7 - h8 && (o8 = 0.95 * _7 - h8);
          const a12 = this._leftPerp(e13), n18 = [c5[0] - e13[0] * h8, c5[1] - e13[1] * h8], p7 = 0.5 * Math.max(_7 - o8 - h8, h8);
          u13 = Math.abs(u13);
          const d4 = [];
          d4.push([n18[0] + a12[0] * (u13 + p7) - e13[0] * p7, n18[1] + a12[1] * (u13 + p7) - e13[1] * p7]), d4.push([n18[0] + a12[0] * u13, n18[1] + a12[1] * u13]), d4.push([n18[0] - a12[0] * u13, n18[1] - a12[1] * u13]), d4.push([n18[0] - a12[0] * (u13 + p7) - e13[0] * p7, n18[1] - a12[1] * (u13 + p7) - e13[1] * p7]), t15.push(d4), t15.push([n18, c5]);
          break;
        }
        case R.ConcentricCircles: {
          const s15 = this._cp2(r18, 1, 0), i16 = this._cp3(r18, s15, 2, 0), e13 = Math.cos(Math.PI / 18), u13 = Math.sin(Math.PI / 18);
          let o8 = this._dist(s15, c5), a12 = [o8, 0], n18 = [];
          for (let t16 = 0; t16 <= 36; t16++) n18.push(this._add(c5, a12)), this._rotateDirect(a12, e13, u13);
          if (t15.push(n18), _6 >= 4) {
            n18 = [];
            const s16 = r18[3];
            o8 = this._dist(s16, c5), a12 = [o8, 0];
            for (let t16 = 0; t16 <= 36; t16++) n18.push(this._add(c5, a12)), 0 === t16 && (n18.push(this._add(c5, a12)), i6(n18[1], 1)), this._rotateDirect(a12, e13, u13);
            t15.push(n18);
          }
          n18 = [], o8 = this._dist(i16, c5), a12 = [o8, 0];
          for (let t16 = 0; t16 <= 36; t16++) n18.push(this._add(c5, a12)), this._rotateDirect(a12, e13, u13);
          t15.push(n18);
          break;
        }
        case R.DoubleJogArrow: {
          c5 = this._arrowPath(r18)[0];
          const [s15, i16] = this._arrowLastSeg(r18), h8 = this._sub(c5, s15), e13 = this._norm(h8);
          this._normalize(h8);
          const _7 = Math.abs(this._crossProduct(h8, this._sub(i16, c5)));
          let u13 = Math.abs(this._dotProduct(h8, this._sub(i16, c5)));
          u13 < 0.05 * e13 ? u13 = 0.05 * e13 : u13 > 0.95 * e13 && (u13 = 0.95 * e13);
          const o8 = Math.max(_7, u13), a12 = this._leftPerp(h8);
          let n18 = [];
          const p7 = [c5[0] - h8[0] * u13 * 0.5 + a12[0] * _7 * 0.5, c5[1] - h8[1] * u13 * 0.5 + a12[1] * _7 * 0.5];
          n18.push([p7[0], p7[1]]), p7[0] += h8[0] * o8 * 0.5 + a12[0] * o8 * 0.4, p7[1] += h8[1] * o8 * 0.5 + a12[1] * o8 * 0.4, n18.push([p7[0], p7[1]]), p7[0] -= a12[0] * o8 * 0.25, p7[1] -= a12[1] * o8 * 0.25, n18.push([p7[0], p7[1]]), p7[0] += h8[0] * o8 * 0.5 + a12[0] * o8 * 0.4, p7[1] += h8[1] * o8 * 0.5 + a12[1] * o8 * 0.4, n18.push([p7[0], p7[1]]), t15.push(n18), n18 = [], p7[0] = c5[0] - h8[0] * u13 * 0.5 - a12[0] * _7 * 0.5, p7[1] = c5[1] - h8[1] * u13 * 0.5 - a12[1] * _7 * 0.5, n18.push([p7[0], p7[1]]), p7[0] += h8[0] * o8 * 0.5 - a12[0] * o8 * 0.4, p7[1] += h8[1] * o8 * 0.5 - a12[1] * o8 * 0.4, n18.push([p7[0], p7[1]]), p7[0] += a12[0] * o8 * 0.25, p7[1] += a12[1] * o8 * 0.25, n18.push([p7[0], p7[1]]), p7[0] += h8[0] * o8 * 0.5 - a12[0] * o8 * 0.4, p7[1] += h8[1] * o8 * 0.5 - a12[1] * o8 * 0.4, n18.push([p7[0], p7[1]]), t15.push(n18);
          break;
        }
        case R.LinkedChevrons: {
          const s15 = this._cp2(r18, -5, 0), i16 = this._cp3(r18, s15, -0.2, 1), h8 = this._sub(c5, s15);
          this._normalize(h8);
          const e13 = this._leftPerp(h8), _7 = Math.abs(this._crossProduct(h8, this._sub(i16, s15)));
          t15.push([s15, c5]);
          const u13 = [];
          u13.push([c5[0] - h8[0] * _7 + e13[0] * _7, c5[1] - h8[1] * _7 + e13[1] * _7]), u13.push(c5), u13.push([c5[0] - h8[0] * _7 - e13[0] * _7, c5[1] - h8[1] * _7 - e13[1] * _7]), t15.push(u13), this._addDash(t15, s15, [-h8[0] * _7 + e13[0] * _7, -h8[1] * _7 + e13[1] * _7]), this._addDash(t15, s15, [-h8[0] * _7 - e13[0] * _7, -h8[1] * _7 - e13[1] * _7]);
          break;
        }
        case R.SegmentThenHalfCircle: {
          const s15 = this._cp2(r18, 2, 0), i16 = this._cp3(r18, s15, 1.5, 0);
          let h8;
          h8 = _6 >= 4 ? r18[3] : this._cp3(r18, s15, 1.25, -0.5);
          const e13 = this._sub(s15, c5);
          this._normalize(e13);
          const u13 = 0.5 * this._dist(s15, i16), o8 = this._crossProduct(e13, this._sub(h8, c5)) > 0, a12 = Math.cos(Math.PI / 18);
          let n18 = Math.sin(Math.PI / 18);
          o8 && (n18 = -n18);
          const p7 = [c5, s15];
          e13[0] *= u13, e13[1] *= u13;
          const d4 = this._add(s15, e13);
          e13[0] = -e13[0], e13[1] = -e13[1];
          for (let t16 = 1; t16 <= 18; t16++) this._rotateDirect(e13, a12, n18), p7.push(this._add(d4, e13));
          t15.push(p7);
          break;
        }
        case R.LineWithStraightTicks: {
          const s15 = this._cp2(r18, -2, 1), i16 = this._cp3(r18, s15, -1, -0.5), h8 = this._sub(i16, s15);
          this._normalize(h8);
          const e13 = this._dotProduct(h8, this._sub(s15, c5)), _7 = this._dotProduct(h8, this._sub(i16, c5));
          let u13 = [c5];
          u13.push([c5[0] + h8[0] * e13, c5[1] + h8[1] * e13]), u13.push(s15), t15.push(u13), u13 = [c5], u13.push([c5[0] + h8[0] * _7, c5[1] + h8[1] * _7]), u13.push(i16), t15.push(u13);
          break;
        }
        case R.DoubleCurve: {
          const s15 = this._cp2(r18, -5, -1), i16 = this._cp3(r18, s15, 2, 0), e13 = Math.atan2(1, 5), _7 = Math.cos(e13), u13 = Math.sin(e13), o8 = this._sub(s15, c5), a12 = this._dist(c5, s15);
          this._normalize(o8), this._rotateDirect(o8, _7, -u13);
          const n18 = [c5];
          n18.push([c5[0] + o8[0] * a12 * 0.5, c5[1] + o8[1] * a12 * 0.5]), i6(n18[1], 1), n18.push([c5[0] + o8[0] * a12 * 0.8, c5[1] + o8[1] * a12 * 0.8]), this._addBezier2(n18, n18[2], [c5[0] + o8[0] * a12, c5[1] + o8[1] * a12], s15, 3);
          const p7 = this._sub(i16, s15), d4 = this._dist(s15, i16);
          this._normalize(p7), this._rotateDirect(p7, _7, -u13), this._addBezier2(n18, s15, [i16[0] - p7[0] * d4, i16[1] - p7[1] * d4], [i16[0] - p7[0] * d4 * 0.8, i16[1] - p7[1] * d4 * 0.8], 3), n18.push(i16), t15.push(n18);
          break;
        }
        case R.ParallelWithTicksByWidth: {
          const s15 = this._cp2(r18, 0, -1), i16 = this._cp3(r18, s15, 0.5, 3), h8 = this._sub(s15, c5);
          this._normalize(h8);
          const e13 = this._crossProduct(h8, this._sub(i16, c5));
          this._leftPerpendicular(h8), e13 > 0 ? (this._addAngledTicks(t15, c5, [c5[0] + h8[0] * e13, c5[1] + h8[1] * e13], s15), this._addAngledTicks(t15, s15, [s15[0] + h8[0] * e13, s15[1] + h8[1] * e13], c5)) : (this._addAngledTicks(t15, [c5[0] + h8[0] * e13, c5[1] + h8[1] * e13], c5, s15), this._addAngledTicks(t15, [s15[0] + h8[0] * e13, s15[1] + h8[1] * e13], c5, s15));
          break;
        }
        case R.EnclosingRoundedRectangle: {
          const s15 = this._cp2(r18, 3, -2), t16 = [Math.min(c5[0], s15[0]), Math.max(c5[1], s15[1])], i16 = [Math.max(c5[0], s15[0]), Math.min(c5[1], s15[1])], h8 = i16[0] - t16[0], e13 = t16[1] - i16[1], _7 = Math.min(h8, e13) / 10, u13 = [];
          u13.push([t16[0] + _7 + 0.75 * (h8 - 2 * _7), t16[1]]), u13.push([i16[0] - _7, t16[1]]), this._add90DegArc(u13, [i16[0] - _7, t16[1]], [i16[0], t16[1] - _7], [i16[0], t16[1]]), u13.push([i16[0], i16[1] + _7]), this._add90DegArc(u13, [i16[0], i16[1] + _7], [i16[0] - _7, i16[1]], i16), u13.push([t16[0] + _7, i16[1]]), this._add90DegArc(u13, [t16[0] + _7, i16[1]], [t16[0], i16[1] + _7], [t16[0], i16[1]]), u13.push([t16[0], t16[1] - _7]), this._add90DegArc(u13, [t16[0], t16[1] - _7], [t16[0] + _7, t16[1]], t16), u13.push([t16[0] + _7 + 0.75 * (h8 - 2 * _7), t16[1]]);
          break;
        }
        case R.FullGeometry:
        default:
          t15.push(r18);
      }
    }
    return t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectCut.js
var r6 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(e13, t15, i16, r18, n18) {
    return new u8(e13, t15, i16);
  }
};
r6.instance = null;
var u8 = class extends s5 {
  constructor(e13, t15, r18) {
    super(e13, true, true), this._curveHelper = new s6(), this._beginCut = (void 0 !== t15.beginCut ? t15.beginCut : 1) * r18, this._endCut = (void 0 !== t15.endCut ? t15.endCut : 1) * r18, this._middleCut = (void 0 !== t15.middleCut ? t15.middleCut : 0) * r18, this._invert = void 0 !== t15.invert && t15.invert, this._beginCut < 0 && (this._beginCut = 0), this._endCut < 0 && (this._endCut = 0), this._middleCut < 0 && (this._middleCut = 0);
  }
  processPath(t15) {
    const { _beginCut: i16, _endCut: r18, _middleCut: u13 } = this, n18 = t15.pathLength(), s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._invert) {
      if (0 !== i16 || 0 !== r18 || 0 !== u13) if (i16 + r18 + u13 >= n18) for (s13.startPath(); t15.nextPoint(); ) s13.pushXY(t15.x, t15.y);
      else this._curveHelper.appendSubCurve(s13, t15, 0, i16), this._curveHelper.appendSubCurve(s13, t15, 0.5 * (n18 - u13), 0.5 * (n18 + u13)), this._curveHelper.appendSubCurve(s13, t15, n18 - r18, r18);
    } else if (0 === i16 && 0 === r18 && 0 === u13) for (s13.startPath(); t15.nextPoint(); ) s13.pushXY(t15.x, t15.y);
    else i16 + r18 + u13 < n18 && (0 === u13 ? this._curveHelper.appendSubCurve(s13, t15, i16, n18 - r18) : (this._curveHelper.appendSubCurve(s13, t15, i16, 0.5 * (n18 - u13)), this._curveHelper.appendSubCurve(s13, t15, 0.5 * (n18 + u13), n18 - r18)));
    return 0 === s13.totalSize ? null : s13;
  }
};

// node_modules/@arcgis/core/symbols/cim/GeometryWalker.js
var n7 = 1e-7;
var i8 = class {
  constructor() {
    this._values = [], this.extPtGap = 0, this.ctrlPtGap = 0, this._length = 0, this._currentValue = 0;
  }
  isEmpty() {
    return 0 === this._values.length;
  }
  size() {
    return this._values.length;
  }
  init(t15, e13, s13 = true) {
    if (this._setEmpty(), !t15 || 0 === t15.length) return false;
    for (let i16 = 0; i16 < t15.length; i16++) {
      let e14 = Math.abs(t15[i16]);
      s13 && e14 < n7 && (e14 = n7), this._values.push(e14), this._length += e14;
    }
    return e13 && 1 & t15.length && (this._length *= 2), 0 !== this._length && (this.ctrlPtGap = this.extPtGap = 0, this._currentValue = -1, true);
  }
  scale(t15) {
    const e13 = this._values ? this._values.length : 0;
    for (let s13 = 0; s13 < e13; ++s13) this._values[s13] *= t15;
    this._length *= t15, this.extPtGap *= t15, this.ctrlPtGap *= t15;
  }
  addValue(t15) {
    this._length += t15, this._values.push(t15);
  }
  firstValue() {
    return this._values[0];
  }
  lastValue() {
    return this._values[this._values.length - 1];
  }
  nextValue() {
    return this._currentValue++, this._currentValue === this._values.length && (this._currentValue = 0), this._values[this._currentValue];
  }
  reset() {
    this._currentValue = -1;
  }
  length() {
    return this._length;
  }
  _setEmpty() {
    this.extPtGap = this.ctrlPtGap = this._length = 0, this._currentValue = -1, this._values.length = 0;
  }
};
var h3 = class {
  constructor() {
    this.pt = null, this.ca = 0, this.sa = 0;
  }
};
var r7;
!function(t15) {
  t15[t15.FAIL = 0] = "FAIL", t15[t15.END = 1] = "END", t15[t15.CONTINUE = 2] = "CONTINUE";
}(r7 || (r7 = {}));
var a7 = class {
  constructor() {
    this.reset();
  }
  reset() {
    this.segment = null, this.segmentLength = 0, this.abscissa = 0, this.isPathEnd = false, this.isPartEnd = false;
  }
  isValid() {
    return null !== this.segment;
  }
  copyTo(t15) {
    t15.segment = this.segment, t15.segmentLength = this.segmentLength, t15.abscissa = this.abscissa, t15.isPathEnd = this.isPathEnd, t15.isPartEnd = this.isPartEnd;
  }
};
var o2 = class extends s6 {
  constructor(t15 = 0, e13 = false) {
    super(t15, e13), this._tolerance = n5, this._currentPosition = new a7();
  }
  updateTolerance(t15) {
    this._tolerance = n5 * t15;
  }
  init(t15, e13, s13 = true) {
    return s13 ? (this._patternLength = e13.length(), this._partExtPtGap = e13.extPtGap, this._partCtrlPtGap = e13.ctrlPtGap) : (this._patternLength = 0, this._partExtPtGap = 0, this._partCtrlPtGap = 0), this._currentPosition.reset(), this._partSegCount = 0, this._pathCursor = t15, this._seg = -1, this._setPosAtNextPart();
  }
  curPositionIsValid() {
    return this._currentPosition.isValid();
  }
  nextPosition(t15, e13 = r7.FAIL) {
    const s13 = new a7();
    return !!this._nextPosition(t15, s13, null, e13) && (s13.copyTo(this._currentPosition), true);
  }
  curPointAndAngle(t15) {
    t15.pt = this._getPoint(this._currentPosition);
    const [e13, s13] = this._getAngleCS(this._currentPosition);
    t15.ca = e13, t15.sa = s13;
  }
  nextPointAndAngle(t15, e13, s13 = r7.FAIL) {
    const n18 = new a7();
    if (!this._nextPosition(t15, n18, null, s13)) return false;
    n18.copyTo(this._currentPosition), e13.pt = this._getPoint(n18);
    const [i16, h8] = this._getAngleCS(n18);
    return e13.ca = i16, e13.sa = h8, true;
  }
  nextCurve(e13) {
    if (0 === e13) return null;
    const s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    s13.startPath(), s13.nextPath();
    const n18 = new a7();
    return this._nextPosition(e13, n18, s13, r7.END) ? (n18.copyTo(this._currentPosition), s13) : null;
  }
  isPathEnd() {
    return this._currentPosition.isPathEnd;
  }
  getPathEnd() {
    return this._currentPosition.segment[1];
  }
  getPt(t15) {
    return this._pathCursor.seekInPath(t15), [this._pathCursor.x, this._pathCursor.y];
  }
  getSeg(t15) {
    return [this.getPt(t15), this.getPt(t15 + 1)];
  }
  _nextPosition(t15, e13, s13, n18) {
    if (this._currentPosition.isPathEnd) return false;
    let i16 = this._currentPosition.abscissa;
    for (this._currentPosition.segmentLength > 0 && (i16 /= this._currentPosition.segmentLength), this._currentPosition.copyTo(e13); e13.abscissa + t15 * this._partLengthRatio > e13.segmentLength + this._tolerance; ) {
      if (s13) {
        if (0 === s13.pathSize) if (0 === i16) {
          const t17 = e13.segment[0];
          s13.pushXY(t17[0], t17[1]);
        } else s13.pushPoint(this.getSegCoord2D(e13.segment, i16));
        const t16 = e13.segment[1];
        s13.pushXY(t16[0], t16[1]);
      }
      if (i16 = 0, t15 -= (e13.segmentLength - e13.abscissa) / this._partLengthRatio, this._partSegCount) e13.segment = this._nextSegment(), e13.segmentLength = this.getSegLength(e13.segment), e13.abscissa = 0, this._partSegCount--;
      else {
        if (!this._setPosAtNextPart()) return n18 !== r7.FAIL && (e13.segmentLength = this.getSegLength(e13.segment), e13.isPartEnd = true, n18 === r7.END ? (e13.abscissa = e13.segmentLength, e13.isPathEnd = true) : e13.abscissa = e13.segmentLength + t15, true);
        this._currentPosition.copyTo(e13);
      }
    }
    if (e13.abscissa += t15 * this._partLengthRatio, s13) {
      0 === s13.pathSize && (0 === i16 ? s13.pushPoint(e13.segment[0]) : s13.pushPoint(this.getSegCoord2D(e13.segment, i16)));
      const t16 = e13.abscissa / e13.segmentLength;
      1 === t16 ? s13.pushPoint(e13.segment[1]) : s13.pushPoint(this.getSegCoord2D(e13.segment, t16));
    }
    return this._partSegCount || Math.abs(e13.abscissa - e13.segmentLength) < this._tolerance && (e13.isPathEnd = this._partIsLast, e13.isPartEnd = true), true;
  }
  _getPoint(t15) {
    const e13 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegCoord2D(this._currentPosition.segment, e13);
  }
  _getAngleCS(t15) {
    const e13 = t15.segmentLength <= 0 ? 0 : t15.abscissa / t15.segmentLength;
    return this.getSegAngleCS(this._currentPosition.segment, e13);
  }
  _setPosAtNextPart() {
    for (; this._partSegCount; ) this._hasNextSegment() && this._nextSegment(), this._partSegCount--;
    if (!this._hasNextSegment()) return false;
    for (this._partLength = 0, this._partIsLast = true, this._partSegCount = 0; this._hasNextSegment(); ) if (this._partLength += this.getSegLength(this._nextSegment()), this._partSegCount++, this._pathCursor.getControlPointAt(this._getEndPointIndex())) {
      this._partIsLast = !this._hasNextSegment();
      break;
    }
    let t15 = this._partSegCount;
    for (; t15; ) this._previousSegment(), --t15;
    this._currentPosition.segment = this._nextSegment(), this._currentPosition.segmentLength = this.getSegLength(this._currentPosition.segment), this._currentPosition.abscissa = 0, this._currentPosition.isPathEnd = this._currentPosition.isPartEnd = false, --this._partSegCount;
    const e13 = this._getStartPointIndex();
    this._ctrlPtBegin = this._pathCursor.getControlPointAt(e13);
    let s13 = e13 + this._partSegCount + 1;
    if (s13 >= this._pathCursor.pathSize && (s13 = 0), this._ctrlPtEnd = this._pathCursor.getControlPointAt(s13), this._patternLength > 0) {
      const t16 = this._ctrlPtBegin ? this._partCtrlPtGap : this._partExtPtGap, e14 = this._ctrlPtEnd ? this._partCtrlPtGap : this._partExtPtGap;
      let s14 = Math.round((this._partLength - (t16 + e14)) / this._patternLength);
      s14 <= 0 && (s14 = t16 + e14 > 0 ? 0 : 1), this._partLengthRatio = this._partLength / (t16 + e14 + s14 * this._patternLength), this._partLengthRatio < 0.01 && (this._partLengthRatio = 1);
    } else this._partLengthRatio = 1;
    return true;
  }
  _hasNextSegment() {
    return this._seg < this._pathCursor.pathSize - 2;
  }
  _previousSegment() {
    return this.getSeg(--this._seg);
  }
  _nextSegment() {
    return this.getSeg(++this._seg);
  }
  _getStartPointIndex() {
    return this._seg;
  }
  _getEndPointIndex() {
    return this._seg + 1;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDashes.js
var h4 = class _h {
  static local() {
    return null === _h.instance && (_h.instance = new _h()), _h.instance;
  }
  execute(t15, e13, s13, i16, r18) {
    return new l6(t15, e13, s13);
  }
};
h4.instance = null;
var l6 = class extends s5 {
  constructor(t15, e13, s13) {
    super(t15, true, true), this._firstCurve = null, this._walker = new o2(), this._walker.updateTolerance(s13), this._endings = e13.lineDashEnding, this._customDashPos = -(e13.offsetAlongLine ?? 0) * s13, this._offsetAtEnd = (e13.customEndingOffset ?? 0) * s13;
    let i16 = B2(e13).dashTemplate;
    null == i16 && (i16 = []), i16.length % 2 && (i16 = [...i16, ...i16]), this._pattern = new i8(), this._pattern.init(i16, true), this._pattern.scale(s13);
  }
  processPath(s13) {
    if (0 === this._pattern.length()) {
      this.iteratePath = false;
      const i16 = n2(s13);
      return a6.fromJSONCIM({ paths: [i16] });
    }
    if (!this.iteratePath) {
      let r19 = true;
      switch (this._endings) {
        case b.HalfPattern:
        case b.HalfGap:
        default:
          this._pattern.extPtGap = 0;
          break;
        case b.FullPattern:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.firstValue());
          break;
        case b.FullGap:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._pattern.lastValue());
          break;
        case b.NoConstraint:
          this.isClosed || (r19 = false);
          break;
        case b.Custom:
          this.isClosed || (this._pattern.extPtGap = 0.5 * this._offsetAtEnd);
      }
      const a13 = s13.pathLength();
      if (this._pattern.isEmpty() || a13 < 0.1 * this._pattern.length()) {
        const i16 = n2(s13);
        return a6.fromJSONCIM({ paths: [i16] });
      }
      if (!this._walker.init(s13, this._pattern, r19)) {
        const i16 = n2(s13);
        return a6.fromJSONCIM({ paths: [i16] });
      }
    }
    let r18;
    if (this.iteratePath) r18 = this._pattern.nextValue();
    else {
      let t15;
      switch (this._endings) {
        case b.HalfPattern:
        default:
          t15 = 0.5 * this._pattern.firstValue();
          break;
        case b.HalfGap:
          t15 = 0.5 * -this._pattern.lastValue();
          break;
        case b.FullGap:
          t15 = -this._pattern.lastValue();
          break;
        case b.FullPattern:
          t15 = 0;
          break;
        case b.NoConstraint:
        case b.Custom:
          t15 = -this._customDashPos;
      }
      let e13 = t15 / this._pattern.length();
      e13 -= Math.floor(e13), t15 = e13 * this._pattern.length(), this._pattern.reset(), r18 = this._pattern.nextValue();
      let s14 = false;
      for (; t15 >= r18; ) t15 -= r18, r18 = this._pattern.nextValue(), s14 = !s14;
      r18 -= t15, s14 ? (this._walker.nextPosition(r18), r18 = this._pattern.nextValue()) : this.isClosed && (this._firstCurve = this._walker.nextCurve(r18), r18 = this._pattern.nextValue(), this._walker.nextPosition(r18), r18 = this._pattern.nextValue());
    }
    let a12 = this._walker.nextCurve(r18);
    if (a12) if (this._walker.isPathEnd()) {
      if (this.iteratePath = false, this._firstCurve) {
        for (this._firstCurve.nextPath(); this._firstCurve.nextPoint(); ) a12.pushXY(this._firstCurve.x, this._firstCurve.y);
        this._firstCurve = null;
      }
    } else r18 = this._pattern.nextValue(), !this._walker.nextPosition(r18) || this._walker.isPathEnd() ? (this.iteratePath = false, this._firstCurve && (a12.pushCursor(this._firstCurve), this._firstCurve = null)) : this.iteratePath = true;
    else this.iteratePath = false, a12 = this._firstCurve, this._firstCurve = null;
    return a12 == null ? void 0 : a12.reset(), a12;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectDonut.js
var s8 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(t15, i16, e13, n18, s13, o8) {
    return new r8(t15, i16, e13, n18, s13, o8);
  }
};
s8.instance = null;
var r8 = class {
  constructor(t15, i16, n18, s13, r18, o8) {
    switch (this._inputGeometries = t15, this._tileKey = s13, this._geometryEngine = r18, this._maxInflateSize = o8 * n18, this._width = (void 0 !== i16.width ? i16.width : 2) * n18, i16.method) {
      case B.Mitered:
      case B.Bevelled:
      case B.Rounded:
      case B.TrueBuffer:
      case B.Square:
    }
    this._option = i16.option;
  }
  next() {
    let e13;
    for (; e13 = this._inputGeometries.next(); ) {
      if ("esriGeometryEnvelope" === e13.geometryType && this._width > 0) {
        const i16 = e13.asJSON();
        return Math.min(i16.xmax - i16.xmin, i16.ymax - i16.ymin) - 2 * this._width < 0 ? e13 : a6.fromJSONCIM({ paths: [[[i16.xmin + this._width, i16.ymin + this._width], [i16.xmax - this._width, i16.ymin + this._width], [i16.xmax - this._width, i16.ymax - this._width], [i16.xmin + this._width, i16.ymax - this._width], [i16.xmin + this._width, i16.ymin + this._width]], [[i16.xmin, i16.ymin], [i16.xmin, i16.ymax], [i16.xmax, i16.ymax], [i16.xmax, i16.ymin], [i16.xmin, i16.ymin]]] });
      }
      if ("esriGeometryPolygon" === e13.geometryType) {
        if (0 === this._width) return e13.clone();
        const t15 = this._geometryEngine;
        if (null == t15) return null;
        const s13 = this._tileKey ? i7(e13, this._maxInflateSize) : e13.clone();
        if (!s13) continue;
        const r18 = t15.buffer(g.WebMercator, s13.asJSON(), -this._width, 1);
        if (r18) {
          for (const i16 of r18.rings) if (i16) {
            s13.startPath();
            for (const t16 of i16.reverse()) s13.pushXY(t16[0], s13.yFactor * t16[1]);
          }
        }
        return s13;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectJog.js
var e6 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, i16, s13, e13, o8) {
    return new n8(t15, i16, s13);
  }
};
e6.instance = null;
var n8 = class extends s5 {
  constructor(t15, i16, e13) {
    super(t15, false, true), this._curveHelper = new s6(), this._length = (void 0 !== i16.length ? i16.length : 20) * e13, this._angle = void 0 !== i16.angle ? i16.angle : 225, this._position = void 0 !== i16.position ? i16.position : 50, this._length < 0 && (this._length = -this._length), this._position < 20 && (this._position = 20), this._position > 80 && (this._position = 80), this._mirror = false;
  }
  processPath(i16) {
    const s13 = a6.createEmptyOptimizedCIM("esriGeometryPolyline");
    if (this._curveHelper.isEmpty(i16)) return null;
    i16.seekInPath(0);
    const e13 = i16.x, n18 = i16.y;
    i16.seekInPath(i16.pathSize - 1);
    const o8 = i16.x, r18 = i16.y, h8 = [o8 - e13, r18 - n18];
    this._curveHelper.normalize(h8);
    const l12 = e13 + (o8 - e13) * this._position / 100, _6 = n18 + (r18 - n18) * this._position / 100, a12 = Math.cos((90 - this._angle) / 180 * Math.PI);
    let p7 = Math.sin((90 - this._angle) / 180 * Math.PI);
    this._mirror && (p7 = -p7), this._mirror = !this._mirror;
    const c5 = [l12 - this._length / 2 * a12, _6 - this._length / 2 * p7], m7 = [l12 + this._length / 2 * a12, _6 + this._length / 2 * p7];
    return s13.pushPath([[e13, n18], c5, m7, [o8, r18]]), s13;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectMove.js
var t7 = class _t {
  static local() {
    return null === _t.instance && (_t.instance = new _t()), _t.instance;
  }
  execute(t15, s13, n18, o8, i16) {
    return new e7(t15, s13, n18);
  }
};
t7.instance = null;
var e7 = class {
  constructor(t15, e13, s13) {
    this._inputGeometries = t15, this._offsetX = void 0 !== e13.offsetX ? e13.offsetX * s13 : 0, this._offsetY = void 0 !== e13.offsetY ? e13.offsetY * s13 : 0;
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (t15.totalSize > 0) return this._move(t15.clone(), this._offsetX, this._offsetY);
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _move(t15, e13, s13) {
    for (; t15.nextPath(); ) for (; t15.nextPoint(); ) t15.x = t15.x + e13, t15.y = t15.y + s13;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectOffset.js
var f5 = 10;
var h5 = class _h {
  static local() {
    return null === _h.instance && (_h.instance = new _h()), _h.instance;
  }
  execute(t15, e13, s13, o8, r18, i16) {
    return new l7(t15, e13, s13, o8, r18, i16);
  }
};
h5.instance = null;
var l7 = class {
  constructor(t15, e13, s13, o8, n18, m7) {
    this._inputGeometries = t15, this._tileKey = o8, this._geometryEngine = n18, this._curveHelper = new s6(), this._offset = (e13.offset ?? 1) * s13, this._method = e13.method, this._maxInflateSize = Math.max(Math.abs(m7 * s13), f5), this._option = e13.option, this._offsetFlattenError = n5 * s13;
  }
  next() {
    let r18;
    for (; r18 = this._inputGeometries.next(); ) {
      if (0 === this._offset) return r18.clone();
      if ("esriGeometryEnvelope" === r18.geometryType) {
        if (this._method === N.Rounded && this._offset > 0) {
          const s13 = n2(r18), o9 = this._curveHelper.offset(s13, -this._offset, this._method, 4, this._offsetFlattenError);
          if (o9) {
            const e13 = a6.createEmptyOptimizedCIM(r18.geometryType);
            return e13.pushPath(o9), e13;
          }
          return null;
        }
        const o8 = r18.asJSON();
        if (m(o8) && Math.min(o8.xmax - o8.xmin, o8.ymax - o8.ymin) + 2 * this._offset > 0) return a6.fromJSONCIM({ xmin: o8.xmin - this._offset, xmax: o8.xmax + this._offset, ymin: o8.ymin - this._offset, ymax: o8.ymax + this._offset });
      }
      const i16 = this._geometryEngine;
      if (null == i16) continue;
      const f7 = this._tileKey ? i7(r18, this._maxInflateSize) : r18.clone();
      if (!f7) continue;
      const h8 = i16.offset(g.WebMercator, f7.asJSON(), -this._offset, 1, this._method, 4, this._offsetFlattenError);
      return h8 ? a6.fromJSONCIM(h8) : null;
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectReverse.js
var e8 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(e13, n18, r18, s13, i16) {
    return new t8(e13, n18, r18);
  }
};
e8.instance = null;
var t8 = class {
  constructor(e13, t15, n18) {
    this._inputGeometries = e13, this._reverse = void 0 === t15.reverse || t15.reverse;
  }
  next() {
    let e13 = this._inputGeometries.next();
    for (; e13; ) {
      if (!this._reverse) return e13;
      if ("esriGeometryPolyline" === e13.geometryType) return n9(e13.clone());
      e13 = this._inputGeometries.next();
    }
    return null;
  }
};
function n9(e13) {
  for (; e13.nextPath(); ) for (let t15 = 0; t15 < e13.pathSize / 2; t15++) {
    e13.seekInPath(t15);
    const n18 = e13.x, r18 = e13.y;
    e13.seekInPath(e13.pathSize - t15 - 1);
    const s13 = e13.x, i16 = e13.y;
    e13.x = n18, e13.y = r18, e13.seekInPath(t15), e13.x = s13, e13.y = i16;
  }
  return e13.reset(), e13;
}

// node_modules/@arcgis/core/symbols/cim/effects/EffectRotate.js
var e9 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e13, r18, s13, o8) {
    return new n10(t15, e13, r18);
  }
};
e9.instance = null;
var n10 = class {
  constructor(t15, e13, n18) {
    this._inputGeometries = t15, this._rotateAngle = void 0 !== e13.angle ? e13.angle * Math.PI / 180 : 0;
  }
  next() {
    let e13 = this._inputGeometries.next();
    for (; e13; ) {
      if (0 === this._rotateAngle || "esriGeometryPoint" === e13.geometryType) return e13;
      if (e13.totalSize > 0) {
        const n18 = c(e13), r18 = (n18[2] + n18[0]) / 2, s13 = (n18[3] + n18[1]) / 2;
        return e13.reset(), this._rotate(e13.clone(), r18, s13);
      }
      e13 = this._inputGeometries.next();
    }
    return null;
  }
  _rotate(t15, e13, n18) {
    const r18 = Math.cos(this._rotateAngle), s13 = Math.sin(this._rotateAngle);
    for (; t15.nextPath(); ) for (; t15.nextPoint(); ) {
      const o8 = t15.x - e13, i16 = t15.y - n18;
      t15.x = e13 + o8 * r18 - i16 * s13, t15.y = n18 + o8 * s13 + i16 * r18;
    }
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectScale.js
var e10 = class _e {
  static local() {
    return null === _e.instance && (_e.instance = new _e()), _e.instance;
  }
  execute(t15, e13, o8, s13, n18) {
    return new r9(t15, e13, o8);
  }
};
e10.instance = null;
var r9 = class {
  constructor(t15, e13, r18) {
    this._inputGeometries = t15, this._xFactor = void 0 !== e13.xScaleFactor ? e13.xScaleFactor : 1.15, this._yFactor = void 0 !== e13.yScaleFactor ? e13.yScaleFactor : 1.15;
  }
  next() {
    const e13 = this._inputGeometries.next();
    if (e13) {
      if (1 === this._xFactor && 1 === this._yFactor) return e13;
      if ("esriGeometryPoint" === e13.geometryType) return e13;
      if (e13.totalSize > 0) {
        const r18 = c(e13), o8 = (r18[2] + r18[0]) / 2, s13 = (r18[3] + r18[1]) / 2;
        return e13.reset(), this._scaleCursor(e13.clone(), o8, s13);
      }
    }
    return null;
  }
  _scaleCursor(t15, e13, r18) {
    for (; t15.nextPath(); ) for (; t15.nextPoint(); ) t15.x = e13 + (t15.x - e13) * this._xFactor, t15.y = r18 + (t15.y - r18) * this._yFactor;
    return t15.reset(), t15;
  }
};

// node_modules/@arcgis/core/symbols/cim/effects/EffectWave.js
var n11 = class _n {
  static local() {
    return null === _n.instance && (_n.instance = new _n()), _n.instance;
  }
  execute(t15, e13, i16, s13, h8) {
    return new r10(t15, e13, i16);
  }
};
n11.instance = null;
var r10 = class {
  constructor(t15, e13, h8) {
    this._inputGeometries = t15, this._height = (void 0 !== e13.amplitude ? e13.amplitude : 2) * h8, this._period = (void 0 !== e13.period ? e13.period : 3) * h8, this._style = e13.waveform, this._height <= 0 && (this._height = Math.abs(this._height)), this._period <= 0 && (this._period = Math.abs(this._period)), this._pattern = new i8(), this._pattern.addValue(this._period), this._pattern.addValue(this._period), this._walker = new o2(), this._walker.updateTolerance(h8);
  }
  next() {
    let t15 = this._inputGeometries.next();
    for (; t15; ) {
      if (0 === this._height || 0 === this._period) return t15;
      const e13 = this._processGeom(t15);
      if (e13) return e13;
      t15 = this._inputGeometries.next();
    }
    return null;
  }
  _processGeom(i16) {
    const s13 = a6.createEmptyOptimizedCIM(i16.geometryType);
    for (; i16.nextPath(); ) {
      s13.startPath();
      const t15 = i16.pathLength();
      if (this._walker.init(i16, this._pattern)) switch (this._style) {
        case E.Sinus:
        default:
          this._constructCurve(s13, t15, false);
          break;
        case E.Square:
          this._constructSquare(s13, t15);
          break;
        case E.Triangle:
          this._constructTriangle(s13, t15);
          break;
        case E.Random:
          this._constructCurve(s13, t15, true);
      }
      else for (; i16.nextPoint(); ) s13.pushXY(i16.x, i16.y);
    }
    return s13;
  }
  _constructCurve(t15, e13, i16) {
    let s13 = Math.round(e13 / this._period);
    0 === s13 && (s13 = 1);
    const n18 = s13 * 16 + 1, r18 = e13 / s13, a12 = this._period / 16, o8 = 1 / n18, p7 = 2 * Math.PI * e13 / r18, _6 = 2 * Math.PI * Math.random(), u13 = 2 * Math.PI * Math.random(), l12 = 2 * Math.PI * Math.random(), c5 = 0.75 - Math.random() / 2, d4 = 0.75 - Math.random() / 2, g5 = new h3();
    this._walker.curPointAndAngle(g5), t15.pushPoint(g5.pt);
    let w5 = 0;
    for (; ; ) {
      if (!this._walker.nextPointAndAngle(a12, g5)) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
      {
        const e14 = w5;
        let s14;
        if (w5 += o8, i16) {
          const t16 = this._height / 2 * (1 + 0.3 * Math.sin(c5 * p7 * e14 + _6));
          s14 = t16 * Math.sin(p7 * e14 + u13), s14 += t16 * Math.sin(d4 * p7 * e14 + l12), s14 /= 2;
        } else s14 = 0.5 * this._height * Math.sin(0.5 * p7 * e14);
        t15.pushXY(g5.pt[0] - s14 * g5.sa, g5.pt[1] + s14 * g5.ca);
      }
    }
  }
  _constructSquare(t15, e13) {
    Math.round(e13 / this._period);
    let i16 = true;
    for (; ; ) {
      let e14 = false;
      if (this._walker.curPositionIsValid()) {
        const s13 = new h3();
        this._walker.curPointAndAngle(s13);
        const n18 = new h3();
        if (this._walker.nextPointAndAngle(this._period, n18)) {
          const r18 = new h3();
          this._walker.nextPointAndAngle(this._period, r18) && (i16 ? (t15.pushPoint(s13.pt), i16 = false) : t15.pushPoint(s13.pt), t15.pushXY(s13.pt[0] - this._height / 2 * s13.sa, s13.pt[1] + this._height / 2 * s13.ca), t15.pushXY(n18.pt[0] - this._height / 2 * n18.sa, n18.pt[1] + this._height / 2 * n18.ca), t15.pushXY(n18.pt[0] + this._height / 2 * n18.sa, n18.pt[1] - this._height / 2 * n18.ca), t15.pushXY(r18.pt[0] + this._height / 2 * r18.sa, r18.pt[1] - this._height / 2 * r18.ca), e14 = true);
        }
      }
      if (!e14) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
  _constructTriangle(t15, e13) {
    Math.round(e13 / this._period);
    let i16 = true;
    for (; ; ) {
      let e14 = false;
      if (this._walker.curPositionIsValid()) {
        const s13 = new h3();
        this._walker.curPointAndAngle(s13);
        const n18 = new h3();
        if (this._walker.nextPointAndAngle(this._period / 2, n18)) {
          const r18 = new h3();
          this._walker.nextPointAndAngle(this._period, r18) && (this._walker.nextPosition(this._period / 2) && (i16 ? (t15.pushPoint(s13.pt), i16 = false) : t15.pushPoint(s13.pt), t15.pushXY(n18.pt[0] - this._height / 2 * n18.sa, n18.pt[1] + this._height / 2 * n18.ca), t15.pushXY(r18.pt[0] + this._height / 2 * r18.sa, r18.pt[1] - this._height / 2 * r18.ca)), e14 = true);
        }
      }
      if (!e14) {
        t15.pushPoint(this._walker.getPathEnd());
        break;
      }
    }
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAlongLineSameSize.js
var a8 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, e13, s13, i16, n18) {
    return new r11(t15, e13, s13);
  }
};
a8.instance = null;
var r11 = class extends r3 {
  constructor(t15, e13, n18) {
    super(t15), this._geometryWalker = new o2(), this._geometryWalker.updateTolerance(n18), this._angleToLine = e13.angleToLine ?? true, this._offset = (e13.offset ? e13.offset : 0) * n18, this._originalEndings = e13.endings, this._offsetAtEnd = (e13.customEndingOffset ? e13.customEndingOffset : 0) * n18, this._position = -(e13.offsetAlongLine ? e13.offsetAlongLine : 0) * n18, this._pattern = new i8(), this._pattern.init(e13.placementTemplate, false), this._pattern.scale(n18), this._endings = this._originalEndings;
  }
  processPath(t15) {
    if (this._pattern.isEmpty()) return null;
    let s13;
    if (this.iteratePath) s13 = this._pattern.nextValue();
    else {
      this._originalEndings === Y2.WithFullGap && this.isClosed ? this._endings = Y2.WithMarkers : this._endings = this._originalEndings, this._pattern.extPtGap = 0;
      let i17, n18 = true;
      switch (this._endings) {
        case Y2.NoConstraint:
          i17 = -this._position, i17 = this._adjustPosition(i17), n18 = false;
          break;
        case Y2.WithHalfGap:
        default:
          i17 = -this._pattern.lastValue() / 2;
          break;
        case Y2.WithFullGap:
          i17 = -this._pattern.lastValue(), this._pattern.extPtGap = this._pattern.lastValue();
          break;
        case Y2.WithMarkers:
          i17 = 0;
          break;
        case Y2.Custom:
          i17 = -this._position, i17 = this._adjustPosition(i17), this._pattern.extPtGap = 0.5 * this._offsetAtEnd;
      }
      if (!this._geometryWalker.init(t15, this._pattern, n18)) return null;
      this._pattern.reset();
      let a12 = 0;
      for (; i17 > a12; ) i17 -= a12, a12 = this._pattern.nextValue();
      a12 -= i17, s13 = a12, this.iteratePath = true;
    }
    const i16 = new h3();
    return this._geometryWalker.nextPointAndAngle(s13, i16) ? this._endings === Y2.WithFullGap && this._geometryWalker.isPathEnd() ? (this.iteratePath = false, null) : this._endings === Y2.WithMarkers && this._geometryWalker.isPathEnd() && (this.iteratePath = false, this.isClosed) ? null : (this.internalPlacement.setTranslate(i16.pt[0] - this._offset * i16.sa, i16.pt[1] + this._offset * i16.ca), this._angleToLine && this.internalPlacement.setRotateCS(i16.ca, i16.sa), this.internalPlacement) : (this.iteratePath = false, null);
  }
  _adjustPosition(t15) {
    let e13 = t15 / this._pattern.length();
    return e13 -= Math.floor(e13), e13 * this._pattern.length();
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtExtremities.js
var i9 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t15, e13, s13, i16, n18) {
    return new r12(t15, e13, s13);
  }
};
i9.instance = null;
var r12 = class extends r3 {
  constructor(t15, s13, i16) {
    super(t15, false, true), this._curveHelper = new s6(), this._placePerPart = s13.placePerPart ?? false, this._angleToLine = void 0 === s13.angleToLine || s13.angleToLine, this._offset = void 0 !== s13.offset ? s13.offset * i16 : 0, this._type = s13.extremityPlacement, this._position = void 0 !== s13.offsetAlongLine ? s13.offsetAlongLine * i16 : 0, this._beginProcessed = false;
  }
  processMultiPath(t15) {
    return this._placePerPart ? super.processMultiPath(t15) : this.processPath(t15);
  }
  processPath(t15) {
    let e13;
    switch (this._type) {
      case r.Both:
      default:
        this._beginProcessed ? (e13 = this._atExtremities(t15, this._position, false), this._beginProcessed = false, this.iterateMultiPath = false, this.iteratePath = false) : (e13 = this._atExtremities(t15, this._position, true), this._beginProcessed = true, this.iterateMultiPath = true, this.iteratePath = true);
        break;
      case r.JustBegin:
        e13 = this._atExtremities(t15, this._position, true);
        break;
      case r.JustEnd:
        e13 = this._atExtremities(t15, this._position, false);
      case r.None:
    }
    return e13;
  }
  _atExtremities(t15, e13, s13) {
    if (this._placePerPart || (s13 ? t15.seekPath(0) : t15.seekPath(t15.totalSize - 1)), s13 || t15.seekPathEnd(), s13 ? t15.nextPoint() : t15.prevPoint()) {
      let i16 = 0, [r18, n18] = [0, 0], [a12, o8] = [t15.x, t15.y];
      for (; s13 ? t15.nextPoint() : t15.prevPoint(); ) {
        r18 = a12, n18 = o8, a12 = t15.x, o8 = t15.y;
        const s14 = this._curveHelper.getLength(r18, n18, a12, o8);
        if (i16 + s14 > e13) {
          const t16 = (e13 - i16) / s14, [h8, l12] = this._curveHelper.getAngleCS(r18, n18, a12, o8, t16), c5 = this._curveHelper.getCoord2D(r18, n18, a12, o8, t16);
          return this.internalPlacement.setTranslate(c5[0] - this._offset * l12, c5[1] + this._offset * h8), this._angleToLine && this.internalPlacement.setRotateCS(-h8, -l12), this.internalPlacement;
        }
        i16 += s14;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementAtRatioPositions.js
var a9 = class _a {
  static local() {
    return null === _a.instance && (_a.instance = new _a()), _a.instance;
  }
  execute(t15, i16, s13, e13, n18) {
    return new r13(t15, i16, s13);
  }
};
a9.instance = null;
var r13 = class extends r3 {
  constructor(t15, e13, n18) {
    super(t15), this._walker = new o2(), this._walker.updateTolerance(n18), this._angleToLine = void 0 === e13.angleToLine || e13.angleToLine, this._offset = void 0 !== e13.offset ? e13.offset * n18 : 0, this._beginGap = void 0 !== e13.beginPosition ? e13.beginPosition * n18 : 0, this._endGap = void 0 !== e13.endPosition ? e13.endPosition * n18 : 0, this._flipFirst = void 0 === e13.flipFirst || e13.flipFirst, this._pattern = new i8(), this._pattern.init(e13.positionArray, false, false), this._subPathLen = 0, this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0;
  }
  processPath(t15) {
    if (this._pattern.isEmpty()) return null;
    let i16;
    if (this.iteratePath) {
      const t16 = this._pattern.nextValue() * this._subPathLen, s14 = this._beginGap + t16;
      i16 = s14 - this._prevPos, this._prevPos = s14;
    } else {
      if (this._posCount = this._pattern.size(), this._isFirst = true, this._prevPos = 0, this._subPathLen = t15.pathLength() - this._beginGap - this._endGap, this._subPathLen < 0) return this.iteratePath = false, null;
      if (!this._walker.init(t15, this._pattern, false)) return null;
      this._pattern.reset();
      const s14 = this._pattern.nextValue() * this._subPathLen, e13 = this._beginGap + s14;
      i16 = e13 - this._prevPos, this._prevPos = e13, this.iteratePath = true;
    }
    const s13 = new h3();
    if (!this._walker.nextPointAndAngle(i16, s13, r7.END)) return this.iteratePath = false, null;
    this.internalPlacement.setTranslate(s13.pt[0] - this._offset * s13.sa, s13.pt[1] + this._offset * s13.ca);
    const a12 = this._isFirst && this._flipFirst;
    let r18, h8;
    return this._angleToLine ? (r18 = s13.ca, h8 = s13.sa) : (r18 = 1, h8 = 0), a12 && (r18 = -r18, h8 = -h8), this.internalPlacement.setRotateCS(r18, h8), this._isFirst = false, this._posCount--, 0 === this._posCount && (this.iteratePath = false), this.internalPlacement;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementInsidePolygon.js
var e11 = 512;
var h6 = 10;
var n12 = 24;
var _3 = 1e-6;
var r14 = class _r {
  static local() {
    return null === _r.instance && (_r.instance = new _r()), _r.instance;
  }
  execute(t15, s13, i16, e13, h8) {
    return new a10(t15, s13, i16, e13, h8);
  }
};
r14.instance = null;
var a10 = class _a {
  constructor(h8, n18, _6, r18, a12) {
    if (this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, this._currentX = 0, this._currentY = 0, this._accelerationMap = null, this._testInsidePolygon = false, this._verticalSubdivision = true, this._stepX = Math.abs(n18.stepX ?? 16) * _6, this._stepY = Math.abs(n18.stepY ?? 16) * _6, this._stepX = Math.round(128 * this._stepX) / 128, this._stepY = Math.round(128 * this._stepY) / 128, 0 !== this._stepX && 0 !== this._stepY) {
      if (this._gridType = n18.gridType ?? Z.Fixed, this._gridType === Z.Random) {
        const s13 = n18.seed ?? 13, i16 = 1;
        this._randomLCG = new t(s13 * i16), this._randomness = (n18.randomness ?? 100) / 100, this._gridAngle = 0, this._shiftOddRows = false, this._cosAngle = 1, this._sinAngle = 0, this._offsetX = 0, this._offsetY = 0, this._buildRandomValues();
      } else {
        if (this._randomness = 0, this._gridAngle = n18.gridAngle ?? 0, this._shiftOddRows = n18.shiftOddRows ?? false, this._offsetX = (n18.offsetX ?? 0) * _6, this._offsetY = (n18.offsetY ?? 0) * _6, this._cosAngle = Math.cos(this._gridAngle / 180 * Math.PI), this._sinAngle = -Math.sin(this._gridAngle / 180 * Math.PI), this._stepX) if (this._offsetX < 0) for (; this._offsetX < -0.5 * this._stepX; ) this._offsetX += this._stepX;
        else for (; this._offsetX >= 0.5 * this._stepX; ) this._offsetX -= this._stepX;
        if (this._stepY) if (this._offsetY < 0) for (; this._offsetY < -0.5 * this._stepY; ) this._offsetY += this._stepY;
        else for (; this._offsetY >= 0.5 * this._stepY; ) this._offsetY -= this._stepY;
      }
      if (this._graphicOriginX = 0, this._graphicOriginY = 0, null != r18) {
        const [t15, s13, i16, h9] = r18.split("/"), n19 = parseFloat(t15), _7 = parseFloat(s13), a13 = parseFloat(i16), o8 = parseFloat(h9);
        this._graphicOriginX = -(o8 * 2 ** n19 + a13) * e11, this._graphicOriginY = _7 * e11, this._testInsidePolygon = true;
      }
      this._internalPlacement = new t6(), this._calculateMinMax(h8), this._geometryCursor = h8;
    }
  }
  next() {
    return this._geometryCursor ? this._nextInside() : null;
  }
  _buildRandomValues() {
    if (!_a._randValues) {
      _a._randValues = [];
      for (let t15 = 0; t15 < n12; t15++) for (let s13 = 0; s13 < n12; s13++) _a._randValues.push(this._randomLCG.getFloat()), _a._randValues.push(this._randomLCG.getFloat());
    }
  }
  _calculateMinMax(t15) {
    let s13, i16, h8, n18, _6, r18, a12, o8, l12, f7, c5, u13, p7, M4;
    this._xMin = 0, this._xMax = 0, this._yMin = 0, this._yMax = 0, a12 = o8 = p7 = c5 = Number.MAX_VALUE, l12 = f7 = M4 = u13 = -Number.MAX_VALUE;
    const g5 = 1 !== this._cosAngle;
    for (t15.reset(); t15.nextPath(); ) for (; t15.nextPoint(); ) r18 = t15.x, _6 = t15.y, s13 = r18 - this._graphicOriginX - this._offsetX, i16 = _6 - this._graphicOriginY - this._offsetY, g5 ? (h8 = this._cosAngle * s13 - this._sinAngle * i16, n18 = this._sinAngle * s13 + this._cosAngle * i16) : (h8 = s13, n18 = i16), a12 = Math.min(a12, h8), l12 = Math.max(l12, h8), o8 = Math.min(o8, n18), f7 = Math.max(f7, n18), c5 = Math.min(c5, _6), u13 = Math.max(u13, _6), p7 = Math.min(p7, r18), M4 = Math.max(M4, r18);
    c5 = c5 !== Number.MAX_VALUE ? c5 : -e11 - this._stepY, u13 = u13 !== -Number.MAX_VALUE ? u13 : this._stepY, p7 = p7 !== Number.MAX_VALUE ? p7 : -this._stepX, M4 = M4 !== -Number.MAX_VALUE ? M4 : e11 + this._stepX;
    const d4 = u13 - c5, X2 = M4 - p7;
    if (this._verticalSubdivision = d4 >= X2, this._polygonMin = this._verticalSubdivision ? c5 : p7, this._testInsidePolygon) {
      let t16 = 0 - this._graphicOriginX - this._offsetX - this._stepX, s14 = e11 - this._graphicOriginX - this._offsetX + this._stepX, i17 = -e11 - this._graphicOriginY - this._offsetY - this._stepY, h9 = 0 - this._graphicOriginY - this._offsetY + this._stepY;
      if (g5) {
        const e13 = [[t16, i17], [t16, h9], [s14, i17], [s14, h9]];
        t16 = i17 = Number.MAX_VALUE, s14 = h9 = -Number.MAX_VALUE;
        for (const n19 of e13) {
          const e14 = this._cosAngle * n19[0] - this._sinAngle * n19[1], _7 = this._sinAngle * n19[0] + this._cosAngle * n19[1];
          t16 = Math.min(t16, e14), s14 = Math.max(s14, e14), i17 = Math.min(i17, _7), h9 = Math.max(h9, _7);
        }
      }
      a12 = a12 !== Number.MAX_VALUE ? Math.max(a12, t16) : t16, o8 = o8 !== Number.MAX_VALUE ? Math.max(o8, i17) : i17, l12 = l12 !== -Number.MAX_VALUE ? Math.min(l12, s14) : s14, f7 = f7 !== -Number.MAX_VALUE ? Math.min(f7, h9) : h9;
    }
    this._xMin = Math.round(a12 / this._stepX), this._xMax = Math.round(l12 / this._stepX), this._yMin = Math.round(o8 / this._stepY), this._yMax = Math.round(f7 / this._stepY), this._currentX = this._xMax + 1, this._currentY = this._yMin - 1, this._buildAccelerationMap(t15, p7, M4, c5, u13);
  }
  _buildAccelerationMap(t15, s13, i16, n18, _6) {
    t15.reset();
    const r18 = /* @__PURE__ */ new Map(), a12 = this._verticalSubdivision, o8 = a12 ? _6 - n18 : i16 - s13;
    let f7 = Math.ceil(o8 / h6);
    if (f7 <= 1) return;
    const c5 = Math.floor(o8 / f7);
    let u13, p7, M4, g5, d4, X2, m7, x4, A5, Y4, y6;
    for (f7++, this._delta = c5, a12 ? (A5 = -e11 - 2 * this._stepY, Y4 = 2 * this._stepY, y6 = n18) : (A5 = -2 * this._stepX, Y4 = e11 + 2 * this._stepX, y6 = s13); t15.nextPath(); ) if (!(t15.pathSize < 2) && t15.nextPoint()) for (u13 = t15.x, p7 = t15.y; t15.nextPoint(); u13 = M4, p7 = g5) {
      if (M4 = t15.x, g5 = t15.y, a12) {
        if (p7 === g5 || p7 < A5 && g5 < A5 || p7 > Y4 && g5 > Y4) continue;
        d4 = Math.min(p7, g5), X2 = Math.max(p7, g5);
      } else {
        if (u13 === M4 || u13 < A5 && M4 < A5 || u13 > Y4 && M4 > Y4) continue;
        d4 = Math.min(u13, M4), X2 = Math.max(u13, M4);
      }
      for (; d4 < X2; ) m7 = Math.floor((d4 - y6) / c5), l8(m7, u13, p7, M4, g5, r18), d4 += c5;
      x4 = Math.floor((X2 - y6) / c5), x4 > m7 && l8(x4, u13, p7, M4, g5, r18);
    }
    this._accelerationMap = r18;
  }
  _nextInside() {
    for (; ; ) {
      if (this._currentX > this._xMax) {
        if (this._currentY++, this._currentY > this._yMax) return null;
        this._currentX = this._xMin, this._shiftOddRows && this._currentY % 2 && this._currentX--;
      }
      let t15 = this._currentX * this._stepX + this._offsetX;
      this._shiftOddRows && this._currentY % 2 && (t15 += 0.5 * this._stepX);
      const s13 = this._currentY * this._stepY + this._offsetY;
      let e13, h8;
      if (this._currentX++, this._gridType === Z.Random) {
        const i16 = (this._currentX % n12 + n12) % n12, _6 = (this._currentY % n12 + n12) % n12;
        e13 = this._graphicOriginX + t15 + this._stepX * this._randomness * (0.5 - _a._randValues[_6 * n12 + i16]) * 2 / 3, h8 = this._graphicOriginY + s13 + this._stepY * this._randomness * (0.5 - _a._randValues[_6 * n12 + i16 + 1]) * 2 / 3;
      } else e13 = this._graphicOriginX + this._cosAngle * t15 + this._sinAngle * s13, h8 = this._graphicOriginY - this._sinAngle * t15 + this._cosAngle * s13;
      if (!this._testInsidePolygon || this._isInsidePolygon(e13, h8, this._geometryCursor)) return this._internalPlacement.setTranslate(e13, h8), this._internalPlacement;
    }
  }
  _isInsidePolygon(t15, s13, i16) {
    if (null == this._accelerationMap) return o3(t15, s13, i16);
    t15 += _3, s13 += _3;
    const e13 = this._verticalSubdivision, h8 = e13 ? s13 : t15, n18 = Math.floor((h8 - this._polygonMin) / this._delta), r18 = this._accelerationMap.get(n18);
    if (!r18) return false;
    let a12, l12, f7, c5 = 0;
    for (const _6 of r18) {
      if (a12 = _6[0], l12 = _6[1], e13) {
        if (a12[1] > s13 == l12[1] > s13) continue;
        f7 = (l12[0] - a12[0]) * (s13 - a12[1]) - (l12[1] - a12[1]) * (t15 - a12[0]);
      } else {
        if (a12[0] > t15 == l12[0] > t15) continue;
        f7 = (l12[1] - a12[1]) * (t15 - a12[0]) - (l12[0] - a12[0]) * (s13 - a12[1]);
      }
      f7 > 0 ? c5++ : c5--;
    }
    return 0 !== c5;
  }
};
function o3(t15, s13, i16) {
  let e13, h8, n18, r18, a12 = 0;
  for (t15 += _3, s13 += _3, i16.reset(); i16.nextPath(); ) if (i16.nextPoint()) for (e13 = i16.x, h8 = i16.y; i16.nextPoint(); e13 = n18, h8 = r18) {
    if (n18 = i16.x, r18 = i16.y, h8 > s13 == r18 > s13) continue;
    (n18 - e13) * (s13 - h8) - (r18 - h8) * (t15 - e13) > 0 ? a12++ : a12--;
  }
  return 0 !== a12;
}
function l8(t15, s13, i16, e13, h8, n18) {
  let _6 = n18.get(t15);
  _6 || (_6 = [], n18.set(t15, _6)), _6.push([[s13, i16], [e13, h8]]);
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnLine.js
var i10 = 1e-3;
var s9 = class _s {
  static local() {
    return null === _s.instance && (_s.instance = new _s()), _s.instance;
  }
  execute(e13, t15, n18, i16, s13) {
    return new r15(e13, t15, n18);
  }
};
s9.instance = null;
var r15 = class extends r3 {
  constructor(e13, n18, s13) {
    super(e13), this._curveHelper = new s6(), this._angleToLine = void 0 === n18.angleToLine || n18.angleToLine, this._offset = void 0 !== n18.offset ? n18.offset * s13 : 0, this._relativeTo = n18.relativeTo, this._position = void 0 !== n18.startPointOffset ? n18.startPointOffset * s13 : 0, this._epsilon = i10 * s13;
  }
  processPath(e13) {
    const t15 = this._position;
    if (this._relativeTo === K.SegmentMidpoint) {
      if (this.iteratePath || (this.iteratePath = true), e13.nextPoint()) {
        let [t16, n18] = [e13.x, e13.y], [i17, s13] = [0, 0];
        for (; e13.nextPoint(); ) {
          i17 = e13.x, s13 = e13.y;
          const r18 = this._curveHelper.getLength(t16, n18, i17, s13);
          if (r18 < this._epsilon) {
            t16 = i17, n18 = s13;
            continue;
          }
          const o8 = 0.5 + this._position / r18, [a12, l12] = this._curveHelper.getAngleCS(t16, n18, i17, s13, o8), h8 = this._curveHelper.getCoord2D(t16, n18, i17, s13, o8);
          return this.internalPlacement.setTranslate(h8[0] - this._offset * l12, h8[1] + this._offset * a12), this._angleToLine && this.internalPlacement.setRotateCS(a12, l12), this.internalPlacement;
        }
      }
      return this.iteratePath = false, null;
    }
    const i16 = this._relativeTo === K.LineEnd;
    return this.onLine(e13, t15, i16);
  }
  onLine(e13, t15, i16) {
    let s13, r18 = false;
    switch (this._relativeTo) {
      case K.LineMiddle:
      default:
        e13.seekPathStart(), s13 = e13.pathLength() / 2 + t15;
        break;
      case K.LineBeginning:
        s13 = t15;
        break;
      case K.LineEnd:
        s13 = t15, r18 = true;
    }
    i16 ? e13.seekPathEnd() : e13.seekPathStart();
    let o8 = 0;
    if (i16 ? e13.prevPoint() : e13.nextPoint()) {
      let [t16, n18] = [e13.x, e13.y], [a12, l12] = [0, 0];
      for (; i16 ? e13.prevPoint() : e13.nextPoint(); ) {
        a12 = e13.x, l12 = e13.y;
        const i17 = this._curveHelper.getLength(t16, n18, a12, l12);
        if (o8 + i17 > s13) {
          const e14 = (s13 - o8) / i17, [h8, c5] = this._curveHelper.getAngleCS(t16, n18, a12, l12, e14), f7 = this._curveHelper.getCoord2D(t16, n18, a12, l12, e14), u13 = r18 ? -this._offset : this._offset;
          return this.internalPlacement.setTranslate(f7[0] - u13 * c5, f7[1] + u13 * h8), this._angleToLine && (r18 ? this.internalPlacement.setRotateCS(-h8, -c5) : this.internalPlacement.setRotateCS(h8, c5)), this.internalPlacement;
        }
        t16 = a12, n18 = l12, o8 += i17;
      }
    }
    return null;
  }
};

// node_modules/@arcgis/core/symbols/cim/placements/PlacementOnVertices.js
var s10 = 1e-15;
var i11 = class _i {
  static local() {
    return null === _i.instance && (_i.instance = new _i()), _i.instance;
  }
  execute(t15, e13, s13, i16, o8) {
    return new n13(t15, e13, s13);
  }
};
i11.instance = null;
var n13 = class extends r3 {
  constructor(t15, s13, i16) {
    super(t15), this._curveHelper = new s6(), this._angleToLine = void 0 === s13.angleToLine || s13.angleToLine, this._offset = void 0 !== s13.offset ? s13.offset * i16 : 0, this._endPoints = void 0 === s13.placeOnEndPoints || s13.placeOnEndPoints, this._controlPoints = void 0 === s13.placeOnControlPoints || s13.placeOnControlPoints, this._regularVertices = void 0 === s13.placeOnRegularVertices || s13.placeOnRegularVertices, this._tags = [], this._tagIterator = 0;
  }
  processPath(t15) {
    if (this.iteratePath || (this._preparePath(t15), this.iteratePath = true), this._tagIterator >= this._tags.length) return this._tags.length = 0, this._tagIterator = 0, this.iteratePath = false, null;
    const e13 = this._tags[this._tagIterator];
    this._angleToLine && this.internalPlacement.setRotate(e13[2]);
    let s13 = e13[0], i16 = e13[1];
    if (0 !== this._offset) {
      const t16 = Math.cos(e13[2]), n18 = Math.sin(e13[2]);
      s13 -= this._offset * n18, i16 += this._offset * t16;
    }
    return this.internalPlacement.setTranslate(s13, i16), this._tagIterator++, this.internalPlacement;
  }
  _preparePath(t15) {
    this._tags.length = 0, this._tagIterator = 0, t15.seekPathStart();
    const e13 = t15.isClosed();
    let s13 = 0, i16 = false, n18 = 0, r18 = 0;
    if (t15.seekPathStart(), t15.nextPoint()) {
      let a12 = t15.x, h8 = t15.y, l12 = t15.getControlPoint(), _6 = true, c5 = t15.nextPoint();
      for (; c5; ) {
        const g5 = t15.x, P5 = t15.y, u13 = t15.getControlPoint();
        (this._angleToLine || 0 !== this._offset) && (n18 = this._curveHelper.getAngle(a12, h8, g5, P5, 0)), _6 ? (_6 = false, e13 ? (s13 = n18, i16 = l12) : (this._endPoints || this._controlPoints && l12) && this._tags.push([a12, h8, n18])) : l12 ? this._controlPoints && this._tags.push([a12, h8, o4(r18, n18)]) : this._regularVertices && this._tags.push([a12, h8, o4(r18, n18)]), (this._angleToLine || 0 !== this._offset) && (r18 = this._curveHelper.getAngle(a12, h8, g5, P5, 1)), c5 = t15.nextPoint(), c5 || (e13 ? u13 || i16 ? this._controlPoints && this._tags.push([g5, P5, o4(r18, s13)]) : this._regularVertices && this._tags.push([g5, P5, o4(r18, s13)]) : (this._endPoints || this._controlPoints && u13) && this._tags.push([g5, P5, r18])), a12 = g5, h8 = P5, l12 = u13;
      }
    }
    this._tagIterator = 0;
  }
};
function o4(t15, e13) {
  const i16 = Math.PI;
  for (; Math.abs(e13 - t15) > i16 + 2 * s10; ) e13 - t15 > i16 ? e13 -= 2 * i16 : e13 += 2 * i16;
  return (t15 + e13) / 2;
}

// node_modules/@arcgis/core/geometry/support/labelPoint.js
var N3 = 100 * 222045e-21;
function l9(t15) {
  if (0 === t15.totalSize) return null;
  const a12 = c(t15);
  if (!a12) return null;
  const o8 = 4 * (Math.abs(a12[0]) + Math.abs(a12[2]) + Math.abs(a12[1]) + Math.abs(a12[3]) + 1) * N3;
  let s13 = 0, c5 = 0;
  t15.reset();
  for (let e13 = 0; t15.nextPath(); e13++) {
    const n18 = t15.getCurrentRingArea();
    n18 > c5 && (c5 = n18, s13 = e13);
  }
  if (t15.seekPath(s13), 0 === t15.pathSize) return null;
  t15.seekPathStart();
  const l12 = f4(t15);
  if (Math.abs(c5) <= 2 * o8 * o8) return [(l12[0] + l12[2]) / 2, (l12[1] + l12[3]) / 2];
  t15.seekPathStart();
  const x4 = i(t15, u());
  if (null === x4) return null;
  if (t15.totalPoints < 4) return x4;
  const m7 = [[NaN, NaN], [NaN, NaN], [NaN, NaN], [NaN, NaN]], d4 = [NaN, NaN, NaN, NaN], P5 = [NaN, NaN, NaN, NaN];
  let y6 = false, M4 = f6(x4, t15, true);
  0 === M4.distance && (y6 = true, m7[0][0] = x4[0], m7[0][1] = x4[1], M4 = f6(x4, t15, false)), d4[0] = M4.distance, P5[0] = 0;
  const b4 = [NaN, NaN];
  let S3 = false, k2 = 0.25, z2 = -1, g5 = NaN;
  do {
    if (g5 = NaN, m7[1] = h7(t15, w3(l12[0], l12[2], k2), o8, a12), isNaN(m7[1][0]) || isNaN(m7[1][1]) || (M4 = f6(m7[1], t15, false), g5 = M4.distance), !isNaN(g5) && g5 > o8 && u10(m7[1], t15)) S3 = true, d4[1] = g5, P5[1] = p4(m7[1], x4);
    else if (!isNaN(g5) && g5 > z2 && (z2 = g5, b4[0] = m7[1][0], b4[1] = m7[1][1]), k2 -= 0.01, k2 < 0.1) {
      if (!(z2 >= 0)) break;
      S3 = true, d4[1] = z2, m7[1][0] = b4[0], m7[1][1] = b4[1], P5[1] = p4(m7[1], x4);
    }
  } while (!S3);
  S3 = false, k2 = 0.5, z2 = -1;
  let q2 = 0.01, j2 = 1;
  do {
    if (g5 = NaN, m7[2] = h7(t15, w3(l12[0], l12[2], k2), o8, a12), isNaN(m7[2][0]) || isNaN(m7[2][1]) || (M4 = f6(m7[2], t15, false), g5 = M4.distance), !isNaN(g5) && g5 > o8 && u10(m7[2], t15)) S3 = true, d4[2] = g5, P5[2] = p4(m7[2], x4);
    else if (!isNaN(g5) && g5 > z2) z2 = g5, b4[0] = m7[2][0], b4[1] = m7[2][1];
    else if (g5 > z2 && (z2 = g5, b4[0] = m7[2][0], b4[1] = m7[2][1]), k2 = 0.5 + q2 * j2, q2 += 0.01, j2 *= -1, k2 < 0.3 || k2 > 0.7) {
      if (!(z2 >= 0)) break;
      S3 = true, d4[2] = z2, m7[2][0] = b4[0], m7[2][1] = b4[1], P5[2] = p4(m7[2], x4);
    }
  } while (!S3);
  S3 = false, k2 = 0.75, z2 = -1;
  do {
    if (g5 = NaN, m7[3] = h7(t15, w3(l12[0], l12[2], k2), o8, a12), isNaN(m7[3][0]) || isNaN(m7[3][1]) || (M4 = f6(m7[3], t15, false), g5 = M4.distance), !isNaN(g5) && g5 > o8 && u10(m7[3], t15)) S3 = true, d4[3] = g5, P5[3] = p4(m7[3], x4);
    else if (g5 > z2 && (z2 = g5, b4[0] = m7[3][0], b4[1] = m7[3][1]), k2 += 0.01, k2 > 0.9) {
      if (!(z2 >= 0)) break;
      S3 = true, d4[3] = z2, m7[3][0] = b4[0], m7[3][1] = b4[1], P5[3] = p4(m7[3], x4);
    }
  } while (!S3);
  const T4 = [0, 1, 2, 3], D = y6 ? 0 : 1;
  let R3;
  for (let e13 = D; e13 < 4; e13++) for (let t16 = D; t16 < 3; t16++) {
    const e14 = P5[t16], n18 = P5[t16 + 1];
    C3(e14, n18) > 0 && (R3 = T4[t16], T4[t16] = T4[t16 + 1], T4[t16 + 1] = R3, P5[t16] = n18, P5[t16 + 1] = e14);
  }
  let B4 = D, Q4 = 0, U3 = 0;
  for (let e13 = D; e13 < 4; e13++) {
    switch (e13) {
      case 0:
        U3 = 2 * d4[T4[e13]];
        break;
      case 1:
        U3 = 1.66666666 * d4[T4[e13]];
        break;
      case 2:
        U3 = 1.33333333 * d4[T4[e13]];
        break;
      case 3:
        U3 = d4[T4[e13]];
    }
    U3 > Q4 && (Q4 = U3, B4 = T4[e13]);
  }
  return m7[B4];
}
function u10(t15, e13) {
  let n18, i16, r18, a12, o8 = 0;
  for (e13.reset(); e13.nextPath() && e13.nextPoint(); ) for (n18 = e13.x, i16 = e13.y; e13.nextPoint(); n18 = r18, i16 = a12) {
    if (r18 = e13.x, a12 = e13.y, i16 > t15[1] == a12 > t15[1]) continue;
    (r18 - n18) * (t15[1] - i16) - (a12 - i16) * (t15[0] - n18) > 0 ? o8++ : o8--;
  }
  return 0 !== o8;
}
function f6(t15, e13, n18) {
  if (n18 && u10(t15, e13)) return { coord: t15, distance: 0 };
  let i16 = 1 / 0, r18 = 0, a12 = 0, s13 = [0, 0], c5 = [0, 0];
  const N5 = [0, 0];
  for (e13.reset(); e13.nextPath() && e13.nextPoint(); ) if (!(e13.pathSize < 2)) for (s13[0] = e13.x, s13[1] = e13.y; e13.nextPoint(); s13 = c5) {
    c5 = [e13.x, e13.y], f(N5, t15, s13, c5);
    const n19 = p4(t15, N5);
    n19 < i16 && (i16 = n19, r18 = N5[0], a12 = N5[1]);
  }
  return { coord: [r18, a12], distance: Math.sqrt(i16) };
}
function h7(t15, n18, i16, r18) {
  const a12 = [n18, 0];
  let o8 = 1 / 0, s13 = 1 / 0, N5 = false, l12 = false;
  const u13 = [[n18, r18[1] - 1], [n18, r18[3] + 1]], f7 = [0, 0], h8 = [0, 0], m7 = [0, 0], d4 = [[0, 0], [0, 0]], P5 = u();
  for (t15.reset(); t15.nextPath() && t15.nextPoint(); ) if (!(t15.pathSize < 2)) for (d4[0][0] = t15.x, d4[0][1] = t15.y; t15.nextPoint(); d4[0][0] = d4[1][0], d4[0][1] = d4[1][1]) {
    if (d4[1][0] = t15.x, d4[1][1] = t15.y, null === x2(P5, d4)) continue;
    if (h8[0] = u13[0][0], h8[1] = u13[0][1], m7[0] = u13[1][0], m7[1] = u13[1][1], 0 === M2(P5, h8, m7)) continue;
    if (!G(u13[0], u13[1], d4[0], d4[1], f7)) continue;
    const e13 = f7[1];
    o8 > s13 ? e13 < o8 && (o8 = e13, N5 = true) : e13 < s13 && (s13 = e13, l12 = true);
  }
  return N5 && l12 ? a12[1] = (o8 + s13) / 2 : a12[0] = a12[1] = NaN, a12;
}
function x2(t15, n18) {
  if (n18.length < 2) return null;
  t15 || (t15 = u());
  const [i16, r18] = n18[0], [a12, o8] = n18[1];
  return t15[0] = Math.min(i16, a12), t15[1] = Math.min(r18, o8), t15[2] = Math.max(i16, a12), t15[3] = Math.max(r18, o8), t15;
}
var m6 = 1;
var d2 = 4;
var P4 = 3;
var y4 = 12;
function M2(t15, e13, n18) {
  let i16 = b2(e13, t15), r18 = b2(n18, t15);
  const a12 = t15[0], o8 = t15[1], s13 = t15[2], c5 = t15[3];
  if (i16 & r18) return 0;
  if (!(i16 | r18)) return 4;
  const N5 = (i16 ? 1 : 0) | (r18 ? 2 : 0);
  do {
    const N6 = n18[0] - e13[0], l12 = n18[1] - e13[1];
    if (N6 > l12) i16 & P4 ? (i16 & m6 ? (e13[1] += l12 * (a12 - e13[0]) / N6, e13[0] = a12) : (e13[1] += l12 * (s13 - e13[0]) / N6, e13[0] = s13), i16 = b2(e13, t15)) : r18 & P4 ? (r18 & m6 ? (n18[1] += l12 * (a12 - n18[0]) / N6, n18[0] = a12) : (n18[1] += l12 * (s13 - n18[0]) / N6, n18[0] = s13), r18 = b2(n18, t15)) : i16 ? (i16 & d2 ? (e13[0] += N6 * (o8 - e13[1]) / l12, e13[1] = o8) : (e13[0] += N6 * (c5 - e13[1]) / l12, e13[1] = c5), i16 = b2(e13, t15)) : (r18 & d2 ? (n18[0] += N6 * (o8 - n18[1]) / l12, n18[1] = o8) : (n18[0] += N6 * (c5 - n18[1]) / l12, n18[1] = c5), r18 = b2(n18, t15));
    else if (i16 & y4 ? (i16 & d2 ? (e13[0] += N6 * (o8 - e13[1]) / l12, e13[1] = o8) : (e13[0] += N6 * (c5 - e13[1]) / l12, e13[1] = c5), i16 = b2(e13, t15)) : r18 & y4 ? (r18 & d2 ? (n18[0] += N6 * (o8 - n18[1]) / l12, n18[1] = o8) : (n18[0] += N6 * (c5 - n18[1]) / l12, n18[1] = c5), r18 = b2(n18, t15)) : i16 ? (i16 & m6 ? (e13[1] += l12 * (a12 - e13[0]) / N6, e13[0] = a12) : (e13[1] += l12 * (s13 - e13[0]) / N6, e13[0] = s13), i16 = b2(e13, t15)) : (r18 & m6 ? (n18[1] += l12 * (a12 - n18[0]) / N6, n18[0] = a12) : (n18[1] += l12 * (s13 - n18[0]) / N6, n18[0] = s13), r18 = b2(n18, t15)), i16 & r18) return 0;
  } while (i16 | r18);
  return N5;
}
function b2(t15, e13) {
  return (t15[0] < e13[0] ? 1 : 0) | (t15[0] > e13[2] ? 1 : 0) << 1 | (t15[1] < e13[1] ? 1 : 0) << 2 | (t15[1] > e13[3] ? 1 : 0) << 3;
}
function w3(t15, e13, n18) {
  return t15 + (e13 - t15) * n18;
}
function p4(t15, e13) {
  return (t15[0] - e13[0]) * (t15[0] - e13[0]) + (t15[1] - e13[1]) * (t15[1] - e13[1]);
}
function C3(t15, e13) {
  if (t15 < e13) return -1;
  if (t15 > e13) return 1;
  if (t15 === e13) return 0;
  const n18 = isNaN(t15), i16 = isNaN(e13);
  return n18 < i16 ? -1 : n18 > i16 ? 1 : 0;
}

// node_modules/@arcgis/core/symbols/cim/placements/PlacementPolygonCenter.js
var o5 = class _o {
  static local() {
    return null === _o.instance && (_o.instance = new _o()), _o.instance;
  }
  execute(t15, e13, s13, n18, r18) {
    return new i12(t15, e13, s13);
  }
};
o5.instance = null;
var i12 = class {
  constructor(t15, e13, s13) {
    this._geometryCursor = t15, this._offsetX = void 0 !== e13.offsetX ? e13.offsetX * s13 : 0, this._offsetY = void 0 !== e13.offsetY ? e13.offsetY * s13 : 0, this._method = void 0 !== e13.method ? e13.method : Q.OnPolygon, this._placementPerPart = void 0 !== e13.placePerPart && e13.placePerPart, this._internalPlacement = new t6();
  }
  next() {
    const t15 = this._geometryCursor;
    if (!t15) return null;
    if (!this._placementPerPart) return this._geometryCursor = null, this._polygonCenter(t15);
    for (; t15.nextPath(); ) if (!(t15.getCurrentRingArea() < 0)) return this._polygonCenter(t15.getCurrentPath());
    return this._geometryCursor = null, null;
  }
  _polygonCenter(n18) {
    let o8 = false;
    switch (this._method) {
      case Q.CenterOfMass:
        {
          const t15 = f2(n18);
          t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), o8 = true);
        }
        break;
      case Q.BoundingBoxCenter:
        {
          const e13 = c(n18);
          e13 && (this._internalPlacement.setTranslate((e13[2] + e13[0]) / 2 + this._offsetX, (e13[3] + e13[1]) / 2 + this._offsetY), o8 = true);
        }
        break;
      case Q.OnPolygon:
      default: {
        const t15 = l9(n18);
        null !== t15 && (this._internalPlacement.setTranslate(t15[0] + this._offsetX, t15[1] + this._offsetY), o8 = true);
      }
    }
    return o8 ? this._internalPlacement : null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/alignmentUtils.js
var t10 = () => n.getLogger("esri.views.2d.engine.webgl.alignmentUtils");
var r16;
var n14;
function a11(e13) {
  if (!e13) return r16.Center;
  switch (e13) {
    case "Left":
    case "left":
      return r16.Left;
    case "Right":
    case "right":
      return r16.Right;
    case "Justify":
      return t10().warnOnce("Horizontal alignment 'justify' is not implemented. Falling back to 'center'."), r16.Center;
    case "Center":
    case "center":
      return r16.Center;
  }
}
function c4(e13) {
  if (!e13) return n14.Center;
  switch (e13) {
    case "Top":
    case "top":
      return n14.Top;
    case "Center":
    case "middle":
      return n14.Center;
    case "Baseline":
    case "baseline":
      return n14.Baseline;
    case "Bottom":
    case "bottom":
      return n14.Bottom;
  }
}
function o6(e13) {
  switch (e13) {
    case "above-left":
    case "esriServerPointLabelPlacementAboveLeft":
      return ["right", "bottom"];
    case "above-center":
    case "above-along":
    case "esriServerPointLabelPlacementAboveCenter":
    case "esriServerLinePlacementAboveAlong":
      return ["center", "bottom"];
    case "above-right":
    case "esriServerPointLabelPlacementAboveRight":
      return ["left", "bottom"];
    case "center-left":
    case "esriServerPointLabelPlacementCenterLeft":
      return ["right", "middle"];
    case "center-center":
    case "center-along":
    case "esriServerPointLabelPlacementCenterCenter":
    case "esriServerLinePlacementCenterAlong":
    case "always-horizontal":
    case "esriServerPolygonPlacementAlwaysHorizontal":
      return ["center", "middle"];
    case "center-right":
    case "esriServerPointLabelPlacementCenterRight":
      return ["left", "middle"];
    case "below-left":
    case "esriServerPointLabelPlacementBelowLeft":
      return ["right", "top"];
    case "below-center":
    case "below-along":
    case "esriServerPointLabelPlacementBelowCenter":
    case "esriServerLinePlacementBelowAlong":
      return ["center", "top"];
    case "below-right":
    case "esriServerPointLabelPlacementBelowRight":
      return ["left", "top"];
    default:
      return console.debug(`Found invalid placement type ${e13}`), ["center", "middle"];
  }
}
function s11(e13) {
  switch (e13) {
    case r16.Right:
    case "right":
      return -1;
    case r16.Center:
    case "center":
      return 0;
    case r16.Left:
    case "left":
      return 1;
    default:
      return console.debug(`Found invalid horizontal alignment ${e13}`), 0;
  }
}
function i13(e13) {
  switch (e13) {
    case n14.Top:
    case "top":
      return 1;
    case n14.Center:
    case "middle":
      return 0;
    case n14.Bottom:
    case n14.Baseline:
    case "baseline":
    case "bottom":
      return -1;
    default:
      return console.debug(`Found invalid vertical alignment ${e13}`), 0;
  }
}
!function(e13) {
  e13[e13.Left = -1] = "Left", e13[e13.Center = 0] = "Center", e13[e13.Right = 1] = "Right";
}(r16 || (r16 = {})), function(e13) {
  e13[e13.Top = 1] = "Top", e13[e13.Center = 0] = "Center", e13[e13.Bottom = -1] = "Bottom", e13[e13.Baseline = 2] = "Baseline";
}(n14 || (n14 = {}));

// node_modules/@arcgis/core/core/BidiText.js
var n15 = new C2();
function i14(r18) {
  if (null == r18) return ["", false];
  if (!n15.hasBidiChar(r18)) return [r18, false];
  let i16;
  return i16 = "rtl" === n15.checkContextual(r18) ? "IDNNN" : "ICNNN", [n15.bidiTransform(r18, i16, "VLYSN"), true];
}

// node_modules/@arcgis/core/symbols/cim/CIMImageColorSubstitutionHelper.js
var t11 = class {
  applyColorSubstitution(t15, a12) {
    if (!a12) return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e13, height: n18 } = t15, o8 = this._rasterizationCanvas, r18 = o8.getContext("2d", { willReadFrequently: true });
    t15 !== o8 && (o8.width = e13, o8.height = n18, r18.drawImage(t15, 0, 0, e13, n18));
    const i16 = r18.getImageData(0, 0, e13, n18).data;
    if (a12) {
      for (const l12 of a12) if (l12 && l12.oldColor && 4 === l12.oldColor.length && l12.newColor && 4 === l12.newColor.length) {
        const [t16, a13, e14, n19] = l12.oldColor, [o9, r19, s14, h8] = l12.newColor;
        if (t16 === o9 && a13 === r19 && e14 === s14 && n19 === h8) continue;
        for (let l13 = 0; l13 < i16.length; l13 += 4) t16 === i16[l13] && a13 === i16[l13 + 1] && e14 === i16[l13 + 2] && n19 === i16[l13 + 3] && (i16[l13] = o9, i16[l13 + 1] = r19, i16[l13 + 2] = s14, i16[l13 + 3] = h8);
      }
    }
    const s13 = new ImageData(i16, e13, n18);
    return r18.putImageData(s13, 0, 0), o8;
  }
  tintImageData(t15, a12) {
    if (!a12 || a12.length < 4) return t15;
    this._rasterizationCanvas || (this._rasterizationCanvas = document.createElement("canvas"));
    const { width: e13, height: n18 } = t15, o8 = this._rasterizationCanvas, r18 = o8.getContext("2d", { willReadFrequently: true });
    t15 !== o8 && (o8.width = e13, o8.height = n18, r18.drawImage(t15, 0, 0, e13, n18));
    const i16 = r18.getImageData(0, 0, e13, n18), s13 = new Uint8Array(i16.data), l12 = [a12[0] / 255, a12[1] / 255, a12[2] / 255, a12[3] / 255];
    for (let g5 = 0; g5 < s13.length; g5 += 4) s13[g5] *= l12[0], s13[g5 + 1] *= l12[1], s13[g5 + 2] *= l12[2], s13[g5 + 3] *= l12[3];
    const h8 = new ImageData(new Uint8ClampedArray(s13.buffer), e13, n18);
    return r18.putImageData(h8, 0, 0), o8;
  }
};

// node_modules/@arcgis/core/symbols/cim/CIMOperators.js
function A3(p7) {
  if (!p7) return null;
  switch (p7.type) {
    case "CIMGeometricEffectAddControlPoints":
      return e5.local();
    case "CIMGeometricEffectArrow":
      return p3.local();
    case "CIMGeometricEffectBuffer":
      return m5.local();
    case "CIMGeometricEffectControlMeasureLine":
      return r5.local();
    case "CIMGeometricEffectCut":
      return r6.local();
    case "CIMGeometricEffectDashes":
      return h4.local();
    case "CIMGeometricEffectDonut":
      return s8.local();
    case "CIMGeometricEffectJog":
      return e6.local();
    case "CIMGeometricEffectMove":
      return t7.local();
    case "CIMGeometricEffectOffset":
      return h5.local();
    case "CIMGeometricEffectReverse":
      return e8.local();
    case "CIMGeometricEffectRotate":
      return e9.local();
    case "CIMGeometricEffectScale":
      return e10.local();
    case "CIMGeometricEffectWave":
      return n11.local();
  }
  return null;
}
function g3(e13) {
  if (!e13) return null;
  switch (e13.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
      return a8.local();
    case "CIMMarkerPlacementAtExtremities":
      return i9.local();
    case "CIMMarkerPlacementAtRatioPositions":
      return a9.local();
    case "CIMMarkerPlacementInsidePolygon":
      return r14.local();
    case "CIMMarkerPlacementOnLine":
      return s9.local();
    case "CIMMarkerPlacementOnVertices":
      return i11.local();
    case "CIMMarkerPlacementPolygonCenter":
      return o5.local();
  }
  return null;
}

// node_modules/@arcgis/core/symbols/cim/imageUtils.js
function t12(t15) {
  const e13 = t15.getFrame(0);
  if (e13 instanceof HTMLImageElement || e13 instanceof HTMLCanvasElement) return e13;
  const n18 = document.createElement("canvas");
  n18.width = t15.width, n18.height = t15.height;
  const a12 = n18.getContext("2d");
  return e13 instanceof ImageData ? a12.putImageData(e13, 0, 0) : a12.drawImage(e13, 0, 0), n18;
}

// node_modules/@arcgis/core/symbols/cim/Rect.js
var t13 = class _t {
  constructor(t15 = 0, h8 = 0, i16 = 0, s13 = 0) {
    this.x = t15, this.y = h8, this.width = i16, this.height = s13;
  }
  static fromExtent(h8) {
    return new _t(h8.xmin, -h8.ymax, h8.xmax - h8.xmin, h8.ymax - h8.ymin);
  }
  get isEmpty() {
    return this.width <= 0 || this.height <= 0;
  }
  union(t15) {
    this.x = Math.min(this.x, t15.x), this.y = Math.min(this.y, t15.y), this.width = Math.max(this.width, t15.width), this.height = Math.max(this.height, t15.height);
  }
};

// node_modules/@arcgis/core/symbols/cim/TextRasterizer.js
function i15(e13) {
  return `rgb(${e13.slice(0, 3).toString()})`;
}
function n16(e13) {
  return `rgba(${e13.slice(0, 3).toString()},${e13[3]})`;
}
var s12 = class {
  constructor(e13) {
    e13 && (this._textRasterizationCanvas = e13);
  }
  rasterizeText(e13, s13) {
    var _a, _b;
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const a12 = this._textRasterizationCanvas, h8 = a12.getContext("2d", { willReadFrequently: true });
    r17(h8, s13), this._parameters = s13, this._textLines = e13.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const { decoration: l12, weight: d4 } = s13.font;
    this._lineThroughWidthOffset = l12 && "line-through" === l12 ? 0.1 * this._lineHeight : 0;
    const c5 = null != s13.backgroundColor || null != s13.borderLine, _6 = c5 ? s3 : 0, u13 = this._computeTextWidth(h8, s13) + 2 * _6, g5 = this._lineHeight * this._textLines.length + 2 * _6;
    if (a12.width = u13 + 2 * this._lineThroughWidthOffset, a12.height = g5, 0 === a12.width || 0 === a12.height) return a12.width = a12.height = 1, { size: [0, 0], image: new Uint32Array(0), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0, canvas: a12 };
    this._renderedLineHeight = Math.round(this._lineHeight), this._renderedOutlineSize = (s13.outline.size || 0) * s13.pixelRatio, this._renderedHaloSize = (s13.halo.size || 0) * s13.pixelRatio, this._renderedWidth = u13, this._renderedHeight = g5, this._lineThroughWidthOffset *= s13.pixelRatio;
    const f7 = (s13.outline && s13.outline.color) ?? [0, 0, 0, 0], m7 = s13.color ?? [0, 0, 0, 0], p7 = s13.halo && s13.halo.color ? s13.halo.color : [0, 0, 0, 0];
    this._fillStyle = n16(m7), this._outlineStyle = n16(f7), this._haloStyle = i15(p7);
    const x4 = this._renderedLineHeight, z2 = this._renderedOutlineSize, b4 = this._renderedHaloSize;
    h8.save(), h8.clearRect(0, 0, a12.width, a12.height), r17(h8, s13);
    const w5 = _6 * s13.pixelRatio, v3 = o7(h8.textAlign, this._renderedWidth - 2 * w5, this._renderedHaloSize + this._renderedOutlineSize) + w5, S3 = b4 + z2 + w5, y6 = b4 > 0;
    let R3 = this._lineThroughWidthOffset, C4 = 0;
    if (c5) {
      h8.save();
      const e14 = s13.backgroundColor ?? [0, 0, 0, 0], t15 = ((_a = s13.borderLine) == null ? void 0 : _a.color) ?? [0, 0, 0, 0], i16 = 2 * (((_b = s13.borderLine) == null ? void 0 : _b.size) ?? 0);
      h8.fillStyle = n16(e14), h8.strokeStyle = n16(t15), h8.lineWidth = i16, h8.fillRect(0, 0, a12.width, a12.height), h8.strokeRect(0, 0, a12.width, a12.height), h8.restore();
    }
    y6 && this._renderHalo(h8, v3, S3, R3, C4, s13), z2 > 0 && this._renderOutline(h8, v3, S3, R3, C4, s13), C4 += S3, R3 += v3;
    for (const t15 of this._textLines) y6 ? (h8.globalCompositeOperation = "destination-out", h8.fillStyle = "rgb(0, 0, 0)", h8.fillText(t15, R3, C4), h8.globalCompositeOperation = "source-over", h8.fillStyle = this._fillStyle, h8.fillText(t15, R3, C4)) : (h8.fillStyle = this._fillStyle, h8.fillText(t15, R3, C4)), l12 && "none" !== l12 && this._renderDecoration(h8, R3, C4, l12, d4), C4 += x4;
    h8.restore();
    const H3 = this._renderedWidth + 2 * this._lineThroughWidthOffset, W2 = this._renderedHeight, T4 = h8.getImageData(0, 0, H3, W2), k2 = new Uint8Array(T4.data);
    if (s13.premultiplyColors) {
      let e14;
      for (let t15 = 0; t15 < k2.length; t15 += 4) e14 = k2[t15 + 3] / 255, k2[t15] = k2[t15] * e14, k2[t15 + 1] = k2[t15 + 1] * e14, k2[t15 + 2] = k2[t15 + 2] * e14;
    }
    let L3, O3;
    switch (s13.horizontalAlignment) {
      case "left":
        L3 = -0.5;
        break;
      case "right":
        L3 = 0.5;
        break;
      default:
        L3 = 0;
    }
    switch (s13.verticalAlignment) {
      case "bottom":
        O3 = -0.5;
        break;
      case "top":
        O3 = 0.5;
        break;
      case "baseline":
        O3 = -1 / 6;
        break;
      default:
        O3 = 0;
    }
    return { size: [H3, W2], image: new Uint32Array(k2.buffer), sdf: false, simplePattern: false, anchorX: L3, anchorY: O3, canvas: a12 };
  }
  _renderHalo(e13, t15, i16, n18, s13, o8) {
    const a12 = this._renderedWidth, h8 = this._renderedHeight;
    this._outlineRasterizationCanvas || (this._outlineRasterizationCanvas = document.createElement("canvas")), this._outlineRasterizationCanvas.width = a12, this._outlineRasterizationCanvas.height = h8;
    const l12 = this._outlineRasterizationCanvas, d4 = l12.getContext("2d");
    d4.clearRect(0, 0, a12, h8), r17(d4, o8);
    const { decoration: c5, weight: _6 } = o8.font;
    d4.fillStyle = this._haloStyle, d4.strokeStyle = this._haloStyle, d4.lineJoin = "round", this._renderOutlineNative(d4, t15, i16, c5, _6, this._renderedHaloSize + this._renderedOutlineSize), e13.globalAlpha = this._parameters.halo.color[3], e13.drawImage(l12, 0, 0, a12, h8, n18, s13, a12, h8), e13.globalAlpha = 1;
  }
  _renderOutline(e13, t15, i16, n18, s13, o8) {
    const a12 = this._renderedWidth, h8 = this._renderedHeight;
    this._outlineRasterizationCanvas || (this._outlineRasterizationCanvas = document.createElement("canvas")), this._outlineRasterizationCanvas.width = a12, this._outlineRasterizationCanvas.height = h8;
    const l12 = this._outlineRasterizationCanvas, d4 = l12.getContext("2d");
    d4.clearRect(0, 0, a12, h8), r17(d4, o8);
    const { decoration: c5, weight: _6 } = o8.font;
    d4.fillStyle = this._outlineStyle, d4.strokeStyle = this._outlineStyle, d4.lineJoin = "round", this._renderOutlineNative(d4, t15, i16, c5, _6, this._renderedOutlineSize), e13.globalAlpha = this._parameters.outline.color[3], e13.drawImage(l12, 0, 0, a12, h8, n18, s13, a12, h8), e13.globalAlpha = 1;
  }
  _renderOutlineNative(e13, t15, i16, n18, s13, r18) {
    const o8 = this._renderedLineHeight;
    for (const a12 of this._textLines) {
      const h8 = 2 * r18, l12 = 5, d4 = 0.1;
      for (let r19 = 0; r19 < l12; r19++) {
        const o9 = (1 - (l12 - 1) * d4 + r19 * d4) * h8;
        e13.lineWidth = o9, e13.strokeText(a12, t15, i16), n18 && "none" !== n18 && this._renderDecoration(e13, t15, i16, n18, s13, o9);
      }
      i16 += o8;
    }
  }
  computeTextSize(e13, t15) {
    this._textRasterizationCanvas || (this._textRasterizationCanvas = document.createElement("canvas"));
    const i16 = this._textRasterizationCanvas, n18 = i16.getContext("2d");
    r17(n18, t15), this._parameters = t15, this._textLines = e13.split(/\r?\n/), this._lineHeight = this._computeLineHeight();
    const s13 = this._computeTextWidth(n18, t15), o8 = this._lineHeight * this._textLines.length;
    return i16.width = s13, i16.height = o8, [s13 * t15.pixelRatio, o8 * t15.pixelRatio];
  }
  _computeTextWidth(t15, i16) {
    let n18 = 0;
    for (const e13 of this._textLines) n18 = Math.max(n18, t15.measureText(e13).width);
    const s13 = i16.font;
    return ("italic" === s13.style || "oblique" === s13.style || "string" == typeof s13.weight && ("bold" === s13.weight || "bolder" === s13.weight) || "number" == typeof s13.weight && s13.weight > 600) && (n18 += 0.3 * t15.measureText("w").width), n18 += 2 * u3(this._parameters.halo.size), Math.round(n18);
  }
  _computeLineHeightBase() {
    return 1.275 * this._parameters.size;
  }
  _computeLineHeight() {
    let t15 = this._computeLineHeightBase();
    const i16 = this._parameters.font.decoration;
    return i16 && "underline" === i16 && (t15 *= 1.3), Math.round(t15 + 2 * u3(this._parameters.halo.size));
  }
  _renderDecoration(e13, t15, i16, n18, s13, r18) {
    let o8 = 0.9 * this._lineHeight;
    const a12 = "bold" === s13 ? 0.06 : "bolder" === s13 ? 0.09 : 0.04;
    switch (e13.textAlign) {
      case "center":
        t15 -= this._renderedWidth / 2;
        break;
      case "right":
        t15 -= this._renderedWidth;
    }
    const h8 = e13.textBaseline;
    if ("underline" === n18) switch (o8 = 0.9 * this._computeLineHeightBase(), h8) {
      case "top":
        i16 += o8;
        break;
      case "middle":
        i16 += o8 / 2;
    }
    else if ("line-through" === n18) switch (h8) {
      case "top":
        i16 += o8 / 1.5;
        break;
      case "middle":
        i16 += o8 / 3;
    }
    const l12 = r18 ? 1.5 * r18 : Math.ceil(o8 * a12);
    e13.save(), e13.beginPath(), e13.strokeStyle = e13.fillStyle, e13.lineWidth = l12, e13.moveTo(t15 - this._lineThroughWidthOffset, i16), e13.lineTo(t15 + this._renderedWidth + 2 * this._lineThroughWidthOffset, i16), e13.stroke(), e13.restore();
  }
};
function r17(t15, i16) {
  const n18 = Math.max(i16.size, 0.5), s13 = i16.font, r18 = `${s13.style} ${s13.weight} ${u3(n18).toFixed(1)}px ${s13.family}, sans-serif`;
  let o8;
  switch (t15.font = r18, t15.textBaseline = "top", i16.horizontalAlignment) {
    case "left":
    default:
      o8 = "left";
      break;
    case "right":
      o8 = "right";
      break;
    case "center":
      o8 = "center";
  }
  t15.textAlign = o8;
}
function o7(e13, t15, i16) {
  return "center" === e13 ? 0.5 * t15 : "right" === e13 ? t15 - i16 : i16;
}

// node_modules/@arcgis/core/views/2d/engine/svgUtils.js
function t14(t15) {
  return document.createElementNS("http://www.w3.org/2000/svg", t15);
}
function e12() {
  const e13 = t14("svg");
  return e13.setAttribute("style", "position: absolute;"), e13.setAttribute("width", "0"), e13.setAttribute("height", "0"), e13.setAttribute("aria-hidden", "true"), e13.setAttribute("role", "presentation"), document.body.appendChild(e13), e13;
}
function n17(t15) {
  return null != t15 && document.body.removeChild(t15), null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/templates/shapingUtils.js
var _4 = 22;
var l10 = 4;
var u11 = _4 + l10;
var x3 = _4 - 6;
var p5 = 3;
var b3 = Math.PI / 180;
var y5 = 8;
var w4 = 1.5;
var L2 = class {
  constructor(t15, s13, i16, e13) {
    this._rotationT = n3(), this._xBounds = 0, this._yBounds = 0, this.minZoom = 0, this.maxZoom = 255, this._bounds = null;
    const h8 = i16.rect, n18 = new Float32Array(8);
    t15 *= e13, s13 *= e13;
    const r18 = i16.code ? h8.width * e13 : i16.metrics.width, a12 = i16.code ? h8.height * e13 : i16.metrics.height;
    this.width = r18, this.height = a12, n18[0] = t15, n18[1] = s13, n18[2] = t15 + r18, n18[3] = s13, n18[4] = t15, n18[5] = s13 + a12, n18[6] = t15 + r18, n18[7] = s13 + a12, this._data = n18, this._setTextureCoords(h8), this._scale = e13, this._mosaic = i16, this.x = t15, this.y = s13, this.maxOffset = Math.max(t15 + r18, s13 + a12);
  }
  get mosaic() {
    return this._mosaic;
  }
  set angle(s13) {
    this._angle = s13, M(this._rotationT, -s13), this._setOffsets();
  }
  get angle() {
    return this._angle;
  }
  get xTopLeft() {
    return this._data[0];
  }
  get yTopLeft() {
    return this._data[1];
  }
  get xBottomRight() {
    return this._data[6];
  }
  get yBottomRight() {
    return this._data[7];
  }
  get texcoords() {
    return this._texcoords;
  }
  get textureBinding() {
    return this._mosaic.textureBinding;
  }
  get offsets() {
    return this._offsets || this._setOffsets(), this._offsets;
  }
  get char() {
    return String.fromCharCode(this._mosaic.code);
  }
  get code() {
    return this._mosaic.code;
  }
  get bounds() {
    if (!this._bounds) {
      const { height: t15, width: i16 } = this._mosaic.metrics, e13 = i16 * this._scale, n18 = Math.abs(t15) * this._scale, r18 = new Float32Array(8);
      r18[0] = this.x, r18[1] = this.y, r18[2] = this.x + e13, r18[3] = this.y, r18[4] = this.x, r18[5] = this.y + n18, r18[6] = this.x + e13, r18[7] = this.y + n18;
      const a12 = e4(n3(), this._rotationT, this._transform);
      a5(r18, r18, a12);
      let f7 = 1 / 0, c5 = 1 / 0, d4 = -1 / 0, m7 = -1 / 0;
      for (let s13 = 0; s13 < 4; s13++) {
        const t16 = r18[2 * s13], i17 = r18[2 * s13 + 1];
        f7 = Math.min(f7, t16), c5 = Math.min(c5, i17), d4 = Math.max(d4, t16), m7 = Math.max(m7, i17);
      }
      const _6 = d4 - f7, l12 = m7 - c5, u13 = f7 + _6 / 2, x4 = c5 + l12 / 2;
      this._bounds = new i5(u13, x4, _6, l12);
    }
    return this._bounds;
  }
  setTransform(t15) {
    this._transform = t15, this._offsets = null;
  }
  _setOffsets() {
    this._offsets || (this._offsets = { topLeft: [0, 0], topRight: [0, 0], bottomLeft: [0, 0], bottomRight: [0, 0] });
    const t15 = e4(n3(), this._rotationT, this._transform);
    this._offsets.topLeft[0] = this._data[0], this._offsets.topLeft[1] = this._data[1], this._offsets.topRight[0] = this._data[2], this._offsets.topRight[1] = this._data[3], this._offsets.bottomLeft[0] = this._data[4], this._offsets.bottomLeft[1] = this._data[5], this._offsets.bottomRight[0] = this._data[6], this._offsets.bottomRight[1] = this._data[7], S(this._offsets.topLeft, this._offsets.topLeft, t15), S(this._offsets.topRight, this._offsets.topRight, t15), S(this._offsets.bottomLeft, this._offsets.bottomLeft, t15), S(this._offsets.bottomRight, this._offsets.bottomRight, t15);
  }
  _setTextureCoords({ x: t15, y: s13, width: i16, height: e13 }) {
    this._texcoords = { topLeft: [t15, s13], topRight: [t15 + i16, s13], bottomLeft: [t15, s13 + e13], bottomRight: [t15 + i16, s13 + e13] };
  }
};
var M3 = (t15, s13) => ({ code: 0, page: 0, sdf: true, rect: new t4(0, 0, 11, 8), textureBinding: s13, metrics: { advance: 0, height: 4, width: t15, left: 0, top: 0 } });
function R2(t15, s13) {
  return t15.forEach((t16) => S(t16, t16, s13)), { topLeft: t15[0], topRight: t15[1], bottomLeft: t15[2], bottomRight: t15[3] };
}
var B3 = class {
  constructor(t15, s13, i16) {
    this._rotation = 0, this._decorate(t15, s13, i16), this.glyphs = t15, this.bounds = this._createBounds(t15), this.isMultiline = s13.length > 1, this._hasRotation = 0 !== i16.angle, this._transform = this._createGlyphTransform(this.bounds, i16), this._borderLineSizePx = i16.borderLineSizePx, (i16.borderLineSizePx || i16.hasBackground) && ([this.bounds, this.textBox] = this.shapeBackground(this._transform));
    for (const e13 of t15) e13.setTransform(this._transform);
  }
  setRotation(i16) {
    if (0 === i16 && 0 === this._rotation) return;
    this._rotation = i16;
    const e13 = this._transform, h8 = M(n3(), i16);
    e4(e13, h8, e13);
    for (const t15 of this.glyphs) t15.setTransform(this._transform);
  }
  _decorate(t15, s13, i16) {
    if (!i16.decoration || "none" === i16.decoration || !t15.length) return;
    const e13 = i16.scale, o8 = "underline" === i16.decoration ? u11 : x3, h8 = t15[0].textureBinding;
    for (const n18 of s13) {
      const s14 = n18.startX * e13, i17 = n18.startY * e13, r18 = (n18.width + n18.glyphWidthEnd) * e13;
      t15.push(new L2(s14, i17 + o8 * e13, M3(r18, h8), 1));
    }
  }
  shapeBackground(t15) {
    const s13 = this._borderLineSizePx || 0, i16 = (w4 + s13) / 2, e13 = this._borderLineSizePx ? i16 : 0, { xmin: o8, ymin: h8, xmax: n18, ymax: r18, x: a12, y: f7, width: c5, height: d4 } = this.bounds, m7 = [o8 - y5, h8 - y5], _6 = [n18 + y5, h8 - y5], l12 = [o8 - y5, r18 + y5], u13 = [n18 + y5, r18 + y5], x4 = R2([[m7[0] - i16, m7[1] - i16], [_6[0] + i16, _6[1] - i16], [m7[0] + e13, m7[1] + e13], [_6[0] - e13, _6[1] + e13]], t15), p7 = R2([[l12[0] + e13, l12[1] - e13], [u13[0] - e13, u13[1] - e13], [l12[0] - i16, l12[1] + i16], [u13[0] + i16, u13[1] + i16]], t15), b4 = R2([[m7[0] - i16, m7[1] - i16], [m7[0] + e13, m7[1] + e13], [l12[0] - i16, l12[1] + i16], [l12[0] + e13, l12[1] - e13]], t15), L3 = R2([[_6[0] - e13, _6[1] + e13], [_6[0] + i16, _6[1] - i16], [u13[0] - e13, u13[1] - e13], [u13[0] + i16, u13[1] + i16]], t15), M4 = { main: R2([m7, _6, l12, u13], t15), top: x4, bot: p7, left: b4, right: L3 };
    return [new i5(a12, f7, c5 + 2 * i16, d4 + 2 * i16), M4];
  }
  get boundsT() {
    const t15 = this.bounds, s13 = o(n4(), t15.x, t15.y);
    if (S(s13, s13, this._transform), this._hasRotation) {
      const i16 = Math.max(t15.width, t15.height);
      return new i5(s13[0], s13[1], i16, i16);
    }
    return new i5(s13[0], s13[1], t15.width, t15.height);
  }
  _createBounds(t15) {
    let s13 = 1 / 0, i16 = 1 / 0, e13 = 0, o8 = 0;
    for (const r18 of t15) s13 = Math.min(s13, r18.xTopLeft), i16 = Math.min(i16, r18.yTopLeft), e13 = Math.max(e13, r18.xBottomRight), o8 = Math.max(o8, r18.yBottomRight);
    const h8 = e13 - s13, n18 = o8 - i16;
    return new i5(s13 + h8 / 2, i16 + n18 / 2, h8, n18);
  }
  _createGlyphTransform(t15, s13) {
    const h8 = b3 * s13.angle, n18 = n3(), f7 = n4();
    return i4(n18, n18, o(f7, s13.xOffset, -s13.yOffset)), s13.useCIMAngleBehavior ? s4(n18, n18, h8) : (i4(n18, n18, o(f7, t15.x, t15.y)), s4(n18, n18, h8), i4(n18, n18, o(f7, -t15.x, -t15.y))), n18;
  }
};
var T3 = class {
  constructor(t15, s13, i16, e13, o8, h8) {
    this.glyphWidthEnd = 0, this.startX = 0, this.startY = 0, this.start = Math.max(0, Math.min(s13, i16)), this.end = Math.max(0, Math.max(s13, i16)), this.end < t15.length && (this.glyphWidthEnd = t15[this.end].metrics.width), this.width = e13, this.yMin = o8, this.yMax = h8;
  }
};
var v2 = (t15) => 10 === t15;
var j = (t15) => 32 === t15;
function A4(t15, s13, i16) {
  const e13 = new Array(), o8 = 1 / i16.scale, h8 = i16.maxLineWidth * o8, n18 = s13 ? t15.length - 1 : 0, r18 = s13 ? -1 : t15.length, a12 = s13 ? -1 : 1;
  let f7 = n18, c5 = 0, d4 = 0, m7 = f7, g5 = m7, _6 = 0, l12 = 1 / 0, u13 = 0;
  for (; f7 !== r18; ) {
    const { code: s14, metrics: i17 } = t15[f7], o9 = Math.abs(i17.top);
    if (v2(s14) || j(s14) || (l12 = Math.min(l12, o9), u13 = Math.max(u13, o9 + i17.height)), v2(s14)) f7 !== n18 && (e13.push(new T3(t15, m7, f7 - a12, c5, l12 === 1 / 0 ? 0 : l12, u13)), l12 = 1 / 0, u13 = 0), c5 = 0, m7 = f7 + a12, g5 = f7 + a12, d4 = 0;
    else if (j(s14)) g5 = f7 + a12, d4 = 0, _6 = i17.advance, c5 += i17.advance;
    else if (c5 > h8) {
      if (g5 !== m7) {
        const s15 = g5 - 2 * a12;
        c5 -= _6, e13.push(new T3(t15, m7, s15, c5 - d4, l12, u13)), l12 = 1 / 0, u13 = 0, m7 = g5, c5 = d4;
      } else e13.push(new T3(t15, m7, f7 - a12, c5, l12, u13)), l12 = 1 / 0, u13 = 0, m7 = f7, g5 = f7, c5 = 0;
      c5 += i17.advance, d4 += i17.advance;
    } else c5 += i17.advance, d4 += i17.advance;
    f7 += a12;
  }
  const x4 = new T3(t15, m7, f7 - a12, c5, l12, u13);
  return x4.start >= 0 && x4.end < t15.length && e13.push(x4), e13;
}
function z(t15, s13) {
  let i16 = 0;
  for (let h8 = 0; h8 < t15.length; h8++) {
    const { width: s14 } = t15[h8];
    i16 = Math.max(s14, i16);
  }
  const e13 = "underline" === s13.decoration ? l10 : 0, o8 = t15[0].yMin;
  return { x: 0, y: o8, height: t15[t15.length - 1].yMax + s13.lineHeight * (t15.length - 1) + e13 - o8, width: i16 };
}
function O(t15, s13) {
  const i16 = s13.scale, e13 = new Array(), { glyphs: o8, isRightToLeft: h8 } = t15, n18 = A4(o8, h8, s13), r18 = n18.length ? z(n18, s13) : { x: 0, y: 0, height: 0, width: 0 }, a12 = a11(s13.horizontalAlignment), m7 = c4(s13.verticalAlignment), g5 = m7 === n14.Baseline ? 1 : 0, l12 = g5 ? 0 : m7 - 1, u13 = (1 - g5) * -r18.y + l12 * (r18.height / 2) + (g5 ? 1 : 0) * -_4;
  for (let f7 = 0; f7 < n18.length; f7++) {
    const { start: h9, end: r19, width: c5 } = n18[f7];
    let d4 = -1 * (a12 + 1) * (c5 / 2) - p5;
    const m8 = (t15.isRightToLeft ? n18.length - 1 - f7 : f7) * s13.lineHeight + u13 - p5;
    n18[f7].startX = d4, n18[f7].startY = m8;
    for (let t16 = h9; t16 <= r19; t16++) {
      const s14 = o8[t16];
      if (v2(s14.code)) continue;
      const h10 = new L2(d4 + s14.metrics.left, m8 - s14.metrics.top, s14, i16);
      d4 += s14.metrics.advance, e13.push(h10);
    }
  }
  return new B3(e13, n18, s13);
}

// node_modules/@arcgis/core/views/2d/layers/graphics/graphicsUtils.js
var u12 = 50;
function l11(r18) {
  if (!r18) return null;
  const { xmin: n18, ymin: t15, xmax: i16, ymax: o8, spatialReference: s13 } = r18;
  return new v({ rings: [[[n18, t15], [n18, o8], [i16, o8], [i16, t15], [n18, t15]]], spatialReference: s13 });
}
function p6(e13) {
  return e2(Math.round(u3(e13)));
}
function g4(n18) {
  const e13 = e2(yi), t15 = e2(zi);
  return Math.max(e13, Math.min(n18 || t15, t15));
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolDrawHelper.js
var K2 = Math.PI / 180;
var Q2 = 0.5;
var Z2 = () => n.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");
var $ = class _$ {
  constructor(t15) {
    this._t = t15;
  }
  static createIdentity() {
    return new _$([1, 0, 0, 0, 1, 0]);
  }
  clone() {
    const t15 = this._t;
    return new _$(t15.slice());
  }
  transform(t15) {
    const e13 = this._t;
    return [e13[0] * t15[0] + e13[1] * t15[1] + e13[2], e13[3] * t15[0] + e13[4] * t15[1] + e13[5]];
  }
  static createScale(t15, e13) {
    return new _$([t15, 0, 0, 0, e13, 0]);
  }
  scale(t15, e13) {
    const r18 = this._t;
    return r18[0] *= t15, r18[1] *= t15, r18[2] *= t15, r18[3] *= e13, r18[4] *= e13, r18[5] *= e13, this;
  }
  scaleRatio() {
    return Math.sqrt(this._t[0] * this._t[0] + this._t[1] * this._t[1]);
  }
  static createTranslate(t15, e13) {
    return new _$([0, 0, t15, 0, 0, e13]);
  }
  translate(t15, e13) {
    const r18 = this._t;
    return r18[2] += t15, r18[5] += e13, this;
  }
  static createRotate(t15) {
    const e13 = Math.cos(t15), r18 = Math.sin(t15);
    return new _$([e13, -r18, 0, r18, e13, 0]);
  }
  rotate(t15) {
    return _$.multiply(this, _$.createRotate(t15), this);
  }
  angle() {
    const t15 = this._t[0], e13 = this._t[3], r18 = Math.sqrt(t15 * t15 + e13 * e13);
    return [t15 / r18, e13 / r18];
  }
  static multiply(t15, e13, r18) {
    const s13 = t15._t, i16 = e13._t, o8 = s13[0] * i16[0] + s13[3] * i16[1], n18 = s13[1] * i16[0] + s13[4] * i16[1], a12 = s13[2] * i16[0] + s13[5] * i16[1] + i16[2], l12 = s13[0] * i16[3] + s13[3] * i16[4], h8 = s13[1] * i16[3] + s13[4] * i16[4], c5 = s13[2] * i16[3] + s13[5] * i16[4] + i16[5], m7 = r18._t;
    return m7[0] = o8, m7[1] = n18, m7[2] = a12, m7[3] = l12, m7[4] = h8, m7[5] = c5, r18;
  }
  invert() {
    const t15 = this._t;
    let e13 = t15[0] * t15[4] - t15[1] * t15[3];
    if (0 === e13) return new _$([0, 0, 0, 0, 0, 0]);
    e13 = 1 / e13;
    const r18 = (t15[1] * t15[5] - t15[2] * t15[4]) * e13, s13 = (t15[2] * t15[3] - t15[0] * t15[5]) * e13, i16 = t15[4] * e13, o8 = -t15[1] * e13, n18 = -t15[3] * e13, a12 = t15[0] * e13;
    return new _$([i16, o8, r18, n18, a12, s13]);
  }
};
var tt = class {
  constructor(t15, e13) {
    this._resourceManager = t15, this._transfos = [], this._sizeTransfos = [], this._geomUnitsPerPoint = 1, this._placementPool = new e(t6, void 0, void 0, 100), this._earlyReturn = false, this._mapRotation = 0, this._transfos.push(e13 || $.createIdentity()), this._sizeTransfos.push(e13 ? e13.scaleRatio() : 1);
  }
  setTransform(t15, e13) {
    this._transfos = [t15 || $.createIdentity()], this._sizeTransfos = [e13 || (t15 ? t15.scaleRatio() : 1)];
  }
  setGeomUnitsPerPoint(t15) {
    this._geomUnitsPerPoint = t15;
  }
  transformPt(t15) {
    return this._transfos[this._transfos.length - 1].transform(t15);
  }
  transformSize(t15) {
    return t15 * this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformPt(t15) {
    return this._transfos[this._transfos.length - 1].invert().transform(t15);
  }
  reverseTransformSize(t15) {
    return t15 / this._sizeTransfos[this._sizeTransfos.length - 1];
  }
  reverseTransformScalar(t15) {
    return t15 / this._transfos[this._transfos.length - 1].scaleRatio();
  }
  getTransformAngle() {
    return this._transfos[this._transfos.length - 1].angle();
  }
  geomUnitsPerPoint() {
    return this.isEmbedded() ? 1 : this._geomUnitsPerPoint;
  }
  prevGeomUnitsPerPoint() {
    return this._transfos.length > 2 ? 1 : this._geomUnitsPerPoint;
  }
  isEmbedded() {
    return this._transfos.length > 1;
  }
  back() {
    return this._transfos[this._transfos.length - 1];
  }
  push(t15, e13) {
    const r18 = e13 ? t15.scaleRatio() : 1;
    $.multiply(t15, this.back(), t15), this._transfos.push(t15), this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length - 1] * r18);
  }
  pop() {
    this._transfos.splice(-1, 1), this._sizeTransfos.splice(-1, 1);
  }
  drawSymbol(t15, e13, r18) {
    if (t15) switch (t15.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this.drawMultiLayerSymbol(t15, e13);
        break;
      case "CIMTextSymbol":
        this.drawTextSymbol(t15, e13, r18);
    }
  }
  drawMultiLayerSymbol(t15, e13) {
    if (!t15 || !e13) return;
    const r18 = t15.symbolLayers;
    if (!r18) return;
    const s13 = t15.effects;
    if (s13 && s13.length > 0) {
      const t16 = this.executeEffects(s13, e13);
      if (t16) {
        let e14 = t16.next();
        for (; e14; ) this.drawSymbolLayers(r18, e14.asJSON()), e14 = t16.next();
      }
    } else this.drawSymbolLayers(r18, e13);
  }
  executeEffects(t15, e13) {
    const r18 = this._resourceManager.geometryEngine;
    let s13 = new s7(a6.fromJSONCIM(e13));
    for (const i16 of t15) {
      const t16 = A3(i16);
      t16 && (s13 = t16.execute(s13, i16, this.geomUnitsPerPoint(), null, r18));
    }
    return s13;
  }
  drawSymbolLayers(t15, e13) {
    let r18 = t15.length;
    for (; r18--; ) {
      const s13 = t15[r18];
      if (!s13 || false === s13.enable) continue;
      const i16 = s13.effects;
      if (i16 && i16.length > 0) {
        const t16 = this.executeEffects(i16, e13);
        if (t16) {
          let e14 = null;
          for (; (e14 = t16.next()) && (this.drawSymbolLayer(s13, e14.asJSON()), !this._earlyReturn); ) ;
        }
      } else this.drawSymbolLayer(s13, e13);
      if (this._earlyReturn) return;
    }
  }
  drawSymbolLayer(t15, e13) {
    switch (t15.type) {
      case "CIMSolidFill":
        this.drawSolidFill(e13, t15.color, t15.path);
        break;
      case "CIMHatchFill":
        this.drawHatchFill(e13, t15);
        break;
      case "CIMPictureFill":
        this.drawPictureFill(e13, t15);
        break;
      case "CIMGradientFill":
        this.drawGradientFill(e13, t15);
        break;
      case "CIMSolidStroke":
        this.drawSolidStroke(e13, t15.color, t15.width, t15.capStyle, t15.joinStyle, t15.miterLimit, t15.path);
        break;
      case "CIMPictureStroke":
        this.drawPictureStroke(e13, t15);
        break;
      case "CIMGradientStroke":
        this.drawGradientStroke(e13, t15);
        break;
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
      case "CIMVectorMarker":
        this.drawMarkerLayer(t15, e13);
    }
  }
  drawHatchFill(t15, e13) {
    const r18 = it(e13, t15, this.geomUnitsPerPoint());
    r18 && (this.pushClipPath(t15), this.drawMultiLayerSymbol(e13.lineSymbol, r18), this.popClipPath());
  }
  drawPictureFill(t15, e13) {
  }
  drawGradientFill(t15, e13) {
  }
  drawPictureStroke(t15, e13) {
  }
  drawGradientStroke(t15, e13) {
  }
  drawMarkerLayer(t15, e13) {
    const r18 = t15.markerPlacement;
    if (r18) {
      const s13 = g3(r18);
      if (s13) {
        const i16 = "CIMMarkerPlacementInsidePolygon" === r18.type || "CIMMarkerPlacementPolygonCenter" === r18.type && r18.clipAtBoundary;
        i16 && this.pushClipPath(e13);
        const o8 = s13.execute(a6.fromJSONCIM(e13), r18, this.geomUnitsPerPoint(), null, this._resourceManager.geometryEngine);
        if (o8) {
          let e14 = null;
          for (; (e14 = o8.next()) && (this.drawMarker(t15, e14), !this._earlyReturn); ) ;
        }
        i16 && this.popClipPath();
      }
    } else {
      const r19 = this._placementPool.acquire();
      if (u2(e13)) r19.tx = e13.x, r19.ty = e13.y, this.drawMarker(t15, r19);
      else if (y(e13)) {
        const s13 = l(e13);
        s13 && ([r19.tx, r19.ty] = s13, this.drawMarker(t15, r19));
      } else for (const s13 of e13.points) if (r19.tx = s13[0], r19.ty = s13[1], this.drawMarker(t15, r19), this._earlyReturn) break;
      this._placementPool.release(r19);
    }
  }
  drawMarker(t15, e13) {
    switch (t15.type) {
      case "CIMCharacterMarker":
      case "CIMPictureMarker":
        this.drawPictureMarker(t15, e13);
        break;
      case "CIMVectorMarker":
        this.drawVectorMarker(t15, e13);
    }
  }
  drawPictureMarker(t15, e13) {
    if (!t15) return;
    const r18 = this._resourceManager.getResource(t15.url), s13 = p(t15.size, i3.CIMPictureMarker.size);
    if (null == r18 || s13 <= 0) return;
    const i16 = r18.width, o8 = r18.height;
    if (!i16 || !o8) return;
    const n18 = i16 / o8, a12 = p(t15.scaleX, 1), l12 = $.createIdentity(), h8 = t15.anchorPoint;
    if (h8) {
      let e14 = h8.x, r19 = h8.y;
      "Absolute" !== t15.anchorPointUnits && (e14 *= s13 * n18 * a12, r19 *= s13), l12.translate(-e14, -r19);
    }
    let c5 = p(t15.rotation);
    t15.rotateClockwise && (c5 = -c5), this._mapRotation && (c5 += this._mapRotation), c5 && l12.rotate(c5 * K2);
    let m7 = p(t15.offsetX), f7 = p(t15.offsetY);
    if (m7 || f7) {
      if (this._mapRotation) {
        const t16 = K2 * this._mapRotation, e14 = Math.cos(t16), r19 = Math.sin(t16), s14 = m7 * r19 + f7 * e14;
        m7 = m7 * e14 - f7 * r19, f7 = s14;
      }
      l12.translate(m7, f7);
    }
    const u13 = this.geomUnitsPerPoint();
    1 !== u13 && l12.scale(u13, u13);
    const d4 = e13.getAngle();
    d4 && l12.rotate(d4), l12.translate(e13.tx, e13.ty), this.push(l12, false), this.drawImage(t15, s13), this.pop();
  }
  drawVectorMarker(t15, e13) {
    if (!t15) return;
    const r18 = t15.markerGraphics;
    if (!r18) return;
    const s13 = p(t15.size, i3.CIMVectorMarker.size), i16 = t15.frame, o8 = i16 ? i16.ymax - i16.ymin : 0, n18 = s13 && o8 ? s13 / o8 : 1, a12 = $.createIdentity();
    i16 && a12.translate(0.5 * -(i16.xmax + i16.xmin), 0.5 * -(i16.ymax + i16.ymin));
    const l12 = t15.anchorPoint;
    if (l12) {
      let e14 = l12.x, r19 = l12.y;
      "Absolute" !== t15.anchorPointUnits ? i16 && (e14 *= i16.xmax - i16.xmin, r19 *= i16.ymax - i16.ymin) : (e14 /= n18, r19 /= n18), a12.translate(-e14, -r19);
    }
    1 !== n18 && a12.scale(n18, n18);
    let h8 = p(t15.rotation);
    t15.rotateClockwise && (h8 = -h8), this._mapRotation && (h8 += this._mapRotation), h8 && a12.rotate(h8 * K2);
    let c5 = p(t15.offsetX), m7 = p(t15.offsetY);
    if (c5 || m7) {
      if (this._mapRotation) {
        const t16 = K2 * this._mapRotation, e14 = Math.cos(t16), r19 = Math.sin(t16), s14 = c5 * r19 + m7 * e14;
        c5 = c5 * e14 - m7 * r19, m7 = s14;
      }
      a12.translate(c5, m7);
    }
    const f7 = this.geomUnitsPerPoint();
    1 !== f7 && a12.scale(f7, f7);
    const u13 = e13.getAngle();
    u13 && a12.rotate(u13), a12.translate(e13.tx, e13.ty), this.push(a12, t15.scaleSymbolsProportionally);
    for (const d4 of r18) {
      (d4 == null ? void 0 : d4.symbol) && d4.geometry || Z2().error("Invalid marker graphic", d4);
      let t16 = d4.textString;
      if ("number" == typeof t16 && (t16 = t16.toString()), this.drawSymbol(d4.symbol, d4.geometry, t16), this._earlyReturn) break;
    }
    this.pop();
  }
  drawTextSymbol(t15, e13, r18) {
    if (!t15) return;
    if (!u2(e13)) return;
    if (p(t15.height, i3.CIMTextSymbol.height) <= 0) return;
    const s13 = $.createIdentity();
    let i16 = p(t15.angle);
    i16 = -i16, i16 && s13.rotate(i16 * K2);
    const o8 = p(t15.offsetX), n18 = p(t15.offsetY);
    (o8 || n18) && s13.translate(o8, n18);
    const a12 = this.geomUnitsPerPoint();
    1 !== a12 && s13.scale(a12, a12), s13.translate(e13.x, e13.y), this.push(s13, false), this.drawText(t15, r18), this.pop();
  }
};
var et = class extends tt {
  constructor(t15, e13) {
    super(t15, e13), this.reset();
  }
  reset() {
    this._xmin = this._ymin = 1 / 0, this._xmax = this._ymax = -1 / 0, this._clipCount = 0;
  }
  envelope() {
    return new t13(this._xmin, this._ymin, this._xmax - this._xmin, this._ymax - this._ymin);
  }
  bounds() {
    return a2(this._xmin, this._ymin, this._xmax, this._ymax);
  }
  drawSolidFill(t15) {
    if (t15 && !(this._clipCount > 0)) if (y(t15)) this._processPath(t15.rings, 0);
    else if (s(t15)) this._processPath(t15.paths, 0);
    else if (m(t15)) {
      const e13 = lt(t15);
      e13 && this._processPath(e13.rings, 0);
    } else console.error("drawSolidFill Unexpected geometry type!");
  }
  drawSolidStroke(t15, e13, r18) {
    if (!t15 || this._clipCount > 0 || null == r18 || r18 <= 0) return;
    const s13 = Math.max(0.5 * this.transformSize(p(r18, i3.CIMSolidStroke.width)), 0.5 * Q2);
    if (y(t15)) this._processPath(t15.rings, s13);
    else if (s(t15)) this._processPath(t15.paths, s13);
    else if (m(t15)) {
      const e14 = lt(t15);
      e14 && this._processPath(e14.rings, s13);
    } else console.error("drawSolidStroke unexpected geometry type!");
  }
  drawMarkerLayer(t15, e13) {
    y(e13) && t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._processPath(e13.rings, 0) : super.drawMarkerLayer(t15, e13);
  }
  drawHatchFill(t15, e13) {
    this.drawSolidFill(t15);
  }
  drawPictureFill(t15, e13) {
    this.drawSolidFill(t15);
  }
  drawGradientFill(t15, e13) {
    this.drawSolidFill(t15);
  }
  drawPictureStroke(t15, e13) {
    this.drawSolidStroke(t15, null, e13.width);
  }
  drawGradientStroke(t15, e13) {
    this.drawSolidStroke(t15, null, e13.width);
  }
  pushClipPath(t15) {
    this.drawSolidFill(t15), this._clipCount++;
  }
  popClipPath() {
    this._clipCount--;
  }
  drawImage(t15, e13) {
    const { url: r18 } = t15, s13 = p(t15.scaleX, 1);
    let i16 = s13 * e13, o8 = e13;
    const n18 = this._resourceManager.getResource(r18);
    if (null != n18) {
      const t16 = n18.height / n18.width;
      i16 = s13 * (e13 ? t16 > 1 ? e13 : e13 / t16 : n18.width), o8 = e13 ? t16 > 1 ? e13 * t16 : e13 : n18.height;
    }
    this._merge(this.transformPt([-i16 / 2, -o8 / 2]), 0), this._merge(this.transformPt([-i16 / 2, o8 / 2]), 0), this._merge(this.transformPt([i16 / 2, -o8 / 2]), 0), this._merge(this.transformPt([i16 / 2, o8 / 2]), 0);
  }
  drawText(t15, e13) {
    if (!e13 || 0 === e13.length) return;
    this._textRasterizer || (this._textRasterizer = new s12());
    const r18 = ct(t15);
    let [s13, o8] = this._textRasterizer.computeTextSize(e13, r18);
    s13 = e2(s13), o8 = e2(o8);
    const n18 = this.transformSize(1) * this.reverseTransformScalar(1);
    s13 *= n18, o8 *= n18;
    let a12 = 0;
    switch (t15.horizontalAlignment) {
      case "Left":
        a12 = s13 / 2;
        break;
      case "Right":
        a12 = -s13 / 2;
    }
    let l12 = 0;
    switch (t15.verticalAlignment) {
      case "Bottom":
        l12 = o8 / 2;
        break;
      case "Top":
        l12 = -o8 / 2;
        break;
      case "Baseline":
        l12 = o8 / 6;
    }
    this._merge(this.transformPt([-s13 / 2 + a12, -o8 / 2 + l12]), 0), this._merge(this.transformPt([-s13 / 2 + a12, o8 / 2 + l12]), 0), this._merge(this.transformPt([s13 / 2 + a12, -o8 / 2 + l12]), 0), this._merge(this.transformPt([s13 / 2 + a12, o8 / 2 + l12]), 0);
  }
  _processPath(t15, e13) {
    if (t15) for (const r18 of t15) {
      const t16 = r18 ? r18.length : 0;
      if (t16 > 1) {
        this._merge(this.transformPt(r18[0]), e13);
        for (let s13 = 1; s13 < t16; s13++) this._merge(this.transformPt(r18[s13]), e13);
      }
    }
  }
  _merge(t15, e13) {
    t15[0] - e13 < this._xmin && (this._xmin = t15[0] - e13), t15[0] + e13 > this._xmax && (this._xmax = t15[0] + e13), t15[1] - e13 < this._ymin && (this._ymin = t15[1] - e13), t15[1] + e13 > this._ymax && (this._ymax = t15[1] + e13);
  }
};
var rt = class extends tt {
  constructor() {
    super(...arguments), this._searchPoint = [0, 0], this._searchDistPoint = 0, this._textInfo = null, this._svg = null, this._path = null, this._canvas = null;
  }
  destroy() {
    this._svg = n17(this._svg), this._path = null, this._canvas = null;
  }
  hitTest(t15, e13, r18, s13, n18, a12) {
    var _a;
    const l12 = a12 * u3(1);
    this.setTransform(), this.setGeomUnitsPerPoint(l12), this._searchPoint = [(t15[0] + t15[2]) / 2, (t15[1] + t15[3]) / 2], this._searchDistPoint = (t15[2] - t15[0]) / 2 / l12, this._textInfo = s13;
    const h8 = e13 && ("CIMPointSymbol" === e13.type && "Map" !== e13.angleAlignment || "CIMTextSymbol" === e13.type);
    if (this._mapRotation = h8 ? n18 : 0, !has("esri-mobile")) {
      const t16 = e2(X * window.devicePixelRatio), r19 = e2(Y);
      !(("CIMLineSymbol" === (e13 == null ? void 0 : e13.type) || "CIMPolygonSymbol" === (e13 == null ? void 0 : e13.type)) && ((_a = e13.symbolLayers) == null ? void 0 : _a.some(C))) && "CIMMeshSymbol" !== (e13 == null ? void 0 : e13.type) && (H(e13) ?? 0) < r19 && (this._searchDistPoint = t16);
    }
    return this._earlyReturn = false, this.drawSymbol(e13, r18), this._earlyReturn;
  }
  executeEffects(t15, e13) {
    var _a;
    return "CIMGeometricEffectDashes" === ((_a = t15.at(-1)) == null ? void 0 : _a.type) && (t15 = t15.slice(0, -1)), super.executeEffects(t15, e13);
  }
  drawSolidFill(t15, e13, r18) {
    null != r18 ? this._hittestSvgPath(t15, r18, true) : this._hitTestFill(t15);
  }
  drawHatchFill(t15, e13) {
    this._hitTestFill(t15);
  }
  drawPictureFill(t15, e13) {
    this._hitTestFill(t15);
  }
  drawGradientFill(t15, e13) {
    this._hitTestFill(t15);
  }
  drawSolidStroke(t15, e13, r18, s13, i16, o8, n18) {
    null != n18 ? this._hittestSvgPath(t15, n18, false, r18) : this._hitTestStroke(t15, r18);
  }
  drawPictureStroke(t15, e13) {
    this._hitTestStroke(t15, e13.width);
  }
  drawGradientStroke(t15, e13) {
    this._hitTestStroke(t15, e13.width);
  }
  drawMarkerLayer(t15, e13) {
    t15.markerPlacement && ("CIMMarkerPlacementInsidePolygon" === t15.markerPlacement.type || "CIMMarkerPlacementPolygonCenter" === t15.markerPlacement.type && t15.markerPlacement.clipAtBoundary) ? this._hitTestFill(e13) : super.drawMarkerLayer(t15, e13);
  }
  pushClipPath(t15) {
  }
  popClipPath() {
  }
  drawImage(t15, e13) {
    const { url: r18 } = t15, s13 = p(t15.scaleX, 1), i16 = this._resourceManager.getResource(r18);
    if (null == i16 || 0 === i16.height || 0 === e13) return;
    const o8 = e13 * this.geomUnitsPerPoint(), n18 = o8 * s13 * (i16.width / i16.height), a12 = this.reverseTransformPt(this._searchPoint), l12 = this._searchDistPoint;
    Math.abs(a12[0]) < n18 / 2 + l12 && Math.abs(a12[1]) < o8 / 2 + l12 && (this._earlyReturn = true);
  }
  drawText(t15, e13) {
    var _a;
    const r18 = this._textInfo;
    if (!r18) return;
    const s13 = r18.get(t15);
    if (!s13) return;
    if (!s13.glyphMosaicItems.glyphs.length) return;
    const i16 = p6(p(t15.height, i3.CIMTextSymbol.height)), { lineGapType: o8, lineGap: n18 } = t15, a12 = o8 ? ht(o8, p(n18), i16) : 0, l12 = "CIMBackgroundCallout" === ((_a = t15.callout) == null ? void 0 : _a.type), h8 = O(s13.glyphMosaicItems, { scale: i16 / A, angle: 0, xOffset: 0, yOffset: 0, horizontalAlignment: t15.horizontalAlignment, verticalAlignment: t15.verticalAlignment, maxLineWidth: g4(t15.lineWidth), lineHeight: G2 * Math.max(0.25, Math.min(a12 || 1, 4)), decoration: t15.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }), c5 = this.reverseTransformPt(this._searchPoint), m7 = c5[0], f7 = c5[1];
    for (const u13 of h8.glyphs) if (m7 > u13.xTopLeft && m7 < u13.xBottomRight && f7 > -u13.yBottomRight && f7 < -u13.yTopLeft) {
      this._earlyReturn = true;
      break;
    }
  }
  _hitTestFill(t15) {
    let e13 = null;
    if (m(t15)) {
      const r19 = t15;
      e13 = [[[r19.xmin, r19.ymin], [r19.xmin, r19.ymax], [r19.xmax, r19.ymax], [r19.xmax, r19.ymin], [r19.xmin, r19.ymin]]];
    } else if (y(t15)) e13 = t15.rings;
    else {
      if (!s(t15)) return;
      e13 = t15.paths;
    }
    const r18 = this.reverseTransformPt(this._searchPoint);
    if (ot(r18, e13) && (this._earlyReturn = true), !this._earlyReturn) {
      nt(r18, e13, this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
    }
  }
  _getSvgPath() {
    return null != this._svg && null != this._path || (this._svg ?? (this._svg = e12()), this._path ?? (this._path = t14("path")), this._svg.appendChild(this._path)), this._path;
  }
  _getCanvas() {
    return this._canvas ?? (this._canvas = document.createElement("canvas")), this._canvas;
  }
  _hittestSvgPath(t15, e13, r18, s13) {
    const i16 = u();
    a3(i16, t15);
    const o8 = { x: i16[0], y: i16[1], width: i16[2] - i16[0], height: i16[3] - i16[1] }, n18 = this._getSvgPath();
    n18.setAttribute("d", e13);
    const a12 = n18.getBBox(), c5 = a12.width / o8.width, m7 = a12.height / o8.height, f7 = this._getCanvas();
    f7.width = a12.width, f7.height = a12.height;
    const u13 = f7.getContext("2d", { willReadFrequently: true });
    u13.setTransform(1, 0, 0, 1, a12.x, -a12.y);
    const d4 = new Path2D(e13);
    r18 ? u13.fill(d4) : (u13.lineWidth = s13 * c5, u13.stroke(d4));
    const p7 = this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint(), _6 = this.reverseTransformPt(this._searchPoint), g5 = (_6[0] - o8.x - p7) * c5, y6 = (o8.height - (_6[1] - o8.y) - p7) * m7, P5 = 2 * p7 * c5, w5 = 2 * p7 * m7, x4 = u13.getImageData(g5, y6, P5, w5).data;
    for (let l12 = 3; l12 < x4.length; l12 += 4) if (x4[l12] > 127.5) return void (this._earlyReturn = true);
  }
  _hitTestStroke(t15, e13) {
    let r18 = null;
    if (m(t15)) {
      const e14 = t15;
      r18 = [[[e14.xmin, e14.ymin], [e14.xmin, e14.ymax], [e14.xmax, e14.ymax], [e14.xmax, e14.ymin], [e14.xmin, e14.ymin]]];
    } else if (y(t15)) r18 = t15.rings;
    else {
      if (!s(t15)) return;
      r18 = t15.paths;
    }
    nt(this.reverseTransformPt(this._searchPoint), r18, p(e13, i3.CIMSolidStroke.width) * this.geomUnitsPerPoint() / 2 + this.reverseTransformScalar(this._searchDistPoint) * this.prevGeomUnitsPerPoint()) && (this._earlyReturn = true);
  }
};
var st = class extends tt {
  constructor(t15, e13, r18, s13) {
    super(e13, r18), this._applyAdditionalRenderProps = s13, this._colorSubstitutionHelper = new t11(), this._ctx = t15;
  }
  drawSolidFill(t15, e13) {
    if (!t15) return;
    if (y(t15)) this._buildPath(t15.rings, true);
    else if (s(t15)) this._buildPath(t15.paths, true);
    else if (m(t15)) this._buildPath(lt(t15).rings, true);
    else {
      if (!l2(t15)) return;
      console.log("CanvasDrawHelper.drawSolidFill - No implementation!");
    }
    const r18 = this._ctx;
    r18.fillStyle = "string" == typeof e13 ? e13 : "rgba(" + Math.round(e13[0]) + "," + Math.round(e13[1]) + "," + Math.round(e13[2]) + "," + (e13[3] ?? 255) / 255 + ")", r18.fill("evenodd");
  }
  drawSolidStroke(t15, e13, r18, s13, i16, o8) {
    if (!t15 || !e13 || 0 === r18) return;
    if (y(t15)) this._buildPath(t15.rings, true);
    else if (s(t15)) this._buildPath(t15.paths, false);
    else {
      if (!m(t15)) return void console.log("CanvasDrawHelper.drawSolidStroke isn't implemented!");
      this._buildPath(lt(t15).rings, true);
    }
    const n18 = this._ctx;
    n18.strokeStyle = "string" == typeof e13 ? e13 : "rgba(" + Math.round(e13[0]) + "," + Math.round(e13[1]) + "," + Math.round(e13[2]) + "," + (e13[3] ?? 255) / 255 + ")", n18.lineWidth = Math.max(this.transformSize(r18), Q2), this._setCapStyle(s13), this._setJoinStyle(i16), n18.miterLimit = o8, n18.stroke();
  }
  pushClipPath(t15) {
    if (this._ctx.save(), y(t15)) this._buildPath(t15.rings, true);
    else if (s(t15)) this._buildPath(t15.paths, true);
    else {
      if (!m(t15)) return;
      this._buildPath(lt(t15).rings, true);
    }
    this._ctx.clip("evenodd");
  }
  popClipPath() {
    this._ctx.restore();
  }
  drawImage(t15, e13) {
    const { colorSubstitutions: r18, url: s13, tintColor: i16 } = t15, o8 = p(t15.scaleX, 1), n18 = this._resourceManager.getResource(s13);
    if (null == n18) return;
    let a12 = e13 * (n18.width / n18.height), l12 = e13;
    e13 || (a12 = n18.width, l12 = n18.height);
    const h8 = G3(s13) || "src" in n18 && G3(n18.src);
    let c5 = "getFrame" in n18 ? t12(n18) : n18;
    r18 && (c5 = this._colorSubstitutionHelper.applyColorSubstitution(c5, r18)), this._applyAdditionalRenderProps && !h8 && i16 && (c5 = this._colorSubstitutionHelper.tintImageData(c5, i16));
    const m7 = this.transformPt([0, 0]), [f7, u13] = this.getTransformAngle(), d4 = this.transformSize(1), p7 = this._ctx;
    p7.save(), p7.setTransform({ m11: o8 * d4 * f7, m12: o8 * d4 * u13, m21: -d4 * u13, m22: d4 * f7, m41: m7[0], m42: m7[1] }), p7.drawImage(c5, -a12 / 2, -l12 / 2, a12, l12), p7.restore();
  }
  drawText(t15, e13) {
    if (!e13 || 0 === e13.length) return;
    this._textRasterizer || (this._textRasterizer = new s12());
    const r18 = ct(t15, this.transformSize(e2(1))), s13 = this._textRasterizer.rasterizeText(e13, r18);
    if (!s13) return;
    const { size: o8, anchorX: n18, anchorY: a12, canvas: l12 } = s13, h8 = o8[0] * (n18 + 0.5), c5 = o8[1] * (a12 - 0.5), m7 = this._ctx, f7 = this.transformPt([0, 0]), [u13, d4] = this.getTransformAngle(), p7 = 1;
    m7.save(), m7.setTransform({ m11: p7 * u13, m12: p7 * d4, m21: -p7 * d4, m22: p7 * u13, m41: f7[0] - p7 * h8, m42: f7[1] + p7 * c5 }), m7.drawImage(l12, 0, 0), m7.restore();
  }
  drawPictureFill(t15, e13) {
    if (!t15) return;
    let { colorSubstitutions: r18, height: s13, offsetX: i16, offsetY: o8, rotation: n18, scaleX: a12, tintColor: l12, url: h8 } = e13;
    const c5 = this._resourceManager.getResource(h8);
    if (null == c5) return;
    if (y(t15)) this._buildPath(t15.rings, true);
    else if (s(t15)) this._buildPath(t15.paths, true);
    else if (m(t15)) this._buildPath(lt(t15).rings, true);
    else {
      if (!l2(t15)) return;
      console.log("CanvasDrawHelper.drawPictureFill - No implementation!");
    }
    const m7 = this._ctx, _6 = G3(h8) || "src" in c5 && G3(c5.src);
    let g5, y6 = "getFrame" in c5 ? t12(c5) : c5;
    if (r18 && (y6 = this._colorSubstitutionHelper.applyColorSubstitution(y6, r18)), this._applyAdditionalRenderProps) {
      _6 || l12 && (y6 = this._colorSubstitutionHelper.tintImageData(y6, l12)), g5 = m7.createPattern(y6, "repeat");
      const t16 = this.transformSize(1);
      n18 || (n18 = 0), i16 ? i16 *= t16 : i16 = 0, o8 ? o8 *= t16 : o8 = 0, s13 && (s13 *= t16);
      const e14 = s13 ? s13 / c5.height : 1, r19 = a12 && s13 ? a12 * s13 / c5.width : 1;
      if (0 !== n18 || 1 !== e14 || 1 !== r19 || 0 !== i16 || 0 !== o8) {
        const t17 = new DOMMatrix();
        t17.rotateSelf(0, 0, -n18).translateSelf(i16, o8).scaleSelf(r19, e14, 1), g5.setTransform(t17);
      }
    } else g5 = m7.createPattern(y6, "repeat");
    m7.save(), m7.fillStyle = g5, m7.fill("evenodd"), m7.restore();
  }
  drawPictureStroke(t15, r18) {
    if (!t15) return;
    let { colorSubstitutions: s13, capStyle: i16, joinStyle: n18, miterLimit: a12, tintColor: l12, url: h8, width: c5 } = r18;
    const m7 = this._resourceManager.getResource(h8);
    if (null == m7) return;
    let _6;
    if (y(t15)) _6 = t15.rings;
    else if (s(t15)) _6 = t15.paths;
    else {
      if (!m(t15)) return l2(t15) ? void console.log("CanvasDrawHelper.drawPictureStroke - No implementation!") : void 0;
      _6 = lt(t15).rings;
    }
    c5 || (c5 = m7.width);
    const g5 = G3(h8) || "src" in m7 && G3(m7.src);
    let y6 = "getFrame" in m7 ? t12(m7) : m7;
    s13 && (y6 = this._colorSubstitutionHelper.applyColorSubstitution(y6, s13)), this._applyAdditionalRenderProps && (g5 || l12 && (y6 = this._colorSubstitutionHelper.tintImageData(y6, l12)));
    const P5 = Math.max(this.transformSize(u3(c5)), 0.5), w5 = P5 / y6.width, x4 = this._ctx, S3 = x4.createPattern(y6, "repeat-y");
    let M4, k2;
    x4.save(), this._setCapStyle(i16), this._setJoinStyle(n18), void 0 !== a12 && (x4.miterLimit = a12), x4.lineWidth = P5;
    for (let o8 of _6) if (o8 = a(o8), ft(o8), o8 && !(o8.length <= 1)) {
      M4 = this.transformPt(o8[0]);
      for (let t16 = 1; t16 < o8.length; t16++) {
        k2 = this.transformPt(o8[t16]);
        const e13 = at(M4, k2), r19 = new DOMMatrix();
        r19.translateSelf(0, M4[1] - P5 / 2).scaleSelf(w5, w5, 1).rotateSelf(0, 0, 90 - e13), S3.setTransform(r19), x4.strokeStyle = S3, x4.beginPath(), x4.moveTo(M4[0], M4[1]), x4.lineTo(k2[0], k2[1]), x4.stroke(), M4 = k2;
      }
    }
    x4.restore();
  }
  _buildPath(t15, e13) {
    const r18 = this._ctx;
    if (r18.beginPath(), t15) for (const s13 of t15) {
      const t16 = s13 ? s13.length : 0;
      if (t16 > 1) {
        let i16 = this.transformPt(s13[0]);
        r18.moveTo(i16[0], i16[1]);
        for (let e14 = 1; e14 < t16; e14++) i16 = this.transformPt(s13[e14]), r18.lineTo(i16[0], i16[1]);
        e13 && r18.closePath();
      }
    }
  }
  _setCapStyle(t15) {
    switch (t15) {
      case U.Butt:
        this._ctx.lineCap = "butt";
        break;
      case U.Round:
        this._ctx.lineCap = "round";
        break;
      case U.Square:
        this._ctx.lineCap = "square";
    }
  }
  _setJoinStyle(t15) {
    switch (t15) {
      case w.Bevel:
        this._ctx.lineJoin = "bevel";
        break;
      case w.Round:
        this._ctx.lineJoin = "round";
        break;
      case w.Miter:
        this._ctx.lineJoin = "miter";
    }
  }
};
function it(t15, e13, r18) {
  let s13 = p(t15.separation, i3.CIMHatchFill.separation) * r18, i16 = p(t15.rotation);
  if (0 === s13) return null;
  s13 < 0 && (s13 = -s13);
  let o8 = 0;
  const n18 = 0.5 * s13;
  for (; o8 > n18; ) o8 -= s13;
  for (; o8 < -n18; ) o8 += s13;
  const a12 = u();
  a3(a12, e13), a12[0] -= n18, a12[1] -= n18, a12[2] += n18, a12[3] += n18;
  const c5 = [[a12[0], a12[1]], [a12[0], a12[3]], [a12[2], a12[3]], [a12[2], a12[1]]];
  for (; i16 > 180; ) i16 -= 180;
  for (; i16 < 0; ) i16 += 180;
  const m7 = Math.cos(i16 * K2), f7 = Math.sin(i16 * K2), u13 = -s13 * f7, d4 = s13 * m7;
  let p7, _6, g5, y6;
  o8 = p(t15.offsetX) * r18 * f7 - p(t15.offsetY) * r18 * m7, p7 = g5 = Number.MAX_VALUE, _6 = y6 = -Number.MAX_VALUE;
  for (const l12 of c5) {
    const t16 = l12[0], e14 = l12[1], r19 = m7 * t16 + f7 * e14, s14 = -f7 * t16 + m7 * e14;
    p7 = Math.min(p7, r19), g5 = Math.min(g5, s14), _6 = Math.max(_6, r19), y6 = Math.max(y6, s14);
  }
  g5 = Math.floor(g5 / s13) * s13;
  let P5 = m7 * p7 - f7 * g5 - u13 * o8 / s13, w5 = f7 * p7 + m7 * g5 - d4 * o8 / s13, S3 = m7 * _6 - f7 * g5 - u13 * o8 / s13, M4 = f7 * _6 + m7 * g5 - d4 * o8 / s13;
  const b4 = 1 + Math.round((y6 - g5) / s13), k2 = [];
  for (let l12 = 0; l12 < b4; l12++) P5 += u13, w5 += d4, S3 += u13, M4 += d4, k2.push([[P5, w5], [S3, M4]]);
  return { paths: k2 };
}
function ot(t15, e13) {
  let r18 = 0;
  for (const s13 of e13) {
    const e14 = s13.length;
    for (let i16 = 1; i16 < e14; i16++) {
      const e15 = s13[i16 - 1], o8 = s13[i16];
      if (e15[1] > t15[1] == o8[1] > t15[1]) continue;
      (o8[0] - e15[0]) * (t15[1] - e15[1]) - (o8[1] - e15[1]) * (t15[0] - e15[0]) > 0 ? r18++ : r18--;
    }
  }
  return 0 !== r18;
}
function nt(t15, e13, r18) {
  for (const s13 of e13) {
    const e14 = s13.length;
    for (let i16 = 1; i16 < e14; i16++) {
      const e15 = s13[i16 - 1], o8 = s13[i16];
      let n18 = (o8[0] - e15[0]) * (o8[0] - e15[0]) + (o8[1] - e15[1]) * (o8[1] - e15[1]);
      if (0 === n18) continue;
      n18 = Math.sqrt(n18);
      const a12 = ((o8[0] - e15[0]) * (t15[1] - e15[1]) - (o8[1] - e15[1]) * (t15[0] - e15[0])) / n18;
      if (Math.abs(a12) < r18) {
        const s14 = ((o8[0] - e15[0]) * (t15[0] - e15[0]) + (o8[1] - e15[1]) * (t15[1] - e15[1])) / n18;
        if (s14 > -r18 && s14 < n18 + r18) return true;
      }
    }
  }
  return false;
}
function at(t15, e13) {
  const r18 = e13[0] - t15[0], s13 = e13[1] - t15[1];
  return 180 / Math.PI * Math.atan2(s13, r18);
}
var lt = (t15) => t15 ? { spatialReference: t15.spatialReference, rings: [[[t15.xmin, t15.ymin], [t15.xmin, t15.ymax], [t15.xmax, t15.ymax], [t15.xmax, t15.ymin], [t15.xmin, t15.ymin]]] } : null;
var ht = (t15, e13, r18) => {
  switch (t15) {
    case "ExtraLeading":
      return 1 + e13 / r18;
    case "Multiple":
      return e13;
    case "Exact":
      return e13 / r18;
  }
};
function ct(e13, r18 = 1) {
  var _a;
  const s13 = L(e13), i16 = w2(e13.fontStyleName), o8 = e13.fontFamilyName ?? t3, { weight: n18, style: a12 } = i16, l12 = r18 * (e13.height || 5), h8 = x(e13.horizontalAlignment), c5 = F(e13.verticalAlignment), m7 = T2(e13), f7 = T2(e13.haloSymbol), u13 = null != f7 ? r18 * (e13.haloSize ?? 0) : 0, d4 = A2(e13.symbol), p7 = r18 * (N2(e13.symbol) || 0), _6 = "CIMBackgroundCallout" === ((_a = e13.callout) == null ? void 0 : _a.type) ? e13.callout.backgroundSymbol : null, g5 = T2(_6), y6 = N2(_6), P5 = A2(_6);
  return { color: m7, size: l12, horizontalAlignment: h8, verticalAlignment: c5, font: { family: o8, style: g2(a12), weight: P2(n18), decoration: s13 }, outline: { size: p7 || 0, color: d4 }, halo: { size: u13 || 0, color: f7, style: a12 }, backgroundColor: g5, borderLine: null != y6 && null != P5 ? { size: y6, color: P5 } : null, pixelRatio: 1, premultiplyColors: true };
}
var mt = 1e-4;
function ft(t15) {
  let e13, r18, s13, i16, o8, n18 = t15[0], a12 = 1;
  for (; a12 < t15.length; ) e13 = t15[a12][0] - n18[0], r18 = t15[a12][1] - n18[1], i16 = 0 !== e13 ? r18 / e13 : Math.PI / 2, void 0 !== s13 && i16 - s13 <= mt ? (t15.splice(a12 - 1, 1), n18 = o8) : (o8 = n18, n18 = t15[a12], a12++), s13 = i16;
}

// node_modules/@arcgis/core/symbols/cim/CIMSymbolHelper.js
var N4 = Math.PI;
var Y3 = N4 / 2;
var _5 = Math.PI / 180;
var U2 = 96 / 72;
var q = 1.4142135623730951;
var H2 = 4;
var O2 = () => n.getLogger("esri.symbols.cim.CIMSymbolHelper");
function W(e13) {
  let t15;
  switch (e13.type) {
    case "cim":
      return e13.data;
    case "web-style":
      return e13;
    case "simple-marker": {
      const r18 = ee.fromSimpleMarker(e13);
      if (!r18) throw new Error("InternalError: Cannot convert symbol to CIM");
      t15 = r18;
      break;
    }
    case "picture-marker":
      t15 = ee.fromPictureMarker(e13);
      break;
    case "simple-line":
      t15 = ee.fromSimpleLineSymbol(e13);
      break;
    case "simple-fill":
      t15 = ee.fromSimpleFillSymbol(e13);
      break;
    case "picture-fill":
      t15 = ee.fromPictureFillSymbol(e13);
      break;
    case "text":
      t15 = ee.fromTextSymbol(e13);
  }
  return { type: "CIMSymbolReference", symbol: t15 };
}
function $2(e13, t15, r18) {
  switch (t15.type) {
    case "CIMSymbolReference":
      return $2(e13, t15.symbol, r18);
    case "CIMPointSymbol":
      null == r18 && (r18 = { x: 0, y: 0 }), e13.drawSymbol(t15, r18);
      break;
    case "CIMLineSymbol":
      null == r18 && (r18 = { paths: [[[0, 0], [10, 0]]] }), e13.drawSymbol(t15, r18);
      break;
    case "CIMPolygonSymbol":
      null == r18 && (r18 = { rings: [[[0, 0], [0, 10], [10, 10], [10, 0], [0, 0]]] }), e13.drawSymbol(t15, r18);
      break;
    case "CIMTextSymbol": {
      const r19 = { x: 0, y: 0 };
      e13.drawSymbol(t15, r19);
      break;
    }
    case "CIMVectorMarker": {
      const r19 = new t6();
      e13.drawMarker(t15, r19);
      break;
    }
  }
  return e13.envelope();
}
function J(e13) {
  if (!e13) return 0;
  switch (e13.type) {
    case "CIMMarkerPlacementAlongLineSameSize":
    case "CIMMarkerPlacementAlongLineRandomSize":
    case "CIMMarkerPlacementAtExtremities":
    case "CIMMarkerPlacementAtMeasuredUnits":
    case "CIMMarkerPlacementAtRatioPositions":
    case "CIMMarkerPlacementOnLine":
    case "CIMMarkerPlacementOnVertices":
      return Math.abs(e13.offset);
    default:
      return 0;
  }
}
function K3(e13) {
  if (!e13) return 0;
  switch (e13.type) {
    case "CIMGeometricEffectArrow":
      return Math.abs(0.5 * e13.width);
    case "CIMGeometricEffectBuffer":
      return Math.abs(e13.size);
    case "CIMGeometricEffectControlMeasureLine":
      return 500;
    case "CIMGeometricEffectExtension":
    case "CIMGeometricEffectRadial":
      return Math.abs(e13.length);
    case "CIMGeometricEffectJog":
      return Math.abs(0.5 * e13.length);
    case "CIMGeometricEffectMove":
      return Math.max(Math.abs(p(e13.offsetX)), Math.abs(p(e13.offsetY)));
    case "CIMGeometricEffectOffset":
    case "CIMGeometricEffectOffsetTangent":
      return Math.abs(e13.offset);
    case "CIMGeometricEffectRegularPolygon":
      return Math.abs(e13.radius);
    case "CIMGeometricEffectRotate":
    case "CIMGeometricEffectScale":
    default:
      return 0;
    case "CIMGeometricEffectTaperedPolygon":
      return 0.5 * Math.max(Math.abs(e13.fromWidth), Math.abs(e13.toWidth));
    case "CIMGeometricEffectWave":
      return Math.abs(e13.amplitude);
    case "CIMGeometricEffectDonut":
      return Math.abs(e13.width);
  }
}
function Q3(e13) {
  if (!e13) return 0;
  let t15 = 0;
  for (const r18 of e13) t15 += K3(r18);
  return t15;
}
var Z3 = class {
  static getSymbolInflateSize(e13, t15, r18, o8, a12) {
    return e13 || (e13 = [0, 0, 0, 0]), t15 ? this._getInflateSize(e13, t15, r18, o8, a12) : e13;
  }
  static safeSize(e13) {
    const t15 = Math.max(Math.abs(e13[0]), Math.abs(e13[2])), r18 = Math.max(Math.abs(e13[1]), Math.abs(e13[3]));
    return Math.sqrt(t15 * t15 + r18 * r18);
  }
  static _vectorMarkerBounds(e13, t15, r18, o8) {
    let a12 = true;
    const i16 = u();
    if (t15 == null ? void 0 : t15.markerGraphics) for (const s13 of t15.markerGraphics) {
      const t16 = [0, 0, 0, 0];
      s13.geometry && (a3(i16, s13.geometry), t16[0] = 0, t16[1] = 0, t16[2] = 0, t16[3] = 0, this.getSymbolInflateSize(t16, s13.symbol, r18, 0, o8), i16[0] += t16[0], i16[1] += t16[1], i16[2] += t16[2], i16[3] += t16[3], a12 ? (e13[0] = i16[0], e13[1] = i16[1], e13[2] = i16[2], e13[3] = i16[3], a12 = false) : (e13[0] = Math.min(e13[0], i16[0]), e13[1] = Math.min(e13[1], i16[1]), e13[2] = Math.max(e13[2], i16[2]), e13[3] = Math.max(e13[3], i16[3])));
    }
    return e13;
  }
  static _getInflateSize(e13, t15, r18, o8, a12) {
    if (fe(t15)) {
      const s13 = this._getLayersInflateSize(e13, t15.symbolLayers, r18, o8, a12), i16 = Q3(t15.effects);
      return i16 > 0 && (s13[0] -= i16, s13[1] -= i16, s13[2] += i16, s13[3] += i16), s13;
    }
    return this._getTextInflatedSize(e13, t15, a12);
  }
  static _getLayersInflateSize(e13, t15, r18, o8, a12) {
    let n18 = true;
    if (!t15) return e13;
    for (const l12 of t15) {
      if (!l12) continue;
      let t16 = [0, 0, 0, 0];
      switch (l12.type) {
        case "CIMSolidFill":
        case "CIMPictureFill":
        case "CIMHatchFill":
        case "CIMGradientFill":
          break;
        case "CIMSolidStroke":
        case "CIMPictureStroke":
        case "CIMGradientStroke": {
          const e14 = l12;
          let r19 = e14.width;
          null != r19 && (e14.capStyle === U.Square || e14.joinStyle === w.Miter ? r19 /= q : r19 /= 2, t16[0] = -r19, t16[1] = -r19, t16[2] = r19, t16[3] = r19);
          break;
        }
        case "CIMCharacterMarker":
        case "CIMVectorMarker":
        case "CIMPictureMarker": {
          const e14 = l12;
          if ("CIMVectorMarker" === l12.type) {
            const e15 = l12;
            if (t16 = this._vectorMarkerBounds(t16, e15, r18, a12), e15.frame) {
              const r19 = (e15.frame.xmin + e15.frame.xmax) / 2, o9 = (e15.frame.ymin + e15.frame.ymax) / 2;
              if (t16[0] -= r19, t16[1] -= o9, t16[2] -= r19, t16[3] -= o9, null != e15.size) {
                const r20 = e15.size / (e15.frame.ymax - e15.frame.ymin);
                t16[0] *= r20, t16[1] *= r20, t16[2] *= r20, t16[3] *= r20;
              }
            }
          } else if ("CIMPictureMarker" === l12.type) {
            const o9 = l12, a13 = r18.getResource(o9.url);
            let s13 = 1;
            if (null != a13 && a13.height && (s13 = a13.width / a13.height), null != e14.size) {
              const r19 = e14.size / 2, a14 = e14.size * s13 * o9.scaleX / 2;
              t16 = [-a14, -r19, a14, r19];
            }
          } else if (null != e14.size) {
            const r19 = e14.size / 2;
            t16 = [-r19, -r19, r19, r19];
          }
          if (e14.anchorPoint) {
            let r19, o9;
            "Absolute" === e14.anchorPointUnits ? (r19 = e14.anchorPoint.x, o9 = e14.anchorPoint.y) : (r19 = e14.anchorPoint.x * (t16[2] - t16[0]), o9 = e14.anchorPoint.y * (t16[3] - t16[1]));
            const a13 = 1.25 * Math.sqrt(r19 * r19 + o9 * o9);
            t16[0] -= a13, t16[1] -= a13, t16[2] += a13, t16[3] += a13;
          }
          let n19 = p(e14.rotation);
          if (e14.rotateClockwise && (n19 = -n19), o8 && (n19 -= o8), n19) {
            const e15 = _5 * n19, r19 = Math.cos(e15), o9 = Math.sin(e15), a13 = u([r2, r2, -r2, -r2]);
            f3(a13, [t16[0] * r19 - t16[1] * o9, t16[0] * o9 + t16[1] * r19]), f3(a13, [t16[0] * r19 - t16[3] * o9, t16[0] * o9 + t16[3] * r19]), f3(a13, [t16[2] * r19 - t16[1] * o9, t16[2] * o9 + t16[1] * r19]), f3(a13, [t16[2] * r19 - t16[3] * o9, t16[2] * o9 + t16[3] * r19]), t16 = a13;
          }
          let c6 = p(e14.offsetX), m7 = p(e14.offsetY);
          if (o8) {
            const e15 = _5 * o8, t17 = Math.cos(e15), r19 = Math.sin(e15), a13 = c6 * r19 + m7 * t17;
            c6 = c6 * t17 - m7 * r19, m7 = a13;
          }
          t16[0] += c6, t16[1] += m7, t16[2] += c6, t16[3] += m7;
          const f7 = J(e14.markerPlacement);
          f7 > 0 && (t16[0] -= f7, t16[1] -= f7, t16[2] += f7, t16[3] += f7);
          break;
        }
      }
      const c5 = Q3(l12.effects);
      c5 > 0 && (t16[0] -= c5, t16[1] -= c5, t16[2] += c5, t16[3] += c5), n18 ? (e13[0] = t16[0], e13[1] = t16[1], e13[2] = t16[2], e13[3] = t16[3], n18 = false) : (e13[0] = Math.min(e13[0], t16[0]), e13[1] = Math.min(e13[1], t16[1]), e13[2] = Math.max(e13[2], t16[2]), e13[3] = Math.max(e13[3], t16[3]));
    }
    return e13;
  }
  static _getTextInflatedSize(e13, t15, r18) {
    var _a;
    const o8 = p6(t15.height ?? i3.CIMTextSymbol.height);
    if (e13[0] = -o8 / 2, e13[1] = -o8 / 2, e13[2] = o8 / 2, e13[3] = o8 / 2, !r18) return e13;
    const a12 = r18.get(t15);
    if (!a12) return e13;
    if (!a12.glyphMosaicItems.glyphs.length) return e13;
    const { lineGapType: s13, lineGap: i16 } = t15, n18 = s13 ? ht(s13, i16 ?? 0, o8) : 0, l12 = "CIMBackgroundCallout" === ((_a = t15.callout) == null ? void 0 : _a.type), c5 = O(a12.glyphMosaicItems, { scale: o8 / A, angle: p(t15.angle), xOffset: p(t15.offsetX), yOffset: p(t15.offsetY), horizontalAlignment: t15.horizontalAlignment, verticalAlignment: t15.verticalAlignment, maxLineWidth: g4(t15.lineWidth), lineHeight: G2 * Math.max(0.25, Math.min(n18 || 1, 4)), decoration: t15.font.decoration || "none", useCIMAngleBehavior: true, hasBackground: l12 }).boundsT, m7 = Math.sqrt(c5.width * c5.width + c5.height * c5.height);
    return e13[0] -= c5.x + m7, e13[1] -= c5.y - m7, e13[2] += c5.x + m7, e13[3] += -c5.y + m7, e13;
  }
};
var ee = class _ee {
  static getEnvelope(e13, t15, r18) {
    if (!e13) return null;
    const o8 = new et(r18);
    if (Array.isArray(e13)) {
      let r19;
      for (const a12 of e13) r19 ? r19.union($2(o8, a12, t15)) : r19 = $2(o8, a12, t15);
      return r19;
    }
    return $2(o8, e13, t15);
  }
  static getTextureAnchor(e13, t15) {
    const r18 = this.getEnvelope(e13, null, t15);
    if (!r18) return [0, 0, 0];
    const o8 = (r18.x + 0.5 * r18.width) * U2, a12 = (r18.y + 0.5 * r18.height) * U2, s13 = r18.width * U2 + 2, i16 = r18.height * U2 + 2;
    return [-o8 / s13, -a12 / i16, i16];
  }
  static rasterize(e13, t15, r18, o8, a12 = true, s13) {
    const i16 = r18 || this.getEnvelope(t15, null, o8);
    if (!i16) return [null, 0, 0, 0, 0];
    const n18 = Math.max(i16.width, i16.height) * U2;
    let l12 = null != s13 ? Math.max(s13 / n18, 1) : 1;
    l12 *= U2;
    const m7 = (i16.x + 0.5 * i16.width) * l12, h8 = (i16.y + 0.5 * i16.height) * l12;
    e13.width = i16.width * l12, e13.height = i16.height * l12, r18 || (e13.width += 2, e13.height += 2);
    const u13 = e13.getContext("2d", { willReadFrequently: true }), p7 = $.createScale(l12, -l12);
    p7.translate(0.5 * e13.width - m7, 0.5 * e13.height + h8);
    const M4 = new st(u13, o8, p7);
    switch (t15.type) {
      case "CIMPointSymbol": {
        const e14 = { type: "point", x: 0, y: 0 };
        M4.drawSymbol(t15, e14);
        break;
      }
      case "CIMVectorMarker": {
        const e14 = new t6();
        M4.drawMarker(t15, e14);
        break;
      }
    }
    const S3 = u13.getImageData(0, 0, e13.width, e13.height), d4 = new Uint8Array(S3.data);
    if (a12) {
      let e14;
      for (let t16 = 0; t16 < d4.length; t16 += 4) e14 = d4[t16 + 3] / 255, d4[t16] = d4[t16] * e14, d4[t16 + 1] = d4[t16 + 1] * e14, d4[t16 + 2] = d4[t16 + 2] * e14;
    }
    return [d4, e13.width, e13.height, -m7 / e13.width, -h8 / e13.height];
  }
  static fromTextSymbol(e13) {
    const { text: t15 } = e13;
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, anchorPointUnits: "Relative", dominantSizeAxis3D: "Y", size: 10, billboardMode3D: "FaceNearPlane", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: _ee.createCIMTextSymbolfromTextSymbol(e13), textString: t15 }], scaleSymbolsProportionally: true, respectFrame: true }], scaleX: 1, angleAlignment: "Display" };
  }
  static fromPictureFillSymbol(e13) {
    const { height: t15, outline: r18, width: o8, xoffset: a12, xscale: s13, yoffset: i16, yscale: n18 } = e13, l12 = [], c5 = { type: "CIMPolygonSymbol", symbolLayers: l12 };
    if (r18) {
      const e14 = pe(r18);
      e14 && l12.push(e14);
    }
    let m7 = e13.url;
    "esriPFS" === e13.type && e13.imageData && (m7 = e13.imageData);
    const f7 = "angle" in e13 ? e13.angle ?? 0 : 0, y6 = (o8 ?? 0) * (s13 || 1), h8 = (t15 ?? 0) * (n18 || 1);
    return l12.push({ type: "CIMPictureFill", invertBackfaceTexture: false, scaleX: 1, textureFilter: te.Picture, tintColor: null, url: m7, height: h8, width: y6, offsetX: p(a12), offsetY: p(i16), rotation: p(-f7), colorSubstitutions: null }), c5;
  }
  static fromSimpleFillSymbol(e13) {
    const { color: r18, style: o8, outline: s13 } = e13, i16 = [], n18 = { type: "CIMPolygonSymbol", symbolLayers: i16 };
    if (s13) {
      const e14 = pe(s13);
      e14 && i16.push(e14);
    }
    if (o8 && "solid" !== o8 && "none" !== o8 && "esriSFSSolid" !== o8 && "esriSFSNull" !== o8) {
      const e14 = { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", color: ie2(r18), capStyle: U.Butt, joinStyle: w.Miter, width: 0.75 }] };
      let s14 = 0;
      const n19 = e2(he(o8) ? 8 : 10);
      switch (o8) {
        case "vertical":
        case "esriSFSVertical":
          s14 = 90;
          break;
        case "forward-diagonal":
        case "esriSFSForwardDiagonal":
        case "diagonal-cross":
        case "esriSFSDiagonalCross":
          s14 = -45;
          break;
        case "backward-diagonal":
        case "esriSFSBackwardDiagonal":
          s14 = 45;
          break;
        case "cross":
        case "esriSFSCross":
          s14 = 0;
      }
      i16.push({ type: "CIMHatchFill", lineSymbol: e14, offsetX: 0, offsetY: 0, rotation: s14, separation: n19 }), "cross" === o8 || "esriSFSCross" === o8 ? i16.push({ type: "CIMHatchFill", lineSymbol: a(e14), offsetX: 0, offsetY: 0, rotation: 90, separation: n19 }) : "diagonal-cross" !== o8 && "esriSFSDiagonalCross" !== o8 || i16.push({ type: "CIMHatchFill", lineSymbol: a(e14), offsetX: 0, offsetY: 0, rotation: 45, separation: n19 });
    } else !o8 || "solid" !== o8 && "esriSFSSolid" !== o8 || i16.push({ type: "CIMSolidFill", enable: true, color: ie2(r18) });
    return n18;
  }
  static fromSimpleLineSymbol(e13) {
    const { cap: t15, color: r18, join: o8, marker: a12, miterLimit: s13, style: i16, width: n18 } = e13;
    let l12 = null;
    "solid" !== i16 && "none" !== i16 && "esriSLSSolid" !== i16 && "esriSLSNull" !== i16 && (l12 = [{ type: "CIMGeometricEffectDashes", dashTemplate: me(i16, t15), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]);
    const c5 = [];
    if (a12) {
      let e14;
      switch (a12.placement) {
        case "begin-end":
          e14 = r.Both;
          break;
        case "begin":
          e14 = r.JustBegin;
          break;
        case "end":
          e14 = r.JustEnd;
          break;
        default:
          e14 = r.None;
      }
      const t16 = _ee.fromSimpleMarker(a12, n18, r18).symbolLayers[0];
      t16.markerPlacement = { type: "CIMMarkerPlacementAtExtremities", placePerPart: false, angleToLine: true, offset: 0, extremityPlacement: e14, offsetAlongLine: 0 }, c5.push(t16);
    }
    return c5.push({ type: "CIMSolidStroke", color: "none" !== i16 && "esriSLSNull" !== i16 ? ie2(r18) : [0, 0, 0, 0], capStyle: re(t15), joinStyle: oe2(o8), miterLimit: s13, width: n18, effects: l12 }), { type: "CIMLineSymbol", symbolLayers: c5 };
  }
  static fromPictureMarker(e13) {
    const { angle: t15, height: r18, width: o8, xoffset: a12, yoffset: s13 } = e13;
    let i16 = e13.url;
    return "esriPMS" === e13.type && e13.imageData && (i16 = e13.imageData), { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: te.Picture, tintColor: null, url: i16, size: r18, width: o8, offsetX: p(a12), offsetY: p(s13), rotation: p(-t15) }] };
  }
  static createCIMTextSymbolfromTextSymbol(t15) {
    const { angle: r18, color: o8, font: a12, haloColor: s13, haloSize: i16, horizontalAlignment: n18, kerning: l12, lineWidth: c5, text: m7, verticalAlignment: f7, xoffset: y6, yoffset: h8, backgroundColor: u13, borderLineColor: p7, borderLineSize: M4 } = t15;
    let S3, d4, L3, z2, D, E2;
    a12 && (S3 = a12.family, d4 = a12.style, L3 = a12.weight, z2 = a12.size, D = a12.decoration);
    let G4 = false;
    if (m7) {
      G4 = i14(m7)[1];
    }
    return (u13 || M4) && (E2 = { type: "CIMBackgroundCallout", margin: null, backgroundSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", color: ie2(u13) }, { type: "CIMSolidStroke", color: ie2(p7), width: M4 }] }, accentBarSymbol: null, gap: null, leaderLineSymbol: null, lineStyle: null }), { type: "CIMTextSymbol", angle: r18, blockProgression: T.BTT, depth3D: 1, extrapolateBaselines: true, fontEffects: l3.Normal, fontEncoding: a4.Unicode, fontFamilyName: S3 || "Arial", fontStyleName: ne(d4, L3), fontType: u4.Unspecified, haloSize: i16, height: z2, hinting: y2.Default, horizontalAlignment: ae(n18 ?? "center"), kerning: l12, letterWidth: 100, ligatures: true, lineGapType: "Multiple", lineWidth: c5, offsetX: p(y6), offsetY: p(h8), strikethrough: "line-through" === D, underline: "underline" === D, symbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ie2(o8) }] }, haloSymbol: { type: "CIMPolygonSymbol", symbolLayers: [{ type: "CIMSolidFill", enable: true, color: ie2(s13) }] }, shadowColor: [0, 0, 0, 255], shadowOffsetX: 1, shadowOffsetY: 1, textCase: "Normal", textDirection: G4 ? ie.RTL : ie.LTR, verticalAlignment: se(f7 ?? "baseline"), verticalGlyphOrientation: oe.Right, wordSpacing: 100, billboardMode3D: m2.FaceNearPlane, callout: E2 };
  }
  static createPictureMarkerRasterizationParam(e13) {
    var _a, _b;
    const { angle: t15, height: r18, width: o8, xoffset: a12, yoffset: s13 } = e13, i16 = e13.url ?? ((_a = e13.source) == null ? void 0 : _a.url) ?? ((_b = e13.source) == null ? void 0 : _b.imageData);
    return i16 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureMarker", invertBackfaceTexture: false, scaleX: 1, textureFilter: te.Picture, tintColor: null, url: i16, size: r18, width: o8, offsetX: p(a12), offsetY: p(s13), rotation: p(-t15) } } : null;
  }
  static createPictureFillRasterizationParam(e13) {
    const { width: t15, height: r18, xoffset: o8, yoffset: a12, url: s13 } = e13;
    return s13 ? { type: "sprite-rasterization-param", overrides: [], resource: { type: "CIMPictureFill", scaleX: 1, textureFilter: te.Picture, tintColor: null, url: s13, width: t15, height: r18, offsetX: p(o8), offsetY: p(a12), rotation: 0 } } : null;
  }
  static fromSimpleMarker(e13, t15, r18) {
    const { style: o8 } = e13, a12 = e13.color ?? r18;
    if ("path" === o8 || "esriSMSPath" === o8) {
      const t16 = [];
      if ("outline" in e13 && e13.outline) {
        const r20 = e13.outline;
        t16.push({ type: "CIMSolidStroke", enable: true, width: r20.width, color: ie2(r20.color), path: e13.path });
      }
      t16.push({ type: "CIMSolidFill", enable: true, color: ie2(a12), path: e13.path });
      const [r19, o9] = ye("square");
      return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: -p(e13.angle), size: p(e13.size || 6), offsetX: p(e13.xoffset), offsetY: p(e13.yoffset), scaleSymbolsProportionally: false, frame: r19, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: o9, symbol: { type: "CIMPolygonSymbol", symbolLayers: t16 } }] }] };
    }
    const s13 = [];
    let i16, n18, l12 = e13.size;
    if ("outline" in e13 && e13.outline && "none" !== e13.outline.style && "esriSLSNull" !== e13.outline.style) {
      const t16 = e13.outline, r19 = "solid" !== t16.style && "esriSLSSolid" !== t16.style;
      [i16, n18] = r19 ? ye(o8, e13.size) : ye(o8);
      const a13 = t16.width ?? u5.width;
      if (r19) {
        const t17 = a13 / e13.size, r20 = (i16.xmax - i16.xmin) * t17 / 2, o9 = (i16.ymax - i16.ymin) * t17 / 2;
        i16.xmin -= r20, i16.xmax += r20, i16.ymin -= o9, i16.ymax += o9, l12 && (l12 += a13);
      }
      const c6 = "cross" !== e13.style && "x" !== e13.style || "dot" === (e13 == null ? void 0 : e13.outline.style) || "short-dot" === (e13 == null ? void 0 : e13.outline.style) ? b.HalfGap : b.FullPattern, m7 = r19 ? [{ type: "CIMGeometricEffectAddControlPoints" }, { type: "CIMGeometricEffectDashes", dashTemplate: me(t16.style, null).map((e14) => t16.width && t16.width > 0 ? e14 * t16.width : e14), lineDashEnding: c6, controlPointEnding: b.FullPattern }] : void 0;
      s13.push({ type: "CIMSolidStroke", capStyle: r19 ? U.Round : U.Butt, enable: true, width: a13, color: ie2(t16.color), effects: m7 });
    } else !t15 || "line-marker" !== e13.type || "cross" !== e13.style && "x" !== e13.style ? [i16, n18] = ye(o8) : ([i16, n18] = ye(o8), s13.push({ type: "CIMSolidStroke", enable: true, width: t15, color: ie2(a12) }));
    s13.push({ type: "CIMSolidFill", enable: true, color: ie2(a12) });
    const c5 = { type: "CIMPolygonSymbol", symbolLayers: s13 };
    return { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, rotation: p(-e13.angle), size: p(l12 || 6 * t15), offsetX: p(e13.xoffset), offsetY: p(e13.yoffset), scaleSymbolsProportionally: false, frame: i16, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: n18, symbol: c5 }] }] };
  }
  static fromCIMHatchFill(e13, r18) {
    var _a;
    const o8 = r18 * (e13.separation ?? i3.CIMHatchFill.separation), a12 = o8 / 2, s13 = a(e13.lineSymbol);
    (_a = s13.symbolLayers) == null ? void 0 : _a.forEach((e14) => {
      var _a2;
      switch (e14.type) {
        case "CIMSolidStroke":
          null != e14.width && (e14.width *= r18), (_a2 = e14.effects) == null ? void 0 : _a2.forEach((e15) => {
            if ("CIMGeometricEffectDashes" === e15.type) {
              const t15 = e15.dashTemplate;
              e15.dashTemplate = t15 == null ? void 0 : t15.map((e16) => e16 * r18);
            }
          });
          break;
        case "CIMVectorMarker": {
          null != e14.size && (e14.size *= r18);
          const t15 = e14.markerPlacement;
          null != t15 && "placementTemplate" in t15 && (t15.placementTemplate = t15.placementTemplate.map((e15) => e15 * r18));
          break;
        }
      }
    });
    let i16 = this._getLineSymbolPeriod(s13) || H2;
    for (; i16 < H2; ) i16 *= 2;
    const n18 = i16 / 2;
    return { type: "CIMVectorMarker", frame: { xmin: -n18, xmax: n18, ymin: -a12, ymax: a12 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { paths: [[[-n18, 0], [n18, 0]]] }, symbol: s13 }], size: o8 };
  }
  static fetchResources(e13, t15, r18, o8 = null) {
    return e13 && t15 ? (te2(e13, (e14) => {
      ue(e14, t15, r18), "url" in e14 && e14.url && r18.push(t15.fetchResource(e14.url, { signal: o8 }));
    }), r18) : r18;
  }
  static fetchFonts(e13, t15, r18) {
    if (e13 && t15) {
      if ("symbolLayers" in e13 && e13.symbolLayers) {
        for (const o8 of e13.symbolLayers) if ("CIMVectorMarker" === o8.type && o8.markerGraphics) for (const e14 of o8.markerGraphics) (e14 == null ? void 0 : e14.symbol) && _ee.fetchFonts(e14.symbol, t15, r18);
      } else if ("CIMTextSymbol" === e13.type) {
        const { fontFamilyName: o8, fontStyleName: a12 } = e13;
        if (!o8 || "calcitewebcoreicons" === o8.toLowerCase()) return;
        const { style: s13, weight: i16 } = w2(a12), n18 = L(e13), c5 = new m3({ family: o8, style: s13, weight: i16, decoration: n18 });
        r18.push(t15.loadFont(c5).catch(() => {
          O2().error(`Unsupported font ${o8} in CIM symbol`);
        }));
      }
    }
  }
  static _getLineSymbolPeriod(e13) {
    if (e13) {
      const t15 = this._getEffectsRepeat(e13.effects);
      if (t15) return t15;
      if (e13.symbolLayers) {
        for (const r18 of e13.symbolLayers) if (r18) {
          const e14 = this._getEffectsRepeat(r18.effects);
          if (e14) return e14;
          switch (r18.type) {
            case "CIMCharacterMarker":
            case "CIMPictureMarker":
            case "CIMVectorMarker":
            case "CIMObjectMarker3D":
            case "CIMglTFMarker3D": {
              const e15 = this._getPlacementRepeat(r18.markerPlacement);
              if (e15) return e15;
            }
          }
        }
      }
    }
    return 0;
  }
  static _getEffectsRepeat(e13) {
    if (e13) {
      for (const t15 of e13) if (t15) switch (t15.type) {
        case "CIMGeometricEffectDashes": {
          const e14 = t15.dashTemplate;
          if (e14 && e14.length) {
            let t16 = 0;
            for (const r18 of e14) t16 += r18;
            return 1 & e14.length && (t16 *= 2), t16;
          }
          break;
        }
        case "CIMGeometricEffectWave":
          return t15.period;
        default:
          O2().error(`unsupported geometric effect type ${t15.type}`);
      }
    }
    return 0;
  }
  static _getPlacementRepeat(e13) {
    if (e13) switch (e13.type) {
      case "CIMMarkerPlacementAlongLineSameSize":
      case "CIMMarkerPlacementAlongLineRandomSize":
      case "CIMMarkerPlacementAlongLineVariableSize": {
        const t15 = e13.placementTemplate;
        if (t15 && t15.length) {
          let e14 = 0;
          for (const r18 of t15) e14 += +r18;
          return 1 & t15.length && (e14 *= 2), e14;
        }
        break;
      }
    }
    return 0;
  }
  static fromCIMInsidePolygon(e13) {
    const t15 = e13.markerPlacement, r18 = { ...e13 };
    r18.markerPlacement = null, r18.anchorPoint = null;
    const s13 = Math.abs(t15.stepX), i16 = Math.abs(t15.stepY), n18 = (t15.randomness ?? 100) / 100;
    let l12, c5, m7, f7;
    if ("Random" === t15.gridType) {
      const e14 = e2(si), r19 = Math.max(Math.floor(e14 / s13), 1), y6 = Math.max(Math.floor(e14 / i16), 1);
      l12 = r19 * s13 / 2, c5 = y6 * i16 / 2, m7 = 2 * c5;
      const h8 = new t(t15.seed), u13 = n18 * s13 / 1.5, p7 = n18 * i16 / 1.5;
      f7 = [];
      for (let t16 = 0; t16 < r19; t16++) for (let e15 = 0; e15 < y6; e15++) {
        const r20 = t16 * s13 - l12 + u13 * (0.5 - h8.getFloat()), o8 = e15 * i16 - c5 + p7 * (0.5 - h8.getFloat());
        f7.push({ x: r20, y: o8 }), 0 === t16 && f7.push({ x: r20 + 2 * l12, y: o8 }), 0 === e15 && f7.push({ x: r20, y: o8 + 2 * c5 });
      }
    } else true === t15.shiftOddRows ? (l12 = s13 / 2, c5 = i16, m7 = 2 * i16, f7 = [{ x: -l12, y: 0 }, { x: l12, y: 0 }, { x: 0, y: c5 }, { x: 0, y: -c5 }]) : (l12 = s13 / 2, c5 = i16 / 2, m7 = i16, f7 = [{ x: -s13, y: 0 }, { x: 0, y: -i16 }, { x: -s13, y: -i16 }, { x: 0, y: 0 }, { x: s13, y: 0 }, { x: 0, y: i16 }, { x: s13, y: i16 }, { x: -s13, y: i16 }, { x: s13, y: -i16 }]);
    return { type: "CIMVectorMarker", frame: { xmin: -l12, xmax: l12, ymin: -c5, ymax: c5 }, markerGraphics: f7.map((e14) => ({ type: "CIMMarkerGraphic", geometry: e14, symbol: { type: "CIMPointSymbol", symbolLayers: [r18] } })), size: m7 };
  }
};
function te2(e13, t15) {
  if (e13) switch (e13.type) {
    case "CIMPointSymbol":
    case "CIMLineSymbol":
    case "CIMPolygonSymbol": {
      const r18 = e13.symbolLayers;
      if (!r18) return;
      for (const e14 of r18) if (t15(e14), "CIMVectorMarker" === e14.type) {
        const r19 = e14.markerGraphics;
        if (!r19) continue;
        for (const e15 of r19) if (e15) {
          const r20 = e15.symbol;
          r20 && te2(r20, t15);
        }
      }
      break;
    }
  }
}
var re = (e13) => {
  if (!e13) return U.Butt;
  switch (e13) {
    case "butt":
      return U.Butt;
    case "square":
      return U.Square;
    case "round":
      return U.Round;
  }
};
var oe2 = (e13) => {
  if (!e13) return w.Miter;
  switch (e13) {
    case "miter":
      return w.Miter;
    case "round":
      return w.Round;
    case "bevel":
      return w.Bevel;
  }
};
var ae = (e13) => {
  if (null == e13) return "Center";
  switch (e13) {
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "center":
      return "Center";
  }
};
var se = (e13) => {
  if (null == e13) return "Center";
  switch (e13) {
    case "baseline":
      return "Baseline";
    case "top":
      return "Top";
    case "middle":
      return "Center";
    case "bottom":
      return "Bottom";
  }
};
var ie2 = (e13) => {
  if (!e13) return [0, 0, 0, 0];
  const { r: t15, g: r18, b: o8, a: a12 } = e13;
  return [t15, r18, o8, 255 * a12];
};
var ne = (e13, t15) => {
  const r18 = le(t15), o8 = ce(e13);
  return r18 && o8 ? `${r18}-${o8}` : `${r18}${o8}`;
};
var le = (e13) => {
  if (!e13) return "";
  switch (e13.toLowerCase()) {
    case "bold":
    case "bolder":
      return "bold";
  }
  return "";
};
var ce = (e13) => {
  if (!e13) return "";
  switch (e13.toLowerCase()) {
    case "italic":
    case "oblique":
      return "italic";
  }
  return "";
};
var me = (e13, t15) => {
  const r18 = has("safari") ? 1e-3 : 0, o8 = "butt" === t15;
  switch (e13) {
    case "dash":
    case "esriSLSDash":
      return o8 ? [4, 3] : [3, 4];
    case "dash-dot":
    case "esriSLSDashDot":
      return o8 ? [4, 3, 1, 3] : [3, 4, r18, 4];
    case "dot":
    case "esriSLSDot":
      return o8 ? [1, 3] : [r18, 4];
    case "long-dash":
    case "esriSLSLongDash":
      return o8 ? [8, 3] : [7, 4];
    case "long-dash-dot":
    case "esriSLSLongDashDot":
      return o8 ? [8, 3, 1, 3] : [7, 4, r18, 4];
    case "long-dash-dot-dot":
    case "esriSLSDashDotDot":
      return o8 ? [8, 3, 1, 3, 1, 3] : [7, 4, r18, 4, r18, 4];
    case "short-dash":
    case "esriSLSShortDash":
      return o8 ? [4, 1] : [3, 2];
    case "short-dash-dot":
    case "esriSLSShortDashDot":
      return o8 ? [4, 1, 1, 1] : [3, 2, r18, 2];
    case "short-dash-dot-dot":
    case "esriSLSShortDashDotDot":
      return o8 ? [4, 1, 1, 1, 1, 1] : [3, 2, r18, 2, r18, 2];
    case "short-dot":
    case "esriSLSShortDot":
      return o8 ? [1, 1] : [r18, 2];
    case "solid":
    case "esriSLSSolid":
    case "none":
      return O2().error("Unexpected: style does not require rasterization"), [0, 0];
    default:
      return O2().error(`Tried to rasterize SLS, but found an unexpected style: ${e13}!`), [0, 0];
  }
};
function fe(e13) {
  return void 0 !== e13.symbolLayers;
}
var ye = (e13, t15 = 100) => {
  const r18 = t15 / 2;
  let o8, a12;
  const s13 = e13;
  if ("circle" === s13 || "esriSMSCircle" === s13) {
    const e14 = 0.25;
    let t16 = Math.acos(1 - e14 / r18), s14 = Math.ceil(N4 / t16 / 4);
    0 === s14 && (s14 = 1), t16 = Y3 / s14, s14 *= 4;
    const i16 = [];
    i16.push([r18, 0]);
    for (let o9 = 1; o9 < s14; o9++) i16.push([r18 * Math.cos(o9 * t16), -r18 * Math.sin(o9 * t16)]);
    i16.push([r18, 0]), o8 = { rings: [i16] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 };
  } else if ("cross" === s13 || "esriSMSCross" === s13) {
    const e14 = 0;
    o8 = { paths: [[[e14, r18], [e14, -r18]], [[r18, e14], [-r18, e14]]] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 };
  } else if ("diamond" === s13 || "esriSMSDiamond" === s13) o8 = { rings: [[[-r18, 0], [0, r18], [r18, 0], [0, -r18], [-r18, 0]]] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 };
  else if ("square" === s13 || "esriSMSSquare" === s13) o8 = { rings: [[[-r18, -r18], [-r18, r18], [r18, r18], [r18, -r18], [-r18, -r18]]] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 };
  else if ("x" === s13 || "esriSMSX" === s13) o8 = { paths: [[[r18, r18], [-r18, -r18]], [[r18, -r18], [-r18, r18]]] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 };
  else if ("triangle" === s13 || "esriSMSTriangle" === s13) {
    const e14 = t15 * 0.5773502691896257, r19 = -e14, s14 = 2 / 3 * t15, i16 = s14 - t15;
    o8 = { rings: [[[r19, i16], [0, s14], [e14, i16], [r19, i16]]] }, a12 = { xmin: r19, ymin: i16, xmax: e14, ymax: s14 };
  } else "arrow" === s13 && (o8 = { rings: [[[-50, 50], [50, 0], [-50, -50], [-33, -20], [-33, 20], [-50, 50]]] }, a12 = { xmin: -r18, ymin: -r18, xmax: r18, ymax: r18 });
  return [a12, o8];
};
var he = (e13) => "vertical" === e13 || "horizontal" === e13 || "cross" === e13 || "esriSFSCross" === e13 || "esriSFSVertical" === e13 || "esriSFSHorizontal" === e13;
function ue(e13, t15, r18) {
  if (!e13.effects || null != t15.geometryEngine) return;
  if (t15.geometryEnginePromise) return void r18.push(t15.geometryEnginePromise);
  k(e13.effects) && (t15.geometryEnginePromise = S2(), r18.push(t15.geometryEnginePromise), t15.geometryEnginePromise.then((e14) => t15.geometryEngine = e14));
}
function pe(e13) {
  if (!e13) return null;
  let t15 = null;
  const { cap: r18, color: o8, join: a12, miterLimit: s13, style: i16, width: n18 } = e13;
  return "solid" !== i16 && "none" !== i16 && "esriSLSSolid" !== i16 && "esriSLSNull" !== i16 && (t15 = [{ type: "CIMGeometricEffectDashes", dashTemplate: me(i16, r18), lineDashEnding: "NoConstraint", scaleDash: true, offsetAlongLine: null }]), { type: "CIMSolidStroke", color: "esriSLSNull" !== i16 && "none" !== i16 ? ie2(o8) : [0, 0, 0, 0], capStyle: re(r18), joinStyle: oe2(a12), miterLimit: s13, width: n18, effects: t15 };
}

export {
  a6 as a,
  s7 as s,
  l9 as l,
  A3 as A,
  g3 as g,
  i14 as i,
  t13 as t,
  t14 as t2,
  e12 as e,
  n17 as n,
  a11 as a2,
  c4 as c,
  o6 as o,
  s11 as s2,
  i13 as i2,
  O,
  u12 as u,
  l11 as l2,
  $,
  rt,
  st,
  W,
  Q3 as Q,
  Z3 as Z,
  ee,
  me
};
//# sourceMappingURL=chunk-5VEO4IUH.js.map
