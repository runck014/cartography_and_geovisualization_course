import {
  A,
  A2,
  E,
  L,
  a as a2,
  a2 as a3,
  b as b2,
  c,
  f,
  h,
  m as m2,
  n as n2,
  o,
  o2,
  o3,
  r as r3,
  s as s4,
  t as t2,
  ue,
  v
} from "./chunk-VD7LJKWR.js";
import "./chunk-QJUE5NJJ.js";
import {
  F
} from "./chunk-F4M4YVE2.js";
import "./chunk-S6R6PMEL.js";
import "./chunk-JHMJSZI5.js";
import "./chunk-2L7UGRIC.js";
import "./chunk-E6IUAXXM.js";
import "./chunk-NJKQE6C5.js";
import "./chunk-ENHHZ2WV.js";
import "./chunk-HKWBRI3V.js";
import "./chunk-NW6OWOSJ.js";
import "./chunk-EVK6ZSVY.js";
import "./chunk-MSUBZ5BW.js";
import "./chunk-YEDSTDY4.js";
import "./chunk-P4TUSPKE.js";
import {
  ot
} from "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import {
  s as s3
} from "./chunk-KI5F6KDS.js";
import "./chunk-HACIIBEF.js";
import "./chunk-2BVPGUC2.js";
import "./chunk-BN24XFSK.js";
import "./chunk-547Z5YIS.js";
import "./chunk-4WB72ND2.js";
import "./chunk-LIUBAYCM.js";
import "./chunk-BLYF375M.js";
import "./chunk-JED7FM2Q.js";
import "./chunk-FFUKJAFO.js";
import "./chunk-H4E2VVPD.js";
import "./chunk-CQFC4JO6.js";
import "./chunk-VS5MKM3H.js";
import "./chunk-CQTV4C3X.js";
import "./chunk-764E6KTP.js";
import "./chunk-GEPD6W23.js";
import "./chunk-TP6LRQ42.js";
import "./chunk-ZE6OS33V.js";
import "./chunk-MWZJIOOL.js";
import "./chunk-ULSRCITK.js";
import "./chunk-5GQ62KHN.js";
import "./chunk-YAGJS3MX.js";
import "./chunk-43KBLSS3.js";
import "./chunk-PV3ZZQOV.js";
import {
  l
} from "./chunk-SM2VXWMT.js";
import "./chunk-WYO25WZZ.js";
import "./chunk-OC7D2HR4.js";
import {
  t
} from "./chunk-IGMG7ERK.js";
import {
  b
} from "./chunk-V47ZBW5W.js";
import "./chunk-HKYICNT2.js";
import {
  S
} from "./chunk-VGUQMPM6.js";
import "./chunk-KKH7HGO3.js";
import "./chunk-Z3NV3VCK.js";
import "./chunk-7VNQKVOW.js";
import "./chunk-PNVXSHN2.js";
import "./chunk-3DVL3O3F.js";
import "./chunk-RN66FJAW.js";
import "./chunk-QYSQ6XPQ.js";
import "./chunk-2RIHQI4N.js";
import "./chunk-VLKWWBLY.js";
import "./chunk-NXGNMEHZ.js";
import "./chunk-TWYDW6LU.js";
import "./chunk-PVHAAI32.js";
import "./chunk-MLATPUII.js";
import "./chunk-NVFQGMP6.js";
import "./chunk-P2IB5HBH.js";
import "./chunk-XX37BOHH.js";
import "./chunk-5CRXWQ3Y.js";
import "./chunk-4RFCLPAF.js";
import "./chunk-NIWINVGG.js";
import "./chunk-DOENTAA7.js";
import "./chunk-CGSFKZP2.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-WPERPIJF.js";
import "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-DB6SP72M.js";
import "./chunk-T6QS4ZNU.js";
import "./chunk-D3FSVA7H.js";
import "./chunk-6B4OMNPA.js";
import "./chunk-3GQ4PJDJ.js";
import "./chunk-QEJMJI2R.js";
import {
  f as f2
} from "./chunk-QMGMKWTA.js";
import "./chunk-2EGO74J5.js";
import "./chunk-4SUK447J.js";
import "./chunk-2X7T37AY.js";
import "./chunk-XQH2QDB2.js";
import "./chunk-6Q7GN2CW.js";
import "./chunk-MYUZZ3A3.js";
import "./chunk-2IGXKE5P.js";
import "./chunk-JFI4ESYU.js";
import "./chunk-4X2UADDH.js";
import "./chunk-ZICJB3ML.js";
import "./chunk-AVBIV2K3.js";
import "./chunk-4NJWIUZG.js";
import "./chunk-F3NUC2RS.js";
import "./chunk-LE3YW4Y3.js";
import "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import "./chunk-NYLBGE62.js";
import "./chunk-LPNAPHOF.js";
import "./chunk-QCBTLG25.js";
import "./chunk-ECCHNTW6.js";
import "./chunk-WWNVF22O.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import "./chunk-VEUN2EF3.js";
import {
  C,
  d
} from "./chunk-W6D3ECTZ.js";
import "./chunk-PJNOPBRY.js";
import "./chunk-23TJP3F6.js";
import "./chunk-EMVTPRQK.js";
import "./chunk-EDGKOPSL.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-SEUZ3J6J.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import {
  d as d2
} from "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import {
  V
} from "./chunk-RCLWOQNR.js";
import "./chunk-DOTSJZHK.js";
import "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  j2 as j,
  w
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import "./chunk-2WXAPZBK.js";
import "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import {
  e,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a,
  r2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  s as s2
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/knowledgeGraph/IdealEdgeLengthTypeOptions.js
var e2;
!function(e3) {
  e3.MULTIPLIER = "multiplier", e3.ABSOLUTE = "absoluteValue";
}(e2 || (e2 = {}));

// node_modules/@arcgis/core/layers/LinkChartLayer.js
var z = class extends b(l(t(S(f2)))) {
  constructor(e3) {
    if (super(e3), this.dataPreloadedInLocalCache = false, this.defaultLinkChartConfig = null, this._currentLinkChartConfig = { layoutMode: "RADIAL_TREE" }, this._graphTypeLookup = /* @__PURE__ */ new Map(), this.dataManager = null, this.knowledgeGraph = null, this.layers = new (V.ofType(ue))(), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.linkChartExtent = new w({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 }), this.memberEntityTypes = null, this.memberRelationshipTypes = null, this.operationalLayerType = "LinkChartLayer", this.sublayerIdsCache = /* @__PURE__ */ new Map(), this.tables = new (V.ofType(ue))(), this.type = "link-chart", this.chronologicalAuxiliaryGraphics = null, this._originalInclusionList = e3 == null ? void 0 : e3.inclusionModeDefinition, (e3 == null ? void 0 : e3.dataPreloadedInLocalCache) && !(e3 == null ? void 0 : e3.inclusionModeDefinition)) throw new s("knowledge-graph:linkchart-layer-constructor", "If creating a link chart composite layer and configured that data is already loaded in the cache, you must specify an inclusion list so the Composite Layer knows what records belong to it");
    this.addHandles(d(() => this.layers.concat(this.tables), (e4, t3) => this._handleSublayersChange(e4, t3), C));
  }
  normalizeCtorArgs(e3) {
    if (!e3) return {};
    const { url: t3, title: a4, dataPreloadedInLocalCache: i, defaultLinkChartConfig: n3 } = e3;
    return { url: t3, title: a4, dataPreloadedInLocalCache: i, defaultLinkChartConfig: n3 };
  }
  _initializeLayerProperties(e3) {
    var _a, _b, _c, _d, _e, _f;
    if (!this.title && this.url) {
      const e4 = this.url.split("/");
      this.title = e4[e4.length - 2];
    }
    const t3 = /* @__PURE__ */ new Set();
    let n3 = [], o4 = [];
    if (e3.inclusionModeDefinition && (!e3.inclusionModeDefinition.namedTypeDefinitions || e3.inclusionModeDefinition.namedTypeDefinitions.size < 1)) throw new s("knowledge-graph:composite-layer-constructor", "If an explicit inclusion definition is defined, at least one namedTypeDefinition must also be defined");
    (_a = e3.knowledgeGraph.dataModel.entityTypes) == null ? void 0 : _a.forEach((e4) => {
      e4.name && this._graphTypeLookup.set(e4.name, e4);
    }), (_b = e3.knowledgeGraph.dataModel.relationshipTypes) == null ? void 0 : _b.forEach((e4) => {
      e4.name && this._graphTypeLookup.set(e4.name, e4);
    }), ((_c = e3.inclusionModeDefinition) == null ? void 0 : _c.generateAllSublayers) ? (n3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []) : ((_d = e3.inclusionModeDefinition) == null ? void 0 : _d.namedTypeDefinitions) && ((_e = e3.inclusionModeDefinition) == null ? void 0 : _e.namedTypeDefinitions.size) > 0 ? (_f = e3.inclusionModeDefinition) == null ? void 0 : _f.namedTypeDefinitions.forEach((a4, s6) => {
      var _a2, _b2;
      const r4 = this._graphTypeLookup.get(s6);
      if (!r4) return n.getLogger(this).warn(`A named type, ${s6}, was in the inclusion list that wasn't in the data model and will be removed`), void ((_a2 = e3.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.delete(s6));
      "relationship" === r4.type ? t3.has(s6) || (t3.add(s6), o4.push(r4)) : "entity" === r4.type ? t3.has(s6) || (t3.add(s6), n3.push(r4)) : (n.getLogger(this).warn(`A named type, ${s6}, was in the inclusion list that wasn't properly modeled and will be removed`), (_b2 = e3.inclusionModeDefinition) == null ? void 0 : _b2.namedTypeDefinitions.delete(s6));
    }) : (n3 = e3.knowledgeGraph.dataModel.entityTypes ?? [], o4 = e3.knowledgeGraph.dataModel.relationshipTypes ?? []);
    const s5 = new E({ knowledgeGraph: e3.knowledgeGraph, inclusionModeDefinition: e3.inclusionModeDefinition });
    this.knowledgeGraph = e3.knowledgeGraph, this.memberEntityTypes = n3, this.memberRelationshipTypes = o4, this.dataManager = s5;
  }
  load(e3) {
    const t3 = async () => {
      var _a;
      const e4 = [], t4 = [];
      this.loadLayerAssumingLocalCache(), await c(this), this.dataManager.inclusionModeDefinition && (this.dataManager.inclusionModeDefinition.generateAllSublayers = false), (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions.forEach((e5) => {
        e5.useAllData = false;
      }), await this._initializeDiagram(), this.layers.forEach((a4) => {
        t4.push(a4.refreshCachedQueryEngine()), e4.push(new Promise((e5) => {
          a4.on("layerview-create", () => {
            e5(null);
          });
        }));
      }), this.tables.forEach((e5) => {
        t4.push(e5.refreshCachedQueryEngine());
      }), await Promise.all(t4);
    };
    return this.addResolvingPromise(new Promise((a4) => {
      F(this.url).then(async (i) => {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this._initializeLayerProperties({ knowledgeGraph: i, inclusionModeDefinition: this._originalInclusionList }), ((_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.size) || (this.dataManager.inclusionModeDefinition = { generateAllSublayers: false, namedTypeDefinitions: /* @__PURE__ */ new Map() }, (_c = this.dataManager.knowledgeGraph.dataModel.entityTypes) == null ? void 0 : _c.forEach((e4) => {
          var _a2;
          e4.name && ((_a2 = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.set(e4.name, { useAllData: true }));
        }), (_d = this.dataManager.knowledgeGraph.dataModel.relationshipTypes) == null ? void 0 : _d.forEach((e4) => {
          var _a2;
          e4.name && ((_a2 = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a2.namedTypeDefinitions.set(e4.name, { useAllData: true }));
        })), this.dataPreloadedInLocalCache) {
          const e4 = o2.getInstance();
          for (const [t4, a5] of ((_e = this.dataManager.inclusionModeDefinition) == null ? void 0 : _e.namedTypeDefinitions) ?? []) for (const i2 of ((_f = a5.members) == null ? void 0 : _f.values()) ?? []) {
            const a6 = e4.readFromStoreById(`${t4}__${i2.id}`);
            if (a6) {
              r2(this.dataManager.sublayerCaches, t4, () => /* @__PURE__ */ new Map()).set(i2.id, a6);
            }
          }
          await t3();
        } else {
          const a5 = "GEOGRAPHIC" === ((_g = this.defaultLinkChartConfig) == null ? void 0 : _g.layoutMode);
          this.addResolvingPromise(this.dataManager.refreshCacheContent(void 0, false, a5, true).then(async () => {
            s2(e3), await t3();
          }));
        }
        a4(null);
      });
    })), Promise.resolve(this);
  }
  set inclusionModeDefinition(e3) {
    "loaded" !== this.loadStatus && "failed" !== this.loadStatus ? this._set("inclusionModeDefinition", e3) : n.getLogger(this).error("#inclusionModeDefinition", "inclusionModeDefinition cannot be changed after the layer is loaded.");
  }
  async addRecords(e3, t3) {
    let a4 = [];
    (t3 == null ? void 0 : t3.cascadeAddRelationshipEndNodes) && this.dataManager.knowledgeGraph.dataModel && (a4 = await A2(e3, this.dataManager.knowledgeGraph));
    const i = e3.concat(a4).filter((e4) => {
      var _a;
      return !((_a = this.sublayerIdsCache.get(e4.typeName)) == null ? void 0 : _a.has(e4.id));
    });
    await this._handleNewRecords(i);
  }
  async removeRecords(e3, { cascadeRemoveRelationships: t3 = true, recalculateLayout: a4 = false } = { cascadeRemoveRelationships: true, recalculateLayout: false }) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    let i = [];
    for (const o4 of e3) false === ((_c = (_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.get(o4.typeName)) == null ? void 0 : _c.useAllData) && ((_g = (_f = (_e = (_d = this.dataManager.inclusionModeDefinition) == null ? void 0 : _d.namedTypeDefinitions) == null ? void 0 : _e.get(o4.typeName)) == null ? void 0 : _f.members) == null ? void 0 : _g.has(o4.id)) && i.push(o4);
    if (t3) {
      const e4 = /* @__PURE__ */ new Set(), t4 = [];
      for (const a5 of i) if (this.dataManager.nodeConnectionsLookup.has(a5.id)) for (const t5 of this.dataManager.nodeConnectionsLookup.get(a5.id)) e4.add(t5);
      for (const a5 of e4) if (this.dataManager.memberIdTypeLookup.has(a5)) for (const e5 of this.dataManager.memberIdTypeLookup.get(a5)) this.dataManager.relationshipTypeNames.has(e5) && t4.push({ id: a5, typeName: e5 });
      i = i.concat(t4);
    }
    this.dataManager.removeFromLayer(i);
    for (const o4 of i) (_h = this.sublayerIdsCache.get(o4.typeName)) == null ? void 0 : _h.delete(o4.id), this.dataManager.relationshipTypeNames.has(o4.typeName) ? this.relationshipLinkChartDiagramLookup.delete(o4.id) : this.entityLinkChartDiagramLookup.delete(o4.id);
    a4 && await this._calculateLayoutWithSublayerTimeInfo(this._currentLinkChartConfig.layoutMode, this._currentLinkChartConfig.layoutOptions);
    const n3 = [];
    return this.layers.forEach((e4) => {
      n3.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(n3), this._refreshNamedTypes(), i;
  }
  async expand(e3, t3) {
    const a4 = await this.dataManager.getConnectedRecordIds(e3, t3), i = a4.filter((e4) => {
      var _a;
      return !((_a = this.sublayerIdsCache.get(e4.typeName)) == null ? void 0 : _a.has(e4.id));
    });
    return await this._handleNewRecords(a4), { records: i };
  }
  loadLayerAssumingLocalCache() {
    var _a, _b;
    const e3 = [...this.memberRelationshipTypes, ...this.memberEntityTypes];
    this.originIdOf("layers") === e.DEFAULTS ? this._createSublayers(e3, this.layers, (e4) => !!e4.geometryType) : this._updateSublayers(e3, this.layers), this.originIdOf("tables") === e.DEFAULTS ? this._createSublayers(e3, this.tables, (e4) => !e4.geometryType) : this._updateSublayers(e3, this.tables), (_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.forEach((e4, t3) => {
      var _a2;
      const a4 = r2(this.sublayerIdsCache, t3, () => /* @__PURE__ */ new Set());
      (_a2 = e4.members) == null ? void 0 : _a2.forEach(({ id: e5, linkChartLocation: i }) => {
        if (a4.add(e5), i) {
          const a5 = i instanceof s3 ? i : ot(i);
          this.dataManager.relationshipTypeNames.has(t3) ? this.relationshipLinkChartDiagramLookup.set(e5, a5) : this.entityLinkChartDiagramLookup.set(e5, a5);
        }
      });
    });
  }
  async calculateLinkChartLayout(e3 = "RADIAL_TREE", t3) {
    var _a, _b, _c, _d;
    const n3 = [], o4 = [], s5 = [];
    this.dataManager.sublayerCaches.forEach((e4, t4) => {
      this.dataManager.entityTypeNames.has(t4) ? e4.forEach((e5) => {
        n3.push({ typeName: t4, feature: e5 });
      }) : this.dataManager.relationshipTypeNames.has(t4) && e4.forEach((e5) => {
        o4.push({ typeName: t4, feature: e5 });
      });
    }), this.entityLinkChartDiagramLookup = /* @__PURE__ */ new Map(), this.relationshipLinkChartDiagramLookup = /* @__PURE__ */ new Map();
    const r4 = /* @__PURE__ */ new Map(), l2 = /* @__PURE__ */ new Map(), h2 = /* @__PURE__ */ new Map(), d3 = /* @__PURE__ */ new Map(), u = new Uint8Array(n3.length), p = new Float64Array(n3.length), y = new Float64Array(n3.length), g = new Float64Array(n3.length), m3 = new Float64Array(n3.length), f3 = new Uint32Array(o4.length), k = new Uint32Array(o4.length), T = new Float64Array(o4.length), E2 = new Float64Array(o4.length), N = [], I = "FORCE_DIRECTED", D = new w({ xmin: -1e-7, ymin: -1e-7, xmax: 1e-7, ymax: 1e-7 });
    let H, z2 = "FORCE_DIRECTED", W2 = 0, Q = 0;
    const $ = b2.apply;
    switch (z2 = "GEOGRAPHIC" === e3 ? I : e3, z2) {
      case "FORCE_DIRECTED":
        H = f.apply;
        break;
      case "COMMUNITY":
        H = A.apply;
        break;
      case "HIERARCHICAL":
        H = h.apply;
        break;
      case "RADIAL_TREE":
        H = m2.apply;
        break;
      case "SMART_TREE":
        H = L.apply;
        break;
      default:
        H = v.apply;
    }
    let K = false;
    n3.forEach(({ typeName: a4, feature: i }) => {
      var _a2, _b2, _c2, _d2, _e;
      if ("CHRONOLOGICAL_SINGLE" !== e3 && "CHRONOLOGICAL_MULTIPLE" !== e3 && ((_a2 = t3 == null ? void 0 : t3.lockedNodeLocations) == null ? void 0 : _a2.has(i.attributes[a2]))) {
        "GEOGRAPHIC" === e3 && this.dataManager.geographicLookup.has(a4) ? u[W2] = s4.IsGeographic : u[W2] = s4.None;
        const n4 = t3.lockedNodeLocations.get(i.attributes[a2]);
        p[W2] = n4.x, y[W2] = n4.y;
      } else if ("GEOGRAPHIC" === e3 && this.dataManager.geographicLookup.has(a4)) {
        u[W2] = s4.IsGeographic;
        let e4 = null;
        const t4 = i.attributes[this.dataManager.geographicLookup.get(a4).name], n4 = (_b2 = this.dataManager.geographicLookup.get(a4)) == null ? void 0 : _b2.geometryType;
        switch (n4) {
          case "esriGeometryPoint":
            p[W2] = t4 == null ? void 0 : t4.x, y[W2] = t4 == null ? void 0 : t4.y;
            break;
          case "esriGeometryPolygon":
            e4 = t4 == null ? void 0 : t4.centroid, null != (e4 == null ? void 0 : e4.x) && null != (e4 == null ? void 0 : e4.y) ? (p[W2] = e4.x, y[W2] = e4.y) : u[W2] = s4.IsMovable;
            break;
          case "esriGeometryPolyline":
          case "esriGeometryMultipoint":
            e4 = (_c2 = t4 == null ? void 0 : t4.extent) == null ? void 0 : _c2.center, null != (e4 == null ? void 0 : e4.x) && null != (e4 == null ? void 0 : e4.y) ? (p[W2] = e4.x, y[W2] = e4.y) : u[W2] = s4.IsMovable;
            break;
          default:
            u[W2] = s4.IsMovable;
        }
        (null == p[W2] || null == y[W2] || Number.isNaN(p[W2]) || Number.isNaN(y[W2])) && (u[W2] = s4.IsMovable, p[W2] = 0, y[W2] = 0);
      } else if ("CHRONOLOGICAL_SINGLE" === e3 || "CHRONOLOGICAL_MULTIPLE" === e3) {
        !K && ((_d2 = t3 == null ? void 0 : t3.lockedNodeLocations) == null ? void 0 : _d2.has(i.attributes[a2])) && (K = true);
        const e4 = (_e = t3 == null ? void 0 : t3.timeInfoByTypeName) == null ? void 0 : _e.get(a4), n4 = e4 == null ? void 0 : e4.startField, o5 = n4 && (e4 == null ? void 0 : e4.startField) ? i.attributes[n4] : null;
        g[W2] = o5 ? new Date(o5).getTime() : NaN;
        const s6 = e4 == null ? void 0 : e4.endField, r5 = s6 && (e4 == null ? void 0 : e4.endField) ? i.attributes[s6] : null;
        m3[W2] = r5 ? new Date(r5).getTime() : NaN, p[W2] = 0, y[W2] = 0, u[W2] = s4.IsMovable;
      } else u[W2] = s4.IsMovable, p[W2] = 0, y[W2] = 0;
      d3.set(i.attributes[a2], W2), N[W2] = { feature: i, typeName: a4 }, W2++;
    }), K && n.getLogger(this).warn("Locked node locations are not supported for chronological layout at this time.  Requested node locations were ignored");
    let Y = false;
    const q = /* @__PURE__ */ new Map();
    o4.forEach((a4) => {
      var _a2;
      const i = a4.feature.attributes[t2], n4 = a4.feature.attributes[r3], o5 = d3.get(i), r5 = d3.get(n4), l3 = (_a2 = t3 == null ? void 0 : t3.timeInfoByTypeName) == null ? void 0 : _a2.get(a4.typeName), h3 = (t3 == null ? void 0 : t3.timeInfoByTypeName) ? l3 == null ? void 0 : l3.startField : null, u2 = h3 ? a4.feature.attributes[h3] : null, p2 = l3 == null ? void 0 : l3.endField, c2 = p2 ? a4.feature.attributes[p2] : null;
      if (void 0 !== o5 && void 0 !== r5) {
        let t4 = i + "-" + n4;
        "CHRONOLOGICAL_SINGLE" !== e3 && "CHRONOLOGICAL_MULTIPLE" !== e3 || (t4 = t4 + "-" + u2 + "-" + c2);
        const l4 = q.get(t4), h4 = l4 == null ? void 0 : l4.has(a4.typeName);
        h4 || (f3[Q] = o5, k[Q] = r5, "CHRONOLOGICAL_SINGLE" !== e3 && "CHRONOLOGICAL_MULTIPLE" !== e3 || (T[Q] = u2 ? new Date(u2).getTime() : NaN, E2[Q] = c2 ? new Date(c2).getTime() : NaN), void 0 === l4 ? q.set(t4, /* @__PURE__ */ new Map([[a4.typeName, Q]])) : l4.set(a4.typeName, Q), Q++), s5.push(a4);
      } else Y = true, this.relationshipLinkChartDiagramLookup.set(i, null);
    }), Y && n.getLogger(this).warn("A relationship is a member of this layer that has either origin or destination entity nodes that are not members. The diagram geometry will be set to null");
    const J = this._validateLayoutSettings(e3, t3), V2 = this._convertLayoutSettingsToCalculationSettings(J);
    await a3();
    let X = false, Z = null;
    if ("CHRONOLOGICAL_SINGLE" === e3 || "CHRONOLOGICAL_MULTIPLE" === e3) {
      let a4;
      ({ success: X, links: Z, graphics: a4 } = $(u, p, y, g, m3, f3.subarray(0, Q), k.subarray(0, Q), T.subarray(0, Q), E2.subarray(0, Q), "CHRONOLOGICAL_MULTIPLE" === e3, (t3 == null ? void 0 : t3.chronologicalLayoutSettings) ?? {})), X && (this.chronologicalAuxiliaryGraphics = a4);
    } else ({ success: X, links: Z } = H(u, p, y, f3.subarray(0, Q), k.subarray(0, Q), V2.computationBudgetTime, V2.idealEdgeLengthMultiplier, V2.repulsionRadiusMultiplier));
    if (!X) throw new s("knowledge-graph:layout-failed", "Attempting to arrange the records in the specified layout failed");
    for (let a4 = 0; a4 < N.length; a4++) {
      if (y[a4] > 84.9999 ? y[a4] = 84.9999 : y[a4] < -84.9999 && (y[a4] = -84.9999), p[a4] > 179.9999 ? p[a4] = 179.9999 : p[a4] < -179.9999 && (p[a4] = -179.9999), N[a4].feature.attributes[n2] = new j(p[a4], y[a4]), r4.has(N[a4].typeName)) {
        const e5 = r4.get(N[a4].typeName);
        e5 == null ? void 0 : e5.set(N[a4].feature.attributes[a2], N[a4].feature);
      } else {
        const e5 = /* @__PURE__ */ new Map();
        e5.set(N[a4].feature.attributes[a2], N[a4].feature), r4.set(N[a4].typeName, e5);
      }
      h2.set(N[a4].feature.attributes[a2], N[a4].feature);
      const e4 = ot(N[a4].feature.attributes[n2]);
      this.entityLinkChartDiagramLookup.set(N[a4].feature.attributes[a2], N[a4].feature.attributes[n2] ? e4 : null), N[a4].feature.attributes[n2].x < D.xmin && (D.xmin = N[a4].feature.attributes[n2].x), N[a4].feature.attributes[n2].x > D.xmax && (D.xmax = N[a4].feature.attributes[n2].x), N[a4].feature.attributes[n2].y < D.ymin && (D.ymin = N[a4].feature.attributes[n2].y), N[a4].feature.attributes[n2].y > D.ymax && (D.ymax = N[a4].feature.attributes[n2].y);
    }
    if (this.linkChartExtent.xmin = D.xmin, this.linkChartExtent.xmax = D.xmax, this.linkChartExtent.ymin = D.ymin, this.linkChartExtent.ymax = D.ymax, !Z) throw new s("knowledge-graph:layout-failed", "Attempting to retrieve link geometry from diagram engine failed");
    const ee = /* @__PURE__ */ new Map(), te = /* @__PURE__ */ new Map(), ae = /* @__PURE__ */ new Map(), ie = /* @__PURE__ */ new Set();
    for (let a4 = 0; a4 < s5.length; a4++) {
      const n4 = [], o5 = s5[a4], r5 = o5.feature.attributes[t2], u2 = o5.feature.attributes[r3];
      let p2 = r5 + "-" + u2;
      if ("CHRONOLOGICAL_SINGLE" === e3 || "CHRONOLOGICAL_MULTIPLE" === e3) {
        const e4 = (_a = t3 == null ? void 0 : t3.timeInfoByTypeName) == null ? void 0 : _a.get(o5.typeName), a5 = (t3 == null ? void 0 : t3.timeInfoByTypeName) ? e4 == null ? void 0 : e4.startField : null, i = a5 ? o5.feature.attributes[a5] : null, n5 = e4 == null ? void 0 : e4.endField;
        p2 += "-" + i + "-" + (n5 ? o5.feature.attributes[n5] : null);
      }
      const y2 = q.get(p2).get(o5.typeName), g2 = 0 === y2 ? 0 : Z == null ? void 0 : Z.vertexEndIndex[y2 - 1];
      if (!ie.has(y2)) {
        if (ie.add(y2), Z.types[y2] === o3.Recursive) {
          const e4 = [Z.vertices[2 * g2], Z.vertices[2 * g2 + 1]], t4 = [Z.vertices[2 * (g2 + 1)], Z.vertices[2 * (g2 + 1) + 1]], a5 = [0.5 * (e4[0] + t4[0]), 0.5 * (e4[1] + t4[1])], i = [a5[0] - e4[0], a5[1] - e4[1]], o6 = [a5[0] + i[1], a5[1] - i[0]], s6 = [a5[0] - i[1], a5[1] + i[0]];
          n4.push(e4), n4.push(o6), n4.push(t4), n4.push(s6), n4.push(e4);
        } else {
          if (Z.types[y2] !== o3.Regular) {
            n.getLogger(this).warn("A relationship generated an unsupported link geometry type.  It will not be rendered");
            continue;
          }
          for (let e4 = g2; e4 < Z.vertexEndIndex[y2]; e4++) n4.push([Z.vertices[2 * e4], Z.vertices[2 * e4 + 1]]);
        }
        if ("CHRONOLOGICAL_SINGLE" !== e3 && "CHRONOLOGICAL_MULTIPLE" !== e3) {
          const e4 = (_b = N[d3.get(r5)]) == null ? void 0 : _b.feature.attributes[n2], t4 = (_c = N[d3.get(u2)]) == null ? void 0 : _c.feature.attributes[n2];
          n4[0][0] === e4.x && n4[0][1] === e4.y || (n4[0] = [e4.x, e4.y]), n4[n4.length - 1][0] === t4.x && n4[n4.length - 1][1] === t4.y || (n4[n4.length - 1] = [t4.x, t4.y]);
        }
        for (let e4 = 1; e4 < n4.length - 1; e4++) n4[e4][1] > 85.5 ? n4[e4][1] = 85.5 : n4[e4][1] < -85.5 && (n4[e4][1] = -85.5), n4[e4][0] > 179.9999 ? n4[e4][0] = 179.9999 : n4[e4][0] < -179.9999 && (n4[e4][0] = -179.9999);
        ee.has(p2) ? ee.get(p2).push(n4) : ee.set(p2, [n4]);
      }
      const m4 = ee.get(p2);
      te.has(p2) || (te.set(p2, /* @__PURE__ */ new Map()), ae.set(p2, /* @__PURE__ */ new Map()));
      const f4 = te.get(p2), b3 = ae.get(p2);
      f4.has(o5.typeName) || (f4.set(o5.typeName, m4.shift()), b3.set(o5.typeName, 0));
      const k2 = f4.get(o5.typeName);
      b3.set(o5.typeName, b3.get(o5.typeName) + 1);
      const T2 = new d2({ paths: [k2] });
      if (o5.feature.attributes[n2] = T2, l2.has(o5.typeName)) {
        const e4 = l2.get(o5.typeName);
        e4 == null ? void 0 : e4.set(o5.feature.attributes[a2], o5.feature);
      } else {
        const e4 = /* @__PURE__ */ new Map();
        e4.set(o5.feature.attributes[a2], o5.feature), l2.set(o5.typeName, e4);
      }
      h2.set(o5.feature.attributes[a2], o5.feature);
      const E3 = ot(o5.feature.attributes[n2]);
      this.relationshipLinkChartDiagramLookup.set(o5.feature.attributes[a2], o5.feature.attributes[n2] ? E3 : null);
    }
    for (const a4 of s5) a4.feature.attributes[o] = ((_d = ae.get(a4.feature.attributes[t2] + "-" + a4.feature.attributes[r3])) == null ? void 0 : _d.get(a4.typeName)) ?? null;
    return this._currentLinkChartConfig = { layoutMode: e3, layoutOptions: J }, { nodes: r4, links: l2, idMap: h2 };
  }
  async applyNewLinkChartLayout(e3 = "RADIAL_TREE", t3) {
    const a4 = [];
    await this._calculateLayoutWithSublayerTimeInfo(e3, t3), this.layers.forEach((e4) => {
      a4.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(a4), this._refreshNamedTypes();
  }
  getCurrentNodeLocations() {
    var _a, _b;
    const e3 = /* @__PURE__ */ new Map();
    return (_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.forEach((t3) => {
      var _a2;
      (_a2 = t3 == null ? void 0 : t3.members) == null ? void 0 : _a2.forEach((t4) => {
        const a4 = t4.linkChartLocation;
        let i;
        const n3 = t4.id;
        a4 && (i = "x" in a4 ? { x: a4.x, y: a4.y } : { x: a4.coords[0], y: a4.coords[1] }, e3.set(n3, new j({ x: i.x, y: i.y })));
      });
    }), e3;
  }
  async synchronizeInclusionListWithCache() {
    return new Promise((e3) => {
      var _a;
      (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions.forEach((e4, t3) => {
        if (e4.useAllData = false, e4.members && e4.members.size > 0) {
          if (!this.dataManager.sublayerCaches.get(t3)) return;
          const a4 = new Set(Array.from(this.dataManager.sublayerCaches.get(t3).keys()));
          Array.from(e4.members.keys()).filter((e5) => !a4.has(e5)).forEach((t4) => {
            var _a2;
            (_a2 = e4.members) == null ? void 0 : _a2.delete(t4);
          });
        }
      }), e3();
    });
  }
  async refreshLinkChartCache(e3) {
    await this.dataManager.refreshCacheContent(e3);
    const t3 = [];
    this.layers.forEach((e4) => {
      t3.push(e4.refreshCachedQueryEngine());
    }), await Promise.all(t3), this._refreshNamedTypes();
  }
  async connectBetweenEntities(e3) {
    let t3 = [];
    for (const i of this.dataManager.relationshipTypeNames) {
      const e4 = this.sublayerIdsCache.get(i);
      e4 && (t3 = t3.concat(Array.from(e4.keys())));
    }
    const a4 = await this.dataManager.getRelationshipsBetweenNodes(e3, t3);
    return await this._handleNewRecords(a4), { records: a4 };
  }
  async connectFromEntities(e3) {
    let t3 = [];
    for (const n3 of this.dataManager.relationshipTypeNames) {
      const e4 = this.sublayerIdsCache.get(n3);
      e4 && (t3 = t3.concat(Array.from(e4.keys())));
    }
    let a4 = [];
    for (const n3 of this.dataManager.entityTypeNames) {
      const e4 = this.sublayerIdsCache.get(n3);
      e4 && (a4 = a4.concat(Array.from(e4)));
    }
    const i = await this.dataManager.getRelationshipsFromNodes(e3, a4, t3);
    return await this._handleNewRecords(i), { records: i };
  }
  getCurrentLayout() {
    return this._currentLinkChartConfig.layoutMode;
  }
  async _calculateLayoutWithSublayerTimeInfo(e3 = "RADIAL_TREE", t3) {
    const a4 = /* @__PURE__ */ new Map();
    this.layers.forEach((e4) => {
      a4.set(e4.objectType.name, e4.timeInfo);
    }), await this.calculateLinkChartLayout(e3, { timeInfoByTypeName: a4, ...t3 });
  }
  async _handleNewRecords(e3) {
    const t3 = [];
    this.dataManager.addToLayer(e3);
    for (const i of e3) this.sublayerIdsCache.has(i.typeName) || (this.sublayerIdsCache.set(i.typeName, /* @__PURE__ */ new Set()), t3.push(i.typeName)), this.sublayerIdsCache.get(i.typeName).add(i.id);
    for (const i of t3) {
      const e4 = this._graphTypeLookup.get(i);
      if (e4) {
        const t4 = this._createSublayer(e4);
        "entity" === e4.type ? this.dataManager.entityTypeNames.add(i) : this.dataManager.relationshipTypeNames.add(i), t4.geometryType ? this.layers.push(t4) : this.tables.push(t4), this.dataManager.sublayerCaches.set(i, /* @__PURE__ */ new Map());
      }
    }
    await c(this, t3), await this.dataManager.refreshCacheContent(e3.map((e4) => e4.id));
    const a4 = Object.assign({}, this._currentLinkChartConfig.layoutOptions);
    a4.lockedNodeLocations = /* @__PURE__ */ new Map();
    for (const [i, n3] of this.entityLinkChartDiagramLookup.entries()) n3 && a4.lockedNodeLocations.set(i, new j(n3.coords[0], n3.coords[1]));
    await this.applyNewLinkChartLayout(this._currentLinkChartConfig.layoutMode, a4);
  }
  _createSublayers(e3, t3, a4) {
    e3.forEach((e4) => {
      const i = this._createSublayer(e4);
      a4(i) && t3.push(i), this._updateSublayerCaches(e4);
    });
  }
  _updateSublayers(e3, t3) {
    t3.forEach((t4) => {
      t4.parentCompositeLayer = this;
      const a4 = e3.find((e4) => e4.type === t4.graphType && e4.name === t4.graphTypeName);
      a4 && (t4.objectType = a4, t4.read({ title: a4.name }, { origin: "service" }), this._updateSublayerCaches(a4));
    });
  }
  _updateSublayerCaches(e3) {
    const t3 = this.dataManager.sublayerCaches;
    t3.has(e3.name) || t3.set(e3.name, /* @__PURE__ */ new Map());
  }
  async _initializeDiagram() {
    var _a, _b;
    this.defaultLinkChartConfig ? this.defaultLinkChartConfig.doNotRecalculateLayout ? ((_b = (_a = this.dataManager.inclusionModeDefinition) == null ? void 0 : _a.namedTypeDefinitions) == null ? void 0 : _b.forEach((e3, t3) => {
      var _a2;
      (_a2 = e3 == null ? void 0 : e3.members) == null ? void 0 : _a2.forEach((e4) => {
        const a4 = e4.linkChartLocation;
        let i;
        const n3 = e4.id;
        if (!a4) return;
        i = "x" in a4 ? { x: a4.x, y: a4.y } : { x: a4.coords[0], y: a4.coords[1] };
        const o4 = ot(i);
        this.dataManager.relationshipTypeNames.has(t3) ? this.relationshipLinkChartDiagramLookup.set(n3, o4) : this.entityLinkChartDiagramLookup.set(n3, o4), this.linkChartExtent.xmin > i.x && (this.linkChartExtent.xmin = i.x), this.linkChartExtent.xmax < i.x && (this.linkChartExtent.xmax = i.x), this.linkChartExtent.ymin > i.y && (this.linkChartExtent.ymin = i.y), this.linkChartExtent.ymax < i.y && (this.linkChartExtent.ymax = i.y);
      });
    }), this.memberRelationshipTypes.forEach((e3) => {
      var _a2;
      e3.name && ((_a2 = this.dataManager.sublayerCaches.get(e3.name)) == null ? void 0 : _a2.forEach((e4) => {
        const t3 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[t2]), a4 = this.relationshipLinkChartDiagramLookup.get(e4.attributes[r3]);
        if (t3 && a4) {
          const i = ot(new d2({ paths: [[[t3.coords[0], t3.coords[1]], [a4.coords[0], a4.coords[1]]]] }));
          this.relationshipLinkChartDiagramLookup.set(e4.attributes[a2], i);
        } else this.relationshipLinkChartDiagramLookup.set(e4.attributes[a2], null);
      }));
    })) : await this._calculateLayoutWithSublayerTimeInfo(this.defaultLinkChartConfig.layoutMode, { lockedNodeLocations: this.getCurrentNodeLocations(), ...this.defaultLinkChartConfig.layoutOptions || {} }) : await this._calculateLayoutWithSublayerTimeInfo("RADIAL_TREE", { lockedNodeLocations: this.getCurrentNodeLocations() });
  }
  _refreshNamedTypes() {
    for (const e3 of this.layers) e3.emit("refresh", { dataChanged: true });
    for (const e3 of this.tables) e3.emit("refresh", { dataChanged: true });
  }
  _validateLayoutSettings(e3, t3) {
    const a4 = (e4) => "number" == typeof e4 && !isNaN(e4), n3 = (e4) => a4(e4) && e4 >= 1, o4 = (e4) => a4(e4) && e4 >= 1, s5 = (e4) => Object.values(e2).includes(e4), r4 = (e4) => a4(e4) && e4 >= 0, l2 = { organicLayoutSettings: {}, chronologicalLayoutSettings: {} };
    if (!(/* @__PURE__ */ new Set(["FORCE_DIRECTED", "COMMUNITY", "GEOGRAPHIC", "CHRONOLOGICAL_MULTIPLE", "CHRONOLOGICAL_SINGLE"])).has(e3) || !t3) return l2;
    t3.organicLayoutSettings ?? (t3.organicLayoutSettings = {});
    const { computationBudgetTime: h2, repulsionRadiusMultiplier: d3, idealEdgeLength: u, idealEdgeLengthType: p } = t3.organicLayoutSettings;
    o4(h2) ? l2.organicLayoutSettings.computationBudgetTime = h2 : void 0 !== h2 && n.getLogger(this).warn("Invalid layout computationBudgetTime setting, will revert to default setting"), n3(d3) ? l2.organicLayoutSettings.repulsionRadiusMultiplier = d3 : void 0 !== d3 && n.getLogger(this).warn("Invalid layout repulsionRadiusMultiplier setting, will revert to default setting");
    if ("GEOGRAPHIC" === e3 && (void 0 !== u || void 0 !== p) && (s5(p) ? l2.organicLayoutSettings.idealEdgeLengthType = p : void 0 !== p && n.getLogger(this).warn('Invalid layout idealEdgeLengthType setting, will revert to "multiplier" setting'), r4(u) ? l2.organicLayoutSettings.idealEdgeLength = u : void 0 !== u && n.getLogger(this).warn("Invalid layout idealEdgeLength setting, will revert to default setting")), ("CHRONOLOGICAL_MULTIPLE" === e3 || "CHRONOLOGICAL_SINGLE" === e3) && t3.chronologicalLayoutSettings) {
      const e4 = t3.chronologicalLayoutSettings;
      e4.durationLineWidth && e4.durationLineWidth < 0 && n.getLogger(this).warn("Invalid layout durationLineWidth setting, will revert to default setting");
    }
    return l2;
  }
  _convertLayoutSettingsToCalculationSettings(e3) {
    e3.organicLayoutSettings ?? (e3.organicLayoutSettings = {});
    let t3 = e3.organicLayoutSettings.idealEdgeLength;
    return e3.organicLayoutSettings.idealEdgeLengthType === e2.ABSOLUTE && (void 0 === t3 ? t3 = -1 : t3 *= -1), { computationBudgetTime: e3.organicLayoutSettings.computationBudgetTime, repulsionRadiusMultiplier: e3.organicLayoutSettings.repulsionRadiusMultiplier, idealEdgeLengthMultiplier: t3 };
  }
  _createSublayer(e3) {
    return new ue({ objectType: e3, parentCompositeLayer: this, graphType: e3.type });
  }
  _handleSublayersChange(e3, t3) {
    t3 && (t3.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner")), e3 && (e3.forEach((e4) => {
      e4.parent = this;
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this;
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null;
    })], "sublayers-owner"));
  }
};
r([m()], z.prototype, "dataPreloadedInLocalCache", void 0), r([m()], z.prototype, "defaultLinkChartConfig", void 0), r([m()], z.prototype, "dataManager", void 0), r([m()], z.prototype, "inclusionModeDefinition", null), r([m()], z.prototype, "knowledgeGraph", void 0), r([m({ type: V.ofType(ue), json: { write: { ignoreOrigin: true } } })], z.prototype, "layers", void 0), r([m()], z.prototype, "entityLinkChartDiagramLookup", void 0), r([m()], z.prototype, "relationshipLinkChartDiagramLookup", void 0), r([m()], z.prototype, "linkChartExtent", void 0), r([m()], z.prototype, "memberEntityTypes", void 0), r([m()], z.prototype, "memberRelationshipTypes", void 0), r([m({ type: ["LinkChartLayer"] })], z.prototype, "operationalLayerType", void 0), r([m()], z.prototype, "sublayerIdsCache", void 0), r([m({ type: V.ofType(ue), json: { write: { ignoreOrigin: true } } })], z.prototype, "tables", void 0), r([m({ json: { read: false } })], z.prototype, "type", void 0), r([m({ json: { read: false } })], z.prototype, "chronologicalAuxiliaryGraphics", void 0), z = r([a("esri.layers.LinkChartLayer")], z);
var W = z;
export {
  W as default
};
//# sourceMappingURL=LinkChartLayer-YG6PEMV5.js.map
