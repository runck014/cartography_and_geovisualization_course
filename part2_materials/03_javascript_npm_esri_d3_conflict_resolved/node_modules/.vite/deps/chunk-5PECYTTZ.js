import {
  n2 as n3
} from "./chunk-KDQTUT24.js";
import {
  o as o5
} from "./chunk-CKPBZSTT.js";
import {
  A,
  B2,
  B3,
  C2,
  C3,
  C4,
  C5,
  Ct,
  D as D3,
  D3 as D4,
  Dt,
  E as E3,
  F as F3,
  F2 as F4,
  G as G2,
  G2 as G3,
  Gt,
  H as H2,
  H2 as H3,
  H3 as H4,
  I as I3,
  In,
  Jn,
  K,
  Mt,
  O as O2,
  P as P2,
  P2 as P3,
  P3 as P4,
  Pt,
  R,
  S,
  S2,
  S3,
  Sn,
  T,
  U as U2,
  Un,
  Ut,
  Y,
  Yt,
  Z,
  Zn,
  _ as _3,
  _2 as _4,
  a as a2,
  bn,
  c,
  d as d2,
  d2 as d3,
  e as e2,
  ee as ee2,
  f,
  f2,
  g,
  g2,
  gt,
  h,
  h2,
  h3,
  h4,
  hn,
  i as i5,
  j,
  j2,
  jn,
  jt,
  l as l2,
  l2 as l3,
  le,
  ln,
  m as m3,
  m2 as m4,
  mt,
  n as n2,
  ne,
  nn,
  nt,
  o as o2,
  o2 as o3,
  o3 as o4,
  p as p2,
  p2 as p3,
  q,
  q2,
  q3,
  q4,
  r as r3,
  re,
  t as t3,
  tn,
  tt,
  u as u2,
  v,
  v2,
  w,
  w2,
  x as x2,
  x2 as x3,
  xt,
  yt,
  z2,
  zn
} from "./chunk-OXCT6NNS.js";
import {
  c as c2,
  t as t4
} from "./chunk-J3GKRP7Y.js";
import {
  i as i3,
  s as s3,
  x
} from "./chunk-DPVSO6BH.js";
import {
  ee
} from "./chunk-5VEO4IUH.js";
import {
  E as E2
} from "./chunk-U6IFI7EK.js";
import {
  t as t2
} from "./chunk-AHZHHHCW.js";
import {
  i as i4
} from "./chunk-2RIHQI4N.js";
import {
  i as i2
} from "./chunk-VLKWWBLY.js";
import {
  m
} from "./chunk-CGSFKZP2.js";
import {
  E as E4,
  L as L3,
  M,
  S as S4,
  c as c3,
  e as e3,
  f as f3,
  h as h5,
  m as m5,
  p as p4,
  w as w3,
  y
} from "./chunk-F3ZOBTPK.js";
import {
  t as t5
} from "./chunk-EZCH3ZAJ.js";
import {
  _ as _2
} from "./chunk-G6LMYOSA.js";
import {
  m as m2,
  p
} from "./chunk-QJXYURT2.js";
import {
  D as D2,
  H,
  I as I2,
  L as L2,
  a,
  mi
} from "./chunk-CGJUTDVJ.js";
import {
  i,
  s as s2
} from "./chunk-D6FJTDNK.js";
import {
  B,
  C,
  D,
  E,
  F as F2,
  G,
  I,
  L,
  O,
  P,
  U,
  _
} from "./chunk-KV3S4QI2.js";
import {
  o,
  u
} from "./chunk-YVSEBNS4.js";
import {
  z
} from "./chunk-E2I7HYXQ.js";
import {
  e,
  r
} from "./chunk-MV5XBD6C.js";
import {
  d
} from "./chunk-GRW2QIBT.js";
import {
  r as r2
} from "./chunk-R2PAF6JT.js";
import {
  l2 as l,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F,
  has,
  t
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/definitions.js
var T2 = { [C.BYTE]: 1, [C.UNSIGNED_BYTE]: 1, [C.SHORT]: 2, [C.UNSIGNED_SHORT]: 2, [C.HALF_FLOAT]: 2, [C.INT]: 4, [C.UNSIGNED_INT]: 4, [C.FLOAT]: 4 };

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/Mesh.js
var i6 = class {
  constructor(t13, i10) {
    var _a;
    this._boundPart = null, this.vertexBuffers = /* @__PURE__ */ new Map();
    for (const [s8, n12] of Object.entries(i10.vertex)) {
      const o12 = E2.createVertex(t13, F2.STATIC_DRAW, n12);
      this.vertexBuffers.set(s8, o12);
    }
    const a6 = /* @__PURE__ */ new Map();
    for (const [s8, n12] of Object.entries(i10.index ?? {})) {
      const o12 = E2.createIndex(t13, F2.STATIC_DRAW, n12);
      a6.set(s8, o12);
    }
    this.groups = [];
    for (const e5 of i10.groups) {
      let r5;
      if (null != e5.index) {
        if (!((_a = i10.index) == null ? void 0 : _a[e5.index])) throw new Error("No index data.");
        const { BYTES_PER_ELEMENT: t14 } = i10.index[e5.index];
        2 === t14 ? r5 = C.UNSIGNED_SHORT : 4 === t14 && (r5 = C.UNSIGNED_INT);
      }
      const d10 = null != e5.index ? a6.get(e5.index) : null, u11 = /* @__PURE__ */ new Map(), c8 = /* @__PURE__ */ new Map();
      for (const t14 of e5.attributes) {
        const { name: e6, count: r6, type: s8, offset: n12, normalized: i11, divisor: a7, stride: d11, vertex: f13, location: l8 } = t14;
        let p14 = c8.get(f13);
        p14 || (p14 = [], c8.set(f13, p14));
        const h10 = new t2(e6, r6, s8, n12, d11, i11, a7);
        p14.push(h10), u11.set(e6, l8);
      }
      const f12 = new o5(t13, u11, c8, this.vertexBuffers, d10);
      this.groups.push({ ...e5, vertexArray: f12, locations: u11, layout: c8, indexing: r5 });
    }
    this.parts = i10.parts;
  }
  bind(t13, e5) {
    this._boundPart = e5;
    const { group: r5 } = this.parts[this._boundPart], { vertexArray: s8 } = this.groups[r5];
    t13.bindVAO(s8);
  }
  draw(e5) {
    if (null == this._boundPart) throw new Error("Mesh.bind() has not been called.");
    const { start: r5, count: s8 } = this.parts[this._boundPart], { group: n12 } = this.parts[this._boundPart], { indexing: o12, primitive: i10 } = this.groups[n12];
    o12 ? e5.drawElements(i10, s8, o12, r5 * T2[o12]) : e5.drawArrays(i10, r5, s8);
  }
  unbind(t13) {
    this._boundPart = null, t13.bindVAO(null);
  }
  destroy() {
    for (const { vertexArray: t13 } of this.groups) t13.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/meshing/SimpleMesh.js
var n4 = { position: { type: C.SHORT, count: 2 } };
var o6 = class _o extends i6 {
  static create(e5, i10, r5) {
    const n12 = [];
    let { stride: s8 } = i10;
    if (null == s8) {
      s8 = 0;
      for (const [e6, { count: r6, type: n13, offset: o12 }] of Object.entries(i10.layout)) {
        if (null != o12) throw new Error("Stride cannot be computed automatically when attribute offsets are supplied explicitly.");
        s8 += r6 * T2[n13];
      }
    }
    let a6 = 0;
    for (const [o12, { count: f12, offset: d10, type: m16, normalized: x8 }] of Object.entries(i10.layout)) {
      null != d10 && (a6 = d10);
      const e6 = r5.get(o12);
      if (null == e6) throw new Error("Locations must be specified at mesh initialization.");
      const i11 = { name: o12, location: e6, vertex: "vertexData", count: f12, type: m16, offset: a6, stride: s8, divisor: 0, normalized: null != x8 && x8 };
      n12.push(i11), a6 += f12 * T2[m16];
    }
    const l8 = { attributes: n12, primitive: i10.primitive };
    null != i10.index && (l8.index = "indexData");
    let { count: u11 } = i10;
    if (null == u11 && (u11 = i10.index ? i10.index.length : i10.vertex.byteLength / s8, Math.floor(u11) !== u11)) throw new Error(`The byte length of vertex data must be an exact multiple of the stride, which is ${s8}.`);
    const c8 = { start: 0, count: u11, group: 0, primitive: i10.primitive }, p14 = { vertex: { vertexData: i10.vertex }, parts: [c8], groups: [l8] };
    return null != i10.index && (p14.index = { indexData: i10.index }), new _o(e5, p14, i10.layout);
  }
  static fromVertexStream(t13, e5) {
    return _o.create(t13, { primitive: E.TRIANGLE_STRIP, vertex: new Uint16Array(e5), layout: n4 }, /* @__PURE__ */ new Map([["position", 0]]));
  }
  constructor(t13, e5, i10) {
    super(t13, e5), this._spec = i10;
  }
  bind(t13, e5 = 0) {
    super.bind(t13, e5);
  }
};

// node_modules/@arcgis/core/symbols/cim/animationDebugFlags.js
var e4 = class {
  get forceStaticPath() {
    return "disabled" === has("esri-cim-animations-enable-status");
  }
  get forceAnimatedPath() {
    return "forced" === has("esri-cim-animations-enable-status");
  }
  get freezeGlobalTime() {
    const e5 = has("esri-cim-animations-freeze-time");
    return e5 ?? false;
  }
  get spotlightAnimatedSymbols() {
    return !!has("esri-cim-animations-spotlight");
  }
  get forceGlobalTimeOrigin() {
    return false !== has("esri-cim-animations-freeze-time");
  }
};
var t6 = new e4();

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimationUniformInfo.js
var d4 = class extends P2 {
};
r([g(j)], d4.prototype, "globalTime", void 0), r([g(C2)], d4.prototype, "animationTextureSize", void 0), r([g(S)], d4.prototype, "animationTexture", void 0), r([g(tt)], d4.prototype, "toScreen", void 0), r([g(tt)], d4.prototype, "toNdc", void 0), r([g(j)], d4.prototype, "mapRotation", void 0), r([g(j)], d4.prototype, "pixelRatio", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/VisualVariableRotation.js
var d5 = class extends P2 {
  getVVRotationMat4(t13) {
    return xt(w2(t13), nt.identity(), () => {
      const e5 = this.getNormalizedAngle(t13).multiply(t3), r5 = Zn(e5), o12 = nn(e5);
      return new nt(o12, r5, 0, 0, r5.multiply(new j(-1)), o12, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    });
  }
  getVVRotationMat3(t13) {
    return xt(w2(t13), tt.identity(), () => {
      const e5 = this.getNormalizedAngle(t13).multiply(t3), r5 = Zn(e5), o12 = nn(e5);
      return new tt(o12, r5, 0, r5.multiply(new j(-1)), o12, 0, 0, 0, 1);
    });
  }
  getNormalizedAngle(t13) {
    const e5 = Ut(this.rotationType, new j(i5.Arithmatic));
    return xt(e5, new j(90).subtract(t13), t13);
  }
};
r([g(j)], d5.prototype, "rotationType", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedShader.js
var A2 = class extends S2 {
};
r([h(3, H3)], A2.prototype, "animationPointerAndBaseSizeAndReferenceSize", void 0), r([h(4, C2)], A2.prototype, "zoomRange", void 0);
var L4 = class extends F4 {
};
var U3 = class extends P3 {
  _getScreenPosition(i10) {
    const { pos: t13, translation: o12, rotation: e5, scale: r5, offset: a6, id: p14, vvScale: d10 } = i10, c8 = o4(this, p14).multiply(Math.PI / 180), y5 = o12.x.multiply(4 / 3), f12 = o12.y.multiply(-1).multiply(4 / 3), h10 = Zn(e5.subtract(c8)), S7 = nn(e5.subtract(c8)), b7 = new j(0), g7 = new j(1), { pixelRatio: V4 } = this.animationInfo, v6 = new tt(g7, b7, b7, b7, g7, b7, y5.multiply(V4), f12.multiply(V4), g7), w7 = new tt(S7, h10.multiply(-1), b7, h10, S7, b7, 0, 0, g7), x8 = r5.multiply(d10).multiply(V4).multiply(4 / 3), j4 = w7.multiply(x8), z6 = this.animationInfo.toScreen.multiply(new G3(t13, 1)), T4 = v6.multiply(z6).xy, _7 = j4.multiply(new G3(a6, 0)).xy;
    return T4.add(_7);
  }
  _clip(i10, o12) {
    let e5 = super.clip(i10, o12);
    const r5 = Ct(this._getLocalTimeOrigin(i10), new j(0));
    return t6.forceGlobalTimeOrigin || (e5 = e5.add(gt([r5, () => new j(2)], [true, () => new j(0)]))), e5;
  }
  _getLocalTimeOrigin(i10) {
    return this.storage.getLocalTimeOrigin(i10);
  }
  _toNdc(i10) {
    return this.animationInfo.toNdc.multiply(new G3(i10, 1)).xy;
  }
  _getEvalParams(i10, t13) {
    const { globalTime: o12, animationTextureSize: e5, animationTexture: r5 } = this.animationInfo;
    return { globalTime: o12, localTimeOrigin: this._getLocalTimeOrigin(i10.id), animationTextureSize: e5, animationTexture: r5, pixelDimensions: t13 };
  }
  _getColor(i10, t13) {
    return xt(Ut(t13.isSDF, new j(1)), this._getSDFColor(i10, t13), this._getSpriteColor(i10, t13));
  }
  _getSpriteColor(i10, t13) {
    return le(this.mosaicInfo.texture, i10).multiply(t13.color);
  }
  _getSDFColor(i10, t13) {
    const o12 = le(this.mosaicInfo.texture, i10), e5 = new j(0.5).subtract(B2(o12)).multiply(t13.distanceToPx).multiply(o3), r5 = tn(new j(0.5).subtract(e5), new j(0), new j(1)), a6 = t13.color.multiply(r5), s8 = t13.outlineSize.multiply(0.5), l8 = Yt(e5).subtract(s8), m16 = tn(new j(0.5).subtract(l8), new j(0), new j(1)), u11 = t13.outlineColor.multiply(m16);
    return new j(1).subtract(u11.a).multiply(a6).add(u11);
  }
};
function E5(i10, t13, e5) {
  const r5 = i10.add(new C2(t13, 0)), a6 = le(e5.animationTexture, r5.add(0.5).divide(e5.animationTextureSize)).xy;
  return i10 = i10.add(a6), mt({ animationPointer: i10, ...e5 }, H3, null, (i11) => {
    const { out: t14 } = i11;
    if (!t14) throw new Error("out is null");
    return x3({ ...i11, out: t14 });
  });
}
r([g(p2)], U3.prototype, "mosaicInfo", void 0), r([g(d4)], U3.prototype, "animationInfo", void 0), r([_3(f)], U3.prototype, "visualVariableColor", void 0), r([_3(h4)], U3.prototype, "visualVariableOpacity", void 0), r([_3(m4)], U3.prototype, "visualVariableSizeMinMaxValue", void 0), r([_3(p3)], U3.prototype, "visualVariableSizeScaleStops", void 0), r([_3(f2)], U3.prototype, "visualVariableSizeStops", void 0), r([_3(l3)], U3.prototype, "visualVariableSizeUnitValue", void 0), r([_3(d5)], U3.prototype, "visualVariableRotation", void 0);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/enums.js
var o7;
!function(o12) {
  o12[o12.transform = 0] = "transform", o12[o12.fromColor = 1] = "fromColor", o12[o12.toColor = 2] = "toColor", o12[o12.colorMix = 3] = "colorMix", o12[o12.toOpacity = 4] = "toOpacity", o12[o12.opacityMix = 5] = "opacityMix";
}(o7 || (o7 = {}));

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMarkerShader.js
var W = class extends A2 {
};
r([h(5, C2)], W.prototype, "offset", void 0), r([h(6, C2)], W.prototype, "uv", void 0), r([h(7, H3)], W.prototype, "sizing", void 0), r([h(8, j)], W.prototype, "angle", void 0);
var B4 = class extends C3 {
};
r([h(12, C2)], B4.prototype, "offsetNextVertex1", void 0), r([h(13, C2)], B4.prototype, "offsetNextVertex2", void 0), r([h(14, C2)], B4.prototype, "textureUVNextVertex1", void 0), r([h(15, C2)], B4.prototype, "textureUVNextVertex2", void 0);
var E6 = class extends L4 {
};
function G4(t13, e5, i10, s8) {
  return e5.multiply(t13.x).add(i10.multiply(t13.y)).add(s8.multiply(t13.z));
}
var H5 = class extends U3 {
  constructor() {
    super(...arguments), this.computeAttributes = { offset: ["offsetNextVertex1", "offsetNextVertex2"], uv: ["textureUVNextVertex1", "textureUVNextVertex2"] };
  }
  _vertexPreamble(t13) {
    const { id: e5, pos: i10, offset: s8, animationPointerAndBaseSizeAndReferenceSize: o12, uv: r5, sizing: p14, angle: h10 } = t13, c8 = o12.xy, x8 = o12.z, y5 = o12.w, v6 = p14.xy, f12 = p14.z, w7 = h2(t13.bitset, o2.bitset.isStroke), b7 = p14.w, S7 = h2(t13.bitset, o2.bitset.scaleSymbolsProportionally), g7 = this._getEvalParams(t13, v6), z6 = E5(c8, o7.transform, g7), P6 = gt([Ut(h2(t13.bitset, o2.bitset.isMapAligned), new j(1)), this.view.rotation.divide(180).multiply(Math.PI)], [true, new j(0)]), _7 = new Z(nn(P6), Zn(P6.multiply(-1)), Zn(P6), nn(P6)).multiply(z6.xy), V4 = z6.z.subtract(P6).subtract(h10.multiply(c)), C7 = z6.w, j4 = h2(t13.bitset, o2.bitset.isSDF), F8 = l2(this, e5, new j(y5)).divide(new j(y5));
    return { baseSize: x8, animationPointer: c8, strokeWidth: f12, isOutline: w7, unscaledDistanceToPx: b7, scaleSymbolsProportionally: S7, isSDF: j4, position: this._getScreenPosition({ id: e5, pos: i10, offset: s8, referenceSize: y5, translation: _7, rotation: V4, scale: C7, vvScale: F8 }), uv: r5, evalParams: g7, vvScale: F8, scale: C7 };
  }
  vertex(t13, e5) {
    const { position: i10, animationPointer: s8, evalParams: o12, isOutline: r5, unscaledDistanceToPx: l8, vvScale: n12, uv: d10, strokeWidth: m16, scaleSymbolsProportionally: u11, scale: v6, isSDF: f12, baseSize: w7 } = this._vertexPreamble(t13), b7 = this._toNdc(i10);
    let S7 = E5(s8, o7.fromColor, o12);
    S7 = new H3(S7.rgb.multiply(S7.a), S7.a);
    let g7 = E5(s8, o7.toColor, o12);
    g7 = new H3(g7.rgb.multiply(g7.a), g7.a);
    let z6 = E5(s8, o7.colorMix, o12);
    z6 = new H3(z6.rgb.multiply(z6.a), z6.a);
    const P6 = E5(s8, o7.toOpacity, o12).a, _7 = E5(s8, o7.opacityMix, o12).a, V4 = r3(this, t13.id, S7, Mt(v2(t13.bitset, o2.bitset.colorLocked), new Y(r5))), C7 = jn(V4, g7, z6), D6 = n2(this, t13.id), j4 = jn(D6, P6, _7), F8 = C7.multiply(j4), R3 = this.clip(t13.id, t13.zoomRange), U4 = l8.multiply(n12);
    return { glPosition: new H3(b7, R3, 1), uv: d10.divide(this.mosaicInfo.size), color: F8.multiply(new j(1).subtract(r5)), outlineColor: F8.multiply(r5), distanceToPx: U4, strokeWidth: m16.multiply(jn(new j(1), v6, u11)), isOutline: r5, isSDF: f12, ...this.maybeRunHittest(t13, e5, { pos: t13.pos, size: w7, sizeCorrection: new j(1), isMapAligned: new j(1), vvRotationMat3: new tt(1, 0, 0, 0, 1, 0, 0, 0, 1), placementMat3: new tt(1, 0, 0, 0, 1, 0, 0, 0, 1), outlineSize: new j(1), distanceToPx: U4, isSDF: f12 }) };
  }
  fragment(t13) {
    let e5 = this._getColor(t13.uv, { color: t13.color, distanceToPx: t13.distanceToPx, isSDF: t13.isSDF, outlineColor: t13.outlineColor, outlineSize: t13.strokeWidth });
    return t6.spotlightAnimatedSymbols && (e5 = e5.add(new H3(0, 0.3, 0, 0.3))), this.getFragmentOutput(e5, t13);
  }
  hittest(t13, e5, i10) {
    return xt(jt(i10.size, this.hittestRequest.smallSymbolSizeThreshold), this._hittestSmallMarker(t13, e5, i10), this._hittestMarker(t13, e5, i10));
  }
  _hittestSmallMarker(t13, e5, i10) {
    const { position: s8, distance: o12, smallSymbolDistance: r5 } = this.hittestRequest, l8 = o12.subtract(r5), { viewMat3: a6, tileMat3: n12 } = this.view, d10 = a6.multiply(n12).multiply(new G3(i10.pos, 1)).xy, m16 = i10.size.multiply(0.5);
    return ln(d10, s8).subtract(m16).add(l8);
  }
  _hittestMarker(t13, e5, i10) {
    const s8 = this._vertexPreamble({ ...t13 }).position, o12 = this._vertexPreamble({ ...t13, offset: e5.offsetNextVertex1, uv: e5.textureUVNextVertex1 }).position, r5 = this._vertexPreamble({ ...t13, offset: e5.offsetNextVertex2, uv: e5.textureUVNextVertex2 }).position, l8 = this.hittestRequest.position, a6 = this.hittestRequest.distance, n12 = P4(l8, s8, o12, r5);
    return xt(Gt(n12, a6), n12, this._hittestSamples(s8, o12, r5, t13, e5, i10));
  }
  _hittestSamples(t13, e5, i10, s8, o12, r5) {
    const { outlineSize: l8, isSDF: n12, distanceToPx: d10 } = r5, m16 = this.hittestRequest.position, u11 = this.hittestRequest.distance, h10 = h3(m16.add(new C2(yt(u11), yt(u11))), t13, e5, i10), c8 = h3(m16.add(new C2(0, yt(u11))), t13, e5, i10), x8 = h3(m16.add(new C2(u11, yt(u11))), t13, e5, i10), y5 = h3(m16.add(new C2(yt(u11), 0)), t13, e5, i10), v6 = h3(m16, t13, e5, i10), f12 = h3(m16.add(new C2(u11, 0)), t13, e5, i10), w7 = h3(m16.add(new C2(yt(u11), u11)), t13, e5, i10), b7 = h3(m16.add(new C2(0, u11)), t13, e5, i10), S7 = h3(m16.add(new C2(u11, u11)), t13, e5, i10), _7 = s8.uv.divide(this.mosaicInfo.size), V4 = o12.textureUVNextVertex1.divide(this.mosaicInfo.size), C7 = o12.textureUVNextVertex2.divide(this.mosaicInfo.size), N = { color: new H3(1, 1, 1, 1), outlineSize: l8, outlineColor: new H3(1, 1, 1, 1), isSDF: n12, distanceToPx: d10 };
    let M3 = new j(0);
    return M3 = M3.add(g2(h10).multiply(this._getColor(G4(h10, _7, V4, C7), N).a)), M3 = M3.add(g2(c8).multiply(this._getColor(G4(c8, _7, V4, C7), N).a)), M3 = M3.add(g2(x8).multiply(this._getColor(G4(x8, _7, V4, C7), N).a)), M3 = M3.add(g2(y5).multiply(this._getColor(G4(y5, _7, V4, C7), N).a)), M3 = M3.add(g2(v6).multiply(this._getColor(G4(v6, _7, V4, C7), N).a)), M3 = M3.add(g2(f12).multiply(this._getColor(G4(f12, _7, V4, C7), N).a)), M3 = M3.add(g2(w7).multiply(this._getColor(G4(w7, _7, V4, C7), N).a)), M3 = M3.add(g2(b7).multiply(this._getColor(G4(b7, _7, V4, C7), N).a)), M3 = M3.add(g2(S7).multiply(this._getColor(G4(S7, _7, V4, C7), N).a)), re(M3, new j(0.05)).multiply(q3(this.hittestRequest));
  }
};
r([e(0, m3(W)), e(1, m3(B4))], H5.prototype, "vertex", null), r([e(0, m3(E6))], H5.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/Technique.js
var t7 = class {
  constructor() {
    this.drawPhase = E4.MAP | E4.HITTEST | E4.HIGHLIGHT | E4.DEBUG;
  }
  startup() {
  }
  shutdown(s8) {
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureTechnique.js
var t8 = class extends t7 {
  constructor() {
    super(...arguments), this.symbologyPlane = S4.FILL, this._input = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedTechnique.js
var u3 = class extends t8 {
  render(a6, u11) {
    const { context: f12, painter: c8 } = a6, { target: l8 } = u11, { freezeGlobalTime: p14 } = t6, g7 = 0, x8 = c8.textureManager.animationStore.getTexture(f12, g7), d10 = [2 / a6.state.size[0], 0, 0, 0, -2 / a6.state.size[1], 0, -1, 1, 1], h10 = Array.from(s2(e3(), d10)), b7 = Array.from(i(e3(), h10, l8.transforms.displayViewScreenMat3)), T4 = u11.instance.getInput();
    c8.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(a6, u11.target, T4.uniforms), ...h5(a6, u11.target), mosaicInfo: c8.textureManager.getMosaicInfo(f12, u11.textureKey, true), animationInfo: { globalTime: false === p14 ? a6.time / 1e3 : p14, animationTextureSize: [x8.descriptor.width, x8.descriptor.height], animationTexture: { unit: 6, texture: x8 }, toScreen: b7, toNdc: d10, mapRotation: a6.state.rotation, pixelRatio: a6.state.pixelRatio } }, defines: { ...y(a6) }, optionalAttributes: { zoomRange: true }, useComputeBuffer: true }), c8.setPipelineState({ ...M(a6) }), c8.submitDraw(a6, u11), false === p14 && l8.requestRender();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/animated/AnimatedMarkerTechnique.js
var s4 = class extends u3 {
  constructor() {
    super(...arguments), this.type = e2.AnimatedMarker, this.shaders = { geometry: new H5() };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/utils.js
function o8(o12) {
  return o12.locationsMap;
}
var t9 = { color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityPointShader.js
var z3 = class extends I3 {
};
r([h(0, C2)], z3.prototype, "pos", void 0);
var F5 = class extends F4 {
};
var R2 = class extends P2 {
};
r([g(j)], R2.prototype, "dotSize", void 0);
var b = class extends P2 {
};
r([g(S)], b.prototype, "locations", void 0), r([g(j)], b.prototype, "pixelRatio", void 0), r([g(j)], b.prototype, "tileZoomFactor", void 0);
var P5 = 1e-6;
var C6 = class extends j2 {
  vertex(t13) {
    const o12 = new tt(1, 0, 0, 0, -1, 0, 0, 1, 1).multiply(new G3(t13.pos.xy.divide(a), 1)), i10 = le(this.draw.locations, o12.xy), s8 = Un(this.instance.dotSize.divide(2), new j(1));
    let r5 = new j(0);
    r5 = r5.add(re(i10.a, new j(P5)).multiply(2));
    let d10 = s8.add(this.instance.dotSize);
    const n12 = this.view.displayViewScreenMat3.multiply(new G3(t13.pos.add(0.5), 1)), a6 = new H3(n12.xy, r5, 1), l8 = this.instance.dotSize.divide(d10), h10 = new j(-1).divide(s8.divide(d10));
    return d10 = d10.multiply(this.draw.pixelRatio.multiply(this.draw.tileZoomFactor)), { glPosition: a6, glPointSize: d10, color: i10, ratio: l8, invEdgeRatio: h10 };
  }
  fragment(t13) {
    const o12 = zn(t13.glPointCoord.subtract(0.5)).multiply(2), e5 = ne(new j(0), new j(1), t13.invEdgeRatio.multiply(o12.subtract(t13.ratio)).add(1)), i10 = new w();
    return i10.glFragColor = t13.color.multiply(e5), i10;
  }
};
r([g(R2)], C6.prototype, "instance", void 0), r([g(b)], C6.prototype, "draw", void 0), r([g(d2)], C6.prototype, "view", void 0), r([e(0, m3(z3))], C6.prototype, "vertex", null), r([e(0, m3(F5))], C6.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityPolygonShader.js
var D5 = class extends S2 {
};
r([h(3, j)], D5.prototype, "inverseArea", void 0);
var V = class extends P2 {
};
r([g(U2.ofType(H3, 2))], V.prototype, "isActive", void 0), r([g(U2.ofType(H3, 8))], V.prototype, "colors", void 0), r([g(j)], V.prototype, "dotValue", void 0);
var F6 = class extends P2 {
};
r([g(S)], F6.prototype, "dotTexture0", void 0), r([g(S)], F6.prototype, "dotTexture1", void 0), r([g(j)], F6.prototype, "tileZoomFactor", void 0), r([g(j)], F6.prototype, "pixelRatio", void 0), r([g(j)], F6.prototype, "tileDotsOverArea", void 0);
var _5 = class extends P3 {
  _dotThreshold(t13, e5, o12) {
    return t13.divide(e5).divide(o12);
  }
  vertex(t13) {
    const e5 = new tt(2 / a, 0, 0, 0, -2 / a, 0, -1, 1, 1).multiply(new G3(t13.pos, 1)), s8 = this.clip(t13.id), i10 = new H3(e5.xy, s8, 1), r5 = this.storage.getVVData(t13.id).multiply(this.instance.isActive.get(0)).multiply(t13.inverseArea), l8 = this.storage.getDataDrivenData0(t13.id).multiply(this.instance.isActive.get(1)).multiply(t13.inverseArea), d10 = this.draw.tileZoomFactor.multiply(a).divide(this.draw.pixelRatio), a6 = this._dotThreshold(r5, this.instance.dotValue, this.draw.tileDotsOverArea), n12 = this._dotThreshold(l8, this.instance.dotValue, this.draw.tileDotsOverArea), u11 = t13.pos.add(0.5).divide(d10);
    return { glPosition: i10, color: new H3(0, 0, 0, 0), textureCoords: u11, thresholds0: a6, thresholds1: n12 };
  }
  fragment(t13) {
    const e5 = new w(), o12 = le(this.draw.dotTexture0, t13.textureCoords), s8 = le(this.draw.dotTexture1, t13.textureCoords), i10 = t13.thresholds0.subtract(o12), r5 = t13.thresholds1.subtract(s8);
    let l8;
    const a6 = nt.fromColumns(this.instance.colors[0], this.instance.colors[1], this.instance.colors[2], this.instance.colors[3]), n12 = nt.fromColumns(this.instance.colors[4], this.instance.colors[5], this.instance.colors[6], this.instance.colors[7]);
    if (this.blending) {
      const t14 = re(new j(0), i10), e6 = re(new j(0), r5), o13 = hn(t14, i10).add(hn(e6, r5)), s9 = re(o13, new j(0)), d10 = new j(1).subtract(s9), p14 = o13.add(s9), h10 = i10.multiply(t14).divide(p14), c8 = r5.multiply(e6).divide(p14), u11 = a6.multiply(h10).add(n12.multiply(c8));
      l8 = d10.multiply(u11);
    } else {
      const t14 = Un(C4(i10), C4(r5)), e6 = re(t14, new j(0)), o13 = new j(1).subtract(e6), s9 = re(t14, i10), d10 = re(t14, r5), p14 = a6.multiply(s9).add(n12.multiply(d10));
      l8 = o13.multiply(p14);
    }
    return e5.glFragColor = l8, e5;
  }
  hittest(t13) {
    return q3(this.hittestRequest);
  }
};
r([K], _5.prototype, "blending", void 0), r([g(V)], _5.prototype, "instance", void 0), r([g(F6)], _5.prototype, "draw", void 0), r([e(0, m3(D5))], _5.prototype, "vertex", null), r([e(0, m3(F4))], _5.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityResources.js
var p5 = { pos: { count: 2, type: C.UNSIGNED_SHORT } };
var f4 = class {
  constructor() {
    this._dotTextureSize = 0, this._dotTextures = null, this._dotMesh = null;
  }
  destroy() {
    this._disposeTextures(), this._dotFBO && this._dotFBO.dispose(), this._dotMesh && this._dotMesh.destroy();
  }
  getFBO(t13) {
    if (null == this._dotFBO) {
      const s8 = a, o12 = a, h10 = new p(s8, o12);
      h10.samplingMode = L.NEAREST, h10.wrapMode = D.CLAMP_TO_EDGE;
      const d10 = new s3(t13, new i3(B.DEPTH_STENCIL, s8, o12));
      this._dotFBO = new x(t13, h10, d10);
    }
    return this._dotFBO;
  }
  getDotDensityMesh(t13, o12) {
    if (null == this._dotMesh) {
      const r5 = a, i10 = r5 * r5, n12 = 2, d10 = new Int16Array(i10 * n12);
      for (let t14 = 0; t14 < r5; t14++) for (let e5 = 0; e5 < r5; e5++) d10[n12 * (e5 + t14 * r5)] = e5, d10[n12 * (e5 + t14 * r5) + 1] = t14;
      this._dotMesh = o6.create(t13, { primitive: E.POINTS, vertex: d10, count: i10, layout: p5 }, o12);
    }
    return this._dotMesh;
  }
  getDotDensityTextures(e5, s8, o12) {
    if (this._dotTextureSize === s8 && this._seed === o12 || (this._disposeTextures(), this._dotTextureSize = s8, this._seed = o12), null === this._dotTextures) {
      const r5 = new t(o12);
      this._dotTextures = [this._allocDotDensityTexture(e5, s8, r5), this._allocDotDensityTexture(e5, s8, r5)];
    }
    return this._dotTextures;
  }
  _disposeTextures() {
    if (this._dotTextures) {
      for (let t13 = 0; t13 < this._dotTextures.length; t13++) this._dotTextures[t13].dispose();
      this._dotTextures = null;
    }
  }
  _allocDotDensityTexture(t13, e5, s8) {
    const o12 = new Float32Array(e5 * e5 * 4);
    for (let r5 = 0; r5 < o12.length; r5++) o12[r5] = s8.getFloat();
    const i10 = new p();
    return i10.dataType = U.FLOAT, i10.samplingMode = L.NEAREST, i10.width = e5, i10.height = e5, new m2(t13, i10, o12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/dotDensity/DotDensityTechnique.js
var g3 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.DotDensity, this.shaders = { polygon: new _5(), point: new C6(), fill: new x2() }, this._resources = /* @__PURE__ */ new Map();
  }
  render(e5, t13) {
    p4(e5) || f3(e5) ? this._renderPolygons(e5, t13) : this._renderDotDensity(e5, t13);
  }
  _renderPolygons(e5, t13) {
    const { painter: i10 } = e5;
    i10.setShader({ shader: this.shaders.fill, uniforms: { ...h5(e5, t13.target), visualVariableColor: null, visualVariableOpacity: null }, defines: { ...y(e5) }, optionalAttributes: { zoomRange: false }, useComputeBuffer: f3(e5) }), i10.setPipelineState(M(e5)), i10.submitDraw(e5, t13);
  }
  _renderDotDensity(r5, s8) {
    const { context: n12, painter: c8, requiredLevel: p14 } = r5, h10 = s8.instance.getInput().uniforms, m16 = this._getOrCreateResourcesRecord(n12), f12 = m16.getDotDensityTextures(n12, a, h10.seed), g7 = 1 / 2 ** (p14 - s8.target.key.level), x8 = a, D6 = x8 * window.devicePixelRatio * x8 * window.devicePixelRatio, y5 = 1 / g7 * (1 / g7), b7 = h10.dotScale ? r5.state.scale / h10.dotScale : 1, R3 = h10.dotValue * b7 * y5;
    c8.setShader({ shader: this.shaders.polygon, uniforms: { ...h5(r5, s8.target), instance: { isActive: h10.isActive, colors: h10.colors, dotValue: Math.max(1, R3) }, draw: { dotTexture0: { unit: H, texture: f12[0] }, dotTexture1: { unit: I2, texture: f12[1] }, tileZoomFactor: g7, pixelRatio: window.devicePixelRatio, tileDotsOverArea: D6 / (a * window.devicePixelRatio * a * window.devicePixelRatio) } }, defines: { ...y(r5), blending: h10.blending }, optionalAttributes: {}, useComputeBuffer: false });
    const v6 = n12.getViewport();
    n12.setViewport(0, 0, a, a);
    const P6 = n12.getBoundFramebufferObject(), S7 = m16.getFBO(n12);
    n12.bindFramebuffer(S7), n12.setClearColor(0, 0, 0, 0), n12.clear(_.COLOR), c8.setPipelineState({ color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false }), c8.updatePipelineState(n12), c8.submitDraw(r5, s8), n12.bindFramebuffer(P6), n12.setViewport(v6.x, v6.y, v6.width, v6.height);
    const j4 = m16.getFBO(n12).colorTexture, _7 = { shader: this.shaders.point, uniforms: { view: c3(r5, s8.target), instance: { dotSize: h10.dotSize }, draw: { locations: { unit: H, texture: j4 }, tileZoomFactor: 1, pixelRatio: window.devicePixelRatio } }, defines: { ...y(r5) }, optionalAttributes: {}, useComputeBuffer: false };
    c8.setPipelineState(M(r5)), c8.submitDrawMesh(n12, _7, m16.getDotDensityMesh(n12, o8(this.shaders.point)));
  }
  shutdown(e5) {
    var _a;
    super.shutdown(e5), (_a = this._resources.get(e5)) == null ? void 0 : _a.destroy(), this._resources.delete(e5);
  }
  _getOrCreateResourcesRecord(e5) {
    let t13 = this._resources.get(e5);
    return null == t13 && (t13 = new f4(), this._resources.set(e5, t13)), t13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexFillTechnique.js
var m6 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.ComplexFill, this.shaders = { geometry: new _4() };
  }
  render(e5, n12) {
    const { context: u11, painter: m16 } = e5, p14 = n12.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, n12.target, p14.uniforms), ...h5(e5, n12.target), mosaicInfo: m16.textureManager.getMosaicInfo(u11, n12.textureKey), localTileOffset: w3(n12.target) }, defines: { ...y(e5) }, optionalAttributes: p14.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, n12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/utils.js
function n5(n12) {
  const t13 = 1 / n12;
  return { antialiasing: t13, blur: 0 + t13 };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/ComplexOutlineFillTechnique.js
var m7 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.ComplexOutlineFill, this.shaders = { geometry: new C5() };
  }
  render(e5, a6) {
    const { context: u11, painter: m16, pixelRatio: p14 } = e5, f12 = a6.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, a6.target, f12.uniforms), ...h5(e5, a6.target), antialiasingControls: n5(p14), mosaicInfo: m16.textureManager.getMosaicInfo(u11, a6.textureKey), localTileOffset: w3(a6.target) }, defines: { ...y(e5) }, optionalAttributes: f12.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, a6);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/FillTechnique.js
var u4 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Fill, this.shaders = { geometry: new x2() };
  }
  render(e5, n12) {
    const { painter: a6 } = e5, u11 = n12.instance.getInput();
    a6.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, n12.target, u11.uniforms), ...h5(e5, n12.target) }, defines: y(e5), optionalAttributes: u11.optionalAttributes, useComputeBuffer: f3(e5) }), a6.setPipelineState(M(e5)), a6.submitDraw(e5, n12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/OutlineFillTechnique.js
var l4 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.OutlineFill, this.shaders = { geometry: new H4() };
  }
  render(e5, n12) {
    const { painter: u11, pixelRatio: l8 } = e5, m16 = n12.instance.getInput();
    u11.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, n12.target, m16.uniforms), ...h5(e5, n12.target), antialiasingControls: n5(l8) }, defines: { ...y(e5) }, optionalAttributes: m16.optionalAttributes, useComputeBuffer: f3(e5) }), u11.setPipelineState(M(e5)), u11.submitDraw(e5, n12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternFillTechnique.js
var m8 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.PatternFill, this.shaders = { geometry: new z2() };
  }
  render(e5, n12) {
    const { context: u11, painter: m16 } = e5, f12 = n12.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, n12.target, f12.uniforms), ...h5(e5, n12.target), mosaicInfo: m16.textureManager.getMosaicInfo(u11, n12.textureKey), localTileOffset: w3(n12.target) }, defines: { ...y(e5) }, optionalAttributes: f12.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, n12);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/fill/PatternOutlineFillTechnique.js
var m9 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.PatternOutlineFill, this.shaders = { geometry: new S3() };
  }
  render(e5, a6) {
    const { context: l8, painter: m16, pixelRatio: p14 } = e5, f12 = a6.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, a6.target, f12.uniforms), ...h5(e5, a6.target), antialiasingControls: n5(p14), mosaicInfo: m16.textureManager.getMosaicInfo(l8, a6.textureKey), localTileOffset: w3(a6.target) }, defines: { ...y(e5) }, optionalAttributes: f12.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, a6);
  }
};

// node_modules/@arcgis/core/views/webgl/heatmapTextureUtils.js
var l5 = class {
  constructor(e5, t13, r5, o12) {
    this.dataType = e5, this.samplingMode = t13, this.pixelFormat = r5, this.internalFormat = o12;
  }
};
function n6(n12, i10) {
  const { textureFloatLinear: s8, colorBufferFloat: f12 } = n12.capabilities, u11 = f12 == null ? void 0 : f12.textureFloat, _7 = f12 == null ? void 0 : f12.textureHalfFloat, c8 = f12 == null ? void 0 : f12.floatBlend, m16 = n12.driverTest.floatBufferBlend.result;
  if (!u11 && !_7) throw new s("heatmap:missing-color-buffer-float", "HeatmapRenderer requires the WebGL extension EXT_color_buffer_float or EXT_color_buffer_half_float or WEBGL_color_buffer_float.");
  if (!(c8 && m16 || _7)) throw new s("heatmap:missing-float-blend", "HeatmapRenderer requires the WebGL extension EXT_float_blend or EXT_color_buffer_half_float." + (m16 ? "" : " This device claims support for EXT_float_blend, but does not actually support it."));
  const p14 = u11 && c8 && m16, d10 = _7, R3 = s8, h10 = !!(f12 == null ? void 0 : f12.R32F), b7 = !!(f12 == null ? void 0 : f12.R16F);
  if (p14 && R3) return R3 || i10.warnOnce("Missing WebGL extension OES_texture_float_linear. Heatmap quality may be reduced."), new l5(U.FLOAT, R3 ? L.LINEAR : L.NEAREST, h10 ? G.RED : G.RGBA, h10 ? P.R32F : G.RGBA);
  if (d10) return new l5(U.HALF_FLOAT, L.LINEAR, b7 ? G.RED : G.RGBA, b7 ? P.R16F : G.RGBA);
  throw new s("heatmap:missing-hardware-support", "HeatmapRenderer requires WebGL extensions that allow it to render and blend to float or half float textures.");
}
var i7 = new l5(U.HALF_FLOAT, L.NEAREST, G.RGBA, G.RGBA);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapResources.js
var m10 = () => n.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.heatmap.HeatmapResources");
var f5 = class {
  destroy() {
    this._accumulateFramebuffer = r2(this._accumulateFramebuffer), this._resolveGradientTexture = r2(this._resolveGradientTexture), this._prevGradientHash = null, this._qualityProfile = null;
  }
  get initialized() {
    return null != this._accumulateFramebuffer && null != this._resolveGradientTexture;
  }
  get accumulateFramebuffer() {
    return this._accumulateFramebuffer;
  }
  get resolveGradientTexture() {
    return this._resolveGradientTexture;
  }
  loadQualityProfile(e5) {
    if (null == this._qualityProfile) {
      const r5 = n6(e5, m10());
      this._qualityProfile = { ...r5, defines: { usesHalfFloatPrecision: r5.dataType !== U.FLOAT } };
    }
    return this._qualityProfile;
  }
  ensureAccumulateFBO(e5, r5, t13) {
    if (null == this._accumulateFramebuffer) {
      const { dataType: u11, samplingMode: o12, pixelFormat: m16, internalFormat: f12 } = this.loadQualityProfile(e5), h10 = new p(r5, t13);
      h10.pixelFormat = m16, h10.internalFormat = f12, h10.dataType = u11, h10.samplingMode = o12, h10.wrapMode = D.CLAMP_TO_EDGE;
      const c8 = new i3(B.DEPTH_STENCIL, r5, t13);
      this._accumulateFramebuffer = new x(e5, h10, c8);
    } else {
      const { width: e6, height: a6 } = this._accumulateFramebuffer;
      e6 === r5 && a6 === t13 || this._accumulateFramebuffer.resize(r5, t13);
    }
    return this._accumulateFramebuffer;
  }
  ensureResolveGradientTexture(e5, r5, t13) {
    if (null == this._resolveGradientTexture) {
      const r6 = new p();
      r6.wrapMode = D.CLAMP_TO_EDGE, this._resolveGradientTexture = new m2(e5, r6);
    } else this._prevGradientHash !== r5 && (this._resolveGradientTexture.resize(t13.length / 4, 1), this._resolveGradientTexture.setData(t13), this._prevGradientHash = r5);
    return this._resolveGradientTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/heatmapUtils.js
function n7(n12) {
  return n12 ? 0.25 : 1;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/HeatmapAccumulateShader.js
var v3 = class extends S2 {
};
r([h(5, C2)], v3.prototype, "offset", void 0);
var x4 = class extends F4 {
};
var g4 = class extends P2 {
};
r([g(j)], g4.prototype, "radius", void 0), r([g(j)], g4.prototype, "isFieldActive", void 0);
var F7 = class extends P3 {
  constructor() {
    super(...arguments), this.usesHalfFloatPrecision = false;
  }
  vertex(t13) {
    const { radius: e5, isFieldActive: s8 } = this.kernelControls, i10 = t13.offset, o12 = s8.multiply(this.storage.getVVData(t13.id).x).add(new j(1).subtract(s8)), l8 = this.view.displayViewScreenMat3.multiply(new G3(t13.pos, 1)).add(this.view.displayViewMat3.multiply(new G3(i10, 0)).multiply(e5)), r5 = this.clip(t13.id);
    return { glPosition: new H3(l8.xy, r5, 1), offset: i10, fieldValue: o12, color: new H3(0), ...this.maybeRunHittest(t13, {}, null) };
  }
  fragment(t13) {
    const { offset: e5, fieldValue: s8 } = t13, i10 = zn(e5), o12 = re(i10, new j(1)), l8 = new j(1).subtract(i10.multiply(i10)), r5 = l8.multiply(l8), a6 = o12.multiply(r5).multiply(s8).multiply(new j(n7(this.usesHalfFloatPrecision)));
    return this.getFragmentOutput(new H3(a6), t13);
  }
  hittest(t13) {
    const { viewMat3: e5, tileMat3: s8 } = this.view, i10 = e5.multiply(s8).multiply(new G3(t13.pos, 1));
    return R(i10.xy, this.kernelControls.radius, this.hittestRequest.position);
  }
};
r([K], F7.prototype, "usesHalfFloatPrecision", void 0), r([g(g4)], F7.prototype, "kernelControls", void 0), r([e(0, m3(v3))], F7.prototype, "vertex", null), r([e(0, m3(x4))], F7.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/HeatmapResolveShader.js
var x5 = class extends I3 {
};
r([h(0, C2)], x5.prototype, "position", void 0);
var f6 = class extends v {
};
var h6 = class extends P2 {
};
r([g(S)], h6.prototype, "texture", void 0), r([g(C2)], h6.prototype, "minAndInvRange", void 0), r([g(j)], h6.prototype, "normalization", void 0);
var w4 = class extends P2 {
};
r([g(S)], w4.prototype, "texture", void 0);
var b2 = class extends j2 {
  constructor() {
    super(...arguments), this.usesHalfFloatPrecision = false;
  }
  vertex(t13) {
    return { glPosition: new H3(t13.position.multiply(2).subtract(1), 1, 1), uv: t13.position };
  }
  fragment(t13) {
    const { accumulatedDensity: e5, gradient: o12 } = this;
    let r5 = le(e5.texture, t13.uv).r.divide(new j(n7(this.usesHalfFloatPrecision)));
    r5 = r5.multiply(e5.normalization), r5 = r5.subtract(e5.minAndInvRange.x).multiply(e5.minAndInvRange.y);
    const s8 = le(o12.texture, new C2(r5, 0.5)), i10 = new w();
    return i10.glFragColor = new H3(s8.rgb.multiply(s8.a), s8.a), i10;
  }
};
r([K], b2.prototype, "usesHalfFloatPrecision", void 0), r([g(h6)], b2.prototype, "accumulatedDensity", void 0), r([g(w4)], b2.prototype, "gradient", void 0), r([e(0, m3(x5))], b2.prototype, "vertex", null), r([e(0, m3(f6))], b2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/heatmap/HeatmapTechnique.js
var p6 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Heatmap, this.drawPhase = E4.MAP | E4.HITTEST | E4.DEBUG, this.shaders = { accumulate: new F7(), resolve: new b2() }, this._isBound = false, this._resources = /* @__PURE__ */ new Map();
  }
  shutdown(e5) {
    var _a;
    super.shutdown(e5), (_a = this._resources.get(e5)) == null ? void 0 : _a.destroy(), this._resources.delete(e5), this._prevFBO = null, this._unbind();
  }
  render(e5, t13) {
    const { context: n12, painter: o12, state: u11 } = e5, a6 = t13.instance.getInput(), { isFieldActive: d10 } = a6.uniforms, l8 = this._getOrCreateResourcesRecord(n12), h10 = l8.loadQualityProfile(n12);
    f3(e5) || this._bind(e5, l8, a6), o12.setShader({ shader: this.shaders.accumulate, uniforms: { ...h5(e5, t13.target), kernelControls: { radius: g5(a6, u11), isFieldActive: d10 ? 1 : 0 } }, defines: { ...y(e5), ...h10.defines }, optionalAttributes: {}, useComputeBuffer: f3(e5) });
    const c8 = f3(e5) ? w5 : _6;
    o12.setPipelineState(c8), o12.submitDraw(e5, t13);
  }
  getStencilReference(e5) {
    return f7(e5);
  }
  renderResolvePass(e5, t13) {
    if (f3(e5)) return;
    const { context: s8, painter: i10 } = e5, n12 = this._resources.get(s8);
    if (null == this._prevFBO || null == this._prevViewport || !(n12 == null ? void 0 : n12.initialized)) return;
    const { defines: o12 } = n12.loadQualityProfile(s8), { minDensity: u11, maxDensity: a6, radius: d10 } = t13.getInput().uniforms, l8 = 8, h10 = 9, c8 = n12.accumulateFramebuffer, p14 = n12.resolveGradientTexture, m16 = { shader: this.shaders.resolve, uniforms: { accumulatedDensity: { texture: { unit: l8, texture: c8.colorTexture }, minAndInvRange: [u11, 1 / (a6 - u11)], normalization: 3 / (d10 * d10 * Math.PI) }, gradient: { texture: { unit: h10, texture: p14 } } }, defines: o12, optionalAttributes: {}, useComputeBuffer: false };
    s8.bindFramebuffer(this._prevFBO), s8.setViewport(0, 0, this._prevViewport.width, this._prevViewport.height), s8.bindTexture(c8.colorTexture, l8), s8.bindTexture(p14, h10), i10.setPipelineState(b3), i10.submitDrawMesh(s8, m16, i10.quadMesh), this._unbind();
  }
  _getOrCreateResourcesRecord(e5) {
    let t13 = this._resources.get(e5);
    return null == t13 && (t13 = new f5(), this._resources.set(e5, t13)), t13;
  }
  _unbind() {
    this._prevFBO = null, this._prevViewport = null, this._isBound = false;
  }
  _bind(e5, t13, r5) {
    if (this._isBound) return;
    const { context: s8, state: i10, pixelRatio: n12 } = e5, o12 = s8.getBoundFramebufferObject(), u11 = s8.getViewport();
    this._prevFBO = o12, this._prevViewport = u11;
    const { gradient: a6, gradientHash: d10 } = r5.uniforms;
    t13.ensureResolveGradientTexture(s8, d10, a6);
    const { width: l8, height: p14 } = u11, f12 = m11(g5(r5, i10), n12), _7 = l8 * f12, w7 = p14 * f12, b7 = t13.ensureAccumulateFBO(s8, _7, w7);
    s8.blitFramebuffer(o12, b7, 0, 0, o12.width, o12.height, 0, 0, b7.width, b7.height, _.STENCIL, L.NEAREST), s8.bindFramebuffer(b7), s8.setViewport(0, 0, b7.width, b7.height), s8.setColorMask(true, true, true, true), s8.setClearColor(0, 0, 0, 0), s8.clear(_.COLOR), this._isBound = true;
  }
};
function m11(e5, t13) {
  const r5 = t13 > 1.5 ? 0.25 : 0.5;
  return e5 < 1 / (2 * r5) ? 1 : r5;
}
function f7(e5) {
  return e5.key.level + 1;
}
var _6 = { color: { write: [true, true, true, true], blendMode: "additive" }, depth: false, stencil: { write: false, test: { ref: f7, compare: O.GEQUAL, mask: 255, op: { fail: I.KEEP, zFail: I.KEEP, zPass: I.REPLACE } } } };
var w5 = { ..._6, stencil: false };
var b3 = { color: { write: [true, true, true, true], blendMode: "composite" }, depth: false, stencil: false };
function g5(e5, t13) {
  const { referenceScale: r5, radius: s8 } = e5.uniforms;
  return s8 * (0 !== r5 ? r5 / t13.scale : 1);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextShader.js
var K2 = 360 / 254;
var Q;
!function(t13) {
  t13[t13.Color = 0] = "Color", t13[t13.Outline = 1] = "Outline", t13[t13.Halo = 2] = "Halo";
}(Q || (Q = {}));
var X = class extends S2 {
};
r([h(3, H3)], X.prototype, "color", void 0), r([h(4, C2)], X.prototype, "offset", void 0), r([h(5, C2)], X.prototype, "textureUV", void 0), r([h(6, j)], X.prototype, "fontSize", void 0), r([h(7, j)], X.prototype, "referenceSize", void 0), r([h(8, H3)], X.prototype, "outlineColor", void 0), r([h(9, H3)], X.prototype, "haloColor", void 0), r([h(10, C2)], X.prototype, "outlineAndHaloSize", void 0), r([h(11, C2)], X.prototype, "zoomRange", void 0), r([h(12, j)], X.prototype, "clipAngle", void 0), r([h(13, H3)], X.prototype, "referenceSymbol", void 0);
var Y2 = class extends C3 {
};
r([h(14, C2)], Y2.prototype, "offsetNextVertex1", void 0), r([h(15, C2)], Y2.prototype, "offsetNextVertex2", void 0);
var $ = class extends F4 {
};
var tt2 = class extends P3 {
  constructor() {
    super(...arguments), this.computeAttributes = { offset: ["offsetNextVertex1", "offsetNextVertex2"] }, this.textRenderPassType = Q.Color, this.isBackgroundPass = false, this.isLabel = false;
  }
  clipLabel(t13, e5, o12) {
    const s8 = e5.multiply(K2), l8 = Yt(this.view.rotation.subtract(s8)), a6 = Sn(new j(360).subtract(l8), l8);
    let r5 = new j(0);
    const n12 = bn(this.view.currentZoom.multiply(mi)).divide(mi), p14 = t13.x, f12 = t13.y, h10 = new j(1).subtract(re(p14, n12)).multiply(2), v6 = re(new j(90), a6).multiply(2), b7 = new j(2).multiply(new j(1).subtract(re(n12, f12)));
    return r5 = r5.add(o12.multiply(h10)), r5 = r5.add(o12.multiply(v6)), r5 = r5.add(b7), r5;
  }
  vertex(t13, e5) {
    const i10 = h2(t13.bitset, F3), s8 = new j(1).subtract(i10);
    let l8 = t13.fontSize, a6 = l8.divide(A);
    const r5 = this.textRenderPassType === Q.Outline ? t13.outlineColor : this.textRenderPassType === Q.Halo ? t13.haloColor : this._getVertexColor(t13), n12 = this.isLabel ? this.storage.getLabelVisibility(t13.id) : new j(1), p14 = this.isLabel ? r5.multiply(n12) : r5, d10 = this.view.displayViewScreenMat3.multiply(new G3(t13.pos, 1));
    let u11 = t13.offset, m16 = new j(1), c8 = tt.identity(), g7 = new C2(0);
    if (this.isLabel) {
      if (!t13.referenceSymbol) throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");
      const e6 = t13.referenceSymbol, i11 = e6.xy, s9 = e6.z, l9 = this._unpackDirection(e6.w), a7 = l2(this, t13.id, s9).divide(2), r6 = l9.multiply(a7.add(L2));
      g7 = i11.add(r6), u11 = u11.add(g7);
    } else {
      m16 = l2(this, t13.id, t13.referenceSize).divide(t13.referenceSize), l8 = l8.multiply(m16), a6 = a6.multiply(m16), u11 = u11.multiply(m16), c8 = u2(this, t13.id), u11 = c8.multiply(new G3(u11, 0)).xy;
    }
    const z6 = h2(t13.bitset, H2), j4 = this._getViewRotationMatrix(z6).multiply(new G3(u11, 0));
    let R3 = this.isLabel ? this.clipLabel(t13.zoomRange, t13.clipAngle, z6) : this.clip(t13.id, t13.zoomRange);
    R3 = this.isBackgroundPass ? R3.add(s8.multiply(2)) : R3.add(i10.multiply(2));
    const C7 = this.isLabel ? Mt(Gt(R3, new j(1)), Ut(n12, new j(0))) : new Y(false), O3 = new H3(d10.xy.add(j4.xy), R3, 1), M3 = t13.textureUV.divide(this.mosaicInfo.size);
    let L5 = new j(0);
    if (this.textRenderPassType === Q.Outline) {
      Ut(t13.outlineAndHaloSize.x, new j(0)) && (R3 = R3.add(new j(2)));
      L5 = new j(t13.outlineAndHaloSize.x).divide(a6).divide(G2);
    }
    if (this.textRenderPassType === Q.Halo) {
      const e6 = t13.outlineAndHaloSize.x, i11 = new j(t13.outlineAndHaloSize.y);
      Ut(i11, new j(0)) && (R3 = R3.add(new j(2)));
      L5 = i11.add(e6).divide(a6).divide(G2);
    }
    return { glPosition: O3, color: p14, size: a6, textureUV: M3, antialiasingWidth: new j(0.105 * A).divide(l8).divide(this.view.pixelRatio), outlineDistanceOffset: L5, ...this.maybeRunHittest(t13, e5, { vvSizeAdjustment: m16, vvRotation: c8, labelOffset: g7, labelClipped: C7 }) };
  }
  _getViewRotationMatrix(t13) {
    const e5 = this.view.displayViewMat3, i10 = this.view.displayMat3, o12 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i10.multiply(o12));
  }
  fragment(t13) {
    const e5 = new j(2 / 8), i10 = new j(1).subtract(e5), o12 = le(this.mosaicInfo.texture, t13.textureUV).a;
    let s8 = i10.subtract(t13.outlineDistanceOffset);
    this.highlight && (s8 = s8.divide(2));
    const l8 = t13.antialiasingWidth, a6 = ne(s8.subtract(l8), s8.add(l8), o12);
    return this.getFragmentOutput(t13.color.multiply(a6), t13);
  }
  hittest(t13, e5, { vvSizeAdjustment: i10, vvRotation: o12, labelOffset: s8, labelClipped: l8 }) {
    let a6, r5, n12;
    this.isLabel ? (a6 = new G3(t13.offset.add(s8), 0), r5 = new G3(e5.offsetNextVertex1.add(s8), 0), n12 = new G3(e5.offsetNextVertex2.add(s8), 0)) : (a6 = o12.multiply(new G3(t13.offset.multiply(i10), 0)), r5 = o12.multiply(new G3(e5.offsetNextVertex1.multiply(i10), 0)), n12 = o12.multiply(new G3(e5.offsetNextVertex2.multiply(i10), 0)));
    const { viewMat3: p14, tileMat3: d10 } = this.view, u11 = p14.multiply(d10).multiply(new G3(t13.pos, 1)), y5 = u11.add(d10.multiply(a6)).xy, m16 = u11.add(d10.multiply(r5)).xy, c8 = u11.add(d10.multiply(n12)).xy, h10 = P4(this.hittestRequest.position, y5.xy, m16.xy, c8.xy);
    return this.isLabel ? xt(l8, q3(this.hittestRequest), h10) : h10;
  }
  _unpackDirection(t13) {
    const e5 = new O2(t13), i10 = Dt(e5, new O2(2)), o12 = Pt(e5, new O2(3));
    return new C2(new j(i10).subtract(1), new j(o12).subtract(1));
  }
  _getVertexColor(t13) {
    let e5 = t13.color;
    if (this.visualVariableColor) {
      const i10 = this.storage.getColorValue(t13.id);
      e5 = this.visualVariableColor.getColor(i10, t13.color, new Y(false));
    }
    if (this.visualVariableOpacity) {
      const i10 = this.storage.getOpacityValue(t13.id), o12 = this.visualVariableOpacity.getOpacity(i10);
      e5 = e5.multiply(o12);
    }
    return e5;
  }
};
r([_3(f)], tt2.prototype, "visualVariableColor", void 0), r([_3(h4)], tt2.prototype, "visualVariableOpacity", void 0), r([_3(d5)], tt2.prototype, "visualVariableRotation", void 0), r([_3(m4)], tt2.prototype, "visualVariableSizeMinMaxValue", void 0), r([_3(p3)], tt2.prototype, "visualVariableSizeScaleStops", void 0), r([_3(f2)], tt2.prototype, "visualVariableSizeStops", void 0), r([_3(l3)], tt2.prototype, "visualVariableSizeUnitValue", void 0), r([g(p2)], tt2.prototype, "mosaicInfo", void 0), r([K], tt2.prototype, "textRenderPassType", void 0), r([K], tt2.prototype, "isBackgroundPass", void 0), r([K], tt2.prototype, "isLabel", void 0), r([e(0, m3(X)), e(1, m3(Y2))], tt2.prototype, "vertex", null), r([e(0, m3($))], tt2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/labels/LabelTechnique.js
var d6 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Label, this.shaders = { geometry: new tt2() }, this.drawPhase = E4.LABEL | E4.LABEL_ALPHA | E4.HITTEST, this.symbologyPlane = S4.TEXT;
  }
  render(e5, t13) {
    const { context: s8, painter: u11 } = e5, m16 = y(e5), d10 = { ...M(e5) }, h10 = t13.instance.getInput(), l8 = { shader: this.shaders.geometry, uniforms: { ...m5(e5, t13.target, h10.uniforms), ...h5(e5, t13.target), mosaicInfo: u11.textureManager.getMosaicInfo(s8, t13.textureKey) }, defines: { ...m16, textRenderPassType: Q.Color, isBackgroundPass: true, isLabel: true }, optionalAttributes: h10.optionalAttributes, useComputeBuffer: f3(e5) };
    u11.setShader(l8), u11.setPipelineState(d10), u11.submitDraw(e5, t13), u11.setShader({ ...l8, defines: { ...m16, textRenderPassType: Q.Halo, isBackgroundPass: false, isLabel: true } }), u11.setPipelineState(d10), u11.submitDraw(e5, t13), u11.setShader({ ...l8, defines: { ...m16, textRenderPassType: Q.Color, isBackgroundPass: false, isLabel: true } }), u11.setPipelineState(d10), u11.submitDraw(e5, t13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/LineTechnique.js
var p7 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Line, this.shaders = { geometry: new B3() }, this.symbologyPlane = S4.LINE;
  }
  render(e5, t13) {
    const { painter: a6, pixelRatio: u11 } = e5, p14 = t13.instance.getInput();
    a6.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, t13.target, p14.uniforms), ...h5(e5, t13.target), antialiasingControls: n5(u11) }, defines: { ...y(e5) }, optionalAttributes: p14.optionalAttributes, useComputeBuffer: f3(e5) }), a6.setPipelineState(M(e5)), a6.submitDraw(e5, t13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/TexturedLineShader.js
var W2 = class extends q4 {
};
r([h(9, j)], W2.prototype, "accumulatedDistance", void 0), r([h(10, C2)], W2.prototype, "segmentDirection", void 0), r([h(11, j)], W2.prototype, "offsetAlongLine", void 0), r([h(12, j)], W2.prototype, "capType", void 0), r([h(13, H3)], W2.prototype, "tlbr", void 0);
var H6 = class extends B3 {
  _getDistanceRatio(t13, e5) {
    const o12 = h2(t13.bitset, D3);
    return o12.multiply(Un(e5, new j(0.25)).multiply(new j(2))).add(new j(1).subtract(o12).multiply(u(1)));
  }
  _getSDFAlpha(t13) {
    const { halfWidth: e5, normal: i10, tlbr: a6, patternSize: l8, accumulatedDistance: n12, offsetAlongLine: x8, dashToPx: v6, capType: D6 } = t13, j4 = l8.x.divide(t4).multiply(v6), S7 = In(n12.add(x8).divide(j4)), A4 = jn(a6.xy, a6.zw, new C2(S7, 0.5)), z6 = B2(le(this.mosaicInfo.texture, A4)).multiply(2).subtract(1).multiply(c2).multiply(v6), F8 = i10.y.multiply(e5), _7 = gt([Ut(D6, new j(1)), z6.subtract(e5)], [Ut(D6, new j(2)), ee2(Jn(Un(z6, new j(0)), new j(2)).add(F8.multiply(F8))).subtract(e5)], [true, z6]), T4 = tn(new j(0.25).subtract(_7), new j(0), new j(1));
    return new H3(T4);
  }
  _getPatternColor(t13) {
    const { halfWidth: e5, normal: i10, color: o12, accumulatedDistance: s8, patternSize: a6, sampleAlphaOnly: l8, tlbr: n12 } = t13, r5 = a6.y.multiply(new j(2).multiply(e5).divide(a6.x)), y5 = In(s8.divide(r5)), h10 = new j(0.5).multiply(i10.y).add(new j(0.5)), f12 = jn(n12.xy, n12.zw, new C2(h10, y5));
    let w7 = le(this.mosaicInfo.texture, f12);
    return null != this.visualVariableColor && (w7 = xt(Gt(l8, new j(0.5)), new H3(o12.a), o12)), w7;
  }
  vertex(t13, e5) {
    const { segmentDirection: i10, tlbr: o12, bitset: s8 } = t13, a6 = T(this, t13), l8 = t13.accumulatedDistance.divide(this.view.displayZoomFactor).add(hn(i10, a6.scaledOffset)), n12 = new C2(o12.z.subtract(o12.x), o12.w.subtract(o12.y)), r5 = o12.divide(this.mosaicInfo.size.xyxy), m16 = h2(s8, E3), c8 = h2(s8, q), d10 = xt(Gt(m16, new j(0.5)), this._getDistanceRatio(t13, a6.scaledHalfWidth), new j(1));
    return { ...a6, tlbr: r5, patternSize: n12, accumulatedDistance: l8, isSDF: m16, sampleAlphaOnly: c8, dashToPx: d10, offsetAlongLine: t13.offsetAlongLine, capType: t13.capType, ...this.maybeRunHittest(t13, e5, a6.halfWidth) };
  }
  fragment(t13) {
    const { color: e5, opacity: i10, isSDF: o12 } = t13, s8 = D4(t13, this.antialiasingControls.blur), a6 = xt(Gt(o12, new j(0.5)), this._getSDFAlpha(t13), this._getPatternColor(t13)), l8 = e5.multiply(i10).multiply(s8).multiply(a6);
    return this.getFragmentOutput(l8, t13);
  }
};
r([g(p2)], H6.prototype, "mosaicInfo", void 0), r([e(0, m3(W2)), e(1, m3(q2))], H6.prototype, "vertex", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/line/TexturedLineTechnique.js
var p8 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.TexturedLine, this.shaders = { geometry: new H6() }, this.symbologyPlane = S4.LINE;
  }
  render(e5, t13) {
    const { context: a6, painter: m16, pixelRatio: p14 } = e5, f12 = t13.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, t13.target, f12.uniforms), ...h5(e5, t13.target), antialiasingControls: n5(p14), mosaicInfo: m16.textureManager.getMosaicInfo(a6, t13.textureKey) }, defines: { ...y(e5) }, optionalAttributes: f12.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, t13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerShader.js
var X2 = class extends S2 {
};
r([h(3, H3)], X2.prototype, "color", void 0), r([h(4, H3)], X2.prototype, "outlineColor", void 0), r([h(5, C2)], X2.prototype, "offset", void 0), r([h(6, C2)], X2.prototype, "textureUV", void 0), r([h(7, H3)], X2.prototype, "sizing", void 0), r([h(8, j)], X2.prototype, "placementAngle", void 0), r([h(9, j)], X2.prototype, "sdfDecodeCoeff", void 0), r([h(10, C2)], X2.prototype, "zoomRange", void 0);
var Y3 = class extends C3 {
};
r([h(12, C2)], Y3.prototype, "offsetNextVertex1", void 0), r([h(13, C2)], Y3.prototype, "offsetNextVertex2", void 0), r([h(14, C2)], Y3.prototype, "textureUVNextVertex1", void 0), r([h(15, C2)], Y3.prototype, "textureUVNextVertex2", void 0);
var Z2 = class extends F4 {
};
function $2(t13, e5, i10, o12) {
  return e5.multiply(t13.x).add(i10.multiply(t13.y)).add(o12.multiply(t13.z));
}
function tt3(t13) {
  return t13.multiply(t13).divide(128);
}
var et = class extends P3 {
  constructor() {
    super(...arguments), this.computeAttributes = { offset: ["offsetNextVertex1", "offsetNextVertex2"], textureUV: ["textureUVNextVertex1", "textureUVNextVertex2"] };
  }
  vertex(t13, e5) {
    const i10 = tt3(t13.sizing.x), o12 = tt3(t13.sizing.y), s8 = tt3(t13.sizing.z), l8 = t13.placementAngle, r5 = h2(t13.bitset, o2.bitset.isSDF), y5 = h2(t13.bitset, o2.bitset.isMapAligned), h10 = h2(t13.bitset, o2.bitset.scaleSymbolsProportionally), c8 = v2(t13.bitset, o2.bitset.colorLocked), x8 = n2(this, t13.id), v6 = r3(this, t13.id, t13.color, c8).multiply(x8), f12 = this.view.displayViewScreenMat3.multiply(new G3(t13.pos.xy, 1)), V4 = l2(this, t13.id, s8).divide(s8), w7 = i10.multiply(V4), S7 = t13.offset.xy.multiply(V4);
    let b7 = o12.multiply(h10.multiply(V4.subtract(1)).add(1));
    b7 = Sn(b7, Un(w7.subtract(0.99), new j(0)));
    const g7 = Un(b7, new j(1)), C7 = Sn(b7, new j(1)), M3 = tt.fromRotation(l8.multiply(c)), _7 = u2(this, t13.id), j4 = this._getViewRotationMatrix(y5).multiply(_7).multiply(M3).multiply(new G3(S7.xy, 0)), U4 = this.clip(t13.id, t13.zoomRange), N = new H3(f12.xy.add(j4.xy), U4, 1), D6 = t13.textureUV.divide(this.mosaicInfo.size), F8 = t13.outlineColor.multiply(C7), I5 = h2(t13.bitset, o2.bitset.overrideOutlineColor), O3 = t13.sdfDecodeCoeff.multiply(w7);
    return { glPosition: N, color: v6, textureUV: D6, outlineColor: F8, outlineSize: g7, distanceToPx: O3, isSDF: r5, overrideOutlineColor: I5, ...this.maybeRunHittest(t13, e5, { pos: t13.pos, size: w7, sizeCorrection: V4, isMapAligned: y5, vvRotationMat3: _7, placementMat3: M3, outlineSize: g7, distanceToPx: O3, isSDF: r5 }) };
  }
  fragment(t13) {
    const e5 = this._getColor(t13.textureUV, t13);
    return this.getFragmentOutput(e5, t13);
  }
  hittest(t13, e5, i10) {
    return xt(jt(i10.size, this.hittestRequest.smallSymbolSizeThreshold), this._hittestSmallMarker(t13, e5, i10), this._hittestMarker(t13, e5, i10));
  }
  _getViewRotationMatrix(t13) {
    const e5 = this.view.displayViewMat3, i10 = this.view.displayMat3, o12 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i10.multiply(o12));
  }
  _getViewScreenMatrix(t13) {
    const e5 = this.view.viewMat3.multiply(this.view.tileMat3), i10 = this.view.tileMat3, o12 = new j(1).subtract(t13);
    return e5.multiply(t13).add(i10.multiply(o12));
  }
  _getColor(t13, e5) {
    return xt(Ut(e5.isSDF, new j(1)), this._getSDFColor(t13, e5), this._getSpriteColor(t13, e5));
  }
  _getSpriteColor(t13, e5) {
    return le(this.mosaicInfo.texture, t13).multiply(e5.color);
  }
  _getSDFColor(t13, e5) {
    const i10 = le(this.mosaicInfo.texture, t13), o12 = new j(0.5).subtract(B2(i10)).multiply(e5.distanceToPx).multiply(o3), s8 = tn(new j(0.5).subtract(o12), new j(0), new j(1)), l8 = e5.color.multiply(s8);
    let r5 = e5.outlineSize;
    this.highlight && (r5 = Un(r5, e5.overrideOutlineColor.multiply(4)));
    const a6 = r5.multiply(0.5), p14 = Yt(o12).subtract(a6), d10 = tn(new j(0.5).subtract(p14), new j(0), new j(1)), m16 = jn(e5.outlineColor, e5.color, e5.overrideOutlineColor).multiply(d10);
    return new j(1).subtract(m16.a).multiply(l8).add(m16);
  }
  _hittestSmallMarker(t13, e5, i10) {
    const { position: o12, distance: s8, smallSymbolDistance: l8 } = this.hittestRequest, r5 = s8.subtract(l8), { viewMat3: p14, tileMat3: n12 } = this.view, u11 = p14.multiply(n12).multiply(new G3(i10.pos, 1)).xy, d10 = i10.size.multiply(0.5);
    return ln(u11, o12).subtract(d10).add(r5);
  }
  _hittestMarker(t13, e5, i10) {
    const { pos: o12, sizeCorrection: s8, isMapAligned: l8 } = i10, r5 = new G3(t13.offset.multiply(s8), 0), p14 = new G3(e5.offsetNextVertex1.multiply(s8), 0), n12 = new G3(e5.offsetNextVertex2.multiply(s8), 0), { viewMat3: u11, tileMat3: d10 } = this.view, m16 = u11.multiply(d10).multiply(new G3(o12, 1)), h10 = this._getViewScreenMatrix(l8).multiply(i10.vvRotationMat3).multiply(i10.placementMat3), c8 = m16.add(h10.multiply(r5)).xy, x8 = m16.add(h10.multiply(p14)).xy, v6 = m16.add(h10.multiply(n12)).xy, f12 = this.hittestRequest.position, V4 = this.hittestRequest.distance, w7 = P4(f12, c8, x8, v6);
    return xt(Gt(w7, V4), w7, this._hittestSamples(c8, x8, v6, t13, e5, i10));
  }
  _hittestSamples(t13, e5, i10, o12, s8, l8) {
    const { outlineSize: r5, isSDF: a6, distanceToPx: p14 } = l8, n12 = this.hittestRequest.position, d10 = this.hittestRequest.distance, y5 = h3(n12.add(new C2(yt(d10), yt(d10))), t13, e5, i10), h10 = h3(n12.add(new C2(0, yt(d10))), t13, e5, i10), c8 = h3(n12.add(new C2(d10, yt(d10))), t13, e5, i10), x8 = h3(n12.add(new C2(yt(d10), 0)), t13, e5, i10), v6 = h3(n12, t13, e5, i10), f12 = h3(n12.add(new C2(d10, 0)), t13, e5, i10), V4 = h3(n12.add(new C2(yt(d10), d10)), t13, e5, i10), w7 = h3(n12.add(new C2(0, d10)), t13, e5, i10), S7 = h3(n12.add(new C2(d10, d10)), t13, e5, i10), z6 = o12.textureUV.divide(this.mosaicInfo.size), M3 = s8.textureUVNextVertex1.divide(this.mosaicInfo.size), _7 = s8.textureUVNextVertex2.divide(this.mosaicInfo.size), j4 = { color: new H3(1), outlineColor: new H3(1), overrideOutlineColor: new j(1), outlineSize: r5, distanceToPx: p14, isSDF: a6 };
    let R3 = new j(0);
    return R3 = R3.add(g2(y5).multiply(this._getColor($2(y5, z6, M3, _7), j4).a)), R3 = R3.add(g2(h10).multiply(this._getColor($2(h10, z6, M3, _7), j4).a)), R3 = R3.add(g2(c8).multiply(this._getColor($2(c8, z6, M3, _7), j4).a)), R3 = R3.add(g2(x8).multiply(this._getColor($2(x8, z6, M3, _7), j4).a)), R3 = R3.add(g2(v6).multiply(this._getColor($2(v6, z6, M3, _7), j4).a)), R3 = R3.add(g2(f12).multiply(this._getColor($2(f12, z6, M3, _7), j4).a)), R3 = R3.add(g2(V4).multiply(this._getColor($2(V4, z6, M3, _7), j4).a)), R3 = R3.add(g2(w7).multiply(this._getColor($2(w7, z6, M3, _7), j4).a)), R3 = R3.add(g2(S7).multiply(this._getColor($2(S7, z6, M3, _7), j4).a)), re(R3, new j(0.05)).multiply(q3(this.hittestRequest));
  }
};
r([_3(f)], et.prototype, "visualVariableColor", void 0), r([_3(h4)], et.prototype, "visualVariableOpacity", void 0), r([_3(d5)], et.prototype, "visualVariableRotation", void 0), r([_3(m4)], et.prototype, "visualVariableSizeMinMaxValue", void 0), r([_3(p3)], et.prototype, "visualVariableSizeScaleStops", void 0), r([_3(f2)], et.prototype, "visualVariableSizeStops", void 0), r([_3(l3)], et.prototype, "visualVariableSizeUnitValue", void 0), r([g(p2)], et.prototype, "mosaicInfo", void 0), r([e(0, m3(X2)), e(1, m3(Y3))], et.prototype, "vertex", null), r([e(0, m3(Z2))], et.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/markers/MarkerTechnique.js
var u5 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Marker, this.shaders = { geometry: new et() }, this.symbologyPlane = S4.MARKER;
  }
  render(e5, t13) {
    const { context: a6, painter: m16 } = e5, u11 = t13.instance.getInput();
    m16.setShader({ shader: this.shaders.geometry, uniforms: { ...m5(e5, t13.target, u11.uniforms), ...h5(e5, t13.target), mosaicInfo: m16.textureManager.getMosaicInfo(a6, t13.textureKey, true) }, defines: { ...y(e5) }, optionalAttributes: u11.optionalAttributes, useComputeBuffer: f3(e5) }), m16.setPipelineState(M(e5)), m16.submitDraw(e5, t13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/GLSLShaderModule.js
var o9 = class {
  constructor() {
    this.computeAttributes = {};
  }
  get locationsMap() {
    const t13 = /* @__PURE__ */ new Map();
    for (const e5 in this.locations) t13.set(e5, this.locations[e5].index);
    return t13;
  }
  get optionPropertyKeys() {
    if (!this._optionPropertyKeys) {
      const t13 = new Set(Object.keys(this.options));
      this._optionPropertyKeys = t13;
    }
    return this._optionPropertyKeys;
  }
  get _transformFeedbackBindings() {
    return [];
  }
  get locationInfo() {
    if (!this._locationInfo) {
      const e5 = this.locationsMap, o12 = Array.from(e5.entries()).map(([t13, e6]) => `${t13}.${e6}`).join("."), n12 = l(o12);
      this._locationInfo = { hash: n12, locations: e5, computeAttributeMap: this.computeAttributes };
    }
    return this._locationInfo;
  }
  get renamedLocationsMap() {
    const t13 = /* @__PURE__ */ new Map();
    for (const [e5, o12] of this.locationsMap.entries()) t13.set("a_" + e5, o12);
    return t13;
  }
  getShaderKey(t13, e5, o12) {
    return `${Object.keys(t13).map((e6) => `${e6}.${t13[e6]}`).join(".")}.${Object.keys(o12).filter((t14) => o12[t14]).map((t14) => `${t14}_${o12[t14].toString()}`).join(".")}.${Object.keys(e5).filter((t14) => this.optionPropertyKeys.has(t14)).join(".")}`;
  }
  getProgram(t13, o12, n12, r5) {
    let i10 = "", s8 = "";
    for (const e5 in n12) if (n12[e5]) {
      const t14 = "boolean" == typeof n12[e5] ? `#define ${e5}
` : `#define ${e5} ${n12[e5]}
`;
      i10 += t14, s8 += t14;
    }
    return i10 += this.vertexShader, s8 += this.fragmentShader, new a2(i10, s8, this.renamedLocationsMap, this.locationInfo, this._getUniformBindings(o12), this._transformFeedbackBindings);
  }
  _getUniformBindings(t13) {
    const e5 = [];
    for (const o12 in this.required) {
      const t14 = this.required[o12];
      e5.push({ uniformHydrated: null, shaderModulePath: o12, uniformName: o12, uniformType: t14.type, uniformArrayElementType: n8(t14), uniformArrayLength: r4(t14) });
    }
    for (const o12 in t13) {
      const i10 = this.options[o12];
      if (t13[o12]) for (const t14 in i10) {
        const s8 = i10[t14];
        e5.push({ uniformHydrated: null, shaderModulePath: `${o12}.${t14}`, uniformName: t14, uniformType: s8.type, uniformArrayElementType: n8(s8), uniformArrayLength: r4(s8) });
      }
    }
    return e5;
  }
};
var n8 = (t13) => {
  var _a;
  return "array" === t13.type ? (_a = t13.elementType) == null ? void 0 : _a.type : void 0;
};
var r4 = (t13) => "array" === t13.type ? t13.size : void 0;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartShader.js
var p9 = { hittestDist: j, hittestPos: C2 };
var y2 = { filterFlags: S, animation: S, visualVariableData: S, dataDriven0: S, dataDriven1: S, dataDriven2: S, gpgpu: S, size: j };
var d7 = { displayViewScreenMat3: tt, displayViewMat3: tt, displayMat3: tt, viewMat3: tt, tileMat3: tt, displayZoomFactor: j, requiredZoomFactor: j, tileOffset: C2, currentScale: j, currentZoom: j, metersPerSRUnit: j };
var u6 = class extends o9 {
  constructor() {
    super(...arguments), this.vertexShader = n3("materials/pie/pie.vert"), this.fragmentShader = n3("materials/pie/pie.frag"), this.required = { ...y2, ...d7, outlineWidth: j, colors: U2, defaultColor: H3, othersColor: H3, outlineColor: H3, donutRatio: j, sectorThreshold: j }, this.options = { hittestUniforms: p9, visualVariableSizeMinMaxValue: { minMaxValueAndSize: H3 }, visualVariableSizeScaleStops: { sizes: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, values: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } }, visualVariableSizeStops: { sizes: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, values: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } }, visualVariableSizeUnitValue: { unitValueToPixelsRatio: j }, visualVariableOpacity: { opacities: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 }, opacityValues: { ...U2.ofType(j, 8), type: "array", elementType: j, size: 8 } } }, this.locations = { pos: { index: 0, type: C2 }, id: { index: 1, type: G3 }, bitset: { index: 2, type: j }, offset: { index: 3, type: C2 }, texCoords: { index: 4, type: C2 }, size: { index: 5, type: C2 }, referenceSize: { index: 6, type: j }, zoomRange: { index: 7, type: C2 } }, this.defines = { VV_SIZE_MIN_MAX_VALUE: "boolean", VV_SIZE_SCALE_STOPS: "boolean", VV_SIZE_FIELD_STOPS: "boolean", VV_SIZE_UNIT_VALUE: "boolean", VV_OPACITY: "boolean", HITTEST: "boolean", numberOfFields: "number", highlight: "boolean", inside: "boolean", outside: "boolean" };
  }
  setNumberOfFields(e5) {
    this.required.colors = { ...U2.ofType(H3, e5), type: "array", elementType: H3, size: e5 };
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/pieChart/PieChartTechnique.js
var h7 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.PieChart, this.shaders = { geometry: new u6() }, this.symbologyPlane = S4.MARKER;
  }
  render(e5, t13) {
    var _a, _b;
    const { painter: u11 } = e5, { instance: n12, target: h10 } = t13, m16 = this.shaders.geometry, l8 = n12.getInput(), f12 = l8.uniforms.numberOfFields, S7 = f3(e5), V4 = h5(e5, h10), d10 = y(e5);
    m16.setNumberOfFields(f12), u11.setShader({ shader: m16, uniforms: { ...m5(e5, t13.target, l8.uniforms.shader), ...V4.storage, ...V4.view, hittestUniforms: V4.hittestRequest ? { hittestDist: (_a = V4.hittestRequest) == null ? void 0 : _a.distance, hittestPos: (_b = V4.hittestRequest) == null ? void 0 : _b.position } : null }, defines: { VV_SIZE_MIN_MAX_VALUE: !!l8.uniforms.shader.visualVariableSizeMinMaxValue, VV_SIZE_SCALE_STOPS: !!l8.uniforms.shader.visualVariableSizeScaleStops, VV_SIZE_FIELD_STOPS: !!l8.uniforms.shader.visualVariableSizeStops, VV_SIZE_UNIT_VALUE: !!l8.uniforms.shader.visualVariableSizeUnitValue, VV_OPACITY: !!l8.uniforms.shader.visualVariableOpacity, HITTEST: S7, highlight: V4.highlight ? 1 : 0, ...d10, numberOfFields: f12 }, optionalAttributes: {}, useComputeBuffer: S7 }), u11.setPipelineState(M(e5)), u11.submitDraw(e5, t13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/text/TextTechnique.js
var m12 = class extends t8 {
  constructor() {
    super(...arguments), this.type = e2.Text, this.shaders = { geometry: new tt2() }, this.symbologyPlane = S4.TEXT;
  }
  render(e5, s8) {
    const { context: n12, painter: u11 } = e5, m16 = y(e5), p14 = s8.instance.getInput(), f12 = { shader: this.shaders.geometry, uniforms: { ...m5(e5, s8.target, p14.uniforms), ...h5(e5, s8.target), mosaicInfo: u11.textureManager.getMosaicInfo(n12, s8.textureKey) }, defines: { ...m16, isBackgroundPass: true, isLabel: false, textRenderPassType: Q.Color }, optionalAttributes: p14.optionalAttributes, useComputeBuffer: f3(e5) };
    u11.setShader(f12), u11.setPipelineState(M(e5)), u11.submitDraw(e5, s8), u11.setShader({ ...f12, defines: { ...m16, isBackgroundPass: false, isLabel: false, textRenderPassType: Q.Halo } }), u11.submitDraw(e5, s8), u11.setShader({ ...f12, defines: { ...m16, isBackgroundPass: false, isLabel: false, textRenderPassType: Q.Outline } }), u11.submitDraw(e5, s8), u11.setShader({ ...f12, defines: { ...m16, isBackgroundPass: false, isLabel: false, textRenderPassType: Q.Color } }), u11.submitDraw(e5, s8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueRegistry.js
var T3 = { fill: new u4(), patternFill: new m8(), complexFill: new m6(), outlineFill: new l4(), patternOutlineFill: new m9(), complexOutlineFill: new m7(), marker: new u5(), pieChart: new h7(), line: new p7(), texturedLine: new p8(), text: new m12(), label: new d6(), heatmap: new p6(), dotDensity: new g3(), animatedMarker: new s4() };
function w6() {
  for (const e5 in T3) {
    T3[e5].startup();
  }
}
function j3(e5) {
  for (const i10 in T3) {
    T3[i10].shutdown(e5);
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/schemaUtils.js
function n9(n12, t13) {
  const r5 = n12.slice(0, t13), e5 = t13 - r5.length;
  for (let o12 = 0; o12 < e5; o12++) {
    const n13 = r5[r5.length - 1];
    r5.push(n13);
  }
  return r5;
}
function t10(n12) {
  if (!n12) return [0, 0, 0, 0];
  const { r: t13, g: r5, b: e5, a: o12 } = n12;
  return [t13 * (o12 / 255), r5 * (o12 / 255), e5 * (o12 / 255), o12];
}

// node_modules/@arcgis/core/views/2d/layers/features/support/rendererUtils.js
var l6 = 8;
var s5 = l6 - 2;
var n10 = () => n.getLogger("esri.views.2d.layers.features.support.rendererUtils");
function u7(e5) {
  return e5.map((e6) => a3(e6) ? i8(e6.clone()) : e6);
}
function a3(e5) {
  return ("size" === e5.type || "color" === e5.type || "opacity" === e5.type) && null != e5.stops;
}
function i8(e5) {
  return e5.stops = b4(e5.type, e5.stops ?? []), e5;
}
function p10(e5, o12, r5) {
  return (1 - r5) * e5 + r5 * o12;
}
function c4(e5, o12) {
  const [t13, ...l8] = o12, n12 = l8.pop(), u11 = l8[0].value, a6 = l8[l8.length - 1].value, i10 = (a6 - u11) / s5, c8 = [];
  for (let s8 = u11; s8 < a6; s8 += i10) {
    let t14 = 0;
    for (; s8 >= l8[t14].value; ) t14++;
    const n13 = l8[t14], u12 = o12[t14 - 1], a7 = s8 - u12.value, i11 = n13.value === u12.value ? 1 : a7 / (n13.value - u12.value);
    if ("color" === e5) {
      const e6 = l8[t14], r5 = o12[t14 - 1], n14 = e6.color.clone();
      n14.r = p10(r5.color.r, n14.r, i11), n14.g = p10(r5.color.g, n14.g, i11), n14.b = p10(r5.color.b, n14.b, i11), n14.a = p10(r5.color.a, n14.a, i11), c8.push({ value: s8, color: n14, label: e6.label });
    } else if ("size" === e5) {
      const e6 = l8[t14], n14 = o12[t14 - 1], u13 = o(e6.size), a8 = p10(o(n14.size), u13, i11);
      c8.push({ value: s8, size: a8, label: e6.label });
    } else {
      const e6 = l8[t14], r5 = p10(o12[t14 - 1].opacity, e6.opacity, i11);
      c8.push({ value: s8, opacity: r5, label: e6.label });
    }
  }
  return [t13, ...c8, n12];
}
function f8(e5) {
  const [o12, ...r5] = e5, t13 = r5.pop();
  for (; r5.length > s5; ) {
    let e6 = 0, o13 = 0;
    for (let t14 = 1; t14 < r5.length; t14++) {
      const l8 = r5[t14 - 1], s8 = r5[t14], n12 = Math.abs(s8.value - l8.value);
      n12 > o13 && (o13 = n12, e6 = t14);
    }
    r5.splice(e6, 1);
  }
  return [o12, ...r5, t13];
}
function b4(e5, o12) {
  return o12.length <= l6 ? o12 : (n10().warn(`Found ${o12.length} Visual Variable stops, but MapView only supports ${l6}. Displayed stops will be simplified.`), o12.length > 2 * l6 ? c4(e5, o12) : f8(o12));
}
function g6() {
  const { supportsColorBufferFloat: e5, supportsColorBufferFloatBlend: o12, supportsColorBufferHalfFloat: r5 } = t5();
  return e5 && o12 || r5;
}
function m13(o12) {
  if (!o12) return true;
  switch (o12.type) {
    case "dot-density":
      break;
    case "heatmap":
      if (!g6()) {
        const o13 = t5(), r5 = ["supportsColorBufferFloat", "supportsColorBufferFloatBlend", "supportsColorBufferHalfFloat"].filter((e5) => !o13[e5]).join(", ");
        return n10().errorOnce(new s("webgl-missing-extension", `Missing WebGL2 requirements for Heatmap: ${r5}`)), false;
      }
  }
  return true;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/VisualVariablesSchema.js
var u8 = 1.25;
var o10 = 128;
var c5 = 128;
function p11(e5) {
  var _a;
  if (!((_a = e5.stops) == null ? void 0 : _a.length)) return null;
  const a6 = e5.stops.sort((e6, a7) => e6.value - a7.value), i10 = n9(a6, 8), l8 = i10.map(({ value: e6 }) => e6), s8 = i10.map(({ color: e6 }) => t10(e6));
  return { values: l8, colors: s8 };
}
function v4(e5) {
  var _a;
  if (!((_a = e5.stops) == null ? void 0 : _a.length)) return null;
  const a6 = e5.stops.sort((e6, a7) => e6.value - a7.value), i10 = n9(a6, 8);
  return { opacityValues: i10.map(({ value: e6 }) => e6), opacities: i10.map(({ opacity: e6 }) => e6) };
}
function V2(e5) {
  return { rotationType: "geographic" === e5.rotationType ? i5.Geographic : i5.Arithmatic };
}
function f9(a6) {
  var _a;
  if (!((_a = a6.stops) == null ? void 0 : _a.length)) return null;
  if (a6.stops.some((e5) => e5.useMaxValue || e5.useMinValue)) return (i11, s9) => {
    const r5 = i11.statisticsByLevel.get(s9.key.level), n12 = a6.stops.map((i12) => {
      var _a2, _b;
      return { value: i12.useMaxValue ? ((_a2 = r5 == null ? void 0 : r5.get(a6.field)) == null ? void 0 : _a2.maxValue) ?? 0 : i12.useMinValue ? ((_b = r5 == null ? void 0 : r5.get(a6.field)) == null ? void 0 : _b.minValue) ?? 0 : i12.value, size: i12.size ? u(i12.size) : D2 };
    }).sort((e5, a7) => e5.value - a7.value), u11 = n9(n12, 8);
    return { values: u11.map(({ value: e5 }) => e5), sizes: u11.map(({ size: e5 }) => e5) };
  };
  const i10 = a6.stops.sort((e5, a7) => e5.value - a7.value), s8 = n9(i10, 8);
  return { values: s8.map(({ value: e5 }) => e5), sizes: s8.map(({ size: a7 }) => u(a7)) };
}
function S5(e5) {
  return (l8) => {
    const { state: s8 } = l8;
    return { unitValueToPixelsRatio: z(s8.spatialReference) / m[e5.valueUnit ?? "meters"] / s8.resolution };
  };
}
function b5(e5, a6) {
  const i10 = a6.length;
  if (e5 < a6[0].value || 1 === i10) return a6[0].size;
  for (let l8 = 1; l8 < i10; l8++) if (e5 < a6[l8].value) {
    const i11 = (e5 - a6[l8 - 1].value) / (a6[l8].value - a6[l8 - 1].value);
    return a6[l8 - 1].size + i11 * (a6[l8].size - a6[l8 - 1].size);
  }
  return a6[i10 - 1].size;
}
function z4(a6) {
  const { minDataValue: i10, maxDataValue: l8, minSize: s8, maxSize: t13 } = a6;
  if ("object" == typeof s8 && "object" == typeof t13) return (a7, r5) => {
    const n12 = a7.state.scale, u11 = u(b5(n12, s8.stops)), o12 = u(b5(n12, t13.stops));
    return { minMaxValueAndSize: [i10, l8, u11, o12] };
  };
  if ("object" == typeof s8 || "object" == typeof t13) throw new Error("InternalError: Found a partial VisualVariableSizeMinMaxValue");
  return { minMaxValueAndSize: [i10, l8, u(s8), u(t13)] };
}
var x6 = { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: null, visualVariableSizeStops: null, visualVariableSizeScaleStops: null, visualVariableSizeOutlineScaleStops: null, visualVariableSizeUnitValue: null, visualVariableSizeMinMaxValue: null };
function h8(e5, a6 = c5, i10 = u8) {
  if (e5.visualVariableSizeMinMaxValue) return e5.visualVariableSizeMinMaxValue instanceof Function ? o10 : Math.max(e5.visualVariableSizeMinMaxValue.minMaxValueAndSize[3] * i10, a6);
  if (e5.visualVariableSizeScaleStops) {
    if (e5.visualVariableSizeScaleStops instanceof Function) return o10;
    const l8 = e5.visualVariableSizeScaleStops.sizes;
    return Math.max(l8[l8.length - 1] * i10, a6);
  }
  if (e5.visualVariableSizeStops) {
    if (e5.visualVariableSizeStops instanceof Function) return o10;
    const l8 = e5.visualVariableSizeStops.sizes;
    return Math.max(l8[l8.length - 1] * i10, a6);
  }
  return e5.visualVariableSizeUnitValue ? 2 * o10 : 0;
}
function M2(e5) {
  const a6 = { ...x6 };
  if (!e5 || !("visualVariables" in e5) || !e5.visualVariables) return a6;
  for (const i10 of u7(e5.visualVariables)) switch (i10.type) {
    case "color":
      a6.visualVariableColor = p11(i10);
      break;
    case "opacity":
      a6.visualVariableOpacity = v4(i10);
      break;
    case "rotation":
      a6.visualVariableRotation = V2(i10);
      break;
    case "size":
      switch (y3(i10)) {
        case "field-stops":
          a6.visualVariableSizeStops = f9(i10);
          break;
        case "scale-stops":
          "outline" === i10.target ? a6.visualVariableSizeOutlineScaleStops = f9(i10) : a6.visualVariableSizeScaleStops = f9(i10);
          break;
        case "min-max":
          a6.visualVariableSizeMinMaxValue = z4(i10);
          break;
        case "unit-value":
          a6.visualVariableSizeUnitValue = S5(i10);
      }
      break;
  }
  return a6;
}
function y3(e5) {
  return "number" == typeof e5.minDataValue && "number" == typeof e5.maxDataValue && null != e5.minSize && null != e5.maxSize ? "min-max" : "$view.scale" === (e5 == null ? void 0 : e5.valueExpression) && Array.isArray(e5.stops) ? "scale-stops" : null == e5.field && "$view.scale" === (e5 == null ? void 0 : e5.valueExpression) || !(Array.isArray(e5.stops) || "levels" in e5 && e5.levels) ? null != e5.field || "$view.scale" !== (e5 == null ? void 0 : e5.valueExpression) ? "unit-value" : null : "field-stops";
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/utils.js
function a4(a6) {
  return !!(a6.visualVariableSizeMinMaxValue || a6.visualVariableSizeScaleStops || a6.visualVariableSizeStops || a6.visualVariableSizeUnitValue || a6.visualVariableSizeOutlineScaleStops);
}
function i9(a6) {
  return !!a6.visualVariableRotation;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/ComplexSymbolSchema.js
function n11(e5) {
  return e5.minScale || e5.maxScale ? { minScale: e5.minScale ?? 0, maxScale: e5.maxScale ?? 0 } : null;
}
function s6(e5) {
  if (null == e5) return null;
  if (Array.isArray(e5)) {
    const [a6, i10, l8, o12] = e5;
    return [a6, i10, l8, 255 * o12];
  }
  return "string" == typeof e5 ? e5 : { ...e5, defaultValue: s6(e5 == null ? void 0 : e5.defaultValue) };
}
async function c6(a6, i10) {
  const { cimResourceManager: l8, cimAnalyzer: o12, scaleExpression: r5 } = i10.schemaOptions;
  await Promise.all(ee.fetchResources(a6.symbol, l8, []));
  const t13 = o12.analyzeSymbolReference(a6, false), s8 = { scaleInfo: n11(a6), scaleExpression: r5 }, c8 = [];
  for (const e5 of t13) switch (e5.type) {
    case "marker":
      c8.push(...f10(e5, i10, s8));
      break;
    case "fill":
      c8.push(...b6(e5, i10, s8));
      break;
    case "line":
      c8.push(...z5(e5, i10, s8));
      break;
    case "text":
      c8.push(...d8(e5, i10, s8));
  }
  return c8;
}
function f10(e5, a6, i10) {
  const { uniforms: r5, schemaOptions: t13 } = a6, { store: n12 } = t13, s8 = e5.isOutline ? { ...x6, visualVariableSizeScaleStops: r5.visualVariableSizeOutlineScaleStops } : { visualVariableColor: r5.visualVariableColor, visualVariableOpacity: r5.visualVariableOpacity, visualVariableSizeMinMaxValue: r5.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r5.visualVariableSizeScaleStops, visualVariableSizeStops: r5.visualVariableSizeStops, visualVariableSizeUnitValue: r5.visualVariableSizeUnitValue, visualVariableRotation: r5.visualVariableRotation };
  if (e5.animationParams) {
    return u9(n12.ensureInstance(T3.animatedMarker, { uniforms: s8, optionalAttributes: { zoomRange: true } }), e5, x6, i10);
  }
  return m14(n12.ensureInstance(T3.marker, { uniforms: s8, optionalAttributes: { zoomRange: !!i10.scaleInfo } }), e5, r5, i10);
}
function u9(e5, a6, l8, o12) {
  if (!a6.animationParams) return [];
  return [e5.createMeshInfo({ pixelDimensions: a6.pixelDimensions, texelDimensions: a6.texelDimensions, effects: a6.effects ? { type: "cim-effect-infos", effectInfos: a6.effects } : null, sprite: a6.spriteRasterizationParam, animations: a6.animationParams, scaleInfo: o12.scaleInfo, scaleSymbolsProportionally: a6.scaleSymbolsProportionally, strokeWidth: a6.outlineWidth, isMapAligned: a6.alignment === i2.MAP, colorLocked: a6.colorLocked, isStroke: a6.isStroke, baseSize: a6.baseSize, referenceSize: a6.referenceSize, angleToLine: !!a6.markerPlacement && (a6.markerPlacement.placement && "angleToLine" in a6.markerPlacement.placement && a6.markerPlacement.placement.angleToLine), sizeRatio: a6.sizeRatio })];
}
function m14(e5, i10, l8, { scaleInfo: o12, scaleExpression: n12 }) {
  const c8 = a4(l8);
  return [e5.createMeshInfo({ size: i10.size, scaleX: i10.scaleX, anchorX: i10.anchorPoint.x, anchorY: i10.anchorPoint.y, angle: i10.rotation, color: s6(i10.color) ?? [0, 0, 0, 0], colorLocked: i10.colorLocked, frameHeight: i10.frameHeight, widthRatio: i10.widthRatio, scaleInfo: o12, offsetX: i10.offsetX, offsetY: i10.offsetY, outlineColor: s6(i10.outlineColor) ?? [0, 0, 0, 0], outlineSize: i10.outlineWidth, referenceSize: i10.referenceSize || i4.CIMVectorMarker.size, rotateClockwise: i10.rotateClockwise, scaleFactor: n12 ?? 1, sizeRatio: i10.sizeRatio, alignment: i10.alignment, isAbsoluteAnchorPoint: i10.isAbsoluteAnchorPoint, scaleSymbolsProportionally: i10.scaleSymbolsProportionally, sprite: i10.spriteRasterizationParam, hasSizeVV: c8, placement: i10.markerPlacement, effects: i10.effects ? { type: "cim-effect-infos", effectInfos: i10.effects } : null, transforms: i10.transform, minPixelBuffer: h8(l8) })];
}
function p12(e5, a6, i10) {
  const { uniforms: o12, schemaOptions: r5 } = a6, { store: t13 } = r5;
  return S6(t13.ensureInstance(T3.fill, { uniforms: { visualVariableColor: e5.colorLocked ? null : o12.visualVariableColor, visualVariableOpacity: o12.visualVariableOpacity }, optionalAttributes: { zoomRange: !!i10.scaleInfo } }), e5, i10);
}
function S6(e5, a6, { scaleInfo: i10 }) {
  return [e5.createMeshInfo({ color: s6(a6.color) ?? [0, 0, 0, 0], scaleInfo: i10, effects: a6.effects ? { type: "cim-effect-infos", effectInfos: a6.effects } : null })];
}
function b6(e5, a6, i10) {
  if (!e5.spriteRasterizationParam) return p12(e5, a6, i10);
  const { uniforms: o12, schemaOptions: r5 } = a6, { store: t13 } = r5;
  return V3(t13.ensureInstance(T3.complexFill, { uniforms: { visualVariableColor: e5.colorLocked ? null : o12.visualVariableColor, visualVariableOpacity: o12.visualVariableOpacity }, optionalAttributes: { zoomRange: !!i10.scaleInfo } }), e5, null != o12.visualVariableColor, i10);
}
function V3(e5, a6, i10, { scaleInfo: l8 }) {
  if (!a6.spriteRasterizationParam) throw new Error("InternalError: Sprite should always be defined");
  const o12 = !!a6.hasUnresolvedReplacementColor && (!i10 || a6.colorLocked), r5 = a6.sampleAlphaOnly && !o12, t13 = a6.spriteRasterizationParam;
  return [e5.createMeshInfo({ color: s6(a6.color) ?? [0, 0, 0, 0], height: a6.height, aspectRatio: a6.scaleX, offsetX: a6.offsetX, offsetY: a6.offsetY, scaleX: 1, scaleY: 1, angle: a6.angle, applyRandomOffset: a6.applyRandomOffset, sampleAlphaOnly: r5, scaleProportionally: "CIMHatchFill" === t13.resource.type, sprite: t13, scaleInfo: l8, effects: a6.effects ? { type: "cim-effect-infos", effectInfos: a6.effects } : null })];
}
function z5(e5, a6, i10) {
  const { uniforms: r5, schemaOptions: t13 } = a6, { store: n12 } = t13, s8 = e5.isOutline ? { ...x6, visualVariableSizeScaleStops: r5.visualVariableSizeOutlineScaleStops } : { visualVariableColor: e5.colorLocked ? null : r5.visualVariableColor, visualVariableOpacity: r5.visualVariableOpacity, visualVariableSizeMinMaxValue: r5.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: r5.visualVariableSizeScaleStops, visualVariableSizeStops: r5.visualVariableSizeStops, visualVariableSizeUnitValue: r5.visualVariableSizeUnitValue }, c8 = { uniforms: s8, optionalAttributes: { zoomRange: !!i10.scaleInfo } }, f12 = !!(s8.visualVariableSizeMinMaxValue || s8.visualVariableSizeScaleStops || s8.visualVariableSizeStops || s8.visualVariableSizeUnitValue);
  if (!e5.spriteRasterizationParam) {
    return v5(n12.ensureInstance(T3.line, c8), e5, f12, i10);
  }
  return y4(n12.ensureInstance(T3.texturedLine, c8), e5, f12, i10);
}
function h9(e5, a6, { scaleInfo: i10 }) {
  return { color: s6(e5.color) ?? [0, 0, 0, 0], width: e5.width, referenceWidth: e5.referenceWidth, capType: e5.cap, joinType: e5.join, miterLimit: e5.miterLimit, scaleInfo: i10, hasSizeVV: a6, effects: e5.effects ? { type: "cim-effect-infos", effectInfos: e5.effects } : null };
}
function v5(e5, a6, i10, l8) {
  if (a6.spriteRasterizationParam) throw new Error("InternalError: Sprite should not be defined");
  const o12 = h9(a6, i10, l8);
  return [e5.createMeshInfo(o12)];
}
function y4(e5, a6, i10, l8) {
  const { spriteRasterizationParam: o12, scaleDash: r5, sampleAlphaOnly: t13 } = a6;
  if (!o12) throw new Error("InternalError: Sprite should be defined");
  return [e5.createMeshInfo({ ...h9(a6, i10, l8), offsetAlongLine: a6.offsetAlongLine ?? 0, shouldScaleDash: r5 ?? false, shouldSampleAlphaOnly: t13, isSDF: "CIMPictureStroke" !== o12.resource.type, sprite: o12 })];
}
function d8(e5, a6, i10) {
  const { uniforms: o12, schemaOptions: r5 } = a6, { store: t13 } = r5;
  return I4(t13.ensureInstance(T3.text, { uniforms: { visualVariableColor: e5.colorLocked ? null : o12.visualVariableColor, visualVariableOpacity: o12.visualVariableOpacity, visualVariableRotation: o12.visualVariableRotation, visualVariableSizeMinMaxValue: o12.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: o12.visualVariableSizeScaleStops, visualVariableSizeStops: o12.visualVariableSizeStops, visualVariableSizeUnitValue: o12.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: !!i10.scaleInfo, referenceSymbol: false, clipAngle: false } }), e5, o12, i10);
}
function I4(e5, a6, i10, { scaleInfo: l8, scaleExpression: o12 }) {
  return [e5.createMeshInfo({ boxBackgroundColor: s6(a6.backgroundColor), boxBorderLineColor: s6(a6.borderLineColor), boxBorderLineSize: a6.borderLineWidth ?? 0, color: s6(a6.color) ?? [0, 0, 0, 0], offsetX: a6.offsetX, offsetY: a6.offsetY, postAngle: a6.angle, fontSize: a6.size, referenceSize: a6.referenceSize, decoration: a6.decoration, haloColor: s6(a6.haloColor) ?? [0, 0, 0, 0], haloSize: a6.haloSize ?? 0, outlineColor: s6(a6.outlineColor) ?? [0, 0, 0, 0], outlineSize: a6.outlineSize, lineWidth: a6.lineWidth || 512, lineHeightRatio: 1, horizontalAlignment: a6.horizontalAlignment ?? "center", verticalAlignment: a6.verticalAlignment ?? "baseline", useCIMAngleBehavior: false, glyphs: a6.textRasterizationParam, scaleInfo: l8, effects: a6.effects ? { type: "cim-effect-infos", effectInfos: a6.effects } : null, placement: a6.markerPlacement, transforms: a6.transform, scaleFactor: o12 ?? 1, minPixelBuffer: h8(i10), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null })];
}

// node_modules/@arcgis/core/views/2d/layers/support/FeatureCommandQueue.js
var t11 = class {
  constructor(e5) {
    this.updateTracking = new d3({ debugName: "FeatureCommandQueue" }), this._queueProcessor = new _2({ concurrency: 1, process: e5.process });
  }
  destroy() {
    this.updateTracking.destroy(), this._queueProcessor.destroy(), this.clear();
  }
  clear() {
    this._queueProcessor.clear();
  }
  async push(s8) {
    return d(this.updateTracking.addPromise(this._doPush(s8)));
  }
  async _doPush(e5) {
    const s8 = this._queueProcessor, r5 = s8.last();
    switch (e5.type) {
      case "update":
      case "highlight":
        if ((r5 == null ? void 0 : r5.type) === e5.type) return;
        return s8.push(e5);
      case "edit-by-id":
      case "edit-by-feature":
        return s8.push(e5);
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/StorageSchema.js
function t12(e5, i10) {
  return { type: "simple", filters: i10, capabilities: { maxTextureSize: t5().maxTextureSize }, bindings: a5(e5) };
}
function s7(e5) {
  switch (e5) {
    case "opacity":
      return L3.OPACITY;
    case "color":
      return L3.COLOR;
    case "rotation":
      return L3.ROTATION;
    case "size":
      return L3.SIZE;
    default:
      return null;
  }
}
function a5(e5) {
  if (!e5) return [];
  switch (e5.type) {
    case "simple":
    case "class-breaks":
    case "unique-value":
    case "dictionary":
      return c7(e5);
    case "dot-density":
      return o11(e5);
    case "pie-chart":
      return l7(e5);
    case "heatmap":
      return u10(e5);
  }
}
function o11(e5) {
  const i10 = [];
  for (const n12 of e5.attributes) i10.push({ binding: i10.length, expression: n12.valueExpression, field: n12.field });
  return i10;
}
function l7(e5) {
  const i10 = c7(e5);
  let n12 = 4;
  for (const r5 of e5.attributes) i10.push({ binding: n12++, expression: r5.valueExpression, field: r5.field });
  return i10;
}
function u10({ valueExpression: e5, field: i10 }) {
  return e5 || i10 ? [{ binding: 0, expression: e5, field: i10 }] : [];
}
function c7(i10) {
  var _a;
  if (!("visualVariables" in i10) || !((_a = i10.visualVariables) == null ? void 0 : _a.length)) return [];
  return u7(i10.visualVariables).map((e5) => x7(e5)).filter(F);
}
function p13(e5) {
  return "$view.scale" === e5.valueExpression ? null : { binding: s7(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression, valueRepresentation: e5.valueRepresentation };
}
function f11(e5) {
  return { binding: s7(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression };
}
function d9(e5) {
  return { binding: s7(e5.type), field: e5.field, normalizationField: e5.normalizationField, expression: e5.valueExpression };
}
function m15(e5) {
  return { binding: s7(e5.type), expression: e5.valueExpression, field: e5.field };
}
function x7(e5) {
  switch (e5.type) {
    case "size":
      return p13(e5);
    case "color":
      return f11(e5);
    case "opacity":
      return d9(e5);
    case "rotation":
      return m15(e5);
  }
}

export {
  t6 as t,
  t9 as t2,
  t7 as t3,
  i6 as i,
  o6 as o,
  T3 as T,
  w6 as w,
  j3 as j,
  t10 as t4,
  m13 as m,
  x6 as x,
  h8 as h,
  M2 as M,
  a4 as a,
  i9 as i2,
  n11 as n,
  c6 as c,
  u9 as u,
  m14 as m2,
  S6 as S,
  V3 as V,
  v5 as v,
  y4 as y,
  I4 as I,
  t12 as t5,
  c7 as c2,
  t11 as t6
};
//# sourceMappingURL=chunk-5PECYTTZ.js.map
