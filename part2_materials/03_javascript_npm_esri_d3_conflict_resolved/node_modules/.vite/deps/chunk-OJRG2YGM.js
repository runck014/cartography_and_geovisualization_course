import {
  c
} from "./chunk-P5H5PJSC.js";
import {
  o
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/core/number.js
var n = { ar: [".", ","], bg: [",", " "], bs: [",", "."], ca: [",", "."], cs: [",", " "], da: [",", "."], de: [",", "."], "de-ch": [".", "’"], el: [",", "."], en: [".", ","], "en-au": [".", ","], es: [",", "."], "es-mx": [".", ","], et: [",", " "], fi: [",", " "], fr: [",", " "], "fr-ch": [",", " "], he: [".", ","], hi: [".", ",", "#,##,##0.###"], hr: [",", "."], hu: [",", " "], id: [",", "."], it: [",", "."], "it-ch": [".", "’"], ja: [".", ","], ko: [".", ","], lt: [",", " "], lv: [",", " "], mk: [",", "."], nb: [",", " "], nl: [",", "."], pl: [",", " "], pt: [",", "."], "pt-pt": [",", " "], ro: [",", "."], ru: [",", " "], sk: [",", " "], sl: [",", "."], sr: [",", "."], sv: [",", " "], th: [".", ","], tr: [",", "."], uk: [",", " "], vi: [",", "."], zh: [".", ","] };
function r(e = c()) {
  let r2 = (e = e.toLowerCase()) in n;
  if (!r2) {
    const t = e.split("-");
    t.length > 1 && t[0] in n && (e = t[0], r2 = true), r2 || (e = "en");
  }
  const [l2, s2, i2 = "#,##0.###"] = n[e];
  return { decimal: l2, group: s2, pattern: i2 };
}
function l(e, t) {
  const n2 = r((t = { ...t }).locale);
  t.customs = n2;
  const l2 = t.pattern || n2.pattern;
  return isNaN(e) || Math.abs(e) === 1 / 0 ? null : i(e, l2, t);
}
var s = /[#0,]*[#0](?:\.0*#*)?/;
function i(e, t, n2) {
  const r2 = (n2 = n2 || {}).customs.group, l2 = n2.customs.decimal, i2 = t.split(";"), a = i2[0];
  if ((t = i2[e < 0 ? 1 : 0] || "-" + a).includes("%")) e *= 100;
  else if (t.includes("‰")) e *= 1e3;
  else {
    if (t.includes("¤")) throw new Error("currency notation not supported");
    if (t.includes("E")) throw new Error("exponential notation not supported");
  }
  const c3 = s, p2 = a.match(c3);
  if (!p2) throw new Error("unable to find a number expression in pattern: " + t);
  return false === n2.fractional && (n2.places = 0), t.replace(c3, o2(e, p2[0], { decimal: l2, group: r2, places: n2.places, round: n2.round }));
}
function o2(e, t, n2) {
  true === (n2 = n2 || {}).places && (n2.places = 0), n2.places === 1 / 0 && (n2.places = 6);
  const r2 = t.split("."), l2 = "string" == typeof n2.places && n2.places.indexOf(",");
  let s2 = n2.places;
  l2 ? s2 = n2.places.slice(l2 + 1) : +s2 >= 0 || (s2 = (r2[1] || []).length), n2.round < 0 || (e = Number(e.toFixed(Number(s2))));
  const i2 = String(Math.abs(e)).split("."), o3 = i2[1] || "";
  if (r2[1] || n2.places) {
    l2 && (n2.places = n2.places.slice(0, Math.max(0, l2)));
    const e2 = void 0 !== n2.places ? n2.places : r2[1] && r2[1].lastIndexOf("0") + 1;
    +e2 > o3.length && (i2[1] = o3.padEnd(Number(e2), "0")), +s2 < o3.length && (i2[1] = o3.slice(0, Math.max(0, Number(s2))));
  } else i2[1] && i2.pop();
  const a = r2[0].replace(",", "");
  let c3 = a.indexOf("0");
  -1 !== c3 && (c3 = a.length - c3, c3 > i2[0].length && (i2[0] = i2[0].padStart(c3, "0")), a.includes("#") || (i2[0] = i2[0].slice(-c3)));
  let p2, u2, d2 = r2[0].lastIndexOf(",");
  if (-1 !== d2) {
    p2 = r2[0].length - d2 - 1;
    const e2 = r2[0].slice(0, d2);
    d2 = e2.lastIndexOf(","), -1 !== d2 && (u2 = e2.length - d2 - 1);
  }
  const f2 = [];
  for (let g2 = i2[0]; g2; ) {
    const e2 = g2.length - p2;
    f2.push(e2 > 0 ? g2.slice(Math.max(0, e2)) : g2), g2 = e2 > 0 ? g2.slice(0, e2) : "", u2 && (p2 = u2, u2 = void 0);
  }
  return i2[0] = f2.reverse().join(n2.group || ","), i2.join(n2.decimal || ".");
}
function c2(t) {
  const n2 = r((t = t || {}).locale), l2 = t.pattern || n2.pattern, i2 = n2.group, o3 = n2.decimal;
  let a = 1;
  if (l2.includes("%")) a /= 100;
  else if (l2.includes("‰")) a /= 1e3;
  else if (l2.includes("¤")) throw new Error("currency notation not supported");
  const c3 = l2.split(";");
  1 === c3.length && c3.push("-" + c3[0]);
  const p2 = f(c3, (n3) => (n3 = "(?:" + o(n3, ".") + ")").replace(s, (e) => {
    const n4 = { signed: false, separator: t.strict ? i2 : [i2, ""], fractional: t.fractional, decimal: o3, exponent: false }, r2 = e.split(".");
    let l3 = t.places;
    1 === r2.length && 1 !== a && (r2[1] = "###"), 1 === r2.length || 0 === l3 ? n4.fractional = false : (void 0 === l3 && (l3 = t.pattern ? r2[1].lastIndexOf("0") + 1 : 1 / 0), l3 && null == t.fractional && (n4.fractional = true), !t.places && +l3 < r2[1].length && (l3 += "," + r2[1].length), n4.places = l3);
    const s2 = r2[0].split(",");
    return s2.length > 1 && (n4.groupSize = s2.pop().length, s2.length > 1 && (n4.groupSize2 = s2.pop().length)), "(" + u(n4) + ")";
  }), true);
  return { regexp: p2.replaceAll(/[\xa0 ]/g, "[\\s\\xa0]"), group: i2, decimal: o3, factor: a };
}
function p(e, t) {
  const n2 = c2(t), r2 = new RegExp("^" + n2.regexp + "$").exec(e);
  if (!r2) return NaN;
  let l2 = r2[1];
  if (!r2[1]) {
    if (!r2[2]) return NaN;
    l2 = r2[2], n2.factor *= -1;
  }
  return l2 = l2.replaceAll(new RegExp("[" + n2.group + "\\s\\xa0]", "g"), "").replace(n2.decimal, "."), Number(l2) * n2.factor;
}
function u(e) {
  "places" in (e = e || {}) || (e.places = 1 / 0), "string" != typeof e.decimal && (e.decimal = "."), "fractional" in e && !String(e.places).startsWith("0") || (e.fractional = [true, false]), "exponent" in e || (e.exponent = [true, false]), "eSigned" in e || (e.eSigned = [true, false]);
  const t = d(e), n2 = f(e.fractional, (t2) => {
    let n3 = "";
    return t2 && 0 !== e.places && (n3 = "\\" + e.decimal, e.places === 1 / 0 ? n3 = "(?:" + n3 + "\\d+)?" : n3 += "\\d{" + e.places + "}"), n3;
  }, true);
  let r2 = t + n2;
  return n2 && (r2 = "(?:(?:" + r2 + ")|(?:" + n2 + "))"), r2 + f(e.exponent, (t2) => t2 ? "([eE]" + d({ signed: e.eSigned }) + ")" : "");
}
function d(t) {
  "signed" in (t = t || {}) || (t.signed = [true, false]), "separator" in t ? "groupSize" in t || (t.groupSize = 3) : t.separator = "";
  return f(t.signed, (e) => e ? "[-+]" : "", true) + f(t.separator, (n2) => {
    if (!n2) return "(?:\\d+)";
    " " === (n2 = o(n2)) ? n2 = "\\s" : " " === n2 && (n2 = "\\s\\xa0");
    const r2 = t.groupSize, l2 = t.groupSize2;
    if (l2) {
      const e = "(?:0|[1-9]\\d{0," + (l2 - 1) + "}(?:[" + n2 + "]\\d{" + l2 + "})*[" + n2 + "]\\d{" + r2 + "})";
      return r2 - l2 > 0 ? "(?:" + e + "|(?:0|[1-9]\\d{0," + (r2 - 1) + "}))" : e;
    }
    return "(?:0|[1-9]\\d{0," + (r2 - 1) + "}(?:[" + n2 + "]\\d{" + r2 + "})*)";
  }, true);
}
var f = (e, t, n2) => {
  if (!Array.isArray(e)) return t(e);
  const r2 = [];
  for (let l2 = 0; l2 < e.length; l2++) r2.push(t(e[l2]));
  return g(r2.join("|"), Boolean(n2));
};
var g = (e, t) => "(" + (t ? "?:" : "") + e + ")";

export {
  l,
  c2 as c,
  p
};
//# sourceMappingURL=chunk-OJRG2YGM.js.map
