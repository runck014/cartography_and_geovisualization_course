import {
  p as p2
} from "./chunk-UHYXHDMF.js";
import {
  i as i2
} from "./chunk-JEA2CH67.js";
import "./chunk-FDS5NNQY.js";
import {
  r,
  t
} from "./chunk-ACRZEGQW.js";
import "./chunk-NT3C5DNX.js";
import {
  n,
  p
} from "./chunk-XYX2DKFQ.js";
import {
  m
} from "./chunk-VGUQMPM6.js";
import {
  o
} from "./chunk-YQIF7GJR.js";
import {
  a,
  f,
  i,
  s as s3
} from "./chunk-4ISVH4NS.js";
import {
  I as I2
} from "./chunk-P3GRQ2CH.js";
import "./chunk-ECCHNTW6.js";
import "./chunk-WWNVF22O.js";
import "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import "./chunk-VEUN2EF3.js";
import {
  w
} from "./chunk-W6D3ECTZ.js";
import {
  T,
  U,
  j as j2
} from "./chunk-PJNOPBRY.js";
import "./chunk-23TJP3F6.js";
import "./chunk-EMVTPRQK.js";
import "./chunk-EDGKOPSL.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-SEUZ3J6J.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import {
  L,
  w as w2
} from "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-RCLWOQNR.js";
import "./chunk-DOTSJZHK.js";
import "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import {
  S
} from "./chunk-RD2BBQYN.js";
import {
  b
} from "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import {
  j
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  s3 as s2
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import {
  I,
  W
} from "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import "./chunk-H77COA2S.js";
import "./chunk-7LJCT7EA.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/webdoc/support/webdocSaveUtils.js
var I3 = ["NatGeo_World_Map", "Ocean_Basemap", "USA_Topo_Maps", "World_Imagery", "World_Street_Map", "World_Terrain_Base", "World_Topo_Map", "World_Hillshade", "Canvas/World_Light_Gray_Base", "Canvas/World_Light_Gray_Reference", "Canvas/World_Dark_Gray_Base", "Canvas/World_Dark_Gray_Reference", "Ocean/World_Ocean_Base", "Ocean/World_Ocean_Reference", "Reference/World_Boundaries_and_Places", "Reference/World_Reference_Overlay", "Reference/World_Transportation"].map((e) => e.toLowerCase());
async function A(e, t2, r2) {
  r2 ?? (r2 = {}), U2(e, t2), await w(() => !t2.updatingFromView), await t2.load(), await E(t2), await r(t2), await M(e, t2);
  const a2 = t2.portalItem, { json: i3, jsonContext: n2 } = await O(t2, a2);
  return t(n2, { errorName: `${e.name}:save` }, r2), await V(t2, a2), await ye(e, t2, a2, i3, n2), await Promise.all([t2.updateItemThumbnail(), p2(t2.resourceReferences, n2)]), a2;
}
async function O(e, t2) {
  const o2 = o(t2, "web-map", true), r2 = e.write({}, o2);
  return await Promise.all(o2.resources.pendingOperations), { json: r2, jsonContext: o2 };
}
async function T2(e, t2, r2, a2) {
  a2 ?? (a2 = {});
  const i3 = D(e, r2);
  await w(() => !t2.updatingFromView), await t2.load(), await E(t2), await r(t2), await M(e, t2);
  const { json: n2, jsonContext: s4 } = await O(t2, i3);
  t(s4, { errorName: `${e.name}:save` }, a2), await X(t2, i3);
  const l = t2.getThumbnailState();
  return await he(e, t2, i3, n2, s4, a2) && (t2.resourceReferences.portalItem = i3), t2.restoreThumbnailFromState(l), await Promise.all([t2.updateItemThumbnail(), p2(t2.resourceReferences, s4)]), i3;
}
function U2(t2, o2) {
  if (!o2.portalItem) throw new s(`${t2.name}:portal-item-not-set`, "Portal item to save to has not been set on the WebMap");
  C(t2, o2.portalItem);
}
function C(t2, o2) {
  if (o2.type !== t2.itemType) throw new s(`${t2.name}:portal-item-wrong-type`, `Portal item needs to have type "${t2.itemType}"`);
}
async function M(t2, r2) {
  var _a;
  if (!((_a = r2.basemap) == null ? void 0 : _a.baseLayers.length)) throw new s(`${t2.name}:save`, "Map does not have a valid basemap with a base layer.");
  let a2 = null;
  if (await w(() => {
    const e = j2(r2.initialViewProperties, r2.basemap);
    return a2 = e.spatialReference, !e.updating;
  }), !s2(a2, r2.initialViewProperties.spatialReference)) throw new s(`${t2.name}:save`, "The spatial reference of the basemap is not compatible with the one from the map.", { expected: r2.initialViewProperties.spatialReference, actual: a2 });
}
function D(e, t2) {
  let o2 = S.from(t2);
  return o2.id && (o2 = o2.clone(), o2.id = null), o2.type || (o2.type = e.itemType), o2.portal || (o2.portal = b.getDefault()), C(e, o2), o2;
}
function E(e) {
  const t2 = [];
  return e.basemap && t2.push(e.basemap.load()), e.ground && t2.push(e.ground.load()), Promise.allSettled(t2).then(() => {
  });
}
async function V(e, t2) {
  t2.extent = await pe(e.portalItem, e.initialViewProperties.viewpoint.targetGeometry), await Y(e, t2);
}
var k = f.JSAPI;
var x = "CollectorDisabled";
var G = "Collector";
var L2 = "Data Editing";
var N = "OfflineDisabled";
var $ = "Offline";
var B = "Workforce Project";
var F = "Workforce Worker";
var K = "Workforce Dispatcher";
var H = "Offline Map Areas";
var J = "FieldMapsDisabled";
var q = f.DEVELOPER_BASEMAP;
var z = "UtilityNetwork";
var Q = "IPS";
async function X(e, t2) {
  a(t2, x), a(t2, J), a(t2, f.METADATA), a(t2, N), a(t2, H), a(t2, K), a(t2, B), a(t2, F), await V(e, t2);
}
async function Y(e, t2) {
  i(t2, k), await Z(e), re(e, t2), ae(e, t2), ie(e, t2), ne(e, t2), se(e, t2), le(e, t2), t2.typeKeywords && (t2.typeKeywords = t2.typeKeywords.filter((e2, t3, o2) => o2.indexOf(e2) === t3));
}
function Z(e) {
  const t2 = ee(e).map((e2) => e2.load()).toArray();
  return Promise.allSettled(t2).then(() => {
  });
}
function ee(e) {
  return e.allLayers.concat(e.allTables);
}
function te(e) {
  return ee(e).some((e2) => e2.loaded && L(e2) && e2.capabilities.operations.supportsEditing && e2.editingEnabled && ("subtype-group" !== e2.type || e2.sublayers.some((e3) => e3.editingEnabled)));
}
function oe(e) {
  return ee(e).filter((e2) => "group" !== e2.type).every((t2) => t2.loaded && me(e, t2));
}
function re(e, t2) {
  s3(t2, x) || s3(t2, B) || s3(t2, F) || s3(t2, K) || !te(e) ? a(t2, G) : i(t2, G);
}
function ae(e, t2) {
  te(e) ? i(t2, L2) : a(t2, L2);
}
function ie(e, t2) {
  !s3(t2, N) && oe(e) ? i(t2, $) : a(t2, $);
}
function ne(e, t2) {
  T(e.basemap) ? i(t2, q) : a(t2, q);
}
function se(e, t2) {
  var _a;
  ((_a = e.utilityNetworks) == null ? void 0 : _a.length) ? i(t2, z) : a(t2, z);
}
function le(e, t2) {
  e.ipsInfo ? i(t2, Q) : a(t2, Q);
}
async function pe(e, t2) {
  const o2 = t2.clone().normalize();
  let r2;
  if (o2.length > 1) for (const a2 of o2) r2 ? a2.width > r2.width && (r2 = a2) : r2 = a2;
  else r2 = o2[0];
  return ce(e, r2);
}
async function ce(e, t2) {
  const o2 = t2.spatialReference;
  if (o2.isWGS84) return t2.clone();
  if (o2.isWebMercator) return j(t2);
  const { getGeometryServiceURL: r2 } = await import("./geometryServiceUtils-6L6FBVHH.js"), a2 = await r2(e), i3 = new p({ geometries: [t2], outSpatialReference: g.WGS84 });
  return (await n(a2, i3))[0];
}
function ue(e) {
  return w2(e) || "map-notes" === e.type || "route" === e.type;
}
function me(e, t2) {
  return L(t2) && t2.capabilities.operations.supportsSync || ue(t2) && !t2.portalItem || fe(t2) && !de(t2) && t2.spatialReference.equals(e.initialViewProperties.spatialReference);
}
function fe(e) {
  return ("tile" === e.type || "vector-tile" === e.type) && (e.capabilities.operations.supportsExportTiles || we(e) || U(e));
}
function de(e) {
  return "vector-tile" === e.type && Object.keys(e.sourceNameToSource).length > 1;
}
function we(e) {
  return "tile" === e.type && (I2(e.url) && I3.some((t2) => {
    var _a;
    return (_a = e.url) == null ? void 0 : _a.toLowerCase().includes("/" + t2 + "/");
  }));
}
async function ye(e, t2, o2, r2, a2) {
  await o2.update({ data: r2 }), be(e, t2, o2, r2, a2);
}
async function he(t2, o2, r2, a2, i3, n2) {
  const s4 = o2.portalItem, l = { item: s4, authenticated: !(!(s4 == null ? void 0 : s4.id) || !s4.portal.user) }, p3 = r2.portal;
  await p3.signIn();
  const { copyAllowed: c, itemReloaded: u } = await ge(l, p3);
  if (l.authenticated || (l.authenticated = u), !c) throw new s(`${t2.name}:save-as-copy-not-allowed`, "Owner of this map does not allow others to save a copy");
  const m2 = await _e(r2, l, a2, n2);
  return o2.portalItem = r2, be(t2, o2, r2, a2, i3), m2;
}
async function ge(e, t2) {
  var _a;
  const { item: o2, authenticated: r2 } = e;
  return (o2 == null ? void 0 : o2.id) && ((_a = o2.typeKeywords) == null ? void 0 : _a.includes("useOnly")) ? o2.portal.portalHostname !== t2.portalHostname ? { copyAllowed: false, itemReloaded: false } : (r2 || await o2.reload(), { copyAllowed: "admin" === o2.itemControl || "update" === o2.itemControl, itemReloaded: true }) : { copyAllowed: true, itemReloaded: false };
}
async function _e(e, t2, o2, a2) {
  const i3 = e.portal, { item: n2 } = t2, { folder: s4, copyAllResources: l } = a2;
  let p3 = false;
  if (l && (n2 == null ? void 0 : n2.id) && W(n2.portal.url, i3.url) && parseInt(n2.portal.currentVersion, 10) >= 2023) {
    const { total: e2 } = await n2.fetchResources();
    p3 = !!e2;
  }
  if (p3) {
    const t3 = await n2.copy({ copyResources: "all", folder: s4 });
    e.id = t3.id, e.portal = t3.portal;
    const r2 = e.toJSON();
    await e.load(), e.read(r2), await e.update({ data: o2 });
  } else await i3.user.addItem({ item: e, folder: s4, data: o2 });
  return p3;
}
function be(e, o2, r2, n2, s4) {
  m.prototype.read.call(o2, { version: n2.version, authoringApp: n2.authoringApp, authoringAppVersion: n2.authoringAppVersion }, { origin: e.origin, ignoreDefaults: true, url: r2.itemUrl ? I(r2.itemUrl) : void 0 }), i2(s4), o2.resourceInfo = n2;
}
export {
  O as createJSON,
  _e as initializeNewItem,
  ge as isCopyAllowed,
  A as save,
  T2 as saveAs
};
//# sourceMappingURL=webdocSaveUtils-7COFEXL7.js.map
