import {
  o as o3
} from "./chunk-NACUKAMN.js";
import {
  n as n5
} from "./chunk-PAS43ZQC.js";
import {
  i as i4,
  o as o2
} from "./chunk-G7VPHLH2.js";
import {
  n as n4
} from "./chunk-V6VYGXU4.js";
import {
  n as n3,
  p as p3
} from "./chunk-5Y4XRWDV.js";
import {
  H
} from "./chunk-6ZMDPECL.js";
import {
  R
} from "./chunk-6B4OMNPA.js";
import {
  d
} from "./chunk-6Q7GN2CW.js";
import {
  y
} from "./chunk-AVBIV2K3.js";
import {
  p as p2
} from "./chunk-TA32QX7Z.js";
import {
  f as f3,
  i as i2,
  s as s3
} from "./chunk-WWNVF22O.js";
import {
  v
} from "./chunk-W6D3ECTZ.js";
import {
  b as b2,
  i as i3
} from "./chunk-BWTCR2DR.js";
import {
  n as n2
} from "./chunk-SMOTPOZ7.js";
import {
  n
} from "./chunk-EZXLBRAS.js";
import {
  i
} from "./chunk-2PK57UYA.js";
import {
  f as f2,
  p
} from "./chunk-3L2AYCZY.js";
import {
  V
} from "./chunk-RCLWOQNR.js";
import {
  w
} from "./chunk-FG3XOAFD.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  g,
  r as r3
} from "./chunk-2WXAPZBK.js";
import {
  c,
  z
} from "./chunk-E2I7HYXQ.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a,
  h,
  r2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  e,
  k,
  s as s2
} from "./chunk-GRW2QIBT.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F,
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/rest/operations/identify.js
function o4(e2, r4) {
  const { dpi: n6, gdbVersion: s5, geometry: o5, geometryPrecision: a5, height: m4, historicMoment: p5, layerOption: f5, mapExtent: y2, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d3, returnUnformattedValues: g2, returnZ: x, spatialReference: h2, timeExtent: b3, tolerance: E, width: O } = e2.toJSON(), { dynamicLayers: S, layerDefs: j, layerIds: N } = l(e2), $ = null != (r4 == null ? void 0 : r4.geometry) ? r4.geometry : null, I2 = { historicMoment: p5, geometryPrecision: a5, maxAllowableOffset: u3, returnFieldName: c2, returnGeometry: d3, returnUnformattedValues: g2, returnZ: x, tolerance: E }, R3 = ($ == null ? void 0 : $.toJSON()) || o5;
  I2.imageDisplay = `${O},${m4},${n6}`, s5 && (I2.gdbVersion = s5), R3 && (delete R3.spatialReference, I2.geometry = JSON.stringify(R3), I2.geometryType = p(R3));
  const U2 = h2 ?? (R3 == null ? void 0 : R3.spatialReference) ?? (y2 == null ? void 0 : y2.spatialReference);
  if (U2 && (I2.sr = c(U2)), I2.time = b3 ? [b3.start, b3.end].join(",") : null, y2) {
    const { xmin: e3, ymin: t, xmax: r5, ymax: i5 } = y2;
    I2.mapExtent = `${e3},${t},${r5},${i5}`;
  }
  return j && (I2.layerDefs = j), S && !j && (I2.dynamicLayers = S), I2.layers = "popup" === f5 ? "visible" : f5, N && !S && (I2.layers += `:${N.join(",")}`), I2;
}
function l(e2) {
  var _a, _b;
  const { mapExtent: t, floors: i5, width: o5, sublayers: l2, layerIds: m4, layerOption: p5, gdbVersion: f5 } = e2, y2 = (_b = (_a = l2 == null ? void 0 : l2.find((e3) => null != e3.layer)) == null ? void 0 : _a.layer) == null ? void 0 : _b.serviceSublayers, u3 = "popup" === p5, c2 = {}, d3 = i4({ extent: t, width: o5, spatialReference: t == null ? void 0 : t.spatialReference }), g2 = [], x = (e3) => {
    const t2 = 0 === d3, r4 = 0 === e3.minScale || d3 <= e3.minScale, i6 = 0 === e3.maxScale || d3 >= e3.maxScale;
    if (e3.visible && (t2 || r4 && i6)) if (e3.sublayers) e3.sublayers.forEach(x);
    else {
      if (false === (m4 == null ? void 0 : m4.includes(e3.id)) || u3 && (!e3.popupTemplate || !e3.popupEnabled)) return;
      g2.unshift(e3);
    }
  };
  if (l2 == null ? void 0 : l2.forEach(x), l2 && !g2.length) c2.layerIds = [];
  else {
    const e3 = n4(g2, y2, f5), t2 = g2.map((e4) => {
      const t3 = n5(i5, e4);
      return e4.toExportImageJSON(t3);
    });
    if (e3) c2.dynamicLayers = JSON.stringify(t2);
    else {
      if (l2) {
        let e5 = g2.map(({ id: e6 }) => e6);
        m4 && (e5 = e5.filter((e6) => m4.includes(e6))), c2.layerIds = e5;
      } else (m4 == null ? void 0 : m4.length) && (c2.layerIds = m4);
      const e4 = a2(i5, g2);
      if (null != e4 && e4.length) {
        const t3 = {};
        for (const r4 of e4) r4.definitionExpression && (t3[r4.id] = r4.definitionExpression);
        Object.keys(t3).length && (c2.layerDefs = JSON.stringify(t3));
      }
    }
  }
  return c2;
}
function a2(t, r4) {
  const i5 = !!(t == null ? void 0 : t.length), s5 = r4.filter((e2) => null != e2.definitionExpression || i5 && null != e2.floorInfo);
  return s5.length ? s5.map((r5) => {
    const i6 = n5(t, r5), s6 = n2(i6, r5.definitionExpression);
    return { id: r5.id, definitionExpression: s6 ?? void 0 };
  }) : null;
}

// node_modules/@arcgis/core/rest/support/IdentifyParameters.js
var a3;
var u = a3 = class extends f {
  static from(t) {
    return h(a3, t);
  }
  constructor(t) {
    super(t), this.dpi = 96, this.floors = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = null, this.height = 400, this.historicMoment = null, this.layerIds = null, this.layerOption = "top", this.mapExtent = null, this.maxAllowableOffset = null, this.returnFieldName = true, this.returnGeometry = false, this.returnM = false, this.returnUnformattedValues = true, this.returnZ = false, this.spatialReference = null, this.sublayers = null, this.timeExtent = null, this.tolerance = null, this.width = 400;
  }
  writeHistoricMoment(t, e2) {
    e2.historicMoment = t && t.getTime();
  }
};
r([m({ type: Number, json: { write: true } })], u.prototype, "dpi", void 0), r([m()], u.prototype, "floors", void 0), r([m({ type: String, json: { write: true } })], u.prototype, "gdbVersion", void 0), r([m({ types: n, json: { read: f2, write: true } })], u.prototype, "geometry", void 0), r([m({ type: Number, json: { write: true } })], u.prototype, "geometryPrecision", void 0), r([m({ type: Number, json: { write: true } })], u.prototype, "height", void 0), r([m({ type: Date })], u.prototype, "historicMoment", void 0), r([r3("historicMoment")], u.prototype, "writeHistoricMoment", null), r([m({ type: [Number], json: { write: true } })], u.prototype, "layerIds", void 0), r([m({ type: ["top", "visible", "all", "popup"], json: { write: true } })], u.prototype, "layerOption", void 0), r([m({ type: w, json: { write: true } })], u.prototype, "mapExtent", void 0), r([m({ type: Number, json: { write: true } })], u.prototype, "maxAllowableOffset", void 0), r([m({ type: Boolean, json: { write: true } })], u.prototype, "returnFieldName", void 0), r([m({ type: Boolean, json: { write: true } })], u.prototype, "returnGeometry", void 0), r([m({ type: Boolean, json: { write: true } })], u.prototype, "returnM", void 0), r([m({ type: Boolean, json: { write: true } })], u.prototype, "returnUnformattedValues", void 0), r([m({ type: Boolean, json: { write: true } })], u.prototype, "returnZ", void 0), r([m({ type: g, json: { write: true } })], u.prototype, "spatialReference", void 0), r([m()], u.prototype, "sublayers", void 0), r([m({ type: p2, json: { write: true } })], u.prototype, "timeExtent", void 0), r([m({ type: Number, json: { write: true } })], u.prototype, "tolerance", void 0), r([m({ type: Number, json: { write: true } })], u.prototype, "width", void 0), u = a3 = r([a("esri.rest.support.IdentifyParameters")], u);
var d2 = u;

// node_modules/@arcgis/core/rest/support/IdentifyResult.js
var u2 = class extends f {
  constructor(r4) {
    super(r4), this.displayFieldName = null, this.feature = null, this.layerId = null, this.layerName = null;
  }
  readFeature(r4, t) {
    return d.fromJSON({ attributes: { ...t.attributes }, geometry: { ...t.geometry } });
  }
  writeFeature(r4, e2) {
    if (!r4) return;
    const { attributes: t, geometry: o5 } = r4;
    t && (e2.attributes = { ...t }), null != o5 && (e2.geometry = o5.toJSON(), e2.geometryType = i.toJSON(o5.type));
  }
};
r([m({ type: String, json: { write: true } })], u2.prototype, "displayFieldName", void 0), r([m({ type: d })], u2.prototype, "feature", void 0), r([o("feature", ["attributes", "geometry"])], u2.prototype, "readFeature", null), r([r3("feature")], u2.prototype, "writeFeature", null), r([m({ type: Number, json: { write: true } })], u2.prototype, "layerId", void 0), r([m({ type: String, json: { write: true } })], u2.prototype, "layerName", void 0), u2 = r([a("esri.rest.support.IdentifyResult")], u2);
var m2 = u2;

// node_modules/@arcgis/core/rest/identify.js
async function f4(u3, i5, f5) {
  const c2 = (i5 = a4(i5)).geometry ? [i5.geometry] : [], l2 = f3(u3);
  return l2.path += "/identify", R(c2).then((e2) => {
    const t = o4(i5, { geometry: e2 == null ? void 0 : e2[0] }), u4 = s3({ ...l2.query, f: "json", ...t }), a5 = i2(u4, f5);
    return U(l2.path, a5).then(m3).then((r4) => p4(r4, i5.sublayers));
  });
}
function m3(r4) {
  const e2 = r4.data;
  return e2.results = e2.results || [], e2.exceededTransferLimit = Boolean(e2.exceededTransferLimit), e2.results = e2.results.map((r5) => m2.fromJSON(r5)), e2;
}
function a4(r4) {
  return r4 = d2.from(r4);
}
function p4(r4, e2) {
  if (!(e2 == null ? void 0 : e2.length)) return r4;
  const t = /* @__PURE__ */ new Map();
  function o5(r5) {
    t.set(r5.id, r5), r5.sublayers && r5.sublayers.forEach(o5);
  }
  e2.forEach(o5);
  for (const s5 of r4.results) s5.feature.sourceLayer = t.get(s5.layerId);
  return r4;
}

// node_modules/@arcgis/core/views/3d/layers/support/highlightUtils.js
var s4 = e();

// node_modules/@arcgis/core/views/layers/support/MapServiceLayerViewHelper.js
var G = null;
function _(e2, t) {
  return "tile" === t.type || "map-image" === t.type;
}
var R2 = class extends b {
  constructor(e2) {
    super(e2), this._featuresResolutions = /* @__PURE__ */ new WeakMap(), this.highlightGraphics = null, this.highlightGraphicUpdated = null, this.updateHighlightedFeatures = k(async (e3) => {
      this.destroyed || this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(e3).catch(() => {
      }));
    });
  }
  initialize() {
    const e2 = (e3) => {
      this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(e3).catch(() => {
      })), this.updateHighlightedFeatures(this._highlightGeometriesResolution);
    };
    this.addHandles([v(() => this.highlightGraphics, "change", (t) => e2(t.added), { onListenerAdd: (t) => e2(t) })]);
  }
  async fetchPopupFeaturesAtLocation(e2, t) {
    var _a, _b;
    const { layerView: { layer: r4, view: { scale: s5 } } } = this;
    if (!e2) throw new s("fetchPopupFeatures:invalid-area", "Nothing to fetch without area", { layer: r4 });
    const i5 = A(r4.sublayers, s5, t);
    if (!i5.length) return [];
    const a5 = await V2(r4, i5);
    if (!((((_b = (_a = r4.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsIdentify) ?? true) && r4.version >= 10.5) && !a5) throw new s("fetchPopupFeatures:not-supported", "query operation is disabled for this service", { layer: r4 });
    return a5 ? this._fetchPopupFeaturesUsingQueries(e2, i5, t) : this._fetchPopupFeaturesUsingIdentify(e2, i5, t);
  }
  clearHighlights() {
    var _a;
    (_a = this.highlightGraphics) == null ? void 0 : _a.removeAll();
  }
  highlight(e2) {
    const r4 = this.highlightGraphics;
    if (!e2 || !r4) return s4;
    let o5 = H(e2) ? [e2] : V.isCollection(e2) ? e2.toArray() : Array.isArray(e2) ? e2 : [];
    if (o5 = o5 == null ? void 0 : o5.filter(F), 0 === ((o5 == null ? void 0 : o5.length) ?? 0)) return s4;
    for (const t of o5) {
      const { sourceLayer: e3 } = t;
      null != e3 && "geometryType" in e3 && "point" === e3.geometryType && (t.visible = false);
    }
    return r4.addMany(o5), e(() => r4.removeMany(o5 ?? []));
  }
  async _updateHighlightedFeaturesSymbols(e2) {
    const { layerView: { view: t }, highlightGraphics: r4, highlightGraphicUpdated: s5 } = this;
    if (r4 && s5) for (const i5 of e2) {
      const e3 = i5.sourceLayer && "renderer" in i5.sourceLayer && i5.sourceLayer.renderer;
      i5.sourceLayer && "geometryType" in i5.sourceLayer && "point" === i5.sourceLayer.geometryType && e3 && "getSymbolAsync" in e3 && e3.getSymbolAsync(i5).then(async (o5) => {
        var _a;
        o5 || (o5 = new y());
        let a5 = null;
        const n6 = "visualVariables" in e3 ? (_a = e3.visualVariables) == null ? void 0 : _a.find((e4) => "size" === e4.type) : void 0;
        n6 && (G || (G = (await import("./visualVariableUtils-BBI5S5CS.js")).getSize), a5 = G(n6, i5, { view: t.type, scale: t.scale, shape: "simple-marker" === o5.type ? o5.style : null })), a5 || (a5 = "width" in o5 && "height" in o5 && null != o5.width && null != o5.height ? Math.max(o5.width, o5.height) : "size" in o5 ? o5.size : 16), r4.includes(i5) && (i5.symbol = new y({ style: "square", size: a5, xoffset: "xoffset" in o5 ? o5.xoffset : 0, yoffset: "yoffset" in o5 ? o5.yoffset : 0 }), s5(i5, "symbol"), i5.visible = true);
      });
    }
  }
  async _updateHighlightedFeaturesGeometries(e2) {
    const { layerView: { layer: t, view: r4 }, highlightGraphics: s5, highlightGraphicUpdated: i5 } = this;
    if (this._highlightGeometriesResolution = e2, !i5 || !(s5 == null ? void 0 : s5.length) || !t.capabilities.operations.supportsQuery) return;
    const o5 = this._getTargetResolution(e2), a5 = /* @__PURE__ */ new Map();
    for (const c2 of s5) if (!this._featuresResolutions.has(c2) || this._featuresResolutions.get(c2) > o5) {
      const e3 = c2.sourceLayer;
      r2(a5, e3, () => /* @__PURE__ */ new Map()).set(c2.getObjectId(), c2);
    }
    const l2 = Array.from(a5, ([e3, t2]) => {
      const s6 = e3.createQuery();
      return s6.objectIds = [...t2.keys()], s6.outFields = [e3.objectIdField], s6.returnGeometry = true, s6.maxAllowableOffset = o5, s6.outSpatialReference = r4.spatialReference, e3.queryFeatures(s6);
    }), p5 = await Promise.all(l2);
    if (!this.destroyed) for (const { features: n6 } of p5) for (const e3 of n6) {
      const t2 = e3.sourceLayer, r5 = a5.get(t2).get(e3.getObjectId());
      r5 && s5.includes(r5) && (r5.geometry = e3.geometry, i5(r5, "geometry"), this._featuresResolutions.set(r5, o5));
    }
  }
  _getTargetResolution(e2) {
    const t = e2 * z(this.layerView.view.spatialReference), r4 = t / 16;
    return r4 <= 10 ? 0 : e2 / t * r4;
  }
  async _fetchPopupFeaturesUsingIdentify(e2, t, r4) {
    const s5 = await this._createIdentifyParameters(e2, t, r4);
    if (null == s5) return [];
    const { results: i5 } = await f4(this.layerView.layer.parsedUrl, s5, r4);
    return i5.map((e3) => e3.feature);
  }
  async _createIdentifyParameters(e2, t, r4) {
    const { floors: s5, layer: i5, timeExtent: o5, view: { spatialReference: a5, scale: n6 } } = this.layerView;
    if (!t.length) return null;
    await Promise.all(t.map(({ sublayer: e3 }) => e3.load(r4).catch(() => {
    })));
    const l2 = Math.min(has("mapservice-popup-identify-max-tolerance"), i5.allSublayers.reduce((e3, t2) => t2.renderer ? o3({ renderer: t2.renderer, pointerType: r4 == null ? void 0 : r4.pointerType }) : e3, 2)), p5 = this.createFetchPopupFeaturesQueryGeometry(e2, l2), c2 = o2(n6, a5), u3 = Math.round(p5.width / c2), h2 = new w({ xmin: p5.center.x - c2 * u3, ymin: p5.center.y - c2 * u3, xmax: p5.center.x + c2 * u3, ymax: p5.center.y + c2 * u3, spatialReference: p5.spatialReference });
    return new d2({ floors: s5, gdbVersion: "gdbVersion" in i5 ? i5.gdbVersion : void 0, geometry: e2, height: u3, layerOption: "popup", mapExtent: h2, returnGeometry: true, spatialReference: a5, sublayers: i5.sublayers, timeExtent: o5, tolerance: l2, width: u3 });
  }
  async _fetchPopupFeaturesUsingQueries(e2, t, r4) {
    const { layerView: { floors: i5, timeExtent: o5 } } = this, a5 = t.map(async ({ sublayer: t2, popupTemplate: s5 }) => {
      var _a;
      if (await t2.load(r4).catch(() => {
      }), t2.capabilities && !t2.capabilities.operations.supportsQuery) return [];
      const a6 = t2.createQuery(), n6 = o3({ renderer: t2.renderer, pointerType: r4 == null ? void 0 : r4.pointerType }), l2 = this.createFetchPopupFeaturesQueryGeometry(e2, n6), c2 = /* @__PURE__ */ new Set(), [h2] = await Promise.all([n3(t2, s5), (_a = t2.renderer) == null ? void 0 : _a.collectRequiredFields(c2, t2.fieldsIndex)]);
      s2(r4), b2(c2, t2.fieldsIndex, h2);
      const y2 = Array.from(c2).sort();
      a6.geometry = l2, a6.outFields = y2, a6.timeExtent = o5;
      const m4 = n5(i5, t2);
      a6.where = n2(a6.where, m4);
      const f5 = this._getTargetResolution(l2.width / n6), d3 = await T(s5);
      s2(r4);
      const j = "point" === t2.geometryType || d3 && d3.arcadeUtils.hasGeometryOperations(s5);
      j || (a6.maxAllowableOffset = f5);
      let { features: v2 } = await t2.queryFeatures(a6, r4);
      const x = j ? 0 : f5;
      v2 = await I(t2, v2, r4);
      for (const e3 of v2) this._featuresResolutions.set(e3, x);
      return v2;
    });
    return (await Promise.allSettled(a5)).reduce((e3, t2) => "fulfilled" === t2.status ? [...e3, ...t2.value] : e3, []).filter(F);
  }
};
function A(e2, t, r4) {
  const s5 = [];
  if (!e2) return s5;
  const i5 = (e3) => {
    const o5 = 0 === e3.minScale || t <= e3.minScale, a5 = 0 === e3.maxScale || t >= e3.maxScale;
    if (e3.visible && o5 && a5) {
      if (e3.sublayers) e3.sublayers.forEach(i5);
      else if (e3.popupEnabled) {
        const t2 = p3(e3, { ...r4, defaultPopupTemplateEnabled: false });
        null != t2 && s5.unshift({ sublayer: e3, popupTemplate: t2 });
      }
    }
  };
  return e2.map(i5), s5;
}
function T(e2) {
  var _a;
  return ((_a = e2.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e2.content) && e2.content.some((e3) => "expression" === e3.type) ? i3() : Promise.resolve();
}
async function V2(e2, t) {
  var _a, _b;
  if ((_b = (_a = e2.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsQuery) return true;
  try {
    return await Promise.any(t.map(({ sublayer: e3 }) => e3.load().then(() => e3.capabilities.operations.supportsQuery)));
  } catch {
    return false;
  }
}
async function I(e2, t, r4) {
  const s5 = e2.renderer;
  return s5 && "defaultSymbol" in s5 && !s5.defaultSymbol && (t = s5.valueExpression ? await Promise.all(t.map((e3) => s5.getSymbolAsync(e3, r4).then((t2) => t2 ? e3 : null))).then((e3) => e3.filter((e4) => null != e4)) : t.filter((e3) => null != s5.getSymbol(e3))), t;
}
r([m({ constructOnly: true })], R2.prototype, "createFetchPopupFeaturesQueryGeometry", void 0), r([m({ constructOnly: true })], R2.prototype, "layerView", void 0), r([m({ constructOnly: true })], R2.prototype, "highlightGraphics", void 0), r([m({ constructOnly: true })], R2.prototype, "highlightGraphicUpdated", void 0), r([m({ constructOnly: true })], R2.prototype, "updatingHandles", void 0), R2 = r([a("esri.views.layers.support.MapServiceLayerViewHelper")], R2);

export {
  _,
  R2 as R
};
//# sourceMappingURL=chunk-37X6JYDL.js.map
