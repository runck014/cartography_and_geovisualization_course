import {
  E as E2
} from "./chunk-VVL7KRSE.js";
import {
  S,
  c as c4,
  f as f3,
  x
} from "./chunk-X3DAAXDC.js";
import "./chunk-A3GASGJZ.js";
import {
  a as a4
} from "./chunk-RH3RAT7T.js";
import "./chunk-556C3V64.js";
import {
  m as m2
} from "./chunk-NJKQE6C5.js";
import {
  o as o4
} from "./chunk-ENHHZ2WV.js";
import "./chunk-HKWBRI3V.js";
import {
  V
} from "./chunk-NW6OWOSJ.js";
import "./chunk-EVK6ZSVY.js";
import "./chunk-MSUBZ5BW.js";
import "./chunk-YEDSTDY4.js";
import "./chunk-P4TUSPKE.js";
import {
  ct,
  gt,
  it
} from "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import "./chunk-HACIIBEF.js";
import "./chunk-2BVPGUC2.js";
import "./chunk-BN24XFSK.js";
import "./chunk-547Z5YIS.js";
import "./chunk-4WB72ND2.js";
import "./chunk-LIUBAYCM.js";
import "./chunk-BLYF375M.js";
import {
  h as h2
} from "./chunk-NIWINVGG.js";
import {
  n as n2
} from "./chunk-DOENTAA7.js";
import "./chunk-CVI4GL5M.js";
import "./chunk-CGSFKZP2.js";
import {
  e as e3
} from "./chunk-WPERPIJF.js";
import "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-XKMN3LJN.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import {
  h
} from "./chunk-GYV5TPN6.js";
import {
  z
} from "./chunk-ZOEKS56J.js";
import {
  t as t2
} from "./chunk-IYJHGZBJ.js";
import "./chunk-T6QS4ZNU.js";
import "./chunk-D3FSVA7H.js";
import "./chunk-6B4OMNPA.js";
import "./chunk-3GQ4PJDJ.js";
import "./chunk-QEJMJI2R.js";
import {
  b as b3
} from "./chunk-F3NUC2RS.js";
import "./chunk-LE3YW4Y3.js";
import "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import {
  g as g2
} from "./chunk-P3GRQ2CH.js";
import "./chunk-NYLBGE62.js";
import "./chunk-QCBTLG25.js";
import "./chunk-ECCHNTW6.js";
import "./chunk-WWNVF22O.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import {
  e as e2
} from "./chunk-VEUN2EF3.js";
import {
  C,
  d as d2,
  p,
  w
} from "./chunk-W6D3ECTZ.js";
import "./chunk-PJNOPBRY.js";
import "./chunk-23TJP3F6.js";
import "./chunk-EMVTPRQK.js";
import "./chunk-EDGKOPSL.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-SEUZ3J6J.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-7FJIOZSE.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import {
  f as f2
} from "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import {
  E,
  c as c3,
  l as l2,
  o as o3,
  u as u2
} from "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-RCLWOQNR.js";
import {
  o as o2
} from "./chunk-DOTSJZHK.js";
import {
  b as b2,
  d
} from "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-RD2BBQYN.js";
import "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-AIYFWM42.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  w as w2
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  W2 as W
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import {
  b2 as b,
  e2 as e,
  f,
  i2 as i,
  m,
  o4 as o,
  u3 as u
} from "./chunk-H77COA2S.js";
import {
  a4 as a3,
  r2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  L,
  a as a2,
  s
} from "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  a,
  l2 as l,
  n2 as n
} from "./chunk-PKLD5YJF.js";
import {
  c,
  c2,
  t3 as t
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationAlignment.js
function i2(e5 = false, t5) {
  if (e5) {
    const { elevationInfo: e6, alignPointsInFeatures: s3 } = t5;
    return new c5(e6, s3);
  }
  return new a5();
}
var a5 = class {
  async alignCandidates(e5, t5, s3) {
    return e5;
  }
  notifyElevationSourceChange() {
  }
};
var r3 = 1024;
var c5 = class {
  constructor(t5, s3) {
    this._elevationInfo = t5, this._alignPointsInFeatures = s3, this._alignmentsCache = new e3(r3), this._cacheVersion = 0;
  }
  async alignCandidates(e5, t5, s3) {
    const n6 = this._elevationInfo;
    return null == n6 || "absolute-height" !== n6.mode || n6.featureExpressionInfo ? this._alignComputedElevationCandidates(e5, t5, s3) : (l3(e5, t5, n6), e5);
  }
  notifyElevationSourceChange() {
    this._alignmentsCache.clear(), this._cacheVersion++;
  }
  async _alignComputedElevationCandidates(e5, n6, o6) {
    const i6 = /* @__PURE__ */ new Map();
    for (const s3 of e5) r2(i6, s3.objectId, d3).push(s3);
    const [a8, r7, c8] = this._prepareQuery(i6, n6), h4 = await this._alignPointsInFeatures(a8, o6);
    s(o6);
    if (c8 !== this._cacheVersion) return this._alignComputedElevationCandidates(e5, n6, o6);
    this._applyCacheAndResponse(a8, h4, r7);
    const { drapedObjectIds: u5, failedObjectIds: l4 } = h4, p2 = [];
    for (const t5 of e5) {
      const { objectId: e6 } = t5;
      u5.has(e6) && "edge" === t5.type && (t5.draped = true), l4.has(e6) || p2.push(t5);
    }
    return p2;
  }
  _prepareQuery(e5, t5) {
    const s3 = [], n6 = [];
    for (const [o6, i6] of e5) {
      const e6 = [];
      for (const t6 of i6) this._addToQueriesOrCachedResult(o6, t6.target, e6, n6), "edge" === t6.type && (this._addToQueriesOrCachedResult(o6, t6.start, e6, n6), this._addToQueriesOrCachedResult(o6, t6.end, e6, n6));
      0 !== e6.length && s3.push({ objectId: o6, points: e6 });
    }
    return [{ spatialReference: t5.toJSON(), pointsInFeatures: s3 }, n6, this._cacheVersion];
  }
  _addToQueriesOrCachedResult(e5, t5, s3, n6) {
    const o6 = u3(e5, t5), i6 = this._alignmentsCache.get(o6);
    null == i6 ? s3.push(t5) : n6.push(new h3(t5, i6));
  }
  _applyCacheAndResponse(e5, { elevations: t5, drapedObjectIds: s3, failedObjectIds: n6 }, o6) {
    for (const r7 of o6) r7.apply();
    let i6 = 0;
    const a8 = this._alignmentsCache;
    for (const { objectId: r7, points: c8 } of e5.pointsInFeatures) {
      if (n6.has(r7)) {
        i6 += c8.length;
        continue;
      }
      const e6 = !s3.has(r7);
      for (const s4 of c8) {
        const n7 = u3(r7, s4), o7 = t5[i6++];
        s4.z = o7, e6 && a8.put(n7, o7, 1);
      }
    }
  }
};
var h3 = class {
  constructor(e5, t5) {
    this.point = e5, this.z = t5;
  }
  apply() {
    this.point.z = this.z;
  }
};
function u3(e5, { x: t5, y: s3, z: n6, spatialReference: o6 }) {
  return `${e5}-${t5}-${s3}-${n6 ?? 0}}-wkid:${o6 == null ? void 0 : o6.wkid}`;
}
function l3(e5, t5, s3) {
  const { offset: i6, unit: a8 } = s3;
  if (null == i6) return;
  const r7 = W(t5), c8 = i6 * (n2(a8 ?? "meters") / r7);
  for (const n6 of e5) switch (n6.type) {
    case "edge":
      n6.start.z += c8, n6.end.z += c8;
      continue;
    case "vertex":
      n6.target.z += c8;
      continue;
  }
}
function d3() {
  return [];
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/snappingCandidateElevationFilter.js
var t3 = class {
  filter(t5, n6) {
    return n6;
  }
  notifyElevationSourceChange() {
  }
};
var n3 = class {
  filter(t5, n6) {
    const { point: r7, distance: c8 } = t5, { z: i6 } = r7;
    if (!(null != i6)) return n6;
    if (0 === n6.length) return n6;
    const o6 = s2(c8), u5 = this._updateCandidatesTo3D(n6, r7, o6).filter(e4);
    return u5.sort(a6), u5;
  }
  _updateCandidatesTo3D(t5, n6, e5) {
    for (const r7 of t5) switch (r7.type) {
      case "edge":
        c6(r7, n6, e5);
        continue;
      case "vertex":
        o5(r7, n6, e5);
        continue;
    }
    return t5;
  }
};
function e4(t5) {
  return t5.distance <= 1;
}
function r4(e5 = false) {
  return e5 ? new n3() : new t3();
}
function c6(t5, n6, { x: e5, y: r7, z: c8 }) {
  const { start: o6, end: s3, target: a8 } = t5;
  t5.draped || i3(a8, n6, o6, s3);
  const u5 = (n6.x - a8.x) / e5, d4 = (n6.y - a8.y) / r7, f4 = (n6.z - a8.z) / c8;
  t5.distance = Math.sqrt(u5 * u5 + d4 * d4 + f4 * f4);
}
function i3(t5, n6, e5, r7) {
  const c8 = r7.x - e5.x, i6 = r7.y - e5.y, o6 = r7.z - e5.z, s3 = c8 * c8 + i6 * i6 + o6 * o6, a8 = (n6.x - e5.x) * c8 + (n6.y - e5.y) * i6 + o6 * (n6.z - e5.z), u5 = Math.min(1, Math.max(0, a8 / s3)), d4 = e5.x + c8 * u5, f4 = e5.y + i6 * u5, x4 = e5.z + o6 * u5;
  t5.x = d4, t5.y = f4, t5.z = x4;
}
function o5(t5, n6, { x: e5, y: r7, z: c8 }) {
  const { target: i6 } = t5, o6 = (n6.x - i6.x) / e5, s3 = (n6.y - i6.y) / r7, a8 = (n6.z - i6.z) / c8, u5 = Math.sqrt(o6 * o6 + s3 * s3 + a8 * a8);
  t5.distance = u5;
}
function s2(t5) {
  return "number" == typeof t5 ? { x: t5, y: t5, z: t5 } : t5;
}
function a6(t5, n6) {
  return t5.distance - n6.distance;
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/symbologySnappingCandidates.js
function n4(t5 = false, e5) {
  return t5 ? new i4(e5) : new c7();
}
var c7 = class {
  async fetch() {
    return [];
  }
  notifySymbologyChange() {
  }
};
var r5 = 1024;
var i4 = class {
  constructor(t5) {
    this._getSymbologyCandidates = t5, this._candidatesCache = new e3(r5), this._cacheVersion = 0;
  }
  async fetch(e5, o6) {
    if (0 === e5.length) return [];
    const n6 = [], c8 = [], r7 = this._candidatesCache;
    for (const s3 of e5) {
      const e6 = a7(s3), o7 = r7.get(e6);
      if (o7) for (const s4 of o7) c8.push(a(s4));
      else n6.push(s3), r7.put(e6, [], 1);
    }
    if (0 === n6.length) return c8;
    const i6 = this._cacheVersion, { candidates: h4, sourceCandidateIndices: d4 } = await this._getSymbologyCandidates(n6, o6);
    s(o6);
    if (i6 !== this._cacheVersion) return this.fetch(e5, o6);
    const f4 = [], { length: g3 } = h4;
    for (let s3 = 0; s3 < g3; ++s3) {
      const e6 = h4[s3], o7 = a7(n6[d4[s3]]), c9 = r7.get(o7);
      c9.push(e6), r7.put(o7, c9, c9.length), f4.push(a(e6));
    }
    return c8.concat(f4);
  }
  notifySymbologyChange() {
    this._candidatesCache.clear(), this._cacheVersion++;
  }
};
function a7(t5) {
  switch (t5.type) {
    case "vertex": {
      const { objectId: e5, target: s3 } = t5, n6 = `${e5}-vertex-${s3.x}-${s3.y}-${s3.z ?? 0}`;
      return l(n6).toString();
    }
    case "edge": {
      const { objectId: e5, start: s3, end: n6 } = t5, c8 = `${e5}-edge-${s3.x}-${s3.y}-${s3.z ?? 0}-to-${n6.x}-${n6.y}-${n6.z ?? 0}`;
      return l(c8).toString();
    }
    default:
      return "";
  }
}

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/PendingFeatureTile.js
var r6 = class {
  constructor(t5, e5) {
    this.data = t5, this.resolution = e5, this.state = { type: i5.CREATED }, this.alive = true;
  }
  process(t5) {
    switch (this.state.type) {
      case i5.CREATED:
        return this.state = this._gotoFetchCount(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case i5.FETCH_COUNT:
        break;
      case i5.FETCHED_COUNT:
        return this.state = this._gotoFetchFeatures(this.state, t5), this.state.task.promise.then(t5.resume, t5.resume);
      case i5.FETCH_FEATURES:
        break;
      case i5.FETCHED_FEATURES:
        this.state = this._goToDone(this.state, t5);
      case i5.DONE:
    }
    return null;
  }
  get debugInfo() {
    return { data: this.data, featureCount: this._featureCount, state: this._stateToString };
  }
  get _featureCount() {
    switch (this.state.type) {
      case i5.CREATED:
      case i5.FETCH_COUNT:
        return 0;
      case i5.FETCHED_COUNT:
        return this.state.featureCount;
      case i5.FETCH_FEATURES:
        return this.state.previous.featureCount;
      case i5.FETCHED_FEATURES:
        return this.state.features.length;
      case i5.DONE:
        return this.state.previous.features.length;
    }
  }
  get _stateToString() {
    switch (this.state.type) {
      case i5.CREATED:
        return "created";
      case i5.FETCH_COUNT:
        return "fetch-count";
      case i5.FETCHED_COUNT:
        return "fetched-count";
      case i5.FETCH_FEATURES:
        return "fetch-features";
      case i5.FETCHED_FEATURES:
        return "fetched-features";
      case i5.DONE:
        return "done";
    }
  }
  _gotoFetchCount(s3, a8) {
    return { type: i5.FETCH_COUNT, previous: s3, task: d(async (t5) => {
      const s4 = await b2(a8.fetchCount(this, t5));
      this.state.type === i5.FETCH_COUNT && (this.state = u4(this.state, s4.ok ? s4.value : 1 / 0));
    }) };
  }
  _gotoFetchFeatures(s3, a8) {
    return { type: i5.FETCH_FEATURES, previous: s3, task: d(async (t5) => {
      const E4 = await b2(a8.fetchFeatures(this, s3.featureCount, t5));
      this.state.type === i5.FETCH_FEATURES && (this.state = T(this.state, E4.ok ? E4.value : []));
    }) };
  }
  _goToDone(t5, e5) {
    return e5.finish(this, t5.features), { type: i5.DONE, previous: t5 };
  }
  reset() {
    const t5 = this.state;
    switch (this.state = { type: i5.CREATED }, t5.type) {
      case i5.CREATED:
      case i5.FETCHED_COUNT:
      case i5.FETCHED_FEATURES:
      case i5.DONE:
        break;
      case i5.FETCH_COUNT:
      case i5.FETCH_FEATURES:
        t5.task.abort();
    }
  }
  intersects(t5) {
    return null == t5 || !this.data.extent || (o3(t5, n5), E(this.data.extent, n5));
  }
};
function u4(t5, e5) {
  return { type: i5.FETCHED_COUNT, featureCount: e5, previous: t5 };
}
function T(t5, e5) {
  return { type: i5.FETCHED_FEATURES, previous: t5, features: e5 };
}
var i5;
!function(t5) {
  t5[t5.CREATED = 0] = "CREATED", t5[t5.FETCH_COUNT = 1] = "FETCH_COUNT", t5[t5.FETCHED_COUNT = 2] = "FETCHED_COUNT", t5[t5.FETCH_FEATURES = 3] = "FETCH_FEATURES", t5[t5.FETCHED_FEATURES = 4] = "FETCHED_FEATURES", t5[t5.DONE = 5] = "DONE";
}(i5 || (i5 = {}));
var n5 = u2();

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTiledFetcher.js
var C2 = class extends b {
  get _minimumVerticesPerFeature() {
    var _a;
    switch ((_a = this.store) == null ? void 0 : _a.featureStore.geometryType) {
      case "esriGeometryPoint":
      case "esriGeometryMultipoint":
        return 1;
      case "esriGeometryPolygon":
        return 4;
      case "esriGeometryPolyline":
        return 2;
    }
  }
  get _mandatoryOutFields() {
    const e5 = /* @__PURE__ */ new Set();
    return this.objectIdField && e5.add(this.objectIdField), this.globalIdField && e5.add(this.globalIdField), e5;
  }
  set outFields(e5) {
    const t5 = this._get("outFields"), i6 = u(e5, this._mandatoryOutFields);
    f(i6, t5) || (this._set("outFields", i6), e(i6, t5) || this.refresh());
  }
  get outFields() {
    return this._get("outFields") ?? this._mandatoryOutFields;
  }
  set filter(e5) {
    const t5 = this._get("filter"), i6 = this._filterProperties(e5);
    JSON.stringify(t5) !== JSON.stringify(i6) && this._set("filter", i6);
  }
  set customParameters(e5) {
    const t5 = this._get("customParameters");
    JSON.stringify(t5) !== JSON.stringify(e5) && this._set("customParameters", e5);
  }
  get _configuration() {
    return { filter: this.filter, customParameters: this.customParameters, tileInfo: this.tileInfo, tileSize: this.tileSize };
  }
  set tileInfo(e5) {
    const t5 = this._get("tileInfo");
    t5 !== e5 && (null != e5 && null != t5 && JSON.stringify(e5) === JSON.stringify(t5) || (this._set("tileInfo", e5), this.store.tileInfo = e5));
  }
  set tileSize(e5) {
    this._get("tileSize") !== e5 && this._set("tileSize", e5);
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get hasZ() {
    return this.store.featureStore.hasZ;
  }
  constructor(e5) {
    super(e5), this.suspended = true, this._historicMoment = null, this.tilesOfInterest = [], this.availability = 0, this._pendingTiles = /* @__PURE__ */ new Map(), this._updatingHandles = new h();
  }
  initialize() {
    this._initializeFetchExtent(), this._updatingHandles.add(() => this._configuration, () => this.refresh()), this._updatingHandles.add(() => this.tilesOfInterest, (e5, t5) => {
      c(e5, t5, ({ id: e6 }, { id: t6 }) => e6 === t6) || this._process();
    }, C), this.addHandles(p(() => !this.suspended, () => this._process()));
  }
  destroy() {
    this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._pendingTiles.clear(), this.store.destroy(), this.tilesOfInterest.length = 0, this._updatingHandles.destroy();
  }
  refresh() {
    this.store.refresh(), this._pendingTiles.forEach((e5) => this._deletePendingTile(e5)), this._process();
  }
  async handleEdits(e5) {
    if (e5.historicMoment && (this._historicMoment = e5.historicMoment), !e5.addedFeatures.length && !e5.updatedFeatures.length && !e5.deletedFeatures.length) return;
    for (const s3 of this._pendingTiles.values()) s3.reset();
    const t5 = { ...e5, deletedFeatures: e5.deletedFeatures.map(({ objectId: e6, globalId: t6 }) => e6 && -1 !== e6 ? e6 : this._lookupObjectIdByGlobalId(t6)) }, i6 = d(async (e6) => {
      try {
        await this.store.processEdits(t5, (e7, t6) => this._queryFeaturesById(e7, t6), e6), this._processPendingTiles();
      } catch (i7) {
        a2(i7), n.getLogger(this).warn("Failed to apply edits", i7);
      }
    });
    this.addHandles(i6), await this._updatingHandles.addPromise(i6.promise);
  }
  setHistoricMoment(e5) {
    var _a;
    (e5 == null ? void 0 : e5.getTime()) !== ((_a = this._historicMoment) == null ? void 0 : _a.getTime()) && (this._historicMoment = e5, this.refresh());
  }
  _initializeFetchExtent() {
    if (!this.capabilities.query.supportsExtent || !g2(this.url)) return;
    const e5 = d(async (e6) => {
      var _a;
      try {
        const t5 = await x(this.url, new b3({ where: "1=1", outSpatialReference: this.spatialReference, cacheHint: this.capabilities.query.supportsCacheHint ?? void 0 }), { query: this._configuration.customParameters, signal: e6 });
        this.store.extent = w2.fromJSON((_a = t5.data) == null ? void 0 : _a.extent);
      } catch (t5) {
        a2(t5), n.getLogger(this).warn("Failed to fetch data extent", t5);
      }
    });
    this._updatingHandles.addPromise(e5.promise.then(() => this._process())), this.addHandles(e5);
  }
  get debugInfo() {
    return { numberOfFeatures: this.store.featureStore.numFeatures, tilesOfInterest: this.tilesOfInterest, pendingTiles: Array.from(this._pendingTiles.values()).map((e5) => e5.debugInfo), storedTiles: this.store.debugInfo };
  }
  _process() {
    this._markTilesNotAlive(), this._createPendingTiles(), this._deletePendingTiles(), this._processPendingTiles();
  }
  _markTilesNotAlive() {
    for (const e5 of this._pendingTiles.values()) e5.alive = false;
  }
  _createPendingTiles() {
    if (this.suspended) return;
    const e5 = this._collectMissingTilesInfo();
    if (this._setAvailability(null == e5 ? 1 : e5.coveredArea / e5.fullArea), null != e5) for (const { data: t5, resolution: i6 } of e5.missingTiles) {
      const e6 = this._pendingTiles.get(t5.id);
      e6 ? (e6.resolution = i6, e6.alive = true) : this._createPendingTile(t5, i6);
    }
  }
  _collectMissingTilesInfo() {
    let e5 = null;
    for (let t5 = this.tilesOfInterest.length - 1; t5 >= 0; t5--) {
      const i6 = this.tilesOfInterest[t5], s3 = this.store.process(i6, (e6, t6) => this._verifyTileComplexity(e6, t6), this.outFields);
      null == e5 ? e5 = s3 : e5.prepend(s3);
    }
    return e5;
  }
  _deletePendingTiles() {
    for (const e5 of this._pendingTiles.values()) e5.alive || this._deletePendingTile(e5);
  }
  _processPendingTiles() {
    const e5 = { fetchCount: (e6, t5) => this._fetchCount(e6, t5), fetchFeatures: (e6, t5, i6) => this._fetchFeatures(e6, t5, i6), finish: (e6, t5) => this._finishPendingTile(e6, t5), resume: () => this._processPendingTiles() };
    if (this._ensureFetchAllCounts(e5)) for (const t5 of this._pendingTiles.values()) this._verifyTileComplexity(this.store.getFeatureCount(t5.data), t5.resolution) && this._updatingHandles.addPromise(t5.process(e5));
  }
  _verifyTileComplexity(e5, t5) {
    return this._verifyVertexComplexity(e5) && this._verifyFeatureDensity(e5, t5);
  }
  _verifyVertexComplexity(e5) {
    return e5 * this._minimumVerticesPerFeature < q;
  }
  _verifyFeatureDensity(e5, t5) {
    if (null == this.tileInfo) return false;
    const i6 = this.tileSize * t5;
    return e5 * (M / (i6 * i6)) < H;
  }
  _ensureFetchAllCounts(e5) {
    let t5 = true;
    for (const i6 of this._pendingTiles.values()) i6.state.type < i5.FETCHED_COUNT && this._updatingHandles.addPromise(i6.process(e5)), i6.state.type <= i5.FETCH_COUNT && (t5 = false);
    return t5;
  }
  _finishPendingTile(e5, t5) {
    this.store.add(e5.data, t5), this._deletePendingTile(e5), this._updateAvailability();
  }
  _updateAvailability() {
    const e5 = this._collectMissingTilesInfo();
    this._setAvailability(null == e5 ? 1 : e5.coveredArea / e5.fullArea);
  }
  _setAvailability(e5) {
    this._set("availability", e5);
  }
  _createPendingTile(e5, t5) {
    const i6 = new r6(e5, t5);
    return this._pendingTiles.set(e5.id, i6), i6;
  }
  _deletePendingTile(e5) {
    e5.reset(), this._pendingTiles.delete(e5.data.id);
  }
  async _fetchCount(e5, t5) {
    return this.store.fetchCount(e5.data, this.url, this._createCountQuery(e5), { query: this.customParameters, timeout: w3, signal: t5 });
  }
  async _fetchFeatures(e5, t5, i6) {
    let s3 = 0;
    const r7 = [];
    let o6 = 0, n6 = t5;
    for (; ; ) {
      const a8 = this._createFeaturesQuery(e5), l4 = this._setPagingParameters(a8, s3, n6), { features: u5, exceededTransferLimit: d4 } = await this._queryFeatures(a8, i6);
      l4 && (s3 += a8.num), o6 += u5.length;
      for (const e6 of u5) r7.push(e6);
      if (n6 = t5 - o6, !l4 || !d4 || n6 <= 0) return r7;
    }
  }
  _filterProperties(e5) {
    return null == e5 ? { where: "1=1", gdbVersion: void 0, timeExtent: void 0 } : { where: e5.where || "1=1", timeExtent: e5.timeExtent, gdbVersion: e5.gdbVersion };
  }
  _lookupObjectIdByGlobalId(e5) {
    const t5 = this.globalIdField, i6 = this.objectIdField;
    if (null == t5) throw new Error("Expected globalIdField to be defined");
    let s3 = null;
    const r7 = e5 ? e2(e5) : e5;
    if (this.store.featureStore.forEach((e6) => {
      r7 === e2(e6.attributes[t5]) && (s3 = e6.objectId ?? e6.attributes[i6]);
    }), null == s3) throw new Error(`Expected to find a feature with globalId ${e5}`);
    return s3;
  }
  _queryFeaturesById(e5, t5) {
    const i6 = this._createFeaturesQuery();
    return i6.objectIds = e5, this._queryFeatures(i6, t5);
  }
  _queryFeatures(e5, t5) {
    return this.capabilities.query.supportsFormatPBF ? this._queryFeaturesPBF(e5, t5) : this._queryFeaturesJSON(e5, t5);
  }
  async _queryFeaturesPBF(e5, t5) {
    const { sourceSpatialReference: i6 } = this, { data: s3 } = await f3(this.url, e5, new a4({ sourceSpatialReference: i6 }), { query: this._configuration.customParameters, timeout: w3, signal: t5 });
    return it(s3);
  }
  async _queryFeaturesJSON(e5, t5) {
    const { sourceSpatialReference: i6 } = this, { data: s3 } = await c4(this.url, e5, i6, { query: this._configuration.customParameters, timeout: w3, signal: t5 });
    return ct(s3, this.objectIdField);
  }
  _createCountQuery(e5) {
    const t5 = this._createBaseQuery(e5);
    return this.capabilities.query.supportsCacheHint && (t5.cacheHint = true), t5;
  }
  _createFeaturesQuery(e5 = null) {
    var _a;
    const t5 = this._createBaseQuery(e5), i6 = null != (e5 == null ? void 0 : e5.data) ? this.store.getAttributesForTile((_a = e5 == null ? void 0 : e5.data) == null ? void 0 : _a.id) : null, s3 = u(i(this.outFields, i6 ?? /* @__PURE__ */ new Set()), this._mandatoryOutFields);
    return t5.outFields = Array.from(s3), t5.returnGeometry = true, null != e5 && (this.capabilities.query.supportsResultType ? t5.resultType = "tile" : this.capabilities.query.supportsCacheHint && (t5.cacheHint = true)), t5;
  }
  _createBaseQuery(e5) {
    const t5 = new b3({ returnZ: this.hasZ, returnM: false, historicMoment: this._historicMoment, geometry: null != this.tileInfo && null != e5 ? c3(e5.data.extent, this.tileInfo.spatialReference) : void 0 }), i6 = this._configuration.filter;
    return null != i6 && (t5.where = i6.where, t5.gdbVersion = i6.gdbVersion, t5.timeExtent = i6.timeExtent), t5.outSpatialReference = this.spatialReference, t5;
  }
  _setPagingParameters(e5, t5, i6) {
    if (!this.capabilities.query.supportsPagination) return false;
    const { supportsMaxRecordCountFactor: s3, supportsCacheHint: r7, tileMaxRecordCount: o6, maxRecordCount: n6, supportsResultType: a8 } = this.capabilities.query, l4 = s3 ? b3.MAX_MAX_RECORD_COUNT_FACTOR : 1, u5 = l4 * ((a8 || r7) && o6 ? o6 : n6 || x2);
    return e5.start = t5, s3 ? (e5.maxRecordCountFactor = Math.min(l4, Math.ceil(i6 / u5)), e5.num = Math.min(i6, e5.maxRecordCountFactor * u5)) : e5.num = Math.min(i6, u5), true;
  }
};
r([m({ constructOnly: true })], C2.prototype, "url", void 0), r([m({ constructOnly: true })], C2.prototype, "objectIdField", void 0), r([m({ constructOnly: true })], C2.prototype, "globalIdField", void 0), r([m({ constructOnly: true })], C2.prototype, "capabilities", void 0), r([m({ constructOnly: true })], C2.prototype, "sourceSpatialReference", void 0), r([m({ constructOnly: true })], C2.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], C2.prototype, "store", void 0), r([m({ readOnly: true })], C2.prototype, "_minimumVerticesPerFeature", null), r([m()], C2.prototype, "_mandatoryOutFields", null), r([m()], C2.prototype, "outFields", null), r([m()], C2.prototype, "suspended", void 0), r([m()], C2.prototype, "_historicMoment", void 0), r([m()], C2.prototype, "filter", null), r([m()], C2.prototype, "customParameters", null), r([m({ readOnly: true })], C2.prototype, "_configuration", null), r([m()], C2.prototype, "tileInfo", null), r([m()], C2.prototype, "tileSize", null), r([m()], C2.prototype, "tilesOfInterest", void 0), r([m({ readOnly: true })], C2.prototype, "updating", null), r([m({ readOnly: true })], C2.prototype, "availability", void 0), r([m()], C2.prototype, "hasZ", null), C2 = r([a3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTiledFetcher")], C2);
var x2 = 2e3;
var w3 = 6e5;
var q = 1e6;
var M = 25;
var H = 1;

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileCache.js
var t4 = class {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._byteSize = 0;
  }
  set(t5, e5) {
    this.delete(t5), this._store.set(t5, e5), this._byteSize += e5.byteSize;
  }
  delete(t5) {
    const e5 = this._store.get(t5);
    return !!this._store.delete(t5) && (null != e5 && (this._byteSize -= e5.byteSize), true);
  }
  get(t5) {
    return this._used(t5), this._store.get(t5);
  }
  has(t5) {
    return this._used(t5), this._store.has(t5);
  }
  clear() {
    this._store.clear();
  }
  applyByteSizeLimit(t5, e5) {
    for (const [s3, r7] of this._store) {
      if (this._byteSize <= t5) break;
      this.delete(s3), e5(r7);
    }
  }
  values() {
    return this._store.values();
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
  _used(t5) {
    const e5 = this._store.get(t5);
    e5 && (this._store.delete(t5), this._store.set(t5, e5));
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceTileStore.js
var y = class extends b {
  constructor(e5) {
    super(e5), this.tileInfo = null, this.extent = null, this.maximumByteSize = 10 * E2.MEGABYTES, this._tileBounds = new o4(), this._tiles = new t4(), this._refCounts = /* @__PURE__ */ new Map(), this._tileFeatureCounts = /* @__PURE__ */ new Map(), this._tmpBoundingRect = u2();
  }
  add(e5, t5) {
    var _a;
    for (const r7 of t5) this._referenceFeature(r7.objectId);
    const s3 = this.featureStore.upsertMany(t5), i6 = s3.map((e6) => new Set(Object.keys(e6.attributes))).reduce((e6, t6) => o(e6, t6), new Set(Object.keys(((_a = s3[0]) == null ? void 0 : _a.attributes) ?? [])));
    this._addTileStorage(e5, new Set(s3.map((e6) => e6.objectId)), S2(s3), i6), this._tiles.applyByteSizeLimit(this.maximumByteSize, (e6) => this._removeTileStorage(e6));
  }
  getAttributesForTile(e5) {
    var _a;
    return e5 ? (_a = this._tiles.get(e5)) == null ? void 0 : _a.attributeKeys : null;
  }
  destroy() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  clear() {
    this.featureStore.clear(), this._tileBounds.clear(), this._tiles.clear(), this._refCounts.clear();
  }
  refresh() {
    this.clear(), this._tileFeatureCounts.clear();
  }
  processEdits(e5, t5, s3) {
    return this._processEditsDelete(e5.deletedFeatures.concat(e5.updatedFeatures)), this._processEditsRefetch(e5.addedFeatures.concat(e5.updatedFeatures), t5, s3);
  }
  _addTileStorage(e5, t5, s3, i6) {
    const r7 = e5.id;
    this._tiles.set(r7, new w4(e5, t5, s3, i6)), this._tileBounds.set(r7, e5.extent), this._tileFeatureCounts.set(r7, t5.size);
  }
  _remove({ id: e5 }) {
    const t5 = this._tiles.get(e5);
    t5 && this._removeTileStorage(t5);
  }
  _removeTileStorage(e5) {
    const t5 = [];
    for (const i6 of e5.objectIds) this._unreferenceFeature(i6) === x3.REMOVED && t5.push(i6);
    this.featureStore.removeManyById(t5);
    const s3 = e5.data.id;
    this._tiles.delete(s3), this._tileBounds.delete(s3);
  }
  _processEditsDelete(e5) {
    this.featureStore.removeManyById(e5);
    for (const t5 of this._tiles.values()) {
      for (const s3 of e5) t5.objectIds.delete(s3);
      this._tileFeatureCounts.set(t5.data.id, t5.objectIds.size);
    }
    for (const t5 of e5) this._refCounts.delete(t5);
  }
  async _processEditsRefetch(e5, t5, s3) {
    if (!e5.length) return;
    const i6 = (await t5(e5, s3)).features, { hasZ: r7, hasM: o6 } = this.featureStore;
    for (const n6 of i6) {
      const e6 = gt(this._tmpBoundingRect, n6.geometry, r7, o6);
      null != e6 && this._tileBounds.forEachInBounds(e6, (e7) => {
        const t6 = this._tiles.get(e7);
        this.featureStore.add(n6);
        const s4 = n6.objectId;
        t6.objectIds.has(s4) || (t6.objectIds.add(s4), this._referenceFeature(s4), this._tileFeatureCounts.set(t6.data.id, t6.objectIds.size));
      });
    }
  }
  process(e5, t5 = () => true, s3) {
    if (null == this.tileInfo || !e5.extent || null != this.extent && !E(o3(this.extent, this._tmpBoundingRect), e5.extent)) return new j(e5);
    const i6 = this.getAttributesForTile(e5.id);
    if (e(s3, i6)) return new j(e5);
    const r7 = this._createTileTree(e5, this.tileInfo);
    return this._simplify(r7, t5, null, 0, 1), this._collectMissingTiles(e5, r7, this.tileInfo, s3);
  }
  get debugInfo() {
    return Array.from(this._tiles.values()).map(({ data: e5 }) => ({ data: e5, featureCount: this._tileFeatureCounts.get(e5.id) || 0 }));
  }
  getFeatureCount(e5) {
    return this._tileFeatureCounts.get(e5.id) ?? 0;
  }
  async fetchCount(e5, t5, s3, i6) {
    const r7 = this._tileFeatureCounts.get(e5.id);
    if (null != r7) return r7;
    const o6 = await S(t5, s3, i6);
    return this._tileFeatureCounts.set(e5.id, o6.data.count), o6.data.count;
  }
  _createTileTree(e5, t5) {
    const s3 = new F(e5.level, e5.row, e5.col);
    return t5.updateTileInfo(s3, z.ExtrapolateOptions.POWER_OF_TWO), this._tileBounds.forEachInBounds(e5.extent, (i6) => {
      var _a;
      const r7 = (_a = this._tiles.get(i6)) == null ? void 0 : _a.data;
      r7 && C3(e5, r7) && this._populateChildren(s3, r7, t5, this._tileFeatureCounts.get(r7.id) || 0);
    }), s3;
  }
  _populateChildren(e5, t5, s3, i6) {
    const r7 = t5.level - e5.level - 1;
    if (r7 < 0) return void (e5.isLeaf = true);
    const o6 = t5.row >> r7, n6 = t5.col >> r7, l4 = e5.row << 1, u5 = n6 - (e5.col << 1) + (o6 - l4 << 1), c8 = e5.children[u5];
    if (null != c8) this._populateChildren(c8, t5, s3, i6);
    else {
      const r8 = new F(e5.level + 1, o6, n6);
      s3.updateTileInfo(r8, z.ExtrapolateOptions.POWER_OF_TWO), e5.children[u5] = r8, this._populateChildren(r8, t5, s3, i6);
    }
  }
  _simplify(e5, t5, s3, i6, r7) {
    const o6 = r7 * r7;
    if (e5.isLeaf) return t5(this.getFeatureCount(e5), r7) ? 0 : (this._remove(e5), null != s3 && (s3.children[i6] = null), o6);
    const n6 = r7 / 2, l4 = n6 * n6;
    let u5 = 0;
    for (let c8 = 0; c8 < e5.children.length; c8++) {
      const s4 = e5.children[c8];
      u5 += null != s4 ? this._simplify(s4, t5, e5, c8, n6) : l4;
    }
    return 0 === u5 ? this._mergeChildren(e5) : 1 - u5 / o6 < I && (this._purge(e5), null != s3 && (s3.children[i6] = null), u5 = o6), u5;
  }
  _mergeChildren(e5) {
    const t5 = /* @__PURE__ */ new Set();
    let s3, i6 = 0;
    this._forEachLeaf(e5, (e6) => {
      const r7 = this._tiles.get(e6.id);
      if (r7) {
        s3 = s3 ? o(s3, r7.attributeKeys) : new Set(r7.attributeKeys), i6 += r7.byteSize;
        for (const e7 of r7.objectIds) t5.has(e7) || (t5.add(e7), this._referenceFeature(e7));
        this._remove(e6);
      }
    }), this._addTileStorage(e5, t5, i6, s3 ?? /* @__PURE__ */ new Set()), e5.isLeaf = true, e5.children[0] = e5.children[1] = e5.children[2] = e5.children[3] = null, this._tileFeatureCounts.set(e5.id, t5.size);
  }
  _forEachLeaf(e5, t5) {
    for (const s3 of e5.children) null != s3 && (s3.isLeaf ? t5(s3) : this._forEachLeaf(s3, t5));
  }
  _purge(e5) {
    if (null != e5) if (e5.isLeaf) this._remove(e5);
    else for (let t5 = 0; t5 < e5.children.length; t5++) {
      const s3 = e5.children[t5];
      this._purge(s3), e5.children[t5] = null;
    }
  }
  _collectMissingTiles(e5, t5, s3, i6) {
    const r7 = new b4(s3, e5, this.extent);
    return this._collectMissingTilesRecurse(t5, r7, 1, i6), r7.info;
  }
  _collectMissingTilesRecurse(e5, t5, s3, i6) {
    const r7 = this.getAttributesForTile(e5.id), o6 = r7 && !e(i6, r7);
    if (o6 && t5.addMissing(e5.level, e5.row, e5.col, s3), e5.isLeaf) return;
    if (!e5.hasChildren) return void (o6 || t5.addMissing(e5.level, e5.row, e5.col, s3));
    const l4 = s3 / 2;
    for (let n6 = 0; n6 < e5.children.length; n6++) {
      const s4 = e5.children[n6];
      null == s4 ? t5.addMissing(e5.level + 1, (e5.row << 1) + ((2 & n6) >> 1), (e5.col << 1) + (1 & n6), l4) : this._collectMissingTilesRecurse(s4, t5, l4, i6);
    }
  }
  _referenceFeature(e5) {
    const t5 = (this._refCounts.get(e5) || 0) + 1;
    return this._refCounts.set(e5, t5), 1 === t5 ? x3.ADDED : x3.UNCHANGED;
  }
  _unreferenceFeature(e5) {
    const t5 = (this._refCounts.get(e5) || 0) - 1;
    return 0 === t5 ? (this._refCounts.delete(e5), x3.REMOVED) : (t5 > 0 && this._refCounts.set(e5, t5), x3.UNCHANGED);
  }
  get test() {
  }
};
function C3(e5, t5) {
  if (!e5 || !t5) return false;
  if (e5.level === t5.level) return e5.row === t5.row && e5.col === t5.col;
  const s3 = e5.level < t5.level, i6 = s3 ? e5 : t5, r7 = s3 ? t5 : e5, o6 = 1 << r7.level - i6.level;
  return Math.floor(r7.row / o6) === i6.row && Math.floor(r7.col / o6) === i6.col;
}
function S2(e5) {
  return e5.reduce((e6, t5) => e6 + E3(t5), 0);
}
function E3(e5) {
  return 32 + T2(e5.geometry) + t(e5.attributes);
}
function T2(e5) {
  if (null == e5) return 0;
  const t5 = c2(e5.lengths, 4);
  return 32 + c2(e5.coords, 8) + t5;
}
r([m({ constructOnly: true })], y.prototype, "featureStore", void 0), r([m()], y.prototype, "tileInfo", void 0), r([m()], y.prototype, "extent", void 0), r([m()], y.prototype, "maximumByteSize", void 0), y = r([a3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceTileStore")], y);
var w4 = class {
  constructor(e5, t5, s3, i6) {
    this.data = e5, this.objectIds = t5, this.byteSize = s3, this.attributeKeys = i6;
  }
};
var F = class {
  constructor(e5, t5, s3) {
    this.level = e5, this.row = t5, this.col = s3, this.isLeaf = false, this.extent = null, this.children = [null, null, null, null];
  }
  get hasChildren() {
    return !this.isLeaf && (null != this.children[0] || null != this.children[1] || null != this.children[2] || null != this.children[3]);
  }
};
var j = class {
  constructor(e5, t5 = []) {
    this.missingTiles = t5, this.fullArea = 0, this.coveredArea = 0, this.fullArea = l2(e5.extent), this.coveredArea = this.fullArea;
  }
  prepend(e5) {
    this.missingTiles = e5.missingTiles.concat(this.missingTiles), this.coveredArea += e5.coveredArea, this.fullArea += e5.fullArea;
  }
};
var b4 = class {
  constructor(e5, t5, s3) {
    this._tileInfo = e5, this._extent = null, this.info = new j(t5), null != s3 && (this._extent = o3(s3));
  }
  addMissing(e5, t5, s3, i6) {
    const r7 = new t2(null, e5, t5, s3);
    this._tileInfo.updateTileInfo(r7, z.ExtrapolateOptions.POWER_OF_TWO), null == r7.extent || null != this._extent && !E(this._extent, r7.extent) || (this.info.missingTiles.push({ data: r7, resolution: i6 }), this.info.coveredArea -= l2(r7.extent));
  }
};
var I = 0.18751;
var x3;
!function(e5) {
  e5[e5.ADDED = 0] = "ADDED", e5[e5.REMOVED = 1] = "REMOVED", e5[e5.UNCHANGED = 2] = "UNCHANGED";
}(x3 || (x3 = {}));

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/featureServiceSource/FeatureServiceSnappingSourceWorker.js
var w5 = class extends o2.EventedAccessor {
  constructor() {
    super(...arguments), this._isInitializing = true, this.remoteClient = null, this._whenSetup = L(), this._elevationAligner = i2(), this._elevationFilter = r4(), this._symbologyCandidatesFetcher = n4(), this._updatingHandles = new h(), this._alignPointsInFeatures = async (e5, t5) => {
      const i6 = { query: e5 }, s3 = await this.remoteClient.invoke("alignElevation", i6, { signal: t5 });
      return s(t5), s3;
    }, this._getSymbologyCandidates = async (e5, t5) => {
      const i6 = { candidates: e5, spatialReference: this._spatialReference.toJSON() }, s3 = await this.remoteClient.invoke("getSymbologyCandidates", i6, { signal: t5 });
      return s(t5), s3;
    };
  }
  get updating() {
    return this._isInitializing || this._updatingHandles.updating || this._featureFetcher.updating;
  }
  destroy() {
    var _a, _b, _c;
    (_a = this._featureFetcher) == null ? void 0 : _a.destroy(), (_b = this._queryEngine) == null ? void 0 : _b.destroy(), (_c = this._featureStore) == null ? void 0 : _c.clear();
  }
  async setup(e5) {
    if (this.destroyed) return { result: {} };
    const { geometryType: t5, objectIdField: i6, timeInfo: r7, fieldsIndex: a8 } = e5.serviceInfo, { hasZ: o6 } = e5, l4 = g.fromJSON(e5.spatialReference);
    this._spatialReference = l4, this._featureStore = new m2({ ...e5.serviceInfo, hasZ: o6, hasM: false }), this._queryEngine = new V({ spatialReference: e5.spatialReference, featureStore: this._featureStore, geometryType: t5, fieldsIndex: a8, hasZ: o6, hasM: false, objectIdField: i6, timeInfo: r7 }), this._featureFetcher = new C2({ store: new y({ featureStore: this._featureStore }), url: e5.serviceInfo.url, objectIdField: e5.serviceInfo.objectIdField, globalIdField: e5.serviceInfo.globalIdField, capabilities: e5.serviceInfo.capabilities, spatialReference: l4, sourceSpatialReference: g.fromJSON(e5.serviceInfo.spatialReference), customParameters: e5.configuration.customParameters });
    const u5 = "3d" === e5.configuration.viewType;
    return this._elevationAligner = i2(u5, { elevationInfo: null != e5.elevationInfo ? h2.fromJSON(e5.elevationInfo) : null, alignPointsInFeatures: this._alignPointsInFeatures }), this._elevationFilter = r4(u5), this.addHandles([d2(() => this._featureFetcher.availability, (e6) => this.emit("notify-availability", { availability: e6 }), C), d2(() => this.updating, () => this._notifyUpdating())]), this._whenSetup.resolve(), this._isInitializing = false, this.configure(e5.configuration);
  }
  async configure(e5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), this._updateFeatureFetcherConfiguration(e5), b5;
  }
  async setSuspended(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.suspended = e5, b5;
  }
  async updateOutFields(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.outFields = new Set(e5 ?? []), b5;
  }
  async fetchCandidates(e5, t5) {
    await this._whenSetup.promise, s(t5);
    const i6 = j2(e5), s3 = t5 == null ? void 0 : t5.signal, a8 = await this._queryEngine.executeQueryForSnapping(i6, s3);
    s(s3);
    const n6 = await this._elevationAligner.alignCandidates(a8.candidates, g.fromJSON(e5.point.spatialReference) ?? g.WGS84, s3);
    s(s3);
    const o6 = await this._symbologyCandidatesFetcher.fetch(n6, s3);
    s(s3);
    const l4 = 0 === o6.length ? n6 : n6.concat(o6);
    return { result: { candidates: this._elevationFilter.filter(i6, l4) } };
  }
  async updateTiles(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.tileSize = e5.tileSize, this._featureFetcher.tilesOfInterest = e5.tiles, this._featureFetcher.tileInfo = null != e5.tileInfo ? z.fromJSON(e5.tileInfo) : null, b5;
  }
  async refresh(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), this._featureFetcher.refresh(), b5;
  }
  async whenNotUpdating(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), await w(() => !this.updating, t5), s(t5), b5;
  }
  async getDebugInfo(e5, t5) {
    return s(t5), { result: this._featureFetcher.debugInfo };
  }
  async handleEdits(e5, t5) {
    return await this._updatingHandles.addPromise(this._whenSetup.promise), s(t5), await this._updatingHandles.addPromise(this._featureFetcher.handleEdits(e5)), s(t5), b5;
  }
  async setHistoricMoment(e5, t5) {
    return this._featureFetcher.setHistoricMoment(e5.moment), b5;
  }
  async notifyElevationSourceChange(e5, t5) {
    return this._elevationAligner.notifyElevationSourceChange(), b5;
  }
  async notifySymbologyChange(e5, t5) {
    return this._symbologyCandidatesFetcher.notifySymbologyChange(), b5;
  }
  async setSymbologySnappingSupported(e5) {
    return this._symbologyCandidatesFetcher = n4(e5, this._getSymbologyCandidates), b5;
  }
  _updateFeatureFetcherConfiguration(e5) {
    this._featureFetcher.filter = null != e5.filter ? b3.fromJSON(e5.filter) : null, this._featureFetcher.customParameters = e5.customParameters;
  }
  _notifyUpdating() {
    this.emit("notify-updating", { updating: this.updating });
  }
};
r([m({ readOnly: true })], w5.prototype, "updating", null), r([m()], w5.prototype, "_isInitializing", void 0), w5 = r([a3("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorker")], w5);
var I2 = w5;
function j2(e5) {
  if (!e5.filter) return { ...e5, query: { where: "1=1" } };
  const { distance: t5, units: i6, spatialRel: r7, where: s3, timeExtent: a8, objectIds: n6 } = e5.filter, o6 = { geometry: e5.filter.geometry ? f2(e5.filter.geometry) : void 0, distance: t5, units: i6, spatialRel: r7, timeExtent: a8, objectIds: n6, where: s3 ?? "1=1" };
  return { ...e5, query: o6 };
}
var b5 = { result: {} };
export {
  I2 as default
};
//# sourceMappingURL=FeatureServiceSnappingSourceWorker-WM2AJY53.js.map
