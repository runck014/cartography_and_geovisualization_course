import {
  s
} from "./chunk-WTNHDCCU.js";
import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  n2 as n
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/geometry/support/meshProperties.js
function e(e2, n3, r3, t2) {
  const { loggerTag: o, stride: f2 } = n3;
  return e2.length % f2 != 0 ? (t2.error(o, `Invalid array length, expected a multiple of ${f2}`), new r3([])) : e2;
}
function n2(n3, r3, t2, o, f2) {
  if (!n3) return n3;
  if (n3 instanceof r3) return e(n3, o, r3, f2);
  for (const i of t2) if (n3 instanceof i) return e(new r3(n3), o, r3, f2);
  if (Array.isArray(n3)) return e(new r3(n3), o, r3, f2);
  {
    const e2 = t2.map((e3) => `'${e3.name}'`);
    return f2.error(`Failed to set property, expected one of ${e2}, but got ${n3.constructor.name}`), new r3([]);
  }
}
function r2(e2, n3, r3) {
  n3[r3] = t(e2);
}
function t(e2) {
  const n3 = new Array(e2.length);
  for (let r3 = 0; r3 < e2.length; r3++) n3[r3] = e2[r3];
  return n3;
}

// node_modules/@arcgis/core/geometry/support/MeshVertexAttributes.js
var g;
var p = g = class extends f {
  constructor(t2) {
    super(t2), this.color = null, this.position = new Float64Array(0), this.uv = null, this.normal = null, this.tangent = null;
  }
  castColor(t2) {
    return n2(t2, Uint8Array, [Uint8ClampedArray], { loggerTag: ".color=", stride: 4 }, n.getLogger(this));
  }
  castPosition(t2) {
    t2 && t2 instanceof Float32Array && n.getLogger(this).warn(".position=", "Setting position attribute from a Float32Array may cause precision problems. Consider storing data in a Float64Array or a regular number array");
    return n2(t2, Float64Array, [Float32Array], { loggerTag: ".position=", stride: 3 }, n.getLogger(this));
  }
  castUv(t2) {
    return n2(t2, Float32Array, [Float64Array], { loggerTag: ".uv=", stride: 2 }, n.getLogger(this));
  }
  castNormal(t2) {
    return n2(t2, Float32Array, [Float64Array], { loggerTag: ".normal=", stride: 3 }, n.getLogger(this));
  }
  castTangent(t2) {
    return n2(t2, Float32Array, [Float64Array], { loggerTag: ".tangent=", stride: 4 }, n.getLogger(this));
  }
  clone() {
    const t2 = { position: a(this.position), uv: a(this.uv), normal: a(this.normal), tangent: a(this.tangent), color: a(this.color) };
    return new g(t2);
  }
  clonePositional() {
    const t2 = { position: a(this.position), normal: a(this.normal), tangent: a(this.tangent), uv: this.uv, color: this.color };
    return new g(t2);
  }
  get memoryUsage() {
    let t2 = 0;
    return t2 += this.position.byteLength, null != this.uv && (t2 += this.uv.byteLength), null != this.normal && (t2 += this.normal.byteLength), null != this.tangent && (t2 += this.tangent.byteLength), null != this.color && (t2 += this.color.byteLength), t2;
  }
};
r([m({ json: { write: r2 } })], p.prototype, "color", void 0), r([s("color")], p.prototype, "castColor", null), r([m({ nonNullable: true, json: { write: r2 } })], p.prototype, "position", void 0), r([s("position")], p.prototype, "castPosition", null), r([m({ json: { write: r2 } })], p.prototype, "uv", void 0), r([s("uv")], p.prototype, "castUv", null), r([m({ json: { write: r2 } })], p.prototype, "normal", void 0), r([s("normal")], p.prototype, "castNormal", null), r([m({ json: { write: r2 } })], p.prototype, "tangent", void 0), r([s("tangent")], p.prototype, "castTangent", null), p = g = r([a2("esri.geometry.support.MeshVertexAttributes")], p);

export {
  n2 as n,
  r2 as r,
  p
};
//# sourceMappingURL=chunk-LY6SU3A2.js.map
