import {
  B,
  V as V3
} from "./chunk-UK4PA5E2.js";
import {
  i as i5
} from "./chunk-C5QEEP7V.js";
import {
  n as n6
} from "./chunk-XECP56E2.js";
import {
  t as t4
} from "./chunk-TGFVKJXH.js";
import {
  i as i4
} from "./chunk-ZZTUJWOP.js";
import {
  l as l2
} from "./chunk-SVRTKGNR.js";
import {
  c as c2
} from "./chunk-JED7FM2Q.js";
import {
  p
} from "./chunk-CQFC4JO6.js";
import {
  c
} from "./chunk-CQTV4C3X.js";
import {
  s as s4
} from "./chunk-GEPD6W23.js";
import {
  p as p2
} from "./chunk-QSIT7EPR.js";
import {
  C as C2,
  n as n7
} from "./chunk-TP6LRQ42.js";
import {
  l as l3
} from "./chunk-ZE6OS33V.js";
import {
  d as d4
} from "./chunk-MWZJIOOL.js";
import {
  p as p3
} from "./chunk-ULSRCITK.js";
import {
  e as e2
} from "./chunk-FLUE3DMC.js";
import {
  m as m4,
  o as o2,
  u
} from "./chunk-5GQ62KHN.js";
import {
  A as A2
} from "./chunk-WH2FR6UE.js";
import {
  j as j2
} from "./chunk-RG7AMCT5.js";
import {
  f
} from "./chunk-PV3ZZQOV.js";
import {
  l
} from "./chunk-SM2VXWMT.js";
import {
  t
} from "./chunk-IGMG7ERK.js";
import {
  b as b4
} from "./chunk-V47ZBW5W.js";
import {
  I as I3,
  T as T2,
  a as a4,
  b as b3,
  d as d5,
  l as l4,
  p as p6,
  s as s5,
  u as u2
} from "./chunk-HKYICNT2.js";
import {
  S
} from "./chunk-VGUQMPM6.js";
import {
  o as o3
} from "./chunk-CTU2XDPA.js";
import {
  i as i3
} from "./chunk-SUBGY5CE.js";
import {
  A,
  C,
  D,
  E,
  F as F2,
  I as I2,
  J,
  L,
  M,
  O,
  P,
  Q,
  R,
  S as S2,
  T,
  U as U2,
  V as V4,
  W,
  Z,
  _,
  g as g2,
  q as q2,
  v as v2,
  x,
  z
} from "./chunk-Z3NV3VCK.js";
import {
  d as d3
} from "./chunk-PVHAAI32.js";
import {
  F
} from "./chunk-U3JQIAF6.js";
import {
  t as t3
} from "./chunk-BHQS42D6.js";
import {
  t as t2
} from "./chunk-CVI4GL5M.js";
import {
  f as f2
} from "./chunk-QMGMKWTA.js";
import {
  p as p4
} from "./chunk-2EGO74J5.js";
import {
  d as d2
} from "./chunk-6Q7GN2CW.js";
import {
  q
} from "./chunk-MYUZZ3A3.js";
import {
  j2 as j
} from "./chunk-JFI4ESYU.js";
import {
  n as n5
} from "./chunk-ZICJB3ML.js";
import {
  b as b2
} from "./chunk-F3NUC2RS.js";
import {
  K
} from "./chunk-NYLL2YZF.js";
import {
  d,
  m as m3,
  w as w3
} from "./chunk-P3GRQ2CH.js";
import {
  i as i2
} from "./chunk-NYLBGE62.js";
import {
  g as g3,
  p as p5
} from "./chunk-BWTCR2DR.js";
import {
  n as n4
} from "./chunk-SMOTPOZ7.js";
import {
  i
} from "./chunk-2PK57UYA.js";
import {
  v2 as v
} from "./chunk-VUJERGGB.js";
import {
  V as V2,
  n as n3
} from "./chunk-RCLWOQNR.js";
import {
  m as m2
} from "./chunk-B6VE32RA.js";
import {
  n as n2
} from "./chunk-2M53HYNY.js";
import {
  w as w2
} from "./chunk-FG3XOAFD.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  g,
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  s as s3
} from "./chunk-WTNHDCCU.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  I,
  V
} from "./chunk-YFGQMO6E.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a3,
  s4 as s2,
  w
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a as a2,
  h,
  k
} from "./chunk-GRW2QIBT.js";
import {
  a,
  e,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/layers/graphics/sources/MemorySource.js
var _2 = 0;
var T3 = class extends m2.LoadableMixin(n2(V2)) {
  constructor(e4) {
    super(e4), this._idToClientGraphic = null, this.type = "memory";
  }
  load(e4) {
    const t5 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this._startWorker(t5)), Promise.resolve(this);
  }
  destroy() {
    var _a;
    (_a = this._connection) == null ? void 0 : _a.close(), this._connection = null;
  }
  get _workerGeometryType() {
    var _a;
    const e4 = (_a = this.layer) == null ? void 0 : _a.geometryType;
    return e4 ? this._geometryTypeRequiresClientGraphicMapping(e4) ? "polygon" : e4 : null;
  }
  applyEdits(e4) {
    return this.load().then(() => this._applyEdits(e4));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(e4, t5 = {}) {
    await this.load(t5);
    const r3 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t5);
    t2(e4, this.layer.spatialReference, r3);
    const s6 = d3.fromJSON(r3);
    if (!this._requiresClientGraphicMapping()) return s6;
    const i6 = this.layer.objectIdField;
    for (const o5 of s6.features) {
      const e5 = o5.attributes[i6], t6 = this._idToClientGraphic.get(e5);
      t6 && (o5.geometry = t6.geometry);
    }
    return s6.geometryType = this.layer.geometryType, s6;
  }
  async queryFeaturesJSON(e4, t5 = {}) {
    if (this._requiresClientGraphicMapping()) throw new s("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(t5);
    const r3 = await this._connection.invoke("queryFeatures", e4 ? e4.toJSON() : null, t5);
    return t2(e4, this.layer.spatialReference, r3), r3;
  }
  queryFeatureCount(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryFeatureCount", e4 ? e4.toJSON() : null, t5));
  }
  queryObjectIds(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryObjectIds", e4 ? e4.toJSON() : null, t5));
  }
  queryExtent(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("queryExtent", e4 ? e4.toJSON() : null, t5)).then((e5) => ({ count: e5.count, extent: w2.fromJSON(e5.extent) }));
  }
  querySnapping(e4, t5 = {}) {
    return this.load(t5).then(() => this._connection.invoke("querySnapping", e4, t5));
  }
  async _applyEdits(e4) {
    if (!this._connection) throw new s("feature-layer-source:edit-failure", "Memory source not loaded");
    const t5 = this.layer.objectIdField;
    let r3 = null;
    const i6 = [], o5 = [];
    await Promise.all([this._prepareClientMapping(e4.addFeatures, null), this._prepareClientMapping(e4.updateFeatures, null)]);
    const n9 = (e5) => "objectId" in e5 && null != e5.objectId ? e5.objectId : "attributes" in e5 && null != e5.attributes[t5] ? e5.attributes[t5] : null;
    if (e4.addFeatures && (r3 = this._prepareAddFeatures(e4.addFeatures)), e4.deleteFeatures) for (const s6 of e4.deleteFeatures) {
      const e5 = n9(s6);
      null != e5 && i6.push(e5);
    }
    const a5 = e4.updateFeatures && this._idToClientGraphic ? /* @__PURE__ */ new Map() : null;
    if (e4.updateFeatures) {
      for (const s6 of e4.updateFeatures) if (o5.push(this._serializeFeature(s6)), a5) {
        const e5 = n9(s6);
        null != e5 && a5.set(e5, s6);
      }
    }
    i3(r3 ? r3.features : null, o5, this.layer.spatialReference);
    const { fullExtent: l5, featureEditResults: u3 } = await this._connection.invoke("applyEdits", { adds: r3 ? r3.features : [], updates: o5, deletes: i6 });
    return this.fullExtent = l5, r3 && r3.finish(u3.uidToObjectId), this._updateClientGraphicIds(a5, u3), this._createEditsResult(u3);
  }
  async _prepareClientMapping(e4, t5) {
    if ("mesh" !== this._layerOrSourceGeometryType || null == e4) return;
    const r3 = [];
    for (const { geometry: s6 } of e4) null == s6 || "mesh" !== s6.type || s6.hasExtent || s6.loaded || r3.push(s6.load({ signal: t5 }));
    r3.length && await Promise.all(r3);
  }
  _updateClientGraphicIds(e4, t5) {
    if (this._idToClientGraphic) {
      if (e4) for (const r3 of t5.updateResults) {
        if (!r3.success) continue;
        const t6 = e4.get(r3.objectId);
        null != t6 && this._addIdToClientGraphic(t6);
      }
      for (const e5 of t5.deleteResults) e5.success && this._idToClientGraphic.delete(e5.objectId);
    }
  }
  _createEditsResult(e4) {
    return { addFeatureResults: e4.addResults ? e4.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: e4.updateResults ? e4.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: e4.deleteResults ? e4.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(e4) {
    const t5 = true === e4.success ? null : e4.error || { code: void 0, description: void 0 };
    return { objectId: e4.objectId, globalId: e4.globalId, error: t5 ? new s("feature-layer-source:edit-failure", t5.description, { code: t5.code }) : null };
  }
  _prepareAddFeatures(e4) {
    const t5 = /* @__PURE__ */ new Map(), r3 = new Array(e4.length);
    let s6 = null;
    for (let o5 = 0; o5 < e4.length; o5++) {
      const i7 = e4[o5], n9 = this._serializeFeature(i7);
      s6 || null == i7.geometry || (s6 = i7.geometry.type), r3[o5] = n9, t5.set(`${n9.uid}`, i7);
    }
    const i6 = this;
    return { features: r3, inferredGeometryType: s6, finish(e5) {
      const r4 = i6.sourceJSON.objectIdField;
      for (const s7 in e5) {
        const o5 = e5[s7], n9 = t5.get(s7);
        n9 && (n9.attributes || (n9.attributes = {}), -1 === o5 ? delete n9.attributes[r4] : n9.attributes[r4] = o5, i6._addIdToClientGraphic(n9));
      }
    } };
  }
  _addIdToClientGraphic(e4) {
    var _a;
    if (!this._idToClientGraphic) return;
    const t5 = this.sourceJSON.objectIdField, r3 = (_a = e4.attributes) == null ? void 0 : _a[t5];
    null != r3 && this._idToClientGraphic.set(r3, e4);
  }
  get _layerOrSourceGeometryType() {
    var _a, _b;
    return ((_a = this.layer) == null ? void 0 : _a.geometryType) ?? ((_b = this.sourceJSON) == null ? void 0 : _b.geometryType);
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(e4) {
    return this._geometryTypeRequiresClientGraphicMapping(e4.type);
  }
  _geometryTypeRequiresClientGraphicMapping(e4) {
    return "mesh" === e4 || "multipatch" === e4 || "extent" === e4;
  }
  _serializeFeature(e4) {
    const { attributes: t5 } = e4, r3 = this._geometryForSerialization(e4), s6 = (_2++).toString();
    return r3 ? { uid: s6, geometry: r3.toJSON(), attributes: t5 } : { uid: s6, attributes: t5 };
  }
  _geometryForSerialization(e4) {
    const { geometry: t5 } = e4;
    if (null == t5) return null;
    if (this._geometryRequiresClientGraphicMapping(t5)) {
      return t5.extent ? v.fromExtent(t5.extent) : null;
    }
    return t5;
  }
  async _startWorker(e4) {
    this._connection = await p4("MemorySourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: e4, registryTarget: this });
    const { fields: t5, spatialReference: r3, objectIdField: s6, hasM: i6, hasZ: n9, timeInfo: l5, dateFieldsTimeZone: u3 } = this.layer, p8 = "defaults" === this.layer.originOf("spatialReference");
    await this._prepareClientMapping(this.items, e4);
    const c3 = this._prepareAddFeatures(this.items);
    this.addHandles(this.on("before-changes", (e5) => {
      n.getLogger(this).error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), e5.preventDefault();
    }));
    const d6 = { features: c3.features, fields: t5 == null ? void 0 : t5.map((e5) => e5.toJSON()), geometryType: i.toJSON(this._workerGeometryType), hasM: "mesh" !== this._layerOrSourceGeometryType && i6, hasZ: "mesh" === this._layerOrSourceGeometryType || n9, objectIdField: s6, spatialReference: p8 ? null : r3 && r3.toJSON(), timeInfo: (l5 == null ? void 0 : l5.toJSON()) ?? null, dateFieldsTimeZone: u3 }, h2 = await this._connection.invoke("load", d6, { signal: e4 });
    for (const a5 of h2.warnings) n.getLogger(this.layer).warn("#load()", `${a5.message} (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { warning: a5 });
    h2.featureErrors.length && n.getLogger(this.layer).warn("#load()", `Encountered ${h2.featureErrors.length} validation errors while loading features. (title: '${this.layer.title || "no title"}', id: '${this.layer.id ?? "no id"}')`, { errors: h2.featureErrors });
    const y = h2.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(c3.inferredGeometryType) && (y.geometryType = i.toJSON(c3.inferredGeometryType)), this.sourceJSON = y, this._requiresClientGraphicMapping() && (this._idToClientGraphic = /* @__PURE__ */ new Map()), c3.finish(h2.assignedObjectIds);
  }
};
r([n3({ Type: d2, ensureType: w(d2) })], T3.prototype, "itemType", void 0), r([m()], T3.prototype, "type", void 0), r([m({ constructOnly: true })], T3.prototype, "layer", void 0), r([m({ readOnly: true })], T3.prototype, "_workerGeometryType", null), r([m()], T3.prototype, "sourceJSON", void 0), T3 = r([a3("esri.layers.graphics.sources.MemorySource")], T3);

// node_modules/@arcgis/core/layers/support/PublishingInfo.js
var e3 = class extends b {
  constructor() {
    super(...arguments), this.updating = false, this.status = "unknown";
  }
};
r([m()], e3.prototype, "updating", void 0), r([m()], e3.prototype, "status", void 0), e3 = r([a3("esri.layers.support.PublishingInfo")], e3);
var p7 = e3;

// node_modules/@arcgis/core/layers/mixins/PublishableLayer.js
var o4 = Symbol();
var n8 = (i6) => {
  var n9;
  let u3 = class extends i6 {
    constructor() {
      super(...arguments), this[n9] = true;
    }
    get publishingInfo() {
      if (this.destroyed) return null;
      const t5 = this._get("publishingInfo");
      if (t5) return t5;
      const s6 = new p7();
      return this._checkPublishingStatus(s6), s6;
    }
    _checkPublishingStatus(t5) {
      const s6 = 250, e4 = 125;
      let r3 = 0;
      const o5 = async (s7) => {
        let n10;
        t5.updating = true;
        try {
          n10 = await this.fetchPublishingStatus();
        } catch (u4) {
          n10 = "unavailable";
        }
        "published" !== n10 && "unavailable" !== n10 || ("publishing" === t5.status && this.refresh(), i7.remove()), t5.status = n10, t5.updating = false, i7.removed || (r3 = setTimeout(o5, s7, s7 + e4));
      }, i7 = { removed: false, remove() {
        this.removed = true, clearTimeout(r3);
      } };
      this.when().catch(() => i7.remove()), o5(s6), this.addHandles(i7);
    }
  };
  return n9 = o4, r([m({ readOnly: true, clonable: false })], u3.prototype, "publishingInfo", null), u3 = r([a3("esri.layers.mixins.PublishableLayer")], u3), u3;
};

// node_modules/@arcgis/core/layers/FeatureLayer.js
var We = "FeatureLayer";
function Ze(e4, t5) {
  return new s("layer:unsupported", `Layer (${e4.title}, ${e4.id}) of type '${e4.declaredClass}' ${t5}`, { layer: e4 });
}
function He(e4) {
  return e4 && e4 instanceof V2;
}
var ke = s4();
function ze(e4, t5, r3) {
  const i6 = !!(r3 == null ? void 0 : r3.writeLayerSchema);
  return { enabled: i6, ignoreOrigin: i6 };
}
var Ke = class extends B(c2(c(n8(F(l(p(l3(t(f(l2(b4(j2(S(e2(i4(i2(f2))))))))))))))))) {
  constructor(...e4) {
    super(...e4), this.attributeTableTemplate = null, this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = false, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = true, this.popupTemplate = null, this.resourceInfo = null, this.screenSizePerspectiveEnabled = true, this.spatialReference = g.WGS84, this.subtypeCode = null, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Oriented Imagery Layer", "Table", "Catalog Layer"]), this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = true, this._debouncedSaveOperations = k(async (e5, t5, r3) => {
      const { save: i6, saveAs: o5 } = await import("./featureLayerUtils-FDGTT2YY.js");
      switch (e5) {
        case A2.SAVE:
          return i6(this, t5);
        case A2.SAVE_AS:
          return o5(this, r3, t5);
      }
    });
  }
  destroy() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.destroy();
  }
  normalizeCtorArgs(e4, t5) {
    return "string" == typeof e4 ? { url: e4, ...t5 } : e4;
  }
  load(e4) {
    var _a;
    const t5 = null != e4 ? e4.signal : null;
    if (((_a = this.portalItem) == null ? void 0 : _a.loaded) && this.source) return this.addResolvingPromise(this.createGraphicsSource(t5).then((e5) => this.initLayerProperties(e5))), Promise.resolve(this);
    const r3 = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection", "Scene Service"] }, e4).catch(a2).then(async () => {
      if (this.url && null == this.layerId && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const e5 = await this._fetchFirstValidLayerId(t5);
        null != e5 && (this.layerId = e5);
      }
      if (!this.url && !this._hasMemorySource()) throw new s("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(t5));
    }).then(() => J(this, "load", e4));
    return this.addResolvingPromise(r3), Promise.resolve(this);
  }
  warnInvisibleDrapedSymbols() {
    var _a, _b, _c;
    "on-the-ground" === ((_a = this.elevationInfo) == null ? void 0 : _a.mode) && "simple" === ((_b = this.renderer) == null ? void 0 : _b.type) && "polygon-3d" === ((_c = this.renderer.symbol) == null ? void 0 : _c.type) && this.renderer.symbol.symbolLayers.some((e4) => "fill" === e4.type && null != e4.material && ((!e4.material.color || e4.material.color.a * this.opacity < o3) && (this.loadWarnings.push(new s2("feature-layer:invisible-draped-symbols", "FeatureLayer has fully transparent symbols which will no longer render or highlight", { layer: this })), true)));
  }
  readCapabilities(e4, t5) {
    return t5 = t5.layerDefinition || t5, i5(t5, this.url);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    var _a;
    return !(this.loaded && !((_a = this.capabilities) == null ? void 0 : _a.operations.supportsEditing)) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e4) {
    this._overrideIfSome("editingEnabled", e4);
  }
  readEditingEnabled(e4, t5) {
    return this._readEditingEnabled(t5, false);
  }
  readEditingEnabledFromWebMap(e4, t5, r3) {
    return this._readEditingEnabled(t5, true, r3);
  }
  writeEditingEnabled(e4, t5) {
    this._writeEditingEnabled(e4, t5, false);
  }
  writeEditingEnabledToWebMap(e4, t5, r3, i6) {
    this._writeEditingEnabled(e4, t5, true, i6);
  }
  get effectiveEditingEnabled() {
    return Z(this);
  }
  readIsTable(e4, t5) {
    return "Table" === (t5 = (t5 == null ? void 0 : t5.layerDefinition) ?? t5).type || !t5.geometryType;
  }
  writeIsTable(e4, t5, r3, i6) {
    (i6 == null ? void 0 : i6.writeLayerSchema) && e(r3, e4 ? "Table" : "Feature Layer", t5);
  }
  readGlobalIdField(e4, t5) {
    return V4(t5.layerDefinition || t5);
  }
  readObjectIdField(e4, t5) {
    return D(t5.layerDefinition || t5);
  }
  get parsedUrl() {
    const e4 = I(this.url);
    return null != e4 && (null != this.dynamicDataSource ? e4.path = V(e4.path, "dynamicLayer") : null != this.layerId && (e4.path = V(e4.path, this.layerId.toString()))), e4;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e4) {
    p5(e4, this.fieldsIndex), this._set("renderer", e4);
  }
  readRenderer(e4, t5, i6) {
    var _a;
    t5 = t5.layerDefinition || t5;
    const o5 = (_a = t5.drawingInfo) == null ? void 0 : _a.renderer;
    if (o5) {
      const e5 = o2(o5, t5, i6) ?? void 0;
      return e5 || n.getLogger(this).error("Failed to create renderer", { rendererDefinition: t5.drawingInfo.renderer, layer: this, context: i6 }), e5;
    }
    return z(t5, i6);
  }
  set source(e4) {
    const t5 = this._get("source");
    t5 !== e4 && (He(t5) && this._resetMemorySource(t5), He(e4) && this._initMemorySource(e4), this._set("source", e4));
  }
  castSource(e4) {
    return e4 ? Array.isArray(e4) || e4 instanceof V2 ? new T3({ layer: this, items: e4 }) : e4 : null;
  }
  readSource(e4, t5) {
    const r3 = d3.fromJSON(t5.featureSet);
    return new T3({ layer: this, items: (r3 == null ? void 0 : r3.features) ?? [] });
  }
  readTemplates(e4, t5) {
    const r3 = t5.editFieldsInfo, i6 = r3 == null ? void 0 : r3.creatorField, o5 = r3 == null ? void 0 : r3.editorField;
    return e4 = e4 == null ? void 0 : e4.map((e5) => p2.fromJSON(e5)), this._fixTemplates(e4, i6), this._fixTemplates(e4, o5), e4;
  }
  readTitle(e4, t5) {
    var _a, _b, _c;
    const r3 = ((_a = t5.layerDefinition) == null ? void 0 : _a.name) ?? t5.name, i6 = t5.title || ((_b = t5.layerDefinition) == null ? void 0 : _b.title);
    if (r3) {
      const e5 = (_c = this.portalItem) == null ? void 0 : _c.title;
      if ("item-title" === this.sublayerTitleMode) return this.url ? w3(this.url, r3) : r3;
      let t6 = r3;
      if (!t6 && this.url) {
        const e6 = d(this.url);
        null != e6 && (t6 = e6.title);
      }
      if (!t6) return;
      return "item-title-and-service-name" === this.sublayerTitleMode && e5 && e5 !== t6 && (t6 = e5 + " - " + t6), m3(t6);
    }
    if ("item-title" === this.sublayerTitleMode && i6) return i6;
  }
  readTitleFromWebMap(e4, t5) {
    var _a;
    return t5.title || ((_a = t5.layerDefinition) == null ? void 0 : _a.name);
  }
  readTypeIdField(e4, t5) {
    let r3 = (t5 = t5.layerDefinition || t5).typeIdField;
    if (r3 && t5.fields) {
      r3 = r3.toLowerCase();
      const e5 = t5.fields.find((e6) => e6.name.toLowerCase() === r3);
      e5 && (r3 = e5.name);
    }
    return r3;
  }
  readTypes(e4, t5) {
    e4 = (t5 = t5.layerDefinition || t5).types;
    const r3 = t5.editFieldsInfo, i6 = r3 == null ? void 0 : r3.creatorField, o5 = r3 == null ? void 0 : r3.editorField;
    return e4 == null ? void 0 : e4.map((e5) => (e5 = n6.fromJSON(e5), this._fixTemplates(e5.templates, i6), this._fixTemplates(e5.templates, o5), e5));
  }
  readVisible(e4, t5) {
    var _a;
    return null != ((_a = t5.layerDefinition) == null ? void 0 : _a.defaultVisibility) ? !!t5.layerDefinition.defaultVisibility : null != t5.visibility ? !!t5.visibility : void 0;
  }
  async addAttachment(e4, t5) {
    const r3 = await I2(this, e4, t5, We);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r3;
  }
  async updateAttachment(e4, t5, r3) {
    const i6 = await F2(this, e4, t5, r3, We);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), i6;
  }
  async applyEdits(e4, t5) {
    return q2(this, e4, t5);
  }
  async uploadAssets(e4, t5) {
    return x(this, e4, t5);
  }
  on(e4, t5) {
    return super.on(e4, t5);
  }
  createPopupTemplate(e4) {
    return p3(this, e4);
  }
  async createGraphicsSource(e4) {
    if (this._hasMemorySource() && this.source) return this.source.load({ signal: e4 });
    const { default: t5 } = await h(import("./FeatureLayerSource-E3CFS5BC.js"), e4);
    return new t5({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e4 });
  }
  createQuery() {
    const e4 = M(this);
    e4.dynamicDataSource = this.dynamicDataSource;
    const t5 = null != this.subtypeCode ? `${this.subtypeField} = ${this.subtypeCode}` : null, r3 = n4(this.definitionExpression, t5);
    return e4.where = r3 || "1=1", e4;
  }
  async deleteAttachments(e4, t5) {
    const r3 = await A(this, e4, t5, We);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r3;
  }
  async fetchRecomputedExtents(e4) {
    return v2(this, e4, We);
  }
  getFeatureType(e4) {
    return W(this.types, this.typeIdField, e4);
  }
  getFieldDomain(e4, t5) {
    var _a, _b;
    const r3 = t5 == null ? void 0 : t5.feature, i6 = !!((_a = this.subtypes) == null ? void 0 : _a.length);
    if (i6 && !(t5 == null ? void 0 : t5.excludeImpliedDomains)) {
      const t6 = T(this, e4);
      if (t6) return t6;
    }
    const o5 = i6 && Q(this, r3);
    if (o5) {
      const t6 = (_b = o5 == null ? void 0 : o5.domains) == null ? void 0 : _b[e4];
      return "inherited" === (t6 == null ? void 0 : t6.type) ? this._getLayerDomain(e4) : t6;
    }
    const s6 = this.getFeatureType(r3), a5 = this._getLayerDomain(e4);
    if (s6) {
      const t6 = s6.domains && s6.domains[e4];
      if (t6 && "inherited" !== (t6 == null ? void 0 : t6.type)) return t6;
    }
    if (a5) return a5;
    if (!(t5 == null ? void 0 : t5.excludeImpliedDomains)) {
      const t6 = U2(this, e4);
      if (t6) return t6;
    }
    return null;
  }
  getField(e4) {
    return this.fieldsIndex.get(e4);
  }
  async queryAttachments(e4, t5) {
    return S2(this, e4, t5, We);
  }
  async queryFeatures(e4, t5) {
    const r3 = await this.load(), i6 = await r3.source.queryFeatures(b2.from(e4) ?? r3.createQuery(), t5);
    if (i6 == null ? void 0 : i6.features) for (const o5 of i6.features) o5.layer = o5.sourceLayer = r3;
    return i6;
  }
  async queryObjectIds(e4, t5) {
    return O(this, e4, t5, We);
  }
  async queryFeatureCount(e4, t5) {
    return P(this, e4, t5, We);
  }
  async queryExtent(e4, t5) {
    return E(this, e4, t5, We);
  }
  async queryRelatedFeatures(e4, t5) {
    return L(this, e4, t5, We);
  }
  async queryRelatedFeaturesCount(e4, t5) {
    return C(this, e4, t5, We);
  }
  async queryTopFeatures(e4, t5) {
    var _a;
    const { source: r3, capabilities: i6 } = await this.load();
    if (!r3.queryTopFeatures || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery)) throw new s(We, "Layer source does not support queryTopFeatures capability");
    const o5 = await import("./TopFeaturesQuery-FWZVFBGF.js"), s6 = await r3.queryTopFeatures(o5.default.from(e4), t5);
    if (s6 == null ? void 0 : s6.features) for (const a5 of s6.features) a5.layer = a5.sourceLayer = this;
    return s6;
  }
  async queryBins(e4, t5) {
    var _a;
    const { source: r3, capabilities: i6 } = await this.load();
    if (!r3.queryBins || !((_a = i6 == null ? void 0 : i6.operations) == null ? void 0 : _a.supportsQueryBins)) throw new s(We, "Layer source does not support queryBins capability");
    _(e4, i6, We);
    const o5 = await import("./BinsQuery-JGG6CAAC.js"), s6 = await r3.queryBins(o5.default.from(e4), t5);
    if (s6.features) for (const a5 of s6.features) a5.layer = a5.sourceLayer = this;
    return s6;
  }
  async queryTopObjectIds(e4, t5) {
    const { source: r3, capabilities: i6 } = await this.load();
    if (!r3.queryTopObjectIds || !(i6 == null ? void 0 : i6.query.supportsTopFeaturesQuery)) throw new s(We, "Layer source does not support queryTopObjectIds capability");
    const o5 = await import("./TopFeaturesQuery-FWZVFBGF.js");
    return r3.queryTopObjectIds(o5.default.from(e4), t5);
  }
  async queryTopFeaturesExtent(e4, t5) {
    var _a;
    const { source: r3, capabilities: i6 } = await this.load();
    if (!r3.queryTopExtents || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery)) throw new s(We, "Layer source does not support queryTopExtents capability");
    const o5 = await import("./TopFeaturesQuery-FWZVFBGF.js");
    return r3.queryTopExtents(o5.default.from(e4), t5);
  }
  async queryTopFeatureCount(e4, t5) {
    var _a;
    const { source: r3, capabilities: i6 } = await this.load();
    if (!r3.queryTopCount || !((_a = i6 == null ? void 0 : i6.query) == null ? void 0 : _a.supportsTopFeaturesQuery)) throw new s(We, "Layer source does not support queryFeatureCount capability");
    const o5 = await import("./TopFeaturesQuery-FWZVFBGF.js");
    return r3.queryTopCount(o5.default.from(e4), t5);
  }
  read(e4, t5) {
    const r3 = e4.featureCollection;
    if ((r3 || "Feature Collection" === e4.type) && (this.resourceInfo = e4), r3) {
      const e5 = r3.layers;
      e5 && 1 === e5.length && (super.read(e5[0], t5), null != r3.showLegend && super.read({ showLegend: r3.showLegend }, t5));
    }
    super.read(e4, t5), t5 && "service" === t5.origin && (this.revert(["objectIdField", "fields", "timeInfo", "dateFieldsTimeZone"], "service"), this.spatialReference || this.revert(["spatialReference"], "service"));
  }
  write(e4, t5) {
    t5 = { ...t5, origin: (t5 == null ? void 0 : t5.origin) ?? void 0, writeLayerSchema: (t5 == null ? void 0 : t5.writeLayerSchema) ?? this._hasMemorySource() };
    const { origin: r3, layerContainerType: i6, messages: o5 } = t5;
    if (this.dynamicDataSource) return o5 == null ? void 0 : o5.push(Ze(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if (("web-map" === r3 || "web-scene" === r3) && "tables" !== i6) return o5 == null ? void 0 : o5.push(Ze(this, `a table source can only be written to tables, not ${i6}`)), null;
      if (this._hasMemorySource()) return o5 == null ? void 0 : o5.push(Ze(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && ("web-map" === r3 || "web-scene" === r3) && "tables" === i6) return o5 == null ? void 0 : o5.push(Ze(this, "using a non-table source cannot be written to tables in web maps or web scenes")), null;
    return super.write(e4, t5);
  }
  clone() {
    if (this._hasMemorySource()) throw new s(We, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e4) {
    var _a;
    return !!this.loaded && ("memory" === ((_a = this.source) == null ? void 0 : _a.type) || t4(this, e4));
  }
  async save(e4) {
    return this._debouncedSaveOperations(A2.SAVE, e4);
  }
  async saveAs(e4, t5) {
    return this._debouncedSaveOperations(A2.SAVE_AS, t5, e4);
  }
  _readEditingEnabled(e4, t5, r3) {
    var _a;
    let i6 = (_a = e4.layerDefinition) == null ? void 0 : _a.capabilities;
    return i6 ? this._hasEditingCapability(i6) : (i6 = e4.capabilities, t5 && "web-map" === (r3 == null ? void 0 : r3.origin) && !this._hasMemorySource() && i6 ? this._hasEditingCapability(i6) : void 0);
  }
  _hasEditingCapability(e4) {
    return e4.toLowerCase().split(",").map((e5) => e5.trim()).includes("editing");
  }
  _writeEditingEnabled(e4, t5, r3, i6) {
    var _a, _b;
    if (!e4) {
      const e5 = ((_b = (_a = this.capabilities) == null ? void 0 : _a.operations) == null ? void 0 : _b.supportsSync) ? "Query,Sync" : "Query";
      e("layerDefinition.capabilities", e5, t5), r3 && !(i6 == null ? void 0 : i6.writeLayerSchema) && (t5.capabilities = e5);
    }
  }
  _getLayerDomain(e4) {
    const t5 = this.fieldsIndex.get(e4);
    return t5 ? t5.domain : null;
  }
  _fetchFirstValidLayerId(e4) {
    return U(this.url ?? "", { query: { f: "json", ...this.customParameters, token: this.apiKey }, responseType: "json", signal: e4 }).then((e5) => {
      const t5 = e5.data;
      if (t5) return this.findFirstValidLayerId(t5);
    });
  }
  async initLayerProperties(e4) {
    var _a;
    return this._set("source", e4), e4.sourceJSON && (this.sourceJSON = e4.sourceJSON, this.read(e4.sourceJSON, { origin: "service", portalItem: this.portalItem, portal: (_a = this.portalItem) == null ? void 0 : _a.portal, url: this.parsedUrl })), this._verifySource(), this._verifyFields(), p5(this.renderer, this.fieldsIndex), g3(this.timeInfo, this.fieldsIndex), t3(this, { origin: "service" });
  }
  async hasDataChanged() {
    return R(this);
  }
  async fetchPublishingStatus() {
    const e4 = this.source;
    return (e4 == null ? void 0 : e4.fetchPublishingStatus) ? e4.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    var _a, _b;
    const e4 = ((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e4 + ")"), this.isTable || this._hasMemorySource() || -1 !== e4.search(/\/FeatureServer\//i) || ((_b = this.fields) == null ? void 0 : _b.some((e5) => "geometry" === e5.type)) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e4 + ")");
  }
  _fixTemplates(e4, t5) {
    e4 && e4.forEach((e5) => {
      var _a;
      const r3 = (_a = e5.prototype) == null ? void 0 : _a.attributes;
      r3 && t5 && delete r3[t5];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url) throw new s("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url) throw new s("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = this, e5.sourceLayer = this;
    }), this.addHandles([e4.on("after-add", (e5) => {
      e5.item.layer = this, e5.item.sourceLayer = this;
    }), e4.on("after-remove", (e5) => {
      e5.item.layer = null, e5.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e4) {
    e4.forEach((e5) => {
      e5.layer = null, e5.sourceLayer = null;
    }), this.removeHandles("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
  findFirstValidLayerId(e4) {
    return Array.isArray(e4.layers) && e4.layers.length > 0 ? e4.layers[0].id : Array.isArray(e4.tables) && e4.tables.length > 0 ? e4.tables[0].id : void 0;
  }
};
r([m(T2)], Ke.prototype, "attributeTableTemplate", void 0), r([o("service", "capabilities")], Ke.prototype, "readCapabilities", null), r([m({ json: { origins: { "web-scene": { write: false } }, write: true } })], Ke.prototype, "charts", void 0), r([m({ readOnly: true })], Ke.prototype, "createQueryVersion", null), r([m({ json: { read: { source: "layerDefinition.copyrightText" } } })], Ke.prototype, "copyright", void 0), r([m({ json: { read: { source: "layerDefinition.displayField" } } })], Ke.prototype, "displayField", void 0), r([m({ types: j, readOnly: true })], Ke.prototype, "defaultSymbol", void 0), r([m({ type: K })], Ke.prototype, "dynamicDataSource", void 0), r([m({ type: Boolean })], Ke.prototype, "editingEnabled", null), r([o(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], Ke.prototype, "readEditingEnabled", null), r([o("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], Ke.prototype, "readEditingEnabledFromWebMap", null), r([r2(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], Ke.prototype, "writeEditingEnabled", null), r([r2("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], Ke.prototype, "writeEditingEnabledToWebMap", null), r([m({ readOnly: true })], Ke.prototype, "effectiveEditingEnabled", null), r([m({ ...ke.fields, json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: ze } } } } })], Ke.prototype, "fields", void 0), r([m(ke.fieldsIndex)], Ke.prototype, "fieldsIndex", void 0), r([m({ type: V3, json: { name: "formInfo", write: true, origins: { "web-scene": { read: false, write: false } } } })], Ke.prototype, "formTemplate", void 0), r([m({ json: { read: { source: "layerDefinition.extent" } } })], Ke.prototype, "fullExtent", void 0), r([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: ze, writer(e4, t5, r3) {
  const i6 = e4 ? g2.toJSON(e4) : null;
  i6 && e(r3, i6, t5);
} } } }, read: { source: "layerDefinition.geometryType", reader: g2.read } } })], Ke.prototype, "geometryType", void 0), r([m({ json: { read: { source: "layerDefinition.hasM" } } })], Ke.prototype, "hasM", void 0), r([m({ json: { read: { source: "layerDefinition.hasZ" } } })], Ke.prototype, "hasZ", void 0), r([m(u2)], Ke.prototype, "id", void 0), r([m({ readOnly: true, json: { origins: { service: { read: true } }, read: false } })], Ke.prototype, "infoFor3D", void 0), r([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], Ke.prototype, "isTable", void 0), r([o("service", "isTable", ["type", "geometryType"]), o("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], Ke.prototype, "readIsTable", null), r([r2("web-map", "isTable")], Ke.prototype, "writeIsTable", null), r([m(p6)], Ke.prototype, "labelsVisible", void 0), r([m({ type: [C2], json: { origins: { service: { name: "drawingInfo.labelingInfo", read: n7, write: false }, "web-scene": { name: "layerDefinition.drawingInfo.labelingInfo", read: n7, write: { enabled: true, layerContainerTypes: a4 } } }, name: "layerDefinition.drawingInfo.labelingInfo", read: n7, write: true } })], Ke.prototype, "labelingInfo", void 0), r([m((() => {
  const e4 = a(b3);
  return e4.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(e5, t5, r3) {
    e(r3, n5(e5), t5);
  } } }, e4;
})())], Ke.prototype, "opacity", void 0), r([m(d5)], Ke.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"], json: (() => {
  const e4 = a(I3.json);
  return e4.origins["portal-item"] = { read: false, write: false }, e4;
})() })], Ke.prototype, "listMode", void 0), r([o("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], Ke.prototype, "readGlobalIdField", null), r([m({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: ze } } } } })], Ke.prototype, "objectIdField", void 0), r([o("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], Ke.prototype, "readObjectIdField", null), r([m({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], Ke.prototype, "operationalLayerType", void 0), r([m(ke.outFields)], Ke.prototype, "outFields", void 0), r([m({ readOnly: true })], Ke.prototype, "parsedUrl", null), r([m({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Ke.prototype, "path", void 0), r([m(l4)], Ke.prototype, "popupEnabled", void 0), r([m({ type: q, json: { name: "popupInfo", write: true } })], Ke.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], Ke.prototype, "defaultPopupTemplate", null), r([m({ types: m4, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: false } }, "web-scene": { types: u, name: "layerDefinition.drawingInfo.renderer", write: { layerContainerTypes: a4, overridePolicy: (e4, t5, r3) => ({ ignoreOrigin: r3 == null ? void 0 : r3.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e4, t5, r3) => ({ ignoreOrigin: r3 == null ? void 0 : r3.writeLayerSchema }) } } })], Ke.prototype, "renderer", null), r([o("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), o("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], Ke.prototype, "readRenderer", null), r([m()], Ke.prototype, "resourceInfo", void 0), r([m((() => {
  const e4 = a(s5);
  return e4.json.origins["portal-item"] = { read: false, write: false }, e4;
})())], Ke.prototype, "screenSizePerspectiveEnabled", void 0), r([m({ clonable: false })], Ke.prototype, "source", null), r([s3("source")], Ke.prototype, "castSource", null), r([o("portal-item", "source", ["featureSet"]), o("web-map", "source", ["featureSet"])], Ke.prototype, "readSource", null), r([m({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], Ke.prototype, "spatialReference", void 0), r([m({ type: Number })], Ke.prototype, "subtypeCode", void 0), r([m({ type: [p2] })], Ke.prototype, "templates", void 0), r([o("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], Ke.prototype, "readTemplates", null), r([m({ type: d4 })], Ke.prototype, "timeInfo", void 0), r([m()], Ke.prototype, "title", void 0), r([o("service", "title", ["name"]), o("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], Ke.prototype, "readTitle", null), r([o("web-map", "title", ["layerDefinition.name", "title"])], Ke.prototype, "readTitleFromWebMap", null), r([m({ type: String })], Ke.prototype, "sublayerTitleMode", void 0), r([m({ json: { read: false } })], Ke.prototype, "type", void 0), r([m({ type: String })], Ke.prototype, "typeIdField", void 0), r([o("service", "typeIdField"), o("typeIdField", ["layerDefinition.typeIdField"])], Ke.prototype, "readTypeIdField", null), r([m({ type: [n6] })], Ke.prototype, "types", void 0), r([o("service", "types", ["types"]), o("types", ["layerDefinition.types"])], Ke.prototype, "readTypes", null), r([m({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], Ke.prototype, "visible", void 0), r([o("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], Ke.prototype, "readVisible", null), Ke = r([a3("esri.layers.FeatureLayer")], Ke);
var Xe = Ke;

export {
  Xe
};
//# sourceMappingURL=chunk-NWZXTYBZ.js.map
