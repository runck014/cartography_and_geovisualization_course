import {
  t as t3
} from "./chunk-2JJO7SCG.js";
import {
  n2 as n3
} from "./chunk-KDQTUT24.js";
import {
  t as t2
} from "./chunk-7TPUFUXO.js";
import {
  t
} from "./chunk-2O2NCM6Y.js";
import {
  C2 as C,
  Ct,
  D2 as D,
  E2 as E,
  G2 as G,
  G3 as G2,
  Gt,
  H2 as H,
  I,
  In,
  J,
  Jn,
  K,
  O,
  P,
  Qn,
  S,
  Sn,
  Tt,
  Un,
  Ut,
  Vt,
  Yt,
  Zn,
  ee,
  g as g2,
  gt,
  h,
  hn,
  j as j2,
  j2 as j3,
  jn,
  jt,
  le,
  m as m2,
  ne,
  nn,
  re,
  tn,
  tt,
  v,
  w,
  xt,
  z,
  zn,
  zt
} from "./chunk-OXCT6NNS.js";
import {
  r as r6
} from "./chunk-NSVZKQ66.js";
import {
  _
} from "./chunk-BZVFVFOB.js";
import {
  $,
  Gt as Gt2,
  Rt,
  bt,
  kt,
  pt,
  rt
} from "./chunk-7RAZQP6S.js";
import {
  L as L2
} from "./chunk-F3ZOBTPK.js";
import {
  L,
  M,
  N
} from "./chunk-CGJUTDVJ.js";
import {
  n as n2
} from "./chunk-ECMDQ4LS.js";
import {
  o as o2,
  r as r4,
  u as u2
} from "./chunk-LP6TMAPE.js";
import {
  g,
  o as o3,
  r as r5
} from "./chunk-RENLZYKC.js";
import {
  m as m3
} from "./chunk-VGE7RXNF.js";
import {
  p
} from "./chunk-W6D3ECTZ.js";
import {
  c,
  f
} from "./chunk-YVSEBNS4.js";
import {
  n,
  r as r3
} from "./chunk-6Y2LNRVP.js";
import {
  o
} from "./chunk-DOTSJZHK.js";
import {
  r as r2
} from "./chunk-6YWQXXBX.js";
import {
  j2 as j
} from "./chunk-FG3XOAFD.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  e,
  r
} from "./chunk-MV5XBD6C.js";
import {
  u
} from "./chunk-R2PAF6JT.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/BitBlitPrograms.js
var e2 = { shaders: { vertexShader: n3("bitBlit/bitBlit.vert"), fragmentShader: n3("bitBlit/bitBlit.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0], ["a_tex", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/StencilPrograms.js
var r7 = { shaders: { vertexShader: n3("stencil/stencil.vert"), fragmentShader: n3("stencil/stencil.frag") }, attributes: /* @__PURE__ */ new Map([["a_pos", 0]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/BlendShader.js
var z2 = class extends I {
};
r([h(0, C)], z2.prototype, "position", void 0);
var A = class extends v {
};
var B = class extends P {
};
r([g2(S)], B.prototype, "layerTexture", void 0), r([g2(S)], B.prototype, "backbufferTexture", void 0), r([g2(j2)], B.prototype, "opacity", void 0), r([g2(j2)], B.prototype, "inFadeOpacity", void 0);
var D2 = class extends j3 {
  vertex(l3) {
    return { uv: l3.position, glPosition: new H(z(l3.position), 0, 1) };
  }
  fragment(l3) {
    const t7 = new w(), e4 = le(this.config.layerTexture, l3.uv), r13 = le(this.config.backbufferTexture, l3.uv), n6 = xt(Ut(e4.a, new j2(0)), e4.rgb, e4.rgb.divide(e4.a)), i2 = xt(Ut(r13.a, new j2(0)), r13.rgb, r13.rgb.divide(r13.a)), a5 = this.config.opacity.multiply(e4.a), o5 = r13.a;
    switch (this.blendMode) {
      case "destination-over":
        t7.glFragColor = new H(n6.multiply(a5).multiply(D(o5)).add(i2.multiply(o5)), a5.add(o5).subtract(a5.multiply(o5)));
        break;
      case "source-in":
        {
          const l4 = new H(n6.multiply(a5).multiply(o5), a5.multiply(o5)), e5 = new H(i2.multiply(o5), o5).multiply(D(this.config.opacity)).multiply(this.config.inFadeOpacity);
          t7.glFragColor = l4.add(e5);
        }
        break;
      case "destination-in":
        {
          const l4 = new H(i2.multiply(o5).multiply(a5), o5.multiply(a5)), e5 = new H(i2.multiply(o5), o5).multiply(new H(D(this.config.opacity).multiply(this.config.inFadeOpacity)));
          t7.glFragColor = l4.add(e5);
        }
        break;
      case "source-out":
        t7.glFragColor = new H(n6.multiply(a5).multiply(D(o5)), a5.multiply(D(o5)));
        break;
      case "destination-out":
        t7.glFragColor = new H(i2.multiply(o5).multiply(D(a5)), o5.multiply(D(a5)));
        break;
      case "source-atop":
        t7.glFragColor = new H(n6.multiply(a5).multiply(o5).add(i2.multiply(o5.multiply(D(a5)))), o5);
        break;
      case "destination-atop":
        t7.glFragColor = new H(n6.multiply(a5.multiply(D(o5))).add(i2.multiply(o5).multiply(a5)), a5);
        break;
      case "xor":
        t7.glFragColor = new H(n6.multiply(a5.multiply(D(o5))).add(i2.multiply(o5.multiply(D(a5)))), a5.multiply(D(o5)).add(o5.multiply(D(a5))));
        break;
      case "multiply":
        t7.glFragColor = new H(n6.multiply(a5).multiply(i2.multiply(o5)).add(n6.multiply(a5).multiply(D(o5))).add(i2.multiply(o5).multiply(D(a5))), a5.add(o5.multiply(D(a5))));
        break;
      case "screen":
        t7.glFragColor = new H(n6.add(i2).subtract(n6.multiply(i2)).multiply(a5.multiply(o5)).add(n6.multiply(a5).multiply(D(o5))).add(i2.multiply(o5).multiply(D(a5))), a5.add(o5.multiply(D(a5))));
        break;
      case "overlay":
        {
          const l4 = new G(H2(i2.r, n6.r), H2(i2.g, n6.g), H2(i2.b, n6.b));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "darken":
        {
          const l4 = Sn(n6, i2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "lighter":
        t7.glFragColor = new H(n6.multiply(a5).add(i2.multiply(o5)), a5.add(o5));
        break;
      case "lighten":
        {
          const l4 = Un(n6, i2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "color-dodge":
        {
          const l4 = tn(new G(I2(i2.r, n6.r), I2(i2.g, n6.g), I2(i2.b, n6.b)), new G(0), new G(1));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "color-burn":
        {
          const l4 = new G(J2(i2.r, n6.r), J2(i2.g, n6.g), J2(i2.b, n6.b));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "hard-light":
        {
          const l4 = new G(K2(i2.r, n6.r), K2(i2.g, n6.g), K2(i2.b, n6.b));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "soft-light":
        {
          const l4 = new G(L3(i2.r, n6.r), L3(i2.g, n6.g), L3(i2.b, n6.b));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "difference":
        {
          const l4 = Yt(i2.subtract(n6));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "exclusion":
        {
          const l4 = n6.add(i2).subtract(new j2(2).multiply(n6).multiply(i2));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "invert":
        t7.glFragColor = new H(new G(1).subtract(i2).multiply(a5).multiply(o5).add(i2.multiply(o5).multiply(D(a5))), o5);
        break;
      case "vivid-light":
        {
          const l4 = new G(tn(N2(i2.r, n6.r), new j2(0), new j2(1)), tn(N2(i2.g, n6.g), new j2(0), new j2(1)), tn(N2(i2.b, n6.b), new j2(0), new j2(1)));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "hue":
        {
          const l4 = Y(n6, i2, i2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "saturation":
        {
          const l4 = Y(i2, n6, i2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "color":
        {
          const l4 = X(n6, i2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "luminosity":
        {
          const l4 = X(i2, n6);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "plus":
        t7.glFragColor = tn(new H(e4.r.add(i2.r), e4.g.add(i2.g), e4.b.add(i2.b), a5.add(o5)), new H(0), new H(1));
        break;
      case "minus":
        t7.glFragColor = new H(tn(new G(i2.r.subtract(e4.r), i2.g.subtract(e4.g), i2.b.subtract(e4.b)), new G(0), new G(1)), o5.multiply(a5));
        break;
      case "average":
        {
          const l4 = i2.add(n6).divide(2);
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      case "reflect":
        {
          const l4 = tn(new G(Z(i2.r, n6.r), Z(i2.g, n6.g), Z(i2.b, n6.b)), new G(0), new G(1));
          t7.glFragColor = E2(l4, n6, i2, a5, o5);
        }
        break;
      default:
        t7.glFragColor = e4.multiply(this.config.opacity);
    }
    return t7;
  }
};
function E2(l3, t7, e4, r13, n6) {
  return new H(l3.multiply(r13).multiply(n6).add(t7.multiply(r13).multiply(D(n6))).add(e4.multiply(n6).multiply(D(r13))), r13.add(n6.multiply(D(r13))));
}
function H2(l3, t7) {
  return new j2(1).subtract(re(new j2(0.5), t7)).multiply(D(new j2(2).multiply(D(t7).multiply(D(l3))))).add(re(new j2(0.5), t7).multiply(new j2(2).multiply(t7).multiply(l3)));
}
function I2(l3, t7) {
  return xt(Ut(l3, new j2(0)), new j2(0), xt(Ut(t7, new j2(1)), new j2(1), Sn(new j2(1), l3.divide(new j2(1).subtract(t7)))));
}
function J2(l3, t7) {
  return xt(Ut(l3, new j2(1)), new j2(1), xt(Ut(t7, new j2(0)), new j2(0), D(Sn(new j2(1), D(l3).divide(t7)))));
}
function K2(l3, t7) {
  return new j2(1).subtract(re(new j2(0.5), t7)).multiply(new j2(2).multiply(t7).multiply(l3)).add(re(new j2(0.5), t7).multiply(D(new j2(2).multiply(D(t7).multiply(D(l3))))));
}
function L3(l3, t7) {
  return gt([Ct(t7, new j2(0.5)), () => {
    const e4 = new j2(2).multiply(t7), r13 = D(e4), n6 = D(l3);
    return l3.subtract(r13.multiply(l3).multiply(n6));
  }], [Ct(l3, new j2(0.25)), () => {
    const e4 = new j2(2).multiply(t7), r13 = E(e4).multiply(l3), n6 = new j2(16).multiply(l3).subtract(new j2(12)).multiply(l3).add(new j2(3));
    return l3.add(r13.multiply(n6));
  }], [true, () => {
    const e4 = new j2(2).multiply(t7), r13 = E(e4), n6 = ee(l3).subtract(l3);
    return l3.add(r13.multiply(n6));
  }]);
}
function N2(l3, t7) {
  const e4 = D(re(new j2(0.5), t7)).multiply(J2(l3, new j2(2).multiply(t7))), r13 = re(new j2(0.5), t7).multiply(I2(l3, new j2(2).multiply(G2(t7, 0.5))));
  return e4.add(r13);
}
function Q(l3) {
  return Sn(Sn(l3.r, l3.g), l3.b);
}
function R(l3) {
  return Un(Un(l3.r, l3.g), l3.b);
}
function U(l3) {
  return hn(l3, new G(0.3, 0.59, 0.11));
}
function V(l3) {
  return R(l3).subtract(Q(l3));
}
function W(l3) {
  const t7 = U(l3), e4 = Q(l3), r13 = R(l3);
  return gt([jt(e4, new j2(0)), () => {
    const r14 = l3.subtract(t7).multiply(t7), n6 = t7.subtract(e4);
    return t7.add(r14.divide(n6));
  }], [Gt(r13, new j2(1)), () => {
    const e5 = l3.subtract(t7), n6 = D(t7), i2 = e5.multiply(n6), a5 = r13.subtract(t7);
    return t7.add(i2.divide(a5));
  }], [true, l3]);
}
function X(l3, t7) {
  const e4 = U(l3), r13 = U(t7).subtract(e4);
  return W(l3.add(new G(r13)));
}
function Y(l3, t7, e4) {
  const r13 = Q(l3), n6 = V(l3), i2 = V(t7);
  return X(xt(Gt(n6, new j2(0)), () => l3.subtract(r13).multiply(i2).divide(n6), new G(0)), e4);
}
function Z(l3, t7) {
  return xt(Ut(t7, new j2(1)), t7, () => {
    const e4 = D(t7), r13 = l3.multiply(l3).divide(e4);
    return Sn(r13, new j2(1));
  });
}
r([K], D2.prototype, "blendMode", void 0), r([g2(B)], D2.prototype, "config", void 0), r([e(0, m2(z2))], D2.prototype, "vertex", null), r([e(0, m2(A))], D2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/OpacityShader.js
var m4 = class extends I {
};
r([h(0, C)], m4.prototype, "position", void 0);
var x = class extends v {
};
var f2 = class extends P {
};
r([g2(S)], f2.prototype, "layerTexture", void 0), r([g2(j2)], f2.prototype, "opacity", void 0);
var v2 = class extends j3 {
  vertex(t7) {
    return { uv: t7.position, glPosition: new H(t7.position.subtract(new C(0.5)).multiply(2), 0, 1) };
  }
  fragment(t7) {
    const o5 = new w();
    return o5.glFragColor = le(this.config.layerTexture, t7.uv).multiply(this.config.opacity), o5;
  }
};
r([g2(f2)], v2.prototype, "config", void 0), r([e(0, m2(m4))], v2.prototype, "vertex", null), r([e(0, m2(x))], v2.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaders/HighlightPrograms.js
var t4 = { shaders: { vertexShader: n3("highlight/textured.vert"), fragmentShader: n3("highlight/highlight.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };
var r8 = { shaders: { vertexShader: n3("highlight/textured.vert"), fragmentShader: n3("highlight/blur.frag") }, attributes: /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]) };

// node_modules/@arcgis/core/views/2d/engine/webgl/Profiler.js
var r9 = !!has("esri-2d-profiler");
var n4 = class {
  constructor(n6, i2) {
    if (this._events = new o(), this._entries = /* @__PURE__ */ new Map(), this._timings = new t2(10), this._currentContainer = null, this._currentPass = null, this._currentBrush = null, this._currentSummary = null, !r9) return;
    this._ext = t3(n6.gl, {}), this._debugOutput = i2;
    const o5 = n6.gl;
    if (!this.enableCommandLogging) return;
    let a5;
    for (a5 in o5) if ("function" == typeof o5[a5]) {
      const e4 = o5[a5], t7 = a5.includes("draw");
      o5[a5] = (...s3) => (this._events.emit("command", { container: this._currentContainer, pass: this._currentPass, brush: this._currentBrush, method: a5, args: s3, isDrawCommand: t7 }), this._currentSummary && (this._currentSummary.commands++, t7 && this._currentSummary.drawCommands++), e4.apply(o5, s3));
    }
  }
  get enableCommandLogging() {
    return !("object" == typeof r9 && r9.disableCommands);
  }
  recordContainerStart(e4) {
    r9 && (this._currentContainer = e4);
  }
  recordContainerEnd() {
    r9 && (this._currentContainer = null);
  }
  recordPassStart(e4) {
    r9 && (this._currentPass = e4, this._initSummary());
  }
  recordPassEnd() {
    r9 && (this._currentPass = null, this._emitSummary());
  }
  recordBrushStart(e4) {
    r9 && (this._currentBrush = e4);
  }
  recordBrushEnd() {
    r9 && (this._currentBrush = null);
  }
  recordStart(e4) {
    if (r9 && null != this._ext) {
      if (this._entries.has(e4)) {
        const t8 = this._entries.get(e4), s3 = this._ext.resultAvailable(t8.query), r13 = this._ext.disjoint();
        if (s3 && !r13) {
          const s4 = this._ext.getResult(t8.query) / 1e6;
          let r14 = 0;
          if (null != this._timings.enqueue(s4)) {
            const e5 = this._timings.entries, t9 = e5.length;
            let s5 = 0;
            for (const r15 of e5) s5 += r15;
            r14 = s5 / t9;
          }
          const n6 = s4.toFixed(2), i2 = r14 ? r14.toFixed(2) : "--";
          this.enableCommandLogging ? (console.groupCollapsed(`Frame report for ${e4}, ${n6} ms (${i2} last 10 avg)
${t8.commandsLen} Commands (${t8.drawCommands} draw)`), console.log("RenderPass breakdown: "), console.table(t8.summaries), console.log("Commands: ", t8.commands), console.groupEnd()) : console.log(`Frame report for ${e4}, ${n6} ms (${i2} last 10 avg)`), this._debugOutput.innerHTML = `${n6} (${i2})`;
        }
        for (const e5 of t8.handles) e5.remove();
        this._ext.deleteQuery(t8.query), this._entries.delete(e4);
      }
      const t7 = { name: e4, query: this._ext.createQuery(), commands: [], commandsLen: 0, drawCommands: 0, summaries: [], handles: [] };
      this.enableCommandLogging && (t7.handles.push(this._events.on("command", (e5) => {
        t7.commandsLen++, t7.commands.push(e5), e5.isDrawCommand && t7.drawCommands++;
      })), t7.handles.push(this._events.on("summary", (e5) => {
        t7.summaries.push(e5);
      }))), this._ext.beginTimeElapsed(t7.query), this._entries.set(e4, t7);
    }
  }
  recordEnd(e4) {
    r9 && null != this._ext && this._entries.has(e4) && this._ext.endTimeElapsed();
  }
  _initSummary() {
    this.enableCommandLogging && (this._currentSummary = { container: this._currentContainer, pass: this._currentPass, drawCommands: 0, commands: 0 });
  }
  _emitSummary() {
    this.enableCommandLogging && this._currentSummary && this._events.emit("summary", this._currentSummary);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionGrid.js
var i = 1;
var e3 = 0;
var h2 = 1;
var o4 = 2;
var r10 = class {
  constructor(t7, e4, h4) {
    this._width = t7 * h4, this._height = e4 * h4, this._pixelRatio = h4;
    const o5 = Math.ceil(this._width / i), r13 = Math.ceil(this._height / i);
    this._cols = o5, this._rows = r13, this._cells = t.create(o5 * r13);
  }
  insertMetrics(t7) {
    this._markMetrics(t7);
  }
  hasCollision(t7) {
    let s3 = 0;
    for (const { transformedX: i2, transformedY: e4, width: r13, height: l3 } of t7.bounds) {
      const t8 = r13 * this._pixelRatio, a5 = l3 * this._pixelRatio, c5 = i2 * this._pixelRatio, _4 = e4 * this._pixelRatio;
      switch (this._collide(c5, _4, t8, a5)) {
        case o4:
          return o4;
        case h2:
          s3++;
      }
    }
    return s3 === t7.bounds.length ? h2 : e3;
  }
  getCellId(t7, s3) {
    return t7 + s3 * this._cols;
  }
  has(t7) {
    return this._cells.has(t7);
  }
  hasRange(t7, s3) {
    return this._cells.hasRange(t7, s3);
  }
  set(t7) {
    this._cells.set(t7);
  }
  setRange(t7, s3) {
    this._cells.setRange(t7, s3);
  }
  _collide(s3, r13, l3, a5) {
    const c5 = s3 - l3 / 2, _4 = r13 - a5 / 2, n6 = c5 + l3, f6 = _4 + a5;
    if (n6 < 0 || f6 < 0 || c5 > this._width || _4 > this._height) return h2;
    const d7 = r2(Math.floor(c5 / i), 0, this._cols), u4 = r2(Math.floor(_4 / i), 0, this._rows), p2 = r2(Math.ceil(n6 / i), 0, this._cols), g5 = r2(Math.ceil(f6 / i), 0, this._rows);
    for (let t7 = u4; t7 <= g5; t7++) for (let s4 = d7; s4 <= p2; s4++) {
      const i2 = this.getCellId(s4, t7);
      if (this.has(i2)) return o4;
    }
    return e3;
  }
  _mark(s3, e4, h4, o5) {
    const r13 = s3 - h4 / 2, l3 = e4 - o5 / 2, a5 = r13 + h4, c5 = l3 + o5, _4 = r2(Math.floor(r13 / i), 0, this._cols), n6 = r2(Math.floor(l3 / i), 0, this._rows), f6 = r2(Math.ceil(a5 / i), 0, this._cols), d7 = r2(Math.ceil(c5 / i), 0, this._rows);
    for (let t7 = n6; t7 <= d7; t7++) for (let s4 = _4; s4 <= f6; s4++) {
      const i2 = this.getCellId(s4, t7);
      this.set(i2);
    }
    return false;
  }
  _markMetrics(t7) {
    for (const { transformedX: s3, transformedY: i2, width: e4, height: h4 } of t7.bounds) {
      const t8 = e4 * this._pixelRatio, o5 = h4 * this._pixelRatio, r13 = s3 * this._pixelRatio, l3 = i2 * this._pixelRatio;
      this._mark(r13, l3, t8, o5);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/collisions/CollisionEngine.js
var a2 = 254;
var c2 = 255;
var f3 = 0;
function d(e4, t7) {
  const o5 = e4.children.slice();
  o5.sort((e5, t8) => e5.tileAge - t8.tileAge), o5.forEach((e5) => {
    null != e5.labelMetrics && e5.isReady && t7(e5, e5.labelMetrics);
  });
}
function u3(e4, t7) {
  return (!e4.minScale || e4.minScale >= t7) && (!e4.maxScale || e4.maxScale <= t7);
}
var b2 = class {
  run(e4, t7, o5, n6) {
    var _a;
    const i2 = [];
    for (let s3 = e4.length - 1; s3 >= 0; s3--) {
      const t8 = e4[s3];
      ((_a = t8.labelingCollisionInfos) == null ? void 0 : _a.length) && i2.push(...t8.labelingCollisionInfos);
    }
    has("esri-2d-update-debug") && i2.length && console.debug("CollisionEngine.run"), this._transformMetrics(i2), this._runCollision(i2, t7, o5, n6);
    for (const s3 of i2) s3.container.requestRender();
  }
  _runCollision(e4, t7, o5, n6) {
    const [s3, l3] = t7.state.size, r13 = new r10(s3, l3, t7.pixelRatio);
    for (const { container: i2, deconflictionEnabled: b3, visible: m5 } of e4) {
      const e5 = i2.attributeView;
      b3 ? m5 ? (this._prepare(i2), this._collideVisible(r13, i2, o5, n6), this._collideInvisible(r13, i2)) : d(i2, (t8, o6) => {
        for (const n7 of o6) e5.setLabelMinZoom(n7.entityTexel, c2);
      }) : d(i2, (t8, n7) => {
        for (const i3 of n7) u3(i3, o5) ? (e5.setLabelMinZoom(i3.entityTexel, f3), m5 && r13.insertMetrics(i3)) : e5.setLabelMinZoom(i3.entityTexel, a2);
      });
    }
  }
  _isFiltered(o5, n6, i2) {
    const s3 = n6.getFilterFlags(o5), l3 = !i2.hasFilter || !!(s3 & M), r13 = null == i2.featureEffect || i2.featureEffect.excludedLabelsVisible || !!(s3 & N);
    return !(l3 && r13);
  }
  _prepare(e4) {
    const t7 = e4.attributeView, o5 = /* @__PURE__ */ new Set();
    d(e4, (n6, i2) => {
      for (const s3 of i2) {
        const n7 = s3.entityTexel;
        if (o5.has(n7)) continue;
        if (o5.add(n7), this._isFiltered(n7, t7, e4.layerView)) {
          t7.setLabelMinZoom(n7, a2);
          continue;
        }
        t7.getLabelMinZoom(n7) !== f3 ? t7.setLabelMinZoom(n7, c2) : t7.setLabelMinZoom(n7, f3);
      }
    });
  }
  _collideVisible(e4, t7, o5, n6) {
    const i2 = t7.attributeView, c5 = /* @__PURE__ */ new Set();
    d(t7, (t8, d7) => {
      for (let b3 = 0; b3 < d7.length; b3++) {
        const m5 = d7[b3].entityTexel;
        if (c5.has(m5)) continue;
        if (t8.key.level !== n6) {
          i2.setLabelMinZoom(m5, a2), c5.add(m5);
          continue;
        }
        if (!u3(d7[b3], o5)) {
          i2.setLabelMinZoom(m5, a2), c5.add(m5);
          continue;
        }
        if (0 !== i2.getLabelMinZoom(m5)) {
          c5.add(m5);
          continue;
        }
        let h4 = false, M3 = true;
        const g5 = b3;
        let y2 = b3;
        for (; y2 < d7.length; y2++) {
          const t9 = d7[y2];
          if (t9.entityTexel !== m5) break;
          if (h4) continue;
          switch (e4.hasCollision(t9)) {
            case h2:
              break;
            case o4:
              h4 = true, M3 = false;
              break;
            case e3:
              M3 = false;
          }
        }
        if (!h4) for (let t9 = g5; t9 < y2; t9++) e4.insertMetrics(d7[t9]);
        b3 = y2 - 1, M3 || (c5.add(m5), i2.setLabelMinZoom(m5, h4 ? a2 : f3));
      }
    });
  }
  _collideInvisible(e4, t7) {
    const o5 = t7.attributeView, n6 = /* @__PURE__ */ new Set();
    d(t7, (t8, i2) => {
      for (let a5 = 0; a5 < i2.length; a5++) {
        const t9 = i2[a5].entityTexel;
        if (n6.has(t9)) continue;
        if (o5.getLabelMinZoom(t9) !== c2) {
          n6.add(t9);
          continue;
        }
        let d7 = false, u4 = true;
        const b3 = a5;
        let m5 = a5;
        for (; m5 < i2.length; m5++) {
          const o6 = i2[m5];
          if (o6.entityTexel !== t9) break;
          if (d7) continue;
          switch (e4.hasCollision(o6)) {
            case h2:
              break;
            case o4:
              d7 = true, u4 = false;
              break;
            case e3:
              u4 = false;
          }
        }
        if (!d7) for (let o6 = b3; o6 < m5; o6++) e4.insertMetrics(i2[o6]);
        a5 = m5 - 1, u4 || (n6.add(t9), o5.setLabelMinZoom(t9, d7 ? c2 : f3));
      }
    });
  }
  _transformMetrics(e4) {
    for (const { container: t7, geometryType: i2, vvEvaluators: s3 } of e4) d(t7, (e5, l3) => {
      var _a;
      const r13 = t7.attributeView, a5 = e5.transforms.labelMat2d;
      a5[4] = Math.round(a5[4]), a5[5] = Math.round(a5[5]);
      const c5 = "polyline" === i2;
      for (const t8 of l3) {
        const { entityTexel: e6, anchorX: i3, anchorY: l4 } = t8;
        let f6 = ((_a = t8.referenceBounds) == null ? void 0 : _a.size) ?? 0;
        const d7 = s3[0];
        if (null != d7) {
          const t9 = d7(r13.getVisualVariableData(e6, L2.SIZE));
          f6 = isNaN(t9) || null == t9 || t9 === 1 / 0 ? f6 : t9;
        }
        const u4 = L + f6 / 2, b3 = t8.directionX * u4, m5 = t8.directionY * u4;
        for (const o5 of t8.bounds) {
          let e7 = i3, t9 = l4;
          if (c5) {
            const n6 = i3 + o5.x + b3, s4 = l4 + o5.y + m5;
            e7 = a5[0] * n6 + a5[2] * s4 + a5[4], t9 = a5[1] * n6 + a5[3] * s4 + a5[5];
            const r14 = e7, c6 = t9;
            o5.transformedX = Math.floor(r14), o5.transformedY = Math.floor(c6);
          } else {
            e7 = a5[0] * i3 + a5[2] * l4 + a5[4], t9 = a5[1] * i3 + a5[3] * l4 + a5[5];
            const n6 = e7 + o5.x + b3, s4 = t9 + o5.y + m5;
            o5.transformedX = n6, o5.transformedY = s4;
          }
        }
      }
    });
  }
};

// node_modules/@arcgis/core/views/2d/LabelManager.js
var r11 = 32;
var a3 = class extends b {
  constructor(e4) {
    super(e4), this._lastUpdate = 0, this.collisionEngine = new b2(), this.lastUpdateId = -1, this.updateRequested = false, this.view = null;
  }
  get updating() {
    return has("esri-2d-log-updating") && console.log(`Updating LabelManager ${this.updateRequested}:
-> updateRequested: ${this.updateRequested}`), this.updateRequested;
  }
  update(e4) {
    const t7 = performance.now();
    t7 - this._lastUpdate >= r11 ? (this._lastUpdate = t7, this.doUpdate(e4)) : this.requestUpdate();
  }
  viewChange() {
    this.requestUpdate();
  }
  requestUpdate() {
    var _a;
    this.updateRequested || (this.updateRequested = true, (_a = this.view) == null ? void 0 : _a.requestUpdate());
  }
  processUpdate(e4) {
    this.updateRequested && (this.updateRequested = false, this.update(e4));
  }
  doUpdate(e4) {
    const t7 = this.view;
    if (t7) try {
      const s3 = e4.state.scale, o5 = t7.featuresTilingScheme.getClosestInfoForScale(s3).level;
      this.collisionEngine.run(t7.allLayerViews.items, e4, s3, o5);
    } catch (s3) {
    }
  }
};
r([m()], a3.prototype, "updateRequested", void 0), r([m()], a3.prototype, "updating", null), r([m()], a3.prototype, "view", void 0), a3 = r([a("esri.views.2d.LabelManager")], a3);

// node_modules/@arcgis/core/views/2d/navigation/ZoomBox.js
var n5 = "esri-zoom-box";
var h3 = { container: `${n5}__container`, overlay: `${n5}__overlay`, background: `${n5}__overlay-background`, box: `${n5}__outline` };
var l = { zoom: "Shift", counter: "Control" };
var d2 = class extends b {
  constructor(t7) {
    super(t7), this._container = null, this._overlay = null, this._backgroundShape = null, this._boxShape = null, this._box = { x: 0, y: 0, width: 0, height: 0 }, this._rafId = null, this._redraw = this._redraw.bind(this);
  }
  destroy() {
    this.view = null;
  }
  set view(t7) {
    this.removeAllHandles(), this._destroyOverlay(), this._set("view", t7), t7 && this.addHandles([t7.on("drag", [l.zoom], (t8) => this._handleDrag(t8, 1), _.INTERNAL), t7.on("drag", [l.zoom, l.counter], (t8) => this._handleDrag(t8, -1), _.INTERNAL)]);
  }
  _start() {
    this._createContainer(), this._createOverlay(), this.navigation.begin();
  }
  _update(t7, e4, i2, r13) {
    this._box.x = t7, this._box.y = e4, this._box.width = i2, this._box.height = r13, this._rafId || (this._rafId = requestAnimationFrame(this._redraw));
  }
  _end(t7, e4, r13, o5, a5) {
    const n6 = this.view, h4 = n6.toMap(c(t7 + 0.5 * r13, e4 + 0.5 * o5));
    let l3 = Math.max(r13 / n6.width, o5 / n6.height);
    -1 === a5 && (l3 = 1 / l3), this._destroyOverlay(), this.navigation.end(), n6.goTo({ center: h4, scale: n6.scale * l3 }, { animationMode: "always", duration: r6() });
  }
  _updateBox(t7, e4, i2, r13) {
    const o5 = this._boxShape;
    o5.setAttributeNS(null, "x", "" + t7), o5.setAttributeNS(null, "y", "" + e4), o5.setAttributeNS(null, "width", "" + i2), o5.setAttributeNS(null, "height", "" + r13), o5.setAttributeNS(null, "class", h3.box);
  }
  _updateBackground(t7, e4, i2, r13) {
    this._backgroundShape.setAttributeNS(null, "d", this._toSVGPath(t7, e4, i2, r13, this.view.width, this.view.height));
  }
  _createContainer() {
    const t7 = document.createElement("div");
    t7.className = h3.container, this.view.root.appendChild(t7), this._container = t7;
  }
  _createOverlay() {
    const t7 = this.view.width, e4 = this.view.height, i2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i2.setAttributeNS(null, "d", "M 0 0 L " + t7 + " 0 L " + t7 + " " + e4 + " L 0 " + e4 + " Z"), i2.setAttributeNS(null, "class", h3.background);
    const r13 = document.createElementNS("http://www.w3.org/2000/svg", "rect"), o5 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o5.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink"), o5.setAttributeNS(null, "class", h3.overlay), o5.appendChild(i2), o5.appendChild(r13), this._container.appendChild(o5), this._backgroundShape = i2, this._boxShape = r13, this._overlay = o5;
  }
  _destroyOverlay() {
    this._container && this._container.parentNode && this._container.parentNode.removeChild(this._container), this._container = this._backgroundShape = this._boxShape = this._overlay = null;
  }
  _toSVGPath(t7, e4, i2, r13, o5, s3) {
    const a5 = t7 + i2, n6 = e4 + r13;
    return "M 0 0 L " + o5 + " 0 L " + o5 + " " + s3 + " L 0 " + s3 + " ZM " + t7 + " " + e4 + " L " + t7 + " " + n6 + " L " + a5 + " " + n6 + " L " + a5 + " " + e4 + " Z";
  }
  _handleDrag(t7, e4) {
    const i2 = t7.x, r13 = t7.y, o5 = t7.origin.x, s3 = t7.origin.y;
    let a5, n6, h4, l3;
    switch (i2 > o5 ? (a5 = o5, h4 = i2 - o5) : (a5 = i2, h4 = o5 - i2), r13 > s3 ? (n6 = s3, l3 = r13 - s3) : (n6 = r13, l3 = s3 - r13), t7.action) {
      case "start":
        this._start();
        break;
      case "update":
        this._update(a5, n6, h4, l3);
        break;
      case "end":
        this._end(a5, n6, h4, l3, e4);
    }
    t7.stopPropagation();
  }
  _redraw() {
    if (!this._rafId) return;
    if (this._rafId = null, !this._overlay) return;
    const { x: t7, y: e4, width: i2, height: r13 } = this._box;
    this._updateBox(t7, e4, i2, r13), this._updateBackground(t7, e4, i2, r13), this._rafId = requestAnimationFrame(this._redraw);
  }
};
r([m()], d2.prototype, "navigation", void 0), r([m()], d2.prototype, "view", null), d2 = r([a("esri.views.2d.navigation.ZoomBox")], d2);
var c3 = d2;

// node_modules/@arcgis/core/views/navigation/FilteredFiniteDifference.js
var t5 = class {
  constructor(t7) {
    this._gain = t7, this.lastValue = void 0, this.filteredDelta = void 0;
  }
  update(t7) {
    if (this.hasLastValue()) {
      const e4 = this.computeDelta(t7);
      this._updateDelta(e4);
    }
    this.lastValue = t7;
  }
  reset() {
    this.lastValue = void 0, this.filteredDelta = void 0;
  }
  hasLastValue() {
    return void 0 !== this.lastValue;
  }
  hasFilteredDelta() {
    return void 0 !== this.filteredDelta;
  }
  computeDelta(t7) {
    return void 0 === this.lastValue ? NaN : t7 - this.lastValue;
  }
  _updateDelta(t7) {
    void 0 !== this.filteredDelta ? this.filteredDelta = (1 - this._gain) * this.filteredDelta + this._gain * t7 : this.filteredDelta = t7;
  }
};

// node_modules/@arcgis/core/views/navigation/Momentum.js
var t6 = class {
  constructor(t7, i2, o5) {
    this._initialVelocity = t7, this._stopVelocity = i2, this._friction = o5, this._duration = Math.abs(Math.log(Math.abs(this._initialVelocity) / this._stopVelocity) / Math.log(1 - this._friction));
  }
  get duration() {
    return this._duration;
  }
  isFinished(t7) {
    return t7 > this.duration;
  }
  get friction() {
    return this._friction;
  }
  value(t7) {
    return this.valueFromInitialVelocity(this._initialVelocity, t7);
  }
  valueDelta(t7, i2) {
    const o5 = this.value(t7);
    return this.value(t7 + i2) - o5;
  }
  valueFromInitialVelocity(t7, i2) {
    i2 = Math.min(i2, this.duration);
    const o5 = 1 - this.friction;
    return t7 * (o5 ** i2 - 1) / Math.log(o5);
  }
};

// node_modules/@arcgis/core/views/navigation/PanPlanarMomentumEstimator.js
var l2 = class extends t6 {
  constructor(e4, t7, i2, s3, n6) {
    super(e4, t7, i2), this._sceneVelocity = s3, this.direction = n6;
  }
  value(e4) {
    return super.valueFromInitialVelocity(this._sceneVelocity, e4);
  }
};
var c4 = class {
  constructor(e4 = 300, t7 = 12, i2 = 0.84) {
    this._minimumInitialVelocity = e4, this._stopVelocity = t7, this._friction = i2, this.enabled = true, this._time = new t5(0.6), this._screen = [new t5(0.4), new t5(0.4)], this._scene = [new t5(0.6), new t5(0.6), new t5(0.6)], this._tmpDirection = n();
  }
  add(e4, t7, i2) {
    if (this.enabled) {
      if (this._time.hasLastValue()) {
        if (this._time.computeDelta(i2) < 0.015) return;
      }
      this._screen[0].update(e4[0]), this._screen[1].update(e4[1]), this._scene[0].update(t7[0]), this._scene[1].update(t7[1]), this._scene[2].update(t7[2]), this._time.update(i2);
    }
  }
  reset() {
    this._screen[0].reset(), this._screen[1].reset(), this._scene[0].reset(), this._scene[1].reset(), this._scene[2].reset(), this._time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this._screen[0].hasFilteredDelta() || !this._time.hasFilteredDelta()) return null;
    const e4 = this._screen[0].filteredDelta, t7 = this._screen[1].filteredDelta, i2 = null == e4 || null == t7 ? 0 : Math.sqrt(e4 * e4 + t7 * t7), s3 = this._time.filteredDelta, n6 = null == s3 || null == i2 ? 0 : i2 / s3;
    return Math.abs(n6) < this._minimumInitialVelocity ? null : this.createMomentum(n6, this._stopVelocity, this._friction);
  }
  createMomentum(s3, n6, r13) {
    o3(this._tmpDirection, this._scene[0].filteredDelta ?? 0, this._scene[1].filteredDelta ?? 0, this._scene[2].filteredDelta ?? 0);
    const c5 = r5(this._tmpDirection);
    c5 > 0 && g(this._tmpDirection, this._tmpDirection, 1 / c5);
    const h4 = this._time.filteredDelta;
    return new l2(s3, n6, r13, null == h4 ? 0 : c5 / h4, this._tmpDirection);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pan.js
var v3 = class extends b {
  constructor(t7) {
    super(t7), this.animationTime = 0, this.momentumEstimator = new c4(500, 6, 0.92), this.momentum = null, this.tmpMomentum = n(), this.momentumFinished = false, this.viewpoint = new m3({ targetGeometry: new j(), scale: 0, rotation: 0 }), this._previousDrag = null, p(() => this.momentumFinished, () => this.navigation.stop());
  }
  begin(t7, i2) {
    this.navigation.begin(), this.momentumEstimator.reset(), this.addToEstimator(i2), this._previousDrag = i2;
  }
  update(t7, i2) {
    this.addToEstimator(i2);
    let o5 = i2.center.x, e4 = i2.center.y;
    const s3 = this._previousDrag;
    o5 = s3 ? s3.center.x - o5 : -o5, e4 = s3 ? e4 - s3.center.y : e4, t7.viewpoint = kt(this.viewpoint, t7.viewpoint, [o5 || 0, e4 || 0]), this._previousDrag = i2;
  }
  end(t7, i2) {
    this.addToEstimator(i2);
    const o5 = t7.navigation.effectiveMomentumEnabled;
    this.momentum = o5 ? this.momentumEstimator.evaluateMomentum() : null, this.animationTime = 0, this.momentum && this.onAnimationUpdate(t7), this._previousDrag = null, this.navigation.end();
  }
  addToEstimator(t7) {
    const i2 = t7.center.x, o5 = t7.center.y, e4 = f(-i2, o5), m5 = r3(-i2, o5, 0);
    this.momentumEstimator.add(e4, m5, 1e-3 * t7.timestamp);
  }
  onAnimationUpdate(t7) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinuous(t7.viewpoint, (i2, o5) => {
      const { momentum: e4, animationTime: s3, tmpMomentum: m5 } = this, n6 = 1e-3 * o5;
      if (!(this.momentumFinished = !e4 || e4.isFinished(s3))) {
        const o6 = e4.valueDelta(s3, n6);
        g(m5, e4.direction, o6), kt(i2, i2, m5), t7.constraints.constrainByGeometry(i2);
      }
      this.animationTime += n6;
    });
  }
  stopMomentumNavigation() {
    this.momentum && (this.momentumEstimator.reset(), this.momentum = null, this.navigation.stop());
  }
};
r([m()], v3.prototype, "momentumFinished", void 0), r([m()], v3.prototype, "viewpoint", void 0), r([m()], v3.prototype, "navigation", void 0), v3 = r([a("esri.views.2d.navigation.actions.Pan")], v3);
var d3 = v3;

// node_modules/@arcgis/core/views/navigation/MomentumEstimator.js
var s = class {
  constructor(t7 = 2.5, i2 = 0.01, s3 = 0.95, l3 = 12) {
    this._minimumInitialVelocity = t7, this._stopVelocity = i2, this._friction = s3, this._maxVelocity = l3, this.enabled = true, this.value = new t5(0.8), this.time = new t5(0.3);
  }
  add(t7, e4) {
    if (this.enabled && null != e4) {
      if (this.time.hasLastValue()) {
        if (this.time.computeDelta(e4) < 0.01) return;
        if (this.value.hasFilteredDelta()) {
          const e5 = this.value.computeDelta(t7);
          this.value.filteredDelta * e5 < 0 && this.value.reset();
        }
      }
      this.time.update(e4), this.value.update(t7);
    }
  }
  reset() {
    this.value.reset(), this.time.reset();
  }
  evaluateMomentum() {
    if (!this.enabled || !this.value.hasFilteredDelta() || !this.time.hasFilteredDelta()) return null;
    let e4 = this.value.filteredDelta / this.time.filteredDelta;
    return e4 = r2(e4, -this._maxVelocity, this._maxVelocity), Math.abs(e4) < this._minimumInitialVelocity ? null : this.createMomentum(e4, this._stopVelocity, this._friction);
  }
  createMomentum(t7, e4, s3) {
    return new t6(t7, e4, s3);
  }
};

// node_modules/@arcgis/core/views/navigation/RotationMomentumEstimator.js
var a4 = class extends s {
  constructor(t7 = 3, a5 = 0.01, s3 = 0.95, o5 = 12) {
    super(t7, a5, s3, o5);
  }
  add(t7, a5) {
    const s3 = this.value.lastValue;
    if (null != s3) {
      let a6 = t7 - s3;
      for (; a6 > Math.PI; ) a6 -= 2 * Math.PI;
      for (; a6 < -Math.PI; ) a6 += 2 * Math.PI;
      t7 = s3 + a6;
    }
    super.add(t7, a5);
  }
};

// node_modules/@arcgis/core/views/navigation/ZoomMomentumEstimator.js
var r12 = class extends t6 {
  constructor(e4, t7, r13) {
    super(e4, t7, r13);
  }
  value(e4) {
    const t7 = super.value(e4);
    return Math.exp(t7);
  }
  valueDelta(e4, t7) {
    const r13 = super.value(e4), s3 = super.value(e4 + t7) - r13;
    return Math.exp(s3);
  }
};
var s2 = class extends s {
  constructor(e4 = 2.5, t7 = 0.01, r13 = 0.95, s3 = 12) {
    super(e4, t7, r13, s3);
  }
  add(e4, t7) {
    super.add(Math.log(e4), t7);
  }
  createMomentum(e4, t7, s3) {
    return new r12(e4, t7, s3);
  }
};

// node_modules/@arcgis/core/views/2d/navigation/actions/Pinch.js
var _2 = class extends b {
  constructor(t7) {
    super(t7), this._animationTime = 0, this._momentumFinished = false, this._previousAngle = 0, this._previousRadius = 0, this._previousCenter = null, this._rotationMomentumEstimator = new a4(0.6, 0.15, 0.95), this._rotationDirection = 1, this._startAngle = 0, this._startRadius = 0, this._updateTimestamp = null, this._zoomDirection = 1, this._zoomMomentumEstimator = new s2(), this._zoomOnly = null, this.viewpoint = new m3({ targetGeometry: new j(), scale: 0, rotation: 0 }), this.zoomMomentum = null, this.rotateMomentum = null, this.addHandles(p(() => this._momentumFinished, () => this.navigation.stop()));
  }
  begin(t7, o5) {
    this.navigation.begin(), this._rotationMomentumEstimator.reset(), this._zoomMomentumEstimator.reset(), this._zoomOnly = null, this._previousAngle = this._startAngle = o5.angle, this._previousRadius = this._startRadius = o5.radius, this._previousCenter = o5.center, this._updateTimestamp = null, t7.constraints.rotationEnabled && this.addToRotateEstimator(0, o5.timestamp), this.addToZoomEstimator(o5, 1);
  }
  update(t7, o5) {
    null === this._updateTimestamp && (this._updateTimestamp = o5.timestamp);
    const i2 = o5.angle, s3 = o5.radius, e4 = o5.center, n6 = Math.abs(180 * (i2 - this._startAngle) / Math.PI), m5 = Math.abs(s3 - this._startRadius), a5 = this._startRadius / s3;
    if (this._previousRadius && this._previousCenter) {
      const r13 = s3 / this._previousRadius;
      let h4 = 180 * (i2 - this._previousAngle) / Math.PI;
      this._rotationDirection = h4 >= 0 ? 1 : -1, this._zoomDirection = r13 >= 1 ? 1 : -1, t7.constraints.rotationEnabled ? (null === this._zoomOnly && o5.timestamp - this._updateTimestamp > 200 && (this._zoomOnly = m5 - n6 > 0), null === this._zoomOnly || this._zoomOnly ? h4 = 0 : this.addToRotateEstimator(i2 - this._startAngle, o5.timestamp)) : h4 = 0, this.addToZoomEstimator(o5, a5), this.navigation.setViewpoint([e4.x, e4.y], 1 / r13, h4, [this._previousCenter.x - e4.x, e4.y - this._previousCenter.y]);
    }
    this._previousAngle = i2, this._previousRadius = s3, this._previousCenter = e4;
  }
  end(t7) {
    this.rotateMomentum = this._rotationMomentumEstimator.evaluateMomentum(), this.zoomMomentum = this._zoomMomentumEstimator.evaluateMomentum(), this._animationTime = 0, (this.rotateMomentum || this.zoomMomentum) && this.onAnimationUpdate(t7), this.navigation.end();
  }
  addToRotateEstimator(t7, o5) {
    this._rotationMomentumEstimator.add(t7, 1e-3 * o5);
  }
  addToZoomEstimator(t7, o5) {
    this._zoomMomentumEstimator.add(o5, 1e-3 * t7.timestamp);
  }
  canZoomIn(t7) {
    const o5 = t7.scale, i2 = t7.constraints.effectiveMaxScale;
    return 0 === i2 || o5 > i2;
  }
  canZoomOut(t7) {
    const o5 = t7.scale, i2 = t7.constraints.effectiveMinScale;
    return 0 === i2 || o5 < i2;
  }
  onAnimationUpdate(t7) {
    var _a;
    (_a = this.navigation.animationManager) == null ? void 0 : _a.animateContinuous(t7.viewpoint, (o5, i2) => {
      const s3 = !this.canZoomIn(t7) && this._zoomDirection > 1 || !this.canZoomOut(t7) && this._zoomDirection < 1, e4 = !this.rotateMomentum || this.rotateMomentum.isFinished(this._animationTime), n6 = s3 || !this.zoomMomentum || this.zoomMomentum.isFinished(this._animationTime), h4 = 1e-3 * i2;
      if (this._momentumFinished = e4 && n6, !this._momentumFinished) {
        const i3 = this.rotateMomentum ? Math.abs(this.rotateMomentum.valueDelta(this._animationTime, h4)) * this._rotationDirection * 180 / Math.PI : 0;
        let s4 = this.zoomMomentum ? Math.abs(this.zoomMomentum.valueDelta(this._animationTime, h4)) : 1;
        const e5 = n2(), n7 = n2();
        if (this._previousCenter) {
          o2(e5, this._previousCenter.x, this._previousCenter.y), rt(n7, t7.size, t7.padding), u2(e5, e5, n7);
          const { constraints: r13, scale: h5 } = t7, p2 = h5 * s4;
          s4 < 1 && !r13.canZoomInTo(p2) ? (s4 = h5 / r13.effectiveMaxScale, this.zoomMomentum = null, this.rotateMomentum = null) : s4 > 1 && !r13.canZoomOutTo(p2) && (s4 = h5 / r13.effectiveMinScale, this.zoomMomentum = null, this.rotateMomentum = null), Gt2(o5, t7.viewpoint, s4, i3, e5, t7.size), t7.constraints.constrainByGeometry(o5);
        }
      }
      this._animationTime += h4;
    });
  }
  stopMomentumNavigation() {
    (this.rotateMomentum || this.zoomMomentum) && (this.rotateMomentum && (this._rotationMomentumEstimator.reset(), this.rotateMomentum = null), this.zoomMomentum && (this._zoomMomentumEstimator.reset(), this.zoomMomentum = null), this.navigation.stop());
  }
};
r([m()], _2.prototype, "_momentumFinished", void 0), r([m()], _2.prototype, "viewpoint", void 0), r([m()], _2.prototype, "navigation", void 0), _2 = r([a("esri.views.2d.navigation.actions.Pinch")], _2);
var d4 = _2;

// node_modules/@arcgis/core/views/2d/navigation/actions/Rotate.js
var d5 = n2();
var g3 = n2();
var j4 = class extends b {
  constructor(t7) {
    super(t7), this._previousCenter = n2(), this.viewpoint = new m3({ targetGeometry: new j(), scale: 0, rotation: 0 });
  }
  begin(t7, e4) {
    this.navigation.begin(), o2(this._previousCenter, e4.center.x, e4.center.y);
  }
  update(t7, e4) {
    const { state: { size: o5, padding: r13 } } = t7;
    o2(d5, e4.center.x, e4.center.y), $(g3, o5, r13), t7.viewpoint = bt(this.viewpoint, t7.state.paddedViewState.viewpoint, pt(g3, this._previousCenter, d5)), r4(this._previousCenter, d5);
  }
  end() {
    this.navigation.end();
  }
};
r([m()], j4.prototype, "viewpoint", void 0), r([m()], j4.prototype, "navigation", void 0), j4 = r([a("esri.views.2d.navigation.actions.Rotate")], j4);
var f4 = j4;

// node_modules/@arcgis/core/views/2d/navigation/MapViewNavigation.js
var v4 = 10;
var g4 = 1;
var d6 = new m3({ targetGeometry: new j() });
var _3 = [0, 0];
var T = 250;
var f5 = class extends b {
  constructor(t7) {
    super(t7), this._endTimer = null, this._lastEventTimestamp = null, this.animationManager = null, this.interacting = false;
  }
  initialize() {
    this.pan = new d3({ navigation: this }), this.rotate = new f4({ navigation: this }), this.pinch = new d4({ navigation: this }), this.zoomBox = new c3({ view: this.view, navigation: this });
  }
  destroy() {
    this.pan = u(this.pan), this.rotate = u(this.rotate), this.pinch = u(this.pinch), this.zoomBox = u(this.zoomBox), this.animationManager = null;
  }
  begin() {
    this.stop(), this._set("interacting", true);
  }
  end() {
    this._lastEventTimestamp = performance.now(), this._startTimer(T);
  }
  async zoom(t7, i2 = this._getDefaultAnchor()) {
    if (this.begin(), this.view.constraints.snapToZoom && this.view.constraints.effectiveLODs) return t7 < 1 ? this.zoomIn(i2) : this.zoomOut(i2);
    this.setViewpoint(i2, t7, 0, [0, 0]);
  }
  async zoomIn(t7) {
    const i2 = this.view, o5 = i2.constraints.snapToNextScale(i2.scale);
    return this._zoomToScale(o5, t7);
  }
  async zoomOut(t7) {
    const i2 = this.view, o5 = i2.constraints.snapToPreviousScale(i2.scale);
    return this._zoomToScale(o5, t7);
  }
  setViewpoint(t7, i2, o5, n6) {
    this.begin(), this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, t7, i2, o5, n6), this.end();
  }
  setViewpointImmediate(t7, i2 = 0, o5 = [0, 0], n6 = this._getDefaultAnchor()) {
    this.view.stateManager.state.viewpoint = this._scaleRotateTranslateViewpoint(this.view.viewpoint, n6, t7, i2, o5);
  }
  continuousRotateClockwise() {
    var _a;
    const t7 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(t7, (t8) => {
      bt(t8, t8, -g4);
    });
  }
  continuousRotateCounterclockwise() {
    var _a;
    const t7 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(t7, (t8) => {
      bt(t8, t8, g4);
    });
  }
  resetRotation() {
    this.view.constraints.rotationEnabled && (this.view.rotation = 0);
  }
  continuousPanLeft() {
    this._continuousPan([-v4, 0]);
  }
  continuousPanRight() {
    this._continuousPan([v4, 0]);
  }
  continuousPanUp() {
    this._continuousPan([0, v4]);
  }
  continuousPanDown() {
    this._continuousPan([0, -v4]);
  }
  continuousPanVector({ x: t7, y: i2 }) {
    this._continuousPan([t7 * v4, i2 * v4]);
  }
  stop() {
    var _a;
    this.pan.stopMomentumNavigation(), (_a = this.animationManager) == null ? void 0 : _a.stop(), this.end(), null !== this._endTimer && (clearTimeout(this._endTimer), this._endTimer = null, this._set("interacting", false));
  }
  _continuousPan(t7) {
    var _a;
    const i2 = this.view.viewpoint;
    (_a = this.animationManager) == null ? void 0 : _a.animateContinuous(i2, (i3) => {
      kt(i3, i3, t7), this.view.constraints.constrainByGeometry(i3);
    });
  }
  _startTimer(t7) {
    return null !== this._endTimer || (this._endTimer = setTimeout(() => {
      this._endTimer = null;
      const t8 = performance.now() - (this._lastEventTimestamp ?? 0);
      t8 < T ? this._endTimer = this._startTimer(t8) : this._set("interacting", false);
    }, t7)), this._endTimer;
  }
  _getDefaultAnchor() {
    const { size: t7, padding: { left: i2, right: o5, top: n6, bottom: e4 } } = this.view;
    return _3[0] = 0.5 * (t7[0] - o5 + i2), _3[1] = 0.5 * (t7[1] - e4 + n6), _3;
  }
  async _zoomToScale(t7, i2 = this._getDefaultAnchor()) {
    const { view: o5 } = this, { constraints: n6, scale: e4, viewpoint: s3, size: a5, padding: r13 } = o5, c5 = n6.canZoomInTo(t7), p2 = n6.canZoomOutTo(t7);
    if (!(t7 < e4 && !c5 || t7 > e4 && !p2)) return Rt(d6, s3, t7 / e4, 0, i2, a5, r13), n6.constrainByGeometry(d6), o5.goTo(d6, { animate: true, animationMode: "always", duration: r6(), pickClosestTarget: false });
  }
  _scaleRotateTranslateViewpoint(t7, i2, o5, n6, e4) {
    const { view: s3 } = this, { size: a5, padding: r13, constraints: h4, scale: p2, viewpoint: u4 } = s3, l3 = p2 * o5, w2 = h4.canZoomInTo(l3), v5 = h4.canZoomOutTo(l3);
    return (o5 < 1 && !w2 || o5 > 1 && !v5) && (o5 = 1), kt(u4, u4, e4), Rt(t7, u4, o5, n6, i2, a5, r13), h4.constrainByGeometry(t7);
  }
};
r([m()], f5.prototype, "animationManager", void 0), r([m({ type: Boolean, readOnly: true })], f5.prototype, "interacting", void 0), r([m()], f5.prototype, "pan", void 0), r([m()], f5.prototype, "pinch", void 0), r([m()], f5.prototype, "rotate", void 0), r([m()], f5.prototype, "view", void 0), r([m()], f5.prototype, "zoomBox", void 0), f5 = r([a("esri.views.2d.navigation.MapViewNavigation")], f5);
var y = f5;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/MagnifierShader.js
var T2 = class extends I {
};
r([h(0, C)], T2.prototype, "position", void 0);
var C2 = class extends v {
};
var j5 = class extends P {
};
r([g2(S)], j5.prototype, "readbackTexture", void 0), r([g2(S)], j5.prototype, "maskTexture", void 0), r([g2(S)], j5.prototype, "overlayTexture", void 0), r([g2(H)], j5.prototype, "background", void 0), r([g2(H)], j5.prototype, "drawPos", void 0), r([g2(j2)], j5.prototype, "maskEnabled", void 0), r([g2(j2)], j5.prototype, "overlayEnabled", void 0);
var E3 = class extends j3 {
  vertex(t7) {
    const o5 = t7.position, e4 = t7.position.subtract(new C(0.5)).multiply(this.config.drawPos.zw), r13 = this.config.drawPos.xy.add(e4);
    return { glPosition: new H(r13, 0, 1), texCoord: o5 };
  }
  fragment(t7) {
    let o5 = le(this.config.readbackTexture, P2(t7.texCoord));
    o5 = o5.add(new j2(1).subtract(o5.a)).multiply(this.config.background);
    const e4 = xt(Ut(this.config.maskEnabled, new j2(1)), le(this.config.maskTexture, t7.texCoord).a, new j2(1));
    o5 = o5.multiply(e4);
    const r13 = xt(Ut(this.config.overlayEnabled, new j2(1)), le(this.config.overlayTexture, t7.texCoord), new H(0)), n6 = new w();
    return n6.glFragColor = r13.add(new j2(1).subtract(r13.a).multiply(o5)), n6;
  }
};
function P2(t7) {
  const o5 = t7.multiply(new C(2)).subtract(1);
  return xt(Ut(o5.x, new j2(0)).and(Ut(o5.y, new j2(0))), new C(0.5), () => {
    const t8 = Vt(o5.y, o5.x), e4 = Jn(zn(o5), new j2(J)), r13 = new C(nn(t8), Zn(t8));
    return e4.multiply(r13).multiply(new C(0.5)).add(new j2(0.5));
  });
}
r([g2(j5)], E3.prototype, "config", void 0), r([e(0, m2(T2))], E3.prototype, "vertex", null), r([e(0, m2(C2))], E3.prototype, "fragment", null);

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/shaders/GridShader.js
var k = class extends I {
};
r([h(0, C)], k.prototype, "position", void 0);
var F = class extends v {
};
var G3 = class extends P {
};
r([g2(tt)], G3.prototype, "dvs", void 0);
var M2 = class extends P {
};
r([g2(j2)], M2.prototype, "halfWidth", void 0), r([g2(j2)], M2.prototype, "aaWidth", void 0), r([g2(j2)], M2.prototype, "pxPerCell", void 0), r([g2(H)], M2.prototype, "minorLineColor", void 0), r([g2(H)], M2.prototype, "majorLineColor", void 0), r([g2(O)], M2.prototype, "majorLineInterval", void 0);
var S2 = class extends j3 {
  vertex(o5) {
    const t7 = o5.position.multiply(2).subtract(1);
    return { gridPos: this.transform.dvs.multiply(new G(t7, 1)).xy, glPosition: new H(t7, 0, 1) };
  }
  fragment(o5) {
    const t7 = Yt(o5.gridPos), e4 = In(t7), i2 = Sn(e4.x, new j2(1).subtract(e4.x)), r13 = Sn(e4.y, new j2(1).subtract(e4.y)), n6 = new C(i2, r13).multiply(this.config.pxPerCell).subtract(this.config.halfWidth), s3 = Sn(n6.x, n6.y), p2 = new j2(1).subtract(ne(new j2(0), this.config.aaWidth, s3)), l3 = new O(Qn(t7.x)), d7 = new O(Qn(t7.y)), c5 = new j2(zt(l3, this.config.majorLineInterval)), I3 = new j2(zt(d7, this.config.majorLineInterval)), k2 = xt(jt(n6.x, n6.y), c5, I3), F2 = Gt(Tt(re(n6.x, this.config.aaWidth), re(n6.y, this.config.aaWidth)), new j2(0.5)), G4 = Sn(c5, I3), M3 = xt(F2, G4, k2), S3 = jn(this.config.majorLineColor, this.config.minorLineColor, Sn(M3, new j2(1))), _4 = new w();
    return _4.glFragColor = S3.multiply(p2), _4;
  }
};
r([g2(G3)], S2.prototype, "transform", void 0), r([g2(M2)], S2.prototype, "config", void 0), r([e(0, m2(k))], S2.prototype, "vertex", null), r([e(0, m2(F))], S2.prototype, "fragment", null);

export {
  e2 as e,
  r7 as r,
  D2 as D,
  v2 as v,
  t4 as t,
  r8 as r2,
  n4 as n,
  a3 as a,
  y,
  E3 as E,
  S2 as S
};
//# sourceMappingURL=chunk-UCJNTTSW.js.map
