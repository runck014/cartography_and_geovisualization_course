import {
  f3 as f2,
  k,
  n2 as n6,
  s as s4
} from "./chunk-OXCT6NNS.js";
import {
  d as d2,
  j as j3,
  s as s3,
  t as t2
} from "./chunk-Q3K5MAUZ.js";
import {
  a as a2,
  l as l3
} from "./chunk-5VEO4IUH.js";
import {
  P,
  n as n5,
  t
} from "./chunk-EVK6ZSVY.js";
import {
  j2
} from "./chunk-YEDSTDY4.js";
import {
  pt,
  rt
} from "./chunk-OMMWWGIU.js";
import {
  e as e2
} from "./chunk-CH3XVKUV.js";
import {
  s as s2
} from "./chunk-KI5F6KDS.js";
import {
  m,
  n as n3,
  n2 as n4
} from "./chunk-BN24XFSK.js";
import {
  p
} from "./chunk-QYSQ6XPQ.js";
import {
  d
} from "./chunk-NXGNMEHZ.js";
import {
  Z
} from "./chunk-RXJCBLN2.js";
import {
  J,
  K,
  qi
} from "./chunk-CGJUTDVJ.js";
import {
  U
} from "./chunk-KV3S4QI2.js";
import {
  b
} from "./chunk-F3NUC2RS.js";
import {
  D
} from "./chunk-K5RYAJV4.js";
import {
  ge,
  m as m2,
  o as o2,
  pe
} from "./chunk-BWTCR2DR.js";
import {
  e
} from "./chunk-SMOTPOZ7.js";
import {
  f
} from "./chunk-3L2AYCZY.js";
import {
  a
} from "./chunk-VUJERGGB.js";
import {
  u
} from "./chunk-ZCHZRNUG.js";
import {
  l as l2
} from "./chunk-JVEZN6WF.js";
import {
  E,
  j
} from "./chunk-NHJGPXZH.js";
import {
  o,
  r
} from "./chunk-JS7R723S.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  n as n2
} from "./chunk-R2PAF6JT.js";
import {
  l2 as l,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/util/Writer.js
var t3 = 1.25;
var r2 = class {
  get length() {
    return this._pos;
  }
  constructor(t8, r7) {
    this._pos = 0;
    const e4 = r7 ? this._roundToNearest(r7, t8.BYTES_PER_ELEMENT) : 40;
    this._array = new ArrayBuffer(e4), this._buffer = new t8(this._array), this._ctor = t8, this._i16View = new Int16Array(this._array);
  }
  _roundToNearest(t8, r7) {
    const e4 = Math.round(t8);
    return 1 === r7 ? e4 : e4 + (r7 - e4 % r7);
  }
  _ensureSize(r7) {
    if (this._pos + r7 >= this._buffer.length) {
      const e4 = this._roundToNearest((this._array.byteLength + r7 * this._buffer.BYTES_PER_ELEMENT) * t3, this._buffer.BYTES_PER_ELEMENT), s9 = new ArrayBuffer(e4), i3 = new this._ctor(s9);
      i3.set(this._buffer, 0), this._array = s9, this._buffer = i3, this._i16View = new Int16Array(this._array);
    }
  }
  ensureSize(t8) {
    this._ensureSize(t8);
  }
  writeF32(t8) {
    this._ensureSize(1);
    const r7 = this._pos;
    return new Float32Array(this._array, 4 * this._pos, 1)[0] = t8, this._pos++, r7;
  }
  push(t8) {
    this._ensureSize(1);
    const r7 = this._pos;
    return this._buffer[this._pos++] = t8, r7;
  }
  writeFixed(t8) {
    this._buffer[this._pos++] = t8;
  }
  setValue(t8, r7) {
    this._buffer[t8] = r7;
  }
  i1616Add(t8, r7, e4) {
    this._i16View[2 * t8] += r7, this._i16View[2 * t8 + 1] += e4;
  }
  getValue(t8) {
    return this._buffer[t8];
  }
  getValueF32(t8) {
    return new Float32Array(this._array, 4 * t8, 1)[0];
  }
  incr(t8) {
    if (this._buffer.length < t8) throw new Error("Increment index overflows the target buffer");
    this._buffer[t8]++;
  }
  decr(t8) {
    this._buffer[t8]--;
  }
  writeRegion(t8) {
    this._ensureSize(t8.length);
    const r7 = this._pos;
    return this._buffer.set(t8, this._pos), this._pos += t8.length, r7;
  }
  writeManyFrom(t8, r7, e4) {
    this._ensureSize(e4 - r7);
    for (let s9 = r7; s9 !== e4; s9++) this.writeFixed(t8._buffer[s9]);
  }
  buffer() {
    const t8 = this._array.slice(0, 4 * this._pos);
    return this.destroy(), t8;
  }
  toArray() {
    return [...this._buffer];
  }
  seek(t8) {
    this._pos = t8;
  }
  destroy() {
    this._array = null, this._buffer = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/VertexDataWriter.js
var e3 = 6;
var i = 4;
var r3 = class {
  constructor(r7, s9, n12 = 0) {
    const c4 = e3 * n12 * Uint32Array.BYTES_PER_ELEMENT, h = i * n12 * s9.stride, u2 = s9.stride / 4, _4 = s9.attributes.find((t8) => "pos" === t8.name || "position" === t8.name);
    if (!_4) throw new Error("InternalError: Unable to find position attribute");
    this.layout = { ...s9, position: _4 }, this._indices = new r2(Uint32Array, c4), this._vertices = new r2(Uint32Array, h), this._metrics = new r2(Uint32Array, 0), this._metricCountOffset = this._metrics.push(0), this._strideInt = u2, this._instanceId = r7;
  }
  serialize(t8) {
    const e4 = this._indices.buffer(), i3 = this._vertices.buffer(), r7 = this._metrics.length ? this._metrics.buffer() : null;
    return t8.push(e4, i3), { instanceId: this._instanceId, layout: this.layout, indices: e4, vertices: i3, metrics: r7 };
  }
  get strideInt() {
    return this._strideInt;
  }
  get vertexCount() {
    return this._vertices.length / this._strideInt;
  }
  get indexCount() {
    return this._indices.length;
  }
  get indexWriter() {
    return this._indices;
  }
  get vertexWriter() {
    return this._vertices;
  }
  get metricWriter() {
    return this._metrics;
  }
  vertexEnsureSize(t8) {
    this._vertices.ensureSize(t8);
  }
  indexEnsureSize(t8) {
    this._indices.ensureSize(t8);
  }
  writeIndex(t8) {
    this._indices.push(t8);
  }
  writeVertex(t8) {
    this._vertices.push(t8);
  }
  writeVertexRegion(t8) {
    this._vertices.writeRegion(t8);
  }
  writeVertexF32(t8) {
    this._vertices.writeF32(t8);
  }
  writeMetric(t8) {
    this._metrics.incr(this._metricCountOffset), t8.serialize(this._metrics);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/MeshData.js
var n7 = class {
  constructor(e4, r7 = 0) {
    this._id = e4, this._sizeHint = r7, this._entityRecordCountOffset = 0, this._entityCountOffset = 0, this._entityIdIndex = 0, this._entitySortKeyIndex = 0, this._didEntityStart = false, this._instanceIdToVertexData = /* @__PURE__ */ new Map(), this._recordIndexStart = 0, this._recordIndexCount = 0, this._recordVertexStart = 0, this._recordVertexCount = 0, this._current = { metric: null, writer: null, start: 0, sortKey: 0, instanceId: 0, layoutHash: 0, indexStart: 0, vertexStart: 0, textureKey: 0, metricBoxLenPointer: 0 }, this._entities = new r2(Uint32Array, this._sizeHint * s3.byteSizeHint), this._entityCountOffset = this._entities.push(0);
  }
  get id() {
    return this._id;
  }
  serialize() {
    const t8 = new Array(), e4 = [], r7 = this._entities.buffer();
    for (const i3 of this._instanceIdToVertexData.values()) e4.push(i3.serialize(t8));
    return { message: { data: e4, entities: r7 }, transferList: t8 };
  }
  vertexCount() {
    var _a;
    return ((_a = this._current.writer) == null ? void 0 : _a.vertexCount) ?? 0;
  }
  indexCount() {
    var _a;
    return ((_a = this._current.writer) == null ? void 0 : _a.indexCount) ?? 0;
  }
  vertexEnsureSize(t8) {
    this._current.writer.vertexEnsureSize(t8);
  }
  indexEnsureSize(t8) {
    this._current.writer.indexEnsureSize(t8);
  }
  vertexWrite(t8) {
    this._current.writer.writeVertex(t8);
  }
  vertexWriteRegion(t8) {
    this._current.writer.writeVertexRegion(t8);
  }
  vertexWriteF32(t8) {
    this._current.writer.writeVertexF32(t8);
  }
  recordBounds(t8, e4, r7, i3) {
  }
  indexWrite(t8) {
    this._current.writer.writeIndex(t8);
  }
  metricStart(t8) {
    this._current.metric = t8;
  }
  metricEnd() {
    const t8 = this._current.writer;
    this._current.metric.bounds.length && t8.writeMetric(this._current.metric);
  }
  metricBoxWrite(t8) {
    this._current.metric.bounds.push(t8);
  }
  entityStart(t8, e4 = t8) {
    this._entityIdIndex = this._entities.push(t8), this._entitySortKeyIndex = this._entities.writeF32(e4), this._entityRecordCountOffset = this._entities.push(0), this._didEntityStart = true;
  }
  entityRecordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  entityEnd() {
    if (!this._didEntityStart) return;
    0 === this.entityRecordCount() ? this._entities.seek(this._entityIdIndex) : this._entities.incr(this._entityCountOffset), this._didEntityStart = false;
  }
  recordCount() {
    return this._entities.getValue(this._entityRecordCountOffset);
  }
  recordStart(t8, e4, r7 = 0) {
    this._current.writer = this._getVertexWriter(t8, e4), this._current.indexStart = this._current.writer.indexCount, this._current.vertexStart = this._current.writer.vertexCount, this._current.instanceId = t8, this._current.layoutHash = e4.hash, this._current.textureKey = r7;
  }
  recordEnd(t8 = 0) {
    const r7 = this._current.vertexStart, i3 = this._current.writer.vertexCount - r7;
    if (!i3) return false;
    const n12 = this._current.indexStart, s9 = this._current.writer.indexCount - n12;
    return this._recordIndexStart = n12, this._recordIndexCount = s9, this._recordVertexStart = r7, this._recordVertexCount = i3, this._entities.incr(this._entityRecordCountOffset), t2.write(this._entities, this._current.instanceId, this._current.textureKey, n12, s9, r7, i3, t8), true;
  }
  copyLast(t8, r7) {
    const i3 = this._recordVertexStart + this._recordVertexCount;
    this._entities.incr(this._entityRecordCountOffset), t2.write(this._entities, this._current.instanceId, this._current.textureKey, this._recordIndexStart + this._recordIndexCount, this._recordIndexCount, i3, this._recordVertexCount, 0);
    const n12 = this._current.writer.indexWriter, s9 = this._current.writer.vertexWriter, o4 = this._recordIndexStart + this._recordIndexCount, c4 = this._recordVertexCount;
    for (let e4 = this._recordIndexStart; e4 !== o4; e4++) {
      const t9 = n12.getValue(e4);
      n12.push(t9 + c4);
    }
    const u2 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, h = this._recordVertexStart * u2, _4 = (this._recordVertexStart + this._recordVertexCount) * u2;
    for (let e4 = h; e4 !== _4; e4++) {
      const t9 = s9.getValue(e4);
      s9.push(t9);
    }
    const d4 = this._current.writer.layout.position, a7 = d4.packPrecisionFactor ?? 1, x3 = d4.offset / Uint32Array.BYTES_PER_ELEMENT, y2 = t8 * a7, S2 = r7 * a7;
    for (let e4 = i3 * u2; e4 <= s9.length; e4 += u2) s9.i1616Add(e4 + x3, y2, S2);
  }
  copyLastFrom(t8, e4, r7) {
    const i3 = t8._entities.getValue(t8._entityIdIndex);
    if (i3 !== this._entities.getValue(this._entityIdIndex)) {
      const e5 = t8._entities.getValueF32(t8._entitySortKeyIndex);
      this.entityStart(i3, e5);
    }
    this.recordStart(t8._current.instanceId, t8._current.writer.layout, t8._current.textureKey);
    const n12 = this._current.writer.layout.stride / Uint32Array.BYTES_PER_ELEMENT, s9 = this._current.vertexStart, o4 = t8._current.vertexStart - s9, c4 = this._current.writer.indexWriter, u2 = this._current.writer.vertexWriter, h = t8._current.writer.indexWriter, _4 = t8._current.writer.vertexWriter;
    for (let f4 = t8._current.indexStart; f4 !== h.length; f4++) {
      const t9 = h.getValue(f4);
      c4.push(t9 - o4);
    }
    for (let f4 = t8._current.vertexStart * n12; f4 !== _4.length; f4++) {
      const t9 = _4.getValue(f4);
      u2.push(t9);
    }
    const d4 = this._current.writer.layout.position, a7 = d4.packPrecisionFactor ?? 1, x3 = d4.offset / Uint32Array.BYTES_PER_ELEMENT, y2 = e4 * a7, S2 = r7 * a7;
    for (let f4 = s9 * n12; f4 <= u2.length; f4 += n12) u2.i1616Add(f4 + x3, y2, S2);
    this.recordEnd();
  }
  _getVertexWriter(t8, e4) {
    const i3 = this._instanceIdToVertexData;
    return i3.has(t8) || i3.set(t8, new r3(t8, e4, this._sizeHint)), i3.get(t8);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/mesh/AResourceProxy.js
var s5 = class {
};

// node_modules/@arcgis/core/views/2d/engine/webgl/mesh/factories/ResourceProxy.js
var s6 = class extends s5 {
  constructor(e4) {
    super(), this._fetcher = e4, this._controller = new AbortController(), this._pendingIds = /* @__PURE__ */ new Set(), this._pendingRequests = [], this._resourceIdToResource = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._controller.abort();
  }
  get _abortOptions() {
    return { signal: this._controller.signal };
  }
  enqueueRequest(r7) {
    const s9 = j3(r7.resource), o4 = l(JSON.stringify(s9));
    return this._pendingIds.has(o4) || (this._pendingIds.add(o4), this._pendingRequests.push({ ...r7, resourceId: o4 })), o4;
  }
  async fetchEnqueuedResources() {
    const e4 = this._pendingRequests;
    this._pendingIds.clear(), this._pendingRequests = [];
    const t8 = await this._fetcher.fetch(e4, this._abortOptions);
    for (let r7 = 0; r7 < t8.length; r7++) {
      const s9 = e4[r7].resourceId;
      this._resourceIdToResource.set(s9, t8[r7]);
    }
  }
  async fetchResourceImmediate(e4) {
    const t8 = await this._fetcher.fetch([e4], this._abortOptions);
    if (1 !== t8.length) throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");
    return t8[0];
  }
  async fetchDictionaryResourceImmediate(e4) {
    const t8 = await this._fetcher.fetchDictionary([e4], this._abortOptions);
    if (1 !== t8.length) throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");
    return t8[0];
  }
  getResource(e4) {
    return this._resourceIdToResource.get(e4);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AComputedField.js
var s7 = class {
  destroy() {
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/CachedField.js
var r4 = class extends s7 {
  constructor(e4) {
    super(), this._field = e4;
  }
  resize(e4) {
    throw new Error("Method not implemented.");
  }
  read(e4, r7) {
    return e4.readAttribute(this._field);
  }
  readWithDefault(e4, r7) {
    return e4.readAttribute(this._field);
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/arcade/callExpressionWithCursor.js
function r5(r7, n12, t8) {
  var _a;
  if (null == r7) return null;
  const u2 = n12.readArcadeFeature();
  n12.contextTimeZone = (_a = t8.$view) == null ? void 0 : _a.timeZone;
  try {
    return r7.evaluate({ ...t8, $feature: u2 }, r7.services);
  } catch (a7) {
    return n.getLogger("esri.views.2d.support.arcadeOnDemand").warn("Feature arcade evaluation failed:", a7), null;
  }
}
function n8(e4) {
  return null == e4 || e4 === 1 / 0 || e4 === -1 / 0 || "number" == typeof e4 && isNaN(e4);
}
function t4(e4, r7, t8, u2) {
  var _a;
  if (null == e4) return null != u2 ? u2 : null;
  const a7 = r7.readArcadeFeature();
  r7.contextTimeZone = (_a = t8.$view) == null ? void 0 : _a.timeZone;
  const o4 = e4.evaluate({ ...t8, $feature: a7 }, e4.services);
  return n8(o4) ? null != u2 ? u2 : null : o4;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedExpression.js
var c = class _c extends s7 {
  static async create(t8, s9) {
    const a7 = await o2(t8, s9.spatialReference, s9.fields), i3 = l(t8);
    return new _c(a7, i3);
  }
  constructor(e4, r7) {
    super(), this._compiled = e4, this._cacheKey = r7;
  }
  resize(e4) {
  }
  read(e4, r7) {
    return this.referencesScale() || "system" !== r7.$view.timeZone ? r5(this._compiled, e4, r7) : this._readCached(e4, r7);
  }
  readWithDefault(e4, r7, t8) {
    return this.referencesScale() || "system" !== r7.$view.timeZone ? t4(this._compiled, e4, r7, t8) : this._readWithDefaultCached(e4, r7, t8);
  }
  referencesScale() {
    var _a;
    return ((_a = this._compiled) == null ? void 0 : _a.referencesScale()) ?? false;
  }
  referencesGeometry() {
    var _a;
    return ((_a = this._compiled) == null ? void 0 : _a.referencesGeometry()) ?? false;
  }
  _readCached(e4, r7) {
    if (e4.setCache(this._cacheKey), e4.hasCachedValue()) return e4.getCachedValue();
    const s9 = r5(this._compiled, e4, r7);
    return e4.setCachedValue(s9), s9;
  }
  _readWithDefaultCached(e4, r7, t8) {
    if (e4.setCache(this._cacheKey), e4.hasCachedValue()) return e4.getCachedValue();
    const a7 = t4(this._compiled, e4, r7, t8);
    return e4.setCachedValue(a7), a7;
  }
};

// node_modules/@arcgis/core/layers/support/labelFormatUtils.js
function g2(e4, r7) {
  if (null == e4) return "";
  const t8 = r7.domain;
  if (t8) {
    if ("codedValue" === t8.type || "coded-value" === t8.type) {
      const r8 = e4;
      for (const e5 of t8.codedValues) if (e5.code === r8) return e5.name;
    } else if ("range" === t8.type) {
      const { max: n12, min: o4 } = m2(r7), a7 = +e4;
      if (null != o4 && null != n12 && o4 <= a7 && a7 <= n12) return t8.name;
    }
  }
  let u2 = e4;
  return ge(r7) ? u2 = j(u2, E("short-date")) : pe(r7) && (u2 = l2(+u2)), u2 || "";
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedLegacyLabelExpression.js
var a3 = class _a extends s7 {
  static async create(t8, s9) {
    const l5 = p(t8);
    return new _a((r7) => l5.replaceAll(/{[^}]*}/g, (t9) => {
      const s10 = t9.slice(1, -1), a7 = r7.metadata.fieldsIndex.get(s10);
      if (null == a7) return t9;
      const l6 = r7.readAttribute(s10);
      return null == l6 ? "" : g2(l6, a7);
    }));
  }
  constructor(e4) {
    super(), this._evaluator = e4;
  }
  resize(e4) {
  }
  read(e4, r7) {
    return this._evaluator(e4);
  }
  readWithDefault(e4, r7, s9) {
    const a7 = this._evaluator(e4);
    return n8(a7) ? s9 : a7;
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/NormalizedField.js
var r6 = class extends s7 {
  constructor(e4, r7) {
    super(), this._field = e4, this._normalizationInfo = r7;
  }
  resize(e4) {
    throw new Error("Method not implemented.");
  }
  read(e4, r7) {
    return this._readNormalized(e4);
  }
  readWithDefault(e4, r7) {
    return this._readNormalized(e4);
  }
  referencesScale() {
    return false;
  }
  referencesGeometry() {
    return false;
  }
  _readNormalized(e4) {
    const r7 = e4.readAttribute(this._field);
    if (null == r7) return null;
    const { normalizationField: t8, normalizationTotal: i3, normalizationType: o4 } = this._normalizationInfo, a7 = e4.readAttribute(t8);
    switch (o4 ?? "esriNormalizeByField") {
      case "esriNormalizeByField":
        return a7 ? a7 ? r7 / a7 : void 0 : null;
      case "esriNormalizeByLog":
        return Math.log(r7) * Math.LOG10E;
      case "esriNormalizeByPercentOfTotal":
        return i3 ? r7 / i3 * 100 : null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/StaticBitSet.js
var t5 = class _t {
  static fromBuffer(e4, s9) {
    return new _t(e4, s9);
  }
  static create(e4, s9 = 4294967295) {
    const r7 = new Uint32Array(Math.ceil(e4 / 32));
    return new _t(r7, s9);
  }
  constructor(t8, e4) {
    this._mask = 0, this._buf = t8, this._mask = e4;
  }
  _getIndex(t8) {
    return Math.floor(t8 / 32);
  }
  has(t8) {
    const e4 = this._mask & t8;
    return !!(this._buf[this._getIndex(e4)] & 1 << e4 % 32);
  }
  hasRange(t8, e4) {
    let s9 = t8, r7 = e4;
    for (; s9 % 32 && s9 !== r7; ) {
      if (this.has(s9)) return true;
      s9++;
    }
    for (; r7 % 32 && s9 !== r7; ) {
      if (this.has(s9)) return true;
      r7--;
    }
    if (s9 === r7) return false;
    for (let h = s9 / 32; h !== r7 / 32; h++) {
      if (this._buf[h]) return true;
    }
    return false;
  }
  set(t8) {
    const e4 = this._mask & t8, s9 = this._getIndex(e4), r7 = 1 << e4 % 32;
    this._buf[s9] |= r7;
  }
  setRange(t8, e4) {
    let s9 = t8, r7 = e4;
    for (; s9 % 32 && s9 !== r7; ) this.set(s9++);
    for (; r7 % 32 && s9 !== r7; ) this.set(r7--);
    if (s9 !== r7) for (let h = s9 / 32; h !== r7 / 32; h++) this._buf[h] = 4294967295;
  }
  unset(t8) {
    const e4 = this._mask & t8, s9 = this._getIndex(e4), r7 = 1 << e4 % 32;
    this._buf[s9] &= 4294967295 ^ r7;
  }
  resize(t8) {
    const e4 = this._buf, s9 = new Uint32Array(Math.ceil(t8 / 32));
    s9.set(e4), this._buf = s9;
  }
  or(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] |= t8._buf[e4];
    return this;
  }
  and(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] &= t8._buf[e4];
    return this;
  }
  xor(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] ^= t8._buf[e4];
    return this;
  }
  ior(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] |= ~t8._buf[e4];
    return this;
  }
  iand(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] &= ~t8._buf[e4];
    return this;
  }
  ixor(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] ^= ~t8._buf[e4];
    return this;
  }
  any() {
    for (let t8 = 0; t8 < this._buf.length; t8++) if (this._buf[t8]) return true;
    return false;
  }
  copy(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) this._buf[e4] = t8._buf[e4];
    return this;
  }
  clone() {
    return new _t(this._buf.slice(), this._mask);
  }
  clear() {
    for (let t8 = 0; t8 < this._buf.length; t8++) this._buf[t8] = 0;
    return this;
  }
  forEachSet(t8) {
    for (let e4 = 0; e4 < this._buf.length; e4++) {
      let s9 = this._buf[e4], r7 = 32 * e4;
      if (s9) for (; s9; ) {
        1 & s9 && t8(r7), s9 >>>= 1, r7++;
      }
    }
  }
  countSet() {
    let t8 = 0;
    return this.forEachSet((e4) => {
      t8++;
    }), t8;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/whereUtils.js
var a4 = () => n.getLogger("esri.views.2d.layers.features.support.whereUtils");
var n9 = { getAttribute: (e4, r7) => e4.readAttribute(r7) };
async function o3(r7, o4) {
  try {
    const s9 = await e(r7, o4);
    if (!s9.isStandardized) {
      const r8 = new s("mapview - bad input", "Unable to apply filter's definition expression, as expression is not standardized.", s9);
      a4().error(r8);
    }
    return (e4) => {
      const t8 = e4.readArcadeFeature();
      try {
        return s9.testFeature(t8, n9);
      } catch (o5) {
        return a4().warn("mapview-bad-where-clause", "Encountered an error when evaluating where clause", r7), true;
      }
    };
  } catch (s9) {
    return a4().warn("mapview-bad-where-clause", "Encountered an error when evaluating where clause", r7), (e4) => true;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/support/ComputedAttributeStorage.js
var a5 = () => n.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage");
var c3 = 4294967295;
function m3(t8, e4, s9) {
  if (!(t8.length > e4)) for (; t8.length <= e4; ) t8.push(s9);
}
var p2 = class {
  constructor(t8) {
    this._numerics = [], this._strings = [], this._allocatedSize = 256, this._bitsets = [], this._instanceIds = [], this._bounds = [], this._dirtyBitset = this.getBitset(this.createBitset()), this.compilationOptions = t8;
  }
  createBitset() {
    const t8 = this._bitsets.length;
    return this._bitsets.push(t5.create(this._allocatedSize, n6)), t8 + 1;
  }
  async createComputedField(e4, s9 = false) {
    if (e4.expression) try {
      if (!this.compilationOptions) throw new Error("InternalError: Compilation options not defined");
      if (s9) return await a3.create(e4.expression, this.compilationOptions);
      return await c.create(e4.expression, this.compilationOptions);
    } catch (d4) {
      const s10 = new s("featurelayer", "Failed to compile arcade expression", { error: d4, expression: e4.expression });
      return a5().error(s10), null;
    }
    if (e4.normalizationType || e4.normalizationField) return new r6(e4.field, e4);
    if (e4.field) return new r4(e4.field);
    const i3 = new s("featurelayer", "Unable to create computed field. No expression or field found", { info: e4 });
    return a5().error(i3), null;
  }
  async createWhereClause(t8) {
    return t8 ? o3(t8, this.compilationOptions.fields) : null;
  }
  getBitset(t8) {
    return this._bitsets[t8 - 1];
  }
  getComputedNumeric(t8, e4) {
    return this.getComputedNumericAtIndex(t8 & n6, 0);
  }
  setComputedNumeric(t8, e4, s9) {
    return this.setComputedNumericAtIndex(t8 & n6, s9, 0);
  }
  getComputedString(t8, e4) {
    return this.getComputedStringAtIndex(t8 & n6, 0);
  }
  setComputedString(t8, e4, s9) {
    return this.setComputedStringAtIndex(t8 & n6, 0, s9);
  }
  getComputedNumericAtIndex(t8, e4) {
    const s9 = t8 & n6;
    return this._ensureNumeric(e4, s9), this._numerics[e4][s9];
  }
  setComputedNumericAtIndex(t8, e4, s9) {
    const r7 = t8 & n6;
    this._ensureNumeric(e4, r7), this._numerics[e4][r7] = s9;
  }
  getPackedChunkId(t8) {
    const e4 = t8 & n6;
    return this._ensureInstanceId(e4), this._instanceIds[e4];
  }
  setPackedChunkId(t8, e4) {
    const s9 = t8 & n6;
    this._ensureInstanceId(s9), this._instanceIds[s9] = e4;
  }
  getComputedStringAtIndex(t8, e4) {
    const s9 = t8 & n6;
    return this._ensureString(e4, s9), this._strings[e4][s9];
  }
  setComputedStringAtIndex(t8, e4, s9) {
    const r7 = t8 & n6;
    this._ensureString(e4, r7), this._strings[e4][r7] = s9;
  }
  getXMin(t8) {
    return this._bounds[4 * (t8 & n6)];
  }
  getYMin(t8) {
    return this._bounds[4 * (t8 & n6) + 1];
  }
  getXMax(t8) {
    return this._bounds[4 * (t8 & n6) + 2];
  }
  getYMax(t8) {
    return this._bounds[4 * (t8 & n6) + 3];
  }
  setBounds(t8, e4, s9 = false) {
    const r7 = t8 & n6;
    if (!s9 && !this._dirtyBitset.has(t8)) return this._bounds[4 * r7] !== c3;
    this._dirtyBitset.unset(t8);
    const n12 = e4.readGeometryWorldSpace();
    if (m3(this._bounds, 4 * r7 + 4, 0), !n12 || !n12.coords.length) return this._bounds[4 * r7] = c3, this._bounds[4 * r7 + 1] = c3, this._bounds[4 * r7 + 2] = c3, this._bounds[4 * r7 + 3] = c3, false;
    let o4 = 1 / 0, u2 = 1 / 0, d4 = -1 / 0, h = -1 / 0;
    return n12.forEachVertex((t9, e5) => {
      o4 = Math.min(o4, t9), u2 = Math.min(u2, e5), d4 = Math.max(d4, t9), h = Math.max(h, e5);
    }), this._bounds[4 * r7] = o4, this._bounds[4 * r7 + 1] = u2, this._bounds[4 * r7 + 2] = d4, this._bounds[4 * r7 + 3] = h, true;
  }
  getBounds(t8, e4) {
    const i3 = this.getXMin(e4), r7 = this.getYMin(e4), n12 = this.getXMax(e4), o4 = this.getYMax(e4);
    return D(t8, i3, r7, n12, o4), i3 !== c3;
  }
  _ensureNumeric(t8, e4) {
    this._numerics[t8] || (this._numerics[t8] = []);
    m3(this._numerics[t8], e4, 0);
  }
  _ensureInstanceId(t8) {
    m3(this._instanceIds, t8, 0);
  }
  _ensureString(t8, e4) {
    this._strings[t8] || (this._strings[t8] = []);
    m3(this._strings[t8], e4, null);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureMetadata.js
var i2 = class _i {
  static minimal(e4, n12, l5 = []) {
    return new _i({ geometryType: e4, fieldsIndex: new Z(l5).toJSON(), objectIdField: n12, subtypes: null, subtypeField: null, types: null, globalIdField: null, spatialReference: null, timeInfo: null, timeReferenceUnknownClient: null, typeIdField: null });
  }
  static createFeature(e4) {
    return new _i(e4);
  }
  constructor(i3) {
    this._options = i3, this._fieldsIndex = Z.fromJSON(i3.fieldsIndex), i3.spatialReference && (this._spatialReference = g.fromJSON(i3.spatialReference)), this._arcadeSchema = { fields: this.fieldsIndex.fields, fieldsIndex: this.fieldsIndex, geometryType: this.geometryType, objectIdField: this.objectIdField, globalIdField: this._options.globalIdField, spatialReference: this._spatialReference, timeInfo: this._options.timeInfo, typeIdField: this._options.typeIdField ?? void 0, types: this._options.types ?? void 0, subtypeField: this._options.subtypeField, subtypes: this._options.subtypes ?? void 0 };
  }
  get fieldsIndex() {
    return this._fieldsIndex;
  }
  get geometryType() {
    return "esriGeometryMultiPatch" === this._options.geometryType ? "esriGeometryPolygon" : this._options.geometryType;
  }
  get serviceGeometryType() {
    return this._options.geometryType;
  }
  get subtypeField() {
    return this._options.subtypeField;
  }
  get timeInfo() {
    return this._options.timeInfo;
  }
  get objectIdField() {
    return this._options.objectIdField;
  }
  get globalIdField() {
    return this._options.globalIdField;
  }
  get arcadeSchema() {
    return this._arcadeSchema;
  }
  get spatialReference() {
    return this._spatialReference;
  }
  get timeReferenceUnknownClient() {
    return this._options.timeReferenceUnknownClient;
  }
};
var n10 = class _n extends i2 {
  static createGraphics(e4) {
    return new _n({ fieldsIndex: new Z().toJSON(), objectIdField: "uid", geometryType: null, spatialReference: e4, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: null, typeIdField: null, types: null, timeReferenceUnknownClient: null });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/util/debug.js
var n11 = (n12, l5) => n12 && ((...n13) => l5.warn("DEBUG:", ...n13)) || (() => null);
var l4 = false;

// node_modules/@arcgis/core/views/2d/layers/features/support/DisplayIdGenerator.js
var t6 = class {
  constructor(e4) {
    this.data = e4, this._referenceCount = 0;
  }
  increment() {
    this._referenceCount += 1;
  }
  decrement() {
    this._referenceCount -= 1;
  }
  empty() {
    return 0 === this._referenceCount;
  }
};
var s8 = class {
  constructor() {
    this._freeIdsGenerationA = [], this._freeIdsGenerationB = [], this._idCounter = 1, this._freeIds = this._freeIdsGenerationA, this._objectIdToDisplayId = /* @__PURE__ */ new Map();
  }
  createIdForObjectId(s9) {
    let r7 = this._objectIdToDisplayId.get(s9);
    return r7 ? r7.increment() : (r7 = new t6(s4(this._getFreeId(), false)), r7.increment(), this._objectIdToDisplayId.set(s9, r7)), r7.data;
  }
  releaseIdForObjectId(e4) {
    const t8 = this._objectIdToDisplayId.get(e4);
    t8 && (t8.decrement(), t8.empty() && (this._objectIdToDisplayId.delete(e4), this._freeIds.push(t8.data)));
  }
  getDisplayIdForObjectId(e4) {
    const t8 = this._objectIdToDisplayId.get(e4);
    return null != t8 ? t8.data : null;
  }
  releaseAll() {
    for (const e4 of this._objectIdToDisplayId.values()) this._freeIds.push(e4.data);
    this._objectIdToDisplayId.clear();
  }
  incrementGeneration() {
    this._freeIds = this._freeIds === this._freeIdsGenerationA ? this._freeIdsGenerationB : this._freeIdsGenerationA;
  }
  _getFreeId() {
    return this._freeIds.length ? this._freeIds.pop() : this._idCounter++;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureStoreQueryAdapter.js
var t7 = class {
  getObjectId(t8) {
    return t8.getObjectId();
  }
  getAttributes(t8) {
    return t8.readAttributes();
  }
  getAttribute(t8, e4) {
    return t8.readAttribute(e4);
  }
  getAttributeAsTimestamp(t8, e4) {
    return t8.readAttributeAsTimestamp(e4);
  }
  cloneWithGeometry(t8, e4) {
    return t8;
  }
  getGeometry(t8) {
    return t8.readGeometryWorldSpace();
  }
  getCentroid(t8, e4) {
    return t8.readCentroidForDisplay();
  }
};
t7.Shared = new t7();

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureFilter.js
var d3 = 1;
var m4 = 2;
var p3 = class _p {
  constructor(t8) {
    this._geometryBounds = u(), this._idToVisibility = /* @__PURE__ */ new Map(), this._serviceInfo = t8;
  }
  static async create(t8) {
    const e4 = new _p(t8);
    return await e4.update(t8.filterJSON, t8.spatialReference), e4;
  }
  get hash() {
    return this._hash;
  }
  check(t8) {
    return this._applyFilter(t8);
  }
  clear() {
    const t8 = this._resetAllHiddenIds();
    return this.update(), { show: t8, hide: [] };
  }
  invalidate() {
    this._idToVisibility.forEach((t8, e4) => {
      this._idToVisibility.set(e4, 0);
    });
  }
  setKnownIds(t8) {
    for (const e4 of t8) this._idToVisibility.set(e4, d3);
  }
  setTrue(t8) {
    const e4 = [], i3 = [], s9 = new Set(t8);
    return this._idToVisibility.forEach((t9, r7) => {
      const o4 = !!(this._idToVisibility.get(r7) & d3), a7 = s9.has(r7);
      !o4 && a7 ? e4.push(r7) : o4 && !a7 && i3.push(r7), this._idToVisibility.set(r7, a7 ? d3 | m4 : 0);
    }), { show: e4, hide: i3 };
  }
  createQuery() {
    const { geometry: t8, spatialRel: e4, where: i3, timeExtent: s9, objectIds: r7 } = this;
    return b.fromJSON({ geometry: t8, spatialRel: e4, where: i3, timeExtent: s9, objectIds: r7 });
  }
  async update(t8, e4) {
    this._hash = JSON.stringify(t8);
    const i3 = await j2(t8, null, e4);
    await Promise.all([this._setGeometryFilter(i3), this._setIdFilter(i3), this._setAttributeFilter(i3), this._setTimeFilter(i3)]);
  }
  async _setAttributeFilter(t8) {
    if (!(t8 == null ? void 0 : t8.where)) return this._clause = null, void (this.where = null);
    this._clause = await o3(t8.where, this._serviceInfo.fieldsIndex), this.where = t8.where;
  }
  _setIdFilter(t8) {
    this._idsToShow = (t8 == null ? void 0 : t8.objectIds) && new Set(t8.objectIds), this._idsToHide = (t8 == null ? void 0 : t8.hiddenIds) && new Set(t8.hiddenIds), this.objectIds = t8 == null ? void 0 : t8.objectIds;
  }
  async _setGeometryFilter(t8) {
    if (!(t8 == null ? void 0 : t8.geometry)) return this._spatialQueryOperator = null, this.geometry = null, void (this.spatialRel = null);
    const e4 = t8.geometry, i3 = t8.spatialRel || "esriSpatialRelIntersects", r7 = await P(i3, e4, this._serviceInfo.geometryType, this._serviceInfo.hasZ, this._serviceInfo.hasM);
    a(this._geometryBounds, e4), this._spatialQueryOperator = r7, this.geometry = e4, this.spatialRel = i3;
  }
  _setTimeFilter(i3) {
    if (this.timeExtent = this._timeOperator = null, i3 == null ? void 0 : i3.timeExtent) if (this._serviceInfo.timeInfo) this.timeExtent = i3.timeExtent, this._timeOperator = t(this._serviceInfo.timeInfo, i3.timeExtent, t7.Shared);
    else {
      const s9 = new s("feature-layer-view:time-filter-not-available", "Unable to apply time filter, as layer doesn't have time metadata.", i3.timeExtent);
      n.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(s9);
    }
  }
  _applyFilter(t8) {
    return this._filterByGeometry(t8) && this._filterById(t8) && this._filterByTime(t8) && this._filterByExpression(t8);
  }
  _filterByExpression(t8) {
    return !this.where || this._clause(t8);
  }
  _filterById(t8) {
    var _a, _b;
    return (!((_a = this._idsToHide) == null ? void 0 : _a.size) || !this._idsToHide.has(t8.getObjectId())) && (!((_b = this._idsToShow) == null ? void 0 : _b.size) || this._idsToShow.has(t8.getObjectId()));
  }
  _filterByGeometry(t8) {
    if (!this.geometry) return true;
    const e4 = t8.readGeometryWorldSpace();
    return !!e4 && this._spatialQueryOperator(e4);
  }
  _filterByTime(t8) {
    return null == this._timeOperator || this._timeOperator(t8);
  }
  _resetAllHiddenIds() {
    const t8 = [];
    return this._idToVisibility.forEach((e4, i3) => {
      e4 & d3 || (this._idToVisibility.set(i3, d3), t8.push(i3));
    }), t8;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/AttributeStore.js
function g3(t8, e4) {
  if (!t8 || !e4) return t8;
  switch (e4) {
    case "radius":
    case "distance":
      return 2 * t8;
    case "diameter":
    case "width":
      return t8;
    case "area":
      return Math.sqrt(t8);
  }
  return t8;
}
var _2 = () => n.getLogger("esri.views.layers.2d.features.support.AttributeStore");
var f3 = n11(l4, _2());
var y = { sharedArrayBuffer: has("esri-shared-array-buffer"), atomics: has("esri-atomics") };
var m5 = class {
  constructor(t8, e4, i3) {
    this.size = 0, this.texelSize = 4, this.dirtyStart = 0, this.dirtyEnd = 0;
    const { pixelType: s9, layout: r7, textureOnly: n12 } = e4;
    this.textureOnly = n12 || false, this.pixelType = s9, this.layout = r7, this._resetRange(), this.size = t8, this.isLocal = i3, n12 || (this.data = this._initData(s9, t8));
  }
  get buffer() {
    var _a;
    return (_a = this.data) == null ? void 0 : _a.buffer;
  }
  unsetComponentAllTexels(t8, e4) {
    const i3 = this.data;
    for (let s9 = 0; s9 < this.size * this.size; s9++) i3[s9 * this.texelSize + t8] &= ~e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponentAllTexels(t8, e4) {
    const i3 = this.data;
    for (let s9 = 0; s9 < this.size * this.size; s9++) i3[s9 * this.texelSize + t8] |= 255 & e4;
    this.dirtyStart = 0, this.dirtyEnd = this.size * this.size - 1;
  }
  setComponent(t8, e4, i3) {
    const s9 = this.data;
    for (const r7 of i3) s9[r7 * this.texelSize + t8] |= e4, this.dirtyStart = Math.min(this.dirtyStart, r7), this.dirtyEnd = Math.max(this.dirtyEnd, r7);
  }
  setComponentTexel(t8, e4, i3) {
    this.data[i3 * this.texelSize + t8] |= e4, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  unsetComponentTexel(t8, e4, i3) {
    this.data[i3 * this.texelSize + t8] &= ~e4, this.dirtyStart = Math.min(this.dirtyStart, i3), this.dirtyEnd = Math.max(this.dirtyEnd, i3);
  }
  getData(t8, e4) {
    const i3 = f2(t8);
    return this.data[i3 * this.texelSize + e4];
  }
  setData(t8, e4, i3) {
    const s9 = f2(t8), r7 = 1 << e4;
    this.layout & r7 ? null != this.data && (this.data[s9 * this.texelSize + e4] = i3, this.dirtyStart = Math.min(this.dirtyStart, s9), this.dirtyEnd = Math.max(this.dirtyEnd, s9)) : _2().error("mapview-attributes-store", "Tried to set a value for a texel's readonly component");
  }
  expand(t8) {
    if (this.size = t8, !this.textureOnly) {
      const e4 = this._initData(this.pixelType, t8), i3 = this.data;
      e4.set(i3), this.data = e4;
    }
  }
  toMessage() {
    const t8 = this.dirtyStart, e4 = this.dirtyEnd, i3 = this.texelSize;
    if (t8 > e4) return null;
    this._resetRange();
    const s9 = !this.isLocal, r7 = this.pixelType, n12 = this.layout, a7 = this.data;
    return { start: t8, end: e4, data: s9 && a7.slice(t8 * i3, (e4 + 1) * i3) || null, pixelType: r7, layout: n12 };
  }
  _initData(t8, e4) {
    const i3 = ArrayBuffer, s9 = d2(t8), r7 = new s9(new i3(e4 * e4 * 4 * s9.BYTES_PER_ELEMENT));
    for (let n12 = 0; n12 < r7.length; n12 += 4) r7[n12 + 1] = 255;
    return r7;
  }
  _resetRange() {
    this.dirtyStart = 2147483647, this.dirtyEnd = 0;
  }
};
var b2 = class {
  constructor(t8) {
    this._client = t8, this._filters = [], this._blocks = new Array(), this._attributeComputeInfo = null, this._abortController = new AbortController(), this._size = qi, this._idsToHighlight = /* @__PURE__ */ new Map(), this._referencesScale = false, this._referencesGeometry = false, this._initialized = false, this.version = 0, this._idGenerator = new s8(), this._epoch = 1;
  }
  destroy() {
    this._abortController.abort();
  }
  _initialize() {
    if (null != this._blockDescriptors) return;
    const t8 = U.FLOAT;
    f3(`Creating AttributeStore ${y.sharedArrayBuffer ? "with" : "without"} shared memory`), this._blockDescriptors = [{ pixelType: U.UNSIGNED_BYTE, layout: 1 }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: U.UNSIGNED_BYTE, layout: 15, textureOnly: true }, { pixelType: t8, layout: 15 }, { pixelType: t8, layout: 15 }, { pixelType: t8, layout: 15 }, { pixelType: t8, layout: 15 }, { pixelType: U.FLOAT, layout: 15 }], this._blocks = this._blockDescriptors.map(() => null);
  }
  get referencesScale() {
    return this._referencesScale;
  }
  get referencesGeometry() {
    return this._referencesGeometry;
  }
  get hasHighlight() {
    return this._idsToHighlight.size > 0;
  }
  createDisplayIdForObjectId(t8) {
    return this._idGenerator.createIdForObjectId(t8);
  }
  releaseDisplayIdForObjectId(t8) {
    return this._idGenerator.releaseIdForObjectId(t8);
  }
  getDisplayIdForObjectId(t8) {
    return this._idGenerator.getDisplayIdForObjectId(t8);
  }
  incrementDisplayIdGeneration() {
    this._idGenerator.incrementGeneration();
  }
  releaseAllIds() {
    this._idGenerator.releaseAll();
  }
  async update(t8, e4, s9, r7, n12 = 0) {
    const a7 = d(this._schema, t8);
    if (this.version = n12, a7 && (has("esri-2d-update-debug") && console.debug(`Version[${n12}] AttributeStore.update`, { changed: a7 }), this._schema = t8, this._attributeComputeInfo = null, this._initialize(), null != t8)) if (s9 && (this._filters = await Promise.all(t8.filters.map((t9) => t9 ? p3.create({ geometryType: s9.geometryType, hasM: false, hasZ: false, timeInfo: s9.timeInfo, fieldsIndex: s9.fieldsIndex, spatialReference: r7 ?? s9.spatialReference, filterJSON: t9 }) : null))), "subtype" !== t8.type) this._attributeComputeInfo = { isSubtype: false, map: /* @__PURE__ */ new Map() }, await Promise.all(t8.bindings.map(async (t9) => {
      const i3 = await this._bind(e4, t9);
      this._referencesGeometry = this._referencesGeometry || ((i3 == null ? void 0 : i3.referencesGeometry()) ?? false), this._referencesScale = this._referencesScale || ((i3 == null ? void 0 : i3.referencesScale()) ?? false);
    }));
    else {
      this._attributeComputeInfo = { isSubtype: true, subtypeField: t8.subtypeField, map: /* @__PURE__ */ new Map() }, this._referencesScale = false, this._referencesGeometry = false;
      for (const i3 in t8.bindings) {
        const s10 = t8.bindings[i3];
        await Promise.all(s10.map(async (t9) => {
          const s11 = await this._bind(e4, t9, parseInt(i3, 10));
          this._referencesGeometry = this._referencesGeometry || ((s11 == null ? void 0 : s11.referencesGeometry()) ?? false), this._referencesScale = this._referencesScale || ((s11 == null ? void 0 : s11.referencesScale()) ?? false);
        }));
      }
    }
  }
  setHighlight(t8, e4) {
    const i3 = this._getBlock(0);
    i3.unsetComponentAllTexels(0, (1 << K) - 1);
    for (const { displayId: s9, highlightFlags: r7 } of t8) {
      if (null == s9) continue;
      const t9 = f2(s9);
      i3.setComponent(0, r7, [t9]);
    }
    this._idsToHighlight.clear();
    for (const { objectId: s9, highlightFlags: r7 } of t8) this._idsToHighlight.set(s9, r7);
    for (const { objectId: s9, highlightFlags: r7 } of e4) this._idsToHighlight.set(s9, r7);
  }
  setData(t8, e4, i3, s9) {
    const r7 = f2(t8);
    this._ensureSizeForTexel(r7), this._getBlock(e4).setData(t8, i3, s9);
  }
  getData(t8, e4, i3) {
    return this._getBlock(e4).getData(t8, i3);
  }
  getHighlightFlags(t8) {
    return this._idsToHighlight.get(t8) || 0;
  }
  unsetAttributeData(t8) {
    const e4 = f2(t8);
    this._getBlock(0).setData(e4, 0, 0);
  }
  setAttributeData(t8, e4, i3) {
    const s9 = f2(t8);
    this._ensureSizeForTexel(s9), this._getBlock(0).setData(s9, 0, this.getFilterFlags(e4));
    const r7 = this._attributeComputeInfo, o4 = 1, h = 4;
    let c4 = null;
    r7 && (c4 = r7.isSubtype ? r7.map.get(e4.readAttribute(r7.subtypeField)) : r7.map, (c4 == null ? void 0 : c4.size) && c4.forEach((t9, r8) => {
      var _a;
      const a7 = r8 * o4 % h, c5 = Math.floor(r8 * o4 / h), d4 = this._getBlock(c5 + J.VV);
      let u2 = (_a = t9.field) == null ? void 0 : _a.read(e4, i3);
      t9.valueRepresentation && (u2 = g3(u2, t9.valueRepresentation));
      (null === u2 || isNaN(u2) || u2 === 1 / 0 || u2 === -1 / 0) && (u2 = k), d4.setData(s9, a7, u2);
    }));
  }
  get epoch() {
    return this._epoch;
  }
  sendUpdates() {
    const t8 = this._blocks.map((t9) => null != t9 ? t9.toMessage() : null), e4 = this._getInitArgs();
    has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.start"), this._client.update({ initArgs: e4, blockData: t8, version: this.version, sendUpdateEpoch: this._epoch }), this._epoch += 1, has("esri-2d-log-updating") && console.log("AttributeStore: _doSendUpdate.end");
  }
  _ensureSizeForTexel(t8) {
    for (; t8 >= this._size * this._size; ) if (this._expand()) return;
  }
  async _bind(t8, e4, i3) {
    const s9 = await t8.createComputedField(e4), { valueRepresentation: r7 } = e4, n12 = this._attributeComputeInfo;
    if (n12.isSubtype) {
      const t9 = n12.map.get(i3) ?? /* @__PURE__ */ new Map();
      t9.set(e4.binding, { field: s9, valueRepresentation: r7 }), n12.map.set(i3, t9);
    } else n12.map.set(e4.binding, { field: s9, valueRepresentation: r7 });
    return s9;
  }
  _getInitArgs() {
    return this._initialized ? null : (this._initialized = true, this._getBlock(J.Animation), this._getBlock(J.GPGPU), this._getBlock(J.LocalTimeOrigin), { blockSize: this._size, blockDescriptors: this._blocks.map((t8) => null != t8 ? { textureOnly: t8.textureOnly, buffer: t8.buffer, pixelType: t8.pixelType } : null) });
  }
  _getBlock(t8) {
    const e4 = this._blocks[t8];
    if (null != e4) return e4;
    f3(`Initializing AttributeBlock at index ${t8}`);
    const i3 = new m5(this._size, this._blockDescriptors[t8], this._client.isLocal);
    return this._blocks[t8] = i3, this._initialized = false, i3;
  }
  _expand() {
    if (this._size < this._schema.capabilities.maxTextureSize) {
      const t8 = this._size <<= 1;
      f3("Expanding block size to", t8, this._blocks);
      for (const e4 of this._blocks) e4 == null ? void 0 : e4.expand(t8);
      return this._initialized = false, this._size = t8, 0;
    }
    return _2().error(new s("mapview-limitations", "Maximum number of onscreen features exceeded.")), -1;
  }
  isVisible(t8) {
    return !!(this._getBlock(0).getData(t8, 0) & 1 << K);
  }
  getFilterFlags(t8) {
    let e4 = 0;
    for (let s9 = 0; s9 < this._filters.length; s9++) {
      const i4 = !!(1 << s9), r7 = this._filters[s9];
      e4 |= (!i4 || null == r7 || r7.check(t8) ? 1 : 0) << s9;
    }
    let i3 = 0;
    if (this._idsToHighlight.size) {
      const e5 = t8.getObjectId();
      i3 = this.getHighlightFlags(e5);
    }
    return e4 << K | i3;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetCache.js
var a6 = class {
  constructor(a7) {
    this._valid = t5.create(a7), this._data = new Array(a7);
  }
  has(t8) {
    return this._valid.has(t8);
  }
  set(t8, a7) {
    this._valid.set(t8), this._data[t8] = a7;
  }
  get(t8) {
    return this._data[t8];
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/support/FeatureSetReader.js
var g4 = has("featurelayer-simplify-thresholds") ?? [0.5, 0.5, 0.5, 0.5];
var _3 = g4[0];
var b3 = g4[1];
var x2 = g4[2];
var T = g4[3];
var I = has("featurelayer-simplify-payload-size-factors") ?? [1, 2, 4];
var A = I[0];
var D2 = I[1];
var F = I[2];
var S = has("featurelayer-simplify-mobile-factor") ?? 2;
var j4 = has("esri-mobile");
var B = 4294967295;
function C(e4, t8, r7) {
  if (!(e4.length > t8)) for (; e4.length <= t8; ) e4.push(r7);
}
var M = class {
  constructor(e4) {
    this.metadata = e4, this.type = "FeatureSetReader", this._deleted = null, this._joined = [], this._objectIdToIndex = null, this._boundsBuffer = [], this._caches = /* @__PURE__ */ new Map(), this.arcadeDeclaredClass = "esri.arcade.Feature", this._contextTimeZone = null;
  }
  destroy() {
  }
  [Symbol.dispose]() {
    this.destroy();
  }
  get isEmpty() {
    return null != this._deleted && this._deleted.countSet() === this.getSize();
  }
  getAreaSimplificationThreshold(e4, t8) {
    let r7 = 1;
    const s9 = j4 ? S : 1;
    t8 > 4e6 ? r7 = F * s9 : t8 > 1e6 ? r7 = D2 * s9 : t8 > 5e5 ? r7 = A * s9 : t8 > 1e5 && (r7 = s9);
    let i3 = 0;
    return e4 > 4e3 ? i3 = T * r7 : e4 > 2e3 ? i3 = x2 * r7 : e4 > 100 ? i3 = b3 : e4 > 15 && (i3 = _3), i3;
  }
  getBounds(e4) {
    if (C(this._boundsBuffer, 4 * this.getIndex() + 4, 0), this.getBoundsXMin() === B) return false;
    if (0 === this.getBoundsXMin()) {
      const t9 = this.readGeometryWorldSpace();
      if (!t9) return this.setBoundsXMin(B), false;
      let r8 = 1 / 0, s10 = 1 / 0, i4 = -1 / 0, a7 = -1 / 0;
      return t9.forEachVertex((e5, t10) => {
        r8 = Math.min(r8, e5), s10 = Math.min(s10, t10), i4 = Math.max(i4, e5), a7 = Math.max(a7, t10);
      }), this.setBoundsXMin(r8), this.setBoundsYMin(s10), this.setBoundsXMax(i4), this.setBoundsYMax(a7), D(e4, r8, s10, i4, a7), true;
    }
    const t8 = this.getBoundsXMin(), r7 = this.getBoundsYMin(), s9 = this.getBoundsXMax(), i3 = this.getBoundsYMax();
    return D(e4, t8, r7, s9, i3), true;
  }
  getBoundsXMin() {
    return this._boundsBuffer[4 * this.getIndex()];
  }
  setBoundsXMin(e4) {
    this._boundsBuffer[4 * this.getIndex()] = e4;
  }
  getBoundsYMin() {
    return this._boundsBuffer[4 * this.getIndex() + 1];
  }
  setBoundsYMin(e4) {
    this._boundsBuffer[4 * this.getIndex() + 1] = e4;
  }
  getBoundsXMax() {
    return this._boundsBuffer[4 * this.getIndex() + 2];
  }
  setBoundsXMax(e4) {
    this._boundsBuffer[4 * this.getIndex() + 2] = e4;
  }
  getBoundsYMax() {
    return this._boundsBuffer[4 * this.getIndex() + 3];
  }
  setBoundsYMax(e4) {
    this._boundsBuffer[4 * this.getIndex() + 3] = e4;
  }
  readAttributeAsTimestamp(e4) {
    const t8 = this.readAttribute(e4);
    return "string" == typeof t8 ? new Date(t8).getTime() : "number" == typeof t8 || null == t8 ? t8 : null;
  }
  readAttribute(e4, t8 = false) {
    const r7 = this._readAttribute(e4, t8);
    if (void 0 !== r7) return r7;
    for (const s9 of this._joined) {
      s9.setIndex(this.getIndex());
      const r8 = s9._readAttribute(e4, t8);
      if (void 0 !== r8) return r8;
    }
  }
  readAttributes() {
    const e4 = this._readAttributes();
    for (const t8 of this._joined) {
      t8.setIndex(this.getIndex());
      const r7 = t8._readAttributes();
      for (const t9 of Object.keys(r7)) e4[t9] = r7[t9];
    }
    return e4;
  }
  joinAttributes(e4) {
    this._joined.push(e4);
  }
  removeIds(e4) {
    if (null == this._objectIdToIndex) {
      const e5 = /* @__PURE__ */ new Map(), r8 = this.getCursor();
      for (; r8.next(); ) {
        const s9 = r8.getObjectId();
        n2(s9), e5.set(s9, r8.getIndex());
      }
      this._objectIdToIndex = e5;
    }
    const r7 = this._objectIdToIndex;
    for (const t8 of e4.values()) r7.has(t8) && this._removeAtIndex(r7.get(t8));
  }
  readOptimizedFeatureWorldSpace() {
    const e4 = this.readGeometryWorldSpace(), t8 = this.readAttributes(), r7 = this.readCentroidWorldSpace(), s9 = new e2(e4, t8, r7);
    return s9.objectId = this.getObjectId(), s9.displayId = this.getDisplayId(), s9;
  }
  readLegacyFeatureForDisplay() {
    const e4 = this.readCentroidForDisplay();
    return { attributes: this.readAttributes(), geometry: this.readLegacyGeometryForDisplay(), centroid: (e4 && { x: e4.coords[0], y: e4.coords[1] }) ?? null };
  }
  readLegacyFeatureWorldSpace() {
    const e4 = this.readCentroidWorldSpace();
    return { attributes: this.readAttributes(), geometry: this._readLegacyGeometryWorldSpace(), centroid: (e4 && { x: e4.coords[0], y: e4.coords[1] }) ?? null };
  }
  readLegacyGeometryForDisplay() {
    const e4 = this.readGeometryForDisplay();
    return rt(e4, this.geometryType, false, false);
  }
  readXForDisplay() {
    return this._readX();
  }
  readYForDisplay() {
    return this._readY();
  }
  readXWorldSpace() {
    const e4 = this._readX(), t8 = this.getInTransform();
    return null == t8 ? e4 : e4 * t8.scale[0] + t8.translate[0];
  }
  readYWorldSpace() {
    const e4 = this._readY(), t8 = this.getInTransform();
    return null == t8 ? e4 : t8.translate[1] - e4 * t8.scale[1];
  }
  readGeometryForDisplay() {
    const e4 = this._readGeometryDeltaDecoded(true);
    if (!e4) {
      const e5 = this._createGeometryFromServerCentroid();
      return e5 ? e5.deltaDecode() : null;
    }
    return e4;
  }
  readGeometryWorldSpace() {
    let e4 = this._readGeometry();
    if (e4 || (e4 = this._createGeometryFromServerCentroid()), !e4) return null;
    const t8 = e4.clone(), r7 = this.getInTransform();
    return null != r7 && pt(t8, t8, this.hasZ, this.hasM, r7), t8;
  }
  readCentroidForDisplay() {
    const e4 = this.readGeometryForDisplay();
    return e4 ? this._computeDisplayCentroid(e4) : this._readServerCentroid();
  }
  readCentroidWorldSpace() {
    const e4 = this.readGeometryForDisplay(), t8 = e4 ? this._computeDisplayCentroid(e4) : this._readServerCentroid();
    if (!t8) return null;
    const r7 = t8.clone(), s9 = this.getInTransform();
    return null != s9 && pt(r7, r7, this.hasZ, this.hasM, s9), r7;
  }
  setCache(e4) {
    let t8 = this._caches.get(e4);
    null == t8 && (t8 = new a6(this.getSize()), this._caches.set(e4, t8)), this._activeCache = t8;
  }
  setCachedValue(e4) {
    this._activeCache.set(this.getIndex(), e4);
  }
  hasCachedValue() {
    return this._activeCache.has(this.getIndex());
  }
  getCachedValue() {
    return this._activeCache.get(this.getIndex());
  }
  _readGeometryDeltaDecoded(e4) {
    const t8 = this._readGeometry(e4);
    return "esriGeometryPoint" !== this.geometryType && t8 && this.getInTransform() ? t8.deltaDecode() : t8;
  }
  get contextTimeZone() {
    return this._contextTimeZone;
  }
  set contextTimeZone(e4) {
    this._contextTimeZone = e4;
  }
  readArcadeFeature() {
    return this;
  }
  hasField(e4) {
    return this.fields.has(e4) || this._joined.some((t8) => t8.hasField(e4));
  }
  geometry() {
    const e4 = this.readGeometryWorldSpace(), t8 = rt(e4, this.geometryType, this.hasZ, this.hasM), r7 = f(t8);
    if (r7) {
      if (!this.metadata.spatialReference) throw new Error("InternalError: Expected spatial reference to be defined");
      r7.spatialReference = this.metadata.spatialReference;
    }
    return r7;
  }
  autocastArcadeDate(t8, r7) {
    return r7 && r7 instanceof Date ? this.isUnknownDateTimeField(t8) ? m.unknownDateJSToArcadeDate(r7) : m.dateJSAndZoneToArcadeDate(r7, this.contextTimeZone ?? o) : r7;
  }
  isUnknownDateTimeField(e4) {
    return this.metadata.fieldsIndex.getTimeZone(e4) === r;
  }
  field(t8) {
    let i3 = this.fields.get(t8);
    if (i3) switch (i3.type) {
      case "date-only":
      case "esriFieldTypeDateOnly":
        return n3.fromReader(this.readAttribute(t8, false));
      case "time-only":
      case "esriFieldTypeTimeOnly":
        return n4.fromReader(this.readAttribute(t8, false));
      case "esriFieldTypeTimestampOffset":
      case "timestamp-offset":
        return m.fromReaderAsTimeStampOffset(this.readAttribute(t8, false));
      case "date":
      case "esriFieldTypeDate":
        return this.autocastArcadeDate(t8, this.readAttribute(t8, true));
      default:
        return this.readAttribute(t8, false);
    }
    for (const o4 of this._joined) if (o4.setIndex(this.getIndex()), i3 = o4.fields.get(t8), i3) switch (i3.type) {
      case "date-only":
      case "esriFieldTypeDateOnly":
        return n3.fromReader(o4._readAttribute(t8, false));
      case "time-only":
      case "esriFieldTypeTimeOnly":
        return n4.fromReader(o4._readAttribute(t8, false));
      case "esriFieldTypeTimestampOffset":
      case "timestamp-offset":
        return m.fromReaderAsTimeStampOffset(o4._readAttribute(t8, false));
      case "date":
      case "esriFieldTypeDate":
        return this.autocastArcadeDate(t8, o4._readAttribute(t8, true));
      default:
        return this.readAttribute(t8, false);
    }
    throw new Error(`Field ${t8} does not exist`);
  }
  setField(e4, t8) {
    throw new Error("Unable to update feature attribute values, feature is readonly");
  }
  keys() {
    return this.fields.fields.map((e4) => e4.name);
  }
  castToText(e4 = false) {
    if (!e4) return JSON.stringify(this.readLegacyFeatureForDisplay());
    const t8 = this.readLegacyFeatureForDisplay();
    if (!t8) return JSON.stringify(null);
    const r7 = { geometry: t8.geometry, attributes: { ...t8.attributes ?? {} } };
    for (const s9 in r7.attributes) {
      const e5 = r7.attributes[s9];
      e5 instanceof Date && (r7.attributes[s9] = e5.getTime());
    }
    return JSON.stringify(r7);
  }
  gdbVersion() {
    return null;
  }
  fullSchema() {
    return this.metadata.arcadeSchema;
  }
  castAsJson(e4 = null) {
    var _a;
    return { attributes: this._readAttributes(), geometry: true === (e4 == null ? void 0 : e4.keepGeometryType) ? this.geometry() : ((_a = this.geometry()) == null ? void 0 : _a.toJSON()) ?? null };
  }
  castAsJsonAsync(e4 = null, t8 = null) {
    return Promise.resolve(this.castAsJson(t8));
  }
  _getExists() {
    return null == this._deleted || !this._deleted.has(this.getIndex());
  }
  _computeDisplayCentroid(e4) {
    if (null == this.getInTransform()) return n5(new s2(), e4, this.hasM, this.hasZ);
    const t8 = a2.fromOptimized(e4, this.geometryType);
    t8.yFactor *= -1;
    const r7 = l3(t8);
    return r7 ? (r7[1] *= -1, new s2([], r7)) : null;
  }
  copyInto(e4) {
    e4._joined = this._joined, e4._deleted = this._deleted, e4._objectIdToIndex = this._objectIdToIndex, e4._boundsBuffer = this._boundsBuffer, e4._activeCache = this._activeCache, e4._caches = this._caches, e4._contextTimeZone = this._contextTimeZone;
  }
  _readLegacyGeometryWorldSpace() {
    const e4 = this.readGeometryWorldSpace();
    return rt(e4, this.geometryType, false, false);
  }
  _createGeometryFromServerCentroid() {
    const e4 = this._readServerCentroid();
    if (!e4) return null;
    const [t8, r7] = e4.coords;
    return this._createQuantizedExtrudedGeometry(t8, r7);
  }
  _createQuantizedExtrudedGeometry(e4, t8) {
    return "esriGeometryPolyline" === this.geometryType ? this._createQuantizedExtrudedLine(e4, t8) : this._createQuantizedExtrudedQuad(e4, t8);
  }
  _createQuantizedExtrudedQuad(e4, t8) {
    return new s2([5], [e4 - 1, t8, 1, -1, 1, 1, -1, 1, -1, -1]);
  }
  _createQuantizedExtrudedLine(e4, t8) {
    return new s2([2], [e4 - 1, t8 + 1, 1, -1]);
  }
  _removeAtIndex(e4) {
    null == this._deleted && (this._deleted = t5.create(this.getSize())), this._deleted.set(e4);
  }
};

export {
  n7 as n,
  s6 as s,
  s7 as s2,
  n8 as n2,
  t5 as t,
  a6 as a,
  M,
  p2 as p,
  t7 as t2,
  p3 as p2,
  i2 as i,
  n10 as n3,
  b2 as b
};
//# sourceMappingURL=chunk-2O2NCM6Y.js.map
