import {
  D,
  K
} from "./chunk-V4ENL6LP.js";
import {
  B2 as B,
  C,
  D2,
  M,
  a as a4,
  a2 as a5,
  a3 as a6,
  a5 as a7,
  c as c2,
  d as d2,
  d2 as d3,
  f as f4,
  h,
  l as l4,
  m as m3,
  n3 as n4,
  p as p3,
  r3 as r5,
  u as u2,
  w as w3,
  x
} from "./chunk-5XQEH26Y.js";
import {
  a2 as a3,
  c,
  f as f3,
  g,
  g2,
  i,
  i2,
  l,
  l2,
  l3,
  n as n3,
  o as o2,
  o2 as o3,
  p as p2,
  r as r4,
  s as s3,
  u,
  w as w2,
  y as y2
} from "./chunk-7PP3YNSG.js";
import {
  A
} from "./chunk-KKH7HGO3.js";
import {
  m as m2,
  p
} from "./chunk-RN66FJAW.js";
import {
  y
} from "./chunk-QCBTLG25.js";
import {
  n as n2
} from "./chunk-EZXLBRAS.js";
import {
  f as f2
} from "./chunk-3L2AYCZY.js";
import {
  r as r3
} from "./chunk-TSVUPARM.js";
import {
  d
} from "./chunk-6YWQXXBX.js";
import {
  j2 as j,
  w
} from "./chunk-FG3XOAFD.js";
import {
  o
} from "./chunk-GN5RE63N.js";
import {
  r as r2
} from "./chunk-2WXAPZBK.js";
import {
  z
} from "./chunk-E2I7HYXQ.js";
import {
  s as s2
} from "./chunk-WTNHDCCU.js";
import {
  n
} from "./chunk-7O7KFKCG.js";
import {
  f
} from "./chunk-HAF6QJ32.js";
import {
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  a,
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseFunctionArguments.js
var e = class extends f {
  constructor() {
    super(...arguments), this.raster = void 0;
  }
};
r([m({ json: { write: true } })], e.prototype, "raster", void 0), e = r([a2("esri.layers.support.rasterFunctions.BaseFunctionArguments")], e);
var p4 = e;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunctionArguments.js
var e2;
var a8 = e2 = class extends p4 {
  constructor() {
    super(...arguments), this.raster2 = void 0;
  }
  get rasters() {
    return [this.raster, this.raster2];
  }
  clone() {
    return new e2({ raster: this.raster, raster2: this.raster2, operation: this.operation });
  }
};
r([m({ json: { write: true } })], a8.prototype, "operation", void 0), r([m({ json: { write: true } })], a8.prototype, "raster2", void 0), r([m({ readOnly: true })], a8.prototype, "rasters", null), a8 = e2 = r([a2("esri.layers.support.rasterFunctions.ArithmeticFunctionArguments")], a8);
var i3 = a8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BaseRasterFunction.js
var a9 = /* @__PURE__ */ new Set(["slope", "aspect", "curvature", "hillshade", "shadedrelief", "statistics"]);
var u3 = class extends f {
  constructor() {
    super(...arguments), this.functionArguments = null, this.readingBufferSize = 0, this.id = -1, this.isNoopProcess = false, this.rawInputBandIds = [], this.rawSourceRasterInfos = null, this.isInputBandIdsSwizzled = false, this.swizzledBandSelection = [], this.isBranch = false, this._bindingResult = null;
  }
  get supportsGPU() {
    return this._bindingResult.supportsGPU;
  }
  get flatWebGLFunctionChain() {
    var _a;
    const t7 = this.getWebGLProcessorDefinition();
    if (!t7) return null;
    const s12 = [t7], { parameters: e9 } = t7;
    let r12 = e9.rasters || e9.raster && [e9.raster];
    for (; r12 == null ? void 0 : r12.length; ) {
      s12.unshift(...r12);
      const t8 = [];
      for (let s13 = 0; s13 < r12.length; s13++) {
        const { parameters: e10 } = r12[s13], i29 = e10.rasters || e10.raster && [e10.raster];
        (i29 == null ? void 0 : i29.length) && t8.push(...i29);
      }
      r12 = t8;
    }
    for (let a35 = s12.length - 1; a35 >= 0; a35--) s12[a35].isNoopProcess && s12.splice(a35, 1);
    let i28 = false;
    for (let a35 = 0; a35 < s12.length; a35++) {
      const t8 = s12[a35];
      t8.id = s12.length - a35 - 1;
      const { rasters: e10 } = t8.parameters;
      i28 = i28 || null != e10 && e10.length > 1;
    }
    const n21 = s12.some(({ name: t8 }) => a9.has(t8.toLowerCase())), { rawSourceRasterInfos: o10 } = this;
    return { functions: s12, hasBranches: i28, hasFocalFunction: n21, isSourceSingleBand: 1 === ((_a = o10 == null ? void 0 : o10[0]) == null ? void 0 : _a.bandCount) };
  }
  bind(t7, s12 = false, e9 = -1) {
    this.id = e9 + 1;
    const r12 = this._getRasterValues();
    let i28 = true;
    for (let n21 = 0; n21 < r12.length; n21++) {
      const e10 = r12[n21];
      if (null != e10 && this._isRasterFunctionValue(e10)) {
        const r13 = e10.bind(t7, s12, this.id + n21);
        if (!r13.success) return this._bindingResult = r13, r13;
        i28 = i28 && r13.supportsGPU;
      }
    }
    return !this.rasterInfo || s12 ? (this.sourceRasterInfos = this._getSourceRasterInfos(t7), this._bindingResult = this._bindSourceRasters(), this._bindingResult.success && this._patchRasterInfo(), this._bindingResult.supportsGPU = i28 && this._bindingResult.supportsGPU, this.processInputBandIds(), this._bindingResult) : (this._bindingResult = { success: true, supportsGPU: true }, this.processInputBandIds(), this._bindingResult);
  }
  process(t7) {
    const s12 = this._getRasterValues(), e9 = 0 === s12.length ? t7.pixelBlocks ?? t7.primaryPixelBlocks : s12.map((s13) => this._readRasterValue(s13, t7));
    return this._processPixels({ ...t7, pixelBlocks: e9 });
  }
  processInputBandIds() {
    const t7 = this._getRasterValues().filter(this._isRasterFunctionValue);
    let s12;
    if (t7.length > 1) {
      const s13 = t7.map((t8) => t8.processInputBandIds()[0]);
      this.rawInputBandIds = s13, this.isInputBandIdsSwizzled = this.rawInputBandIds.some((t8, s14) => t8 !== s14);
      const e10 = t7.filter((t8) => "ExtractBand" === t8.functionName);
      return e10.length && e10.forEach((t8, s14) => {
        t8.isInputBandIdsSwizzled = true, t8.swizzledBandSelection = [s14, s14, s14];
      }), this.rawInputBandIds;
    }
    const e9 = t7[0];
    if (e9) {
      if (s12 = e9.processInputBandIds(), e9.isInputBandIdsSwizzled) return this.rawInputBandIds = s12, s12;
    } else {
      s12 = [];
      const { bandCount: t8 } = this.sourceRasterInfos[0];
      for (let e10 = 0; e10 < t8; e10++) s12.push(e10);
    }
    const r12 = this._getInputBandIds(s12);
    return this.isInputBandIdsSwizzled = r12.some((t8, s13) => t8 !== s13), this.rawInputBandIds = r12, this.rawInputBandIds;
  }
  getPrimaryRasters() {
    const t7 = [], s12 = [];
    return this._getPrimaryRasters(this, t7, s12), { rasters: t7, rasterIds: s12 };
  }
  getWebGLProcessorDefinition() {
    const t7 = this._getWebGLParameters(), { raster: s12, rasters: e9 } = this.functionArguments;
    return e9 && Array.isArray(e9) && e9.length ? (t7.rasters = e9.map((t8) => this._isRasterFunctionValue(t8) ? t8.getWebGLProcessorDefinition() : "number" == typeof t8 ? { name: "Constant", parameters: { value: t8 }, pixelType: "f32", id: -1, isNoopProcess: false } : { name: "Identity", parameters: { value: t8 }, pixelType: "f32", id: -1, isNoopProcess: false }), t7.rasters.some((t8) => null != t8) || (t7.rasters = null)) : this._isRasterFunctionValue(s12) && (t7.raster = s12.getWebGLProcessorDefinition()), { name: this.functionName, parameters: t7, pixelType: this.outputPixelType, id: this.id, isNoopProcess: this.isNoopProcess };
  }
  getClippingGeometries() {
    const t7 = [];
    "Clip" === this.functionName && t7.push(this.functionArguments);
    const { raster: s12, rasters: e9 } = this.functionArguments;
    if (e9 && Array.isArray(e9) && e9.length) e9.forEach((s13) => {
      if (this._isRasterFunctionValue(s13)) {
        const e10 = s13.getClippingGeometries();
        t7.push(...e10);
      }
    });
    else if (this._isRasterFunctionValue(s12)) {
      const e10 = s12.getClippingGeometries();
      t7.push(...e10);
    }
    return t7;
  }
  _getOutputPixelType(t7) {
    return "unknown" === this.outputPixelType ? t7 : this.outputPixelType ?? t7;
  }
  _getWebGLParameters() {
    return {};
  }
  _getInputBandIds(t7) {
    return t7;
  }
  _removeStatsHistColormapVAT(t7) {
    var _a;
    t7.statistics = null, t7.histograms = null, t7.colormap = null, t7.attributeTable = null, (_a = t7.multidimensionalInfo) == null ? void 0 : _a.variables.forEach((t8) => {
      t8.statistics = void 0, t8.histograms = void 0;
    });
  }
  _getRasterValues() {
    const { rasterArgumentNames: t7 } = this;
    return "rasters" === t7[0] ? this.functionArguments.rasters ?? [] : t7.flatMap((t8) => this.functionArguments[t8]);
  }
  _getSourceRasterInfos(t7) {
    const s12 = this._getRasterValues(), { rasterInfos: e9, rasterIds: r12 } = t7;
    if (0 === s12.length) return e9;
    const i28 = s12.map((t8) => t8 && "object" == typeof t8 && "bind" in t8 && t8.rasterInfo ? t8.rasterInfo : "string" == typeof t8 && r12.includes(t8) ? e9[r12.indexOf(t8)] : "number" != typeof t8 ? e9[0] : void 0), n21 = i28.find((t8) => t8) ?? e9[0];
    return i28.forEach((t8, s13) => {
      void 0 === t8 && (i28[s13] = n21);
    }), i28;
  }
  _getPrimaryRasterId(t7) {
    return t7 == null ? void 0 : t7.rasterId;
  }
  _getPrimaryRasters(t7, s12 = [], e9 = []) {
    for (let r12 = 0; r12 < t7.sourceRasters.length; r12++) {
      const i28 = t7.sourceRasters[r12];
      if ("number" != typeof i28) if ("bind" in i28) this._getPrimaryRasters(i28, s12, e9);
      else {
        const t8 = i28, r13 = this._getPrimaryRasterId(t8);
        if (null == r13) continue;
        e9.includes(r13) || (this.mainPrimaryRasterId === r13 ? (s12.unshift(t8), e9.unshift(r13)) : (s12.push(t8), e9.push(r13)));
      }
    }
  }
  _isRasterFunctionValue(t7) {
    return null != t7 && "object" == typeof t7 && "getWebGLProcessorDefinition" in t7;
  }
  _readRasterValue(t7, s12) {
    const { primaryPixelBlocks: e9 } = s12;
    if (null == t7 || "$$" === t7) {
      const t8 = e9[0];
      return null == t8 ? null : t8.clone();
    }
    if ("string" == typeof t7) {
      const r12 = s12.primaryRasterIds.indexOf(t7);
      return -1 === r12 ? null : e9[r12];
    }
    if ("number" == typeof t7) {
      const s13 = e9[0];
      if (null == s13) return null;
      const { width: r12, height: i28, pixelType: o10 } = s13, a35 = new Float32Array(r12 * i28);
      a35.fill(t7);
      const u21 = this.sourceRasterInfos[0].bandCount, p21 = new Array(u21).fill(a35);
      return new g({ width: r12, height: i28, pixelType: o10, pixels: p21 });
    }
    return t7.process(s12);
  }
  _patchRasterInfo() {
    const { rasterInfo: t7 } = this;
    if (!(t7 == null ? void 0 : t7.keyProperties)) return;
    const { bandCount: s12, keyProperties: e9, statistics: r12, histograms: i28 } = t7, n21 = e9.BandProperties;
    n21 && n21.length !== s12 && (t7.keyProperties = { ...e9, BandProperties: void 0 }), r12 && r12.length !== s12 && (t7.statistics = r12.length > s12 ? r12.slice(0, s12) : null), i28 && i28.length !== s12 && (t7.histograms = i28.length > s12 ? i28.slice(0, s12) : null), e9.BAND_COUNT && Number(e9.BAND_COUNT) !== s12 && (t7.keyProperties = { ...e9, BAND_COUNT: "string" == typeof e9.BAND_COUNT ? String(s12) : s12 });
  }
};
r([m({ json: { write: true } })], u3.prototype, "functionName", void 0), r([m({ json: { write: true } })], u3.prototype, "functionArguments", void 0), r([m()], u3.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } }), s2((t7) => t7 == null ? void 0 : t7.toLowerCase())], u3.prototype, "outputPixelType", void 0), r([m({ json: { write: true } })], u3.prototype, "mainPrimaryRasterId", void 0), r([m()], u3.prototype, "sourceRasters", void 0), r([m({ type: [m3], json: { write: true } })], u3.prototype, "sourceRasterInfos", void 0), r([m({ json: { write: true } })], u3.prototype, "rasterInfo", void 0), r([m({ json: { write: true } })], u3.prototype, "readingBufferSize", void 0), r([m({ json: { write: true } })], u3.prototype, "id", void 0), r([m()], u3.prototype, "isNoopProcess", void 0), r([m()], u3.prototype, "supportsGPU", null), r([m()], u3.prototype, "rawInputBandIds", void 0), r([m()], u3.prototype, "rawSourceRasterInfos", void 0), r([m()], u3.prototype, "isInputBandIdsSwizzled", void 0), r([m()], u3.prototype, "swizzledBandSelection", void 0), r([m()], u3.prototype, "isBranch", void 0), r([m({ readOnly: true })], u3.prototype, "flatWebGLFunctionChain", null), r([m()], u3.prototype, "_bindingResult", void 0), u3 = r([a2("esri.layers.support.rasterFunctions.BaseRasterFunction")], u3);
var p5 = u3;

// node_modules/@arcgis/core/layers/support/rasterFunctionConstants.js
var g3 = { userDefined: -1, lineDetectionHorizontal: 0, lineDetectionVertical: 1, lineDetectionLeftDiagonal: 2, lineDetectionRightDiagonal: 3, gradientNorth: 4, gradientWest: 5, gradientEast: 6, gradientSouth: 7, gradientNorthEast: 8, gradientNorthWest: 9, smoothArithmeticMean: 10, smoothing3x3: 11, smoothing5x5: 12, sharpening3x3: 13, sharpening5x5: 14, laplacian3x3: 15, laplacian5x5: 16, sobelHorizontal: 17, sobelVertical: 18, sharpen: 19, sharpen2: 20, pointSpread: 21, none: 255 };
var u4 = { plus: 1, minus: 2, times: 3, sqrt: 4, power: 5, abs: 10, divide: 23, exp: 25, exp10: 26, exp2: 27, int: 30, float: 32, ln: 35, log10: 36, log2: 37, mod: 44, negate: 45, roundDown: 48, roundUp: 49, square: 53, floatDivide: 64, floorDivide: 65 };
var d4 = { bitwiseAnd: 11, bitwiseLeftShift: 12, bitwiseNot: 13, bitwiseOr: 14, bitwiseRightShift: 15, bitwiseXOr: 16, booleanAnd: 17, booleanNot: 18, booleanOr: 19, booleanXOr: 20, equalTo: 24, greaterThan: 28, greaterThanEqual: 29, lessThan: 33, lessThanEqual: 34, isNull: 31, notEqual: 46 };
var s4 = { acos: 6, asin: 7, atan: 8, atanh: 9, cos: 21, cosh: 22, sin: 51, sinh: 52, tan: 56, tanh: 57, acosh: 59, asinh: 60, atan2: 61 };
var p6 = { majority: 38, max: 39, mean: 40, med: 41, min: 42, minority: 43, range: 47, stddev: 54, sum: 55, variety: 58, majorityIgnoreNoData: 66, maxIgnoreNoData: 67, meanIgnoreNoData: 68, medIgnoreNoData: 69, minIgnoreNoData: 70, minorityIgnoreNoData: 71, rangeIgnoreNoData: 72, stddevIgnoreNoData: 73, sumIgnoreNoData: 74, varietyIgnoreNoData: 75 };
var c3 = { setNull: 50, conditional: 78 };
var B2 = { ...u4, ...d4, ...s4, ...p6, ...c3 };

// node_modules/@arcgis/core/layers/support/rasterFunctions/localUtils.js
var a10 = /* @__PURE__ */ new Map([[s4.acos, { domain: [0, Math.PI], isInteger: false }], [s4.asin, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [s4.atan, { domain: [-Math.PI / 2, Math.PI / 2], isInteger: false }], [s4.cos, { domain: [-1, 1], isInteger: false }], [s4.sin, { domain: [-1, 1], isInteger: false }], [d4.booleanAnd, { domain: [0, 1], isInteger: true }], [d4.booleanNot, { domain: [0, 1], isInteger: true }], [d4.booleanOr, { domain: [0, 1], isInteger: true }], [d4.booleanXOr, { domain: [0, 1], isInteger: true }], [d4.equalTo, { domain: [0, 1], isInteger: true }], [d4.notEqual, { domain: [0, 1], isInteger: true }], [d4.greaterThan, { domain: [0, 1], isInteger: true }], [d4.greaterThanEqual, { domain: [0, 1], isInteger: true }], [d4.lessThan, { domain: [0, 1], isInteger: true }], [d4.lessThanEqual, { domain: [0, 1], isInteger: true }], [d4.isNull, { domain: [0, 1], isInteger: true }]]);
function l5(t7) {
  return a10.get(t7);
}
var c4 = [0, 2, 2, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 999, 999, 999, 999, 999, 999, 2, 1, 2, 999, 1, 1, 2, 1, 1, 1, 999, 999, 1, 1, 999, 1, 1, 2, 999, 999, 2, 2, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 3, 999, 3];
function f5(t7, e9 = false) {
  const n21 = t7.map((t8) => t8.mask), r12 = n21.filter((t8) => null != t8), o10 = t7[0].pixels[0].length;
  if (0 === r12.length || e9 && r12.length !== n21.length) return new Uint8Array(o10).fill(255);
  const s12 = r12[0], a35 = new Uint8Array(s12);
  if (1 === r12.length) return a35;
  if (!e9) {
    for (let t8 = 1; t8 < r12.length; t8++) {
      const e10 = r12[t8];
      for (let t9 = 0; t9 < a35.length; t9++) a35[t9] && (a35[t9] = e10[t9] ? 255 : 0);
    }
    return a35;
  }
  for (let l23 = 1; l23 < r12.length; l23++) {
    const t8 = r12[l23];
    for (let e10 = 0; e10 < a35.length; e10++) 0 === a35[e10] && (a35[e10] = t8[e10] ? 255 : 0);
  }
  return a35;
}
function i4(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] + s12[t7]);
  return l23;
}
function u5(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand("f32", s12);
  return a35.set(o10), a35;
}
function h2(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  for (let t7 = 0; t7 < s12; t7++) n21 && !n21[t7] || (a35[t7] = o10[t7] * o10[t7]);
  return a35;
}
function g4(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] - s12[t7]);
  return l23;
}
function p7(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] * s12[t7]);
  return l23;
}
function m4(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  for (let t7 = 0; t7 < s12; t7++) n21 && !n21[t7] || (a35[t7] = Math.sign(o10[t7]) * Math.floor(Math.abs(o10[t7])));
  return a35;
}
function d5(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] / s12[t7]);
  return l23;
}
function y3(t7, e9, n21) {
  return d5(t7, e9, "f32");
}
function E(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = Math.floor(o10[t7] / s12[t7]));
  return l23;
}
function M2(n21, r12, o10, s12) {
  const a35 = n21[0], l23 = a35.length, c36 = g.createEmptyBand(o10, l23);
  if (s12 === s4.atanh) {
    for (let t7 = 0; t7 < l23; t7++) if (r12[t7]) {
      const e9 = a35[t7];
      Math.abs(e9) >= 1 ? r12[t7] = 0 : c36[t7] = Math.atanh(e9);
    }
    return c36;
  }
  const f7 = s12 === s4.asin ? Math.asin : Math.acos;
  for (let t7 = 0; t7 < l23; t7++) if (r12[t7]) {
    const e9 = a35[t7];
    Math.abs(e9) > 1 ? r12[t7] = 0 : c36[t7] = f7(e9);
  }
  return c36;
}
function B3(e9, n21, r12, o10) {
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10(s12[t7]));
  return l23;
}
function I(e9, n21, r12, o10) {
  const [s12, a35] = e9, l23 = s12.length, c36 = g.createEmptyBand(r12, l23);
  for (let t7 = 0; t7 < l23; t7++) n21 && !n21[t7] || (c36[t7] = o10(s12[t7], a35[t7]));
  return c36;
}
function w4(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] & s12[t7]);
  return l23;
}
function x2(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] << s12[t7]);
  return l23;
}
function b(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  for (let t7 = 0; t7 < s12; t7++) n21 && !n21[t7] || (a35[t7] = ~o10[t7]);
  return a35;
}
function A2(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] | s12[t7]);
  return l23;
}
function P(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] >> s12[t7]);
  return l23;
}
function T(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] ^ s12[t7]);
  return l23;
}
function k(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] && s12[t7] ? 1 : 0);
  return l23;
}
function q(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  for (let t7 = 0; t7 < s12; t7++) n21 && !n21[t7] || (a35[t7] = o10[t7] ? 0 : 1);
  return a35;
}
function N(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] || s12[t7] ? 1 : 0);
  return l23;
}
function U(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = (o10[t7] ? 1 : 0) ^ (s12[t7] ? 1 : 0));
  return l23;
}
function F(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] === s12[t7] ? 1 : 0);
  return l23;
}
function j2(e9, n21, r12, o10) {
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35), c36 = o10 === Math.E;
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = c36 ? Math.exp(s12[t7]) : o10 ** s12[t7]);
  return l23;
}
function z2(t7, e9, n21) {
  return j2(t7, e9, n21, 10);
}
function O(t7, e9, n21) {
  return j2(t7, e9, n21, 2);
}
function C2(t7, e9, n21) {
  return j2(t7, e9, n21, Math.E);
}
function R(e9, n21, r12, o10) {
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (s12[t7] <= 0 ? n21[t7] = 0 : l23[t7] = o10(s12[t7]));
  return l23;
}
function S(t7, e9, n21) {
  return R(t7, e9, n21, Math.log10);
}
function X(t7, e9, n21) {
  return R(t7, e9, n21, Math.log2);
}
function v(t7, e9, n21) {
  return R(t7, e9, n21, Math.log);
}
function D3(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] > s12[t7] ? 1 : 0);
  return l23;
}
function G(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] >= s12[t7] ? 1 : 0);
  return l23;
}
function H(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] < s12[t7] ? 1 : 0);
  return l23;
}
function J(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] <= s12[t7] ? 1 : 0);
  return l23;
}
function K2(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  if (!n21) return a35;
  for (let t7 = 0; t7 < s12; t7++) a35[t7] = n21[t7] ? 0 : 1;
  return a35;
}
function L(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] % s12[t7]);
  return l23;
}
function Q(e9, n21, r12) {
  const [o10] = e9, s12 = o10.length, a35 = g.createEmptyBand(r12, s12);
  for (let t7 = 0; t7 < s12; t7++) n21 && !n21[t7] || (a35[t7] = -o10[t7]);
  return a35;
}
function V(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] === s12[t7] ? 0 : 1);
  return l23;
}
function W(e9, n21, r12) {
  const [o10, s12] = e9, a35 = o10.length, l23 = g.createEmptyBand(r12, a35), c36 = new Uint8Array(a35);
  for (let t7 = 0; t7 < a35; t7++) null != n21 && !n21[t7] || 0 !== o10[t7] || (l23[t7] = s12[t7], c36[t7] = 255);
  return { band: l23, mask: c36 };
}
function Y(e9, n21, r12) {
  const [o10, s12, a35] = e9, l23 = o10.length, c36 = g.createEmptyBand(r12, l23);
  for (let t7 = 0; t7 < l23; t7++) n21 && !n21[t7] || (c36[t7] = o10[t7] ? s12[t7] : a35[t7]);
  return c36;
}
function Z(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    let n22 = s12[t7];
    for (let r13 = 1; r13 < o10; r13++) {
      const o11 = e9[r13][t7];
      n22 < o11 && (n22 = o11);
    }
    l23[t7] = n22;
  }
  return l23;
}
function $(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    let n22 = s12[t7];
    for (let r13 = 1; r13 < o10; r13++) {
      const o11 = e9[r13][t7];
      n22 > o11 && (n22 = o11);
    }
    l23[t7] = n22;
  }
  return l23;
}
function _(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    let n22 = s12[t7], r13 = n22;
    for (let s13 = 1; s13 < o10; s13++) {
      const o11 = e9[s13][t7];
      r13 < o11 ? r13 = o11 : n22 > o11 && (n22 = o11);
    }
    l23[t7] = r13 - n22;
  }
  return l23;
}
function tt(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    let n22 = 0;
    for (let r13 = 0; r13 < o10; r13++) n22 += e9[r13][t7];
    l23[t7] = n22 / o10;
  }
  return l23;
}
function et(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) for (let n22 = 0; n22 < o10; n22++) {
    const r13 = e9[n22];
    l23[t7] += r13[t7];
  }
  return l23;
}
function nt(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    const n22 = new Float32Array(o10);
    let r13 = 0;
    for (let a36 = 0; a36 < o10; a36++) {
      const o11 = e9[a36];
      r13 += o11[t7], n22[a36] = o11[t7];
    }
    r13 /= o10;
    let s13 = 0;
    for (let t8 = 0; t8 < o10; t8++) s13 += (n22[t8] - r13) ** 2;
    l23[t7] = Math.sqrt(s13 / o10);
  }
  return l23;
}
function rt(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const s12 = Math.floor(o10 / 2), [a35] = e9, l23 = a35.length, c36 = g.createEmptyBand(r12, l23), f7 = new Float32Array(o10), i28 = o10 % 2 == 1;
  for (let t7 = 0; t7 < l23; t7++) if (!n21 || n21[t7]) {
    for (let n22 = 0; n22 < o10; n22++) f7[n22] = e9[n22][t7];
    f7.sort(), c36[t7] = i28 ? f7[s12] : (f7[s12] + f7[s12 - 1]) / 2;
  }
  return c36;
}
function ot(e9, n21, r12) {
  const [o10, s12] = e9;
  if (null == s12) return o10;
  const a35 = o10.length, l23 = g.createEmptyBand(r12, a35);
  for (let t7 = 0; t7 < a35; t7++) n21 && !n21[t7] || (l23[t7] = o10[t7] < s12[t7] ? o10[t7] : s12[t7]);
  return l23;
}
function st(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 <= 2) return ot(e9, n21, r12);
  const s12 = e9[0].length, a35 = g.createEmptyBand(r12, s12), l23 = /* @__PURE__ */ new Map();
  for (let t7 = 0; t7 < s12; t7++) if (!n21 || n21[t7]) {
    l23.clear();
    for (let a36 = 0; a36 < o10; a36++) {
      const n23 = e9[a36][t7];
      l23.set(n23, l23.has(n23) ? l23.get(n23) + 1 : 1);
    }
    let n22 = 0, r13 = 0;
    const s13 = [];
    for (const t8 of l23.keys()) n22 = l23.get(t8), n22 > r13 ? (r13 = n22, s13.length = 0, s13.push(t8)) : n22 === r13 && s13.push(t8);
    s13.length > 1 && s13.sort((t8, e10) => t8 - e10), a35[t7] = s13[0];
  }
  return a35;
}
function at(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 <= 2) return ot(e9, n21, r12);
  const s12 = e9[0].length, a35 = g.createEmptyBand(r12, s12), l23 = /* @__PURE__ */ new Map();
  for (let t7 = 0; t7 < s12; t7++) if (!n21 || n21[t7]) {
    l23.clear();
    for (let a36 = 0; a36 < o10; a36++) {
      const n23 = e9[a36][t7];
      l23.set(n23, l23.has(n23) ? l23.get(n23) + 1 : 1);
    }
    let n22 = 0, r13 = e9.length;
    const s13 = [];
    for (const t8 of l23.keys()) n22 = l23.get(t8), n22 < r13 ? (r13 = n22, s13.length = 0, s13.push(t8)) : n22 === r13 && s13.push(t8);
    s13.length > 1 && s13.sort((t8, e10) => t8 - e10), a35[t7] = s13[0];
  }
  return a35;
}
function lt(e9, n21, r12) {
  const o10 = e9.length;
  if (o10 < 2) return e9[0];
  const [s12] = e9, a35 = s12.length, l23 = g.createEmptyBand(r12, a35), c36 = /* @__PURE__ */ new Set();
  for (let t7 = 0; t7 < a35; t7++) if (!n21 || n21[t7]) {
    let n22;
    c36.clear();
    for (let r13 = 0; r13 < o10; r13++) n22 = e9[r13][t7], c36.add(n22);
    l23[t7] = c36.size;
  }
  return l23;
}
var ct = /* @__PURE__ */ new Map();
var ft = /* @__PURE__ */ new Map();
var it = /* @__PURE__ */ new Map();
var ut = /* @__PURE__ */ new Map();
function ht() {
  ct.size || (ct.set(4, Math.sqrt), ct.set(6, Math.acos), ct.set(7, Math.asin), ct.set(8, Math.atan), ct.set(9, Math.atanh), ct.set(10, Math.abs), ct.set(21, Math.cos), ct.set(22, Math.cosh), ct.set(48, Math.floor), ct.set(49, Math.ceil), ct.set(51, Math.sin), ct.set(52, Math.sinh), ct.set(56, Math.tan), ct.set(57, Math.tanh), ct.set(59, Math.acosh), ct.set(60, Math.asinh), ct.set(65, Math.floor), ft.set(5, Math.pow), ft.set(61, Math.atan2), it.set(1, i4), it.set(2, g4), it.set(3, p7), it.set(11, w4), it.set(12, x2), it.set(13, b), it.set(14, A2), it.set(15, P), it.set(16, T), it.set(17, k), it.set(18, q), it.set(19, N), it.set(20, U), it.set(23, d5), it.set(24, F), it.set(25, C2), it.set(26, z2), it.set(27, O), it.set(28, D3), it.set(29, G), it.set(30, m4), it.set(31, K2), it.set(32, u5), it.set(33, H), it.set(34, J), it.set(35, v), it.set(36, S), it.set(37, X), it.set(44, L), it.set(45, Q), it.set(46, V), it.set(53, h2), it.set(64, y3), it.set(65, E), it.set(76, Y), it.set(78, Y), ut.set(38, st), ut.set(39, Z), ut.set(40, tt), ut.set(41, rt), ut.set(42, $), ut.set(43, at), ut.set(47, _), ut.set(54, nt), ut.set(55, et), ut.set(58, lt), ut.set(66, st), ut.set(67, Z), ut.set(68, tt), ut.set(69, rt), ut.set(70, $), ut.set(71, at), ut.set(72, _), ut.set(73, nt), ut.set(74, et), ut.set(75, lt));
}
function gt(l23, c36, i28 = {}) {
  ht();
  let u21 = f5(l23, c36 >= 66 && c36 <= 75);
  const { outputPixelType: h7 = "f32" } = i28, g7 = !ut.has(c36) || i28.processAsMultiband, p21 = g7 ? l23[0].pixels.length : 1, m17 = [];
  for (let f7 = 0; f7 < p21; f7++) {
    const i29 = ut.has(c36) && !g7 ? l23.flatMap((t7) => t7.pixels) : l23.map((t7) => t7.pixels[f7]);
    let p22, d11 = true;
    if (c36 === c3.setNull) {
      const t7 = W(i29, u21, h7);
      p22 = t7.band, u21 = t7.mask, d11 = false;
    } else if (it.has(c36)) {
      p22 = it.get(c36)(i29, u21, "f64");
    } else if (ct.has(c36)) p22 = c36 === s4.asin || c36 === s4.acos || c36 === s4.atanh ? M2(i29, u21, "f64", c36) : B3(i29, u21, "f64", ct.get(c36));
    else if (ft.has(c36)) p22 = I(i29, u21, "f64", ft.get(c36));
    else if (ut.has(c36)) {
      p22 = ut.get(c36)(i29, u21, "f64");
    } else p22 = i29[0], d11 = false;
    if (d11 && c36 !== d4.isNull && !a10.has(c36)) {
      const e9 = g.createEmptyBand(h7, p22.length);
      u21 || (u21 = new Uint8Array(p22.length).fill(255)), l2(p22, u21), i(p22, u21, h7, e9), p22 = e9;
    }
    m17.push(p22);
  }
  const d10 = l23[0];
  return new g({ width: d10.width, height: d10.height, pixelType: h7, mask: c36 === d4.isNull ? null : u21, pixels: m17 });
}
function pt(t7, e9, n21) {
  return gt(t7, e9 = [null, 1, 2, 3, 23, 5, 44][e9] ?? 1, { outputPixelType: n21 });
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ArithmeticFunction.js
var p8 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Arithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster", "raster2"];
  }
  _bindSourceRasters() {
    const { operation: t7 } = this.functionArguments;
    if (t7 < 1 || t7 > 6) return { success: false, supportsGPU: false, error: "unsupported operation" };
    const e9 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e9.pixelType), e9.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 };
  }
  _processPixels(t7) {
    const { pixelBlocks: e9 } = t7;
    return null == (e9 == null ? void 0 : e9[0]) || null == (e9 == null ? void 0 : e9[1]) ? null : pt(e9, this.functionArguments.operation, this.outputPixelType);
  }
  _getWebGLParameters() {
    const { operation: t7 } = this.functionArguments, e9 = ["", "plus", "minus", "times", "divide", "power", "mod"][t7], r12 = this.outputPixelType ?? "f32";
    let [i28, n21] = s3(r12);
    const u21 = o2(r12);
    return u21 && (i28 -= 1e-4, n21 += 1e-4), { imageCount: 2, operationName: e9, domainRange: [i28, n21], isOutputRounded: u21 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], p8.prototype, "functionName", void 0), r([m({ type: i3, json: { write: true, name: "rasterFunctionArguments" } })], p8.prototype, "functionArguments", void 0), r([m()], p8.prototype, "rasterArgumentNames", void 0), p8 = r([a2("esri.layers.support.rasterFunctions.ArithmeticFunction")], p8);
var a11 = p8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunctionArguments.js
var t;
var e3 = t = class extends p4 {
  clone() {
    return new t({ raster: this.raster });
  }
};
e3 = t = r([a2("esri.layers.support.rasterFunctions.AspectFunctionArguments")], e3);
var c5 = e3;

// node_modules/@arcgis/core/layers/support/rasterFunctions/AspectFunction.js
var n5 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Aspect", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    const t7 = this.sourceRasterInfos[0];
    this.isGCS = ((_a = t7.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, this.outputPixelType = this._getOutputPixelType("f32");
    const s12 = t7.clone();
    return s12.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(s12), s12.statistics = [{ min: -1, max: 360, avg: 180, stddev: 30 }], s12.bandCount = 1, this.rasterInfo = s12, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s12) return null;
    const { extent: e9, primaryPixelSizes: r12 } = t7, o10 = r12 == null ? void 0 : r12[0], n21 = o10 ?? (e9 ? { x: e9.width / s12.width, y: e9.height / s12.height } : { x: 1, y: 1 });
    return u2(s12, { resolution: n21 });
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], n5.prototype, "functionName", void 0), r([m({ type: c5, json: { write: true, name: "rasterFunctionArguments" } })], n5.prototype, "functionArguments", void 0), r([m()], n5.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], n5.prototype, "isGCS", void 0), n5 = r([a2("esri.layers.support.rasterFunctions.AspectFunction")], n5);
var p9 = n5;

// node_modules/@arcgis/core/layers/support/rasterFunctions/customBandIndexUtils.js
var e4 = /* @__PURE__ */ new Set(["+", "-", "*", "/", "(", ")"]);
function t2(t7, r12) {
  (t7 = t7.replaceAll(" ", "")).startsWith("-") && (t7 = "0" + t7), t7.startsWith("+") && (t7 = t7.slice(1));
  const l23 = t7.split(""), o10 = [], s12 = [];
  let a35 = "";
  for (let i28 = 0; i28 < l23.length; i28++) {
    const t8 = l23[i28];
    e4.has(t8) ? (a35.length && s12.push(n6(a35, r12)), o10.push(t8), a35 = "") : a35 = a35.concat(t8);
  }
  return a35.length && s12.push(n6(a35, r12)), { ops: o10, nums: s12 };
}
function n6(e9, t7) {
  return e9.toLowerCase().startsWith("b") ? t7[parseInt(e9.slice(1), 10) - 1] : parseFloat(e9);
}
function r6(e9, t7, n21, r12) {
  if ("number" == typeof n21 && "number" == typeof r12) return n21 + r12;
  let l23, o10, s12;
  "number" == typeof n21 ? (s12 = r12, l23 = s12.length, o10 = new Float32Array(l23), o10.fill(n21)) : (l23 = n21.length, o10 = n21, r12.constructor === Number ? (s12 = new Float32Array(l23), s12.fill(r12)) : s12 = r12);
  const a35 = new Float32Array(l23);
  switch (t7) {
    case "+":
      for (let t8 = 0; t8 < l23; t8++) (null == e9 || e9[t8]) && (a35[t8] = o10[t8] + s12[t8]);
      break;
    case "-":
      for (let t8 = 0; t8 < l23; t8++) (null == e9 || e9[t8]) && (a35[t8] = o10[t8] - s12[t8]);
      break;
    case "*":
      for (let t8 = 0; t8 < l23; t8++) (null == e9 || e9[t8]) && (a35[t8] = o10[t8] * s12[t8]);
      break;
    case "/":
      for (let t8 = 0; t8 < l23; t8++) (null == e9 || e9[t8]) && s12[t8] && (a35[t8] = o10[t8] / s12[t8]);
      break;
    case "(":
    case ")":
      throw new Error("encountered error with custom band index equation");
  }
  return a35;
}
function l6(e9, t7) {
  e9.splice(t7, 1);
  let n21 = 0, r12 = 0;
  do {
    n21 = 0, r12 = 0;
    for (let t8 = 0; t8 < e9.length; t8++) if ("(" === e9[t8]) n21 = t8;
    else if (")" === e9[t8]) {
      r12 = t8;
      break;
    }
    r12 === n21 + 1 && e9.splice(n21, 2);
  } while (r12 === n21 + 1);
  return e9;
}
function o4(e9) {
  if (1 === e9.length) return { opIndex: 0, numIndex: 0 };
  let t7 = 0, n21 = 0;
  for (let s12 = 0; s12 < e9.length; s12++) if ("(" === e9[s12]) t7 = s12;
  else if (")" === e9[s12]) {
    n21 = s12;
    break;
  }
  const r12 = 0 === n21 ? e9 : e9.slice(t7 + 1, n21);
  let l23 = -1;
  for (let s12 = 0; s12 < r12.length; s12++) if ("*" === r12[s12] || "/" === r12[s12]) {
    l23 = s12;
    break;
  }
  if (l23 > -1) n21 > 0 && (l23 += t7 + 1);
  else {
    for (let e10 = 0; e10 < r12.length; e10++) if ("+" === r12[e10] || "-" === r12[e10]) {
      l23 = e10;
      break;
    }
    n21 > 0 && (l23 += t7 + 1);
  }
  let o10 = 0;
  for (let s12 = 0; s12 < l23; s12++) "(" === e9[s12] && o10++;
  return { opIndex: l23, numIndex: l23 - o10 };
}
function s5(e9, n21, s12) {
  let a35, { ops: i28, nums: f7 } = t2(s12, n21);
  if (0 === i28.length) {
    const e10 = 1 === f7.length ? f7[0] : n21[0];
    if (e10 instanceof Float32Array) return [e10];
    const t7 = new Float32Array(n21[0].length);
    return "number" == typeof e10 ? t7.fill(e10) : t7.set(e10), [t7];
  }
  for (; i28.length > 0; ) {
    const { numIndex: t7, opIndex: n22 } = o4(i28);
    if (a35 = r6(e9, i28[n22], f7[t7], f7[t7 + 1]), 1 === i28.length) break;
    i28 = l6(i28, n22), f7.splice(t7, 2, a35);
  }
  return [a35];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/bandIndexUtils.js
var i5 = new n({ 0: "custom", 1: "ndvi", 2: "savi", 3: "tsavi", 4: "msavi", 5: "gemi", 6: "pvi", 7: "gvitm", 8: "sultan", 9: "vari", 10: "gndvi", 11: "sr", 12: "ndvi-re", 13: "sr-re", 14: "mtvi2", 15: "rtvi-core", 16: "ci-re", 17: "ci-g", 18: "ndwi", 19: "evi", 20: "iron-oxide", 21: "ferrous-minerals", 22: "clay-minerals", 23: "wndwi", 24: "bai", 25: "nbr", 26: "ndbi", 27: "ndmi", 28: "ndsi", 29: "mndwi" }, { useNumericKeys: true });
function s6(t7, i28) {
  if (!o3(t7)) return t7;
  const { equation: s12, method: l23 } = i28, c36 = i28.bandIndexes.map((t8) => t8 - 1), { pixels: U2, mask: q2 } = t7;
  let M4;
  switch (l23) {
    case "gndvi":
    case "nbr":
    case "ndbi":
    case "ndvi":
    case "ndvi-re":
    case "ndsi":
    case "ndmi":
    case "mndwi":
      M4 = u6(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "ndwi":
      M4 = u6(q2, U2[c36[1]], U2[c36[0]]);
      break;
    case "sr":
    case "sr-re":
    case "iron-oxide":
    case "ferrous-minerals":
    case "clay-minerals":
      M4 = f6(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "ci-g":
    case "ci-re":
      M4 = h3(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "savi":
      M4 = w5(q2, U2[c36[0]], U2[c36[1]], c36[2] + 1);
      break;
    case "tsavi":
      M4 = m5(q2, U2[c36[0]], U2[c36[1]], c36[2] + 1, c36[3] + 1, c36[4] + 1);
      break;
    case "msavi":
      M4 = d6(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "gemi":
      M4 = g5(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "pvi":
      M4 = y4(q2, U2[c36[0]], U2[c36[1]], c36[2] + 1, c36[3] + 1);
      break;
    case "gvitm":
      M4 = p10(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]], U2[c36[3]], U2[c36[4]], U2[c36[5]]]);
      break;
    case "sultan":
      M4 = b2(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]], U2[c36[3]], U2[c36[4]]]);
      break;
    case "vari":
      M4 = v2(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]]]);
      break;
    case "mtvi2":
      M4 = k2(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]]]);
      break;
    case "rtvi-core":
      M4 = A3(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]]]);
      break;
    case "evi":
      M4 = F2(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]]]);
      break;
    case "wndwi":
      M4 = x3(q2, [U2[c36[0]], U2[c36[1]], U2[c36[2]]], c36[3] ? c36[3] + 1 : 0.5);
      break;
    case "bai":
      M4 = j3(q2, U2[c36[0]], U2[c36[1]]);
      break;
    case "custom":
      M4 = s5(q2, U2, s12);
      break;
    default:
      return t7;
  }
  const { outputPixelType: B5 = "f32" } = i28, T3 = null != B5 && o2(B5);
  let I3;
  q2 ? (I3 = new Uint8Array(t7.width * t7.height), I3.set(q2)) : T3 && (I3 = new Uint8Array(t7.width * t7.height).fill(255)), T3 && (M4 = M4.map((t8) => {
    const e9 = g.createEmptyBand(B5, t8.length);
    return i(t8, I3, B5, e9), e9;
  }));
  const P3 = new g({ width: t7.width, height: t7.height, pixelType: B5, pixels: M4, mask: I3 });
  return P3.updateStatistics(), P3;
}
function l7(t7, e9, r12, a35) {
  const { mask: o10, pixels: i28, width: s12, height: l23 } = t7, c36 = i28[r12], u21 = i28[e9], f7 = u21.length, h7 = a35 ? new Uint8Array(f7) : new Float32Array(f7), w7 = a35 ? 100 : 1, m17 = a35 ? 100.5 : 0;
  for (let n21 = 0; n21 < f7; n21++) if (null == o10 || o10[n21]) {
    const t8 = c36[n21], e10 = u21[n21], r13 = t8 + e10;
    r13 && (h7[n21] = (t8 - e10) / r13 * w7 + m17);
  }
  const d10 = new g({ width: s12, height: l23, mask: o10, pixelType: a35 ? "u8" : "f32", pixels: [h7] });
  return d10.updateStatistics(), d10;
}
function c6(t7) {
  const n21 = new Float32Array(9);
  return n21[3 * t7[0]] = 1, n21[3 * t7[1] + 1] = 1, n21[3 * t7[2] + 2] = 1, n21;
}
function u6(t7, n21, e9) {
  const r12 = e9.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) {
    const t8 = n21[o10], r13 = e9[o10], i28 = t8 + r13;
    i28 && (a35[o10] = (t8 - r13) / i28);
  }
  return [a35];
}
function f6(t7, n21, e9) {
  const r12 = e9.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) {
    const t8 = n21[o10], r13 = e9[o10];
    r13 && (a35[o10] = t8 / r13);
  }
  return [a35];
}
function h3(t7, n21, e9) {
  const r12 = n21.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) {
    const t8 = n21[o10], r13 = e9[o10];
    r13 && (a35[o10] = t8 / r13 - 1);
  }
  return [a35];
}
function w5(t7, n21, e9, r12) {
  const a35 = e9.length, o10 = new Float32Array(a35);
  for (let i28 = 0; i28 < a35; i28++) if (null == t7 || t7[i28]) {
    const t8 = e9[i28], a36 = n21[i28], s12 = a36 + t8 + r12;
    s12 && (o10[i28] = (a36 - t8) / s12 * (1 + r12));
  }
  return [o10];
}
function m5(t7, n21, e9, r12, a35, o10) {
  const i28 = e9.length, s12 = new Float32Array(i28), l23 = -a35 * r12 + o10 * (1 + r12 * r12);
  for (let c36 = 0; c36 < i28; c36++) if (null == t7 || t7[c36]) {
    const t8 = e9[c36], o11 = n21[c36], i29 = a35 * o11 + t8 + l23;
    i29 && (s12[c36] = r12 * (o11 - r12 * t8 - a35) / i29);
  }
  return [s12];
}
function d6(t7, n21, e9) {
  const r12 = e9.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) {
    const t8 = e9[o10], r13 = n21[o10], i28 = 2 * r13 + 1;
    a35[o10] = 0.5 * (i28 - Math.sqrt(i28 * i28 - 8 * (r13 - t8)));
  }
  return [a35];
}
function g5(t7, n21, e9) {
  const r12 = e9.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) {
    const t8 = e9[o10], r13 = n21[o10];
    if (1 !== t8 && r13 + t8 + 0.5 !== 0) {
      const n22 = (2 * (r13 * r13 - t8 * t8) + 1.5 * r13 + 0.5 * t8) / (r13 + t8 + 0.5);
      a35[o10] = n22 * (1 - 0.25 * n22) - (t8 - 0.125) / (1 - t8);
    }
  }
  return [a35];
}
function y4(t7, n21, e9, r12, a35) {
  const o10 = e9.length, i28 = new Float32Array(o10), s12 = 1 / Math.sqrt(1 + r12 * r12);
  for (let l23 = 0; l23 < o10; l23++) if (null == t7 || t7[l23]) {
    const t8 = e9[l23], o11 = n21[l23];
    i28[l23] = (o11 - r12 * t8 - a35) * s12;
  }
  return [i28];
}
function p10(t7, n21) {
  const [e9, r12, a35, o10, i28, s12] = n21, l23 = e9.length, c36 = new Float32Array(l23);
  for (let u21 = 0; u21 < l23; u21++) (null == t7 || t7[u21]) && (c36[u21] = -0.2848 * e9[u21] - 0.2435 * r12[u21] - 0.5436 * a35[u21] + 0.7243 * o10[u21] + 0.084 * i28[u21] - 0.18 * s12[u21]);
  return [c36];
}
function b2(t7, n21) {
  const [e9, r12, a35, o10, i28] = n21, s12 = e9.length, l23 = new Float32Array(s12), c36 = new Float32Array(s12), u21 = new Float32Array(s12);
  for (let f7 = 0; f7 < s12; f7++) (null == t7 || t7[f7]) && (l23[f7] = i28[f7] ? o10[f7] / i28[f7] * 100 : 0, c36[f7] = e9[f7] ? o10[f7] / e9[f7] * 100 : 0, u21[f7] = a35[f7] ? r12[f7] / a35[f7] * (o10[f7] / a35[f7]) * 100 : 0);
  return [l23, c36, u21];
}
function v2(t7, n21) {
  const [e9, r12, a35] = n21, o10 = e9.length, i28 = new Float32Array(o10);
  for (let s12 = 0; s12 < o10; s12++) if (null == t7 || t7[s12]) for (s12 = 0; s12 < o10; s12++) {
    const t8 = e9[s12], n22 = r12[s12], o11 = n22 + t8 - a35[s12];
    o11 && (i28[s12] = (n22 - t8) / o11);
  }
  return [i28];
}
function k2(t7, n21) {
  const [e9, r12, a35] = n21, o10 = e9.length, i28 = new Float32Array(o10);
  for (let s12 = 0; s12 < o10; s12++) if (null == t7 || t7[s12]) for (s12 = 0; s12 < o10; s12++) {
    const t8 = e9[s12], n22 = r12[s12], o11 = a35[s12], l23 = Math.sqrt((2 * t8 + 1) ** 2 - (6 * t8 - 5 * Math.sqrt(n22)) - 0.5);
    if (l23) {
      const e10 = 1.5 * (1.2 * (t8 - o11) - 2.5 * (n22 - o11));
      i28[s12] = e10 / l23;
    }
  }
  return [i28];
}
function A3(t7, n21) {
  const [e9, r12, a35] = n21, o10 = e9.length, i28 = new Float32Array(o10);
  for (let s12 = 0; s12 < o10; s12++) if (null == t7 || t7[s12]) for (s12 = 0; s12 < o10; s12++) {
    const t8 = e9[s12], n22 = r12[s12], o11 = a35[s12];
    i28[s12] = 100 * (t8 - n22) - 10 * (t8 - o11);
  }
  return [i28];
}
function F2(t7, n21) {
  const [e9, r12, a35] = n21, o10 = e9.length, i28 = new Float32Array(o10);
  for (let s12 = 0; s12 < o10; s12++) if (null == t7 || t7[s12]) for (s12 = 0; s12 < o10; s12++) {
    const t8 = e9[s12], n22 = r12[s12], o11 = t8 + 6 * n22 - 7.5 * a35[s12] + 1;
    o11 && (i28[s12] = 2.5 * (t8 - n22) / o11);
  }
  return [i28];
}
function x3(t7, n21, e9 = 0.5) {
  const [r12, a35, o10] = n21, i28 = a35.length, s12 = new Float32Array(i28);
  for (let l23 = 0; l23 < i28; l23++) if (null == t7 || t7[l23]) for (l23 = 0; l23 < i28; l23++) {
    const t8 = r12[l23], n22 = a35[l23], i29 = o10[l23], c36 = t8 + e9 * n22 + (1 - e9) * i29;
    c36 && (s12[l23] = (t8 - e9 * n22 - (1 - e9) * i29) / c36);
  }
  return [s12];
}
function j3(t7, n21, e9) {
  const r12 = e9.length, a35 = new Float32Array(r12);
  for (let o10 = 0; o10 < r12; o10++) if (null == t7 || t7[o10]) for (o10 = 0; o10 < r12; o10++) {
    const t8 = (0.1 - n21[o10]) ** 2 + (0.06 - e9[o10]) ** 2;
    t8 && (a35[o10] = 1 / t8);
  }
  return [a35];
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunctionArguments.js
var i6;
var p11 = i6 = class extends p4 {
  constructor() {
    super(...arguments), this.method = "custom";
  }
  clone() {
    return new i6({ method: this.method, bandIndexes: this.bandIndexes, raster: a(this.raster) });
  }
};
r([m({ json: { type: String, write: true } })], p11.prototype, "bandIndexes", void 0), r([r3(i5)], p11.prototype, "method", void 0), p11 = i6 = r([a2("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")], p11);
var a12 = p11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/BandArithmeticFunction.js
var c7 = /* @__PURE__ */ new Set(["vari", "mtvi2", "rtvi-core", "evi"]);
var u7 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "BandArithmetic", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = this.sourceRasterInfos[0];
    if (e9.bandCount < 2) return { success: false, supportsGPU: false, error: "band-arithmetic-function: source raster has insufficient amount of raster bands" };
    const t7 = e9.clone();
    t7.pixelType = this.outputPixelType, t7.bandCount = "sultan" === this.functionArguments.method ? 3 : 1, this._removeStatsHistColormapVAT(t7), t7.keyProperties = { ...t7.keyProperties, BandProperties: void 0 }, this.rasterInfo = t7;
    return { success: true, supportsGPU: !["custom", "gvitm", "sultan"].includes(this.functionArguments.method) };
  }
  _processPixels(e9) {
    var _a;
    const t7 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (null == t7) return t7;
    const { method: s12, bandIndexes: r12 } = this.functionArguments, i28 = r12.split(" ").map((e10) => parseFloat(e10));
    return s6(t7, { method: s12, bandIndexes: i28, equation: r12, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const e9 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1);
    2 === e9.length && e9.push(0);
    const t7 = this.isInputBandIdsSwizzled ? [0, 1, 2] : e9;
    let s12, i28;
    const n21 = new Float32Array(3), { method: o10 } = this.functionArguments;
    switch (o10) {
      case "gndvi":
      case "nbr":
      case "ndbi":
      case "ndvi":
      case "ndvi-re":
      case "ndsi":
      case "ndmi":
      case "mndwi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "ndxi";
        break;
      case "ndwi":
        s12 = c6([t7[1], t7[0], 0]), i28 = "ndxi";
        break;
      case "sr":
      case "sr-re":
      case "iron-oxide":
      case "ferrous-minerals":
      case "clay-minerals":
        s12 = c6([t7[0], t7[1], 0]), i28 = "sr";
        break;
      case "ci-g":
      case "ci-re":
        s12 = c6([t7[0], t7[1], 0]), i28 = "ci";
        break;
      case "savi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "savi", n21[0] = e9[2] + 1;
        break;
      case "tsavi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "tsavi", n21[0] = e9[2] + 1, n21[1] = e9[3] + 1, n21[2] = e9[4] + 1;
        break;
      case "msavi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "msavi";
        break;
      case "gemi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "gemi";
        break;
      case "pvi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "tsavi", n21[0] = e9[2] + 1, n21[1] = e9[3] + 1;
        break;
      case "vari":
        s12 = c6([t7[0], t7[1], t7[2]]), i28 = "vari";
        break;
      case "mtvi2":
        s12 = c6([t7[0], t7[1], t7[2]]), i28 = "mtvi";
        break;
      case "rtvi-core":
        s12 = c6([t7[0], t7[1], t7[2]]), i28 = "rtvicore";
        break;
      case "evi":
        s12 = c6([t7[0], t7[1], t7[2]]), i28 = "evi";
        break;
      case "wndwi":
        s12 = c6([t7[0], t7[1], 0]), i28 = "wndwi", n21[0] = e9[3] ? e9[3] + 1 : 0.5;
        break;
      case "bai":
        s12 = c6([t7[1], t7[0], 0]), i28 = "bai";
        break;
      default:
        s12 = c6([0, 1, 2]), i28 = "custom";
    }
    return { bandIndexMat3: s12, indexType: i28, adjustments: n21, isOutputRounded: o2(this.outputPixelType) };
  }
  _getInputBandIds(e9) {
    if ("custom" === this.functionArguments.method) return e9;
    const t7 = this.functionArguments.bandIndexes.split(" ").map((e10) => parseFloat(e10) - 1), s12 = e9.length, r12 = t7.map((e10) => e10 >= s12 ? s12 - 1 : e10), i28 = c7.has(this.functionArguments.method) ? 3 : 2, n21 = r12.slice(0, i28).map((t8) => e9[t8]);
    return 2 === n21.length && n21.push(0), n21;
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], u7.prototype, "functionName", void 0), r([m({ type: a12, json: { write: true, name: "rasterFunctionArguments" } })], u7.prototype, "functionArguments", void 0), r([m()], u7.prototype, "rasterArgumentNames", void 0), u7 = r([a2("esri.layers.support.rasterFunctions.BandArithmeticFunction")], u7);
var m6 = u7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunctionArguments.js
var c8;
var n7 = new n({ 1: "outside", 2: "inside" }, { useNumericKeys: true });
var m7 = c8 = class extends p4 {
  constructor() {
    super(...arguments), this.clippingType = "outside";
  }
  clone() {
    return new c8({ clippingGeometry: this.clippingGeometry.clone(), clippingType: this.clippingType });
  }
};
r([m({ types: n2, json: { read: f2, write: true } })], m7.prototype, "clippingGeometry", void 0), r([m({ json: { read: n7.read, write: n7.write } })], m7.prototype, "clippingType", void 0), m7 = c8 = r([a2("esri.layers.support.rasterFunctions.ClipFunctionArguments")], m7);
var a13 = m7;

// node_modules/@arcgis/core/layers/support/rasterFunctions/clipUtils.js
function a14(e9, i28) {
  if (e9.spatialReference.equals(i28)) return e9;
  const n21 = z(e9.spatialReference), a35 = z(i28);
  if (n21 === a35) return e9;
  const h7 = n21 / a35;
  return { x: e9.x * h7, y: e9.y * h7 };
}
async function h4(t7, e9, i28) {
  if ("extent" === i28.type) return o5(t7, e9, i28);
  const { width: a35, height: h7 } = t7, m17 = new Uint8Array(a35 * h7), { contains: l23, intersects: s12 } = await import("./geometryEngine-5ALHOU3E.js");
  return s12(e9, i28) ? "polyline" === i28.type ? r7(t7, e9, i28) : l23(i28, e9) ? t7 : x4(t7, e9, i28) : new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: m17, maskIsAlpha: false, pixels: [...t7.pixels] });
}
function x4(t7, e9, i28) {
  if (!t7) return t7;
  const { width: a35, height: h7 } = t7, x7 = e9.width / a35, o10 = e9.height / h7, { xmin: r12, ymax: m17 } = e9;
  let l23;
  if ("extent" === i28.type) {
    const t8 = (i28.xmin - r12) / x7, e10 = (i28.xmax - r12) / x7, n21 = (m17 - i28.ymax) / o10, a36 = (m17 - i28.ymin) / o10;
    l23 = [[[t8, n21], [t8, a36], [e10, a36], [e10, n21], [t8, n21]]];
  } else l23 = i28.rings.map((t8) => t8.map(([t9, e10]) => [(t9 - r12) / x7, (m17 - e10) / o10]));
  const s12 = document.createElement("canvas");
  s12.width = a35, s12.height = h7;
  const p21 = s12.getContext("2d");
  p21.fillStyle = "#f00", p21.beginPath(), l23.forEach((t8) => {
    p21.moveTo(t8[0][0], t8[0][1]);
    for (let e10 = 0; e10 < t8.length; e10++) p21.lineTo(t8[e10][0], t8[e10][1]);
    p21.closePath();
  }), p21.fill();
  const y6 = p21.getImageData(0, 0, a35, h7).data, f7 = t7.mask, c36 = a35 * h7, M4 = new Uint8Array(c36);
  for (let n21 = 0; n21 < c36; n21++) f7 && !f7[n21] || (M4[n21] = y6[4 * n21 + 3] > 127 ? 255 : 0);
  return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: M4, maskIsAlpha: false, pixels: [...t7.pixels] });
}
function o5(t7, e9, i28) {
  const { width: a35, height: h7 } = t7, x7 = new Uint8Array(a35 * h7), o10 = e9.width / a35, r12 = e9.height / h7;
  if (i28.width / o10 < 0.5 || i28.height / r12 < 0.5) return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: x7, pixels: [...t7.pixels] });
  const { xmin: m17, xmax: l23, ymin: s12, ymax: p21 } = e9, { xmin: y6, xmax: f7, ymin: c36, ymax: M4 } = i28, u21 = Math.max(m17, y6), d10 = Math.min(l23, f7), w7 = Math.max(s12, c36), g7 = Math.min(p21, M4), T3 = 0.5 * o10, k4 = 0.5 * r12;
  if (d10 - u21 < T3 || g7 - w7 < k4 || d10 < m17 + T3 || u21 > l23 - T3 || w7 > p21 - k4 || g7 < s12 + k4) return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: x7, pixels: [...t7.pixels] });
  const R2 = Math.max(0, (u21 - m17) / o10), A4 = Math.min(a35, Math.max(0, (d10 - m17) / o10)), j4 = Math.max(0, (p21 - g7) / r12), U2 = Math.min(h7, Math.max(0, (p21 - w7) / r12)), E3 = Math.round(R2), P3 = Math.round(A4) - 1, S2 = Math.round(j4), z3 = Math.round(U2) - 1;
  if (E3 === P3 && R2 % 1 > 0.5 && A4 % 1 < 0.5 || S2 === z3 && j4 % 1 > 0.5 && U2 % 1 < 0.5) return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: x7, pixels: [...t7.pixels] });
  if (0 === E3 && 0 === S2 && P3 === a35 && z3 === h7) return t7;
  const I3 = t7.mask;
  for (let n21 = S2; n21 <= z3; n21++) for (let t8 = E3; t8 <= P3; t8++) {
    const e10 = n21 * a35 + t8;
    x7[e10] = I3 ? I3[e10] : 255;
  }
  return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: x7, pixels: [...t7.pixels] });
}
function r7(t7, e9, i28) {
  const { width: a35, height: h7 } = t7, x7 = new Uint8Array(a35 * h7), o10 = e9.width / a35, r12 = e9.height / h7, { xmin: m17, ymax: l23 } = e9, { paths: s12 } = i28, p21 = t7.mask;
  for (let n21 = 0; n21 < s12.length; n21++) {
    const t8 = s12[n21];
    for (let e10 = 0; e10 < t8.length - 1; e10++) {
      const [i29, n22] = t8[e10], [s13, y6] = t8[e10 + 1];
      let f7 = Math.floor((l23 - n22) / r12), c36 = Math.floor((l23 - y6) / r12);
      if (c36 < f7) {
        const t9 = f7;
        f7 = c36, c36 = t9;
      }
      f7 = Math.max(0, f7), c36 = Math.min(h7 - 1, c36);
      const M4 = (s13 - i29) / (y6 - n22);
      for (let t9 = f7; t9 <= c36; t9++) {
        const e11 = t9 === f7 ? Math.max(n22, y6) : (h7 + 1 - t9) * r12, l24 = t9 === c36 ? Math.min(n22, y6) : e11 - r12;
        let u21 = y6 === n22 ? Math.floor((i29 - m17) / o10) : Math.floor((M4 * (e11 - n22) + i29 - m17) / o10), d10 = y6 === n22 ? Math.floor((s13 - m17) / o10) : Math.floor((M4 * (l24 - n22) + i29 - m17) / o10);
        if (d10 < u21) {
          const t10 = u21;
          u21 = d10, d10 = t10;
        }
        const w7 = t9 * a35;
        u21 = Math.max(0, u21), d10 = Math.min(a35 - 1, d10);
        for (let t10 = w7 + u21; t10 <= w7 + d10; t10++) x7[t10] = p21 ? p21[t10] : 255;
      }
    }
  }
  return new g({ pixelType: t7.pixelType, width: a35, height: h7, mask: x7, pixels: [...t7.pixels] });
}
function m8(t7, e9) {
  const { extent: n21 } = l8(t7, e9, new j({ x: t7.pixelSize.x, y: t7.pixelSize.y, spatialReference: t7.spatialReference })), { extent: a35 } = t7.extent;
  if (n21.xmax = Math.min(n21.xmax, a35.xmax), n21.ymax = Math.min(n21.ymax, a35.ymax), n21.xmin < n21.xmax && n21.ymin < n21.ymax) {
    const { x: e10, y: i28 } = t7.pixelSize, a36 = Math.round(n21.width / e10), h7 = Math.round(n21.height / i28);
    t7.extent = n21, t7.width = a36, t7.height = h7;
  }
}
function l8(t7, i28, n21, h7 = true) {
  const { spatialReference: x7 } = t7, { x: o10, y: r12 } = a14(n21, x7);
  let m17, l23, s12;
  const p21 = "extent" === i28.type ? i28 : i28.extent;
  let { xmin: y6, xmax: f7, ymax: c36, ymin: M4 } = p21;
  const { xmin: u21, ymax: d10 } = t7.extent;
  return h7 ? (y6 = u21 + (y6 > u21 ? o10 * Math.round((y6 - u21) / o10) : 0), c36 = d10 - (c36 < d10 ? r12 * Math.round((d10 - c36) / r12) : 0), f7 = u21 + (f7 > u21 ? o10 * Math.round((f7 - u21) / o10) : 0), M4 = d10 - (M4 < d10 ? r12 * Math.round((d10 - M4) / r12) : 0), m17 = new w({ xmin: y6, ymax: c36, xmax: f7, ymin: M4, spatialReference: x7 }), l23 = Math.round(m17.width / o10), s12 = Math.round(m17.height / r12)) : (l23 = Math.floor((f7 - y6) / o10 + 0.8), s12 = Math.floor((c36 - M4) / r12 + 0.8), y6 = u21 + (y6 > u21 ? o10 * Math.floor((y6 - u21) / o10 + 0.1) : 0), c36 = d10 - (c36 < d10 ? r12 * Math.floor((d10 - c36) / r12 + 0.1) : 0), f7 = y6 + l23 * o10, M4 = c36 - s12 * r12, m17 = new w({ xmin: y6, ymax: c36, xmax: f7, ymin: M4, spatialReference: x7 })), { extent: m17, width: l23, height: s12 };
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ClipFunction.js
var c9 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Clip", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(t7.pixelType), t7.pixelType = this.outputPixelType, this.rasterInfo = t7;
    const { functionArguments: e9 } = this, { clippingGeometry: r12, clippingType: s12 } = e9;
    if (!r12) return { success: false, supportsGPU: false, error: "missing clipping geometry" };
    if ("outside" === s12) try {
      const { spatialReference: e10 } = t7, s13 = "extent" === r12.type ? K(r12, e10) : D(r12, e10).extent;
      s13 && m8(t7, s13);
    } catch {
    }
    return { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    return (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
  }
  _getWebGLParameters() {
    const { clippingGeometry: t7, clippingType: e9 } = this.functionArguments;
    return { clippingGeometry: t7.toJSON(), clippingType: e9 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], c9.prototype, "functionName", void 0), r([m({ type: a13, json: { write: true, name: "rasterFunctionArguments" } })], c9.prototype, "functionArguments", void 0), r([m()], c9.prototype, "rasterArgumentNames", void 0), r([m()], c9.prototype, "isNoopProcess", void 0), c9 = r([a2("esri.layers.support.rasterFunctions.ClipFunction")], c9);
var u8 = c9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunctionArguments.js
var i7;
var u9 = i7 = class extends p4 {
  castColormapName(o10) {
    if (!o10) return null;
    const r12 = o10.toLowerCase();
    return C.includes(r12) ? r12 : null;
  }
  readColorRamp(o10) {
    return p(o10);
  }
  readColorRampName(o10, r12) {
    if (!o10) return null;
    const e9 = a5.jsonValues.find((r13) => r13.toLowerCase() === o10.toLowerCase());
    return e9 ? a5.fromJSON(e9) : null;
  }
  clone() {
    var _a;
    return new i7({ colormap: a(this.colormap), colormapName: this.colormapName, colorRamp: (_a = this.colorRamp) == null ? void 0 : _a.clone(), colorRampName: this.colorRampName });
  }
};
r([m({ type: [[Number]], json: { write: true } })], u9.prototype, "colormap", void 0), r([m({ type: String, json: { write: true } })], u9.prototype, "colormapName", void 0), r([s2("colormapName")], u9.prototype, "castColormapName", null), r([m({ types: m2, json: { write: true } })], u9.prototype, "colorRamp", void 0), r([o("colorRamp")], u9.prototype, "readColorRamp", null), r([m({ type: a5.apiValues, json: { type: a5.jsonValues, write: a5.write } })], u9.prototype, "colorRampName", void 0), r([o("colorRampName")], u9.prototype, "readColorRampName", null), u9 = i7 = r([a2("esri.layers.support.rasterFunctions.ColormapFunctionArguments")], u9);
var d7 = u9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/colormaps.js
var t3 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [112, 75, 3], [113, 76, 3], [114, 77, 3], [115, 77, 3], [116, 78, 3], [117, 79, 3], [118, 79, 3], [119, 80, 3], [121, 81, 4], [122, 82, 4], [123, 82, 4], [124, 83, 4], [125, 84, 4], [126, 84, 4], [127, 85, 4], [128, 86, 4], [129, 86, 4], [130, 87, 4], [131, 88, 4], [132, 89, 4], [133, 89, 4], [134, 90, 4], [135, 91, 4], [136, 91, 4], [137, 92, 4], [138, 93, 4], [139, 94, 4], [140, 94, 4], [142, 95, 5], [143, 96, 5], [144, 96, 5], [145, 97, 5], [146, 98, 5], [147, 99, 5], [148, 99, 5], [149, 100, 5], [150, 101, 5], [151, 101, 5], [152, 102, 5], [153, 103, 5], [154, 104, 5], [155, 104, 5], [156, 105, 5], [157, 106, 5], [158, 106, 5], [159, 107, 5], [160, 108, 5], [161, 108, 5], [162, 109, 5], [164, 110, 6], [165, 111, 6], [166, 111, 6], [167, 112, 6], [168, 113, 6], [169, 113, 6], [170, 114, 6], [171, 115, 6], [172, 116, 6], [173, 116, 6], [174, 117, 6], [245, 0, 0], [245, 5, 0], [245, 10, 0], [246, 15, 0], [246, 20, 0], [246, 25, 0], [246, 30, 0], [247, 35, 0], [247, 40, 0], [247, 45, 0], [247, 50, 0], [247, 55, 0], [248, 60, 0], [248, 65, 0], [248, 70, 0], [248, 75, 0], [249, 81, 0], [249, 86, 0], [249, 91, 0], [249, 96, 0], [250, 101, 0], [250, 106, 0], [250, 111, 0], [250, 116, 0], [250, 121, 0], [251, 126, 0], [251, 131, 0], [251, 136, 0], [251, 141, 0], [252, 146, 0], [252, 151, 0], [252, 156, 0], [252, 156, 0], [251, 159, 0], [250, 162, 0], [249, 165, 0], [248, 168, 0], [247, 171, 0], [246, 174, 0], [245, 177, 0], [245, 179, 0], [244, 182, 0], [243, 185, 0], [242, 188, 0], [241, 191, 0], [240, 194, 0], [239, 197, 0], [238, 200, 0], [237, 203, 0], [236, 206, 0], [235, 209, 0], [234, 212, 0], [233, 215, 0], [232, 218, 0], [231, 221, 0], [230, 224, 0], [230, 226, 0], [229, 229, 0], [228, 232, 0], [227, 235, 0], [226, 238, 0], [225, 241, 0], [224, 244, 0], [223, 247, 0], [165, 247, 0], [163, 244, 0], [161, 240, 0], [158, 237, 0], [156, 233, 1], [154, 230, 1], [152, 227, 1], [149, 223, 1], [147, 220, 1], [145, 216, 1], [143, 213, 1], [140, 210, 2], [138, 206, 2], [136, 203, 2], [134, 200, 2], [132, 196, 2], [129, 193, 2], [127, 189, 2], [125, 186, 3], [123, 183, 3], [120, 179, 3], [118, 176, 3], [116, 172, 3], [114, 169, 3], [111, 166, 3], [109, 162, 4], [107, 159, 4], [105, 155, 4], [103, 152, 4], [100, 149, 4], [98, 145, 4], [96, 142, 4], [94, 138, 5], [91, 135, 5], [89, 132, 5], [87, 128, 5], [85, 125, 5], [82, 121, 5], [80, 118, 5], [78, 115, 6], [76, 111, 6], [73, 108, 6], [71, 105, 6], [69, 101, 6], [67, 98, 6], [65, 94, 6], [62, 91, 7], [60, 88, 7], [58, 84, 7], [56, 81, 7], [53, 77, 7], [51, 74, 7], [49, 71, 7], [47, 67, 8], [44, 64, 8], [42, 60, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8], [40, 57, 8]];
var o6 = [[36, 0, 255], [36, 0, 255], [36, 0, 255], [36, 0, 255], [245, 20, 0], [245, 24, 0], [245, 29, 0], [245, 31, 0], [247, 33, 0], [247, 33, 0], [247, 37, 0], [247, 41, 0], [247, 41, 0], [247, 41, 0], [247, 45, 0], [247, 45, 0], [247, 47, 0], [247, 49, 0], [247, 49, 0], [247, 54, 0], [247, 54, 0], [247, 56, 0], [247, 58, 0], [247, 58, 0], [250, 62, 0], [250, 62, 0], [250, 62, 0], [250, 67, 0], [250, 67, 0], [250, 67, 0], [250, 69, 0], [250, 71, 0], [250, 71, 0], [250, 75, 0], [250, 75, 0], [250, 78, 0], [250, 79, 0], [250, 79, 0], [250, 79, 0], [250, 81, 0], [250, 83, 0], [250, 83, 0], [250, 87, 0], [250, 87, 0], [250, 90, 0], [250, 92, 0], [252, 93, 0], [252, 93, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 97, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 101, 0], [252, 105, 0], [252, 105, 0], [252, 107, 0], [252, 109, 0], [252, 109, 0], [252, 113, 13], [255, 118, 20], [255, 119, 23], [255, 121, 25], [255, 126, 33], [255, 132, 38], [255, 133, 40], [255, 135, 43], [255, 141, 48], [255, 144, 54], [255, 150, 59], [255, 152, 61], [255, 153, 64], [255, 159, 69], [255, 163, 77], [255, 165, 79], [255, 168, 82], [255, 174, 87], [255, 176, 92], [255, 181, 97], [255, 183, 99], [255, 186, 102], [255, 191, 107], [255, 197, 115], [255, 201, 120], [255, 203, 123], [255, 205, 125], [255, 209, 130], [255, 214, 138], [255, 216, 141], [255, 218, 143], [255, 224, 150], [255, 228, 156], [255, 234, 163], [255, 236, 165], [255, 238, 168], [255, 243, 173], [255, 248, 181], [255, 252, 186], [253, 252, 186], [250, 252, 187], [244, 250, 180], [238, 247, 176], [234, 246, 173], [231, 245, 169], [223, 240, 163], [217, 237, 157], [211, 235, 150], [205, 233, 146], [200, 230, 142], [195, 227, 136], [189, 224, 132], [184, 222, 126], [180, 220, 123], [174, 217, 119], [169, 214, 114], [163, 212, 108], [160, 210, 105], [154, 207, 101], [148, 204, 96], [143, 201, 93], [138, 199, 88], [134, 197, 84], [130, 194, 81], [126, 191, 77], [117, 189, 70], [115, 186, 68], [112, 184, 64], [106, 181, 60], [100, 179, 55], [94, 176, 49], [92, 174, 47], [90, 173, 45], [81, 168, 37], [75, 166, 33], [71, 163, 28], [66, 160, 24], [62, 158, 21], [56, 156, 14], [51, 153, 0], [51, 153, 0], [51, 153, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [50, 150, 0], [49, 148, 0], [49, 148, 0], [49, 148, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 145, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [48, 143, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [47, 140, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [46, 138, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [45, 135, 0], [44, 133, 0], [44, 133, 0], [44, 133, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [43, 130, 0], [42, 128, 0], [42, 128, 0], [42, 128, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [42, 125, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [41, 122, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [40, 120, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [39, 117, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0], [38, 115, 0]];
function e5(t7, o10) {
  const e9 = [], n21 = [];
  for (let r12 = 0; r12 < t7.length - 1; r12++) e9.push({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: t7[r12].slice(1), toColor: t7[r12 + 1].slice(1) }), n21.push(t7[r12 + 1][0] - t7[r12][0]);
  const s12 = t7[t7.length - 1][0];
  return w3({ type: "multipart", colorRamps: e9 }, { numColors: s12, weights: o10 = o10 ?? n21 });
}
function n8() {
  return e5([[0, 0, 191, 191], [51, 0, 0, 255], [102, 255, 0, 255], [153, 255, 0, 127], [204, 191, 63, 127], [256, 20, 20, 20]]);
}
function s7() {
  const r12 = e5([[0, 255, 255, 255], [70, 0, 255, 0], [80, 205, 173, 193], [100, 150, 150, 150], [110, 120, 51, 100], [130, 120, 100, 200], [140, 28, 3, 144], [160, 6, 0, 55], [180, 10, 25, 30], [201, 6, 7, 27]]);
  for (let t7 = r12.length; t7 < 256; t7++) r12.push([6, 27, 7]);
  return r12;
}
function l9() {
  return w3({ type: "algorithmic", algorithm: "esriHSVAlgorithm", fromColor: [0, 0, 0], toColor: [255, 255, 255] });
}
function i8() {
  const r12 = [];
  for (let t7 = 0; t7 < 256; t7++) {
    const t8 = [];
    for (let r13 = 0; r13 < 3; r13++) t8.push(Math.round(255 * Math.random()));
    r12.push(t8);
  }
  return r12;
}
function a15() {
  return e5([[0, 38, 41, 54], [69, 79, 82, 90], [131, 156, 156, 156], [256, 253, 253, 241]], [0.268, 0.238, 0.495]);
}
function c10(r12) {
  let e9;
  switch (r12) {
    case "elevation":
      e9 = n8();
      break;
    case "gray":
      e9 = l9();
      break;
    case "hillshade":
      e9 = a15();
      break;
    case "ndvi":
      e9 = t3;
      break;
    case "ndvi2":
      e9 = s7();
      break;
    case "ndvi3":
      e9 = o6;
      break;
    case "random":
      e9 = i8();
  }
  return e9 ? (e9 = e9.map((r13, t7) => [t7, ...r13]), e9) : null;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapFunction.js
var m9 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Colormap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const o10 = this.sourceRasterInfos[0];
    if (o10.bandCount > 1) return { success: false, supportsGPU: false, error: "colormap-function: source data must be single band" };
    let { colormap: r12, colormapName: t7, colorRamp: s12, colorRampName: e9 } = this.functionArguments;
    if (!(r12 == null ? void 0 : r12.length)) if (s12) this.colorRamp = s12, r12 = B(s12, { interpolateAlpha: true });
    else if (e9) {
      const o11 = d3(e9);
      o11 && (r12 = B(o11), this.colorRamp = p(o11));
    } else t7 && (r12 = c10(t7));
    if (!(r12 == null ? void 0 : r12.length)) return { success: false, supportsGPU: false, error: "colormap-function: missing colormap argument" };
    const p21 = this._getOutputPixelType(o10.pixelType);
    this.outputPixelType = p21.startsWith("f") ? "s32" : p21;
    const m17 = o10.clone();
    return m17.pixelType = this.outputPixelType, m17.colormap = r12, m17.bandCount = 1, this.rasterInfo = m17, { success: true, supportsGPU: true };
  }
  _processPixels(o10) {
    var _a;
    let r12 = (_a = o10.pixelBlocks) == null ? void 0 : _a[0];
    return !r12 || o2(r12.pixelType) || (r12 = r12.clone(), r12.clamp(this.outputPixelType)), r12;
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], m9.prototype, "functionName", void 0), r([m({ type: d7, json: { write: true, name: "rasterFunctionArguments" } })], m9.prototype, "functionArguments", void 0), r([m()], m9.prototype, "rasterArgumentNames", void 0), r([m()], m9.prototype, "isNoopProcess", void 0), r([m({ json: { write: true } })], m9.prototype, "indexedColormap", void 0), r([m()], m9.prototype, "colorRamp", void 0), m9 = r([a2("esri.layers.support.rasterFunctions.ColormapFunction")], m9);
var u10 = m9;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapToRGBFunctionArguments.js
var t4;
var e6 = t4 = class extends p4 {
  clone() {
    return new t4({ raster: this.raster });
  }
};
e6 = t4 = r([a2("esri.layers.support.rasterFunctions.ColormapToRGBFunctionArguments")], e6);
var a16 = e6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ColormapToRGBFunction.js
var a17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ColormapToRGB", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    var _a;
    const t7 = this.sourceRasterInfos[0];
    if (t7.bandCount > 1 || !((_a = t7.colormap) == null ? void 0 : _a.length)) return { success: false, supportsGPU: false, error: "colormap-to-rgb-function: source data must be single band with a colormap" };
    const o10 = t7.clone();
    o10.pixelType = this.outputPixelType = this._getOutputPixelType("u8"), this._removeStatsHistColormapVAT(o10), o10.bandCount = 3, o10.statistics = [{ min: 0, max: 255, avg: 100, stddev: 20 }, { min: 0, max: 255, avg: 100, stddev: 20 }, { min: 0, max: 255, avg: 100, stddev: 20 }], this.rasterInfo = o10;
    const r12 = [...t7.colormap].sort((t8, o11) => t8[0] - o11[0]), { indexedColormap: e9, offset: s12 } = a3({ colormap: r12 });
    return e9 ? (this.lookup = { indexedColormap: e9, offset: s12 }, { success: true, supportsGPU: a6(e9) }) : { success: false, supportsGPU: false, error: "colormap-to-rgb-function: the colormap is not supported" };
  }
  _processPixels(t7) {
    var _a;
    let o10 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (!o10 || !this.lookup) return o10;
    o10 = o10.clone();
    const r12 = o10.pixels[0], s12 = o10.mask ?? new Uint8Array(r12.length).fill(255), n21 = new Uint8Array(r12.length), i28 = new Uint8Array(r12.length), p21 = new Uint8Array(r12.length), { indexedColormap: a35, offset: u21 } = this.lookup, c36 = a35.length;
    for (let e9 = 0; e9 < r12.length; e9++) if (s12[e9]) {
      let t8 = 4 * (r12[e9] - u21);
      t8 < 0 || t8 > c36 - 4 ? s12[e9] = 0 : (n21[e9] = a35[t8++], i28[e9] = a35[t8++], p21[e9] = a35[t8++]);
    }
    return o10.pixels = [n21, i28, p21], o10.statistics = [new l(0, 255), new l(0, 255), new l(0, 255)], o10.pixelType = this.outputPixelType, o10;
  }
  _getWebGLParameters() {
    return this.lookup;
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], a17.prototype, "functionName", void 0), r([m({ type: a16, json: { write: true, name: "rasterFunctionArguments" } })], a17.prototype, "functionArguments", void 0), r([m()], a17.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], a17.prototype, "lookup", void 0), a17 = r([a2("esri.layers.support.rasterFunctions.ColormapToRGBFunction")], a17);
var u11 = a17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunctionArguments.js
var a18;
var c11 = a18 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [];
  }
  writeRasters(r12, s12) {
    s12.rasters = r12.map((r13) => "number" == typeof r13 || "string" == typeof r13 ? r13 : r13.toJSON());
  }
  clone() {
    return new a18({ rasters: a(this.rasters) });
  }
};
r([m({ json: { write: true } })], c11.prototype, "rasters", void 0), r([r2("rasters")], c11.prototype, "writeRasters", null), c11 = a18 = r([a2("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")], c11);
var i9 = c11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CompositeBandFunction.js
var i10 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "CompositeBand", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, s12 = t7[0];
    this.outputPixelType = this._getOutputPixelType(s12.pixelType);
    const e9 = s12.clone();
    if (e9.attributeTable = null, e9.colormap = null, e9.pixelType = this.outputPixelType, e9.bandCount = t7.map(({ bandCount: t8 }) => t8).reduce((t8, s13) => t8 + s13), t7.every(({ statistics: t8 }) => null != t8 && t8.length)) {
      const s13 = [];
      t7.forEach(({ statistics: t8 }) => null != t8 && s13.push(...t8)), e9.statistics = s13;
    }
    if (t7.every(({ histograms: t8 }) => null != t8 && t8.length)) {
      const s13 = [];
      t7.forEach(({ histograms: t8 }) => null != t8 && s13.push(...t8)), e9.histograms = s13;
    }
    e9.multidimensionalInfo && e9.multidimensionalInfo.variables.forEach((s13) => {
      const e10 = t7.map((t8) => {
        var _a;
        return (_a = t8.multidimensionalInfo) == null ? void 0 : _a.variables.find(({ name: t9 }) => t9 === s13.name);
      }), r13 = e10.map((t8) => {
        var _a;
        return ((_a = t8 == null ? void 0 : t8.statistics) == null ? void 0 : _a.length) ? t8.statistics : null;
      }), o10 = e10.map((t8) => {
        var _a;
        return ((_a = t8 == null ? void 0 : t8.histograms) == null ? void 0 : _a.length) ? t8.histograms : null;
      });
      s13.statistics = r13.every((t8) => null != t8) ? r13.flat() : null, s13.histograms = o10.every((t8) => null != t8) ? o10.flat() : null;
    }), e9.bandCount > 1 && (e9.colormap = null, e9.attributeTable = null);
    const r12 = t7.every((t8) => {
      var _a;
      return (_a = t8.keyProperties.BandProperties) == null ? void 0 : _a.length;
    }) ? t7.flatMap((t8) => t8.keyProperties.BandProperties) : void 0;
    e9.keyProperties = { ...e9.keyProperties, BandProperties: r12 }, this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 };
  }
  _processPixels(t7) {
    const { pixelBlocks: s12 } = t7;
    if (!s12) return null;
    const e9 = s12 == null ? void 0 : s12[0];
    return null == e9 ? null : r4(s12);
  }
  _getWebGLParameters() {
    return { bandCount: this.rasterInfo.bandCount };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], i10.prototype, "functionName", void 0), r([m({ type: i9, json: { write: true, name: "rasterFunctionArguments" } })], i10.prototype, "functionArguments", void 0), r([m()], i10.prototype, "rasterArgumentNames", void 0), i10 = r([a2("esri.layers.support.rasterFunctions.CompositeBandFunction")], i10);
var a19 = i10;

// node_modules/@arcgis/core/layers/support/rasterFunctions/changeDetectionUtils.js
var n9 = new n({ 0: "difference", 1: "relative-difference", 2: "categorical", 3: "euclidean-distance", 4: "angle-difference", 5: "band-with-most-change" }, { useNumericKeys: true });
var s8 = new n({ 0: "all", 1: "changed", 2: "unchanged" }, { useNumericKeys: true });
function i11(e9, n21, s12, i28) {
  const [f7, h7] = e9, m17 = o2(s12) && !o2(f7.pixelType) && !o2(h7.pixelType), p21 = [f7.mask, h7.mask].filter((e10) => e10), u21 = g.combineBandMasks(p21), g7 = e9.map((e10) => e10.pixels[0]), { width: k4, height: x7 } = f7, b3 = g.createEmptyBand(s12, k4 * x7);
  switch (n21) {
    case "difference":
    case "relative-difference":
      o7({ bands: g7, mask: u21, outBand: b3, isRoundingNeeded: m17, isRelative: "relative-difference" === n21 });
      break;
    case "categorical":
      c12({ bands: g7, mask: u21, outBand: b3, ...i28 });
      break;
    case "euclidean-distance":
      l10({ pixels: e9.map((e10) => e10.pixels), mask: u21, outBand: b3 });
      break;
    case "angle-difference":
      r8({ pixels: e9.map((e10) => e10.pixels), mask: u21, outBand: b3 });
      break;
    case "band-with-most-change":
      d8({ pixels: e9.map((e10) => e10.pixels), mask: u21, outBand: b3 });
  }
  const B5 = new g({ width: k4, height: x7, pixels: [b3], pixelType: s12, mask: u21 });
  return B5.updateStatistics(), B5;
}
function o7(e9) {
  const { bands: [t7, a35], mask: n21, isRelative: s12, isRoundingNeeded: i28, outBand: o10 } = e9, c36 = t7.length;
  for (let l23 = 0; l23 < c36; l23++) if (!n21 || n21[l23]) {
    let e10 = t7[l23] - a35[l23];
    if (s12) {
      const n22 = Math.max(Math.abs(t7[l23]) - Math.abs(a35[l23]));
      e10 = n22 > 0 ? e10 / n22 : 0;
    }
    o10[l23] = i28 ? Math.round(e10) : e10;
  }
}
function c12(e9) {
  const { bands: [t7, a35], categoryIndexLookups: [n21, s12], classNames: [i28, o10], mask: c36, keepMethod: l23, outBand: r12 } = e9, d10 = t7.length, f7 = i28.length, h7 = o10.length, m17 = f7 * h7, p21 = m17 + 1, u21 = m17 + 2;
  for (let g7 = 0; g7 < d10; g7++) if (!c36 || c36[g7]) {
    const e10 = t7[g7], c37 = a35[g7], d11 = n21[e10], f8 = s12[c37], k4 = i28[d11], x7 = o10[f8];
    r12[g7] = null == d11 || null == f8 ? m17 : "changed" === l23 && k4 === x7 ? p21 : "unchanged" === l23 && k4 !== x7 ? u21 : d11 * h7 + f8;
  }
}
function l10(e9) {
  const { pixels: [t7, a35], mask: n21, outBand: s12 } = e9, i28 = t7[0].length, o10 = t7.length;
  for (let c36 = 0; c36 < i28; c36++) if (!n21 || n21[c36]) {
    let e10 = 0;
    for (let n22 = 0; n22 < o10; n22++) {
      const s13 = t7[n22][c36] - a35[n22][c36];
      e10 += s13 * s13;
    }
    s12[c36] = Math.sqrt(e10);
  }
}
function r8(e9) {
  const { pixels: [t7, a35], mask: n21, outBand: s12 } = e9, i28 = t7[0].length, o10 = t7.length;
  for (let c36 = 0; c36 < i28; c36++) if (!n21 || n21[c36]) {
    let e10 = 0, n22 = 0, i29 = 0;
    for (let s13 = 0; s13 < o10; s13++) {
      const o11 = t7[s13][c36], l24 = a35[s13][c36];
      e10 += o11 * l24, n22 += o11 * o11, i29 += l24 * l24;
    }
    const l23 = Math.sqrt(n22 * i29);
    s12[c36] = l23 ? Math.acos(e10 / l23) : 1.5707963267948966;
  }
}
function d8(e9) {
  const { pixels: [t7, a35], mask: n21, outBand: s12 } = e9, i28 = t7[0].length, o10 = t7.length;
  for (let c36 = 0; c36 < i28; c36++) if (!n21 || n21[c36]) {
    let e10 = 0, n22 = 0;
    for (let s13 = 0; s13 < o10; s13++) {
      const i29 = Math.abs(t7[s13][c36] - a35[s13][c36]);
      i29 > e10 && (e10 = i29, n22 = s13);
    }
    s12[c36] = n22;
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/ComputeChangeFunctionArguments.js
var i12;
var c13 = i12 = class extends p4 {
  constructor() {
    super(...arguments), this.method = "difference", this.keepMethod = "all", this.raster2 = void 0;
  }
  get rasters() {
    return [this.raster, this.raster2];
  }
  clone() {
    return new i12({ raster: this.raster, raster2: this.raster2, method: this.method, keepMethod: this.keepMethod });
  }
};
r([r3(n9)], c13.prototype, "method", void 0), r([r3(s8)], c13.prototype, "keepMethod", void 0), r([m({ json: { write: true } })], c13.prototype, "raster2", void 0), r([m({ readOnly: true })], c13.prototype, "rasters", null), c13 = i12 = r([a2("esri.layers.support.rasterFunctions.ComputeChangeFunctionArguments")], c13);
var n10 = c13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ComputeChangeFunction.js
var l11 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ComputeChange", this.functionArguments = null, this.rasterArgumentNames = ["raster", "raster2"];
  }
  _bindSourceRasters() {
    const { method: e9 } = this.functionArguments, t7 = this.sourceRasterInfos[0].clone();
    if (this.outputPixelType = this._getOutputPixelType(t7.pixelType), t7.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(t7), "categorical" === e9) {
      const e10 = this.sourceRasterInfos.map((e11) => e11.attributeTable), s12 = this._getFieldNames(e10, "value"), r12 = e10.map((e11) => this._getClassFieldName(e11));
      if (null == s12[0] || null == s12[1] || null == r12[0] || null == r12[1]) return { success: false, supportsGPU: false, error: "both inputs must have proper attribute table with value and class fields" };
      this._updateAttributeTable(t7, s12, r12);
    }
    t7.bandCount = 1, this.rasterInfo = t7;
    return { success: true, supportsGPU: "difference" === e9 || "relative-difference" === e9 };
  }
  _processPixels(e9) {
    const { pixelBlocks: t7 } = e9;
    if (null == (t7 == null ? void 0 : t7[0]) || null == (t7 == null ? void 0 : t7[1])) return null;
    const { method: s12 } = this.functionArguments;
    return i11(t7, s12, this.outputPixelType, this._categoryConfig);
  }
  _getWebGLParameters() {
    const e9 = this.outputPixelType ?? "f32";
    let [t7, s12] = s3(e9);
    const r12 = o2(e9);
    return r12 && (t7 -= 1e-4, s12 += 1e-4), { method: this.functionArguments.method, domainRange: [t7, s12], isOutputRounded: r12 };
  }
  _updateAttributeTable(e9, t7, s12) {
    const n21 = this.sourceRasterInfos.map((e10) => e10.attributeTable), o10 = n21.map((e10, s13) => e10.features.map((e11) => e11.attributes[t7[s13]])), a35 = n21.map((e10, t8) => e10.features.map((e11) => e11.attributes[s12[t8]])), i28 = o10.map((e10) => {
      const t8 = [];
      return e10.forEach((e11, s13) => t8[e11] = s13), t8;
    }), { keepMethod: u21 } = this.functionArguments;
    this._categoryConfig = { categoryIndexLookups: i28, classNames: a35, keepMethod: u21 };
    const l23 = n21[0].clone();
    l23.fields = [new y({ name: "OID", type: "oid" }), new y({ name: "Value", type: "integer" }), new y({ name: "ClassName", type: "string" }), new y({ name: "Class_From", type: "string" }), new y({ name: "Class_To", type: "string" })];
    const m17 = this._getFieldNames(n21, "red"), p21 = this._getFieldNames(n21, "green"), c36 = this._getFieldNames(n21, "blue"), d10 = [], g7 = 2 === m17.length && 2 === p21.length && 2 === c36.length;
    g7 && (d10.push(...n21.map((e10, t8) => e10.features.map((e11) => [e11.attributes[m17[t8]], e11.attributes[p21[t8]], e11.attributes[c36[t8]]]))), l23.fields.push(new y({ name: "Red", type: "integer" }), new y({ name: "Green", type: "integer" }), new y({ name: "Blue", type: "integer" })));
    const h7 = l23.features[0].clone();
    h7.geometry = null;
    const f7 = [], [y6, C3] = o10.map((e10) => e10.length);
    let b3 = 1;
    for (let r12 = 0; r12 < y6; r12++) {
      const e10 = a35[0][r12];
      for (let t8 = 0; t8 < C3; t8++) {
        const s13 = a35[1][t8];
        if ("changed" === u21 && e10 === s13 || "unchanged" === u21 && e10 !== s13) continue;
        const n22 = h7.clone();
        n22.attributes = { OID: b3++, Value: r12 * C3 + t8, ClassName: e10 === s13 ? e10 : `${e10} -> ${s13}`, Class_From: e10, Class_To: s13 }, g7 && (n22.attributes.Red = d10[0][r12][0] + d10[1][t8][0] >> 1, n22.attributes.Green = d10[0][r12][1] + d10[1][t8][1] >> 1, n22.attributes.Blue = d10[0][r12][2] + d10[1][t8][2] >> 1), f7.push(n22);
      }
    }
    if ("changed" === u21) {
      const e10 = h7.clone();
      e10.attributes = { OID: b3++, Value: y6 * C3 + 1, ClassName: "No Change", Class_From: "Same", Class_To: "Same" }, f7.push(e10);
    } else if ("unchanged" === u21) {
      const e10 = h7.clone();
      e10.attributes = { OID: b3++, Value: y6 * C3 + 2, ClassName: "Changed", Class_From: "Any", Class_To: "Any" }, f7.push(e10);
    }
    l23.features = f7, e9.attributeTable = l23;
  }
  _getFieldNames(e9, t7) {
    return e9.map(({ fields: e10 }) => {
      var _a;
      return (_a = e10.find((e11) => e11.name.toLowerCase() === t7)) == null ? void 0 : _a.name;
    }).filter((e10) => e10);
  }
  _getClassFieldName(e9) {
    const t7 = e9.fields.find((e10) => "string" === e10.type && e10.name.toLowerCase().startsWith("class")) ?? e9.fields.find((e10) => "string" === e10.type && e10.name.toLowerCase().includes("class") || e10.name.toLowerCase().includes("type") || e10.name.toLowerCase().includes("name")) ?? e9.fields.find((e10) => "string" === e10.type);
    return t7 == null ? void 0 : t7.name;
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], l11.prototype, "functionName", void 0), r([m({ type: n10, json: { write: true, name: "rasterFunctionArguments" } })], l11.prototype, "functionArguments", void 0), r([m()], l11.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], l11.prototype, "_categoryConfig", void 0), l11 = r([a2("esri.layers.support.rasterFunctions.ComputeChangeFunction")], l11);
var m10 = l11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunctionArguments.js
var e7;
var n11 = e7 = class extends p4 {
  constructor() {
    super(...arguments), this.contrastOffset = 0, this.brightnessOffset = 0;
  }
  clone() {
    return new e7({ contrastOffset: this.contrastOffset, brightnessOffset: this.brightnessOffset, raster: this.raster });
  }
};
r([m({ json: { write: true } })], n11.prototype, "contrastOffset", void 0), r([m({ json: { write: true } })], n11.prototype, "brightnessOffset", void 0), n11 = e7 = r([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunctionArguments")], n11);
var i13 = n11;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ContrastBrightnessFunction.js
var u12 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ContrastBrightness", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, s12 = t7[0];
    if ("u8" !== s12.pixelType) return { success: false, supportsGPU: false, error: "Only unsigned 8 bit raster is supported by ContrastBrightness function." };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r12 = s12.clone();
    this._removeStatsHistColormapVAT(r12), this.rasterInfo = r12;
    const { contrastOffset: o10, brightnessOffset: e9 } = this.functionArguments;
    return this.lookup = l4(o10, e9), { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    return null == s12 ? null : f3(s12, { lut: s12.pixels.map(() => this.lookup), offset: 0, outputPixelType: "u8" });
  }
  _getWebGLParameters() {
    const { contrastOffset: t7, brightnessOffset: s12 } = this.functionArguments;
    return { contrastOffset: t7, brightnessOffset: s12 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], u12.prototype, "functionName", void 0), r([m({ type: i13, json: { write: true, name: "rasterFunctionArguments" } })], u12.prototype, "functionArguments", void 0), r([m()], u12.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], u12.prototype, "lookup", void 0), u12 = r([a2("esri.layers.support.rasterFunctions.ContrastBrightnessFunction")], u12);
var p12 = u12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/mirror.js
function o8(o10, t7, f7, r12, l23) {
  const e9 = Math.floor(r12 / 2);
  for (let c36 = 0; c36 < e9; c36++) for (let r13 = 0; r13 < t7; r13++) o10[c36 * t7 + r13] = o10[(l23 - 1 - c36) * t7 + r13], o10[(f7 - 1 - c36) * t7 + r13] = o10[(f7 - l23 + c36) * t7 + r13];
  const n21 = Math.floor(l23 / 2);
  for (let c36 = 0; c36 < f7; c36++) {
    const f8 = c36 * t7;
    for (let r13 = 0; r13 < n21; r13++) o10[f8 + r13] = o10[f8 + l23 - 1 - r13], o10[f8 + t7 - r13 - 1] = o10[f8 + t7 + r13 - l23];
  }
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/convolutionUtils.js
var l12 = /* @__PURE__ */ new Map();
function o9(e9) {
  const t7 = Math.sqrt(e9.length), n21 = e9.slice(0, t7), l23 = [1];
  for (let o10 = 1; o10 < t7; o10++) {
    let n22 = null;
    for (let l24 = 0; l24 < t7; l24++) {
      const r12 = e9[l24 + o10 * t7], s12 = e9[l24];
      if (null == n22) if (0 === s12) {
        if (r12) return { separable: false, row: null, col: null };
      } else n22 = r12 / s12;
      else if (r12 / s12 !== n22) return { separable: false, row: null, col: null };
    }
    if (null == n22) return { separable: false, row: null, col: null };
    l23.push(n22);
  }
  return { separable: true, row: n21, col: l23 };
}
function r9(e9, t7, n21, l23, o10, r12, s12) {
  const i28 = new Float32Array(t7 * n21), a35 = r12.length, h7 = s12 ? 0 : l23, c36 = s12 ? l23 : 0, p21 = s12 ? 1 : t7;
  for (let u21 = h7; u21 < n21 - h7; u21++) {
    const n22 = u21 * t7;
    for (let s13 = c36; s13 < t7 - c36; s13++) {
      if (o10 && !o10[n22 + s13]) continue;
      let t8 = 0;
      for (let o11 = 0; o11 < a35; o11++) t8 += e9[n22 + s13 + (o11 - l23) * p21] * r12[o11];
      i28[n22 + s13] = t8;
    }
  }
  return i28;
}
function s9(e9, t7, n21, l23, o10, r12, s12) {
  const i28 = new Float32Array(t7 * n21), a35 = Math.floor(l23 / 2), h7 = Math.floor(o10 / 2);
  for (let c36 = a35; c36 < n21 - a35; c36++) {
    const n22 = c36 * t7;
    for (let c37 = h7; c37 < t7 - h7; c37++) {
      if (r12 && !r12[n22 + c37]) continue;
      let p21 = 0;
      for (let r13 = 0; r13 < l23; r13++) for (let l24 = 0; l24 < o10; l24++) p21 += e9[n22 + c37 + (r13 - a35) * t7 + l24 - h7] * s12[r13 * o10 + l24];
      i28[n22 + c37] = p21;
    }
  }
  return i28;
}
function i14(t7, l23, o10 = true) {
  const { pixels: r12, width: i28, height: a35, pixelType: h7, mask: c36 } = t7, p21 = r12.length, u21 = [], { kernel: f7, rows: g7, cols: m17 } = l23;
  for (let e9 = 0; e9 < p21; e9++) {
    const t8 = s9(r12[e9], i28, a35, g7, m17, c36, f7);
    o10 && o8(t8, i28, a35, g7, m17), u21.push(t8);
  }
  return new g({ width: i28, height: a35, pixelType: h7, pixels: u21, mask: c36 });
}
function a20(t7, l23, o10, s12 = true) {
  const { pixels: i28, width: a35, height: h7, pixelType: c36, mask: p21 } = t7, u21 = i28.length, f7 = [], g7 = l23.length, m17 = o10.length, x7 = Math.floor(g7 / 2), w7 = Math.floor(m17 / 2);
  for (let e9 = 0; e9 < u21; e9++) {
    let t8 = r9(i28[e9], a35, h7, x7, p21, l23, true);
    t8 = r9(t8, a35, h7, w7, p21, o10, false), s12 && o8(t8, a35, h7, g7, m17), f7.push(t8);
  }
  return new g({ width: a35, height: h7, pixelType: c36, pixels: f7, mask: p21 });
}
function h5(e9, t7) {
  const n21 = o9(t7.kernel), l23 = false !== t7.mirrorEdges, r12 = n21.separable ? a20(e9, n21.row, n21.col, l23) : i14(e9, t7, l23), { outputPixelType: s12 } = t7;
  return s12 && r12.clamp(s12), r12;
}
l12.set(g3.none, [0, 0, 0, 0, 1, 0, 0, 0, 0]), l12.set(g3.lineDetectionHorizontal, [-1, -1, -1, 2, 2, 2, -1, -1, -1]), l12.set(g3.lineDetectionVertical, [-1, 2, -1, -1, 2, -1, -1, 2, -1]), l12.set(g3.lineDetectionLeftDiagonal, [2, -1, -1, -1, 2, -1, -1, -1, 2]), l12.set(g3.lineDetectionRightDiagonal, [-1, -1, 2, -1, 2, -1, 2, -1, -1]), l12.set(g3.gradientNorth, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l12.set(g3.gradientWest, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l12.set(g3.gradientEast, [1, 0, -1, 2, 0, -2, 1, 0, -1]), l12.set(g3.gradientSouth, [1, 2, 1, 0, 0, 0, -1, -2, -1]), l12.set(g3.gradientNorthEast, [0, -1, -2, 1, 0, -1, 2, 1, 0]), l12.set(g3.gradientNorthWest, [-2, -1, 0, -1, 0, 1, 0, 1, 2]), l12.set(g3.smoothArithmeticMean, [0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111, 0.111111111111]), l12.set(g3.smoothing3x3, [0.0625, 0.125, 0.0625, 0.125, 0.25, 0.125, 0.0625, 0.125, 0.0625]), l12.set(g3.smoothing5x5, [1, 1, 1, 1, 1, 1, 4, 4, 4, 1, 1, 4, 12, 4, 1, 1, 4, 4, 4, 1, 1, 1, 1, 1, 1]), l12.set(g3.sharpening3x3, [-1, -1, -1, -1, 9, -1, -1, -1, -1]), l12.set(g3.sharpening5x5, [-1, -3, -4, -3, -1, -3, 0, 6, 0, -3, -4, 6, 21, 6, -4, -3, 0, 6, 0, -3, -1, -3, -4, -3, -1]), l12.set(g3.laplacian3x3, [0, -1, 0, -1, 4, -1, 0, -1, 0]), l12.set(g3.laplacian5x5, [0, 0, -1, 0, 0, 0, -1, -2, -1, 0, -1, -2, 17, -2, -1, 0, -1, -2, -1, 0, 0, 0, -1, 0, 0]), l12.set(g3.sobelHorizontal, [-1, -2, -1, 0, 0, 0, 1, 2, 1]), l12.set(g3.sobelVertical, [-1, 0, 1, -2, 0, 2, -1, 0, 1]), l12.set(g3.sharpen, [0, -0.25, 0, -0.25, 2, -0.25, 0, -0.25, 0]), l12.set(g3.sharpen2, [-0.25, -0.25, -0.25, -0.25, 3, -0.25, -0.25, -0.25, -0.25]), l12.set(g3.pointSpread, [-0.627, 0.352, -0.627, 0.352, 2.923, 0.352, -0.627, 0.352, -0.627]);

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunctionArguments.js
var p13;
var c14 = p13 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.kernel = [0, 0, 0, 0, 1, 0, 0, 0, 0];
  }
  set convolutionType(o10) {
    this._set("convolutionType", o10);
    const t7 = l12.get(o10);
    if (!t7 || o10 === g3.userDefined || o10 === g3.none) return;
    const s12 = Math.sqrt(t7.length);
    this._set("kernel", t7), this._set("cols", s12), this._set("rows", s12);
  }
  clone() {
    return new p13({ cols: this.cols, rows: this.rows, kernel: [...this.kernel], convolutionType: this.convolutionType, raster: a(this.raster) });
  }
};
r([m({ json: { type: Number, write: true } })], c14.prototype, "rows", void 0), r([m({ json: { type: Number, write: true } })], c14.prototype, "cols", void 0), r([m({ json: { name: "type", type: Number, write: true } })], c14.prototype, "convolutionType", null), r([m({ json: { type: [Number], write: true } })], c14.prototype, "kernel", void 0), c14 = p13 = r([a2("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")], c14);
var l13 = c14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ConvolutionFunction.js
var c15 = 25;
var l14 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Convolution", this.rasterArgumentNames = ["raster"];
  }
  get _normalizedKernel() {
    const { kernel: t7, convolutionType: e9 } = this.functionArguments, o10 = t7.reduce((t8, e10) => t8 + e10);
    return -1 === e9 || 0 === o10 || 1 === o10 ? t7 : t7.map((t8) => t8 / o10);
  }
  _bindSourceRasters() {
    const { convolutionType: t7, rows: e9, cols: o10, kernel: n21 } = this.functionArguments;
    if (!Object.values(g3).includes(t7)) return { success: false, supportsGPU: false, error: `convolution-function: the specified kernel type is not supported ${t7}` };
    if (t7 !== g3.none && e9 * o10 !== n21.length) return { success: false, supportsGPU: false, error: "convolution-function: the specified rows and cols do not match the length of the kernel" };
    const r12 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(r12.pixelType);
    const i28 = r12.clone();
    i28.pixelType = this.outputPixelType;
    const u21 = [g3.none, g3.sharpen, g3.sharpen2, g3.sharpening3x3, g3.sharpening5x5];
    (-1 === t7 || "u8" !== this.outputPixelType && !u21.includes(t7)) && (i28.statistics = null, i28.histograms = null), i28.colormap = null, i28.attributeTable = null, this.rasterInfo = i28;
    return { success: true, supportsGPU: n21.length <= c15 };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9 || this.functionArguments.convolutionType === g3.none) return e9;
    const { rows: o10, cols: n21 } = this.functionArguments, { _normalizedKernel: r12 } = this;
    return h5(e9, { kernel: r12, rows: o10, cols: n21, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const t7 = new Float32Array(c15);
    return t7.set(this._normalizedKernel), { kernelRows: this.functionArguments.rows, kernelCols: this.functionArguments.cols, kernel: t7, clampRange: s3(this.outputPixelType) };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], l14.prototype, "functionName", void 0), r([m({ type: l13, json: { write: true, name: "rasterFunctionArguments" } })], l14.prototype, "functionArguments", void 0), r([m()], l14.prototype, "rasterArgumentNames", void 0), r([m()], l14.prototype, "_normalizedKernel", null), l14 = r([a2("esri.layers.support.rasterFunctions.ConvolutionFunction")], l14);
var p14 = l14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunctionArguments.js
var c16;
var u13 = new n({ 0: "standard", 1: "planform", 2: "profile" }, { useNumericKeys: true });
var n12 = c16 = class extends p4 {
  constructor() {
    super(...arguments), this.curvatureType = "standard", this.zFactor = 1;
  }
  readCurvatureType(r12, e9) {
    return u13.fromJSON(e9.type ?? e9.curvatureType ?? 0);
  }
  clone() {
    return new c16({ curvatureType: this.curvatureType, zFactor: this.zFactor, raster: this.raster });
  }
};
r([m({ json: { write: { target: "type" } } }), r3(u13)], n12.prototype, "curvatureType", void 0), r([o("curvatureType", ["type", "curvatureType"])], n12.prototype, "readCurvatureType", null), r([m({ type: Number, json: { write: true } })], n12.prototype, "zFactor", void 0), n12 = c16 = r([a2("esri.layers.support.rasterFunctions.CurvatureFunctionArguments")], n12);
var i15 = n12;

// node_modules/@arcgis/core/layers/support/rasterFunctions/CurvatureFunction.js
var u14 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Curvature", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const t7 = this.sourceRasterInfos[0].clone();
    return t7.pixelType = this.outputPixelType, t7.bandCount = 1, this._removeStatsHistColormapVAT(t7), this.rasterInfo = t7, this.isGCS = ((_a = t7.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    const r12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == r12) return null;
    const { zFactor: e9, curvatureType: s12 } = this.functionArguments, { extent: o10, primaryPixelSizes: u21 } = t7, c36 = u21 == null ? void 0 : u21[0], a35 = c36 ?? (o10 ? { x: o10.width / r12.width, y: o10.height / r12.height } : { x: 1, y: 1 }), p21 = this.isGCS && e9 >= 1 ? e9 * n4 : e9;
    return f4(r12, { zFactor: p21, curvatureType: s12, resolution: a35 });
  }
  _getWebGLParameters() {
    const { zFactor: t7, curvatureType: r12 } = this.functionArguments;
    return { curvatureType: r12, zFactor: this.isGCS && t7 >= 1 ? t7 * n4 : t7 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], u14.prototype, "functionName", void 0), r([m({ type: i15, json: { write: true, name: "rasterFunctionArguments" } })], u14.prototype, "functionArguments", void 0), r([m()], u14.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], u14.prototype, "isGCS", void 0), u14 = r([a2("esri.layers.support.rasterFunctions.CurvatureFunction")], u14);
var c17 = u14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunctionArguments.js
var a21;
var i16 = a21 = class extends p4 {
  constructor() {
    super(...arguments), this.bandIds = [], this.bandNames = [], this.bandWavelengths = [], this.missingBandAction = l3.bestMatch;
  }
  clone() {
    var _a, _b, _c;
    return new a21({ bandIds: (_a = this.bandIds) == null ? void 0 : _a.slice(), bandNames: (_b = this.bandNames) == null ? void 0 : _b.slice(), bandWavelengths: (_c = this.bandWavelengths) == null ? void 0 : _c.slice(), missingBandAction: this.missingBandAction, method: this.method, wavelengthMatchTolerance: this.wavelengthMatchTolerance });
  }
};
r([m({ json: { write: true } })], i16.prototype, "bandIds", void 0), r([m({ json: { write: true } })], i16.prototype, "bandNames", void 0), r([m({ json: { write: true } })], i16.prototype, "bandWavelengths", void 0), r([r3({ 0: "name", 1: "wavelength", 2: "id" })], i16.prototype, "method", void 0), r([m({ json: { write: true } })], i16.prototype, "missingBandAction", void 0), r([m({ json: { write: true } })], i16.prototype, "wavelengthMatchTolerance", void 0), i16 = a21 = r([a2("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")], i16);
var c18 = i16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ExtractBandFunction.js
var i17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ExtractBand", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    var _a;
    const { functionArguments: t7, sourceRasterInfos: n21 } = this, e9 = n21[0], { method: s12, bandNames: r12, bandWavelengths: o10, bandIds: i28, missingBandAction: l23 } = t7, h7 = (r12 == null ? void 0 : r12.length) && ("name" === s12 || "id" !== s12 && !(i28 == null ? void 0 : i28.length)), d10 = (o10 == null ? void 0 : o10.length) && ("wavelength" === s12 || "id" !== s12 && !(i28 == null ? void 0 : i28.length)), g7 = l23 === l3.fail, p21 = h7 ? u15(e9, r12) : d10 ? m11(e9, o10, this.functionArguments, g7) : c19(e9, i28, g7);
    if (null == p21) {
      return { success: false, supportsGPU: false, error: `extract-band-function: Invalid ${h7 ? "band names" : d10 ? "band wavelengths" : "band ids"} for the imagery data source` };
    }
    this.functionArguments.bandIds = p21, this.functionArguments.method = "id", this.outputPixelType = this._getOutputPixelType("f32");
    const f7 = e9.clone();
    f7.pixelType = this.outputPixelType, f7.bandCount = p21.length;
    const { statistics: b3, histograms: x7 } = f7;
    null != b3 && b3.length && (f7.statistics = p21.map((t8) => b3[t8] || b3[b3.length - 1])), null != x7 && x7.length && (f7.histograms = p21.map((t8) => x7[t8] || x7[x7.length - 1])), f7.multidimensionalInfo && f7.multidimensionalInfo.variables.forEach((t8) => {
      const { statistics: n22, histograms: e10 } = t8;
      null != n22 && n22.length && (t8.statistics = p21.map((t9) => n22[t9] || n22[n22.length - 1])), null != e10 && e10.length && (t8.histograms = p21.map((t9) => e10[t9] || e10[e10.length - 1]));
    });
    let I3 = (_a = f7.keyProperties) == null ? void 0 : _a.BandProperties;
    (I3 == null ? void 0 : I3.length) && (I3 = p21.map((t8) => t8 >= I3.length ? I3[I3.length - 1] : I3[t8]), f7.keyProperties = { ...f7.keyProperties, BandProperties: I3 }), this.rasterInfo = f7;
    return { success: true, supportsGPU: f7.bandCount <= 3 };
  }
  _processPixels(t7) {
    var _a;
    const n21 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == n21) return null;
    const e9 = n21.pixels.length, s12 = this.functionArguments.bandIds.map((t8) => t8 >= e9 ? e9 - 1 : t8);
    return n21.extractBands(s12);
  }
  _getWebGLParameters() {
    let t7;
    if (this.isInputBandIdsSwizzled) t7 = this.swizzledBandSelection.length ? this.swizzledBandSelection : [0, 1, 2];
    else {
      t7 = [...this.functionArguments.bandIds], 0 === t7.length ? t7 = [0, 1, 2] : t7.length < 3 && (t7[1] = t7[1] ?? t7[0], t7[2] = t7[2] ?? t7[1]);
      for (let n21 = 0; n21 < 3; n21++) t7[n21] = Math.min(t7[n21], 2);
    }
    return { bandIndexMat3: c6(t7) };
  }
  _getInputBandIds(t7) {
    const n21 = t7.length;
    return this.functionArguments.bandIds.map((t8) => t8 >= n21 ? n21 - 1 : t8).map((n22) => t7[n22]);
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], i17.prototype, "functionName", void 0), r([m({ type: c18, json: { write: true, name: "rasterFunctionArguments" } })], i17.prototype, "functionArguments", void 0), r([m()], i17.prototype, "rasterArgumentNames", void 0), i17 = r([a2("esri.layers.support.rasterFunctions.ExtractBandFunction")], i17);
var l15 = i17;
function u15(t7, n21) {
  const e9 = t7.bandInfos.map(({ name: t8 }) => t8.toLowerCase()), s12 = [];
  for (let r12 = 0; r12 < n21.length; r12++) {
    const t8 = n21[r12].toLowerCase();
    let o10 = e9.indexOf(t8);
    if (-1 === o10 && "nearinfrared" === t8 && (o10 = e9.findIndex((t9) => t9.startsWith("nearinfrared_1")), -1 === o10 && (o10 = e9.findIndex((t9) => t9.startsWith("nearinfrared")))), -1 === o10) return null;
    s12.push(o10);
  }
  return s12;
}
function c19(t7, n21, e9) {
  const { bandCount: s12 } = t7;
  return !(n21 == null ? void 0 : n21.length) || e9 && n21.some((t8) => t8 < 0 || t8 >= s12) ? null : n21;
}
function m11(t7, n21, { wavelengthMatchTolerance: e9 }, s12) {
  const { bandInfos: r12 } = t7, o10 = [];
  for (let i28 = 0; i28 < r12.length; i28++) {
    const { minWavelength: t8, maxWavelength: n22 } = r12[i28];
    if (!t8 || !n22) return null;
    o10.push({ minWavelength: t8, maxWavelength: n22 });
  }
  const a35 = [];
  for (let i28 = 0; i28 < n21.length; i28++) {
    const t8 = n21[i28];
    let r13 = false, l23 = -1, u21 = Number.MAX_VALUE;
    for (let n22 = 0; n22 < o10.length; n22++) {
      const e10 = o10[n22], s13 = t8 >= e10.minWavelength && t8 <= e10.maxWavelength, a36 = Math.abs(t8 - (e10.minWavelength + e10.maxWavelength) / 2);
      s13 ? a36 < u21 && (r13 = true, l23 = n22, u21 = a36) : !r13 && a36 < u21 && (l23 = n22, u21 = a36);
    }
    if (!r13 && e9 && u21 < e9 && (r13 = true), !r13 && s12) return null;
    a35.push(l23);
  }
  return a35;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/conversionUtils.js
function i18(i28, s12, a35) {
  const { pixels: l23, width: n21, height: r12, mask: o10, bandMasks: h7 } = i28, p21 = n21 * r12, m17 = (h7 == null ? void 0 : h7.length) ? g.combineBandMasks(h7) : o10, f7 = Math.min(s12.length, l23.length), c36 = a35.startsWith("f"), d10 = !c36 && a35 !== i28.pixelType, [x7, g7] = s3(a35), k4 = g.createEmptyBand(a35, p21);
  for (let t7 = 0; t7 < r12; t7++) {
    let e9 = t7 * n21;
    for (let t8 = 0; t8 < n21; t8++, e9++) if (!m17 || m17[e9]) {
      let t9 = 0;
      for (let i29 = 0; i29 < f7; i29++) t9 += s12[i29] * l23[i29][e9];
      c36 || (t9 = Math.round(t9), d10 && (t9 = t9 > g7 ? g7 : t9 < x7 ? x7 : t9)), k4[e9] = t9;
    }
  }
  const u21 = new g({ width: n21, height: r12, pixels: [k4], pixelType: a35, mask: m17 });
  return u21.updateStatistics(), u21;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunctionArguments.js
var t5;
var a22 = t5 = class extends p4 {
  clone() {
    return new t5({ conversionParameters: [...this.conversionParameters], raster: this.raster });
  }
};
r([m({ type: [Number], json: { write: true } })], a22.prototype, "conversionParameters", void 0), a22 = t5 = r([a2("esri.layers.support.rasterFunctions.GrayscaleFunctionArguments")], a22);
var c20 = a22;

// node_modules/@arcgis/core/layers/support/rasterFunctions/GrayscaleFunction.js
var i19 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Grayscale", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  get _normalizedWeights() {
    const { conversionParameters: t7 } = this.functionArguments, e9 = t7.reduce((t8, e10) => t8 + e10);
    return t7.map((t8) => t8 / e9);
  }
  _bindSourceRasters() {
    const { conversionParameters: t7 } = this.functionArguments;
    if (!(t7 == null ? void 0 : t7.length)) return { success: false, supportsGPU: false, error: "missing valid conversion parameters." };
    const e9 = this.sourceRasterInfos[0].clone();
    this.outputPixelType = this._getOutputPixelType(e9.pixelType), e9.pixelType = this.outputPixelType;
    const s12 = 3 === t7.length || 3 === e9.bandCount && t7.length > 3;
    return e9.bandCount = 1, this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9, { success: true, supportsGPU: s12 };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    return null == e9 ? null : i18(e9, this._normalizedWeights, this.outputPixelType);
  }
  _getWebGLParameters() {
    return { weights: this._normalizedWeights };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], i19.prototype, "functionName", void 0), r([m({ type: c20, json: { write: true, name: "rasterFunctionArguments" } })], i19.prototype, "functionArguments", void 0), r([m()], i19.prototype, "rasterArgumentNames", void 0), r([m()], i19.prototype, "_normalizedWeights", null), i19 = r([a2("esri.layers.support.rasterFunctions.GrayscaleFunction")], i19);
var u16 = i19;

// node_modules/@arcgis/core/layers/support/rasterFunctions/HillshadeFunctionArguments.js
var p15;
var a23 = new n({ 0: "traditional", 1: "multi-directional" }, { useNumericKeys: true });
var c21 = new n({ 1: "degree", 2: "percent-rise", 3: "scaled" }, { useNumericKeys: true });
var l16 = p15 = class extends p4 {
  constructor() {
    super(...arguments), this.altitude = 45, this.azimuth = 315, this.hillshadeType = "traditional", this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.slopeType = "degree", this.zFactor = 1, this.removeEdgeEffect = false;
  }
  clone() {
    return new p15({ hillshadeType: this.hillshadeType, altitude: this.altitude, azimuth: this.azimuth, zFactor: this.zFactor, slopeType: this.slopeType, pixelSizeFactor: this.pixelSizeFactor, pixelSizePower: this.pixelSizePower, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
r([m({ type: Number, json: { write: true } })], l16.prototype, "altitude", void 0), r([m({ type: Number, json: { write: true } })], l16.prototype, "azimuth", void 0), r([m(), r3(a23)], l16.prototype, "hillshadeType", void 0), r([m({ type: Number, json: { write: true, name: "psPower" } })], l16.prototype, "pixelSizePower", void 0), r([m({ type: Number, json: { write: true, name: "psZFactor" } })], l16.prototype, "pixelSizeFactor", void 0), r([m(), r3(c21)], l16.prototype, "slopeType", void 0), r([m({ type: Number, json: { write: true } })], l16.prototype, "zFactor", void 0), r([m({ type: Boolean, json: { write: true } })], l16.prototype, "removeEdgeEffect", void 0), l16 = p15 = r([a2("esri.layers.support.rasterFunctions.HillshadeFunctionArguments")], l16);
var m12 = l16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/HillshadeFunction.js
var c22 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Hillshade", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    const t7 = this.sourceRasterInfos[0];
    if (t7.bandCount > 1) return { success: false, supportsGPU: false, error: "hillshade-function: source data must be single band" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const s12 = t7.clone();
    return this._removeStatsHistColormapVAT(s12), s12.pixelType = this.outputPixelType, s12.bandCount = 1, s12.statistics = [{ min: 0, max: 255, avg: 60, stddev: 10 }], this.rasterInfo = s12, this.isGCS = ((_a = s12.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (!s12) return null;
    const { extent: e9, primaryPixelSizes: r12 } = t7, o10 = r12 == null ? void 0 : r12[0], i28 = o10 ?? (e9 ? { x: e9.width / s12.width, y: e9.height / s12.height } : { x: 1, y: 1 }), p21 = d2(this.functionArguments, i28, this.isGCS), a35 = r5(s12, p21);
    return a35.pixelType = this.outputPixelType, a35;
  }
  _getWebGLParameters() {
    const t7 = d2(this.functionArguments, { x: 1, y: 1 }, this.isGCS), s12 = a4(t7), { slopeType: e9, zFactor: o10, pixelSizeFactor: i28, pixelSizePower: u21 } = this.functionArguments, c36 = "scaled" === e9, l23 = o2(this.outputPixelType);
    return { ...s12, zFactor: o10, gcsFactor: this.isGCS ? n4 : 1, pixelSizeFactor: c36 ? i28 : 0, pixelSizePower: c36 ? u21 : 0, isOutputRounded: l23 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], c22.prototype, "functionName", void 0), r([m({ type: m12, json: { write: true, name: "rasterFunctionArguments" } })], c22.prototype, "functionArguments", void 0), r([m()], c22.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], c22.prototype, "isGCS", void 0), c22 = r([a2("esri.layers.support.rasterFunctions.HillshadeFunction")], c22);
var l17 = c22;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunctionArguments.js
var i20;
var a24 = i20 = class extends p4 {
  constructor() {
    super(...arguments), this.rasters = [], this.processAsMultiband = true;
  }
  writeRasters(r12, s12) {
    s12.rasters = r12.map((r13) => "number" == typeof r13 || "string" == typeof r13 ? r13 : r13.toJSON());
  }
  clone() {
    return new i20({ operation: this.operation, processAsMultiband: this.processAsMultiband, rasters: a(this.rasters) });
  }
};
r([m({ json: { write: true } })], a24.prototype, "operation", void 0), r([m({ json: { write: true } })], a24.prototype, "rasters", void 0), r([r2("rasters")], a24.prototype, "writeRasters", null), r([m({ json: { write: true } })], a24.prototype, "processAsMultiband", void 0), a24 = i20 = r([a2("esri.layers.support.rasterFunctions.LocalFunctionArguments")], a24);
var c23 = a24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/LocalFunction.js
var m13 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Local", this.functionArguments = null, this.rasterArgumentNames = ["rasters"];
  }
  _bindSourceRasters() {
    const { sourceRasterInfos: t7 } = this, s12 = t7[0], { bandCount: e9 } = s12, { processAsMultiband: o10 } = this.functionArguments;
    if (t7.some((t8) => t8.bandCount !== e9)) return { success: false, supportsGPU: false, error: "local-function: input rasters do not have same band count" };
    const { operation: n21, rasters: r12 } = this.functionArguments, i28 = c4[n21];
    if (!(999 === i28 || r12.length === i28 || r12.length <= 1 && 1 === i28)) return { success: false, supportsGPU: false, error: `local-function: the length of functionArguments.rasters does not match operation's requirement: ${i28}` };
    const a35 = s12.clone();
    a35.bandCount = 999 !== i28 || o10 ? e9 : 1, this._removeStatsHistColormapVAT(a35), this._updateStatistics(a35), this._updatePixelType(a35), this.rasterInfo = a35;
    return { success: true, supportsGPU: 1 === a35.bandCount && i28 <= 3 };
  }
  _processPixels(t7) {
    const { pixelBlocks: s12 } = t7;
    return null == s12 || s12.some((t8) => null == t8) ? null : gt(s12, this.functionArguments.operation, { processAsMultiband: this.functionArguments.processAsMultiband, outputPixelType: this.outputPixelType ?? void 0 });
  }
  _getWebGLParameters() {
    var _a;
    const { operation: t7 } = this.functionArguments, s12 = c4[t7], e9 = ((_a = Object.keys(B2).find((s13) => B2[s13] === t7)) == null ? void 0 : _a.toLowerCase()) ?? "undefined", i28 = this.outputPixelType ?? "f32";
    let [a35, u21] = s3(i28);
    const p21 = o2(i28);
    return p21 && (a35 -= 1e-4, u21 += 1e-4), { imageCount: s12, operationName: e9, domainRange: [a35, u21], isOutputRounded: p21 };
  }
  _updateStatistics(t7) {
    var _a, _b;
    const s12 = this.sourceRasterInfos[0], { operation: e9 } = this.functionArguments, o10 = (_a = l5(e9)) == null ? void 0 : _a.domain;
    if (o10) {
      t7.statistics = [];
      for (let s13 = 0; s13 < t7.bandCount; s13++) t7.statistics[s13] = { min: o10[0], max: o10[1], avg: (o10[0] + o10[1]) / 2, stddev: (o10[0] + o10[1]) / 10 };
    } else 45 === e9 && ((_b = s12.statistics) == null ? void 0 : _b.length) && (t7.statistics = s12.statistics.map((t8) => ({ min: -t8.max, max: -t8.min, avg: null != t8.avg ? -t8.avg : void 0, stddev: null != t8.stddev ? -t8.stddev : void 0 })));
  }
  _updatePixelType(t7) {
    const { statistics: s12, pixelType: e9 } = this.sourceRasterInfos[0], { operation: o10 } = this.functionArguments, { domain: n21, isInteger: a35 } = l5(o10) ?? { domain: null, isInteger: false };
    let u21 = "f32";
    if (n21 && a35) u21 = u(n21[0], n21[1]);
    else if (30 === o10) {
      const t8 = s12 == null ? void 0 : s12[0];
      u21 = t8 ? u(t8.min, t8.max) : o2(e9) ? e9 : "s32";
    } else if (45 === o10 && o2(e9)) {
      const t8 = s12 == null ? void 0 : s12.map(({ max: t9 }) => -t9), o11 = s12 == null ? void 0 : s12.map(({ min: t9 }) => -t9), n22 = (t8 == null ? void 0 : t8.length) ? Math.min(...t8) : null, r12 = (o11 == null ? void 0 : o11.length) ? Math.min(...o11) : null;
      u21 = null != n22 && null != r12 ? u(n22, r12) : e9.startsWith("s") ? e9.replace("s", "u") : "u1" === e9 || "u2" === e9 || "u4" === e9 ? "s8" : "u8" === e9 ? "s16" : "s32";
    }
    t7.pixelType = this.outputPixelType = this._getOutputPixelType(u21);
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], m13.prototype, "functionName", void 0), r([m({ type: c23, json: { write: true, name: "rasterFunctionArguments" } })], m13.prototype, "functionArguments", void 0), r([m()], m13.prototype, "rasterArgumentNames", void 0), m13 = r([a2("esri.layers.support.rasterFunctions.LocalFunction")], m13);
var d9 = m13;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunctionArguments.js
var s10;
var a25 = s10 = class extends p4 {
  constructor() {
    super(...arguments), this.includedRanges = null, this.noDataValues = null, this.noDataInterpretation = n3.matchAny;
  }
  get normalizedNoDataValues() {
    const { noDataValues: t7 } = this;
    if (!(t7 == null ? void 0 : t7.length)) return null;
    let e9 = false;
    const r12 = t7.map((t8) => {
      if ("number" == typeof t8) return e9 = true, [t8];
      if ("string" == typeof t8) {
        const r13 = t8.trim().split(" ").filter((t9) => "" !== t9.trim()).map((t9) => Number(t9));
        return e9 = e9 || r13.length > 0, 0 === r13.length ? null : r13;
      }
      return null;
    });
    return e9 ? r12 : null;
  }
  clone() {
    var _a, _b;
    return new s10({ includedRanges: ((_a = this.includedRanges) == null ? void 0 : _a.slice()) ?? [], noDataValues: ((_b = this.noDataValues) == null ? void 0 : _b.slice()) ?? [], noDataInterpretation: this.noDataInterpretation });
  }
};
r([m({ json: { write: true } })], a25.prototype, "includedRanges", void 0), r([m({ json: { write: true } })], a25.prototype, "noDataValues", void 0), r([m()], a25.prototype, "normalizedNoDataValues", null), r([m({ json: { write: true } })], a25.prototype, "noDataInterpretation", void 0), a25 = s10 = r([a2("esri.layers.support.rasterFunctions.MaskFunctionArguments")], a25);
var i21 = a25;

// node_modules/@arcgis/core/layers/support/rasterFunctions/MaskFunction.js
var c24 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Mask", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0].clone(), { pixelType: e9 } = t7;
    this.outputPixelType = this._getOutputPixelType(e9), t7.pixelType = this.outputPixelType, this.rasterInfo = t7;
    const { includedRanges: s12, normalizedNoDataValues: o10 } = this.functionArguments;
    if (!(s12 == null ? void 0 : s12.length) && !(o10 == null ? void 0 : o10.length)) return { success: false, supportsGPU: false, error: "missing includedRanges or noDataValues argument" };
    let r12 = [];
    for (let a35 = 0; a35 < t7.bandCount; a35++) {
      const t8 = w2(e9, s12 == null ? void 0 : s12.slice(2 * a35, 2 * a35 + 2), o10 == null ? void 0 : o10[a35]);
      if (null == t8) {
        r12 = null;
        break;
      }
      r12.push(t8);
    }
    this.lookups = r12;
    const n21 = null != o10 && o10.every((t8) => {
      var _a;
      return (t8 == null ? void 0 : t8.length) === ((_a = o10[0]) == null ? void 0 : _a.length);
    });
    return { success: true, supportsGPU: (!s12 || s12.length <= 2 * i2) && (!o10 || n21 && o10[0].length <= i2) };
  }
  _processPixels(t7) {
    var _a;
    const e9 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == e9) return null;
    const { outputPixelType: s12, lookups: o10 } = this, { includedRanges: r12, noDataInterpretation: n21, normalizedNoDataValues: u21 } = this.functionArguments, a35 = n21 === n3.matchAll;
    return g2(e9, { includedRanges: r12, noDataValues: u21, outputPixelType: s12, matchAll: a35, lookups: o10 });
  }
  _getWebGLParameters() {
    var _a;
    const { includedRanges: t7, normalizedNoDataValues: s12 } = this.functionArguments, o10 = new Float32Array(i2);
    o10.fill(d), ((_a = s12 == null ? void 0 : s12[0]) == null ? void 0 : _a.length) && o10.set(s12[0]);
    const r12 = new Float32Array(i2);
    for (let n21 = 0; n21 < r12.length; n21 += 2) r12[n21] = (t7 == null ? void 0 : t7[n21]) ?? -d, r12[n21 + 1] = (t7 == null ? void 0 : t7[n21 + 1]) ?? d;
    return (t7 == null ? void 0 : t7.length) && r12.set(t7), { bandCount: this.sourceRasterInfos[0].bandCount, noDataValues: o10, includedRanges: r12 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], c24.prototype, "functionName", void 0), r([m({ type: i21, json: { write: true, name: "rasterFunctionArguments" } })], c24.prototype, "functionArguments", void 0), r([m()], c24.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], c24.prototype, "lookups", void 0), c24 = r([a2("esri.layers.support.rasterFunctions.MaskFunction")], c24);
var p16 = c24;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunctionArguments.js
var i22;
var e8 = i22 = class extends p4 {
  constructor() {
    super(...arguments), this.visibleBandID = 0, this.infraredBandID = 1, this.scientificOutput = false;
  }
  clone() {
    const { visibleBandID: r12, infraredBandID: t7, scientificOutput: s12 } = this;
    return new i22({ visibleBandID: r12, infraredBandID: t7, scientificOutput: s12 });
  }
};
r([m({ json: { write: true } })], e8.prototype, "visibleBandID", void 0), r([m({ json: { write: true } })], e8.prototype, "infraredBandID", void 0), r([m({ json: { write: true } })], e8.prototype, "scientificOutput", void 0), e8 = i22 = r([a2("esri.layers.support.rasterFunctions.NDVIFunctionArguments")], e8);
var n13 = e8;

// node_modules/@arcgis/core/layers/support/rasterFunctions/NDVIFunction.js
var u17 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "NDVI", this.functionArguments = null, this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { scientificOutput: t7, visibleBandID: s12, infraredBandID: r12 } = this.functionArguments;
    this.outputPixelType = this._getOutputPixelType(t7 ? "f32" : "u8");
    const e9 = this.sourceRasterInfos[0], n21 = Math.max(s12, r12);
    if (e9.bandCount < 2 || n21 >= e9.bandCount) return { success: false, supportsGPU: false, error: "ndvi-function: source raster has insufficient amount of raster bands" };
    const o10 = e9.clone();
    o10.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(o10), o10.bandCount = 1, o10.keyProperties = { ...o10.keyProperties, BandProperties: void 0 };
    const [i28, u21, a35, c36] = t7 ? [-1, 1, 0, 0.1] : [0, 200, 100, 10];
    return o10.statistics = [{ min: i28, max: u21, avg: a35, stddev: c36 }], this.rasterInfo = o10, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s12) return null;
    const { visibleBandID: r12, infraredBandID: n21, scientificOutput: o10 } = this.functionArguments;
    return l7(s12, r12, n21, !o10);
  }
  _getWebGLParameters() {
    const { visibleBandID: t7, infraredBandID: s12, scientificOutput: r12 } = this.functionArguments, e9 = this.isInputBandIdsSwizzled ? [0, 1, 2] : [s12, t7, 0];
    return { bandIndexMat3: c6(e9), scaled: !r12 };
  }
  _getInputBandIds(t7) {
    const { visibleBandID: s12, infraredBandID: r12 } = this.functionArguments;
    return [r12, s12, 0].map((s13) => t7[s13]);
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], u17.prototype, "functionName", void 0), r([m({ type: n13, json: { write: true, name: "rasterFunctionArguments" } })], u17.prototype, "functionArguments", void 0), r([m()], u17.prototype, "rasterArgumentNames", void 0), u17 = r([a2("esri.layers.support.rasterFunctions.NDVIFunction")], u17);
var a26 = u17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunctionArguments.js
var n14;
var a27 = n14 = class extends p4 {
  constructor() {
    super(...arguments), this.inputRanges = null, this.outputValues = null, this.noDataRanges = null, this.allowUnmatched = false, this.isLastInputRangeInclusive = false;
  }
  clone() {
    return new n14({ inputRanges: [...this.inputRanges], outputValues: [...this.outputValues], noDataRanges: [...this.noDataRanges], allowUnmatched: this.allowUnmatched, isLastInputRangeInclusive: this.isLastInputRangeInclusive });
  }
};
r([m({ json: { write: true } })], a27.prototype, "inputRanges", void 0), r([m({ json: { write: true } })], a27.prototype, "outputValues", void 0), r([m({ json: { write: true } })], a27.prototype, "noDataRanges", void 0), r([m({ json: { write: true } })], a27.prototype, "allowUnmatched", void 0), r([m({ json: { write: true } })], a27.prototype, "isLastInputRangeInclusive", void 0), a27 = n14 = r([a2("esri.layers.support.rasterFunctions.RemapFunctionArguments")], a27);
var r10 = a27;

// node_modules/@arcgis/core/layers/support/rasterFunctions/RemapFunction.js
var m14 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Remap", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0].clone(), { pixelType: s12 } = t7;
    this.outputPixelType = this._getOutputPixelType(s12), t7.pixelType = this.outputPixelType, t7.bandCount = 1;
    const { statistics: e9 } = t7;
    this._removeStatsHistColormapVAT(t7);
    const { allowUnmatched: n21, outputValues: o10, inputRanges: a35, noDataRanges: i28, isLastInputRangeInclusive: l23 } = this.functionArguments;
    if (null != e9 && e9.length && (o10 == null ? void 0 : o10.length)) if (n21) {
      const s13 = Math.min.apply(null, [...o10, e9[0].min]), n22 = Math.max.apply(null, [...o10, e9[0].max]);
      t7.statistics = [{ ...e9[0], min: s13, max: n22 }];
    } else {
      let s13 = o10[0], n22 = s13;
      for (let t8 = 0; t8 < o10.length; t8++) s13 = s13 > o10[t8] ? o10[t8] : s13, n22 = n22 > o10[t8] ? n22 : o10[t8];
      t7.statistics = [{ ...e9[0], min: s13, max: n22 }];
    }
    this.rasterInfo = t7, this.lookup = n21 ? null : y2({ srcPixelType: s12, inputRanges: a35, outputValues: o10, noDataRanges: i28, allowUnmatched: n21, isLastInputRangeInclusive: l23, outputPixelType: this.outputPixelType });
    return { success: true, supportsGPU: (!o10 || o10.length <= i2) && (!i28 || i28.length <= i2) };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s12) return null;
    const { lookup: e9, outputPixelType: n21 } = this;
    if (e9) {
      const t8 = f3(s12, { lut: [e9.lut], offset: e9.offset, outputPixelType: n21 });
      return null != t8 && e9.mask && (t8.mask = c(s12.pixels[0], s12.mask, e9.mask, e9.offset, "u8")), t8;
    }
    const { inputRanges: o10, outputValues: a35, noDataRanges: u21, allowUnmatched: r12, isLastInputRangeInclusive: c36 } = this.functionArguments;
    return p2(s12, { inputRanges: o10, outputValues: a35, noDataRanges: u21, outputPixelType: n21, allowUnmatched: r12, isLastInputRangeInclusive: c36 });
  }
  _getWebGLParameters() {
    const { allowUnmatched: t7, noDataRanges: e9, isLastInputRangeInclusive: n21 } = this.functionArguments, a35 = new Float32Array(3 * i2), u21 = 1e-5, i28 = this.functionArguments.inputRanges ?? [], l23 = this.functionArguments.outputValues ?? [], p21 = l23.length;
    for (let o10 = 0; o10 < i2; o10++) a35[3 * o10] = i28[2 * o10] ?? d - 1, a35[3 * o10 + 1] = i28[2 * o10 + 1] ?? d, a35[3 * o10 + 2] = l23[o10] ?? 0, o10 < p21 && (o10 > 0 && (a35[3 * o10] -= u21), (o10 < p21 - 1 || !n21) && (a35[3 * o10 + 1] -= u21));
    const c36 = new Float32Array(2 * i2);
    c36.fill(d), (e9 == null ? void 0 : e9.length) && c36.set(e9);
    return { allowUnmatched: t7, rangeMaps: a35, noDataRanges: c36, clampRange: s3(this.outputPixelType) };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], m14.prototype, "functionName", void 0), r([m({ type: r10, json: { write: true, name: "rasterFunctionArguments" } })], m14.prototype, "functionArguments", void 0), r([m()], m14.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], m14.prototype, "lookup", void 0), m14 = r([a2("esri.layers.support.rasterFunctions.RemapFunction")], m14);
var g6 = m14;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ShadedReliefFunctionArguments.js
var a28;
var c25 = a28 = class extends m12 {
  readColorRamp(o10) {
    if ("string" == typeof o10) {
      const r12 = a5.jsonValues.find((r13) => r13.toLowerCase() === o10.toLowerCase());
      return r12 ? d3(a5.fromJSON(r12)) : null;
    }
    return "toJSON" in o10 ? o10.toJSON() : o10;
  }
  clone() {
    return new a28({ hillshadeType: this.hillshadeType, altitude: this.altitude, azimuth: this.azimuth, zFactor: this.zFactor, slopeType: this.slopeType, pixelSizeFactor: this.pixelSizeFactor, pixelSizePower: this.pixelSizePower, removeEdgeEffect: this.removeEdgeEffect, colorRamp: this.colorRamp, colormap: this.colormap, raster: this.raster });
  }
};
r([m({ json: { write: true } })], c25.prototype, "colorRamp", void 0), r([o("colorRamp")], c25.prototype, "readColorRamp", null), r([m({ type: [[Number]], json: { write: true } })], c25.prototype, "colormap", void 0), c25 = a28 = r([a2("esri.layers.support.rasterFunctions.ShadedReliefFunctionArguments")], c25);
var l18 = c25;

// node_modules/@arcgis/core/layers/support/rasterFunctions/ShadedReliefFunction.js
var h6 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "ShadedRelief", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    const e9 = this.sourceRasterInfos[0];
    if (e9.bandCount > 1) return { success: false, supportsGPU: false, error: "shadedrelief-function: source data must be single band" };
    let { colorRamp: t7, colormap: s12 } = this.functionArguments;
    if (!t7 && !(s12 == null ? void 0 : s12.length)) return { success: false, supportsGPU: false, error: "shadedrelief-function: a color ramp argument must be specified" };
    this.outputPixelType = this._getOutputPixelType("u8");
    const r12 = e9.clone();
    this._removeStatsHistColormapVAT(r12), r12.pixelType = this.outputPixelType, r12.bandCount = 3, r12.statistics = [{ min: 0, max: 255, avg: 60, stddev: 10 }, { min: 0, max: 255, avg: 60, stddev: 10 }, { min: 0, max: 255, avg: 60, stddev: 10 }], this.rasterInfo = r12, this.isGCS = ((_a = r12.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, (s12 == null ? void 0 : s12.length) || (s12 = B(t7, { interpolateAlpha: true }));
    const { indexedColormap: o10, offset: n21 } = a3({ colormap: s12 });
    if (!(o10 == null ? void 0 : o10.length)) return { success: false, supportsGPU: false, error: "shadedrelief-function: a valid colorramp is required" };
    const p21 = D2(o10);
    return this.lookup = { indexedColormap: o10, offset: n21, hsvMap: p21 }, { success: true, supportsGPU: a6(o10) };
  }
  _processPixels(e9) {
    var _a, _b, _c;
    const t7 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (!t7 || !this.lookup) return null;
    let s12 = (_b = e9.primaryPixelSizes) == null ? void 0 : _b[0];
    if (null == s12) {
      const { extent: r13 } = e9;
      s12 = r13 ? { x: r13.width / t7.width, y: r13.height / t7.height } : { x: 1, y: 1 };
    }
    const r12 = d2(this.functionArguments, s12, this.isGCS), o10 = r5(t7, r12), i28 = ((_c = this.sourceRasterInfos[0].statistics) == null ? void 0 : _c[0]) ?? { min: 0, max: 8e3 };
    return c2(o10, t7, this.lookup.hsvMap, i28), o10.pixelType = this.outputPixelType, o10;
  }
  _getWebGLParameters() {
    var _a;
    const e9 = d2(this.functionArguments, { x: 1, y: 1 }, this.isGCS), t7 = a4(e9), { slopeType: s12, zFactor: o10, pixelSizeFactor: i28, pixelSizePower: n21 } = this.functionArguments, a35 = "scaled" === s12, { indexedColormap: u21, offset: m17 } = this.lookup, d10 = (_a = this.sourceRasterInfos[0].statistics) == null ? void 0 : _a[0], f7 = o2(this.outputPixelType);
    return { ...t7, indexedColormap: u21, offset: m17, zFactor: o10, gcsFactor: this.isGCS ? n4 : 1, pixelSizeFactor: a35 ? i28 : 0, pixelSizePower: a35 ? n21 : 0, minValue: (d10 == null ? void 0 : d10.min) ?? 0, maxValue: (d10 == null ? void 0 : d10.max) ?? 8e3, isOutputRounded: f7 };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], h6.prototype, "functionName", void 0), r([m({ type: l18, json: { write: true, name: "rasterFunctionArguments" } })], h6.prototype, "functionArguments", void 0), r([m()], h6.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], h6.prototype, "isGCS", void 0), r([m({ json: { write: true } })], h6.prototype, "lookup", void 0), h6 = r([a2("esri.layers.support.rasterFunctions.ShadedReliefFunction")], h6);
var x5 = h6;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunctionArguments.js
var i23;
var c26 = new n({ 1: "degree", 2: "percent-rise", 3: "adjusted" }, { useNumericKeys: true });
var a29 = i23 = class extends p4 {
  constructor() {
    super(...arguments), this.slopeType = "degree", this.zFactor = 1, this.pixelSizePower = 0.664, this.pixelSizeFactor = 0.024, this.removeEdgeEffect = false;
  }
  clone() {
    return new i23({ slopeType: this.slopeType, zFactor: this.zFactor, pixelSizePower: this.pixelSizePower, pixelSizeFactor: this.pixelSizeFactor, removeEdgeEffect: this.removeEdgeEffect, raster: this.raster });
  }
};
r([r3(c26)], a29.prototype, "slopeType", void 0), r([m({ type: Number, json: { write: true } })], a29.prototype, "zFactor", void 0), r([m({ type: Number, json: { name: "psPower", write: true } })], a29.prototype, "pixelSizePower", void 0), r([m({ type: Number, json: { name: "psZFactor", write: true } })], a29.prototype, "pixelSizeFactor", void 0), r([m({ type: Boolean, json: { write: true } })], a29.prototype, "removeEdgeEffect", void 0), a29 = i23 = r([a2("esri.layers.support.rasterFunctions.SlopeFunctionArguments")], a29);
var m15 = a29;

// node_modules/@arcgis/core/layers/support/rasterFunctions/SlopeFunction.js
var u18 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Slope", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isGCS = false;
  }
  _bindSourceRasters() {
    var _a;
    this.outputPixelType = this._getOutputPixelType("f32");
    const e9 = this.sourceRasterInfos[0].clone();
    return e9.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(e9), e9.statistics = "percent-rise" !== this.functionArguments.slopeType ? [{ min: 0, max: 90, avg: 1, stddev: 1 }] : null, e9.bandCount = 1, this.rasterInfo = e9, this.isGCS = ((_a = e9.spatialReference) == null ? void 0 : _a.isGeographic) ?? false, { success: true, supportsGPU: true };
  }
  _processPixels(e9) {
    var _a;
    const t7 = (_a = e9.pixelBlocks) == null ? void 0 : _a[0];
    if (null == t7) return null;
    const { zFactor: s12, slopeType: r12, pixelSizePower: o10, pixelSizeFactor: i28 } = this.functionArguments, { isGCS: n21 } = this, { extent: u21, primaryPixelSizes: c36 } = e9, a35 = c36 == null ? void 0 : c36[0], l23 = a35 ?? (u21 ? { x: u21.width / t7.width, y: u21.height / t7.height } : { x: 1, y: 1 });
    return h(t7, { zFactor: s12, slopeType: r12, pixelSizePower: o10, pixelSizeFactor: i28, isGCS: n21, resolution: l23 });
  }
  _getWebGLParameters() {
    const { zFactor: e9, slopeType: t7, pixelSizeFactor: s12, pixelSizePower: o10 } = this.functionArguments;
    return { zFactor: this.isGCS && e9 >= 1 ? e9 * n4 : e9, slopeType: t7, pixelSizeFactor: s12 ?? 0, pixelSizePower: o10 ?? 0, isOutputRounded: o2(this.outputPixelType) };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], u18.prototype, "functionName", void 0), r([m({ type: m15, json: { write: true, name: "rasterFunctionArguments" } })], u18.prototype, "functionArguments", void 0), r([m()], u18.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], u18.prototype, "isGCS", void 0), u18 = r([a2("esri.layers.support.rasterFunctions.SlopeFunction")], u18);
var c27 = u18;

// node_modules/@arcgis/core/layers/support/rasterFunctions/focalStatUtils.js
var n15 = new n({ 1: "min", 2: "max", 3: "mean", 4: "stddev", 5: "median", 6: "majority", 7: "minority" }, { useNumericKeys: true });
function s11(t7, e9) {
  const { fillNoDataOnly: o10 } = e9, { band: n21, width: s12, height: r12, mask: i28, outBand: l23 } = t7;
  if (o10 && !i28) return void l23.set(n21);
  const { statisticsType: a35, kernelRows: c36, kernelCols: f7 } = e9, h7 = "stddev" === a35, m17 = s12 * r12, u21 = new Float64Array(m17), d10 = new Float64Array(m17), y6 = new Uint32Array(m17);
  for (let A4 = 0; A4 < r12; A4++) {
    const t8 = A4 * s12;
    let e10 = 0, o11 = 0, r13 = 0;
    for (let s13 = 0; s13 < f7; s13++) i28 && !i28[t8 + s13] || (e10 += n21[t8 + s13], h7 && (o11 += n21[t8 + s13] ** 2), r13++);
    u21[t8] = e10, d10[t8] = o11, y6[t8] = r13;
    for (let l24 = 1; l24 <= s12 - f7; l24++) {
      const s13 = t8 + l24 - 1, a36 = s13 + f7;
      i28 ? (i28[s13] && (r13--, e10 -= n21[s13], h7 && (o11 -= n21[s13] ** 2)), i28[a36] && (r13++, e10 += n21[a36], h7 && (o11 += n21[a36] ** 2))) : (e10 -= n21[s13], e10 += n21[a36], h7 && (o11 -= n21[s13] ** 2, o11 += n21[a36] ** 2)), u21[t8 + l24] = e10, y6[t8 + l24] = r13, h7 && (d10[t8 + l24] = o11);
    }
  }
  const k4 = new Float64Array(m17), w7 = new Float64Array(m17), p21 = new Uint32Array(m17), M4 = c36 * s12;
  for (let A4 = 0; A4 <= s12 - f7; A4++) {
    let t8 = 0, e10 = 0, o11 = 0;
    for (let n22 = 0; n22 < c36; n22++) {
      const r13 = n22 * s12 + A4;
      t8 += u21[r13], o11 += y6[r13], h7 && (e10 += d10[r13]);
    }
    k4[A4] = t8, w7[A4] = e10, p21[A4] = o11;
    for (let n22 = 1; n22 <= r12 - c36; n22++) {
      const r13 = (n22 - 1) * s12 + A4, i29 = r13 + M4;
      t8 -= u21[r13], t8 += u21[i29], o11 -= y6[r13], o11 += y6[i29], h7 && (e10 -= d10[r13], e10 += d10[i29]), k4[n22 * s12 + A4] = t8, w7[n22 * s12 + A4] = e10, p21[n22 * s12 + A4] = o11;
    }
  }
  const g7 = Math.floor(c36 / 2), b3 = Math.floor(f7 / 2);
  for (let A4 = g7; A4 < r12 - g7; A4++) {
    const t8 = A4 * s12;
    for (let e10 = b3; e10 < s12 - b3; e10++) {
      const n22 = (A4 - g7) * s12 + e10 - b3, r13 = p21[n22];
      if (0 === r13 || o10 && (!i28 || i28[t8 + e10])) continue;
      const a36 = k4[n22] / r13, c37 = h7 ? Math.sqrt((w7[n22] - k4[n22] * a36) / r13) : a36;
      l23[t8 + e10] = c37, i28 && (i28[t8 + e10] = 255);
    }
  }
}
function r11(t7, e9) {
  const { fillNoDataOnly: o10 } = e9, { band: n21, width: s12, height: r12, mask: i28, outBand: l23 } = t7;
  if (o10 && !i28) return void l23.set(n21);
  const { kernelRows: a35, kernelCols: c36, statisticsType: f7 } = e9, h7 = Math.floor(a35 / 2), m17 = Math.floor(c36 / 2), u21 = "min" === f7, d10 = l23.slice(), y6 = new Uint32Array(s12 * r12);
  for (let k4 = h7; k4 < r12 - h7; k4++) {
    const t8 = k4 * s12;
    for (let e10 = m17; e10 < s12 - m17; e10++) {
      let o11 = u21 ? Number.MAX_VALUE : -Number.MAX_VALUE, r13 = 0;
      for (let l24 = 0; l24 < a35; l24++) for (let a36 = 0; a36 < c36; a36++) {
        const c37 = t8 + e10 + (l24 - h7) * s12 + a36 - m17;
        i28 && !i28[c37] || (o11 = u21 ? Math.min(o11, n21[c37]) : Math.max(o11, n21[c37]), r13++);
      }
      i28 ? (d10[t8 + e10] = 0 === r13 ? 0 : o11, y6[t8 + e10] = r13) : l23[t8 + e10] = 0 === r13 ? 0 : o11;
    }
  }
  if (i28) for (let k4 = h7; k4 < r12 - h7; k4++) {
    const t8 = k4 * s12;
    for (let e10 = m17; e10 < s12 - m17; e10++) if (y6[t8 + e10]) {
      if (o10 && i28[t8 + e10]) continue;
      l23[t8 + e10] = d10[t8 + e10], i28[t8 + e10] = 255;
    }
  }
}
function i24(t7, e9) {
  const { fillNoDataOnly: o10 } = e9, { band: n21, width: s12, height: r12, mask: i28, outBand: l23 } = t7;
  if (o10 && !i28) return void l23.set(n21);
  const { kernelRows: a35, kernelCols: c36 } = e9, f7 = Math.floor(a35 / 2), h7 = Math.floor(c36 / 2), m17 = l23.slice(), u21 = new Uint32Array(s12 * r12);
  for (let d10 = f7; d10 < r12 - f7; d10++) {
    const t8 = d10 * s12;
    for (let e10 = h7; e10 < s12 - h7; e10++) {
      if (o10 && (i28 == null ? void 0 : i28[t8 + e10])) continue;
      const r13 = [];
      for (let o11 = 0; o11 < a35; o11++) for (let l24 = 0; l24 < c36; l24++) {
        const a36 = t8 + e10 + (o11 - f7) * s12 + l24 - h7;
        i28 && !i28[a36] || r13.push(n21[a36]);
      }
      r13.length && (r13.sort((t9, e11) => t9 - e11), i28 ? (m17[t8 + e10] = r13[Math.floor((r13.length - 1) / 2)], u21[t8 + e10] = r13.length) : l23[t8 + e10] = r13[Math.floor((r13.length - 1) / 2)]);
    }
  }
  if (i28) for (let d10 = f7; d10 < r12 - f7; d10++) {
    const t8 = d10 * s12;
    for (let e10 = h7; e10 < s12 - h7; e10++) if (u21[t8 + e10]) {
      if (o10 && i28[t8 + e10]) continue;
      l23[t8 + e10] = m17[t8 + e10], i28[t8 + e10] = 255;
    }
  }
}
function l19(t7, e9) {
  const { fillNoDataOnly: o10 } = e9, { band: n21, width: s12, height: r12, mask: i28, outBand: l23 } = t7;
  if (o10 && !i28) return void l23.set(n21);
  const { kernelRows: a35, kernelCols: c36 } = e9, f7 = Math.floor(a35 / 2), h7 = Math.floor(c36 / 2), m17 = "majority" === e9.statisticsType, u21 = a35 * c36, d10 = l23.slice(), y6 = new Uint32Array(s12 * r12);
  for (let k4 = f7; k4 < r12 - f7; k4++) {
    const t8 = k4 * s12;
    for (let e10 = h7; e10 < s12 - h7; e10++) {
      if (o10 && (i28 == null ? void 0 : i28[t8 + e10])) continue;
      const r13 = /* @__PURE__ */ new Map();
      for (let o11 = 0; o11 < a35; o11++) for (let l24 = 0; l24 < c36; l24++) {
        const a36 = t8 + e10 + (o11 - f7) * s12 + l24 - h7;
        if (i28 && !i28[a36]) continue;
        const c37 = n21[a36];
        r13.set(c37, r13.has(c37) ? r13.get(c37) + 1 : 1);
      }
      if (0 === r13.size) continue;
      let k5 = 0, w7 = 0, p21 = m17 ? 0 : u21 + 1;
      for (const t9 of r13.keys()) w7 = r13.get(t9), m17 === w7 > p21 && (p21 = w7, k5 = t9);
      i28 ? (d10[t8 + e10] = k5, y6[t8 + e10] = r13.size) : l23[t8 + e10] = k5;
    }
  }
  if (i28) for (let k4 = f7; k4 < r12 - f7; k4++) {
    const t8 = k4 * s12;
    for (let e10 = h7; e10 < s12 - h7; e10++) if (y6[t8 + e10]) {
      if (o10 && i28[t8 + e10]) continue;
      l23[t8 + e10] = d10[t8 + e10], i28[t8 + e10] = 255;
    }
  }
}
function a30(t7, n21) {
  const { mask: a35 } = t7, { fillNoDataOnly: c36 } = n21;
  if (c36 && !a35) return t7;
  const { pixels: f7, width: h7, height: m17, bandMasks: u21, pixelType: d10 } = t7, y6 = f7.length, k4 = h7 * m17, w7 = [], { kernelRows: p21, kernelCols: M4, statisticsType: g7, mirrorEdges: b3 } = n21;
  if (c36 && !a35) return t7;
  const A4 = n21.outputPixelType ?? d10, x7 = [];
  for (let N2 = 0; N2 < y6; N2++) {
    const t8 = f7[N2], d11 = g.createEmptyBand(A4, k4);
    c36 && d11.set(t8);
    const y7 = (u21 == null ? void 0 : u21[N2]) ?? a35, j5 = (y7 == null ? void 0 : y7.slice()) ?? null, B6 = { band: t8, width: h7, height: m17, mask: j5, outBand: d11 };
    switch (g7) {
      case "min":
      case "max":
        r11(B6, n21);
        break;
      case "mean":
      case "stddev":
        s11(B6, n21);
        break;
      case "median":
        i24(B6, n21);
        break;
      case "majority":
      case "minority":
        l19(B6, n21);
    }
    b3 && !c36 && o8(d11, h7, m17, p21, M4), w7.push(d11), j5 && x7.push(j5);
  }
  let j4 = x7[0] ?? a35;
  x7.length !== y6 && (x7.length = 0), y6 > 1 && (u21 == null ? void 0 : u21.length) && (j4 = g.combineBandMasks(u21));
  const B5 = new g({ pixelType: A4, width: h7, height: m17, pixels: w7, bandMasks: u21 && x7.length ? x7 : null, mask: j4 });
  return B5.updateStatistics(), B5;
}

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunctionArguments.js
var c28;
var p17 = c28 = class extends p4 {
  constructor() {
    super(...arguments), this.rows = 3, this.cols = 3, this.fillNoDataOnly = false, this.statisticsType = "min";
  }
  clone() {
    return new c28({ rows: this.rows, cols: this.cols, fillNoDataOnly: this.fillNoDataOnly, statisticsType: this.statisticsType, raster: a(this.raster) });
  }
};
r([m({ json: { write: true, read: { source: ["kernelRows", "rows"], reader: (s12, r12) => Number(s12 ?? (r12 == null ? void 0 : r12.kernelRows) ?? 3) } } })], p17.prototype, "rows", void 0), r([m({ json: { write: true, read: { source: ["kernelCols", "cols"], reader: (s12, r12) => Number(s12 ?? (r12 == null ? void 0 : r12.kernelCols) ?? 3) } } })], p17.prototype, "cols", void 0), r([m({ json: { write: true } })], p17.prototype, "fillNoDataOnly", void 0), r([m({ json: { read: { source: ["statisticsType", "type"], reader: (s12, r12) => n15.fromJSON((r12 == null ? void 0 : r12.statisticsType) ?? (r12 == null ? void 0 : r12.type)) ?? "min" }, write: { target: "type" } } }), r3(n15)], p17.prototype, "statisticsType", void 0), p17 = c28 = r([a2("esri.layers.support.rasterFunctions.StatisticsFunctionArguments")], p17);
var l20 = p17;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsFunction.js
var c29 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Statistics", this.rasterArgumentNames = ["raster"];
  }
  _bindSourceRasters() {
    const { type: t7 } = this.functionArguments.toJSON();
    if (t7 < 1 || t7 > 7) return { success: false, supportsGPU: false, error: `statistics-function: the given statistics type is not supported ${t7}` };
    const s12 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType(s12.pixelType);
    const e9 = s12.clone();
    e9.pixelType = this.outputPixelType;
    const { statisticsType: o10 } = this.functionArguments;
    "stddev" === o10 && this._removeStatsHistColormapVAT(e9), this.rasterInfo = e9;
    return { success: true, supportsGPU: e9.bandCount <= 3 && t7 < 5 };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s12) return s12;
    const { statisticsType: e9, rows: o10, cols: r12, fillNoDataOnly: n21 } = this.functionArguments;
    return a30(s12, { kernelRows: o10, kernelCols: r12, fillNoDataOnly: n21, outputPixelType: this.outputPixelType, statisticsType: e9, mirrorEdges: true });
  }
  _getWebGLParameters() {
    const { rows: t7, cols: s12, statisticsType: e9, fillNoDataOnly: r12 } = this.functionArguments;
    return { fillNoDataOnly: r12, kernelRows: t7, kernelCols: s12, statisticsType: e9, clampRange: s3(this.outputPixelType) };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], c29.prototype, "functionName", void 0), r([m({ type: l20, json: { write: true, name: "rasterFunctionArguments" } })], c29.prototype, "functionArguments", void 0), r([m()], c29.prototype, "rasterArgumentNames", void 0), c29 = r([a2("esri.layers.support.rasterFunctions.StatisticsFunction")], c29);
var p18 = c29;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunctionArguments.js
var c30;
var n16 = c30 = class extends p4 {
  constructor() {
    super(...arguments), this.statistics = null, this.histograms = null;
  }
  readStatistics(t7, s12) {
    if (!(t7 == null ? void 0 : t7.length)) return null;
    const r12 = [];
    return t7.forEach((t8) => {
      const s13 = { min: t8.min, max: t8.max, avg: t8.avg ?? t8.mean, stddev: t8.stddev ?? t8.standardDeviation };
      r12.push(s13);
    }), r12;
  }
  writeStatistics(t7, s12, r12) {
    if (!(t7 == null ? void 0 : t7.length)) return;
    const o10 = [];
    t7.forEach((t8) => {
      const s13 = { ...t8, mean: t8.avg, standardDeviation: t8.stddev };
      delete s13.avg, delete s13.stddev, o10.push(s13);
    }), s12[r12] = o10;
  }
  clone() {
    return new c30({ statistics: a(this.statistics), histograms: a(this.histograms) });
  }
};
r([m({ json: { write: true } })], n16.prototype, "statistics", void 0), r([o("statistics")], n16.prototype, "readStatistics", null), r([r2("statistics")], n16.prototype, "writeStatistics", null), r([m({ json: { write: true } })], n16.prototype, "histograms", void 0), n16 = c30 = r([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunctionArguments")], n16);
var p19 = n16;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StatisticsHistogramFunction.js
var i25 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "StatisticsHistogram", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0];
    this.outputPixelType = this._getOutputPixelType("u8");
    const s12 = t7.clone(), { statistics: o10, histograms: r12 } = this.functionArguments;
    return r12 && (s12.histograms = r12), o10 && (s12.statistics = o10), this.rasterInfo = s12, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    return (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], i25.prototype, "functionName", void 0), r([m({ type: p19, json: { write: true, name: "rasterFunctionArguments" } })], i25.prototype, "functionArguments", void 0), r([m()], i25.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], i25.prototype, "indexedColormap", void 0), r([m()], i25.prototype, "isNoopProcess", void 0), i25 = r([a2("esri.layers.support.rasterFunctions.StatisticsHistogramFunction")], i25);
var n17 = i25;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunctionArguments.js
var n18;
var p20 = new n({ 0: "none", 3: "standard-deviation", 4: "histogram-equalization", 5: "min-max", 6: "percent-clip", 9: "sigmoid" }, { useNumericKeys: true });
var c31 = n18 = class extends p4 {
  constructor() {
    super(...arguments), this.computeGamma = false, this.dynamicRangeAdjustment = false, this.gamma = [], this.histograms = null, this.statistics = null, this.stretchType = "none", this.useGamma = false;
  }
  writeStatistics(t7, e9, o10) {
    (t7 == null ? void 0 : t7.length) && (Array.isArray(t7[0]) || (t7 = t7.map((t8) => [t8.min, t8.max, t8.avg, t8.stddev])), e9[o10] = t7);
  }
  clone() {
    return new n18({ stretchType: this.stretchType, outputMin: this.outputMin, outputMax: this.outputMax, useGamma: this.useGamma, computeGamma: this.computeGamma, statistics: a(this.statistics), gamma: a(this.gamma), sigmoidStrengthLevel: this.sigmoidStrengthLevel, numberOfStandardDeviations: this.numberOfStandardDeviations, minPercent: this.minPercent, maxPercent: this.maxPercent, histograms: a(this.histograms), dynamicRangeAdjustment: this.dynamicRangeAdjustment, raster: this.raster });
  }
};
r([m({ type: Boolean, json: { write: true } })], c31.prototype, "computeGamma", void 0), r([m({ type: Boolean, json: { name: "dra", write: true } })], c31.prototype, "dynamicRangeAdjustment", void 0), r([m({ type: [Number], json: { write: true } })], c31.prototype, "gamma", void 0), r([m()], c31.prototype, "histograms", void 0), r([m({ type: Number, json: { write: true } })], c31.prototype, "maxPercent", void 0), r([m({ type: Number, json: { write: true } })], c31.prototype, "minPercent", void 0), r([m({ type: Number, json: { write: true } })], c31.prototype, "numberOfStandardDeviations", void 0), r([m({ type: Number, json: { name: "max", write: true } })], c31.prototype, "outputMax", void 0), r([m({ type: Number, json: { name: "min", write: true } })], c31.prototype, "outputMin", void 0), r([m({ type: Number, json: { write: true } })], c31.prototype, "sigmoidStrengthLevel", void 0), r([m({ json: { type: [[Number]], write: true } })], c31.prototype, "statistics", void 0), r([r2("statistics")], c31.prototype, "writeStatistics", null), r([r3(p20)], c31.prototype, "stretchType", void 0), r([m({ type: Boolean, json: { write: true } })], c31.prototype, "useGamma", void 0), c31 = n18 = r([a2("esri.layers.support.rasterFunctions.StretchFunctionArguments")], c31);
var u19 = c31;

// node_modules/@arcgis/core/layers/support/rasterFunctions/StretchFunction.js
var c32 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Stretch", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.lookup = null, this.cutOffs = null;
  }
  _bindSourceRasters() {
    this.lookup = null, this.cutOffs = null;
    const t7 = this.sourceRasterInfos[0], { pixelType: s12 } = t7, { functionArguments: e9 } = this, { dynamicRangeAdjustment: r12, gamma: u21, useGamma: i28 } = e9;
    if (!r12 && ["u8", "u16", "s8", "s16"].includes(s12)) {
      const r13 = p3(e9.toJSON(), { rasterInfo: t7 }), p22 = o2(this.outputPixelType) ? "round" : "float";
      this.lookup = a7({ pixelType: s12, ...r13, gamma: i28 ? u21 : null, rounding: p22 }), this.cutOffs = r13;
    } else r12 || (this.cutOffs = p3(e9.toJSON(), { rasterInfo: t7 }));
    this.outputPixelType = this._getOutputPixelType(s12);
    const p21 = t7.clone();
    p21.pixelType = this.outputPixelType, this._removeStatsHistColormapVAT(p21), "u8" === this.outputPixelType && (p21.keyProperties.DataType = "processed");
    const { outputMin: m17 = 0, outputMax: c36 = 255 } = this.functionArguments;
    p21.statistics = [];
    for (let o10 = 0; o10 < p21.bandCount; o10++) p21.statistics[o10] = { min: m17, max: c36 };
    this.rasterInfo = p21;
    return { success: true, supportsGPU: !r12 };
  }
  _processPixels(t7) {
    var _a;
    const s12 = (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
    if (null == s12) return s12;
    const { lookup: e9 } = this;
    if (e9) return f3(s12, { ...e9, outputPixelType: this.rasterInfo.pixelType });
    const { functionArguments: o10 } = this, r12 = this.cutOffs || p3(o10.toJSON(), { rasterInfo: this.sourceRasterInfos[0], pixelBlock: s12 }), i28 = o10.useGamma ? o10.gamma : null;
    return M(s12, { ...r12, gamma: i28, outputPixelType: this.outputPixelType });
  }
  _getWebGLParameters() {
    const { outputMin: t7 = 0, outputMax: s12 = 255, gamma: e9, useGamma: r12 } = this.functionArguments, u21 = this.rasterInfo.bandCount >= 2 ? 3 : 1, i28 = r12 && (e9 == null ? void 0 : e9.length) ? x(u21, e9) : [1, 1, 1], { minCutOff: n21, maxCutOff: a35 } = this.cutOffs ?? { minCutOff: [0, 0, 0], maxCutOff: [255, 255, 255] };
    1 === n21.length && (n21[1] = n21[2] = n21[0], a35[1] = a35[2] = a35[0]);
    const p21 = new Float32Array(u21);
    let c36;
    for (c36 = 0; c36 < u21; c36++) p21[c36] = (s12 - t7) / (a35[c36] - n21[c36]);
    const l23 = o2(this.outputPixelType);
    return { bandCount: u21, outMin: t7, outMax: s12, minCutOff: n21, maxCutOff: a35, factor: p21, useGamma: r12, gamma: r12 && e9 ? e9 : [1, 1, 1], gammaCorrection: r12 && i28 ? i28 : [1, 1, 1], stretchType: this.functionArguments.stretchType, isOutputRounded: l23, type: "stretch" };
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], c32.prototype, "functionName", void 0), r([m({ type: u19, json: { write: true, name: "rasterFunctionArguments" } })], c32.prototype, "functionArguments", void 0), r([m()], c32.prototype, "rasterArgumentNames", void 0), r([m({ json: { write: true } })], c32.prototype, "lookup", void 0), r([m({ json: { write: true } })], c32.prototype, "cutOffs", void 0), c32 = r([a2("esri.layers.support.rasterFunctions.StretchFunction")], c32);
var l21 = c32;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunctionArguments.js
var c33;
var a31 = c33 = class extends p4 {
  constructor() {
    super(...arguments), this.attributeTableAsRecordSet = null;
  }
  clone() {
    return new c33({ attributeTableAsRecordSet: a(this.attributeTableAsRecordSet) });
  }
};
r([m({ json: { write: true } })], a31.prototype, "attributeTableAsRecordSet", void 0), a31 = c33 = r([a2("esri.layers.support.rasterFunctions.TableFunctionArguments")], a31);
var i26 = a31;

// node_modules/@arcgis/core/layers/support/rasterFunctions/TableFunction.js
var i27 = class extends p5 {
  constructor() {
    super(...arguments), this.functionName = "Table", this.functionArguments = null, this.rasterArgumentNames = ["raster"], this.isNoopProcess = true;
  }
  _bindSourceRasters() {
    const t7 = this.sourceRasterInfos[0];
    if (t7.bandCount > 1 || t7.pixelType.startsWith("f")) return { success: false, supportsGPU: false, error: "table-function: Source data must be single band and integer pixel type." };
    const { attributeTableAsRecordSet: e9 } = this.functionArguments;
    if (!e9) return { success: false, supportsGPU: false, error: "table-function: Missing attributeTableAsRecordSet argument." };
    this.outputPixelType = this._getOutputPixelType(t7.pixelType);
    const s12 = t7.clone();
    return s12.pixelType = this.outputPixelType, s12.bandCount = 1, "thematic" !== s12.dataType && (s12.keyProperties = s12.keyProperties ? { ...s12.keyProperties, DataType: "thematic" } : { DataType: "thematic" }), this.rasterInfo = s12, { success: true, supportsGPU: true };
  }
  _processPixels(t7) {
    var _a;
    return (_a = t7.pixelBlocks) == null ? void 0 : _a[0];
  }
};
r([m({ json: { write: true, name: "rasterFunction" } })], i27.prototype, "functionName", void 0), r([m({ type: i26, json: { write: true, name: "rasterFunctionArguments" } })], i27.prototype, "functionArguments", void 0), r([m()], i27.prototype, "rasterArgumentNames", void 0), r([m()], i27.prototype, "isNoopProcess", void 0), i27 = r([a2("esri.layers.support.rasterFunctions.TableFunction")], i27);
var n19 = i27;

// node_modules/@arcgis/core/layers/support/rasterFunctions/rasterFunctionHelper.js
var v3 = /* @__PURE__ */ new Map();
function w6(t7, e9) {
  const { rasterFunctionArguments: r12 } = t7;
  if (!r12) return;
  (r12.rasters || [r12.raster, r12.raster2]).forEach((t8) => {
    t8 && "number" != typeof t8 && ("string" == typeof t8 ? t8.startsWith("http") && (e9.includes(t8) || e9.push(t8)) : "rasterFunctionArguments" in t8 && w6(t8, e9));
  });
}
function T2(t7, n21) {
  if (n21 = n21 ?? {}, "function" in (t7 = a(t7)) && "arguments" in t7 && t7.arguments) {
    const r12 = $2(t7, /* @__PURE__ */ new Map(), n21);
    if (L2(r12), !r12.renderingRule) throw new s("raster-function-helper", "Unsupported raster function json.");
    t7 = r12.renderingRule;
  }
  if ("rasterFunction" in t7) return k3(t7 = B4(t7), n21);
  throw new s("raster-function-helper", "unsupported raster function json.");
}
function D4(t7, e9) {
  return "rasters" === e9[0] && Array.isArray(t7.rasters) ? t7.rasters : e9.map((e10) => t7[e10]);
}
function V2(t7) {
  return !!(t7 && "object" == typeof t7 && t7.rasterFunction && t7.rasterFunctionArguments);
}
function B4(t7) {
  var _a;
  const { rasterFunction: e9, rasterFunctionArguments: r12 } = t7, n21 = {};
  for (const o10 in r12) {
    let t8 = r12[o10];
    const e10 = o10.toLowerCase();
    if ("rasters" === e10 && Array.isArray(t8)) n21.rasters = t8.map((t9) => V2(t9) ? B4(t9) : t9);
    else switch (V2(t8) && (t8 = B4(t8)), e10) {
      case "dra":
        n21.dra = t8;
        break;
      case "pspower":
        n21.psPower = t8;
        break;
      case "pszfactor":
        n21.psZFactor = t8;
        break;
      case "bandids":
        n21.bandIds = t8;
        break;
      default:
        n21[o10[0].toLowerCase() + o10.slice(1)] = t8;
    }
  }
  return "Local" !== e9 || ((_a = n21.rasters) == null ? void 0 : _a.length) || (n21.rasters = ["$$"]), { ...t7, rasterFunctionArguments: n21 };
}
function k3(t7, r12) {
  var _a, _b;
  const { rasterFunction: n21, rasterFunctionArguments: o10 } = t7, s12 = (_a = t7.outputPixelType) == null ? void 0 : _a.toLowerCase();
  if (null == n21 || !v3.has(n21)) throw new s("raster-function-helper", `unsupported raster function: ${n21}`);
  const a35 = v3.get(n21), i28 = ("function" == typeof a35.ctor ? a35.ctor : a35.ctor.default).fromJSON({ ...t7, outputPixelType: s12 }), { rasterArgumentNames: c36 } = i28, u21 = [], m17 = D4(o10, c36), l23 = "rasters" === c36[0] || c36.length > 1, p21 = [];
  for (let e9 = 0; e9 < m17.length; e9++) {
    const t8 = m17[e9];
    let n22;
    null == t8 || "string" == typeof t8 && t8.startsWith("$") ? u21.push(r12 == null ? void 0 : r12.raster) : "string" == typeof t8 ? r12[t8] && u21.push(r12[t8]) : "number" != typeof t8 && "rasterFunction" in t8 && (n22 = k3(t8, r12), l23 || (i28.functionArguments[c36[e9]] = n22), u21.push(n22)), l23 && p21.push(n22 ?? t8);
  }
  if (l23 && ("rasters" === c36[0] ? i28.functionArguments.rasters = p21 : c36.forEach((t8, e9) => {
    i28.functionArguments[t8] = p21[e9];
  })), r12) {
    i28.sourceRasters = u21;
    const t8 = (_b = r12.raster) == null ? void 0 : _b.url;
    t8 && (i28.mainPrimaryRasterId = t8);
  }
  return i28;
}
function x6(t7, e9) {
  if (t7 && e9) for (const r12 in t7) {
    const n21 = t7[r12];
    n21 && "object" == typeof n21 && "type" in n21 && ("RasterFunctionTemplate" === n21.type ? x6(n21.arguments, e9) : "RasterFunctionVariable" === n21.type && null != e9[n21.name] && (n21.value = e9[n21.name]));
  }
}
function E2(t7, r12) {
  var _a;
  if (!t7 || "object" != typeof t7) return t7;
  const { value: n21 } = t7;
  if (!n21 || "object" != typeof n21) return t7.isDataset ? "$$" : n21;
  if (Array.isArray(n21)) return 0 === n21.length ? [] : n21.map((t8) => "object" == typeof t8 && "RasterFunctionVariable" === t8.type ? E2(t8, r12) : t8);
  if ("value" in n21 && ["number", "string", "boolean"].includes(typeof n21.value)) return n21.value;
  if (t7.isDataset && "Scalar" !== n21.type) return "$$";
  if (!("type" in n21)) return n21;
  let o10 = n21;
  switch (n21.type) {
    case "Scalar":
      o10 = n21.value;
      break;
    case "AlgorithmicColorRamp":
      o10 = M3(n21);
      break;
    case "MultiPartColorRamp":
      o10 = { type: "multipart", colorRamps: n21.ArrayOfColorRamp.map(M3) };
      break;
    case "ArgumentArray":
      if (((_a = n21.elements) == null ? void 0 : _a.length) && "RasterStatistics" !== n21.elements[0].type) {
        const t8 = [];
        for (let o11 = 0; o11 < n21.elements.length; o11++) {
          const s12 = n21.elements[o11], { type: a35 } = s12;
          if (a35) if ("RasterFunctionTemplate" === a35) {
            const { renderingRule: e9 } = $2(s12, r12);
            t8.push(e9), null != s12._object_id && r12.set(s12._object_id, e9);
          } else {
            if ("RasterFunctionVariable" !== a35) throw new s("raster-function-helper", "unsupported raster function json.");
            {
              const e9 = E2(s12, r12);
              t8.push(e9), null != s12._object_id && r12.set(s12._object_id, e9);
            }
          }
          else t8.push(s12);
        }
        o10 = t8;
      } else o10 = n21.elements;
  }
  return null != n21._object_id && r12.set(n21._object_id, o10), o10;
}
function M3(e9) {
  const r12 = e9.algorithm ?? "esriHSVAlgorithm";
  let { FromColor: n21, ToColor: o10 } = e9;
  if (!Array.isArray(n21)) {
    const { r: e10, g: r13, b: o11 } = A({ h: n21.Hue, s: n21.Saturation, v: n21.Value });
    n21 = [e10, r13, o11, n21.AlphaValue];
  }
  if (!Array.isArray(o10)) {
    const { r: e10, g: r13, b: n22 } = A({ h: o10.Hue, s: o10.Saturation, v: o10.Value });
    o10 = [e10, r13, n22, o10.AlphaValue];
  }
  return { type: "algorithmic", algorithm: r12, fromColor: n21, toColor: o10 };
}
function $2(t7, e9, r12) {
  r12 && x6(t7, r12);
  const n21 = { renderingRule: {}, templates: e9 };
  return H2(t7, n21), n21;
}
function H2(t7, e9) {
  if (!t7 || !e9.renderingRule) return;
  const { renderingRule: r12, templates: n21 } = e9, { function: o10, arguments: s12, _object_id: a35 } = t7;
  if (!o10 || !s12) return;
  null != a35 && n21.set(a35, r12), r12.rasterFunction = o10.type.replace("Function", ""), r12.outputPixelType = o10.pixelType;
  const i28 = {};
  r12.rasterFunctionArguments = i28;
  for (const c36 in s12) {
    if ("type" === c36 || "object_id" === c36 || "_object_ref_id" === c36) continue;
    const t8 = s12[c36];
    t8 && "object" == typeof t8 && "type" in t8 && ("RasterFunctionTemplate" === t8.type || "RasterFunctionVariable" === t8.type) ? ("RasterFunctionVariable" === t8.type ? i28[c36] = E2(t8, n21) : (r12.rasterFunctionArguments[c36] = {}, H2(t8, { renderingRule: r12.rasterFunctionArguments[c36], templates: n21 })), null != t8._object_id && n21.set(t8._object_id, i28[c36])) : i28[c36] = t8;
  }
  switch (i28.DEM && !i28.Raster && (i28.Raster = i28.DEM, delete i28.DEM), r12.rasterFunction) {
    case "Stretch":
      O2(i28);
      break;
    case "Colormap":
      G2(i28);
      break;
    case "Convolution":
      P2(i28);
      break;
    case "Mask":
      I2(i28);
  }
}
function L2(t7) {
  const { renderingRule: r12, templates: n21 } = t7;
  if ("object" != typeof r12 || !(r12 == null ? void 0 : r12.rasterFunctionArguments) || !n21.size) return;
  const { rasterFunctionArguments: o10 } = r12;
  for (const s12 in o10) {
    const t8 = o10[s12], r13 = "_object_ref_id" === s12 ? t8 : t8 && "object" == typeof t8 && "_object_ref_id" in t8 ? t8._object_ref_id : null;
    if (null == r13) t8 && "object" == typeof t8 && (t8.rasterFunctionArguments && L2({ renderingRule: t8, templates: n21 }), Array.isArray(t8) && t8.forEach((o11, s13) => {
      if ("object" == typeof o11) if (null != o11._object_ref_id) {
        if (!n21.has(o11._object_ref_id)) throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${t8} does not exist`);
        const a35 = n21.get(r13);
        a35 && "object" == typeof a35 ? Object.assign(o11, a35) : t8[s13] = a35;
      } else L2({ renderingRule: o11, templates: n21 });
    }));
    else {
      if (!n21.has(r13)) throw new s("raster-function-helper", `unsupported raster function json. _object_ref_id: ${r13} does not exist`);
      const t9 = n21.get(r13);
      "_object_ref_id" !== s12 ? o10[s12] = t9 : t9 && "object" == typeof t9 && Object.assign(o10, t9);
    }
  }
}
function O2(t7) {
  var _a;
  ((_a = t7.Statistics) == null ? void 0 : _a.length) && "object" == typeof t7.Statistics && (t7.Statistics = t7.Statistics.map((t8) => [t8.min, t8.max, t8.mean, t8.standardDeviation])), null != t7.NumberOfStandardDeviation && (t7.NumberOfStandardDeviations = t7.NumberOfStandardDeviation, delete t7.NumberOfStandardDeviation);
}
function G2(t7) {
  var _a, _b;
  "randomcolorramp" === ((_b = (_a = t7.ColorRamp) == null ? void 0 : _a.type) == null ? void 0 : _b.toLowerCase()) && (delete t7.ColorRamp, t7.ColormapName = "Random"), 0 === t7.ColorSchemeType && delete t7.ColorRamp;
}
function P2(t7) {
  null != t7.ConvolutionType && (t7.Type = t7.ConvolutionType, delete t7.ConvolutionType);
}
function I2(t7) {
  var _a;
  ((_a = t7.NoDataValues) == null ? void 0 : _a.length) && "string" == typeof t7.NoDataValues[0] && (t7.NoDataValues = t7.NoDataValues.filter((t8) => "" !== t8).map((t8) => Number(t8)));
}
v3.set("Arithmetic", { desc: "Arithmetic Function", ctor: a11, rasterArgumentNames: ["rasters"] }), v3.set("Aspect", { desc: "Aspect Function", ctor: p9, rasterArgumentNames: ["raster"] }), v3.set("BandArithmetic", { desc: "Band Arithmetic Function", ctor: m6, rasterArgumentNames: ["raster"] }), v3.set("Colormap", { desc: "Colormap Function", ctor: u10, rasterArgumentNames: ["raster"] }), v3.set("ColormapToRGB", { desc: "ColormapToRGB Function", ctor: u11, rasterArgumentNames: ["raster"] }), v3.set("CompositeBand", { desc: "CompositeBand Function", ctor: a19, rasterArgumentNames: ["rasters"] }), v3.set("ComputeChange", { desc: "ComputeChange Function", ctor: m10, rasterArgumentNames: ["rasters"] }), v3.set("Convolution", { desc: "Convolution Function", ctor: p14, rasterArgumentNames: ["raster"] }), v3.set("ContrastBrightness", { desc: "Contrast Brightness Function", ctor: p12, rasterArgumentNames: ["raster"] }), v3.set("ExtractBand", { desc: "ExtractBand Function", ctor: l15, rasterArgumentNames: ["raster"] }), v3.set("Curvature", { desc: "Curvature Function", ctor: c17, rasterArgumentNames: ["raster"] }), v3.set("Hillshade", { desc: "Hillshade Function", ctor: l17, rasterArgumentNames: ["raster"] }), v3.set("ShadedRelief", { desc: "ShadedRelief Function", ctor: x5, rasterArgumentNames: ["raster"] }), v3.set("Grayscale", { desc: "Grayscale Function", ctor: u16, rasterArgumentNames: ["raster"] }), v3.set("Clip", { desc: "Clip Function", ctor: u8, rasterArgumentNames: ["raster"] }), v3.set("Local", { desc: "Local Function", ctor: d9, rasterArgumentNames: ["rasters"] }), v3.set("Mask", { desc: "Mask Function", ctor: p16, rasterArgumentNames: ["raster"] }), v3.set("NDVI", { desc: "NDVI Function", ctor: a26, rasterArgumentNames: ["raster"] }), v3.set("Remap", { desc: "Remap Function", ctor: g6, rasterArgumentNames: ["raster"] }), v3.set("Slope", { desc: "Slope Function", ctor: c27, rasterArgumentNames: ["raster"] }), v3.set("Statistics", { desc: "Focal Statistics Function", ctor: p18, rasterArgumentNames: ["raster"] }), v3.set("StatisticsHistogram", { desc: "Statistics Histogram Function", ctor: n17, rasterArgumentNames: ["raster"] }), v3.set("Stretch", { desc: "Stretch Function", ctor: l21, rasterArgumentNames: ["raster"] }), v3.set("Table", { desc: "Attribute Table Function", ctor: n19, rasterArgumentNames: ["raster"] });

// node_modules/@arcgis/core/layers/support/rasterTransforms/BaseRasterTransform.js
var t6 = class extends f {
  get affectsPixelSize() {
    return false;
  }
  forwardTransform(r12) {
    return r12;
  }
  inverseTransform(r12) {
    return r12;
  }
};
r([m()], t6.prototype, "affectsPixelSize", null), r([m({ json: { write: true } })], t6.prototype, "spatialReference", void 0), t6 = r([a2("esri.layers.support.rasterTransforms.BaseRasterTransform")], t6);
var a32 = t6;

// node_modules/@arcgis/core/layers/support/rasterTransforms/GCSShiftTransform.js
var a33;
var n20 = a33 = class extends a32 {
  constructor() {
    super(...arguments), this.type = "gcs-shift", this.tolerance = 1e-8;
  }
  forwardTransform(r12) {
    return "point" === (r12 = r12.clone()).type ? (r12.x > 180 + this.tolerance && (r12.x -= 360), r12) : (r12.xmin >= 180 - this.tolerance ? (r12.xmax -= 360, r12.xmin -= 360) : r12.xmax > 180 + this.tolerance && (r12.xmin = -180, r12.xmax = 180), r12);
  }
  inverseTransform(r12) {
    return "point" === (r12 = r12.clone()).type ? (r12.x < -this.tolerance && (r12.x += 360), r12) : (r12.xmin < -this.tolerance && (r12.xmin += 360, r12.xmax += 360), r12);
  }
  clone() {
    return new a33({ tolerance: this.tolerance });
  }
};
r([r3({ GCSShiftXform: "gcs-shift" })], n20.prototype, "type", void 0), r([m()], n20.prototype, "tolerance", void 0), n20 = a33 = r([a2("esri.layers.support.rasterTransforms.GCSShiftTransform")], n20);
var c34 = n20;

// node_modules/@arcgis/core/layers/support/rasterTransforms/PolynomialTransform.js
var l22;
function a34(e9, r12, o10) {
  const { x: t7, y: s12 } = r12;
  if (o10 < 2) {
    return { x: e9[0] + t7 * e9[2] + s12 * e9[4], y: e9[1] + t7 * e9[3] + s12 * e9[5] };
  }
  if (2 === o10) {
    const r13 = t7 * t7, o11 = s12 * s12, i29 = t7 * s12;
    return { x: e9[0] + t7 * e9[2] + s12 * e9[4] + r13 * e9[6] + i29 * e9[8] + o11 * e9[10], y: e9[1] + t7 * e9[3] + s12 * e9[5] + r13 * e9[7] + i29 * e9[9] + o11 * e9[11] };
  }
  const i28 = t7 * t7, n21 = s12 * s12, f7 = t7 * s12, p21 = i28 * t7, l23 = i28 * s12, a35 = t7 * n21, c36 = s12 * n21;
  return { x: e9[0] + t7 * e9[2] + s12 * e9[4] + i28 * e9[6] + f7 * e9[8] + n21 * e9[10] + p21 * e9[12] + l23 * e9[14] + a35 * e9[16] + c36 * e9[18], y: e9[1] + t7 * e9[3] + s12 * e9[5] + i28 * e9[7] + f7 * e9[9] + n21 * e9[11] + p21 * e9[13] + l23 * e9[15] + a35 * e9[17] + c36 * e9[19] };
}
function c35(e9, r12, o10) {
  const { xmin: t7, ymin: s12, xmax: i28, ymax: n21, spatialReference: f7 } = r12;
  let l23 = [];
  if (o10 < 2) l23.push({ x: t7, y: n21 }), l23.push({ x: i28, y: n21 }), l23.push({ x: t7, y: s12 }), l23.push({ x: i28, y: s12 });
  else {
    let e10 = 10;
    for (let r13 = 0; r13 < e10; r13++) l23.push({ x: t7, y: s12 + (n21 - s12) * r13 / (e10 - 1) }), l23.push({ x: i28, y: s12 + (n21 - s12) * r13 / (e10 - 1) });
    e10 = 8;
    for (let r13 = 1; r13 <= e10; r13++) l23.push({ x: t7 + (i28 - t7) * r13 / e10, y: s12 }), l23.push({ x: t7 + (i28 - t7) * r13 / e10, y: n21 });
  }
  l23 = l23.map((r13) => a34(e9, r13, o10));
  const c36 = l23.map((e10) => e10.x), m17 = l23.map((e10) => e10.y);
  return new w({ xmin: Math.min.apply(null, c36), xmax: Math.max.apply(null, c36), ymin: Math.min.apply(null, m17), ymax: Math.max.apply(null, m17), spatialReference: f7 });
}
function m16(e9) {
  const [r12, o10, t7, s12, i28, n21] = e9, f7 = t7 * n21 - i28 * s12, p21 = i28 * s12 - t7 * n21;
  return [(i28 * o10 - r12 * n21) / f7, (t7 * o10 - r12 * s12) / p21, n21 / f7, s12 / p21, -i28 / f7, -t7 / p21];
}
var u20 = l22 = class extends a32 {
  constructor() {
    super(...arguments), this.polynomialOrder = 1, this.type = "polynomial";
  }
  readForwardCoefficients(e9, r12) {
    const { coeffX: o10, coeffY: t7 } = r12;
    if (!(o10 == null ? void 0 : o10.length) || !(t7 == null ? void 0 : t7.length) || o10.length !== t7.length) return null;
    const s12 = [];
    for (let i28 = 0; i28 < o10.length; i28++) s12.push(o10[i28]), s12.push(t7[i28]);
    return s12;
  }
  writeForwardCoefficients(e9, r12, o10) {
    const t7 = [], s12 = [];
    for (let i28 = 0; i28 < (e9 == null ? void 0 : e9.length); i28++) i28 % 2 == 0 ? t7.push(e9[i28]) : s12.push(e9[i28]);
    r12.coeffX = t7, r12.coeffY = s12;
  }
  get inverseCoefficients() {
    let e9 = this._get("inverseCoefficients");
    const r12 = this._get("forwardCoefficients");
    return !e9 && r12 && this.polynomialOrder < 2 && (e9 = m16(r12)), e9;
  }
  set inverseCoefficients(e9) {
    this._set("inverseCoefficients", e9);
  }
  readInverseCoefficients(e9, r12) {
    const { inverseCoeffX: o10, inverseCoeffY: t7 } = r12;
    if (!(o10 == null ? void 0 : o10.length) || !(t7 == null ? void 0 : t7.length) || o10.length !== t7.length) return null;
    const s12 = [];
    for (let i28 = 0; i28 < o10.length; i28++) s12.push(o10[i28]), s12.push(t7[i28]);
    return s12;
  }
  writeInverseCoefficients(e9, r12, o10) {
    const t7 = [], s12 = [];
    for (let i28 = 0; i28 < (e9 == null ? void 0 : e9.length); i28++) i28 % 2 == 0 ? t7.push(e9[i28]) : s12.push(e9[i28]);
    r12.inverseCoeffX = t7, r12.inverseCoeffY = s12;
  }
  get affectsPixelSize() {
    return this.polynomialOrder > 0;
  }
  forwardTransform(e9) {
    if ("point" === e9.type) {
      const r12 = a34(this.forwardCoefficients, e9, this.polynomialOrder);
      return new j({ x: r12.x, y: r12.y, spatialReference: e9.spatialReference });
    }
    return c35(this.forwardCoefficients, e9, this.polynomialOrder);
  }
  inverseTransform(e9) {
    if ("point" === e9.type) {
      const r12 = a34(this.inverseCoefficients, e9, this.polynomialOrder);
      return new j({ x: r12.x, y: r12.y, spatialReference: e9.spatialReference });
    }
    return c35(this.inverseCoefficients, e9, this.polynomialOrder);
  }
  clone() {
    return new l22({ polynomialOrder: this.polynomialOrder, forwardCoefficients: this.forwardCoefficients ? [...this.forwardCoefficients] : null, inverseCoefficients: this.inverseCoefficients ? [...this.inverseCoefficients] : null });
  }
};
r([m({ json: { write: true } })], u20.prototype, "polynomialOrder", void 0), r([m()], u20.prototype, "forwardCoefficients", void 0), r([o("forwardCoefficients", ["coeffX", "coeffY"])], u20.prototype, "readForwardCoefficients", null), r([r2("forwardCoefficients")], u20.prototype, "writeForwardCoefficients", null), r([m({ json: { write: true } })], u20.prototype, "inverseCoefficients", null), r([o("inverseCoefficients", ["inverseCoeffX", "inverseCoeffY"])], u20.prototype, "readInverseCoefficients", null), r([r2("inverseCoefficients")], u20.prototype, "writeInverseCoefficients", null), r([m()], u20.prototype, "affectsPixelSize", null), r([r3({ PolynomialXform: "polynomial" })], u20.prototype, "type", void 0), u20 = l22 = r([a2("esri.layers.support.rasterTransforms.PolynomialTransform")], u20);
var y5 = u20;

export {
  h4 as h,
  l8 as l,
  w6 as w,
  T2 as T,
  a32 as a,
  c34 as c,
  y5 as y
};
//# sourceMappingURL=chunk-66IRR373.js.map
