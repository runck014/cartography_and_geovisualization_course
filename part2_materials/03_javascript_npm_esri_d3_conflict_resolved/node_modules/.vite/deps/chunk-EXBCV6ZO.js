import {
  i as i8
} from "./chunk-GBAJR7JF.js";
import {
  e as e4
} from "./chunk-SGZGPX6H.js";
import {
  a as a5
} from "./chunk-SK5QCHZZ.js";
import {
  i as i7
} from "./chunk-TQ54TTVN.js";
import {
  j,
  y as y2
} from "./chunk-EVT35YP5.js";
import {
  i as i6,
  n as n5,
  r as r4
} from "./chunk-LAXNQQQH.js";
import {
  M as M2,
  T as T2,
  a as a7,
  c,
  c2,
  h as h2,
  i2 as i5,
  m as m4,
  t4 as t3,
  t5 as t4,
  t6 as t5,
  x as x2
} from "./chunk-5PECYTTZ.js";
import {
  b as b5
} from "./chunk-KDQTUT24.js";
import {
  a as a6
} from "./chunk-TZAPBN5J.js";
import {
  o as o4
} from "./chunk-PAS43ZQC.js";
import {
  n as n4,
  p as p2
} from "./chunk-5Y4XRWDV.js";
import {
  t
} from "./chunk-7TPUFUXO.js";
import {
  e as e3
} from "./chunk-OXCT6NNS.js";
import {
  ee,
  me,
  o as o3
} from "./chunk-5VEO4IUH.js";
import {
  tt
} from "./chunk-OMMWWGIU.js";
import {
  a as a3
} from "./chunk-VS5MKM3H.js";
import {
  d as d6,
  w as w2
} from "./chunk-764E6KTP.js";
import {
  a as a4
} from "./chunk-TP6LRQ42.js";
import {
  i as i2,
  r as r3
} from "./chunk-VLKWWBLY.js";
import {
  d as d5
} from "./chunk-PVHAAI32.js";
import {
  i as i3
} from "./chunk-5CRXWQ3Y.js";
import {
  m as m3
} from "./chunk-CGSFKZP2.js";
import {
  f as f2
} from "./chunk-XKMN3LJN.js";
import {
  E,
  N,
  R,
  h2 as h3,
  r2 as r5
} from "./chunk-F3ZOBTPK.js";
import {
  t as t2
} from "./chunk-EZCH3ZAJ.js";
import {
  e as e2
} from "./chunk-2IVHP3HQ.js";
import {
  s as s3
} from "./chunk-YNC2IEH2.js";
import {
  s as s4
} from "./chunk-CGJUTDVJ.js";
import {
  h
} from "./chunk-GYV5TPN6.js";
import {
  p
} from "./chunk-2EGO74J5.js";
import {
  d as d4
} from "./chunk-6Q7GN2CW.js";
import {
  S,
  d as d3,
  y
} from "./chunk-AVBIV2K3.js";
import {
  b as b3
} from "./chunk-F3NUC2RS.js";
import {
  g as g2
} from "./chunk-P3GRQ2CH.js";
import {
  n as n3
} from "./chunk-LPNAPHOF.js";
import {
  A,
  P,
  d as d2,
  v
} from "./chunk-W6D3ECTZ.js";
import {
  I,
  J,
  L as L2,
  M,
  O as O2,
  T,
  b as b4,
  i as i4,
  je,
  v as v2,
  w as w3,
  x
} from "./chunk-BWTCR2DR.js";
import {
  n as n2
} from "./chunk-SMOTPOZ7.js";
import {
  u as u4
} from "./chunk-YVSEBNS4.js";
import {
  O
} from "./chunk-7FJIOZSE.js";
import {
  u as u3
} from "./chunk-ZCHZRNUG.js";
import {
  V
} from "./chunk-RCLWOQNR.js";
import {
  o
} from "./chunk-DOTSJZHK.js";
import {
  m as m2,
  r as r2
} from "./chunk-6YWQXXBX.js";
import {
  w
} from "./chunk-FG3XOAFD.js";
import {
  o as o2
} from "./chunk-GN5RE63N.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  b2,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a2
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  L,
  b,
  d,
  e,
  f,
  s as s2,
  u as u2
} from "./chunk-GRW2QIBT.js";
import {
  u
} from "./chunk-R2PAF6JT.js";
import {
  a,
  i,
  l2 as l,
  n2 as n,
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  F,
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/AggregateGraphic.js
var p3 = class extends d4 {
  constructor() {
    super(...arguments), this.isAggregate = true;
  }
  getEffectivePopupTemplate(e7 = false) {
    var _a;
    if (this.popupTemplate) return this.popupTemplate;
    const t11 = (_a = this.sourceLayer) == null ? void 0 : _a.featureReduction;
    return t11 && "popupTemplate" in t11 && t11.popupEnabled ? t11.popupTemplate : null;
  }
  getObjectId() {
    return this.attributes.aggregateId;
  }
};
r([m({ type: Boolean })], p3.prototype, "isAggregate", void 0), p3 = r([a2("esri.AggregateGraphic")], p3);
var s5 = p3;

// node_modules/@arcgis/core/layers/effects/FeatureEffectView.js
var c3 = class extends b2 {
  constructor(e7) {
    super(e7), this._filter = null, this.duration = has("mapview-transitions-duration"), this._excludedEffectView = new a6(e7), this._includedEffectView = new a6(e7);
  }
  get excludedEffects() {
    return this._excludedEffectView.effects;
  }
  set featureEffect(e7) {
    this._get("featureEffect") !== e7 && this._transitionTo(e7);
  }
  get filter() {
    var _a;
    return this._filter || ((_a = this.featureEffect) == null ? void 0 : _a.filter) || null;
  }
  get hasEffects() {
    return this._excludedEffectView.hasEffects || this._includedEffectView.hasEffects;
  }
  get includedEffects() {
    return this._includedEffectView.effects;
  }
  set scale(e7) {
    this._set("scale", e7), this._excludedEffectView.scale = e7, this._includedEffectView.scale = e7;
  }
  get transitioning() {
    return this._excludedEffectView.transitioning || this._includedEffectView.transitioning;
  }
  get transitioningToEmpty() {
    return !this._excludedEffectView.final && !this._includedEffectView.final;
  }
  transitionStep(e7, t11) {
    this._set("scale", t11), this.transitioning ? (this._includedEffectView.transitionStep(e7, t11), this._excludedEffectView.transitionStep(e7, t11), this.transitioning || (this._filter = null)) : (this._excludedEffectView.scale = t11, this._includedEffectView.scale = t11);
  }
  endTransition() {
    this._includedEffectView.endTransition(), this._excludedEffectView.endTransition(), this._filter = null;
  }
  _transitionTo(e7) {
    const t11 = this._get("featureEffect"), i12 = e7, s9 = i12 == null ? void 0 : i12.includedEffect, f5 = i12 == null ? void 0 : i12.excludedEffect, c11 = this._includedEffectView.canTransitionTo(s9) && this._excludedEffectView.canTransitionTo(f5);
    this._includedEffectView.effect = s9, this._excludedEffectView.effect = f5, this._set("featureEffect", i12), this._filter = (i12 == null ? void 0 : i12.filter) || (t11 == null ? void 0 : t11.filter) || null, c11 || this.endTransition();
  }
};
r([m()], c3.prototype, "_filter", void 0), r([m()], c3.prototype, "_excludedEffectView", void 0), r([m()], c3.prototype, "_includedEffectView", void 0), r([m()], c3.prototype, "duration", void 0), r([m()], c3.prototype, "excludedEffects", null), r([m()], c3.prototype, "featureEffect", null), r([m()], c3.prototype, "filter", null), r([m()], c3.prototype, "hasEffects", null), r([m()], c3.prototype, "includedEffects", null), r([m({ value: 0 })], c3.prototype, "scale", null), r([m()], c3.prototype, "transitioning", null), r([m()], c3.prototype, "transitioningToEmpty", null), c3 = r([a2("esri.layers.effects.FeatureEffectView")], c3);
var r6 = c3;

// node_modules/@arcgis/core/rest/support/AggregateFeatureSet.js
var c4 = class extends d5 {
  constructor() {
    super(...arguments), this.features = [];
  }
  readFeatures(e7, t11) {
    var _a;
    const o14 = g.fromJSON(t11.spatialReference), s9 = [];
    for (let a11 = 0; a11 < e7.length; a11++) {
      const t12 = e7[a11], p9 = s5.fromJSON(t12), c11 = (_a = t12.geometry) == null ? void 0 : _a.spatialReference;
      null == p9.geometry || c11 || (p9.geometry.spatialReference = o14);
      const m12 = t12.aggregateGeometries, i12 = p9.aggregateGeometries;
      if (m12 && null != i12) for (const e8 in i12) {
        const r12 = i12[e8], t13 = m12[e8], s10 = t13 == null ? void 0 : t13.spatialReference;
        null == r12 || s10 || (r12.spatialReference = o14);
      }
      s9.push(p9);
    }
    return s9;
  }
};
r([m({ type: [s5], json: { write: true } })], c4.prototype, "features", void 0), r([o2("features")], c4.prototype, "readFeatures", null), c4 = r([a2("esri.rest.support.AggregateFeatureSet")], c4);
var m5 = c4;

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/FeatureInstanceStore.js
var s6 = class {
  constructor() {
    this._instanceById = /* @__PURE__ */ new Map();
  }
  destroy() {
    this._instanceById.clear();
  }
  get size() {
    return this._instanceById.size;
  }
  entries() {
    return this._instanceById.entries();
  }
  updateStart() {
    this._instanceByIdNext = /* @__PURE__ */ new Map();
  }
  updateEnd() {
    if (!this._instanceByIdNext) throw new Error("InternalError: Found updateEnd call without corresponding updateStart");
    for (const t11 of this._instanceById.keys()) this._instanceByIdNext.has(t11) || this._instanceById.delete(t11);
    for (const [t11, n11] of this._instanceByIdNext.entries()) {
      const e7 = this._instanceById.get(t11);
      e7 ? e7.setInput(n11.getInput()) : this._instanceById.set(t11, n11);
    }
    this._instanceByIdNext = null;
  }
  values() {
    return this._instanceById.values();
  }
  ensureInstance(s9, i12) {
    let r12;
    if ("object" == typeof i12 && "optionalAttributes" in i12 && "uniforms" in i12) {
      r12 = `${s9.type}${JSON.stringify(i12.optionalAttributes)}`;
      const t11 = i12.uniforms;
      if ("object" == typeof t11) for (const n11 in t11) r12 += `${n11}.${null != t11[n11]}`;
    } else r12 = `${s9.type}.${JSON.stringify(i12)}`;
    const a11 = l(r12);
    if (this._instanceByIdNext) {
      const t11 = new i6(r4(a11), s9, i12);
      return this._instanceByIdNext.set(a11, t11), t11;
    }
    if (!this._instanceById.has(a11)) {
      const t11 = new i6(r4(a11), s9, i12);
      this._instanceById.set(a11, t11);
    }
    return this._instanceById.get(a11);
  }
  getInstance(t11) {
    return this._instanceById.get(t11);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/RenderState.js
var r7 = 1e3;
var d7 = class {
  constructor(t11, i12, s9, o14) {
    this.getStage = t11, this.getSubscriptionVersion = i12, this.version = s9, this._tileInfoView = o14, this._pendingUpdates = new t(r7), this._locked = false, this._tiles = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e7 of this.tiles()) e7.destroy();
    this._pendingUpdates.clear(), this._tiles.clear();
  }
  tiles() {
    return this._tiles.values();
  }
  size() {
    return this._tiles.size;
  }
  setTiles(e7) {
    this._tiles.clear();
    for (const t11 of e7) this._tiles.set(t11.key.id, t11);
  }
  lockUploads() {
    this._locked = true;
  }
  unlockUploads() {
    this._locked = false, this.flush();
  }
  enqueueUpdate(e7) {
    this._pendingUpdates.enqueue(e7);
  }
  update(e7) {
    if (!this._locked) for (; this._pendingUpdates.size; ) {
      const t11 = this._pendingUpdates.peek();
      if (null == t11 || t11.inner.attributeEpoch > e7) break;
      this._updateTile(t11), this._pendingUpdates.dequeue();
    }
  }
  removeTile(e7) {
    const t11 = this._tiles.get(e7);
    has("esri-2d-update-debug") && console.debug(`Tile[${e7}] RenderState.removeTile`), t11 == null ? void 0 : t11.destroy(), this._tiles.delete(e7);
  }
  isTileDone(e7) {
    const t11 = this._tiles.get(e7.id);
    return !!t11 && t11.isReady;
  }
  flush() {
    for (; this._pendingUpdates.size; ) {
      const e7 = this._pendingUpdates.dequeue();
      null != e7 && this._updateTile(e7);
    }
    for (const e7 of this._tiles.values()) e7.upload();
  }
  _updateTile(e7) {
    var _a;
    const { inner: t11, objectIdMap: i12 } = e7, s9 = this.getSubscriptionVersion(t11.id);
    if (s9 !== t11.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e8 = `${t11.subscriptionVesrion} != ${s9}`;
        console.debug(`Version[${e8}] Tile[${t11.id}] FeatureContainer - Dropping message, outdated version]`, t11);
      }
      return;
    }
    if (has("esri-2d-update-debug")) {
      const e8 = ((_a = t11.debugInfo) == null ? void 0 : _a.chunkId) ?? "<EnsureEnd>";
      console.debug(`Version[${t11.version}] Tile[${t11.id}] Chunk[${e8}] RenderState.updateTile [${t11.type}]`, t11);
    }
    const o14 = this._ensureTile(t11.id);
    if ("update" === t11.type) {
      const [e8, ...s10] = t11.modify;
      o14.onMessage({ type: "update", modify: e8, remove: t11.remove, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i12 });
      for (const o15 of s10) {
        const e9 = this._tiles.get(o15.tileId);
        e9 && e9.onMessage({ type: "update", modify: o15, remove: t11.remove, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i12 });
      }
      return;
    }
    if (null == t11.append) return void o14.onMessage({ type: "append", clear: t11.clear, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i12 });
    const [n11, ...r12] = t11.append;
    o14.onMessage({ type: "append", clear: t11.clear, append: n11, debugInfo: t11.debugInfo, end: t11.end, attributeEpoch: t11.attributeEpoch, objectIdMap: i12 });
    for (const d10 of r12) {
      const e8 = this._tiles.get(d10.tileId);
      e8 && e8.onMessage({ type: "update", modify: d10, remove: [], sort: false, end: false, isPixelBuffer: true, attributeEpoch: null, objectIdMap: i12 });
    }
  }
  _ensureTile(e7) {
    if (!this._tiles.has(e7)) {
      const t11 = this._createTile(e7);
      this._copyPixelBufferedEntitiesInto(t11), this._tiles.set(e7, t11);
    }
    return this._tiles.get(e7);
  }
  _createTile(e7) {
    has("esri-2d-update-debug") && console.debug(`Version[${this.version}] Tile[${e7}] RenderState.createTile`);
    const r12 = new e2(e7), d10 = this._tileInfoView.getTileBounds(u3(), r12), l8 = this._tileInfoView.getTileResolution(r12.level), a11 = new b5(r12, l8, d10[0], d10[3], true);
    if (a11.stage = this.getStage(), !a11.stage) {
      const e8 = new s("featurelayerview:webgl", "Cannot create tile with empty stage");
      n.getLogger("esri.views.2d.layers.features.RenderState").error(e8);
    }
    return a11;
  }
  _copyPixelBufferedEntitiesInto(e7) {
    let t11 = 7;
    const i12 = this._tileInfoView.getLODInfoAt(e7.key);
    for (let s9 = -1; s9 <= 1; s9++) for (let o14 = -1; o14 <= 1; o14++) {
      if (0 === s9 && 0 === o14) continue;
      const n11 = e7.key.getNormalizedNeighbor(o14, s9, i12).id, r12 = this._tiles.get(n11);
      if (null != r12) {
        const i13 = 1 << t11;
        e7.copyPixelBufferedEntitesFrom(r12, i13, o14, s9);
      }
      t11--;
    }
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureContainer.js
var c5 = class {
  constructor(e7, s9) {
    this.id = e7, this.version = s9, this._resolver = L(), this._done = false;
  }
  get done() {
    return this._done;
  }
  get promise() {
    return this._resolver.promise;
  }
  end() {
    this._resolver.resolve(), this._done = true;
  }
  destroy() {
    this._resolver.reject();
  }
};
var p4 = class extends n5 {
  constructor(e7) {
    super(e7.view.featuresTilingScheme), this.updatingHandles = new h(), this._hitTestsRequests = [], this._store = new s6(), this._visibleTiles = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Map(), this._updateStatisticsRequests = [], this._lockStatisticUpdates = false, this._layerView = e7, this.addTransitionable(this._layerView.featureEffectView);
  }
  renderChildren(e7) {
    var _a, _b;
    if (this._updateAttributeView(), (_a = this._renderState) == null ? void 0 : _a.update(this.attributeView.currentEpoch), this._renderState) {
      const e8 = Array.from(this._renderState.tiles()).filter((e9) => e9.needsUpload);
      if (e8.length) {
        e8[Math.floor(Math.random() * e8.length)].upload(), e8.length >= 2 && this.requestRender();
      }
      for (const t11 of this._renderState.tiles()) t11.tryReady(this.attributeView.currentEpoch) && ((_b = this._subscriptions.get(t11.key.id)) == null ? void 0 : _b.end(), this._layerView.requestUpdate(), this.hasLabels && this._layerView.view.labelManager.requestUpdate(), this.requestRender());
    }
    for (const t11 of this.children) t11.setTransform(e7.state);
    switch (super.renderChildren(e7), e7.drawPhase) {
      case E.MAP:
        return this._renderMapPhase(e7);
      case E.HIGHLIGHT:
        return this._renderHighlightPhase(e7);
      case E.LABEL:
        return this._renderLabelPhase(e7);
    }
  }
  subscriptions() {
    return this._subscriptions.values();
  }
  get _instanceStore() {
    return this._store;
  }
  get instanceStore() {
    return this._store;
  }
  get layerView() {
    return this._layerView;
  }
  get hasLabels() {
    return this._layerView.labelingCollisionInfos.length > 0;
  }
  get hasHighlight() {
    return this._layerView.hasHighlight();
  }
  get _layer() {
    return this._layerView.layer;
  }
  _getHeatmapInstance(e7) {
    if (null == this._instanceStore || !(e7.drawPhase & T2.heatmap.drawPhase)) return null;
    for (const t11 of this._instanceStore.values()) if (_(t11)) return t11;
    return null;
  }
  get children() {
    return this._renderState ? Array.from(this._renderState.tiles()).filter((e7) => this._visibleTiles.has(e7.key.id)) : [];
  }
  updateAttributeView(e7) {
    this.requestRender(), this.attributeView.requestUpdate(e7), this.hasLabels && this._layerView.view.labelManager.requestUpdate();
  }
  updateSubscriptions(e7) {
    for (const { tileId: t11, version: s9 } of e7.subscribe) if (this._subscriptions.has(t11)) this._subscriptions.get(t11).version = s9;
    else {
      const e8 = new c5(t11, s9);
      this._subscriptions.set(t11, e8), this.updatingHandles.addPromise(e8.promise);
    }
    for (const t11 of e7.unsubscribe) {
      const e8 = this._subscriptions.get(t11);
      e8 == null ? void 0 : e8.destroy(), this._subscriptions.delete(t11), this.removeTile(t11);
    }
  }
  isDone(e7) {
    return !!this._renderState && this._renderState.isTileDone(e7);
  }
  async updateRenderState(e7) {
    has("esri-2d-update-debug") && console.debug(`Version[${e7}] FeatureContainer.updateRenderState`), this._renderStateNext = new d7(() => this._stage, (e8) => {
      var _a;
      return (_a = this._subscriptions.get(e8)) == null ? void 0 : _a.version;
    }, e7, this.tileInfoView);
  }
  getDisplayStatistics(e7, t11) {
    const s9 = this._statisticsByLevel.get(e7);
    return s9 ? s9.get(t11) : null;
  }
  updateStatistics(e7, t11) {
    if (this._lockStatisticUpdates) return void this._updateStatisticsRequests.push({ level: e7, statistics: t11 });
    let s9 = this._statisticsByLevel.get(e7);
    s9 || (s9 = /* @__PURE__ */ new Map(), this._statisticsByLevel.set(e7, s9));
    for (const r12 of t11) s9.set(r12.fieldName, { minValue: r12.minValue, maxValue: r12.maxValue });
  }
  editStart() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.lockUploads(), this.attributeView.lockTextureUploads(), this._lockStatisticUpdates = true;
  }
  editEnd() {
    var _a;
    (_a = this._renderState) == null ? void 0 : _a.unlockUploads(), this.attributeView.unlockTextureUploads(), this._lockStatisticUpdates = false;
    for (const e7 of this._updateStatisticsRequests) this.updateStatistics(e7.level, e7.statistics);
    this._updateStatisticsRequests = [], this.requestRender();
  }
  swapRenderState() {
    var _a;
    this._renderStateNext && (has("esri-2d-update-debug") && console.debug(`Version[${this._renderStateNext.version}] FeatureContainer.update.swapRenderState`), (_a = this._renderState) == null ? void 0 : _a.destroy(), this._renderState = this._renderStateNext, this._renderStateNext = null), this._renderState && this._renderState.flush(), this.requestRender();
  }
  setVisibleTiles(e7) {
    this._visibleTiles = e7;
  }
  async onMessage(t11, s9) {
    s2(s9);
    const r12 = t11.inner;
    if (!this._subscriptions.has(r12.id)) return;
    const i12 = this._subscriptions.get(r12.id);
    if (i12.version !== r12.subscriptionVesrion) {
      if (has("esri-2d-update-debug")) {
        const e7 = `${r12.subscriptionVesrion} != ${i12.version}`;
        console.debug(`Version[${e7}] Tile[${r12.id}] FeatureContainer - Dropping message, outdated version]`, r12);
      }
      return;
    }
    const n11 = this._renderStateNext ?? this._renderState;
    if (!n11) throw new Error("InternalError: No renderState defined");
    n11.version !== r12.version && console.error(`InternalError: Version mismatch. [renderState: ${n11.version}, message: ${r12.version}]`), n11.enqueueUpdate(t11), this.requestRender(), this._layerView.view.labelManager.requestUpdate(), this._layerView.requestUpdate();
  }
  removeTile(e7) {
    (this._renderState || this._renderStateNext) && (this._renderState && this._renderState.removeTile(e7), this._renderStateNext && this._renderStateNext.removeTile(e7));
  }
  hitTest(e7) {
    let s9 = this._hitTestsRequests.find(({ x: t11, y: s10 }) => t11 === e7.x && s10 === e7.y);
    const r12 = L();
    return s9 ? s9.resolvers.push(r12) : (s9 = { x: e7.x, y: e7.y, resolvers: [r12] }, this._hitTestsRequests.push(s9)), this.requestRender(), r12.promise;
  }
  getSortKeys(e7) {
    const t11 = new Set(e7), s9 = /* @__PURE__ */ new Map();
    for (const r12 of this.children) if (r12.getSortKeys(t11).forEach((e8, t12) => s9.set(t12, e8)), s9.size === t11.size) break;
    return s9;
  }
  get hasAnimation() {
    return this.hasLabels;
  }
  doRender(e7) {
    const { minScale: t11, maxScale: s9 } = this._layer.effectiveScaleRange, r12 = e7.state.scale;
    r12 <= (t11 || 1 / 0) && r12 >= s9 && super.doRender(e7);
  }
  afterRender(e7) {
    super.afterRender(e7), this._hitTestsRequests.length && this.requestRender();
  }
  setStencilReference(e7) {
    if (null == this._getHeatmapInstance(e7)) super.setStencilReference(e7);
    else for (const t11 of this.children) t11.stencilRef = T2.heatmap.getStencilReference(t11);
  }
  _renderMapPhase(e7) {
    this._layerView.featureEffectView.hasEffects ? (this._renderOutsideEffect(e7), this._renderInsideEffect(e7)) : this._renderFeatures(e7, R.All), this._hitTestsRequests.length > 0 && this._renderHittest(e7);
  }
  _renderHighlightPhase(e7) {
    this.hasHighlight && h3(e7, false, (e8) => {
      this._renderFeatures(e8, R.Highlight);
    });
  }
  _renderLabelPhase(e7) {
    this._renderFeatures(e7, R.All);
  }
  _renderInsideEffect(e7) {
    const t11 = e7.painter.effects.insideEffect;
    t11.bind(e7), this._renderFeatures(e7, R.InsideEffect), t11.draw(e7, this._layerView.featureEffectView.includedEffects), t11.unbind();
  }
  _renderOutsideEffect(e7) {
    const t11 = e7.painter.effects.outsideEffect;
    t11.bind(e7), this._renderFeatures(e7, R.OutsideEffect), t11.draw(e7, this._layerView.featureEffectView.excludedEffects), t11.unbind();
  }
  _renderHittest(e7) {
    const { context: t11 } = e7, s9 = e7.painter.effects.hittest, r12 = t11.getBoundFramebufferObject(), a11 = t11.getViewport(), o14 = e7.passOptions, h4 = e7.drawPhase;
    s9.bind(e7), e7.passOptions = s9.createOptions(e7, this._hitTestsRequests), e7.drawPhase = E.HITTEST;
    const { distance: d10, smallSymbolDistance: l8 } = e7.passOptions, u12 = Math.max(d10, l8);
    for (const i12 of this.children) i12.visible && i12.containsScreenPoint(e7.state, e7.passOptions.position, 2 * u12) && this._renderTile(i12, e7, R.All);
    s9.draw(e7), s9.unbind(), t11.bindFramebuffer(r12), t11.restoreViewport(a11), e7.passOptions = o14, e7.drawPhase = h4;
  }
  _renderFeatures(e7, t11) {
    const s9 = this._getHeatmapInstance(e7);
    null != s9 ? this._renderHeatmapFeatures(e7, t11, s9) : this._renderGeometryFeatures(e7, t11);
  }
  _renderGeometryFeatures(e7, t11) {
    for (const s9 of this.children) s9.visible && this._renderTile(s9, e7, t11);
  }
  _renderHeatmapFeatures(e7, t11, s9) {
    for (const r12 of this.children) r12.visible && this._renderTile(r12, e7, t11, e3.Heatmap);
    s9.techniqueRef.renderResolvePass(e7, s9);
  }
  _renderTile(e7, t11, s9, r12) {
    const i12 = has("featurelayer-force-marker-text-draw-order") ? N.STRICT_MARKERS_AND_TEXT : N.BATCHING, n11 = e7.getDisplayList(this._instanceStore, i12);
    t11.selection = s9, n11 == null ? void 0 : n11.render(t11, r12);
  }
};
function _(e7) {
  return e7.techniqueRef.type === e3.Heatmap;
}

// node_modules/@arcgis/core/views/2d/layers/features/FeaturePipelineWorkerProxy.js
async function t6(t11) {
  const o14 = await p("FeaturePipelineWorker", { client: t11, strategy: "dedicated" });
  return new n6(o14);
}
var n6 = class {
  constructor(e7) {
    this._connection = e7, this.pipeline = this._connection.createInvokeProxy(), this.features = this._connection.createInvokeProxy("features"), this.aggregates = this._connection.createInvokeProxy("aggregates"), this.streamMessenger = this._connection.createInvokeProxy("streamMessenger");
  }
  destroy() {
    this._connection.destroy();
  }
  get closed() {
    return this._connection.closed;
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/FeatureSourceEventLog.js
var n7 = 10;
var l2 = class extends b2 {
  constructor() {
    super(...arguments), this.events = new o(), this._updatingStrategy = true, this._tileToEvent = new s3(), this._fetchStatus = { outstanding: 0, done: 0 };
  }
  get hasAllFeatures() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryAllFeatures) ?? false);
  }
  get hasAllFeaturesInView() {
    return this._hasAllData();
  }
  get hasFullGeometries() {
    var _a;
    return this._hasAllData() && (((_a = this._strategyInfo) == null ? void 0 : _a.willQueryFullResolutionGeometry) ?? false);
  }
  onEvent(t11) {
    switch (t11.type) {
      case "subscribe":
      case "unsubscribe":
      case "loaded":
      case "error":
        this._handleTileEvent(t11);
        break;
      case "updateStrategyStart":
        this._updatingStrategy = true, this._fetchStatus = { done: 0, outstanding: 0 }, this._strategyInfo = t11.about;
        break;
      case "updateStrategyEnd":
        this._updatingStrategy = false;
        break;
      case "updateFieldsStart":
        this._fetchStatus = { done: 0, outstanding: 0 };
        break;
      case "updateFieldsEnd":
        break;
      case "updateFieldsError":
        this.events.emit("error", t11);
        break;
      case "fetchStart":
        this._fetchStatus.outstanding += 1, this.events.emit("status", this._fetchStatus);
        break;
      case "fetchEnd":
        this._fetchStatus.done += 1, this.events.emit("status", this._fetchStatus), t11.done && (this._fetchStatus = { done: 0, outstanding: 0 });
    }
  }
  _hasAllData() {
    return !this._updatingStrategy && this._hasAllTileData();
  }
  _hasAllTileData() {
    for (const t11 of this._tileToEvent.values()) {
      const e7 = t11.peekLast();
      if ("loaded" !== (e7 == null ? void 0 : e7.type)) return false;
    }
    return true;
  }
  _handleTileEvent(t11) {
    switch (t11.type) {
      case "subscribe": {
        const e7 = new t(n7);
        e7.enqueue(t11), this._tileToEvent.set(t11.tile, e7);
        break;
      }
      case "unsubscribe":
        this._tileToEvent.delete(t11.tile);
        break;
      case "loaded": {
        const e7 = this._tileToEvent.get(t11.tile);
        if (!e7) return;
        e7.enqueue(t11), this._tileToEvent.set(t11.tile, e7);
        break;
      }
      case "error": {
        const e7 = this._tileToEvent.get(t11.tile);
        if (!e7) return;
        e7.enqueue(t11), this._tileToEvent.set(t11.tile, e7), this.events.emit("error", t11);
        break;
      }
    }
  }
};
r([m({ readOnly: true })], l2.prototype, "hasAllFeatures", null), r([m({ readOnly: true })], l2.prototype, "hasAllFeaturesInView", null), r([m({ readOnly: true })], l2.prototype, "hasFullGeometries", null), r([m()], l2.prototype, "_updatingStrategy", void 0), r([m()], l2.prototype, "_strategyInfo", void 0), r([m()], l2.prototype, "_tileToEvent", void 0), l2 = r([a2("esri.views.2d.layers.features.FeatureSourceEventLog")], l2);

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/geometryUtils.js
function e5(e7) {
  switch (e7.geometryType) {
    case "point":
      return "esriGeometryPoint";
    case "polyline":
      return "esriGeometryPolyline";
    case "polygon":
      return "esriGeometryPolygon";
    case "multipatch":
      return "esriGeometryMultiPatch";
    case "multipoint":
      return "esriGeometryMultipoint";
    default:
      return null;
  }
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureReductionUtils.js
function e6(e7, a11) {
  const c11 = e7.featureReduction;
  return c11 && "selection" !== c11.type && (!("maxScale" in c11) || !c11.maxScale || c11.maxScale < a11.scale) ? c11 : null;
}

// node_modules/@arcgis/core/views/2d/layers/support/visualVariableSimpleUtils.js
var r8 = Math.PI;
function i9(e7, t11) {
  switch (t11.transformationType) {
    case i3.Additive:
      return s7(e7, t11);
    case i3.Constant:
      return o5(t11, e7);
    case i3.ClampedLinear:
      return u5(e7, t11);
    case i3.Proportional:
      return l3(e7, t11);
    case i3.Stops:
      return c6(e7, t11);
    case i3.RealWorldSize:
      return m6(e7, t11);
    case i3.Identity:
      return e7;
    case i3.Unknown:
      return null;
  }
}
function a8(e7, t11) {
  return "number" == typeof e7 ? e7 : i9(t11, e7);
}
function s7(e7, t11) {
  return e7 + (a8(t11.minSize, e7) || t11.minDataValue);
}
function o5(e7, t11) {
  const n11 = e7.stops;
  let r12 = (n11 == null ? void 0 : n11.length) && n11[0].size;
  return null == r12 && (r12 = e7.minSize), a8(r12, t11);
}
function u5(e7, t11) {
  const n11 = t11.minDataValue, r12 = t11.maxDataValue, i12 = (e7 - n11) / (r12 - n11), s9 = a8(t11.minSize, e7), o14 = a8(t11.maxSize, e7);
  return e7 <= n11 ? s9 : e7 >= r12 ? o14 : s9 + i12 * (o14 - s9);
}
function l3(t11, n11) {
  const r12 = t11 / n11.minDataValue, i12 = a8(n11.minSize, t11), s9 = a8(n11.maxSize, t11);
  let o14 = null;
  return o14 = r12 * i12, r2(o14, i12, s9);
}
function c6(e7, t11) {
  const [n11, r12, i12] = p5(e7, t11.cache.ipData);
  if (n11 === r12) return a8(t11.stops[n11].size, e7);
  {
    const s9 = a8(t11.stops[n11].size, e7);
    return s9 + (a8(t11.stops[r12].size, e7) - s9) * i12;
  }
}
function m6(n11, i12) {
  const s9 = m3[i12.valueUnit], o14 = a8(i12.minSize, n11), u12 = a8(i12.maxSize, n11), { valueRepresentation: l8 } = i12;
  let c11 = null;
  return c11 = "area" === l8 ? 2 * Math.sqrt(n11 / r8) / s9 : "radius" === l8 || "distance" === l8 ? 2 * n11 / s9 : n11 / s9, r2(c11, o14, u12);
}
function p5(e7, t11) {
  if (!t11) return;
  let n11 = 0, r12 = t11.length - 1;
  return t11.some((t12, i12) => e7 < t12 ? (r12 = i12, true) : (n11 = i12, false)), [n11, r12, (e7 - t11[n11]) / (t11[r12] - t11[n11])];
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/labelingUtils.js
function l4(n11) {
  var _a;
  return (n11.labelsVisible && ((_a = n11.labelingInfo) == null ? void 0 : _a.every((n12) => "none" !== n12.deconflictionStrategy))) ?? false;
}
function r9(n11, i12) {
  var _a;
  const l8 = e6(n11, i12);
  if ((l8 == null ? void 0 : l8.labelsVisible) && ((_a = l8.labelingInfo) == null ? void 0 : _a.length)) return l8.labelingInfo.every((n12) => "none" !== n12.deconflictionStrategy);
}
function t7(e7) {
  return (l8) => u4(i9(l8, e7));
}
function o6(n11) {
  const e7 = null != n11 && "visualVariables" in n11 && n11.visualVariables;
  if (!e7) return null;
  for (const i12 of e7) if ("size" === i12.type) return t7(i12);
  return null;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/SourceSchema.js
function t8(t11, i12, s9, o14) {
  var _a, _b;
  const r12 = null != t11.subtypeCode ? `${t11.subtypeField} = ${t11.subtypeCode}` : null, n11 = n2(t11.definitionExpression, r12), a11 = t11.customParameters ?? {};
  return o14 && (a11.token = o14), { type: "feature", mutable: { sourceRefreshVersion: s9, availableFields: i12.availableFields, dataFilter: { queryScaleRanges: t11.queryScaleRanges ?? [], definitionExpression: n11, gdbVersion: t11.gdbVersion, historicMoment: (_a = t11.historicMoment) == null ? void 0 : _a.getTime(), timeExtent: (_b = t11.timeExtent) == null ? void 0 : _b.toJSON(), customParameters: a11 } } };
}

// node_modules/@arcgis/core/views/2d/engine/webgl/color.js
function u6(n11, r12, t11 = 0) {
  if (null == r12) return n11[t11] = 0, n11[t11 + 1] = 0, n11[t11 + 2] = 0, void (n11[t11 + 3] = 0);
  const { r: o14, g: u12, b: i12, a: c11 } = r12;
  n11[t11] = o14 * c11 / 255, n11[t11 + 1] = u12 * c11 / 255, n11[t11 + 2] = i12 * c11 / 255, n11[t11 + 3] = c11;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/symbols/SymbolSchema.js
async function g3(i12, a11) {
  if (!i12) return [];
  switch (i12.type) {
    case "simple-fill":
      return P2(i12, a11);
    case "picture-fill":
      return U(i12, a11);
    case "simple-marker":
      return w4(i12, a11);
    case "picture-marker":
      return O3(i12, a11);
    case "simple-line":
      return F2(i12, a11, false);
    case "text":
      return L3(i12, a11);
    case "label":
      return R2(i12, a11);
    case "cim":
      return c(i12.data, a11);
    case "web-style": {
      const e7 = await i12.fetchCIMSymbol();
      return c(e7.data, a11);
    }
    case "line-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i12.type}" unsupported in MapView. Defaulting to simple-line`), F2(new d3(), a11, false);
    case "point-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i12.type}" unsupported in MapView. Defaulting to simple-marker`), w4(new y(), a11);
    case "polygon-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i12.type}" unsupported in MapView. Defaulting to simple-fill`), P2(new S(), a11);
    case "mesh-3d":
    case "label-3d":
      return n.getLogger("esri.views.layers.FeatureLayerView").warn("unsupported-symbol", `Symbol of type "${i12.type}" unsupported in MapView. Ignoring`), [];
    case "CIMSymbolReference":
      throw new Error("InternalError: CIMSymbolReference should already be resolved");
  }
}
async function M3(e7, i12) {
  const { schemaOptions: a11 } = i12, { store: l8 } = a11, r12 = new Array(s4), t11 = new Array(s4 / 4);
  for (let p9 = 0; p9 < s4; p9++) {
    const i13 = p9 < e7.attributes.length ? e7.attributes[p9].color : null;
    r12[p9] = [0, 0, 0, 0], u6(r12[p9], i13);
  }
  for (let u12 = 0; u12 < s4 / 4; u12++) t11[u12] = [0, 0, 0, 0], t11[u12][0] = 4 * u12 < e7.attributes.length ? 1 : 0, t11[u12][1] = 4 * u12 + 1 < e7.attributes.length ? 1 : 0, t11[u12][2] = 4 * u12 + 2 < e7.attributes.length ? 1 : 0, t11[u12][3] = 4 * u12 + 3 < e7.attributes.length ? 1 : 0;
  const o14 = { uniforms: { isActive: t11, colors: r12, dotValue: e7.dotValue, dotScale: e7.referenceScale, blending: e7.dotBlendingEnabled, dotSize: e7.dotSize, seed: e7.seed }, optionalAttributes: {} }, s9 = l8.ensureInstance(T2.dotDensity, o14).createMeshInfo({ effects: null }), n11 = [], f5 = new S({ color: e7.backgroundColor ?? [0, 0, 0, 0], outline: null }), b6 = await g3(f5, i12);
  if (n11.push(...b6), n11.push(s9), e7.outline) {
    const a12 = F2(e7.outline, i12, true);
    n11.push(...a12);
  }
  return n11;
}
async function x3(e7, l8) {
  const { store: r12 } = l8, { radius: t11, minDensity: o14, maxDensity: s9, referenceScale: n11, field: u12, valueExpression: c11, colorStops: f5 } = e7, b6 = f2(f5);
  return [r12.ensureInstance(T2.heatmap, { uniforms: { radius: u4(t11), minDensity: o14, maxDensity: s9, referenceScale: n11, isFieldActive: !(!u12 && !c11), gradient: b6, gradientHash: b6.join(",") }, optionalAttributes: {} }).createMeshInfo({ effects: null })];
}
async function C(e7, a11) {
  var _a, _b, _c, _d;
  const { store: l8 } = a11, r12 = ((_a = e7.outline) == null ? void 0 : _a.width) || 0, t11 = M2(e7), o14 = l8.ensureInstance(T2.pieChart, { uniforms: { shader: { outlineWidth: Math.round(u4(r12)), defaultColor: t3(e7.defaultColor), outlineColor: t3((_b = e7.outline) == null ? void 0 : _b.color), othersColor: t3((_c = e7.othersCategory) == null ? void 0 : _c.color), donutRatio: e7.holePercentage, sectorThreshold: ((_d = e7.othersCategory) == null ? void 0 : _d.threshold) || 0, colors: e7.attributes.map((e8) => t3(e8.color)), visualVariableOpacity: t11.visualVariableOpacity, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue, hittestUniforms: null }, numberOfFields: e7.attributes.length }, optionalAttributes: {} }).createMeshInfo({ size: e7.size, outlineWidth: r12, effects: null, scaleInfo: null, minPixelBuffer: h2(t11) });
  return [...e7.backgroundFillSymbol ? await P2(e7.backgroundFillSymbol, { schemaOptions: a11, path: "", uniforms: x2 }) : [], o14];
}
function I2(e7) {
  if ("path" === e7.style) {
    if (null == e7.path) throw new Error("Symbol with a style of type path must define a path");
    return { type: "sprite-rasterization-param", overrides: [], resource: { type: "path", path: e7.path, asFill: true } };
  }
  const i12 = ee.fromSimpleMarker(e7);
  if ("outline" in e7 && e7.outline && "none" !== e7.outline.style) {
    if ("solid" !== e7.outline.style) {
      if (!i12 || !i12.symbolLayers) throw new Error("Error handling marker! ");
      return { type: "sprite-rasterization-param", resource: i12.symbolLayers[0], overrides: [] };
    }
  }
  return { type: "sprite-rasterization-param", resource: a5(i12), overrides: [] };
}
async function w4(e7, i12) {
  var _a, _b, _c, _d, _e;
  const { uniforms: a11, schemaOptions: r12 } = i12, { store: o14 } = r12;
  if ("path" === e7.style || e7.outline && "solid" !== e7.outline.style && "none" !== e7.outline.style) {
    const r13 = ee.fromSimpleMarker(e7);
    if (!r13 || !r13.symbolLayers) throw new Error("Error handling marker! ");
    if (a11.visualVariableRotation && (r13.angleAlignment = "Map"), "path" !== e7.style) {
      const e8 = r13.symbolLayers[0];
      if (a7(i12.uniforms)) {
        const a12 = h2(i12.uniforms, 0, 1);
        if (a12 > e8.size) {
          const i13 = a12 / e8.size;
          e8.size = a12;
          const l8 = (_a = e8.markerGraphics) == null ? void 0 : _a[0].symbol;
          (l8.symbolLayers && l8.symbolLayers[0]).width *= i13;
        }
      }
    }
    return c({ type: "CIMSymbolReference", symbol: r13 }, i12);
  }
  const s9 = o14.ensureInstance(T2.marker, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity, visualVariableSizeMinMaxValue: a11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a11.visualVariableSizeScaleStops, visualVariableSizeStops: a11.visualVariableSizeStops, visualVariableSizeUnitValue: a11.visualVariableSizeUnitValue, visualVariableRotation: a11.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), n11 = I2(e7);
  let u12 = ((_b = e7.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0];
  "CIMVectorMarker" === n11.resource.type && (u12 = [255, 255, 255, 255]);
  const c11 = "triangle" === e7.style ? 124 / 116 : 1, f5 = e7.size, b6 = f5 * c11, S2 = null != a11.visualVariableColor && ("cross" === e7.style || "x" === e7.style);
  return [s9.createMeshInfo({ type: "simple", color: u12, height: f5, width: b6, offsetX: e7.xoffset, offsetY: e7.yoffset, angle: e7.angle, alignment: i5(a11) ? i2.MAP : i2.SCREEN, outlineColor: ((_d = (_c = e7.outline) == null ? void 0 : _c.color) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], outlineSize: ((_e = e7.outline) == null ? void 0 : _e.width) ?? 1, referenceSize: f5, sprite: n11, overrideOutlineColor: S2, hasSizeVV: a7(a11), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h2(a11) })];
}
function O3(e7, i12) {
  const { uniforms: a11, schemaOptions: r12 } = i12, { store: o14 } = r12, s9 = o14.ensureInstance(T2.marker, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity, visualVariableSizeMinMaxValue: a11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a11.visualVariableSizeScaleStops, visualVariableSizeStops: a11.visualVariableSizeStops, visualVariableSizeUnitValue: a11.visualVariableSizeUnitValue, visualVariableRotation: a11.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), n11 = ee.createPictureMarkerRasterizationParam(e7);
  if (!n11) return [];
  return [s9.createMeshInfo({ type: "picture", color: [255, 255, 255, 255], height: e7.height, width: e7.width, offsetX: e7.xoffset, offsetY: e7.yoffset, angle: e7.angle, alignment: i5(a11) ? i2.MAP : i2.SCREEN, outlineColor: null, outlineSize: 0, referenceSize: e7.height, sprite: n11, overrideOutlineColor: false, hasSizeVV: a7(a11), placement: null, effects: null, transforms: null, scaleInfo: null, minPixelBuffer: h2(a11) })];
}
function A2(e7, i12, a11) {
  var _a, _b;
  const { uniforms: l8, schemaOptions: r12 } = a11, { store: s9 } = r12, n11 = s9.ensureInstance(T2.marker, { uniforms: { visualVariableColor: l8.visualVariableColor, visualVariableOpacity: l8.visualVariableOpacity, visualVariableSizeMinMaxValue: l8.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: l8.visualVariableSizeScaleStops, visualVariableSizeStops: l8.visualVariableSizeStops, visualVariableSizeUnitValue: l8.visualVariableSizeUnitValue, visualVariableRotation: l8.visualVariableRotation }, optionalAttributes: { zoomRange: false } }), u12 = I2(e7), c11 = 6, f5 = c11 * i12.width, b6 = f5, S2 = ((_a = e7.color) == null ? void 0 : _a.toArray()) ?? ((_b = i12.color) == null ? void 0 : _b.toArray()) ?? [0, 0, 0, 0], V2 = "cross" === e7.style || "x" === e7.style;
  let h4;
  switch (e7.placement) {
    case "begin-end":
      h4 = r3.Both;
      break;
    case "begin":
      h4 = r3.JustBegin;
      break;
    case "end":
      h4 = r3.JustEnd;
      break;
    default:
      h4 = r3.None;
  }
  const z = { type: "cim-marker-placement-param", placement: { type: "CIMMarkerPlacementAtExtremities", angleToLine: true, offset: 0, extremityPlacement: h4, offsetAlongLine: 0 }, overrides: [] };
  return [n11.createMeshInfo({ type: "simple", color: S2, height: b6, width: f5, offsetX: 0, offsetY: 0, angle: 0, alignment: i5(l8) ? i2.MAP : i2.SCREEN, outlineColor: S2, outlineSize: V2 ? i12.width : 0, referenceSize: b6 / c11, sprite: u12, overrideOutlineColor: V2 && null != l8.visualVariableColor, hasSizeVV: a7(l8), placement: z, transforms: null, effects: null, scaleInfo: null, minPixelBuffer: h2(l8) })];
}
function L3(e7, i12) {
  var _a, _b, _c, _d;
  const { uniforms: a11, schemaOptions: r12 } = i12, { store: t11 } = r12;
  return [t11.ensureInstance(T2.text, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity, visualVariableRotation: a11.visualVariableRotation, visualVariableSizeMinMaxValue: a11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: a11.visualVariableSizeScaleStops, visualVariableSizeStops: a11.visualVariableSizeStops, visualVariableSizeUnitValue: a11.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false, clipAngle: false, referenceSymbol: false } }).createMeshInfo({ boxBackgroundColor: (_a = e7.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = e7.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: e7.borderLineSize ?? 0, color: ((_c = e7.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: e7.xoffset, offsetY: e7.yoffset, postAngle: e7.angle, fontSize: e7.font.size, decoration: e7.font.decoration, haloColor: ((_d = e7.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloSize: e7.haloSize ?? 0, outlineColor: [0, 0, 0, 0], outlineSize: 0, lineWidth: e7.lineWidth, lineHeightRatio: e7.lineHeight, horizontalAlignment: e7.horizontalAlignment, verticalAlignment: e7.verticalAlignment, useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: e7.font.toJSON(), textString: e7.text, symbol: ee.createCIMTextSymbolfromTextSymbol(e7) }, overrides: [] }, referenceSize: null, effects: null, placement: null, scaleInfo: null, transforms: null, scaleFactor: 1, minPixelBuffer: h2(a11), repeatLabel: null, repeatLabelDistance: null, allowOverrun: null, labelPosition: null })];
}
function R2(e7, a11) {
  var _a, _b, _c, _d, _e, _f;
  const { schemaOptions: r12, uniforms: t11 } = a11, { store: o14 } = r12, s9 = e7.symbol, { allowOverrun: u12, repeatLabel: c11, repeatLabelDistance: f5 } = e7, b6 = { maxScale: e7.maxScale ?? 0, minScale: e7.minScale ?? 0 }, S2 = o14.ensureInstance(T2.label, { uniforms: { visualVariableColor: null, visualVariableOpacity: null, visualVariableRotation: t11.visualVariableRotation, visualVariableSizeMinMaxValue: t11.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: t11.visualVariableSizeScaleStops, visualVariableSizeStops: t11.visualVariableSizeStops, visualVariableSizeUnitValue: t11.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: true, clipAngle: true, referenceSymbol: true } }), V2 = e7.labelPlacement, [y5, v3] = o3(V2);
  return [S2.createMeshInfo({ boxBackgroundColor: (_a = s9.backgroundColor) == null ? void 0 : _a.toArray(), boxBorderLineColor: (_b = s9.borderLineColor) == null ? void 0 : _b.toArray(), boxBorderLineSize: s9.borderLineSize ?? 0, color: ((_c = s9.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], offsetX: s9.xoffset, offsetY: s9.yoffset, postAngle: s9.angle, fontSize: s9.font.size, decoration: s9.font.decoration, outlineColor: [0, 0, 0, 0], outlineSize: 0, haloColor: ((_d = s9.haloColor) == null ? void 0 : _d.toArray()) ?? [0, 0, 0, 0], haloSize: s9.haloSize ?? 0, lineWidth: s9.lineWidth, lineHeightRatio: s9.lineHeight, horizontalAlignment: y5, verticalAlignment: v3, repeatLabel: c11, repeatLabelDistance: u4(f5), allowOverrun: u12, labelPosition: e7.labelPosition, scaleInfo: b6, minPixelBuffer: h2(t11), useCIMAngleBehavior: false, glyphs: { type: "text-rasterization-param", resource: { type: "text", font: s9.font.toJSON(), textString: s9.text, symbol: ee.createCIMTextSymbolfromTextSymbol(s9), primitiveName: "label-override" }, useLegacyLabelEvaluationRules: null == ((_e = e7.labelExpressionInfo) == null ? void 0 : _e.expression), overrides: [{ type: "CIMPrimitiveOverride", valueExpressionInfo: { type: "CIMExpressionInfo", expression: ((_f = e7.labelExpressionInfo) == null ? void 0 : _f.expression) ?? e7.labelExpression, returnType: "String" }, primitiveName: "label-override", propertyName: "textString", defaultValue: "" }] }, referenceSize: null, effects: null, placement: null, transforms: null, scaleFactor: 1 })];
}
function k(e7, i12) {
  var _a;
  const a11 = e7.width;
  return { outlineColor: ((_a = e7.color) == null ? void 0 : _a.toArray()) || [0, 0, 0, 1], width: a11, referenceWidth: a11, capType: e7.cap ?? "round", joinType: e7.join ?? "round", miterLimit: e7.miterLimit, hasSizeVV: i12 };
}
function j2(e7, i12) {
  var _a, _b, _c;
  const { uniforms: a11, schemaOptions: l8 } = i12, { store: r12 } = l8, t11 = ((_a = e7.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0], o14 = { type: "sprite-rasterization-param", resource: { type: "fill-style", style: e7.style }, overrides: [] };
  if ("solid" === ((_b = e7.outline) == null ? void 0 : _b.style)) {
    return [r12.ensureInstance(T2.patternOutlineFill, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity, visualVariableSizeScaleStops: a11.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e7.outline, !!a11.visualVariableSizeOutlineScaleStops), sprite: o14, scaleInfo: null, effects: null })];
  }
  const s9 = [], n11 = r12.ensureInstance(T2.patternFill, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: ((_c = e7.color) == null ? void 0 : _c.toArray()) ?? [0, 0, 0, 0], sprite: o14, scaleInfo: null, effects: null });
  return s9.push(n11), e7.outline && s9.push(...F2(e7.outline, i12, true)), s9;
}
function E2(e7, i12) {
  var _a, _b;
  const { uniforms: a11, schemaOptions: l8 } = i12, { store: r12 } = l8, t11 = ((_a = e7.color) == null ? void 0 : _a.toArray()) ?? [0, 0, 0, 0];
  if ("none" !== e7.style && "solid" === ((_b = e7.outline) == null ? void 0 : _b.style)) {
    return [r12.ensureInstance(T2.outlineFill, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity, visualVariableSizeScaleStops: a11.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, ...k(e7.outline, !!a11.visualVariableSizeOutlineScaleStops), scaleInfo: null, effects: null })];
  }
  const o14 = [];
  if ("none" !== e7.style) {
    const e8 = r12.ensureInstance(T2.fill, { uniforms: { visualVariableColor: a11.visualVariableColor, visualVariableOpacity: a11.visualVariableOpacity }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ color: t11, scaleInfo: null, effects: null });
    o14.push(e8);
  }
  return e7.outline && o14.push(...F2(e7.outline, i12, true)), o14;
}
async function P2(e7, i12) {
  if ("cim" === e7.type) return c(e7.data, i12);
  const { style: a11 } = e7;
  return a11 && "none" !== a11 && "solid" !== a11 ? j2(e7, i12) : E2(e7, i12);
}
function U(e7, i12) {
  const { outline: a11 } = e7, { uniforms: r12, schemaOptions: t11 } = i12, { store: o14 } = t11, s9 = [], n11 = ee.createPictureFillRasterizationParam(e7);
  if (!n11) return [];
  const { width: u12, height: c11, xoffset: f5, yoffset: b6, xscale: m12, yscale: S2 } = e7, V2 = { color: [255, 255, 255, 255], sprite: n11, height: c11, aspectRatio: u12 / c11, offsetX: f5, offsetY: b6, scaleX: m12, scaleY: S2, angle: 0, applyRandomOffset: false, sampleAlphaOnly: false, scaleProportionally: false, effects: null, scaleInfo: null };
  if ("solid" === (a11 == null ? void 0 : a11.style)) {
    return [o14.ensureInstance(T2.complexOutlineFill, { uniforms: { visualVariableColor: r12.visualVariableColor, visualVariableOpacity: r12.visualVariableOpacity, visualVariableSizeScaleStops: r12.visualVariableSizeOutlineScaleStops, visualVariableSizeMinMaxValue: null, visualVariableSizeStops: null, visualVariableSizeUnitValue: null }, optionalAttributes: { zoomRange: false } }).createMeshInfo({ ...V2, ...k(a11, !!r12.visualVariableSizeOutlineScaleStops) })];
  }
  const y5 = o14.ensureInstance(T2.complexFill, { uniforms: { visualVariableColor: r12.visualVariableColor, visualVariableOpacity: r12.visualVariableOpacity }, optionalAttributes: { zoomRange: false } });
  return s9.push(y5.createMeshInfo(V2)), a11 && s9.push(...F2(a11, i12, true)), s9;
}
function F2(e7, i12, a11) {
  const { color: l8, style: t11, width: o14, cap: s9, join: n11 } = e7, { schemaOptions: u12 } = i12, { store: c11 } = u12, f5 = [], b6 = a11 ? { ...x2, visualVariableSizeScaleStops: i12.uniforms.visualVariableSizeOutlineScaleStops } : i12.uniforms, m12 = { uniforms: { visualVariableColor: b6.visualVariableColor, visualVariableOpacity: b6.visualVariableOpacity, visualVariableSizeMinMaxValue: b6.visualVariableSizeMinMaxValue, visualVariableSizeScaleStops: b6.visualVariableSizeScaleStops, visualVariableSizeStops: b6.visualVariableSizeStops, visualVariableSizeUnitValue: b6.visualVariableSizeUnitValue }, optionalAttributes: { zoomRange: false } }, V2 = { color: (l8 == null ? void 0 : l8.toArray()) ?? [0, 0, 0, 0], width: o14, referenceWidth: o14, capType: s9, joinType: n11, miterLimit: e7.miterLimit, hasSizeVV: a7(b6), effects: null, scaleInfo: null };
  if (null == t11 || "solid" === t11) {
    const e8 = c11.ensureInstance(T2.line, m12).createMeshInfo(V2);
    f5.push(e8);
  } else if ("none" !== t11) {
    const e8 = c11.ensureInstance(T2.texturedLine, m12).createMeshInfo({ ...V2, offsetAlongLine: 0, shouldScaleDash: true, shouldSampleAlphaOnly: false, isSDF: true, sprite: { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: me(t11, s9) }, overrides: [] } });
    f5.push(e8);
  }
  return null != e7.marker && f5.push(...A2(e7.marker, e7, i12)), f5;
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/LabelMatcherSchema.js
async function l5(a11, l8, r12) {
  const n11 = l8.labelsVisible && l8.labelingInfo || [], i12 = e5(l8), m12 = a4(n11, i12);
  return { type: "label", classes: await Promise.all(m12.map((e7, s9) => o7(a11, e7, s9, r12))) };
}
async function o7(e7, s9, l8, o14) {
  var _a;
  const r12 = await g3(s9, { path: `${l8}`, schemaOptions: e7, uniforms: o14 });
  return { maxScale: s9.maxScale, minScale: s9.minScale, expression: ((_a = s9.labelExpressionInfo) == null ? void 0 : _a.expression) ?? s9.labelExpression, where: s9.where, meshes: r12 };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/MatcherSchema.js
async function r10(e7, a11) {
  if (!a11) return { type: "simple", meshes: [] };
  switch (a11.type) {
    case "simple":
      return o8(e7, a11);
    case "dot-density":
      return u7(e7, a11);
    case "class-breaks":
      return m8(e7, a11);
    case "unique-value":
      return c7(e7, a11);
    case "dictionary":
      return p6(a11);
    case "heatmap":
      return f3(e7, a11);
    case "pie-chart":
      return y3(e7, a11);
  }
}
async function o8(a11, l8) {
  const n11 = l8.getSymbols(), s9 = n11.length ? n11[0] : null, r12 = M2(l8), t11 = "renderer.symbol";
  return { type: "simple", meshes: await g3(s9, { schemaOptions: a11, uniforms: r12, path: t11 }) };
}
async function u7(a11, i12) {
  const n11 = M2(i12), s9 = "renderer.symbol";
  return { type: "dot-density", meshes: await M3(i12, { schemaOptions: a11, uniforms: n11, path: s9 }) };
}
async function m8(l8, n11) {
  const s9 = M2(n11), r12 = n11.backgroundFillSymbol, t11 = n11.normalizationType, o14 = "log" === t11 ? "esriNormalizeByLog" : "percent-of-total" === t11 ? "esriNormalizeByPercentOfTotal" : "field" === t11 ? "esriNormalizeByField" : null, u12 = n11.classBreakInfos.map(async (e7) => ({ meshes: await g3(e7.symbol, { path: `renderer-stop-${e7.minValue}-${e7.maxValue}`, schemaOptions: l8, uniforms: s9 }), min: e7.minValue, max: e7.maxValue })), m12 = (await Promise.all(u12)).sort((e7, a11) => e7.min - a11.min), c11 = await g3(r12, { schemaOptions: l8, path: "renderer.backgroundFill", uniforms: { ...x2, visualVariableSizeOutlineScaleStops: s9.visualVariableSizeOutlineScaleStops } }), p9 = await g3(n11.defaultSymbol, { schemaOptions: l8, path: "renderer.defaultSymbol", uniforms: s9 });
  return { type: "interval", field: n11.field, expression: n11.valueExpression, backgroundFill: c11, defaultSymbol: p9, intervals: m12, normalizationField: n11.normalizationField, normalizationTotal: n11.normalizationTotal, normalizationType: o14, isMaxInclusive: n11.isMaxInclusive };
}
async function c7(l8, n11) {
  const s9 = [], r12 = M2(n11), t11 = await g3(n11.backgroundFillSymbol, { schemaOptions: l8, path: "renderer.backgroundFill", uniforms: { ...x2, visualVariableSizeOutlineScaleStops: r12.visualVariableSizeOutlineScaleStops } }), o14 = await g3(n11.defaultSymbol, { schemaOptions: l8, path: "renderer.defaultSymbol", uniforms: r12 });
  for (const e7 of n11.uniqueValueInfos ?? []) {
    const a11 = await g3(e7.symbol, { path: `renderer-unique-value-${e7.value}`, schemaOptions: l8, uniforms: r12 });
    s9.push({ value: "" + e7.value, symbol: a11 });
  }
  return { type: "map", field: n11.field, expression: n11.valueExpression, field2: n11.field2, field3: n11.field3, fieldDelimiter: n11.fieldDelimiter, backgroundFill: t11, defaultSymbol: o14, map: s9 };
}
function p6(a11) {
  const i12 = M2(a11), l8 = a11.scaleExpression, n11 = null != l8 && "1" !== l8 ? { valueExpressionInfo: { type: "CIMExpressionInfo", expression: a11.scaleExpression, returnType: "Numeric" }, defaultValue: 1 } : void 0;
  return { type: "dictionary", fieldMap: a11.fieldMap, scaleExpression: n11, visualVariableUniforms: i12 };
}
async function f3(e7, a11) {
  return { type: "heatmap", meshes: await x3(a11, e7) };
}
async function y3(e7, a11) {
  return { type: "pie-chart", meshes: await C(a11, e7) };
}

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SimpleProcessorSchema.js
async function a9(e7, r12) {
  const t11 = r12.renderer, n11 = M2(t11);
  return { symbology: await r10(e7, t11), labels: await l5(e7, r12, n11) };
}
async function o9(e7, r12, t11, i12) {
  const s9 = t11.featureReduction;
  if (s9) switch (s9.type) {
    case "binning":
      return f4(s9, e7, r12, t11, i12);
    case "cluster":
      return d8(s9, e7, r12, t11, i12);
  }
  const l8 = y4(t11.orderBy, t11.renderer, t11.objectIdField), o14 = t4(t11.renderer, r12.filters), u12 = await a9(e7, t11), c11 = m9(u12.symbology);
  return { storage: o14, mesh: { properties: { sortKey: l8, timeZone: r12.timeZone, returnMeshObjectId: c11, displayRefreshVersion: i12 }, strategy: { type: "feature" }, factory: u12 } };
}
function u8(e7, r12) {
  return e7.fields.map((e8) => ({ ...e8.toJSON(), type: c8(e8, r12) }));
}
function c8(e7, r12) {
  const { onStatisticExpression: t11, onStatisticField: i12, statisticType: s9 } = e7;
  switch (s9) {
    case "min":
    case "max":
    case "avg":
    case "avg_angle":
    case "sum":
    case "count":
      return "esriFieldTypeDouble";
    case "mode": {
      if (t11) {
        const { returnType: e9 } = t11;
        return e9 ? "string" === e9 ? "esriFieldTypeString" : "esriFieldTypeDouble" : "esriFieldTypeString";
      }
      const e8 = r12.find((e9) => e9.name === i12);
      return e8 ? e8.type : "esriFieldTypeString";
    }
  }
}
async function f4(r12, t11, a11, o14, c11) {
  const f5 = u8(r12, o14.fields), d10 = r12.renderer, y5 = await r10(t11, d10), p9 = t4(d10, [null, null]), g4 = M2(d10), b6 = await l5(t11, { geometryType: "polygon", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, g4), h4 = m9(y5), v3 = "geohash" === r12.binType ? { type: "geohash", fixBinLevel: r12.fixedBinLevel ?? 3 } : { type: "grid", size: u4(r12.size), fixedBinLevel: r12.fixedBinLevel };
  return { storage: p9, mesh: { properties: { sortKey: null, timeZone: a11.timeZone, returnMeshObjectId: h4, displayRefreshVersion: c11 }, strategy: { type: "binning", fields: f5, index: v3, featureFilter: a11.filters[0] }, factory: { labels: b6, symbology: y5 } } };
}
async function d8(r12, t11, a11, o14, c11) {
  const f5 = u8(r12, o14.fields), d10 = { type: "cluster", feature: await r10(t11, r12.effectiveFeatureRenderer), cluster: await r10(t11, r12.effectiveClusterRenderer) }, y5 = M2(r12.effectiveFeatureRenderer), p9 = { type: "cluster", feature: await l5(t11, o14, y5), cluster: await l5(t11, { geometryType: "point", labelingInfo: r12.labelingInfo, labelsVisible: r12.labelsVisible }, y5) }, g4 = t4(r12.effectiveFeatureRenderer, [null, null]), b6 = m9(d10);
  return { storage: g4, mesh: { properties: { sortKey: null, timeZone: a11.timeZone, displayRefreshVersion: c11, returnMeshObjectId: b6 }, strategy: { type: "cluster", fields: f5, featureFilter: a11.filters[0], clusterRadius: u4(r12.clusterRadius / 2) }, factory: { labels: p9, symbology: d10 } } };
}
function y4(e7, t11, i12) {
  const s9 = null != t11 && "unique-value" === t11.type && t11.orderByClassesEnabled;
  if ("default" !== e7 || s9 || (e7 = [new a3({ field: i12, order: "descending" })]), "default" !== e7 && (e7 == null ? void 0 : e7.length)) {
    e7.length;
    const r12 = e7[0], t12 = "ascending" === r12.order ? "asc" : "desc";
    return r12.field ? { field: r12.field, order: t12 } : r12.valueExpression ? { expression: r12.valueExpression, order: t12 } : null;
  }
  if (s9) {
    return { byRenderer: true, order: "asc" };
  }
  return null;
}
function p7(e7) {
  return e7.techniqueType === e3.AnimatedMarker;
}
function m9(e7) {
  if ("simple" === e7.type && e7.meshes.some(p7)) return true;
  if ("interval" === e7.type) {
    if (e7.intervals.some((e8) => e8.meshes.some(p7))) return true;
    if (e7.backgroundFill.some(p7)) return true;
  }
  if ("map" === e7.type) {
    if (e7.map.some((e8) => e8.symbol.some(p7))) return true;
    if (e7.backgroundFill.some(p7)) return true;
  }
  return false;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/CatalogFootprintLayerAdapter.js
var l6 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, t11 = l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(o14) {
    var _a, _b;
    const s9 = this.layer, { capabilities: i12, editingInfo: a11, objectIdField: n11, globalIdField: l8, datesInUnknownTimezone: p9, orderBy: u12, parsedUrl: c11 } = s9, d10 = s9.fieldsIndex.toJSON(), m12 = e5(s9), y5 = (_a = s9.timeInfo) == null ? void 0 : _a.toJSON(), f5 = s9.spatialReference.toJSON(), g4 = a(c11);
    let h4 = n11;
    if (u12 == null ? void 0 : u12.length) {
      const e7 = !u12[0].valueExpression && u12[0].field;
      e7 && (h4 = e7);
    }
    return { type: "feature-service", source: g4, isSourceHosted: g2(g4.path), orderByFields: h4, outSpatialReference: o14.spatialReference.toJSON(), metadata: { timeReferenceUnknownClient: p9, globalIdField: l8, fieldsIndex: d10, geometryType: m12, objectIdField: n11, timeInfo: y5, spatialReference: f5, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i12.query.maxRecordCount, supportsCompactGeometry: i12.query.supportsCompactGeometry, supportsDefaultSpatialReference: i12.query.supportsDefaultSpatialReference, supportsFormatPBF: i12.query.supportsFormatPBF, supportsMaxRecordCountFactor: i12.query.supportsMaxRecordCountFactor, supportsQuantization: i12.query.supportsQuantization, lastEditDate: (_b = a11 == null ? void 0 : a11.lastEditDate) == null ? void 0 : _b.getTime(), snapshotInfo: null } };
  }
  createSourceSchema(e7, r12) {
    const { definitionExpression: t11, customParameters: o14, timeExtent: s9, apiKey: a11 } = this.layer;
    return t8({ definitionExpression: t11, customParameters: o14, timeExtent: s9 }, e7, r12, a11);
  }
  createProcessorSchema(e7, r12, t11) {
    const { fields: o14, geometryType: s9, orderBy: i12, objectIdField: n11, renderer: l8, labelingInfo: p9, labelsVisible: u12 } = this.layer, c11 = { featureReduction: null, fields: o14.map((e8) => e8.toJSON()), geometryType: s9, labelingInfo: p9, labelsVisible: u12, objectIdField: n11, orderBy: i12 ?? "default", renderer: l8 == null ? void 0 : l8.clone() };
    return o9(e7, r12, c11, t11);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e7) {
    const r12 = this.layer, { definitionExpression: t11, apiKey: o14, renderer: s9 } = r12, i12 = this.layer.labelsVisible ? this.layer.labelingInfo : null, a11 = JSON.stringify(r12.customParameters), n11 = JSON.stringify(r12.orderBy);
    return { outFields: this.layer.outFields, apiKey: o14, customParameters: a11, definitionExpression: t11, labelingInfo: i12, orderBy: n11, renderer: s9 };
  }
  setGraphicOrigin(e7) {
    e7.origin = { type: "catalog", layer: this.layer };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/featureServiceUtils.js
function t9(t11, e7) {
  const n11 = t11.extent, o14 = e7 == null ? void 0 : e7.clone().intersection(n11), i12 = null != o14 ? o14.width * o14.height : 0, r12 = e7 ? e7.width * e7.height : 0, h4 = 0 === r12 ? 0 : i12 / r12, s9 = has("featurelayer-snapshot-point-coverage");
  return !isNaN(h4) && h4 >= s9;
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/floorFilterUtils.js
function o10(e7, l8) {
  return null != e7.floorInfo && (e7.floorInfo.viewAllLevelIds.length > 0 || l8.floors.length > 0);
}
function r11(e7, o14, r12) {
  const t11 = n8(e7, o14 == null ? void 0 : o14.where, r12);
  return t11 ? (o14 ?? (o14 = new d6()), o14.where = t11, o14) : o14;
}
function n8(l8, o14, r12) {
  var _a;
  if (null == l8.floorInfo || !((_a = r12.floors) == null ? void 0 : _a.length)) return o14;
  let n11 = r12.floors;
  const { floorField: t11, viewAllLevelIds: f5 } = l8.floorInfo;
  f5.length && (n11 = f5);
  const s9 = n11.filter((e7) => "" !== e7).map((e7) => "'" + e7 + "'");
  if (s9.push("''"), o14 == null ? void 0 : o14.includes(t11)) {
    let e7 = new RegExp("AND \\(" + t11 + ".*NULL\\)", "g");
    o14 = o14.replace(e7, ""), e7 = new RegExp("\\(" + t11 + ".*NULL\\)", "g"), o14 = (o14 = o14.replace(e7, "")).replaceAll(/\s+/g, " ").trim();
  }
  let i12 = "(" + t11 + " IN ({ids}) OR " + t11 + " IS NULL)";
  return i12 = i12.replace("{ids}", s9.join(", ")), n2(o14, i12);
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/FeatureLayerAdapter.js
var c9 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const t11 = this.layer, r12 = r9(t11, e7) ?? l4(t11);
    return [{ vvEvaluators: { 0: o6(t11.renderer) }, deconflictionEnabled: r12 }];
  }
  async createServiceOptions(r12) {
    var _a, _b, _c2, _d;
    const s9 = this.layer, { capabilities: i12, editingInfo: n11, objectIdField: l8, typeIdField: p9, globalIdField: d10, datesInUnknownTimezone: u12, orderBy: y5, subtypeField: c11, refreshInterval: m12 } = s9, f5 = s9.fieldsIndex.toJSON(), h4 = e5(s9), b6 = (_a = s9.timeInfo) == null ? void 0 : _a.toJSON(), g4 = s9.spatialReference.toJSON(), S2 = (_b = s9.types) == null ? void 0 : _b.map((e7) => e7.toJSON()), F3 = a(this.layer.parsedUrl);
    this.layer.dynamicDataSource && (F3.query = { layer: JSON.stringify({ source: this.layer.dynamicDataSource }) });
    let I3 = this.layer.objectIdField;
    if (y5 == null ? void 0 : y5.length) {
      const e7 = !y5[0].valueExpression && y5[0].field;
      e7 && (I3 = e7);
    }
    const x4 = !(null != (n11 == null ? void 0 : n11.lastEditDate)) && m12 > 0, j3 = !!has("featurelayer-snapshot-enabled") && "point" === s9.geometryType && (i12 == null ? void 0 : i12.query.supportsPagination) && !(i12 == null ? void 0 : i12.operations.supportsEditing) && !x4, R3 = j3 && t9(r12, s9.fullExtent);
    return { type: "feature-service", source: F3, isSourceHosted: g2(F3.path), orderByFields: I3, outSpatialReference: r12.spatialReference.toJSON(), metadata: { typeIdField: p9 ?? void 0, types: S2, timeReferenceUnknownClient: u12, subtypeField: c11, globalIdField: d10, fieldsIndex: f5, geometryType: h4, objectIdField: l8, timeInfo: b6, spatialReference: g4, subtypes: (_c2 = this.layer.subtypes) == null ? void 0 : _c2.map((e7) => e7.toJSON()) }, queryMetadata: { maxRecordCount: i12.query.maxRecordCount, supportsCompactGeometry: i12.query.supportsCompactGeometry, supportsDefaultSpatialReference: i12.query.supportsDefaultSpatialReference, supportsFormatPBF: i12.query.supportsFormatPBF, supportsMaxRecordCountFactor: i12.query.supportsMaxRecordCountFactor, supportsQuantization: i12.query.supportsQuantization, lastEditDate: (_d = n11 == null ? void 0 : n11.lastEditDate) == null ? void 0 : _d.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: j3, supportsSnapshotMaxThreshold: R3, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e7, t11) {
    const { definitionExpression: r12, customParameters: o14, gdbVersion: s9, historicMoment: i12, subtypeCode: a11, subtypeField: n11, timeExtent: l8, apiKey: p9 } = this.layer;
    return t8({ definitionExpression: r12, customParameters: o14, gdbVersion: s9, historicMoment: i12, subtypeCode: a11, subtypeField: n11, timeExtent: l8 }, e7, t11, p9);
  }
  createProcessorSchema(e7, t11, o14) {
    const { fields: s9, renderer: i12, geometryType: a11, labelingInfo: n11, labelsVisible: l8, orderBy: p9, objectIdField: d10 } = this.layer, y5 = { fields: s9.map((e8) => e8.toJSON()), renderer: i12 == null ? void 0 : i12.clone(), featureReduction: e6(this.layer, t11), geometryType: a11, labelingInfo: n11, labelsVisible: l8, objectIdField: d10, orderBy: p9 ?? "default" };
    return o9(e7, t11, y5, o14);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  hasFilters(e7) {
    return o10(this.layer, e7);
  }
  addFilters(e7, t11) {
    return r11(this.layer, e7, t11);
  }
  getUpdateHashProperties(e7) {
    var _a;
    const t11 = this.layer, { definitionExpression: o14, renderer: i12, gdbVersion: a11, apiKey: n11, subtypeCode: l8 } = t11, p9 = this.layer.labelsVisible ? this.layer.labelingInfo : null, d10 = ((_a = t11.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, u12 = JSON.stringify(t11.customParameters), y5 = e6(t11, e7), c11 = JSON.stringify(t11.orderBy), m12 = o10(this.layer, e7) ? e7.floors : null;
    return { outFields: this.layer.outFields, apiKey: n11, customParameters: u12, definitionExpression: o14, featureReduction: y5, floors: m12, gdbVersion: a11, historicMoment: d10, labelingInfo: p9, orderBy: c11, renderer: i12, subtypeCode: l8 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/InMemoryLayerAdapter.js
function u9(r12) {
  if (!("openPorts" in r12)) throw new s("source-not-supported");
}
var p8 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, t11 = r9(r12, e7) ?? l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(e7) {
    var _a;
    const r12 = this.layer, { capabilities: o14, objectIdField: s9 } = r12, i12 = r12.fieldsIndex.toJSON(), n11 = e5(r12), l8 = (_a = r12.timeInfo) == null ? void 0 : _a.toJSON(), a11 = r12.spatialReference.toJSON();
    u9(r12.source);
    return { type: "memory", source: await r12.source.openPorts(), orderByFields: s9, outSpatialReference: e7.spatialReference.toJSON(), metadata: { fieldsIndex: i12, geometryType: n11, objectIdField: s9, timeInfo: l8, spatialReference: a11, subtypes: null, subtypeField: null, globalIdField: null, typeIdField: null, types: null, timeReferenceUnknownClient: null }, queryMetadata: { maxRecordCount: o14.query.maxRecordCount, supportsCompactGeometry: o14.query.supportsCompactGeometry, supportsDefaultSpatialReference: o14.query.supportsDefaultSpatialReference, supportsFormatPBF: o14.query.supportsFormatPBF, supportsMaxRecordCountFactor: o14.query.supportsMaxRecordCountFactor, supportsQuantization: o14.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e7, r12) {
    const { definitionExpression: t11, timeExtent: o14 } = this.layer;
    return t8({ definitionExpression: t11, timeExtent: o14, customParameters: null }, e7, r12, null);
  }
  createProcessorSchema(e7, t11, o14) {
    const { fields: s9, renderer: i12, geometryType: n11, labelingInfo: a11, labelsVisible: u12, orderBy: p9, objectIdField: c11 } = this.layer, d10 = { fields: s9.map((e8) => e8.toJSON()), renderer: i12 == null ? void 0 : i12.clone(), featureReduction: e6(this.layer, t11), geometryType: n11, labelingInfo: a11, labelsVisible: u12, objectIdField: c11, orderBy: p9 ?? "default" };
    return o9(e7, t11, d10, o14);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e7) {
    const t11 = this.layer, { definitionExpression: o14, renderer: s9 } = t11, i12 = this.layer.labelsVisible ? this.layer.labelingInfo : null, n11 = e6(t11, e7), l8 = JSON.stringify(t11.orderBy);
    return { outFields: this.layer.outFields, orderBy: l8, definitionExpression: o14, renderer: s9, labelingInfo: i12, featureReduction: n11 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/KnowledgeGraphSublayerAdapter.js
var a10 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, i12 = r9(r12, e7) ?? l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: i12 }];
  }
  async createServiceOptions(e7) {
    var _a2;
    const t11 = this.layer, { capabilities: o14, objectIdField: s9 } = t11, i12 = t11.fieldsIndex.toJSON(), n11 = e5(t11), l8 = t11.spatialReference.toJSON();
    return { type: "memory", source: await t11.source.openPorts(), orderByFields: s9, outSpatialReference: e7.spatialReference.toJSON(), metadata: { fieldsIndex: i12, geometryType: n11, objectIdField: s9, spatialReference: l8, globalIdField: null, subtypeField: null, subtypes: null, timeInfo: (_a2 = t11.timeInfo) == null ? void 0 : _a2.toJSON(), timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: o14.query.maxRecordCount, supportsCompactGeometry: o14.query.supportsCompactGeometry, supportsDefaultSpatialReference: o14.query.supportsDefaultSpatialReference, supportsFormatPBF: o14.query.supportsFormatPBF, supportsMaxRecordCountFactor: o14.query.supportsMaxRecordCountFactor, supportsQuantization: o14.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e7, r12) {
    const { definitionExpression: t11 } = this.layer;
    return t8({ definitionExpression: t11, customParameters: null }, e7, r12, null);
  }
  createProcessorSchema(r12, t11, o14) {
    const { fields: s9, renderer: i12, geometryType: l8, labelingInfo: a11, labelsVisible: u12, objectIdField: p9 } = this.layer, c11 = { fields: s9.map((e7) => e7.toJSON()), renderer: i12 == null ? void 0 : i12.clone(), featureReduction: e6(this.layer, t11), geometryType: l8, labelingInfo: a11, labelsVisible: u12, objectIdField: p9, orderBy: "default" };
    return o9(r12, t11, c11, o14);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(r12) {
    const t11 = this.layer, { definitionExpression: o14, renderer: s9 } = t11;
    return { definitionExpression: o14, renderer: s9, labelingInfo: this.layer.labelsVisible ? this.layer.labelingInfo : null, featureReduction: e6(t11, r12) };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OGCFeatureLayerAdapter.js
var u10 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, t11 = r9(r12, e7) ?? l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(r12) {
    var _a;
    const o14 = this.layer, { capabilities: s9, objectIdField: a11 } = o14, i12 = o14.fieldsIndex.toJSON(), l8 = e5(o14), n11 = (_a = o14.timeInfo) == null ? void 0 : _a.toJSON(), u12 = o14.spatialReference.toJSON(), c11 = o14.source.getSource(), p9 = this.layer.objectIdField, d10 = a(s9);
    return d10.query.maxRecordCount = c11.maxRecordCount, { type: "ogc", source: c11, orderByFields: p9, outSpatialReference: r12.spatialReference.toJSON(), metadata: { fieldsIndex: i12, geometryType: l8, objectIdField: a11, timeInfo: n11, spatialReference: u12, globalIdField: null, subtypeField: null, subtypes: null, timeReferenceUnknownClient: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: d10.query.maxRecordCount, supportsCompactGeometry: d10.query.supportsCompactGeometry, supportsDefaultSpatialReference: d10.query.supportsDefaultSpatialReference, supportsFormatPBF: d10.query.supportsFormatPBF, supportsMaxRecordCountFactor: d10.query.supportsMaxRecordCountFactor, supportsQuantization: d10.query.supportsQuantization, lastEditDate: null, snapshotInfo: null } };
  }
  createSourceSchema(e7, r12) {
    const { customParameters: t11, timeExtent: o14, apiKey: s9 } = this.layer;
    return t8({ customParameters: t11, timeExtent: o14 }, e7, r12, s9);
  }
  createProcessorSchema(e7, t11, o14) {
    const { fields: s9, renderer: a11, geometryType: i12, labelingInfo: n11, labelsVisible: u12, orderBy: c11, objectIdField: p9 } = this.layer, d10 = { fields: s9.map((e8) => e8.toJSON()), renderer: a11 == null ? void 0 : a11.clone(), featureReduction: e6(this.layer, t11), geometryType: i12, labelingInfo: n11, labelsVisible: u12, objectIdField: p9, orderBy: c11 ?? "default" };
    return o9(e7, t11, d10, o14);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e7) {
    const t11 = this.layer, { renderer: o14, apiKey: s9 } = t11, a11 = this.layer.labelsVisible ? this.layer.labelingInfo : null;
    return { apiKey: s9, customParameters: JSON.stringify(t11.customParameters), featureReduction: e6(t11, e7), labelingInfo: a11, orderBy: JSON.stringify(t11.orderBy), renderer: o14 };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/OrientedImageryLayerAdapter.js
var m10 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, t11 = r9(r12, e7) ?? l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: t11 }];
  }
  async createServiceOptions(t11) {
    var _a;
    const s9 = this.layer, { capabilities: i12, objectIdField: l8, globalIdField: n11, orderBy: p9, refreshInterval: u12 } = s9, d10 = s9.fieldsIndex.toJSON(), c11 = e5(s9), m12 = (_a = s9.timeInfo) == null ? void 0 : _a.toJSON(), f5 = s9.spatialReference.toJSON(), y5 = a(this.layer.parsedUrl);
    let h4 = this.layer.objectIdField;
    if (p9 == null ? void 0 : p9.length) {
      const e7 = !p9[0].valueExpression && p9[0].field;
      e7 && (h4 = e7);
    }
    const b6 = u12 > 0, g4 = !!has("featurelayer-snapshot-enabled") && "point" === s9.geometryType && (i12 == null ? void 0 : i12.query.supportsPagination) && !(i12 == null ? void 0 : i12.operations.supportsEditing) && !b6, S2 = g4 && t9(t11, s9.fullExtent);
    return { type: "feature-service", source: y5, isSourceHosted: g2(y5.path), orderByFields: h4, outSpatialReference: t11.spatialReference.toJSON(), metadata: { globalIdField: n11, fieldsIndex: d10, geometryType: c11, objectIdField: l8, timeInfo: m12, spatialReference: f5, timeReferenceUnknownClient: false, subtypeField: null, subtypes: null, typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i12.query.maxRecordCount, supportsCompactGeometry: i12.query.supportsCompactGeometry, supportsDefaultSpatialReference: i12.query.supportsDefaultSpatialReference, supportsFormatPBF: i12.query.supportsFormatPBF, supportsMaxRecordCountFactor: i12.query.supportsMaxRecordCountFactor, supportsQuantization: i12.query.supportsQuantization, lastEditDate: null, snapshotInfo: { supportsSnapshotMinThreshold: g4, supportsSnapshotMaxThreshold: S2, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e7, r12) {
    const { definitionExpression: t11, customParameters: o14, timeExtent: s9 } = this.layer;
    return t8({ definitionExpression: t11, customParameters: o14, timeExtent: s9 }, e7, r12, null);
  }
  createProcessorSchema(e7, r12, o14) {
    const { fields: s9, renderer: i12, geometryType: a11, labelingInfo: l8, labelsVisible: n11, orderBy: p9, objectIdField: u12 } = this.layer, c11 = { fields: s9.map((e8) => e8.toJSON()), renderer: i12 == null ? void 0 : i12.clone(), featureReduction: e6(this.layer, r12), geometryType: a11, labelingInfo: l8, labelsVisible: n11, objectIdField: u12, orderBy: p9 ?? "default" };
    return o9(e7, r12, c11, o14);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  hasFilters(e7) {
    return o10(this.layer, e7);
  }
  addFilters(e7, r12) {
    return r11(this.layer, e7, r12);
  }
  getUpdateHashProperties(e7) {
    const r12 = this.layer, { definitionExpression: o14, renderer: i12, outFields: a11 } = r12, l8 = this.layer.labelsVisible ? this.layer.labelingInfo : null, n11 = JSON.stringify(r12.customParameters), p9 = e6(r12, e7);
    return { outFields: a11, orderBy: JSON.stringify(r12.orderBy), definitionExpression: o14, renderer: i12, labelingInfo: l8, featureReduction: p9, customParameters: n11, floors: o10(this.layer, e7) ? e7.floors : null };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/ParquetLayerAdapter.js
var o11 = class {
  constructor(e7) {
    this.layer = e7;
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return null;
  }
  getLabelingDeconflictionInfo(e7) {
    const r12 = this.layer, i12 = r9(r12, e7) ?? l4(r12);
    return [{ vvEvaluators: { 0: o6(r12.renderer) }, deconflictionEnabled: i12 }];
  }
  getUpdateHashProperties(r12) {
    const t11 = this.layer, { renderer: l8 } = t11, s9 = this.layer.labelsVisible ? this.layer.labelingInfo : null, i12 = JSON.stringify(t11.customParameters), a11 = e6(t11, r12), o14 = JSON.stringify(t11.orderBy);
    return { outFields: this.layer.outFields, labelingInfo: s9, featureReduction: a11, customParameters: i12, orderBy: o14, renderer: l8 };
  }
  async createServiceOptions(e7) {
    const t11 = e5(this.layer);
    return { type: "parquet", source: { urls: this.layer.urls.items }, outSpatialReference: e7.spatialReference.toJSON(), geometryInfo: this.layer.source.geometryInfo, metadata: { spatialReference: this.layer.spatialReference, fieldsIndex: this.layer.fieldsIndex.toJSON(), objectIdField: this.layer.objectIdField, geometryType: t11, types: null, subtypes: null, timeInfo: null, typeIdField: null, subtypeField: null, globalIdField: null, timeReferenceUnknownClient: null } };
  }
  createSourceSchema(e7, r12) {
    return { type: "parquet", mutable: { sourceRefreshVersion: r12, availableFields: e7.availableFields, dataFilter: { customParameters: this.layer.customParameters ?? null } } };
  }
  createProcessorSchema(r12, t11, l8) {
    var _a;
    const s9 = { fields: this.layer.fields.map((e7) => e7.toJSON()), renderer: (_a = this.layer.renderer) == null ? void 0 : _a.clone(), featureReduction: e6(this.layer, t11), geometryType: this.layer.geometryType, labelingInfo: this.layer.labelingInfo, labelsVisible: this.layer.labelsVisible, objectIdField: this.layer.objectIdField, orderBy: this.layer.orderBy };
    return o9(r12, t11, s9, l8);
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/StreamLayerAdapter.js
var l7 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    const t11 = this.layer, o14 = r9(t11, e7) ?? l4(t11);
    return [{ vvEvaluators: { 0: o6(t11.renderer) }, deconflictionEnabled: o14 }];
  }
  async createServiceOptions(e7) {
    var _a;
    const r12 = this.layer, { objectIdField: i12 } = r12, n11 = e5(r12), o14 = ((_a = r12.timeInfo) == null ? void 0 : _a.toJSON()) || null, s9 = r12.spatialReference ? r12.spatialReference.toJSON() : null;
    return { type: "stream", source: this.layer.parsedUrl, outSpatialReference: e7.spatialReference.toJSON(), metadata: { fieldsIndex: this.layer.fieldsIndex.toJSON(), geometryType: n11, objectIdField: i12, timeInfo: o14, timeReferenceUnknownClient: null, spatialReference: s9, subtypeField: null, subtypes: null, globalIdField: null, typeIdField: null, types: null } };
  }
  createSourceSchema(e7, t11) {
    const { definitionExpression: r12, geometryDefinition: i12, customParameters: n11 } = this.layer;
    return { type: "stream", mutable: { sourceRefreshVersion: t11, availableFields: e7.availableFields, dataFilter: { geometryDefinition: i12 == null ? void 0 : i12.toJSON(), definitionExpression: r12, customParameters: n11 ?? null, maxReconnectionAttempts: this.layer.maxReconnectionAttempts, maxReconnectionInterval: this.layer.maxReconnectionInterval, purgeOptions: this.layer.purgeOptions.toJSON() } } };
  }
  createProcessorSchema(t11, r12, i12) {
    const { fields: n11, renderer: s9, geometryType: l8, labelingInfo: a11, labelsVisible: c11, objectIdField: d10 } = this.layer, m12 = { fields: n11.map((e7) => e7.toJSON()), renderer: s9 == null ? void 0 : s9.clone(), featureReduction: e6(this.layer, r12), geometryType: l8, labelingInfo: a11, labelsVisible: c11, objectIdField: d10, orderBy: "default" };
    return o9(t11, r12, m12, i12);
  }
  get hasRequiredSupport() {
    return m4(this.layer.renderer);
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(t11) {
    const r12 = this.layer, { definitionExpression: i12, renderer: n11 } = r12, o14 = this.layer.labelsVisible ? this.layer.labelingInfo : null, s9 = JSON.stringify(r12.customParameters);
    return { definitionExpression: i12, renderer: n11, labelingInfo: o14, featureReduction: e6(r12, t11), customParameters: s9, geometryDefinition: r12.geometryDefinition, definitionExpressoin: r12.definitionExpression };
  }
};

// node_modules/@arcgis/core/views/2d/layers/features/schema/processor/SubtypeProcessorSchema.js
async function i10(e7, { subtypeField: t11, sublayers: s9 }) {
  const a11 = await Promise.all(s9.map(({ renderer: t12 }) => r10(e7, t12)));
  return { type: "subtype", subtypeField: t11, renderers: s9.reduce((e8, { subtypeCode: r12 }, t12) => ({ ...e8, [r12]: a11[t12] }), {}) };
}
function o12(e7, r12) {
  const s9 = t2();
  return { type: "subtype", filters: e7.filters, capabilities: { maxTextureSize: s9.maxTextureSize }, subtypeField: r12.subtypeField, target: "feature", bindings: r12.sublayers.reduce((e8, { renderer: r13, subtypeCode: s10 }) => {
    const a11 = c2(r13);
    return { ...e8, [s10]: a11 };
  }, {}) };
}
async function u11(r12, { subtypeField: t11, sublayers: a11 }) {
  const i12 = await Promise.all(a11.map((t12) => {
    const a12 = M2(t12.renderer), i13 = { ...t12, geometryType: t12.geometryType ?? null };
    return l5(r12, i13, a12);
  }));
  return { type: "subtype", subtypeField: t11, renderers: a11.reduce((e7, { subtypeCode: r13 }, t12) => ({ ...e7, [r13]: i12[t12] }), {}) };
}
async function n9(e7, r12, t11, s9) {
  return { storage: o12(r12, t11), mesh: { properties: { timeZone: r12.timeZone, displayRefreshVersion: s9, returnMeshObjectId: false, sortKey: null }, strategy: { type: "feature" }, factory: { symbology: await i10(e7, t11), labels: await u11(e7, t11) } } };
}

// node_modules/@arcgis/core/views/2d/layers/features/layerAdapters/SubtypeGroupLayerAdapter.js
var m11 = class {
  constructor(e7) {
    this.layer = e7;
  }
  getLabelingDeconflictionInfo(e7) {
    return [{ vvEvaluators: {}, deconflictionEnabled: this.layer.sublayers.every((e8) => l4(e8)) }];
  }
  async createServiceOptions(t11) {
    var _a, _b, _c;
    const r12 = this.layer, { capabilities: i12, datesInUnknownTimezone: a11, editingInfo: l8, globalIdField: p9, objectIdField: u12, refreshInterval: y5, subtypeField: m12 } = r12, c11 = r12.fieldsIndex.toJSON(), d10 = e5(r12), h4 = (_a = r12.timeInfo) == null ? void 0 : _a.toJSON(), f5 = r12.spatialReference.toJSON(), b6 = a(this.layer.parsedUrl), g4 = u12, S2 = !(null != (l8 == null ? void 0 : l8.lastEditDate)) && y5 > 0, F3 = !!has("featurelayer-snapshot-enabled") && "point" === r12.geometryType && (i12 == null ? void 0 : i12.query.supportsPagination) && !(i12 == null ? void 0 : i12.operations.supportsEditing) && !S2, x4 = F3 && t9(t11, r12.fullExtent);
    return { type: "feature-service", source: b6, isSourceHosted: g2(b6.path), orderByFields: g4, outSpatialReference: t11.spatialReference.toJSON(), metadata: { timeReferenceUnknownClient: a11, subtypeField: m12, globalIdField: p9, fieldsIndex: c11, geometryType: d10, objectIdField: u12, timeInfo: h4, spatialReference: f5, subtypes: (_b = this.layer.subtypes) == null ? void 0 : _b.map((e7) => e7.toJSON()), typeIdField: null, types: null }, queryMetadata: { maxRecordCount: i12.query.maxRecordCount, supportsCompactGeometry: i12.query.supportsCompactGeometry, supportsDefaultSpatialReference: i12.query.supportsDefaultSpatialReference, supportsFormatPBF: i12.query.supportsFormatPBF, supportsMaxRecordCountFactor: i12.query.supportsMaxRecordCountFactor, supportsQuantization: i12.query.supportsQuantization, lastEditDate: (_c = l8 == null ? void 0 : l8.lastEditDate) == null ? void 0 : _c.getTime(), snapshotInfo: { supportsSnapshotMinThreshold: F3, supportsSnapshotMaxThreshold: x4, snapshotCountThresholds: { min: has("featurelayer-snapshot-point-min-threshold"), max: has("featurelayer-snapshot-point-max-threshold") } } } };
  }
  createSourceSchema(e7, t11) {
    const { definitionExpression: r12, customParameters: s9, gdbVersion: i12, historicMoment: o14, subtypeField: a11, timeExtent: l8, apiKey: n11 } = this.layer, p9 = { queryScaleRanges: this.layer.sublayers.items.map((e8) => ({ subtypeCode: e8.subtypeCode, minScale: e8.minScale, maxScale: e8.maxScale })), definitionExpression: r12, customParameters: s9, gdbVersion: i12, historicMoment: o14, subtypeField: a11, timeExtent: l8 };
    return t8(p9, e7, t11, n11);
  }
  createProcessorSchema(e7, t11, r12) {
    const s9 = { subtypeField: this.layer.subtypeField, sublayers: Array.from(this.layer.sublayers, (e8) => ({ featureReduction: null, geometryType: this.layer.geometryType, labelingInfo: e8.labelingInfo, labelsVisible: e8.labelsVisible, renderer: e8.renderer, subtypeCode: e8.subtypeCode, orderBy: null })) };
    return n9(e7, t11, s9, r12);
  }
  hasFilters(e7) {
    return o10(this.layer, e7) || c10(this.layer, e7);
  }
  addFilters(e7, t11) {
    e7 = r11(this.layer, e7, t11);
    const s9 = this.layer.sublayers.filter((e8) => !d9(e8, t11)).map((e8) => e8.subtypeCode);
    if (!s9.length) return e7;
    e7 ?? (e7 = new d6());
    const o14 = `NOT ${this.layer.subtypeField} IN (${s9.join(",")})`;
    return e7.where = n2(e7.where, o14), e7;
  }
  get hasRequiredSupport() {
    return true;
  }
  get timeOptions() {
    return this.layer;
  }
  getUpdateHashProperties(e7) {
    var _a;
    const t11 = this.layer, { definitionExpression: r12, gdbVersion: s9, apiKey: i12 } = t11, o14 = ((_a = t11.historicMoment) == null ? void 0 : _a.getTime()) ?? void 0, l8 = JSON.stringify(t11.customParameters), n11 = o10(this.layer, e7) ? e7.floors : null, p9 = this.layer.sublayers.map(({ renderer: e8, labelsVisible: t12, labelingInfo: r13, visible: s10 }) => ({ renderer: e8, labelsVisible: t12, labelingInfo: r13, visible: s10 }));
    return { outFields: this.layer.outFields, gdbVersion: s9, definitionExpression: r12, historicMoment: o14, customParameters: l8, apiKey: i12, sublayers: p9, floors: n11 };
  }
  setGraphicOrigin(e7) {
    const t11 = this.layer.fieldsIndex.get(this.layer.subtypeField), r12 = e7.attributes[t11.name], s9 = this.layer.sublayers.find((e8) => e8.subtypeCode === r12);
    e7.layer = e7.sourceLayer = s9;
  }
};
function c10(e7, t11) {
  return e7.sublayers.some((e8) => !d9(e8, t11));
}
function d9(e7, r12) {
  return e7.visible && (0 === e7.minScale || m2(r12.scale, e7.minScale) || r12.scale < e7.minScale) && (0 === e7.maxScale || m2(r12.scale, e7.maxScale) || r12.scale > e7.maxScale);
}

// node_modules/@arcgis/core/views/2d/layers/support/handleNoEngineError.js
async function n10(n11, r12) {
  try {
    return await n11;
  } catch (t11) {
    if ("no-queryEngine" !== t11.name) throw t11;
    return r12;
  }
}

// node_modules/@arcgis/core/views/2d/tiling/FeatureTileSubscriptionManager.js
function s8(e7, s9) {
  const t11 = /* @__PURE__ */ new Set();
  for (const i12 of e7 instanceof Set ? e7.values() : e7.keys()) s9.has(i12) || t11.add(i12);
  return t11;
}
var t10 = class {
  constructor(e7, s9, t11) {
    const i12 = t11 ? e7.getTileCoverage(t11, 0, true, "closest") : null, o14 = e7.getTileCoverage(s9, 0, true, "closest");
    if (this._tileKeys = /* @__PURE__ */ new Map(), i12) for (const n11 of i12.keys()) this._tileKeys.set(n11.id, n11);
    if (o14) for (const n11 of o14.keys()) this._tileKeys.set(n11.id, n11);
  }
  get coverageSet() {
    return new Set(this._tileKeys.keys());
  }
  keys() {
    return this._tileKeys.values();
  }
};
var i11 = class {
  constructor(e7) {
    this.version = e7;
  }
};
var o13 = class {
  constructor(e7) {
    this._subscriptions = /* @__PURE__ */ new Map(), this._visible = /* @__PURE__ */ new Set(), this._paused = /* @__PURE__ */ new Set(), this._version = 0, this._config = e7;
  }
  destroy() {
  }
  get _coverageSet() {
    var _a;
    return ((_a = this._coverage) == null ? void 0 : _a.coverageSet) ?? /* @__PURE__ */ new Set();
  }
  suspend() {
    this._suspendedOverage = this._coverage, this._coverage = null, this._updateSubscriptions();
  }
  resume() {
    null == this._coverage && (this._coverage = this._suspendedOverage, this._suspendedOverage = null, this._updateSubscriptions());
  }
  update(e7, s9) {
    return this._version = (this._version + 1) % Number.MAX_SAFE_INTEGER, this._updateCoverage(e7, s9), this._updateSubscriptions(), new Set(this._visible);
  }
  _updateCoverage(e7, s9) {
    this._coverage = new t10(this._config.tileInfoView, e7, s9);
  }
  _updateSubscriptions() {
    const e7 = this._coverageSet, t11 = this._updateVisibility(), o14 = s8(t11, e7), n11 = s8(this._subscriptions, t11), r12 = s8(e7, this._subscriptions), a11 = s8(n11, e7), c11 = s8(o14, a11), u12 = s8(c11, this._paused);
    this._visible = t11;
    for (const s9 of r12.values()) this._subscriptions.set(s9, new i11(this._version));
    for (const s9 of u12.values()) this._paused.add(s9);
    for (const s9 of a11.values()) this._subscriptions.delete(s9), this._paused.delete(s9);
    (r12.size || a11.size || u12.size) && this._sendUpdateSubscriptions(r12, a11, u12);
  }
  _sendUpdateSubscriptions(e7, s9, t11) {
    const i12 = Array.from(e7.values()).map((e8) => ({ tileId: e8, version: this._subscriptions.get(e8).version }));
    this._config.updateSubscriptions({ subscribe: i12, unsubscribe: Array.from(s9.values()), pause: Array.from(t11.values()) });
  }
  _updateVisibility() {
    const s9 = /* @__PURE__ */ new Set(), t11 = /* @__PURE__ */ new Set();
    if (!this._coverage) return s9;
    for (const e7 of this._coverage.keys()) {
      if (this._config.isDone(e7)) {
        s9.add(e7.id);
        continue;
      }
      if (this._addVisibleParent(s9, t11, e7)) continue;
      this._addVisibleChildren(s9, e7) || s9.add(e7.id);
    }
    const i12 = new e2(0, 0, 0, 0), o14 = new e2(0, 0, 0, 0);
    for (const e7 of t11) {
      i12.id = e7;
      for (const e8 of s9) o14.id = e8, i12.containsChild(o14) && s9.delete(e8);
    }
    return s9;
  }
  _addVisibleParent(s9, t11, i12) {
    let o14 = false;
    for (const n11 of this._visible.values()) {
      new e2(n11).containsChild(i12) && (s9.add(n11), t11.add(n11), o14 = true);
    }
    return o14;
  }
  _addVisibleChildren(s9, t11) {
    let i12 = false;
    for (const o14 of this._visible.values()) {
      const n11 = new e2(o14);
      t11.containsChild(n11) && (s9.add(o14), i12 = true);
    }
    return i12;
  }
};

// node_modules/@arcgis/core/views/layers/FeatureLayerView.js
var _2 = (_3) => {
  let q = class extends _3 {
    constructor(...e7) {
      super(...e7), this._updatingRequiredFieldsPromise = null, this.dataUpdating = false, this.filter = null, this.layer = null, this.requiredFields = [], this.view = null;
    }
    initialize() {
      this.addHandles([d2(() => {
        var _a;
        const e7 = this.layer;
        return [e7 && "elevationInfo" in e7 ? (_a = e7.elevationInfo) == null ? void 0 : _a.featureExpressionInfo : null, e7 && "displayField" in e7 ? e7.displayField : null, e7 && "timeInfo" in e7 && e7.timeInfo, e7 && "renderer" in e7 && e7.renderer, e7 && "labelingInfo" in e7 && e7.labelingInfo, e7 && "floorInfo" in e7 && e7.floorInfo, this.filter, this.featureEffect, this.timeExtent];
      }, () => this._handleRequiredFieldsChange(), A), v(() => {
        var _a;
        return (_a = this.view) == null ? void 0 : _a.floors;
      }, "change", () => this._handleRequiredFieldsChange()), v(() => {
        const e7 = this.layer;
        return e7 && "sublayers" in e7 ? e7.sublayers : null;
      }, "change", () => this._handleRequiredFieldsChange())]);
    }
    get availableFields() {
      if (!this.layer) return [];
      const { layer: e7, layer: { fieldsIndex: t11 }, requiredFields: r12 } = this;
      return "outFields" in e7 && e7.outFields ? I(t11, [...x(t11, e7.outFields), ...r12]) : I(t11, r12);
    }
    get featureEffect() {
      return this.layer && "featureEffect" in this.layer ? this.layer.featureEffect : null;
    }
    set featureEffect(e7) {
      this._override("featureEffect", e7);
    }
    get maximumNumberOfFeatures() {
      return 0;
    }
    set maximumNumberOfFeatures(e7) {
      n.getLogger(this).error("#maximumNumberOfFeatures=", "Setting maximum number of features is not supported");
    }
    get maximumNumberOfFeaturesExceeded() {
      return false;
    }
    highlight(e7) {
      throw new Error("missing implementation");
    }
    createQuery() {
      const e7 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference }, t11 = null != this.filter ? this.filter.createQuery(e7) : new b3(e7);
      if ("floorInfo" in this.layer && this.layer.floorInfo) {
        const e8 = o4(this);
        null != e8 && (t11.where = t11.where ? `(${t11.where}) AND (${e8})` : e8);
      }
      return null != this.timeExtent && (t11.timeExtent = null != t11.timeExtent ? t11.timeExtent.intersection(this.timeExtent) : this.timeExtent.clone()), t11;
    }
    createAggregateQuery() {
      const e7 = { outFields: ["*"], returnGeometry: true, outSpatialReference: this.view.spatialReference };
      return new b3(e7);
    }
    queryFeatures(e7, t11) {
      throw new Error("missing implementation");
    }
    queryObjectIds(e7, t11) {
      throw new Error("missing implementation");
    }
    queryFeatureCount(e7, t11) {
      throw new Error("missing implementation");
    }
    queryExtent(e7, t11) {
      throw new Error("missing implementation");
    }
    async fetchPopupFeaturesFromGraphics(e7, t11) {
      return this._validateFetchPopupFeatures(e7, t11), this._fetchPopupFeatures(e7, t11);
    }
    _loadArcadeModules(e7) {
      var _a;
      return ((_a = e7.expressionInfos) == null ? void 0 : _a.length) || Array.isArray(e7.content) && e7.content.some((e8) => "expression" === e8.type) ? i4() : Promise.resolve();
    }
    _handleRequiredFieldsChange() {
      const e7 = this._updateRequiredFields();
      this._set("_updatingRequiredFieldsPromise", e7), e7.then(() => {
        this._updatingRequiredFieldsPromise === e7 && this._set("_updatingRequiredFieldsPromise", null);
      });
    }
    async _updateRequiredFields() {
      if (!this.layer || !this.view) return;
      const e7 = "3d" === this.view.type, { layer: t11, layer: { fieldsIndex: i12, objectIdField: o14 } } = this, s9 = "renderer" in t11 && t11.renderer, n11 = "orderBy" in t11 && t11.orderBy, l8 = "featureReduction" in t11 ? t11.featureReduction : null, a11 = /* @__PURE__ */ new Set(), u12 = await Promise.allSettled([s9 ? s9.collectRequiredFields(a11, i12) : null, J(a11, t11), e7 && "elevationInfo" in t11 ? v2(a11, t11) : null, null != this.filter ? M(a11, t11, this.filter) : null, e7 || null == this.featureEffect ? null : M(a11, t11, this.featureEffect.filter), !e7 && l8 ? L2(a11, t11, l8) : null, !e7 && n11 ? O2(a11, t11, n11) : null]);
      if ("timeInfo" in t11 && t11.timeInfo && this.timeExtent && b4(a11, t11.fieldsIndex, [t11.timeInfo.startField, t11.timeInfo.endField]), "floorInfo" in t11 && t11.floorInfo && b4(a11, t11.fieldsIndex, [t11.floorInfo.floorField]), "feature" === t11.type && e7 && null != t11.infoFor3D && (null == t11.globalIdField && n.getLogger(this).error("globalIdField missing on 3DObjectFeatureLayer"), b4(a11, t11.fieldsIndex, [t11.globalIdField])), "subtype-group" === t11.type) {
        w3(a11, i12, t11.subtypeField);
        const e8 = t11.sublayers.map((e9) => {
          var _a;
          return Promise.all([(_a = e9.renderer) == null ? void 0 : _a.collectRequiredFields(a11, i12), J(a11, e9)]);
        });
        await Promise.allSettled(e8);
      }
      if ("catalog-footprint" === t11.type && t11.parent) {
        const e8 = t11.parent;
        b4(a11, i12, [e8.itemNameField, e8.itemSourceField, e8.itemTypeField, e8.maxScaleField, e8.minScaleField]);
      }
      for (const d10 of u12) "rejected" === d10.status && n.getLogger(this).error(d10.reason);
      w3(a11, i12, o14), e7 && "displayField" in t11 && t11.displayField && w3(a11, i12, t11.displayField);
      const p9 = Array.from(a11).sort();
      this._set("requiredFields", p9);
    }
    _validateFetchPopupFeatures(e7, r12) {
      if (null != r12) for (const i12 of e7) {
        const e8 = i12.origin && "layer" in i12.origin ? i12.origin.layer : i12.layer;
        if ("popupEnabled" in e8 && !e8.popupEnabled) throw new s("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: e8 });
        if (i12.isAggregate) {
          const r13 = "featureReduction" in e8 ? e8.featureReduction : null;
          if (!(r13 && "popupTemplate" in r13 && r13.popupEnabled && r13.popupTemplate)) throw new s("featurelayerview:fetchPopupFeatures", "Popups are disabled", { layer: e8 });
        } else if ("popupTemplate" in e8) {
          if (!p2(e8, r12)) throw new s("featurelayerview:fetchPopupFeatures", "Layer does not define a popup template", { layer: e8 });
        }
      }
    }
    _popupFeatureHasRequiredFields(e7, t11) {
      return je(t11, e7);
    }
    async _fetchPopupFeatures(e7, t11) {
      var _a;
      const r12 = new Array(e7.length), o14 = /* @__PURE__ */ new Map(), s9 = await this._createPopupQuery(e7.map((e8) => {
        var _a2;
        return ((_a2 = e8.origin) == null ? void 0 : _a2.layer) ?? e8.layer;
      }), t11);
      for (let n11 = 0; n11 < e7.length; n11++) {
        const l8 = e7[n11];
        if (l8.isAggregate) {
          r12[n11] = l8;
          continue;
        }
        const a11 = ((_a = l8.origin) == null ? void 0 : _a.layer) ?? l8.layer;
        if (!a11 || !("popupEnabled" in a11)) continue;
        const u12 = x(this.layer.fieldsIndex, s9.outFields), p9 = p2(a11, t11);
        if (null == p9) continue;
        const d10 = await this._loadArcadeModules(p9);
        s2(t11);
        d10 && d10.arcadeUtils.hasGeometryOperations(p9) || !this._popupFeatureHasRequiredFields(l8, u12) ? o14.set(l8.getObjectId(), { graphic: l8, index: n11 }) : r12[n11] = l8;
      }
      if ("stream" === this.layer.type || "parquet" === this.layer.type || 0 === o14.size) return r12.filter(Boolean);
      s9.objectIds = Array.from(o14.keys());
      try {
        const e8 = await this.layer.queryFeatures(s9, t11);
        for (const t12 of e8.features) {
          const { graphic: { geometry: e9, origin: i12 }, index: s10 } = o14.get(t12.getObjectId());
          t12.geometry || (t12.geometry = e9), t12.origin = i12, r12[s10] = t12;
        }
      } catch {
      }
      return r12.filter(Boolean);
    }
    async _createPopupQuery(e7, t11) {
      const r12 = this.layer.createQuery(), o14 = /* @__PURE__ */ new Set();
      let s9 = false;
      const n11 = e7 ?? [this.layer];
      for (const l8 of n11) {
        if (!("popupEnabled" in l8)) continue;
        const e8 = p2(l8, t11);
        if (null == e8) continue;
        const r13 = await this._loadArcadeModules(e8);
        s2(t11);
        const n12 = r13 && r13.arcadeUtils.hasGeometryOperations(e8);
        s9 = !("point" !== this.layer.geometryType && !n12);
        const a11 = await n4(this.layer, e8);
        s2(t11);
        for (const t12 of a11) o14.add(t12);
      }
      if (r12.returnGeometry = s9, r12.returnZ = s9, r12.returnM = s9, r12.outFields = Array.from(o14), r12.outSpatialReference = this.view.spatialReference, "floorInfo" in this.layer && this.layer.floorInfo) {
        const e8 = o4(this);
        null != e8 && (r12.where = r12.where ? `(${r12.where}) AND (${e8})` : e8);
      }
      return r12;
    }
    canResume() {
      return !!super.canResume() && (null == this.timeExtent || !this.timeExtent.isEmpty);
    }
    getTest() {
    }
    get test() {
    }
  };
  return r([m()], q.prototype, "_updatingRequiredFieldsPromise", void 0), r([m({ readOnly: true })], q.prototype, "availableFields", null), r([m({ readOnly: true })], q.prototype, "dataUpdating", void 0), r([m({ type: w2 })], q.prototype, "featureEffect", null), r([m({ type: d6 })], q.prototype, "filter", void 0), r([m()], q.prototype, "layer", void 0), r([m({ type: Number })], q.prototype, "maximumNumberOfFeatures", null), r([m({ readOnly: true, type: Boolean })], q.prototype, "maximumNumberOfFeaturesExceeded", null), r([m({ readOnly: true })], q.prototype, "requiredFields", void 0), r([m()], q.prototype, "suspended", void 0), r([m()], q.prototype, "view", void 0), q = r([a2("esri.views.layers.FeatureLayerView")], q), q;
};

// node_modules/@arcgis/core/views/2d/layers/FeatureLayerView2D.js
function X(e7, t11) {
  const r12 = /* @__PURE__ */ new Set();
  return e7 && e7.forEach((e8) => r12.add(e8)), t11 && t11.forEach((e8) => r12.add(e8)), r12.has("*") ? ["*"] : Array.from(r12);
}
var Y = 4294967294;
var ee2 = class extends _2(i7(j(y2))) {
  constructor() {
    super(...arguments), this._commandsQueue = new t5({ process: (e7) => {
      switch (e7.type) {
        case "edit-by-feature":
        case "edit-by-id":
          return this._doEdit(e7);
        case "update":
          return this._doUpdate();
        case "highlight":
          return this._updateHighlights();
      }
    } }), this._visibilityOverrides = /* @__PURE__ */ new Set(), this._highlightCounter = new e4(), this._lastAvailableFields = [], this._lastTargetState = null, this.eventLog = new l2(), this._sourceRefreshVersion = 1, this._displayRefreshVersion = 1, this._pipelineUpdating = false, this._fields = null, this.featureEffectView = new r6();
  }
  destroy() {
    var _a;
    (_a = this._workerProxy) == null ? void 0 : _a.destroy(), this._workerAttached.reject(u2()), this._commandsQueue.destroy();
  }
  initialize() {
    this._workerAttached = L(), d(this._workerAttached.promise), this.addResolvingPromise(this._initProxy()), this.featureEffectView.featureEffect = this.featureEffect, this.featureEffectView.endTransition();
  }
  async _initProxy() {
    var _a;
    const e7 = this.layer;
    if ("isTable" in e7 && e7.isTable) throw new s("featurelayerview:table-not-supported", "table feature layer can't be displayed", { layer: e7 });
    if ("mesh" === e7.geometryType) throw new s("featurelayerview:geometry-type-not-supported", `Geometry type of ${e7.geometryType} is not supported`, { layer: e7 });
    if (("feature" === e7.type || "subtype-group" === e7.type) && false === ((_a = O(e7)) == null ? void 0 : _a.operations.supportsQuery)) throw new s("featurelayerview:query-not-supported", "layer view requires a layer with query capability", { layer: e7 });
    this._workerProxy && this._workerProxy.destroy();
    const t11 = this._createClientOptions();
    this._workerProxy = await t6(t11);
  }
  async _attachProxy() {
    var _a, _b, _c;
    const e7 = { service: await this.layerAdapter.createServiceOptions(this.view), tileInfoJSON: (_c = (_b = (_a = this.view) == null ? void 0 : _a.featuresTilingScheme) == null ? void 0 : _b.tileInfo) == null ? void 0 : _c.toJSON() };
    let t11 = [];
    Array.isArray(e7.service.source) && (t11 = e7.service.source);
    try {
      await this._workerProxy.pipeline.onAttach(e7, { transferList: t11 }), this._workerAttached.resolve();
    } catch (r12) {
      this._workerAttached.reject(u2()), f(r12);
    }
  }
  async _detachProxy() {
    return this._workerProxy.pipeline.onDetach();
  }
  async getWorker() {
    return await this._workerAttached.promise, this._workerProxy;
  }
  get hasAllFeatures() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllFeatures;
  }
  get hasAllFeaturesInView() {
    return this.layer.visible && !this.suspended && this.eventLog.hasAllFeaturesInView;
  }
  get hasFullGeometries() {
    return this.layer.visible && !this.suspended && this.eventLog.hasFullGeometries;
  }
  get labelingCollisionInfos() {
    const e7 = this.layerAdapter.getLabelingDeconflictionInfo(this.view), t11 = this.layer.geometryType, r12 = !this.suspended;
    return e7.map(({ vvEvaluators: e8, deconflictionEnabled: i12 }) => ({ container: this.featureContainer, vvEvaluators: e8, deconflictionEnabled: i12, geometryType: t11, visible: r12 }));
  }
  get layerAdapter() {
    switch (this.layer.type) {
      case "feature":
        return "memory" === this.layer.source.type ? new p8(this.layer) : new c9(this.layer);
      case "geojson":
      case "csv":
      case "wfs":
        return new p8(this.layer);
      case "parquet":
        return new o11(this.layer);
      case "subtype-group":
        return new m11(this.layer);
      case "ogc-feature":
        return new u10(this.layer);
      case "stream":
        return new l7(this.layer);
      case "oriented-imagery":
        return new m10(this.layer);
      case "knowledge-graph-sublayer":
        return new a10(this.layer);
      case "catalog-footprint":
        return new l6(this.layer);
      default:
        n3(this.layer);
    }
    return null;
  }
  get timeExtent() {
    var _a;
    return i8(this.layerAdapter.timeOptions, (_a = this.view) == null ? void 0 : _a.timeExtent, this._get("timeExtent"));
  }
  getDisplayStatistics(e7, t11) {
    var _a;
    return (_a = this.featureContainer) == null ? void 0 : _a.getDisplayStatistics(e7, t11);
  }
  async queryHeatmapStatistics(e7) {
    return (await this.getWorker()).pipeline.queryHeatmapStatistics(e7);
  }
  highlight(e7, t11 = "default") {
    let a11;
    e7 instanceof d4 ? a11 = [e7.getObjectId()] : "number" == typeof e7 || "string" == typeof e7 ? a11 = [e7] : V.isCollection(e7) && e7.length > 0 ? a11 = e7.map((e8) => e8 == null ? void 0 : e8.getObjectId()).toArray() : Array.isArray(e7) && e7.length > 0 && (a11 = "number" == typeof e7[0] || "string" == typeof e7[0] ? e7 : e7.map((e8) => e8 == null ? void 0 : e8.getObjectId()));
    const o14 = a11 == null ? void 0 : a11.filter(F);
    return (o14 == null ? void 0 : o14.length) ? (this._addHighlights(o14, t11), e(() => this._removeHighlights(o14, t11))) : e();
  }
  getHighlightIds() {
    return Array.from(this._highlightCounter.ids());
  }
  hasHighlight() {
    return !this._highlightCounter.empty;
  }
  async hitTest(e7, i12) {
    const s9 = await this.featureContainer.hitTest(i12);
    if (0 === s9.length) return null;
    const a11 = await this.getWorker(), { features: o14, aggregates: n11 } = await a11.pipeline.getDisplayFeatures(s9), u12 = this.featureContainer.getSortKeys(s9), l8 = ({ displayId: e8 }, { displayId: t11 }) => u12.has(e8) && u12.has(t11) ? u12.get(e8) - u12.get(t11) : e8 - t11;
    return o14.sort(l8).reverse(), n11.sort(l8).reverse(), [...n11.map((r12) => this._createGraphicHit(e7, s5.fromJSON(r12))), ...o14.map((t11) => this._createGraphicHit(e7, d4.fromJSON(t11)))];
  }
  async queryStatistics() {
    const e7 = await this.getWorker();
    return n10(e7.pipeline.queryStatistics(), { featureCount: 0, ringCount: 0, vertexCount: 0 });
  }
  async querySummaryStatistics(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.features.executeQueryForSummaryStatistics(this._cleanUpQuery(e7), s9, r12);
    return n10(a11, {});
  }
  async queryAggregateSummaryStatistics(e7, t11, r12) {
    const i12 = { ...t11, scale: this.view.scale }, s9 = (await this.getWorker()).aggregates.executeQueryForSummaryStatistics(this._cleanUpAggregateQuery(e7), i12, r12);
    return n10(s9, {});
  }
  async queryUniqueValues(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.features.executeQueryForUniqueValues(this._cleanUpQuery(e7), s9, r12);
    return n10(a11, { uniqueValueInfos: [] });
  }
  async queryAggregateUniqueValues(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.aggregates.executeQueryForUniqueValues(this._cleanUpAggregateQuery(e7), s9, r12);
    return n10(a11, { uniqueValueInfos: [] });
  }
  async queryClassBreaks(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.features.executeQueryForClassBreaks(this._cleanUpQuery(e7), s9, r12);
    return n10(a11, { classBreakInfos: [] });
  }
  async queryAggregateClassBreaks(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.aggregates.executeQueryForClassBreaks(this._cleanUpAggregateQuery(e7), s9, r12);
    return n10(a11, { classBreakInfos: [] });
  }
  async queryHistogram(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.features.executeQueryForHistogram(this._cleanUpQuery(e7), s9, r12);
    return n10(a11, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  async queryAggregateHistogram(e7, t11, r12) {
    const i12 = await this.getWorker(), s9 = { ...t11, scale: this.view.scale }, a11 = i12.aggregates.executeQueryForHistogram(this._cleanUpAggregateQuery(e7), s9, r12);
    return n10(a11, { bins: [], maxValue: null, minValue: null, normalizationTotal: null });
  }
  queryFeatures(e7, t11) {
    return this.queryFeaturesJSON(e7, t11).then((e8) => {
      const t12 = d5.fromJSON(e8);
      return t12.features.forEach((e9) => this._setLayersForFeature(e9)), t12;
    });
  }
  async queryVisibleFeatures(e7, t11) {
    const r12 = (await this.getWorker()).pipeline.queryVisibleFeatures(this._cleanUpQuery(e7), t11), i12 = await n10(r12, { features: [] }), s9 = d5.fromJSON(i12);
    return s9.features.forEach((e8) => this._setLayersForFeature(e8)), s9;
  }
  async queryAggregates(e7, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e7), t11), i12 = await n10(r12, { features: [] }), s9 = m5.fromJSON(i12);
    return s9.features.forEach((e8) => this._setLayersForFeature(e8)), s9;
  }
  async queryAggregateIds(e7, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForIds(this._cleanUpAggregateQuery(e7), t11);
    return n10(r12, []);
  }
  async queryAggregateCount(e7, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQueryForCount(this._cleanUpAggregateQuery(e7), t11);
    return n10(r12, 0);
  }
  async queryAggregateJSON(e7, t11) {
    const r12 = (await this.getWorker()).aggregates.executeQuery(this._cleanUpAggregateQuery(e7), t11);
    return n10(r12, { features: [] });
  }
  async queryFeaturesJSON(e7, t11) {
    const r12 = (await this.getWorker()).features.executeQuery(this._cleanUpQuery(e7), t11);
    return n10(r12, { features: [] });
  }
  async queryObjectIds(e7, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForIds(this._cleanUpQuery(e7), t11);
    return n10(r12, []);
  }
  async queryFeatureCount(e7, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForCount(this._cleanUpQuery(e7), t11);
    return n10(r12, 0);
  }
  async queryExtent(e7, t11) {
    const r12 = (await this.getWorker()).features.executeQueryForExtent(this._cleanUpQuery(e7), t11), i12 = await n10(r12, { count: 0, extent: null });
    return { count: i12.count, extent: w.fromJSON(i12.extent) };
  }
  async getSampleFeatures(e7) {
    return (await this.getWorker()).pipeline.getSampleFeatures(e7);
  }
  setVisibility(e7, t11) {
    t11 ? this._visibilityOverrides.delete(e7) : this._visibilityOverrides.add(e7), this._update();
  }
  update(e7) {
    if (!this._subscriptionManager) return;
    this.view.animation && !this._lastTargetState && (this._lastTargetState = e7.state.clone()), !this.view.animation && this._lastTargetState && (this._lastTargetState = null);
    const t11 = this._subscriptionManager.update(e7.targetState, this._lastTargetState);
    this.featureContainer.setVisibleTiles(t11);
  }
  attach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.attach"), d(this._updatingHandles.addPromise(this._workerAttached.promise)), d(this._attachProxy()), this.featureContainer = new p4(this), this.container.addChild(this.featureContainer), this.view.timeline.record(`${this.layer.title} (FeatureLayer) Attach`), this._subscriptionManager = new o13({ tileInfoView: this.view.featuresTilingScheme, updateSubscriptions: (e7) => {
      this.featureContainer.updateSubscriptions(e7), d(this._updatingHandles.addPromise(this.getWorker().then((t11) => t11.pipeline.updateSubscriptions(e7))));
    }, isDone: (e7) => this.featureContainer.isDone(e7) }), this.requestUpdate(), this.addAttachHandles([d2(() => JSON.stringify({ displayRefreshVersion: this._displayRefreshVersion, timeExtent: this.timeExtent, clips: this.clips, filter: this.filter, featureEffect: this.featureEffect, sourceRefreshVersion: this._sourceRefreshVersion, timeZone: this.view.timeZone, effect: this.featureEffect, ...this.layerAdapter.getUpdateHashProperties(this.view) }), () => this._update(), P), d2(() => this.updateSuspended, (e7) => {
      e7 || (this._subscriptionManager.resume(), this.view.labelManager.requestUpdate());
    }), d2(() => this.visible, (e7) => {
      this.view.labelManager.requestUpdate();
    })]), "stream" !== this.layer.type && "parquet" !== this.layer.type && "catalog-footprint" !== this.layer.type && this.addAttachHandles(this.layer.on("edits", (e7) => this._edit(e7)));
  }
  detach() {
    has("esri-2d-update-debug") && console.debug("FeatureLayerView2D.detach"), this._detachProxy(), this._fields = null, this.featureContainer.destroy(), this.featureContainer = null, this._commandsQueue.clear(), this.container.removeAllChildren(), this._subscriptionManager = u(this._subscriptionManager), this._workerProxy.pipeline.onDetach(), this._workerAttached = L(), d(this._workerAttached.promise), this._lastAvailableFields = [], this._lastSchema = null;
  }
  viewChange() {
    this.requestUpdate();
  }
  moveEnd() {
    this.requestUpdate();
  }
  isUpdating() {
    const e7 = "renderer" in this.layer && null != this.layer.renderer, t11 = this._commandsQueue.updateTracking.updating, r12 = null != this._updatingRequiredFieldsPromise, i12 = this.featureContainer.updatingHandles.updating, s9 = this.updateRequested || e7 && (t11 || r12) || i12 || this._pipelineUpdating || this.dataUpdating;
    if (has("esri-2d-log-updating")) {
      console.log(`Updating FLV2D (${this.layer.id}): ${s9}
  -> updateRequested ${this.updateRequested}
  -> hasRenderer ${e7}
  -> updatingRequiredFields ${r12}
  -> hasPendingCommand ${t11}
  -> dataUpdating ${this.dataUpdating}
  -> processing ${this._pipelineUpdating}
  -> updatingContainer ${i12}
`);
      for (const e8 of this.featureContainer.subscriptions()) console.log(`    -> Tile[${e8.id}] Done: ${e8.done}`);
    }
    return s9;
  }
  _createClientOptions() {
    const e7 = this;
    return { get container() {
      return e7.featureContainer;
    }, setUpdating: (e8) => {
      this._set("_pipelineUpdating", e8.pipeline), this._set("dataUpdating", e8.data);
    }, emitEvent: (e8) => {
      this.emit(e8.name, e8.event);
    }, get eventLog() {
      return e7.eventLog;
    }, fetch: (t11) => Promise.all(t11.map((t12) => e7.view.stage.painter.textureManager.rasterizeItem(t12))), fetchDictionary: (e8) => Promise.all(e8.map((e9) => this._fetchDictionaryRequest(e9))) };
  }
  async _fetchDictionaryRequest(e7) {
    try {
      if ("subtype-group" === this.layer.type) throw new Error("InternalError: SubtypeGroupLayer does not support dictionary renderer");
      const t11 = this.layer.renderer;
      if (!t11 || "dictionary" !== t11.type) throw new Error("InternalError: Expected layer to have a DictionaryRenderer");
      const r12 = this._lastSchema.processor.mesh.factory.symbology;
      if ("dictionary" !== r12.type) throw new Error("InternalError: Expected schema to be of type 'dictionary'");
      const i12 = { cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, store: this.featureContainer.instanceStore, scaleExpression: r12.scaleExpression };
      this._fields || (this._fields = this.layer.fields.map((e8) => e8.toJSON()));
      const s9 = r12.visualVariableUniforms, a11 = await t11.getSymbolAsync(e7.feature, { fields: this._fields });
      if (!a11 || !a11.data) return { type: "dictionary-response", meshes: [] };
      return { type: "dictionary-response", meshes: await c(a11.data, { uniforms: s9, path: "renderer", schemaOptions: i12 }) };
    } catch (t11) {
      return { type: "dictionary-response", meshes: [] };
    }
  }
  _cleanUpQuery(e7) {
    const t11 = b3.from(e7) || this.createQuery();
    return t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference), t11.toJSON();
  }
  _cleanUpAggregateQuery(e7) {
    const t11 = b3.from(e7) || this.createAggregateQuery();
    t11.outSpatialReference || (t11.outSpatialReference = this.view.spatialReference);
    const r12 = t11.objectIds ?? [];
    for (const i12 of t11.aggregateIds ?? []) r12.push(i12);
    return t11.objectIds = r12, t11.aggregateIds = [], t11.toJSON();
  }
  async _update() {
    return this._commandsQueue.push({ type: "update" });
  }
  async _edit(e7) {
    if (this.updateSuspended) return void this._subscriptionManager.suspend();
    const t11 = this._getEffectiveEdit(e7);
    return t11 ? this._commandsQueue.push(t11).catch(f) : void 0;
  }
  async doRefresh(e7) {
    this.attached && (this.updateSuspended && e7 || (e7 ? this.incrementSourceRefreshVersion() : this.incrementDisplayRefreshVersion()));
  }
  incrementSourceRefreshVersion() {
    this._sourceRefreshVersion = (this._sourceRefreshVersion + 1) % Y + 1;
  }
  incrementDisplayRefreshVersion() {
    this._displayRefreshVersion = (this._displayRefreshVersion + 1) % Y + 1;
  }
  _getEffectiveEdit(e7) {
    var _a, _b;
    const t11 = "globalIdField" in this.layer && this.layer.globalIdField, r12 = e7.deletedFeatures.some((e8) => -1 === e8.objectId || !e8.objectId), i12 = t11 && this.availableFields.includes(t11);
    if (r12 && !i12) return n.getLogger(this).error(new s("mapview-apply-edits", `Editing the specified service requires the layer's globalIdField, ${t11} to be included the layer's outFields for updates to be reflected on the map`)), null;
    const s9 = this.layer, a11 = ((_a = e7.historicMoment) == null ? void 0 : _a.getTime()) ?? null, n11 = "layerId" in s9 && ((_b = e7.editedFeatures) == null ? void 0 : _b.find((e8) => e8.layerId === s9.layerId));
    if (n11 && this._canEditByFeature(n11)) {
      const e8 = false, r13 = false, i13 = r5(this.layer.geometryType), { adds: s10, deletes: o14, updates: u12 } = n11.editedFeatures, l8 = this.layer.objectIdField, h4 = s10.map((t12) => tt(t12, i13, e8, r13)), c11 = u12.map((t12) => tt(t12.current, i13, e8, r13));
      return { type: "edit-by-feature", added: h4, removed: o14.map((e9) => "attributes" in e9 ? { globalId: t11 ? e9.attributes[t11] : null, objectId: l8 ? e9.attributes[l8] : null } : e9), updated: c11, historicMoment: a11 };
    }
    return { type: "edit-by-id", added: e7.addedFeatures, updated: e7.updatedFeatures, removed: e7.deletedFeatures, historicMoment: a11 };
  }
  _canEditByFeature(e7) {
    const { adds: t11, updates: r12 } = e7.editedFeatures;
    return t11.every((e8) => {
      var _a;
      return this.view.spatialReference.equals((_a = e8.geometry) == null ? void 0 : _a.spatialReference);
    }) && r12.every((e8) => {
      var _a;
      return this.view.spatialReference.equals((_a = e8.current.geometry) == null ? void 0 : _a.spatialReference);
    });
  }
  async _doUpdate() {
    var _a, _b, _c, _d;
    "featureReduction" in this.layer && this.layer.featureReduction && this.layer.featureReduction !== this._lastFeatureReduction && (this.layer.featureReduction = (_a = this.layer.featureReduction) == null ? void 0 : _a.clone(), this._lastFeatureReduction = this.layer.featureReduction);
    try {
      if (await this._updateRequiredFields(), this.destroyed || !((_b = this.layerAdapter) == null ? void 0 : _b.hasRequiredSupport) || !this._subscriptionManager) return;
      const e7 = this.featureContainer.instanceStore;
      this.featureContainer.attributeView.lockTextureUploads(), e7.updateStart();
      const t11 = this.featureEffect, r12 = { store: e7, cimAnalyzer: this.view.stage.cimAnalyzer, cimResourceManager: this.view.stage.painter.textureManager.resourceManager, scaleExpression: void 0 }, i12 = this._createViewSchemaConfig(), s9 = { source: this.layerAdapter.createSourceSchema(i12, this._sourceRefreshVersion), processor: await this.layerAdapter.createProcessorSchema(r12, i12, this._displayRefreshVersion) }, a11 = i((_c = this._lastSchema) == null ? void 0 : _c.source.mutable, s9.source.mutable) || i((_d = this._lastSchema) == null ? void 0 : _d.processor, s9.processor);
      if (!a11) return this.featureContainer.requestRender(), this.featureContainer.attributeView.unlockTextureUploads(), e7.updateEnd(), void (this.featureEffectView.featureEffect = t11);
      this._lastSchema = s9, this._fields = null;
      const o14 = Math.round(performance.now());
      has("esri-2d-update-debug") && console.debug(`Id[${this.layer.uid}] Version[${o14}] FeatureLayerView2D._doUpdate`, { changes: a11 });
      const n11 = await this.getWorker();
      await n11.pipeline.updateSchema(s9, o14), e7.updateEnd(), this.featureEffectView.featureEffect = t11, this.featureEffectView.endTransition(), this.featureContainer.restartAllAnimations(), this.featureContainer.attributeView.unlockTextureUploads(), this.featureContainer.swapRenderState(), this.featureContainer.requestRender(), has("esri-2d-update-debug") && console.debug(`Version[${o14}] FeatureLayerView2D.updateEnd`), this.requestUpdate();
    } catch (e7) {
      has("esri-2d-update-debug") && console.error("Encountered an error during update", e7);
    }
  }
  async _doEdit(e7) {
    const t11 = await this.getWorker();
    try {
      this.featureContainer.editStart(), await t11.pipeline.onEdits(e7), this.featureContainer.editEnd();
    } catch (r12) {
      b(r12), 0;
    }
  }
  get hasFilter() {
    var _a, _b;
    const e7 = ((_b = (_a = this.layerAdapter).hasFilters) == null ? void 0 : _b.call(_a, this.view)) ?? false;
    return null != this.filter || null != this.timeExtent || this._visibilityOverrides.size > 0 || e7;
  }
  _getEffectiveAvailableFields(e7) {
    const t11 = X(this._lastAvailableFields, e7);
    return this._lastAvailableFields = t11, T(this.layer.fieldsIndex, t11);
  }
  _createViewSchemaConfig() {
    var _a, _b;
    const e7 = [te(this.view, this.layerAdapter, this.timeExtent, this._visibilityOverrides, this.filter), ((_b = (_a = this.featureEffect) == null ? void 0 : _a.filter) == null ? void 0 : _b.toJSON()) ?? null];
    return { availableFields: this._getEffectiveAvailableFields(this.availableFields), filters: e7, scale: this.view.scale, timeZone: this.view.timeZone };
  }
  _addHighlights(e7, t11) {
    this._highlightCounter.addGroup(e7, t11), this._commandsQueue.push({ type: "highlight" });
  }
  _removeHighlights(e7, t11) {
    this._highlightCounter.deleteGroup(e7, t11), this._commandsQueue.push({ type: "highlight" });
  }
  async _updateHighlights() {
    const e7 = [];
    for (const i12 of this._highlightCounter.ids()) {
      const t12 = this._highlightCounter.getHighlightGroups(i12), r13 = this._getHighlightBits(t12);
      e7.push({ objectId: i12, highlightFlags: r13 });
    }
    const t11 = await this.getWorker();
    if (this.destroyed) return;
    const r12 = t11.pipeline.updateHighlight({ highlights: e7 }).catch((e8) => {
      b(e8) || n.getLogger(this).error(e8);
    });
    this._updatingHandles.addPromise(r12);
  }
  _setLayersForFeature(e7) {
    e7.layer = e7.sourceLayer = this.layer, this.layerAdapter.setGraphicOrigin && this.layerAdapter.setGraphicOrigin(e7);
  }
  _createGraphicHit(e7, t11) {
    return this._setLayersForFeature(t11), null != t11.geometry && (t11.geometry.spatialReference = this.view.spatialReference), { type: "graphic", graphic: t11, layer: this.layer, mapPoint: e7 };
  }
};
function te(e7, t11, r12, i12, s9) {
  var _a;
  s9 && (s9 = s9.clone());
  const a11 = null != s9 ? s9.timeExtent : null, o14 = null != r12 && null != a11 ? r12.intersection(a11) : r12 || a11;
  o14 && (s9 ?? (s9 = new d6()), s9.timeExtent = o14), s9 = ((_a = t11.addFilters) == null ? void 0 : _a.call(t11, s9, e7)) ?? s9;
  let n11 = (s9 == null ? void 0 : s9.toJSON()) ?? null;
  return i12.size && (n11 ?? (n11 = new d6().toJSON()), n11.hiddenIds = Array.from(i12)), n11;
}
r([m()], ee2.prototype, "_commandsQueue", void 0), r([m()], ee2.prototype, "_sourceRefreshVersion", void 0), r([m()], ee2.prototype, "_displayRefreshVersion", void 0), r([m({ readOnly: true })], ee2.prototype, "_pipelineUpdating", void 0), r([m({ readOnly: true })], ee2.prototype, "hasAllFeatures", null), r([m({ readOnly: true })], ee2.prototype, "hasAllFeaturesInView", null), r([m({ readOnly: true })], ee2.prototype, "hasFullGeometries", null), r([m()], ee2.prototype, "featureEffectView", void 0), r([m()], ee2.prototype, "labelingCollisionInfos", null), r([m()], ee2.prototype, "layerAdapter", null), r([m({ readOnly: true })], ee2.prototype, "timeExtent", null), r([m()], ee2.prototype, "updating", void 0), ee2 = r([a2("esri.views.2d.layers.FeatureLayerView2D")], ee2);
var re = ee2;

export {
  n10 as n,
  re
};
//# sourceMappingURL=chunk-EXBCV6ZO.js.map
