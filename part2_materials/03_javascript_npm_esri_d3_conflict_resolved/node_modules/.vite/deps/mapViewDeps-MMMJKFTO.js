import {
  i as i9,
  s as s9
} from "./chunk-UKNTO5OD.js";
import {
  R as R2,
  y as y5
} from "./chunk-5TIXULY3.js";
import {
  f as f5
} from "./chunk-B6UR6G45.js";
import {
  o as o9,
  y as y3
} from "./chunk-EAYFTXNC.js";
import {
  a as a4,
  c as c3,
  h as h4,
  m as m4,
  u as u8
} from "./chunk-SK5QCHZZ.js";
import {
  t as t15
} from "./chunk-VKINFEL6.js";
import {
  n as n6
} from "./chunk-DVRUAVBV.js";
import {
  D as D3,
  E as E5,
  S as S2,
  a as a5,
  e as e11,
  n as n9,
  r as r6,
  r2 as r7,
  t as t14,
  v,
  y as y4
} from "./chunk-UCJNTTSW.js";
import "./chunk-2JJO7SCG.js";
import "./chunk-OHKRFTGD.js";
import {
  F as F3
} from "./chunk-4BM4QPL6.js";
import "./chunk-LAXNQQQH.js";
import {
  j as j5,
  o as o11,
  t as t8,
  t2 as t11,
  t3 as t12,
  w as w3
} from "./chunk-5PECYTTZ.js";
import "./chunk-ZGL6Q57M.js";
import {
  e as e10,
  i as i8,
  n as n8,
  t2 as t9,
  t3 as t10
} from "./chunk-KDQTUT24.js";
import {
  e as e9,
  n as n7
} from "./chunk-TZAPBN5J.js";
import {
  e as e7,
  e2 as e8
} from "./chunk-FKL5AVF4.js";
import {
  i as i7
} from "./chunk-RPZ6EPIC.js";
import {
  o as o8
} from "./chunk-G7VPHLH2.js";
import "./chunk-QLTGZ6EP.js";
import {
  o as o7
} from "./chunk-CKPBZSTT.js";
import {
  t as t7
} from "./chunk-4LE34CVH.js";
import "./chunk-MNEG3JYG.js";
import "./chunk-5CHZW6XY.js";
import "./chunk-BOYBHWD5.js";
import {
  o as o6
} from "./chunk-DLJHW32W.js";
import "./chunk-6LGJYARD.js";
import "./chunk-3T3LUDWR.js";
import {
  L as L4
} from "./chunk-CQZSH27Y.js";
import "./chunk-VBS2Y7KE.js";
import {
  j as j4
} from "./chunk-VWWYTZTJ.js";
import "./chunk-3REIFLHQ.js";
import {
  l as l5
} from "./chunk-BX4DTVY3.js";
import "./chunk-7TPUFUXO.js";
import "./chunk-2O2NCM6Y.js";
import {
  e as e3,
  t2 as t6
} from "./chunk-OXCT6NNS.js";
import "./chunk-J3GKRP7Y.js";
import {
  A as A2,
  j as j3,
  y
} from "./chunk-Q3K5MAUZ.js";
import {
  i as i2,
  s as s7,
  x
} from "./chunk-DPVSO6BH.js";
import {
  e as e4,
  ee,
  i as i4,
  n as n5,
  t as t3,
  t2 as t4
} from "./chunk-5VEO4IUH.js";
import "./chunk-2XVRGGEF.js";
import {
  f as f4,
  u as u7
} from "./chunk-6TRZLPPJ.js";
import {
  E as E3
} from "./chunk-U6IFI7EK.js";
import "./chunk-N42IF4WX.js";
import "./chunk-QJIG5NA3.js";
import "./chunk-MCHNAU6L.js";
import {
  t as t5
} from "./chunk-MYNRH67A.js";
import "./chunk-VAGIPHHR.js";
import "./chunk-JMY2H33H.js";
import "./chunk-U46OHZU7.js";
import "./chunk-MA2KDKKH.js";
import "./chunk-BXIXSFGX.js";
import {
  n as n4
} from "./chunk-556C3V64.js";
import "./chunk-EVK6ZSVY.js";
import "./chunk-YEDSTDY4.js";
import "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import "./chunk-HACIIBEF.js";
import "./chunk-C2RS46RL.js";
import {
  t as t2
} from "./chunk-AHZHHHCW.js";
import "./chunk-BN24XFSK.js";
import {
  y as y2
} from "./chunk-YAGJS3MX.js";
import "./chunk-OC7D2HR4.js";
import {
  c as c2
} from "./chunk-KKH7HGO3.js";
import "./chunk-QYSQ6XPQ.js";
import {
  A as A3,
  D as D2,
  F as F2,
  H,
  I as I4,
  K as K2,
  L as L3,
  N as N2,
  O as O2,
  T as T2,
  U as U4,
  b as b3,
  d as d6,
  f as f3,
  h as h3,
  i as i3,
  o as o5,
  p as p2,
  q,
  u as u6,
  w as w2,
  x as x2,
  z as z2
} from "./chunk-2RIHQI4N.js";
import {
  d as d5,
  i,
  s as s6
} from "./chunk-VLKWWBLY.js";
import "./chunk-NXGNMEHZ.js";
import "./chunk-P2IB5HBH.js";
import "./chunk-CGSFKZP2.js";
import "./chunk-EPAKCM4A.js";
import "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-2U5JYYSG.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import {
  e as e12
} from "./chunk-XSUL7LNZ.js";
import "./chunk-NSVZKQ66.js";
import "./chunk-BZVFVFOB.js";
import "./chunk-7RAZQP6S.js";
import {
  e as e5
} from "./chunk-256XKGQW.js";
import "./chunk-4V237NE5.js";
import {
  A as A4,
  E as E4,
  c2 as c4,
  e as e6,
  o as o10,
  t as t13
} from "./chunk-F3ZOBTPK.js";
import "./chunk-EZCH3ZAJ.js";
import "./chunk-KDUYQUT4.js";
import "./chunk-73FHIZIF.js";
import {
  a as a3,
  c,
  i as i5,
  s as s8
} from "./chunk-ICIPRMPO.js";
import "./chunk-2IVHP3HQ.js";
import {
  i as i6
} from "./chunk-EHD5KM2T.js";
import {
  _
} from "./chunk-G6LMYOSA.js";
import "./chunk-YNC2IEH2.js";
import {
  a2,
  m as m3,
  p
} from "./chunk-QJXYURT2.js";
import {
  Bi,
  C as C2,
  Ci,
  E as E2,
  J,
  S,
  Ti,
  U as U3,
  Ui,
  W,
  X,
  Y,
  ai,
  ei,
  oi,
  si,
  ti,
  u as u5,
  ui
} from "./chunk-CGJUTDVJ.js";
import "./chunk-WC6QRPBL.js";
import {
  M as M2,
  b as b2,
  f as f2,
  h,
  l as l4,
  m as m2
} from "./chunk-D6FJTDNK.js";
import {
  h as h2
} from "./chunk-GYV5TPN6.js";
import {
  r as r4
} from "./chunk-D3FSVA7H.js";
import {
  M,
  P as P2
} from "./chunk-6B4OMNPA.js";
import "./chunk-3GQ4PJDJ.js";
import "./chunk-QEJMJI2R.js";
import {
  B as B3,
  C,
  D,
  E,
  F,
  G,
  I as I3,
  L as L2,
  N,
  O,
  P as P3,
  R,
  T,
  U as U2
} from "./chunk-KV3S4QI2.js";
import {
  n as n3,
  r as r5
} from "./chunk-ECMDQ4LS.js";
import {
  B as B2,
  I as I2,
  l as l3,
  o as o3
} from "./chunk-LP6TMAPE.js";
import {
  o as o4
} from "./chunk-RENLZYKC.js";
import "./chunk-VGE7RXNF.js";
import "./chunk-B3SR7LF7.js";
import "./chunk-2X7T37AY.js";
import "./chunk-2IGXKE5P.js";
import "./chunk-AVBIV2K3.js";
import "./chunk-4NJWIUZG.js";
import "./chunk-F3NUC2RS.js";
import "./chunk-LE3YW4Y3.js";
import "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import "./chunk-NYLBGE62.js";
import "./chunk-QCBTLG25.js";
import "./chunk-ECCHNTW6.js";
import "./chunk-WWNVF22O.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import {
  B,
  K
} from "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import {
  P,
  d as d3
} from "./chunk-W6D3ECTZ.js";
import "./chunk-QXDQJEIU.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import {
  e as e2,
  u as u3
} from "./chunk-YVSEBNS4.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-GNWAZIVF.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import {
  d as d4
} from "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import {
  u as u4
} from "./chunk-2TEGRXBS.js";
import {
  n as n2
} from "./chunk-6Y2LNRVP.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-RCLWOQNR.js";
import {
  o as o2
} from "./chunk-DOTSJZHK.js";
import {
  d as d2
} from "./chunk-UCO66LNK.js";
import "./chunk-5YRJ4YFE.js";
import {
  r as r3,
  s as s5
} from "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  j,
  j2
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import {
  g as g2
} from "./chunk-2WXAPZBK.js";
import {
  I2 as I,
  g,
  s3 as s4,
  z
} from "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import {
  U
} from "./chunk-CRH37WFF.js";
import {
  Pt
} from "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import {
  A,
  r
} from "./chunk-H77COA2S.js";
import "./chunk-7LJCT7EA.js";
import "./chunk-MV5XBD6C.js";
import {
  L,
  b,
  f,
  m,
  o2 as o,
  s as s3,
  t,
  u as u2,
  w
} from "./chunk-GRW2QIBT.js";
import {
  e,
  l as l2,
  r as r2,
  u
} from "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import {
  a,
  l2 as l,
  n2 as n,
  s,
  s2
} from "./chunk-PKLD5YJF.js";
import {
  d,
  has
} from "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/symbols/cim/animationUtils.js
function c5(t22, r11, e15) {
  return { transform: b4(t22, r11, e15.transform), fromColor: P4(t22, r11, e15.fromColor), toColor: g3(t22, r11, e15.toColor), colorMix: I5(t22, r11, e15.colorMix), toOpacity: T3(t22, r11, e15.toOpacity), opacityMix: h5(t22, r11, e15.opacityMix), hasAnimations: e15.hasAnimations || !!r11.animations && r11.animations.length > 0 };
}
function f6(t22) {
  return !t8.forceStaticPath && (t8.forceAnimatedPath || t22.hasAnimations);
}
function p3(r11, e15, n17) {
  if ("CIMCharacterMarker" === e15.type) return n.getLogger("animationUtils").error("#handleMarker()", "CIM character markers do not support animations"), n17;
  const o18 = K2(r11, e15, "OffsetX"), i14 = K2(r11, e15, "OffsetY");
  if ("CIMPictureMarker" === e15.type) return { ...n17, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: D4([o18, i14]), rotation: D4(0), scale: D4(K2(r11, e15, "Size")), parent: n17.transform } };
  const s15 = e15.frame, m6 = s15.ymax - s15.ymin;
  return { ...n17, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: D4([o18, i14]), rotation: D4(0), scale: D4({ type: "Process", op: "Divide", left: K2(r11, e15, "Size"), right: m6 }), parent: n17.transform } };
}
function u9(t22, r11) {
  let e15 = 0, n17 = 0;
  const o18 = "Absolute" !== t22.anchorPointUnits;
  return t22.anchorPoint && (e15 = -t22.anchorPoint.x, n17 = -t22.anchorPoint.y), { ...r11, transform: { type: "AnimatedTransform", relativeTranslation: o18, absoluteScale: false, translation: D4([e15, n17]), rotation: D4(0), scale: D4(1), parent: r11.transform } };
}
function y6(t22, r11) {
  return "Absolute" === t22.anchorPointUnits ? r11 : u9(t22, r11);
}
function C3(t22, r11) {
  return "Absolute" !== t22.anchorPointUnits ? r11 : u9(t22, r11);
}
function M3(t22, r11, e15) {
  return { ...t22, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: D4([r11, e15]), rotation: D4(0), scale: D4(1), parent: t22.transform } };
}
function S3(t22, r11) {
  const e15 = r11 ? 0.5 * -(r11.xmin + r11.xmax) : 0, n17 = r11 ? 0.5 * -(r11.ymin + r11.ymax) : 0;
  let o18 = 0, a13 = 0;
  if ("x" in t22 && "y" in t22) o18 = t22.x + e15, a13 = t22.y + n17;
  else {
    const r12 = m4(t22);
    if (r12) {
      o18 = (r12[0] + r12[2]) / 2 + e15, a13 = (r12[1] + r12[3]) / 2 + n17;
    }
  }
  return [o18, a13];
}
function A5(t22, r11) {
  switch (r11.type) {
    case "CIMPictureMarker":
    case "CIMVectorMarker":
      return K2(t22, r11, "Rotation");
  }
  return 0;
}
function d7(t22, r11) {
  switch (r11.type) {
    case "CIMPointSymbol":
    case "CIMVectorMarker":
      return [1, 1, 1, 1];
    case "CIMSolidStroke":
    case "CIMSolidFill":
      return K2(t22, r11, "Color");
    case "CIMPictureMarker":
    case "CIMPictureStroke":
    case "CIMPictureFill":
      return K2(t22, r11, "TintColor");
  }
  return [1, 1, 1, 1];
}
function b4(t22, r11, e15) {
  return { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: false, translation: O3(t22, r11), rotation: v2(t22, r11), scale: x3(t22, r11), parent: e15 };
}
function P4(t22, r11, e15) {
  return { type: "AnimatedColor", color: D4(d7(t22, r11)), opacity: D4(1), parent: e15 };
}
function g3(t22, r11, e15) {
  const { animations: n17 } = r11;
  let o18 = d7(t22, r11);
  const i14 = n17 == null ? void 0 : n17.filter((t23) => "CIMSymbolAnimationColor" === t23.type)[0];
  return i14 && (o18 = K2(t22, i14, "ToColor")), { type: "AnimatedColor", color: D4(o18), opacity: D4(1), parent: e15 };
}
function I5(t22, r11, e15) {
  const { animations: n17 } = r11, o18 = n17 == null ? void 0 : n17.filter((t23) => "CIMSymbolAnimationColor" === t23.type)[0];
  return o18 ? { type: "AnimatedColor", color: D4([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: k(t22, o18 == null ? void 0 : o18.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : e15;
}
function T3(t22, r11, e15) {
  const { animations: n17 } = r11;
  let o18 = D4(1);
  const i14 = n17 == null ? void 0 : n17.filter((t23) => "CIMSymbolAnimationTransparency" === t23.type)[0];
  if (i14) {
    o18 = D4({ type: "Process", op: "Transparency", value: K2(t22, i14, "ToTransparency") });
  }
  return { type: "AnimatedColor", color: D4([1, 1, 1, 1]), opacity: o18, parent: e15 };
}
function h5(t22, r11, e15) {
  const { animations: n17 } = r11, o18 = n17 == null ? void 0 : n17.filter((t23) => "CIMSymbolAnimationTransparency" === t23.type)[0];
  return o18 ? { type: "AnimatedColor", color: D4([1, 1, 1, 1]), opacity: { from: 0, to: 1, timing: k(t22, o18 == null ? void 0 : o18.animatedSymbolProperties) }, parent: [1, 1, 1, 1] } : e15;
}
function k(t22, r11) {
  if (!r11) return { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t6.Local, repeatType: d5.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 };
  const i14 = K2(t22, r11, "Duration");
  let m6;
  if (K2(t22, r11, "RandomizeStartTime")) {
    m6 = { type: "Process", op: "Random", min: 0, max: i14, seed: K2(t22, r11, "RandomizeStartSeed") };
  } else m6 = K2(t22, r11, "StartTimeOffset");
  const c13 = K2(t22, r11, "RepeatDelay"), f12 = K2(t22, r11, "PlayAnimation"), p7 = K2(t22, r11, "ReverseAnimation"), u15 = h3(r11.repeatType, i3.CIMAnimatedSymbolProperties.repeattype);
  return { duration: i14, startTimeOffset: m6, repeatDelay: c13, timeOriginSelector: u15 === d5.None ? t6.Local : t6.Global, repeatType: u15, easing: h3(r11.easing, i3.CIMAnimatedSymbolProperties.easing), playAnimation: f12, reverseAnimation: p7 };
}
function x3(t22, r11) {
  const { animations: e15 } = r11;
  if ("CIMPictureMarker" !== r11.type && "CIMVectorMarker" !== r11.type && "CIMPointSymbol" !== r11.type) return D4(1);
  let n17;
  n17 = "CIMPictureMarker" === r11.type || "CIMVectorMarker" === r11.type ? K2(t22, r11, "Size") : H(r11) || 10;
  const o18 = e15 == null ? void 0 : e15.filter((t23) => "CIMSymbolAnimationScale" === t23.type)[0];
  if (!o18) {
    const r12 = e15 == null ? void 0 : e15.filter((t23) => "CIMSymbolAnimationSize" === t23.type)[0];
    if (!r12) return D4(1);
    return { from: 1, to: { type: "Process", op: "Divide", left: K2(t22, r12, "ToSize"), right: n17 }, timing: k(t22, r12.animatedSymbolProperties) };
  }
  return { from: 1, to: K2(t22, o18, "ScaleFactor"), timing: k(t22, o18.animatedSymbolProperties) };
}
function O3(t22, r11) {
  const { animations: e15 } = r11, n17 = e15 == null ? void 0 : e15.filter((t23) => "CIMSymbolAnimationOffset" === t23.type)[0];
  if (!n17) return D4([0, 0]);
  return { from: [0, 0], to: [K2(t22, n17, "OffsetX"), K2(t22, n17, "OffsetY")], timing: k(t22, n17.animatedSymbolProperties) };
}
function v2(t22, r11) {
  const { animations: e15 } = r11, n17 = A5(t22, r11), o18 = e15 == null ? void 0 : e15.filter((t23) => "CIMSymbolAnimationRotation" === t23.type)[0];
  if (!o18) return D4(n17);
  return { from: n17, to: K2(t22, o18, "ToRotation"), timing: k(t22, o18.animatedSymbolProperties) };
}
function D4(t22) {
  return { from: t22, to: t22, timing: { duration: 1, startTimeOffset: 0, repeatDelay: 0, timeOriginSelector: t6.Local, repeatType: d5.Loop, easing: s6.Linear, playAnimation: 1, reverseAnimation: 0 } };
}
function L5(t22) {
  if (null == t22) return false;
  if ("object" != typeof t22) return false;
  if (t22.animations && Array.isArray(t22.animations) && t22.animations.length > 0) return true;
  for (const r11 in t22) if (L5(t22[r11])) return true;
  return false;
}

// node_modules/@arcgis/core/symbols/cim/cimAnalyzer.js
var W2 = () => n.getLogger("esri.symbols.cim.cimAnalyzer");
function D5(e15) {
  const r11 = e15.markerPlacement;
  return r11 && r11.angleToLine ? i.MAP : i.SCREEN;
}
var H2 = class {
  constructor(e15) {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [], e15 && (this._resourceManager = e15);
  }
  analyzeSymbolReference(r11, t22, i14) {
    if (this._cimLayers = i14 ?? [], !r11) return this._cimLayers;
    if (this._reset(), r11.primitiveOverrides) {
      this._primitiveOverrides = r11.primitiveOverrides;
      for (const r12 of this._primitiveOverrides) {
        const t23 = r12.valueExpressionInfo;
        if (t23) this._setPoMap(r12.primitiveName, r12.propertyName, t23);
        else if (null != r12.value) {
          let t24 = r12.value;
          r12.propertyName.includes("Color") && (c2(t24) && (t24 = o5(t24)), t24 = f3(t24)), this._setPoMap(r12.primitiveName, r12.propertyName, t24);
        }
      }
    }
    return this._analyzeSymbol(r11.symbol, t22), this._cimLayers;
  }
  _reset() {
    this._cimLayers = [], this._poMap = {}, this._primitiveOverrides = [];
  }
  _analyzeSymbol(e15, r11) {
    switch (e15 == null ? void 0 : e15.type) {
      case "CIMPointSymbol":
      case "CIMLineSymbol":
      case "CIMPolygonSymbol":
        this._analyzeMultiLayerSymbol(e15, r11);
    }
  }
  _analyzeMultiLayerSymbol(e15, r11) {
    const t22 = e15 == null ? void 0 : e15.symbolLayers;
    if (!t22) return;
    const i14 = e15.effects;
    let o18 = i.SCREEN;
    const a13 = H(e15) ?? 0;
    "CIMPointSymbol" === e15.type && "Map" === e15.angleAlignment && (o18 = i.MAP);
    let s15 = { transform: [0, 0, 0, 1], fromColor: [1, 1, 1, 1], toColor: [1, 1, 1, 1], colorMix: [0, 0, 0, 0], toOpacity: [1, 1, 1, 1], opacityMix: [0, 0, 0, 0], hasAnimations: L5(e15) };
    s15 = c5(this._poMap, e15, s15);
    const p7 = "CIMPolygonSymbol" === e15.type;
    let c13 = t22.length;
    for (; c13--; ) {
      const l14 = t22[c13];
      if (!l14 || false === l14.enable) continue;
      let n17;
      (i14 == null ? void 0 : i14.length) && (n17 = [...i14]);
      const m6 = l14.effects;
      (m6 == null ? void 0 : m6.length) && (i14 ? n17.push(...m6) : n17 = [...m6]);
      let y7 = null;
      if (n17) {
        y7 = [];
        for (const e16 of n17) {
          const r12 = y2.findEffectOverrides(e16, this._primitiveOverrides);
          r12 && y7.push(r12);
        }
      }
      const f12 = [];
      switch (y2.findApplicableOverrides(l14, this._primitiveOverrides, f12), l14.type) {
        case "CIMSolidFill":
          this._analyzeSolidFill(l14, y7);
          break;
        case "CIMPictureFill":
          this._analyzePictureFill(l14, y7);
          break;
        case "CIMHatchFill":
          this._analyzeHatchFill(l14, y7);
          break;
        case "CIMGradientFill":
          this._analyzeGradientFill(l14, y7);
          break;
        case "CIMSolidStroke":
          this._analyzeSolidStroke(l14, y7, p7, a13);
          break;
        case "CIMPictureStroke":
          this._analyzePictureStroke(l14, y7, p7, a13);
          break;
        case "CIMGradientStroke":
          this._analyzeGradientStroke(l14, y7, p7, a13);
          break;
        case "CIMCharacterMarker":
        case "CIMPictureMarker":
        case "CIMVectorMarker": {
          "CIMLineSymbol" !== e15.type && "CIMPolygonSymbol" !== e15.type || (o18 = D5(l14));
          const t23 = [], i15 = l14.primitiveName;
          i15 && t23.push(i15);
          const n18 = p7 && I4(l14.markerPlacement);
          this._analyzeMarker(l14, y7, null, t23, o18, a13, r11, [], s15, false, n18);
          break;
        }
        default:
          W2().error("Cannot analyze CIM layer", l14.type);
      }
    }
  }
  _analyzeSolidFill(e15, r11) {
    const { primitiveName: t22, type: i14 } = e15, o18 = f3(e15.color);
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, color: this._getValueOrOverrideExpression(i14, t22, "Color", o18), height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, effects: r11, applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: false });
  }
  _analyzePictureFill(e15, r11) {
    const { primitiveName: t22, type: i14 } = e15, o18 = d6(e15), a13 = p2(e15.height, i3.CIMPictureFill.height);
    let s15 = p2(e15.scaleX, 1);
    if ("width" in e15 && "number" == typeof e15.width) {
      const r12 = e15.width;
      let t23 = 1;
      const i15 = this._resourceManager.getResource(e15.url);
      null != i15 && (t23 = i15.width / i15.height), s15 /= t23 * (a13 / r12);
    }
    const l14 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(t22, i14) };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: l14, colorLocked: !!e15.colorLocked, effects: r11, color: this._getValueOrOverrideExpression(i14, t22, "TintColor", o18), height: this._getValueOrOverrideExpression(i14, t22, "Height", a13), scaleX: this._getValueOrOverrideExpression(i14, t22, "ScaleX", s15), angle: this._getValueOrOverrideExpression(i14, t22, "Rotation", p2(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i14, t22, "OffsetX", p2(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i14, t22, "OffsetY", p2(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeHatchFill(e15, r11) {
    var _a, _b, _c;
    const { primitiveName: t22, type: i14 } = e15, o18 = this._analyzeMaterialOverrides(t22, ["Rotation", "OffsetX", "OffsetY"]), a13 = U4(o18);
    let s15 = [255, 255, 255, 1], l14 = false;
    if ((_a = e15.lineSymbol) == null ? void 0 : _a.symbolLayers) for (const p7 of e15.lineSymbol.symbolLayers) {
      if ("CIMSolidStroke" !== p7.type) continue;
      const e16 = p7.primitiveName ?? t22;
      l14 || !e16 || p7.colorLocked || null == ((_b = this._poMap[e16]) == null ? void 0 : _b.Color) && null == ((_c = this._poMap[e16]) == null ? void 0 : _c.StrokeColor) || (s15 = f3(p7.color), s15 = this._maybeGetValueOrOverrideExpression(e16, "StrokeColor") ?? this._getValueOrOverrideExpression(i14, e16, "Color", s15), l14 = true);
      const r12 = this._maybeGetValueOrOverrideExpression(e16, "StrokeWidth");
      if (r12) {
        let t23 = null, o19 = null;
        "number" == typeof r12 ? t23 = r12 : o19 = r12.valueExpressionInfo;
        let s16 = a13.find((e17) => "strokeWidth" === e17.propertyName);
        s16 ? s16.propertyName = "width" : (s16 = { type: "CIMPrimitiveOverride", primitiveName: e16, propertyName: "width", valueExpressionInfo: o19, value: t23, defaultValue: D2(i14, "width") }, a13.push(s16));
      }
    }
    const n17 = { type: "sprite-rasterization-param", resource: e15, overrides: a13 };
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: n17, colorLocked: !!e15.colorLocked, effects: r11, color: s15, height: this._getValueOrOverrideExpression(i14, t22, "Separation", p2(e15.separation, i3.CIMHatchFill.separation)), scaleX: 1, angle: this._getValueOrOverrideExpression(i14, t22, "Rotation", p2(e15.rotation)), offsetX: this._getValueOrOverrideExpression(i14, t22, "OffsetX", p2(e15.offsetX)), offsetY: this._getValueOrOverrideExpression(i14, t22, "OffsetY", p2(e15.offsetY)), applyRandomOffset: false, sampleAlphaOnly: true, hasUnresolvedReplacementColor: !l14 });
  }
  _analyzeGradientFill(e15, r11) {
    this._cimLayers.push({ type: "fill", spriteRasterizationParam: null, colorLocked: !!e15.colorLocked, effects: r11, color: [128, 128, 128, 1], height: 0, angle: 0, offsetX: 0, offsetY: 0, scaleX: 1, applyRandomOffset: false, sampleAlphaOnly: false, hasUnresolvedReplacementColor: false });
  }
  _analyzeSolidStroke(e15, r11, t22, i14) {
    const { primitiveName: o18, type: a13 } = e15, s15 = f3(e15.color), l14 = p2(e15.width, i3.CIMSolidStroke.width), n17 = b3(e15.capStyle, i3.CIMSolidStroke.capstyle), p7 = b3(e15.joinStyle, i3.CIMSolidStroke.joinstyle), c13 = e15.miterLimit;
    let m6, y7, f12, h13, d11 = [];
    if (this._analyzePrimitiveOverrides(o18, r11, null, null) && (d11 = this._getPrimitiveMaterialOverrides(o18, a13)), r11 && Array.isArray(r11) && r11.length > 0) {
      const e16 = r11[r11.length - 1].effect;
      e16 && "CIMGeometricEffectDashes" === e16.type && "NoConstraint" === e16.lineDashEnding && (m6 = e16.dashTemplate, y7 = e16.scaleDash, f12 = e16.offsetAlongLine, h13 = e16.primitiveName, (r11 = [...r11]).pop());
    }
    null != h13 && d11.push(...this._getPrimitiveMaterialOverrides(h13, a13).filter((e16) => "dashTemplate" === e16.propertyName));
    const u15 = void 0 !== m6 ? { type: "sprite-rasterization-param", resource: { type: "dash", dashTemplate: m6, primitiveName: h13 }, overrides: d11 } : null;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: u15, isOutline: t22, colorLocked: !!e15.colorLocked, effects: r11, color: this._getValueOrOverrideExpression(a13, o18, "Color", s15), width: this._getValueOrOverrideExpression(a13, o18, "Width", l14), cap: this._getValueOrOverrideExpression(a13, o18, "CapStyle", n17), join: this._getValueOrOverrideExpression(a13, o18, "JoinStyle", p7), miterLimit: c13 && this._getValueOrOverrideExpression(a13, o18, "MiterLimit", c13), referenceWidth: i14, zOrder: J2(e15.name), dashTemplate: this._maybeGetValueOrOverrideExpression(h13, "DashTemplate") ?? m6, offsetAlongLine: this._getValueOrOverrideExpression(a13, h13, "OffsetAlongLine", f12 ?? 0), scaleDash: y7, sampleAlphaOnly: true });
  }
  _analyzePictureStroke(e15, r11, t22, i14) {
    const { primitiveName: o18, type: a13 } = e15, s15 = d6(e15), l14 = p2(e15.width, i3.CIMPictureStroke.width), n17 = b3(e15.capStyle, i3.CIMPictureStroke.capstyle), p7 = b3(e15.joinStyle, i3.CIMPictureStroke.joinstyle), c13 = e15.miterLimit, m6 = { type: "sprite-rasterization-param", resource: e15, overrides: this._getPrimitiveMaterialOverrides(o18, a13) };
    this._cimLayers.push({ type: "line", spriteRasterizationParam: m6, isOutline: t22, colorLocked: !!e15.colorLocked, effects: r11, color: this._getValueOrOverrideExpression(a13, o18, "TintColor", s15), width: this._getValueOrOverrideExpression(a13, o18, "Width", l14), cap: this._getValueOrOverrideExpression(a13, o18, "CapStyle", n17), join: this._getValueOrOverrideExpression(a13, o18, "JoinStyle", p7), miterLimit: c13 && this._getValueOrOverrideExpression(a13, o18, "MiterLimit", c13), referenceWidth: i14, zOrder: J2(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeGradientStroke(e15, r11, t22, i14) {
    const { primitiveName: o18, type: a13 } = e15, s15 = p2(e15.width, i3.CIMSolidStroke.width), l14 = b3(e15.capStyle, i3.CIMGradientStroke.capstyle), n17 = b3(e15.joinStyle, i3.CIMGradientStroke.joinstyle), p7 = e15.miterLimit;
    this._cimLayers.push({ type: "line", spriteRasterizationParam: null, isOutline: t22, colorLocked: !!e15.colorLocked, effects: r11, color: [128, 128, 128, 1], width: this._getValueOrOverrideExpression(a13, o18, "Width", s15), cap: this._getValueOrOverrideExpression(a13, o18, "CapStyle", l14), join: this._getValueOrOverrideExpression(a13, o18, "JoinStyle", n17), miterLimit: p7 && this._getValueOrOverrideExpression(a13, o18, "MiterLimit", p7), referenceWidth: i14, zOrder: J2(e15.name), dashTemplate: null, scaleDash: false, sampleAlphaOnly: false });
  }
  _analyzeMarker(e15, r11, t22, i14, o18, a13, s15, l14, y7, f12 = false, h13 = false) {
    if (f12 || (f12 = !!e15.colorLocked), this._analyzeMarkerInsidePolygon(e15, r11, f12)) return;
    const d11 = p2(e15.size, i3.CIMVectorMarker.size), u15 = p2(e15.rotation), O7 = p2(e15.offsetX), _6 = p2(e15.offsetY), { primitiveName: g8, type: S4 } = e15, M6 = this._getValueOrOverrideExpression(S4, g8, "Size", d11), k3 = this._getValueOrOverrideExpression(S4, g8, "Rotation", u15), b6 = this._getValueOrOverrideExpression(S4, g8, "OffsetX", O7), C4 = this._getValueOrOverrideExpression(S4, g8, "OffsetY", _6);
    let P5 = y7;
    switch (P5 = C3(e15, P5), P5 = p3(this._poMap, e15, P5), P5 = y6(e15, P5), P5 = c5(this._poMap, e15, P5), e15.type) {
      case "CIMPictureMarker":
        this._analyzePictureMarker(e15, r11, t22, i14, o18, a13, M6, k3, b6, C4, l14, P5, f12, h13);
        break;
      case "CIMVectorMarker":
        this._analyzeVectorMarker(e15, r11, t22, i14, o18, a13, M6, k3, b6, C4, l14, P5, s15, f12, h13);
    }
  }
  _analyzeMarkerInsidePolygon(e15, r11, t22) {
    const { markerPlacement: i14, type: o18 } = e15;
    if (!i14 || "CIMMarkerPlacementInsidePolygon" !== i14.type) return false;
    if ("CIMVectorMarker" === o18 || "CIMPictureMarker" === o18) {
      const t23 = e15.primitiveName;
      if (t23 && this._analyzePrimitiveOverrides([t23], r11, null, null)) return false;
      const a13 = i14.primitiveName;
      if (a13 && this._analyzePrimitiveOverrides([a13], r11, null, null)) return false;
      if ("CIMVectorMarker" === o18) {
        const { markerGraphics: r12 } = e15;
        if (r12) for (const e16 of r12) {
          const { symbol: r13 } = e16;
          if ("CIMPolygonSymbol" === (r13 == null ? void 0 : r13.type) && r13.symbolLayers) {
            const { symbolLayers: e17 } = r13;
            for (const r14 of e17) if ("CIMSolidStroke" === r14.type) return false;
          }
        }
      } else {
        const { animatedSymbolProperties: r12 } = e15;
        if (r12) return false;
      }
    }
    const s15 = Math.abs(i14.stepX), l14 = Math.abs(i14.stepY);
    if (0 === s15 || 0 === l14) return true;
    let n17, p7;
    if ("Random" === i14.gridType) {
      const e16 = e2(si), r12 = Math.max(Math.floor(e16 / s15), 1);
      n17 = l14 * Math.max(Math.floor(e16 / l14), 1);
      p7 = r12 * s15 / n17;
    } else i14.shiftOddRows ? (n17 = 2 * l14, p7 = s15 / l14 * 0.5) : (n17 = l14, p7 = s15 / l14);
    const c13 = d6(e15), m6 = "CIMCharacterMarker" === e15.type ? null : { type: "sprite-rasterization-param", resource: e15, overrides: [] };
    return this._cimLayers.push({ type: "fill", spriteRasterizationParam: m6, colorLocked: t22, effects: r11, color: c13, height: n17, scaleX: p7, angle: i14.gridAngle, offsetX: p2(i14.offsetX), offsetY: p2(i14.offsetY), applyRandomOffset: "Random" === i14.gridType, sampleAlphaOnly: "CIMPictureMarker" !== e15.type, hasUnresolvedReplacementColor: true }), true;
  }
  _analyzePictureMarker(e15, r11, i14, o18, a13, l14, n17, p7, c13, m6, y7, f12, h13, d11) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const { animatedSymbolProperties: u15, primitiveName: v4, type: O7 } = e15;
    let _6 = p2(e15.scaleX, 1);
    const g8 = d6(e15);
    i14 || (i14 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    const S4 = this._createGIFAnimatedSymbolPropertiesOverrideExpression(u15), M6 = e15.anchorPoint ?? { x: 0, y: 0 };
    if ("width" in e15 && "number" == typeof e15.width) {
      const r12 = e15.width;
      let t22 = 1;
      const i15 = this._resourceManager.getResource(e15.url);
      null != i15 && (t22 = i15.width / i15.height);
      _6 /= t22 * (p2(e15.size) / r12);
    }
    const k3 = [...o18];
    let b6;
    e15.primitiveName && k3.push(e15.primitiveName), u15 || S4 ? b6 = { type: "animated", url: e15.url, urlHash: "H" + l(e15.url), playAnimation: (_a = e15.animatedSymbolProperties) == null ? void 0 : _a.playAnimation, reverseAnimation: (_b = e15.animatedSymbolProperties) == null ? void 0 : _b.reverseAnimation, randomizeStartTime: (_c = e15.animatedSymbolProperties) == null ? void 0 : _c.randomizeStartTime, randomizeStartSeed: (_d = e15.animatedSymbolProperties) == null ? void 0 : _d.randomizeStartSeed, startTimeOffset: (_e = e15.animatedSymbolProperties) == null ? void 0 : _e.startTimeOffset, duration: (_f = e15.animatedSymbolProperties) == null ? void 0 : _f.duration, repeatType: (_g = e15.animatedSymbolProperties) == null ? void 0 : _g.repeatType, repeatDelay: (_h = e15.animatedSymbolProperties) == null ? void 0 : _h.repeatDelay } : (b6 = a(e15), b6.markerPlacement = null);
    const C4 = { type: "sprite-rasterization-param", resource: b6, overrides: this._getMaterialOverrides(k3, O7) };
    S4 && C4.overrides.push(...S4.overrides);
    const P5 = n17;
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: C4, colorLocked: h13, effects: r11, scaleSymbolsProportionally: false, alignment: a13, size: n17, scaleX: this._getValueOrOverrideExpression(O7, v4, "ScaleX", _6), rotation: p7, offsetX: c13, offsetY: m6, transform: { type: "cim-marker-transform-param", params: y7 }, color: this._getValueOrOverrideExpression(O7, v4, "TintColor", g8), anchorPoint: { x: M6.x, y: M6.y }, isAbsoluteAnchorPoint: "Relative" !== e15.anchorPointUnits, outlineColor: [0, 0, 0, 0], outlineWidth: 0, frameHeight: 0, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l14, sizeRatio: 1, isOutline: d11, markerPlacement: i14, animationParams: Z(f12), baseSize: P5 });
  }
  _analyzeVectorMarker(e15, r11, t22, i14, o18, a13, s15, l14, p7, c13, m6, d11, u15, v4, O7) {
    const _6 = e15.markerGraphics;
    if (!_6) return;
    const g8 = e15.frame;
    let S4 = 0;
    S4 = g8 ? g8.ymax - g8.ymin : a13;
    const M6 = !!e15.scaleSymbolsProportionally;
    if (S4) {
      const r12 = { offsetX: p7, offsetY: c13, rotation: l14, size: s15, frameHeight: S4, rotateClockWise: !!e15.rotateClockwise, absoluteAnchorPoint: false, scaleSymbolsProportionally: M6 };
      m6 = [...m6, r12];
    }
    t22 || (t22 = this._createMarkerPlacementOverrideExpression(e15.markerPlacement));
    for (const k3 of _6) if (k3) {
      const s16 = k3.symbol;
      if (!s16) continue;
      const l15 = k3.primitiveName;
      l15 && i14.push(l15);
      let p8, c14 = d11;
      if (("CIMPointSymbol" === s16.type || "CIMTextSymbol" === s16.type) && g8) {
        let r12 = 0, t23 = 0;
        const i15 = k3.geometry;
        "x" in i15 && "y" in i15 && (r12 += i15.x - 0.5 * (g8.xmin + g8.xmax), t23 += i15.y - 0.5 * (g8.ymin + g8.ymax));
        const o19 = e15.anchorPoint;
        let a14 = false;
        o19 && ("Absolute" === e15.anchorPointUnits ? (r12 -= o19.x, t23 -= o19.y, a14 = true) : g8 && (r12 -= (g8.xmax - g8.xmin) * o19.x, t23 -= (g8.ymax - g8.ymin) * o19.y));
        const s17 = { offsetX: r12, offsetY: t23, rotation: 0, size: 0, frameHeight: 0, rotateClockWise: false, absoluteAnchorPoint: a14, scaleSymbolsProportionally: M6 };
        p8 = [...m6, s17];
      }
      const _7 = k3.geometry, [b6, C4] = S3(_7, g8);
      switch (0 === b6 && 0 === C4 || (c14 = M3(c14, b6, C4)), "CIMPointSymbol" === s16.type && (c14 = c5(this._poMap, s16, c14)), s16.type) {
        case "CIMPointSymbol":
        case "CIMLineSymbol":
        case "CIMPolygonSymbol":
          u15 || K3(s16) ? (c14 = { ...c14, transform: { type: "AnimatedTransform", relativeTranslation: false, absoluteScale: true, translation: D4([0, 0]), rotation: D4(0), scale: D4(S4), parent: d11.transform } }, this._analyzeMultiLayerGraphicNonSDF(e15, r11, t22, k3, i14, o18, a13, p8 ?? m6, c14, S4, v4, O7)) : this._analyzeMultiLayerGraphic(e15, r11, t22, k3, i14, o18, a13, p8 ?? m6, c14, S4, v4, O7);
          break;
        case "CIMTextSymbol":
          this._analyzeTextGraphic(r11, t22, k3, i14, o18, a13, p8 ?? m6, v4);
      }
      l15 && i14.pop();
    }
  }
  _analyzeMultiLayerGraphic(e15, r11, t22, i14, o18, a13, s15, l14, p7, c13, m6, y7) {
    const f12 = i14.symbol, h13 = f12.symbolLayers;
    if (!h13) return;
    let u15 = h13.length;
    if (q2(h13) && !f6(p7)) return void this._analyzeCompositeMarkerGraphic(e15, r11, t22, i14, h13, a13, s15, l14, c13, m6, y7);
    const O7 = this._resourceManager.geometryEngine, _6 = l5.applyEffects(f12.effects, i14.geometry, O7);
    if (_6) for (; u15--; ) {
      const f13 = h13[u15];
      if (!f13 || false === f13.enable) continue;
      const d11 = f13.primitiveName;
      switch (d11 && o18.push(d11), f13.type) {
        case "CIMSolidFill":
        case "CIMSolidStroke": {
          const o19 = l5.applyEffects(f13.effects, _6, O7), h14 = m4(o19);
          if (!h14) continue;
          const u16 = "Relative" !== e15.anchorPointUnits, k3 = N2(f13) ?? 0, { frameSizeRatio: C4, anchorX: P5, anchorY: z3, widthRatio: L7, sdfPaddingRatio: I6 } = h4(h14, e15.frame, e15.size, e15.anchorPoint, u16, k3, e15.scaleSymbolsProportionally), E6 = "CIMSolidFill" === f13.type, w5 = { type: "sdf", geom: o19, sdfPaddingRatio: I6, asFill: E6 }, { path: A8 } = f13, G3 = E6 ? f3(T2(f13)) : null == A8 ? f3(A3(f13)) : [0, 0, 0, 0], X2 = E6 ? [0, 0, 0, 0] : f3(A3(f13));
          if (!E6 && !k3) break;
          const F5 = i14.primitiveName;
          let T4 = null;
          E6 && !f13.colorLocked && (T4 = this._maybeGetValueOrOverrideExpression(F5, "FillColor"));
          let j7 = null;
          E6 || f13.colorLocked || (j7 = this._maybeGetValueOrOverrideExpression(F5, "StrokeColor"));
          const W3 = T4 ?? this._getValueOrOverrideExpression(f13.type, d11, "Color", G3), D6 = j7 ?? this._getValueOrOverrideExpression(f13.type, d11, "Color", X2), H3 = this._maybeGetValueOrOverrideExpression(F5, "StrokeWidth") ?? this._getValueOrOverrideExpression(f13.type, d11, "Width", k3), U6 = A8 ? { type: "sprite-rasterization-param", resource: { type: "path", path: A8, asFill: E6 }, overrides: [] } : { type: "sprite-rasterization-param", resource: w5, overrides: [] }, J3 = c5(this._poMap, f13, p7), B5 = p2(e15.size, i3.CIMVectorMarker.size), q4 = this._getValueOrOverrideExpression(e15.type, e15.primitiveName, "Size", B5);
          this._cimLayers.push({ type: "marker", spriteRasterizationParam: U6, colorLocked: !!f13.colorLocked || !!m6, effects: r11, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a13, anchorPoint: { x: P5, y: z3 }, isAbsoluteAnchorPoint: u16, size: c13, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l14 }, frameHeight: c13, widthRatio: L7, rotateClockwise: false, referenceSize: s15, sizeRatio: C4, color: W3, outlineColor: D6, outlineWidth: H3, isOutline: y7, markerPlacement: t22, animationParams: Z(J3), isStroke: "CIMSolidFill" !== f13.type, baseSize: q4, ...c3(o19, I6) });
          break;
        }
        case "CIMPictureMarker":
        case "CIMVectorMarker":
          f13.markerPlacement ? this._analyzeMultiLayerGraphicNonSDF(e15, r11, t22, i14, o18, a13, s15, l14, p7, c13, !!f13.colorLocked || !!m6, y7) : this._analyzeMarker(f13, r11, t22, o18, a13, s15, false, l14, p7, m6, y7);
          break;
        default:
          this._analyzeMultiLayerGraphicNonSDF(e15, r11, t22, i14, o18, a13, s15, l14, p7, c13, !!f13.colorLocked || !!m6, y7);
      }
      d11 && o18.pop();
    }
  }
  _analyzeTextGraphic(e15, t22, i14, o18, a13, s15, l14, n17) {
    var _a, _b, _c;
    const p7 = [];
    y2.findApplicableOverrides(i14, this._primitiveOverrides, p7);
    const c13 = i14.geometry;
    if (!("x" in c13) || !("y" in c13)) return;
    const m6 = i14.symbol, y7 = L3(m6), f12 = w2(m6.fontStyleName), h13 = u7(m6.fontFamilyName);
    m6.font = { family: h13, decoration: y7, ...f12 };
    const d11 = p2(m6.height, i3.CIMTextSymbol.height), u15 = p2(m6.angle), O7 = p2(m6.offsetX), g8 = p2(m6.offsetY), { haloSymbol: S4 } = m6, M6 = p2(m6.haloSize, 0);
    let k3 = [0, 0, 0, 0];
    if ((_a = S4 == null ? void 0 : S4.symbolLayers) == null ? void 0 : _a.length) {
      const e16 = S4.symbolLayers;
      for (const r11 of e16) if (r11.color) {
        k3 = this._getValueOrOverrideExpression(((_b = m6 == null ? void 0 : m6.haloSymbol) == null ? void 0 : _b.type) ?? "CIMPolygonSymbol", r11.primitiveName, "Color", f3(r11.color));
        break;
      }
    }
    const C4 = i14.primitiveName;
    let P5 = [0, 0, 0, 1], z3 = [0, 0, 0, 0], L7 = 0, I6 = false;
    if ((_c = m6.symbol) == null ? void 0 : _c.symbolLayers) for (const r11 of m6.symbol.symbolLayers) {
      const e16 = r11.primitiveName;
      if ("CIMSolidStroke" === r11.type) z3 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Color", f3(r11.color)), L7 = this._getValueOrOverrideExpression("CIMSolidStroke", e16, "Width", N2(r11) ?? 0);
      else if ("CIMSolidFill" === r11.type) {
        const t23 = f3(r11.color);
        I6 = I6 ?? !!r11.colorLocked, P5 = this._getValueOrOverrideExpression("CIMSolidFill", e16 ?? C4, "Color", t23);
      }
    }
    let E6 = null, N4 = null, R3 = null, F5 = null, T4 = null;
    C4 && (E6 = this._maybeGetValueOrOverrideExpression(C4, "TextSize"), N4 = this._maybeGetValueOrOverrideExpression(C4, "TextAngle"), R3 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetX"), F5 = this._maybeGetValueOrOverrideExpression(C4, "TextOffsetY"), I6 || (T4 = this._maybeGetValueOrOverrideExpression(C4, "FillColor")));
    const Y2 = T4 ?? P5;
    let j7 = null, W3 = null, D6 = 0;
    if (m6.callout && "CIMBackgroundCallout" === m6.callout.type) {
      const e16 = m6.callout;
      if (e16.backgroundSymbol) {
        const r11 = e16.backgroundSymbol.symbolLayers;
        if (r11) for (const e17 of r11) "CIMSolidFill" === e17.type ? j7 = f3(e17.color) : "CIMSolidStroke" === e17.type && (W3 = f3(e17.color), D6 = p2(e17.width, i3.CIMSolidStroke.width));
      }
    }
    const H3 = this._getValueOrOverrideExpression(m6.type, i14.primitiveName, "TextString", i14.textString ?? "");
    if (null == H3) return;
    const { fontStyleName: U6 } = m6, J3 = h13 + (U6 ? "-" + U6.toLowerCase() : "-regular"), B5 = this._getMaterialOverrides(o18, m6.type);
    B5.push(...this._getPrimitiveMaterialOverrides(i14.primitiveName, m6.type));
    const q4 = { type: "text-rasterization-param", resource: { type: "text", textString: i14.textString ?? "", font: m6.font, symbol: m6, primitiveName: i14.primitiveName }, overrides: B5 };
    this._cimLayers.push({ type: "text", lineWidth: m6.lineWidth, textRasterizationParam: q4, colorLocked: !!n17 || !!I6, effects: e15, alignment: a13, anchorPoint: { x: 0, y: 0 }, isAbsoluteAnchorPoint: false, fontName: J3, decoration: y7, haloSize: M6, haloColor: k3, weight: f12.weight, style: f12.style, size: E6 ?? d11, angle: N4 ?? u15, offsetX: R3 ?? O7, offsetY: F5 ?? g8, transform: { type: "cim-marker-transform-param", params: l14 }, horizontalAlignment: x2(m6.horizontalAlignment), verticalAlignment: F2(m6.verticalAlignment), text: H3, color: Y2, outlineColor: z3, outlineSize: L7, backgroundColor: j7, borderLineColor: W3, borderLineWidth: D6, referenceSize: s15, sizeRatio: 1, markerPlacement: t22 });
  }
  _analyzeMultiLayerGraphicNonSDF(e15, r11, t22, i14, a13, s15, l14, n17, p7, c13, m6, y7) {
    const f12 = U5(e15, i14), h13 = e15.primitiveName, d11 = this._analyzeMaterialOverrides(h13, ["Rotation", "OffsetX", "OffsetY"]), O7 = U4(d11), [_6, g8, S4] = ee.getTextureAnchor(f12, this._resourceManager), M6 = this._getMaterialOverrides(a13, e15.type);
    M6.push(...O7);
    const k3 = { type: "sprite-rasterization-param", resource: { ...f12, avoidSDFRasterization: true }, overrides: M6 }, b6 = p2(e15.size, i3.CIMVectorMarker.size), C4 = this._getValueOrOverrideExpression(e15.type, h13, "Size", b6);
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: k3, colorLocked: m6, effects: r11, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: s15, anchorPoint: { x: _6, y: g8 }, isAbsoluteAnchorPoint: false, size: c13, rotation: 0, offsetX: 0, offsetY: 0, transform: { type: "cim-marker-transform-param", params: n17 }, color: [255, 255, 255, 1], outlineColor: [0, 0, 0, 0], outlineWidth: 0, scaleX: 1, frameHeight: c13, widthRatio: 1, rotateClockwise: !!e15.rotateClockwise, referenceSize: l14, sizeRatio: S4 / u3(e15.size), isOutline: y7, markerPlacement: t22, animationParams: Z(p7), baseSize: C4 });
  }
  _createMarkerPlacementOverrideExpression(e15) {
    if (!e15) return null;
    const r11 = [];
    return y2.findApplicableOverrides(e15, this._primitiveOverrides, r11), { type: "cim-marker-placement-param", placement: e15, overrides: Q(r11) };
  }
  _createGIFAnimatedSymbolPropertiesOverrideExpression(e15) {
    if (!e15) return null;
    const r11 = [];
    return y2.findApplicableOverrides(e15, this._primitiveOverrides, r11), { type: "cim-gif-animation-params", animation: e15, overrides: Q(r11) };
  }
  _analyzeCompositeMarkerGraphic(e15, r11, t22, i14, o18, a13, s15, l14, n17, p7, c13) {
    const m6 = i14.geometry, y7 = o18[0], f12 = o18[1], h13 = m4(m6);
    if (!h13) return;
    const d11 = "Relative" !== e15.anchorPointUnits, u15 = p2(y7.width, i3.CIMSolidStroke.width), { frameSizeRatio: O7, anchorX: _6, anchorY: M6, widthRatio: k3, sdfPaddingRatio: C4 } = h4(h13, e15.frame, e15.size, e15.anchorPoint, d11, u15, e15.scaleSymbolsProportionally), { path: P5 } = f12, z3 = f12.primitiveName, L7 = y7.primitiveName, I6 = i14.primitiveName;
    let E6 = null;
    f12.colorLocked || p7 || (E6 = this._maybeGetValueOrOverrideExpression(I6, "FillColor"));
    const V = E6 ?? this._getValueOrOverrideExpression(f12.type, z3, "Color", f3(f12.color));
    let N4 = null;
    y7.colorLocked || p7 || (N4 = this._maybeGetValueOrOverrideExpression(I6, "StrokeColor"));
    const R3 = N4 ?? this._getValueOrOverrideExpression(y7.type, L7, "Color", f3(y7.color)), w5 = this._maybeGetValueOrOverrideExpression(I6, "StrokeWidth") ?? this._getValueOrOverrideExpression(y7.type, L7, "Width", u15), A8 = { type: "sprite-rasterization-param", resource: P5 ? { type: "path", path: P5, asFill: true } : { type: "sdf", geom: m6, sdfPaddingRatio: C4, asFill: true }, overrides: [] };
    this._cimLayers.push({ type: "marker", spriteRasterizationParam: A8, colorLocked: p7, effects: r11, scaleSymbolsProportionally: !!e15.scaleSymbolsProportionally, alignment: a13, anchorPoint: { x: _6, y: M6 }, isAbsoluteAnchorPoint: d11, size: n17, rotation: 0, offsetX: 0, offsetY: 0, scaleX: 1, transform: { type: "cim-marker-transform-param", params: l14 }, frameHeight: n17, widthRatio: k3, rotateClockwise: false, referenceSize: s15, sizeRatio: O7, color: V, outlineColor: R3, outlineWidth: w5, isOutline: c13, markerPlacement: t22 });
  }
  _setPoMap(e15, r11, t22) {
    let i14;
    this._poMap[e15] ? i14 = this._poMap[e15] : (i14 = {}, this._poMap[e15] = i14), i14[r11] = t22;
  }
  _maybeGetValueOrOverrideExpression(e15, r11, t22) {
    return this._getValueOrOverrideExpression("", e15, r11, t22, false);
  }
  _getValueOrOverrideExpression(e15, r11, t22, i14, o18 = true) {
    if (o18 && !O2(i14) && (i14 = D2(e15, t22.toLowerCase())), null == r11) return i14;
    const a13 = this._poMap[r11];
    if (null == a13) return i14;
    const s15 = a13[t22];
    return "string" == typeof s15 || "number" == typeof s15 || Array.isArray(s15) ? s15 : s15 ? { valueExpressionInfo: s15, defaultValue: i14 } : i14;
  }
  _analyzePrimitiveOverrides(e15, r11, t22, i14) {
    if (null == e15) return false;
    "string" == typeof e15 && (e15 = [e15]);
    for (const o18 of this._primitiveOverrides) if (e15.includes(o18.primitiveName) && o18.valueExpressionInfo) return true;
    if (null != r11) {
      for (const o18 of r11) if ((o18 == null ? void 0 : o18.overrides.length) > 0) return true;
    }
    if (null != t22) {
      for (const o18 of t22) if ((o18 == null ? void 0 : o18.overrides.length) > 0) return true;
    }
    if (null != i14) {
      for (const o18 of i14) if ((o18 == null ? void 0 : o18.overrides.length) > 0) return true;
    }
    return false;
  }
  _getMaterialOverrides(e15, r11) {
    if (!e15) return [];
    const t22 = [];
    for (const i14 of e15) t22.push(...this._getPrimitiveMaterialOverrides(i14, r11));
    return t22;
  }
  _getPrimitiveMaterialOverrides(e15, r11) {
    if (!e15) return [];
    const t22 = U4(this._primitiveOverrides.filter((r12) => r12.primitiveName === e15));
    return t22.forEach((e16) => e16.defaultValue = D2(r11, e16.propertyName.toLowerCase())), t22;
  }
  _analyzeMaterialOverrides(e15, r11) {
    return this._primitiveOverrides.filter((t22) => t22.primitiveName !== e15 || !r11.includes(t22.propertyName));
  }
};
function U5(e15, r11) {
  return { type: e15.type, enable: true, name: e15.name, colorLocked: e15.colorLocked, primitiveName: e15.primitiveName, anchorPoint: e15.anchorPoint, anchorPointUnits: e15.anchorPointUnits, offsetX: 0, offsetY: 0, rotateClockwise: e15.rotateClockwise, rotation: 0, size: e15.size, billboardMode3D: e15.billboardMode3D, depth3D: e15.depth3D, frame: e15.frame, markerGraphics: [r11], scaleSymbolsProportionally: e15.scaleSymbolsProportionally, respectFrame: e15.respectFrame, clippingPath: e15.clippingPath };
}
function J2(e15) {
  if (e15 && 0 === e15.indexOf("Level_")) {
    const r11 = parseInt(e15.slice(6), 10);
    if (!isNaN(r11)) return r11;
  }
  return 0;
}
var q2 = (e15) => e15 && 2 === e15.length && e15[0].enable && e15[1].enable && "CIMSolidStroke" === e15[0].type && "CIMSolidFill" === e15[1].type && null == e15[0].path && null == e15[1].path && !e15[0].effects && !e15[1].effects && !e15[0].animations && !e15[1].animations;
function K3(e15) {
  const r11 = e15.symbolLayers;
  if (!r11) return false;
  const t22 = r11.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectDashes" === e17.type && null != e17.dashTemplate);
  }), i14 = r11.find((e16) => {
    var _a;
    return (_a = e16.effects) == null ? void 0 : _a.find((e17) => "CIMGeometricEffectAddControlPoints" === e17.type);
  });
  return !!t22 || !!i14;
}
function Q(e15) {
  return a(e15).map((e16) => ({ ...e16, propertyName: z2(e16.propertyName) }));
}
function Z(e15) {
  return f6(e15) ? { type: "animation-params", params: e15 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/ManagedCanvas.js
var c6 = class {
  constructor(r11) {
    this.events = new o2(), this._hasMajorPerformanceCaveat = false, this._lastRenderFrameCounter = 0, this._canvas = document.createElement("canvas"), this._canvas.setAttribute("style", "width: 100%; height:100%; display:block; willChange:transform");
    const s15 = { failIfMajorPerformanceCaveat: true, alpha: true, antialias: false, depth: true, stencil: true, powerPreference: "high-performance" };
    r11.appendChild(this._canvas);
    let i14 = this._canvas.getContext("webgl2", s15);
    i14 || (i14 = this._canvas.getContext("webgl2", { ...s15, failIfMajorPerformanceCaveat: false }), this._hasMajorPerformanceCaveat = true), this._gl = i14, this._handles = t([o(this._canvas, "webglcontextlost", (e15) => this.events.emit("webgl-context-lost", e15))]);
  }
  destroy() {
    var _a;
    (_a = this._canvas.parentNode) == null ? void 0 : _a.removeChild(this._canvas), this._canvas = null, this._handles.remove(), this._gl = null;
  }
  get gl() {
    return this._gl;
  }
  render(e15, t22) {
    if (this._hasMajorPerformanceCaveat || has("esri-force-performance-mode")) {
      if (++this._lastRenderFrameCounter >= has("esri-performance-mode-frames-between-render") && (t22(), this._lastRenderViewState = e15.state.clone(), this._lastRenderFrameCounter = 0), this._lastRenderViewState) {
        const [t23, a13, r11, s15, i14, o18] = this._computeViewTransform(this._lastRenderViewState, e15.state);
        this._canvas.style.transform = `matrix(${t23}, ${a13}, ${r11}, ${s15}, ${i14}, ${o18})`;
      }
    } else t22();
  }
  resize(e15) {
    const t22 = this._canvas, a13 = t22.style, { state: { size: r11 }, pixelRatio: s15 } = e15, i14 = r11[0], o18 = r11[1], n17 = Math.round(i14 * s15), h13 = Math.round(o18 * s15);
    t22.width === n17 && t22.height === h13 || (t22.width = n17, t22.height = h13), a13.width = i14 + "px", a13.height = o18 + "px";
  }
  _computeViewTransform(e15, t22) {
    const [a13, c13] = e15.center, [l14, m6] = t22.center, [d11, f12] = e15.toScreen([0, 0], l14, m6), [_6, p7] = e15.toScreen([0, 0], a13, c13), v4 = _6 - d11, g8 = p7 - f12, w5 = e15.scale / t22.scale, u15 = t22.rotation - e15.rotation, C4 = e5();
    return a3(C4), c(C4, C4, [w5, w5]), s8(C4, C4, s5(u15)), i5(C4, C4, [v4, g8]), C4;
  }
};

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/shaderRepository.js
var e13 = { background: { "background.frag": "#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n}", "background.vert": "precision mediump float;\nattribute vec2 a_pos;\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n}" }, circle: { "circle.frag": "precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n}", "circle.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, fill: { "fill.frag": "precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n}", "fill.vert": "precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, icon: { "icon.frag": "precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n}", "icon.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\nv_tex = a_tex.xy / u_mosaicSize;\n}" }, line: { "line.frag": "precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n}", "line.vert": "precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n}" }, outline: { "outline.frag": "varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n}", "outline.vert": "attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}" }, text: { "text.frag": "uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n}", "text.vert": "attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}" }, util: { "encoding.glsl": "const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}", "util.glsl": "float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}" } };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/sources/resolver.js
function o12(e15) {
  let o18 = e13;
  return e15.split("/").forEach((r11) => {
    o18 && (o18 = o18[r11]);
  }), o18;
}
var t16 = new e7(o12);
function n10(r11) {
  return t16.resolveIncludes(r11);
}

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/Programs.js
var t17 = (e15) => n6({ PATTERN: e15.pattern });
var a6 = { shaders: (r11) => ({ vertexShader: t17(r11) + n10("background/background.vert"), fragmentShader: t17(r11) + n10("background/background.frag") }) };
var d8 = { shaders: (r11) => ({ vertexShader: n10("circle/circle.vert"), fragmentShader: n10("circle/circle.frag") }) };
var n11 = (e15) => n6({ PATTERN: e15.pattern });
var i10 = { shaders: (r11) => ({ vertexShader: n11(r11) + n10("fill/fill.vert"), fragmentShader: n11(r11) + n10("fill/fill.frag") }) };
var l6 = { shaders: (r11) => ({ vertexShader: n10("outline/outline.vert"), fragmentShader: n10("outline/outline.frag") }) };
var s10 = (e15) => n6({ SDF: e15.sdf });
var f7 = { shaders: (r11) => ({ vertexShader: s10(r11) + n10("icon/icon.vert"), fragmentShader: s10(r11) + n10("icon/icon.frag") }) };
var h6 = (e15) => n6({ PATTERN: e15.pattern, SDF: e15.sdf });
var o13 = { shaders: (r11) => ({ vertexShader: h6(r11) + n10("line/line.vert"), fragmentShader: h6(r11) + n10("line/line.frag") }) };
var g4 = { shaders: (r11) => ({ vertexShader: n10("text/text.vert"), fragmentShader: n10("text/text.frag") }) };

// node_modules/@arcgis/core/views/2d/engine/vectorTiles/shaders/VTLMaterialManager.js
var p4 = class {
  constructor() {
    this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((e15) => e15.dispose()), this._programByKey.clear();
  }
  getMaterialProgram(e15, r11, t22) {
    const a13 = r11.key << 3 | this._getMaterialOptionsValue(r11.type, t22);
    if (this._programByKey.has(a13)) return this._programByKey.get(a13);
    const s15 = this._getProgramTemplate(r11.type), { shaders: n17 } = s15, { vertexShader: c13, fragmentShader: o18 } = n17(t22), p7 = r11.getShaderHeader(), u15 = r11.getShaderMain(), i14 = c13.replace("#pragma header", p7).replace("#pragma main", u15), g8 = e15.programCache.acquire(i14, o18, r11.getAttributeLocations());
    return this._programByKey.set(a13, g8), g8;
  }
  _getMaterialOptionsValue(r11, t22) {
    switch (r11) {
      case L4.BACKGROUND:
        return (t22.pattern ? 1 : 0) << 1;
      case L4.FILL:
        return (t22.pattern ? 1 : 0) << 1;
      case L4.OUTLINE:
        return 0;
      case L4.LINE: {
        const e15 = t22;
        return (e15.sdf ? 1 : 0) << 2 | (e15.pattern ? 1 : 0) << 1;
      }
      case L4.ICON:
        return (t22.sdf ? 1 : 0) << 1;
      case L4.CIRCLE:
      case L4.TEXT:
      default:
        return 0;
    }
  }
  _getProgramTemplate(p7) {
    switch (p7) {
      case L4.BACKGROUND:
        return a6;
      case L4.CIRCLE:
        return d8;
      case L4.FILL:
        return i10;
      case L4.ICON:
        return f7;
      case L4.LINE:
        return o13;
      case L4.OUTLINE:
        return l6;
      case L4.TEXT:
        return g4;
      default:
        return null;
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/BitBlitRenderer.js
var _2 = class {
  constructor() {
    this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._vertexArrayObject = r2(this._vertexArrayObject);
  }
  render(r11, t22, e15, i14) {
    r11 && (this._initialized || this._initialize(r11), r11.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), r11.bindVAO(this._vertexArrayObject), r11.useProgram(this._program), t22.setSamplingMode(e15), r11.bindTexture(t22, 0), this._program.setUniform1i("u_tex", 0), this._program.setUniform1f("u_opacity", i14), r11.drawArrays(E.TRIANGLE_STRIP, 0, 4), r11.bindTexture(null, 0), r11.bindVAO());
  }
  _initialize(r11) {
    if (this._initialized) return true;
    const s15 = e8(r11, e11);
    if (!s15) return false;
    const a13 = new Int8Array(16);
    a13[0] = -1, a13[1] = -1, a13[2] = 0, a13[3] = 0, a13[4] = 1, a13[5] = -1, a13[6] = 1, a13[7] = 0, a13[8] = -1, a13[9] = 1, a13[10] = 0, a13[11] = 1, a13[12] = 1, a13[13] = 1, a13[14] = 1, a13[15] = 1;
    const _6 = e11.attributes, p7 = new o7(r11, _6, t9, /* @__PURE__ */ new Map([["geometry", E3.createVertex(r11, F.STATIC_DRAW, a13)]]));
    return this._program = s15, this._vertexArrayObject = p7, this._initialized = true, true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/MaterialManager.js
var e14 = class {
  constructor(r11) {
    this._rctx = r11, this._programByKey = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._programByKey.forEach((r11) => r11.dispose()), this._programByKey.clear();
  }
  getProgram(e15, t22 = []) {
    const a13 = e15.vsPath + "." + e15.fsPath + JSON.stringify(t22);
    if (this._programByKey.has(a13)) return this._programByKey.get(a13);
    const s15 = { ...t22.map((r11) => "string" == typeof r11 ? { name: r11, value: true } : r11).reduce((r11, e16) => ({ ...r11, [e16.name]: e16.value }), {}) }, { vsPath: o18, fsPath: h13, attributes: i14 } = e15, g8 = o9(o18, h13, i14, s15), m6 = this._rctx.programCache.acquire(g8.shaders.vertexShader, g8.shaders.fragmentShader, g8.attributes);
    if (!m6) throw new Error("Unable to get program for key: ${key}");
    return this._programByKey.set(a13, m6), m6;
  }
};

// node_modules/@arcgis/core/symbols/cim/Rasterizer.js
var h7 = 512;
var f8 = class {
  constructor(e15) {
    this._resourceManager = e15, this._cachedRasterizationCanvas = null;
  }
  dispose() {
    this._cachedRasterizationCanvas = null;
  }
  get _canvas() {
    return this._cachedRasterizationCanvas || (this._cachedRasterizationCanvas = document.createElement("canvas")), this._cachedRasterizationCanvas;
  }
  rasterizeJSONResource(e15) {
    switch (e15.type) {
      case "dash": {
        const r11 = q(e15.dashTemplate), [a13, s15, n17] = i9(r11);
        return { size: [s15, n17], image: new Uint32Array(a13.buffer), sdf: true, simplePattern: true, anchorX: 0, anchorY: 0 };
      }
      case "fill-style": {
        const [t22, a13, s15, n17] = s9(this._canvas, e15, ai);
        return { size: [a13, s15], image: new Uint32Array(t22.buffer), sdf: false, simplePattern: true, anchorX: 0, anchorY: 0, rasterizationScale: n17 };
      }
      case "sdf":
        return d9(e15);
      case "CIMHatchFill":
      case "CIMVectorMarker":
      case "CIMPictureMarker":
        return this._rasterizeCIMJSONResource(e15);
    }
  }
  _rasterizeCIMJSONResource(r11) {
    var _a;
    switch (r11.type) {
      case "CIMHatchFill": {
        const t22 = ee.fromCIMHatchFill(r11, ai);
        return this._rasterizeCIMVectorMarker(t22);
      }
      case "CIMPictureMarker": {
        const t22 = ee.fromCIMInsidePolygon(r11);
        return this._rasterizeCIMVectorMarker(t22);
      }
      case "CIMVectorMarker": {
        if ("CIMMarkerPlacementInsidePolygon" === ((_a = r11.markerPlacement) == null ? void 0 : _a.type)) {
          const t23 = ee.fromCIMInsidePolygon(r11);
          return this._rasterizeCIMVectorMarker(t23);
        }
        const t22 = a4(r11);
        return t22 && !r11.avoidSDFRasterization ? d9(t22) : this._rasterizeCIMVectorMarker(r11, false, oi);
      }
    }
  }
  _rasterizeCIMVectorMarker(r11, t22 = true, s15) {
    const n17 = t22 ? t3.fromExtent(r11.frame) : null, [i14, o18, c13, l14, h13] = ee.rasterize(this._canvas, r11, n17, this._resourceManager, true, s15);
    return i14 ? { size: [o18, c13], image: new Uint32Array(i14.buffer), sdf: false, simplePattern: false, anchorX: l14, anchorY: h13 } : null;
  }
  rasterizeImageResource(e15, r11, t22, a13) {
    this._canvas.width = e15, this._canvas.height = r11;
    const s15 = this._canvas.getContext("2d", { willReadFrequently: true });
    t22 instanceof ImageData ? s15.putImageData(t22, 0, 0) : (t22.setAttribute("width", `${e15}px`), t22.setAttribute("height", `${r11}px`), s15.drawImage(t22, 0, 0, e15, r11));
    const n17 = s15.getImageData(0, 0, e15, r11), i14 = new Uint8Array(n17.data);
    if (a13) {
      for (const o18 of a13) if (o18 && o18.oldColor && 4 === o18.oldColor.length && o18.newColor && 4 === o18.newColor.length) {
        const [e16, r12, t23, a14] = o18.oldColor, [s16, n18, c14, l15] = o18.newColor;
        if (e16 === s16 && r12 === n18 && t23 === c14 && a14 === l15) continue;
        for (let o19 = 0; o19 < i14.length; o19 += 4) e16 === i14[o19] && r12 === i14[o19 + 1] && t23 === i14[o19 + 2] && a14 === i14[o19 + 3] && (i14[o19] = s16, i14[o19 + 1] = n18, i14[o19 + 2] = c14, i14[o19 + 3] = l15);
      }
    }
    let c13;
    for (let o18 = 0; o18 < i14.length; o18 += 4) c13 = i14[o18 + 3] / 255, i14[o18] = i14[o18] * c13, i14[o18 + 1] = i14[o18 + 1] * c13, i14[o18 + 2] = i14[o18 + 2] * c13;
    let l14 = i14, f12 = e15, d11 = r11;
    const u15 = h7;
    if (f12 >= u15 || d11 >= u15) {
      const t23 = f12 / d11;
      t23 > 1 ? (f12 = u15, d11 = Math.round(u15 / t23)) : (d11 = u15, f12 = Math.round(u15 * t23)), l14 = new Uint8Array(4 * f12 * d11);
      const a14 = new Uint8ClampedArray(l14.buffer);
      u6(i14, e15, r11, a14, f12, d11, false);
    }
    return { size: [f12, d11], image: new Uint32Array(l14.buffer), sdf: false, simplePattern: false, anchorX: 0, anchorY: 0 };
  }
};
function d9(e15) {
  if (!e15) return null;
  const { data: r11, width: t22, height: a13, sdfPaddingRatio: s15, sdfDecodeCoeff: i14 } = u8(e15);
  return r11 ? { size: [t22, a13], image: new Uint32Array(r11.buffer), sdf: true, simplePattern: true, sdfPaddingRatio: s15, sdfDecodeCoeff: i14, anchorX: 0, anchorY: 0 } : null;
}

// node_modules/@arcgis/core/views/2d/engine/webgl/RectangleBinPack.js
var t18 = class {
  constructor(t22, e15) {
    this._width = 0, this._height = 0, this._free = [], this._width = t22, this._height = e15, this._free.push(new t5(0, 0, t22, e15));
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  allocate(t22, e15) {
    if (t22 > this._width || e15 > this._height) return new t5();
    let i14 = null, s15 = -1;
    for (let h13 = 0; h13 < this._free.length; ++h13) {
      const r11 = this._free[h13];
      t22 <= r11.width && e15 <= r11.height && (null === i14 || r11.y <= i14.y && r11.x <= i14.x) && (i14 = r11, s15 = h13);
    }
    return null === i14 ? new t5() : (this._free.splice(s15, 1), i14.width < i14.height ? (i14.width > t22 && this._free.push(new t5(i14.x + t22, i14.y, i14.width - t22, e15)), i14.height > e15 && this._free.push(new t5(i14.x, i14.y + e15, i14.width, i14.height - e15))) : (i14.width > t22 && this._free.push(new t5(i14.x + t22, i14.y, i14.width - t22, i14.height)), i14.height > e15 && this._free.push(new t5(i14.x, i14.y + e15, t22, i14.height - e15))), new t5(i14.x, i14.y, t22, e15));
  }
  release(h13) {
    for (let t22 = 0; t22 < this._free.length; ++t22) {
      const e15 = this._free[t22];
      if (e15.y === h13.y && e15.height === h13.height && e15.x + e15.width === h13.x) e15.width += h13.width;
      else if (e15.x === h13.x && e15.width === h13.width && e15.y + e15.height === h13.y) e15.height += h13.height;
      else if (h13.y === e15.y && h13.height === e15.height && h13.x + h13.width === e15.x) e15.x = h13.x, e15.width += h13.width;
      else {
        if (h13.x !== e15.x || h13.width !== e15.width || h13.y + h13.height !== e15.y) continue;
        e15.y = h13.y, e15.height += h13.height;
      }
      this._free.splice(t22, 1), this.release(h13);
    }
    this._free.push(h13);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphMosaic.js
var n12 = 256;
var o14 = (t22) => Math.floor(t22 / 256);
function c7(t22) {
  const e15 = /* @__PURE__ */ new Set();
  for (const i14 of t22) e15.add(o14(i14));
  return e15;
}
function l7(e15, i14, h13) {
  return e15.has(i14) || e15.set(i14, h13().then(() => {
    e15.delete(i14);
  }).catch((h14) => {
    e15.delete(i14), f(h14);
  })), e15.get(i14);
}
var g5 = (t22) => ({ rect: new t5(0, 0, 0, 0), page: 0, metrics: { left: 0, width: 0, height: 0, advance: 0, top: 0 }, code: t22, sdf: true });
var p5 = class {
  constructor(t22, e15, h13) {
    this.width = 0, this.height = 0, this._dirties = [], this._glyphData = [], this._currentPage = 0, this._glyphCache = {}, this._textures = [], this._rangePromises = /* @__PURE__ */ new Map(), this._preloadCache = {}, this.width = t22, this.height = e15, this._glyphSource = h13, this._binPack = new t18(t22 - 4, e15 - 4), this._glyphData.push(new Uint8Array(t22 * e15)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs();
  }
  dispose() {
    this._binPack = null;
    for (const t22 of this._textures) t22 && t22.dispose();
    this._textures.length = 0, this._glyphData.length = 0;
  }
  _initDecorationGlyphs() {
    const t22 = [117, 149, 181, 207, 207, 181, 149, 117], e15 = [], i14 = [];
    for (let r11 = 0; r11 < t22.length; r11++) {
      const h14 = t22[r11];
      for (let t23 = 0; t23 < 11; t23++) {
        const s16 = r11 >= 3 && r11 < 5 && t23 >= 3 && t23 < 8 ? 255 : 0;
        e15.push(h14), i14.push(s16);
      }
    }
    const h13 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(e15) }, s15 = { metrics: { width: 5, height: 2, left: 0, top: 0, advance: 0 }, bitmap: new Uint8Array(i14) };
    this._recordGlyph(h13), this._recordGlyph(s15);
  }
  getTexture(t22, e15) {
    if (!this._textures[e15]) {
      const i14 = new p();
      i14.pixelFormat = G.ALPHA, i14.wrapMode = D.CLAMP_TO_EDGE, i14.width = this.width, i14.height = this.height, this._textures[e15] = new m3(t22, i14, new Uint8Array(this.width * this.height));
    }
    return this._dirties[e15] && (this._textures[e15].setData(this._glyphData[e15]), this._dirties[e15] = false), this._textures[e15];
  }
  async getGlyphItems(t22, e15, i14) {
    const h13 = this._getGlyphCache(t22);
    return await this._fetchRanges(t22, e15, i14), e15.map((e16) => this._getMosaicItem(h13, t22, e16));
  }
  bind(t22, e15, i14, h13) {
    const s15 = this.getTexture(t22, i14);
    s15.setSamplingMode(e15), t22.bindTexture(s15, h13);
  }
  preloadASCIIGlyphCache(t22) {
    const e15 = this._preloadCache[t22];
    if (null != e15) return e15;
    const i14 = this._glyphSource.preloadASCIIRange(t22).then(() => {
      const e16 = this._getGlyphCache(t22);
      for (let i15 = 0; i15 < 256; i15++) this._getMosaicItem(e16, t22, i15);
    });
    return this._preloadCache[t22] = i14, i14;
  }
  _getGlyphCache(t22) {
    return this._glyphCache[t22] || (this._glyphCache[t22] = {}), this._glyphCache[t22];
  }
  _invalidate() {
    this._dirties[this._currentPage] = true;
  }
  async _fetchRanges(t22, e15, i14) {
    const h13 = c7(e15), s15 = [];
    h13.forEach((e16) => {
      s15.push(this._fetchRange(t22, e16, i14));
    }), await Promise.all(s15);
  }
  async _fetchRange(t22, e15, i14) {
    if (e15 > n12) return;
    const h13 = t22 + e15;
    return l7(this._rangePromises, h13, () => this._glyphSource.getRange(t22, e15, i14));
  }
  _getMosaicItem(t22, e15, i14) {
    if (!t22[i14]) {
      const h13 = this._glyphSource.getGlyph(e15, i14);
      if (!(h13 == null ? void 0 : h13.metrics)) return g5(i14);
      const s15 = this._recordGlyph(h13), r11 = this._currentPage, a13 = h13.metrics;
      t22[i14] = { rect: s15, page: r11, metrics: a13, code: i14, sdf: true }, this._invalidate();
    }
    return t22[i14];
  }
  _recordGlyph(t22) {
    const h13 = t22.metrics;
    let s15;
    if (0 === h13.width) s15 = new t5(0, 0, 0, 0);
    else {
      const e15 = 3, r11 = h13.width + 2 * e15, a13 = h13.height + 2 * e15;
      s15 = this._binPack.allocate(r11, a13), s15.isEmpty && (this._dirties[this._currentPage] || (this._glyphData[this._currentPage] = null), this._currentPage = this._glyphData.length, this._glyphData.push(new Uint8Array(this.width * this.height)), this._dirties.push(true), this._textures.push(null), this._initDecorationGlyphs(), this._binPack = new t18(this.width - 4, this.height - 4), s15 = this._binPack.allocate(r11, a13));
      const n17 = this._glyphData[this._currentPage], o18 = t22.bitmap;
      let c13, l14;
      if (o18) for (let t23 = 0; t23 < a13; t23++) {
        c13 = r11 * t23, l14 = this.width * (s15.y + t23) + s15.x;
        for (let t24 = 0; t24 < r11; t24++) n17[l14 + t24] = o18[c13 + t24];
      }
      has("esri-glyph-debug") && this._showDebugPage(n17);
    }
    return s15;
  }
  _showDebugPage(t22) {
    const e15 = document.createElement("canvas"), i14 = e15.getContext("2d"), h13 = new ImageData(this.width, this.height), s15 = h13.data;
    e15.width = this.width, e15.height = this.height, e15.style.border = "1px solid black";
    for (let r11 = 0; r11 < t22.length; ++r11) s15[4 * r11] = t22[r11], s15[4 * r11 + 1] = 0, s15[4 * r11 + 2] = 0, s15[4 * r11 + 3] = 255;
    i14.putImageData(h13, 0, 0), document.body.appendChild(e15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/GlyphSource.js
var a7 = class {
  constructor(e15) {
    for (this._metrics = [], this._bitmaps = []; e15.next(); ) switch (e15.tag()) {
      case 1: {
        const t22 = e15.getMessage();
        for (; t22.next(); ) switch (t22.tag()) {
          case 3: {
            const e16 = t22.getMessage();
            let a13, s15, r11, n17, i14, c13, g8;
            for (; e16.next(); ) switch (e16.tag()) {
              case 1:
                a13 = e16.getUInt32();
                break;
              case 2:
                s15 = e16.getBytes();
                break;
              case 3:
                r11 = e16.getUInt32();
                break;
              case 4:
                n17 = e16.getUInt32();
                break;
              case 5:
                i14 = e16.getSInt32();
                break;
              case 6:
                c13 = e16.getSInt32();
                break;
              case 7:
                g8 = e16.getUInt32();
                break;
              default:
                e16.skip();
            }
            e16.release(), a13 && (this._metrics[a13] = { width: r11, height: n17, left: i14, top: c13, advance: g8 }, this._bitmaps[a13] = s15);
            break;
          }
          default:
            t22.skip();
        }
        t22.release();
        break;
      }
      default:
        e15.skip();
    }
  }
  getMetrics(e15) {
    return this._metrics[e15];
  }
  getBitmap(e15) {
    return this._bitmaps[e15];
  }
};
var s11 = class {
  constructor() {
    this._ranges = [];
  }
  getRange(e15) {
    return this._ranges[e15];
  }
  addRange(e15, t22) {
    this._ranges[e15] = t22;
  }
};
var r8 = class {
  constructor(e15) {
    this._glyphInfo = {}, this._baseURL = e15;
  }
  getRange(s15, r11, n17) {
    const i14 = this._getFontStack(s15);
    if (i14.getRange(r11)) return Promise.resolve();
    const c13 = 256 * r11, g8 = c13 + 255, o18 = this._baseURL.replace("{fontstack}", s15).replace("{range}", c13 + "-" + g8);
    return U(o18, { responseType: "array-buffer", ...n17 }).then((e15) => {
      i14.addRange(r11, new a7(new n4(new Uint8Array(e15.data), new DataView(e15.data))));
    });
  }
  async preloadASCIIRange(s15) {
    const r11 = this._getFontStack(s15), n17 = 0, i14 = 255, c13 = this._baseURL.replace("{fontstack}", s15).replace("{range}", n17 + "-" + i14), g8 = await U(c13, { responseType: "array-buffer" }), o18 = new a7(new n4(new Uint8Array(g8.data), new DataView(g8.data)));
    for (let e15 = n17; e15 <= i14; e15++) r11.getRange(e15) || r11.addRange(e15, o18);
  }
  getGlyph(e15, t22) {
    const a13 = this._getFontStack(e15);
    if (!a13) return;
    const s15 = Math.floor(t22 / 256), r11 = a13.getRange(s15);
    return r11 ? { metrics: r11.getMetrics(t22), bitmap: r11.getBitmap(t22) } : void 0;
  }
  _getFontStack(e15) {
    let t22 = this._glyphInfo[e15];
    return t22 || (t22 = this._glyphInfo[e15] = new s11()), t22;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SDFConverter.js
var o15 = 1e20;
var a8 = class {
  constructor(t22, e15 = 2) {
    this._textureSize = t22, this._rasterizationScale = e15, this._canvasSize = this._textureSize * this._rasterizationScale, this._svg = null;
    const { _canvasSize: s15 } = this, i14 = document.createElement("canvas");
    i14.width = i14.height = s15, this._context = i14.getContext("2d", { willReadFrequently: false }), this._gridOuter = new Float64Array(s15 * s15), this._gridInner = new Float64Array(s15 * s15), this._f = new Float64Array(s15), this._d = new Float64Array(s15), this._z = new Float64Array(s15 + 1), this._v = new Int16Array(s15);
  }
  dispose() {
    this._context = this._gridOuter = this._gridInner = this._f = this._d = this._z = this._v = null, this._svg = n5(this._svg);
  }
  draw(i14, r11, n17) {
    const { _canvasSize: a13, _textureSize: h13, _rasterizationScale: _6 } = this, l14 = h13 / 4;
    this._initSVG();
    const c13 = this.createSVGString(i14, r11);
    return new Promise((i15, r12) => {
      const d11 = new Image();
      d11.src = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(c13), d11.onload = () => {
        d11.onload = null, this._context.clearRect(0, 0, a13, a13), this._context.drawImage(d11, 0, 0, a13, a13);
        const e15 = this._context.getImageData(0, 0, a13, a13), s15 = new Uint8Array(h13 * h13 * 4);
        for (let t22 = 0; t22 < a13 * a13; t22++) {
          const s16 = e15.data[4 * t22 + 3] / 255;
          this._gridOuter[t22] = 1 === s16 ? 0 : 0 === s16 ? o15 : Math.max(0, 0.5 - s16) ** 2, this._gridInner[t22] = 1 === s16 ? o15 : 0 === s16 ? 0 : Math.max(0, s16 - 0.5) ** 2;
        }
        this._edt(this._gridOuter, a13, a13), this._edt(this._gridInner, a13, a13);
        for (let i16 = 0; i16 < h13 * h13; i16++) {
          let e16 = 0;
          for (let t22 = 0; t22 < _6; t22++) {
            const s16 = Math.floor(i16 / h13) * _6 + t22;
            for (let t23 = 0; t23 < _6; t23++) {
              const r13 = s16 * a13 + (i16 % h13 * _6 + t23);
              e16 += this._gridOuter[r13] - this._gridInner[r13];
            }
          }
          e16 /= _6 * _6, e16 /= _6;
          o6(0.5 - e16 / (2 * l14), s15, 4 * i16);
        }
        i15(s15);
      };
      const g8 = n17 == null ? void 0 : n17.signal;
      g8 && m(g8, () => r12(u2()));
    });
  }
  _initSVG() {
    return this._svg || (this._svg = e4()), this._svg;
  }
  createSVGString(t22, e15) {
    const s15 = this._initSVG(), i14 = t4("path");
    i14.setAttribute("d", t22), s15.appendChild(i14);
    const r11 = i14.getBBox(), o18 = r11.width / r11.height, a13 = this._canvasSize / 2;
    let h13, _6, l14;
    if (o18 > 1) {
      h13 = a13 / r11.width;
      const t23 = a13 * (1 / o18);
      _6 = this._canvasSize / 4, l14 = a13 - t23 / 2;
    } else {
      h13 = a13 / r11.height;
      _6 = a13 - a13 * o18 / 2, l14 = this._canvasSize / 4;
    }
    const c13 = -r11.x * h13 + _6, d11 = -r11.y * h13 + l14;
    i14.setAttribute("style", `transform: matrix(${h13}, 0, 0, ${h13}, ${c13}, ${d11})`), i14.setAttribute("stroke-width", "" + 0.5 / h13);
    const g8 = `<svg style="fill:${e15 ? "red" : "none"}; stroke:${e15 ? "none" : "red"}" height="${this._canvasSize}" width="${this._canvasSize}" xmlns="http://www.w3.org/2000/svg">${s15.innerHTML}</svg>`;
    return s15.removeChild(i14), g8;
  }
  _edt(t22, e15, s15) {
    const i14 = this._f, r11 = this._d, n17 = this._v, o18 = this._z;
    for (let a13 = 0; a13 < e15; a13++) {
      for (let r12 = 0; r12 < s15; r12++) i14[r12] = t22[r12 * e15 + a13];
      this._edt1d(i14, r11, n17, o18, s15);
      for (let i15 = 0; i15 < s15; i15++) t22[i15 * e15 + a13] = r11[i15];
    }
    for (let a13 = 0; a13 < s15; a13++) {
      for (let s16 = 0; s16 < e15; s16++) i14[s16] = t22[a13 * e15 + s16];
      this._edt1d(i14, r11, n17, o18, e15);
      for (let s16 = 0; s16 < e15; s16++) t22[a13 * e15 + s16] = Math.sqrt(r11[s16]);
    }
  }
  _edt1d(t22, e15, s15, i14, r11) {
    s15[0] = 0, i14[0] = -o15, i14[1] = +o15;
    for (let n17 = 1, a13 = 0; n17 < r11; n17++) {
      let e16 = (t22[n17] + n17 * n17 - (t22[s15[a13]] + s15[a13] * s15[a13])) / (2 * n17 - 2 * s15[a13]);
      for (; e16 <= i14[a13]; ) a13--, e16 = (t22[n17] + n17 * n17 - (t22[s15[a13]] + s15[a13] * s15[a13])) / (2 * n17 - 2 * s15[a13]);
      a13++, s15[a13] = n17, i14[a13] = e16, i14[a13 + 1] = +o15;
    }
    for (let n17 = 0, o18 = 0; n17 < r11; n17++) {
      for (; i14[o18 + 1] < n17; ) o18++;
      e15[n17] = (n17 - s15[o18]) * (n17 - s15[o18]) + t22[s15[o18]];
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/SpriteMosaic.js
function c8(t22) {
  return t22 && "static" === t22.type;
}
var n13 = class _n {
  constructor(t22, e15, i14 = 0) {
    this._mosaicPages = [], this._maxItemSize = 0, this._currentPage = 0, this._pageWidth = 0, this._pageHeight = 0, this._mosaicRects = /* @__PURE__ */ new Map(), this._spriteCopyQueue = [], this.pixelRatio = 1, this._pageWidth = t22, this._pageHeight = e15, i14 > 0 && (this._maxItemSize = i14), this.pixelRatio = window.devicePixelRatio || 1, this._binPack = new t18(this._pageWidth, this._pageHeight);
    const s15 = Math.floor(this._pageWidth), r11 = Math.floor(this._pageHeight);
    this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(s15 * r11) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 });
  }
  getWidth(t22) {
    return t22 >= this._mosaicPages.length ? -1 : this._mosaicPages[t22].size[0];
  }
  getHeight(t22) {
    return t22 >= this._mosaicPages.length ? -1 : this._mosaicPages[t22].size[1];
  }
  getPageTexture(t22) {
    return t22 < this._mosaicPages.length ? this._mosaicPages[t22].texture : null;
  }
  has(t22) {
    return this._mosaicRects.has(t22);
  }
  get itemCount() {
    return this._mosaicRects.size;
  }
  getSpriteItem(t22) {
    return this._mosaicRects.get(t22);
  }
  addSpriteItem(t22, i14, a13, r11, o18, h13, n17 = 1, g8 = 0.5, p7 = 1) {
    if (this._mosaicRects.has(t22)) return this._mosaicRects.get(t22);
    let m6, d11, u15;
    if (c8(a13)) [m6, d11, u15] = this._allocateImage(i14[0], i14[1]);
    else {
      m6 = new t5(0, 0, i14[0], i14[1]), d11 = this._mosaicPages.length;
      const t23 = void 0;
      this._mosaicPages.push({ mosaicsData: a13, size: [i14[0] + 2 * ti, i14[1] + 2 * ti], dirty: true, texture: t23 });
    }
    if (m6.width <= 0 || m6.height <= 0) return null;
    const l14 = { type: "sprite", rect: m6, width: i14[0], height: i14[1], sdf: o18, simplePattern: h13, rasterizationScale: n17, sdfPaddingRatio: g8, sdfDecodeCoeff: p7, page: d11 };
    return this._mosaicRects.set(t22, l14), c8(a13) && (has("esri-mosaic-debug") && this._showDebugSprite(i14, a13.data), this._copy({ rect: m6, spriteSize: i14, spriteData: a13.data, page: d11, pageSize: u15, repeat: r11, sdf: o18 })), l14;
  }
  hasItemsToProcess() {
    return 0 !== this._spriteCopyQueue.length;
  }
  processNextItem() {
    const t22 = this._spriteCopyQueue.pop();
    t22 && this._copy(t22);
  }
  getMosaicItemPosition(t22) {
    const i14 = this.getSpriteItem(t22), s15 = i14 == null ? void 0 : i14.rect;
    if (!s15) return null;
    s15.width = i14.width, s15.height = i14.height;
    const a13 = i14.width, r11 = i14.height, o18 = ti, h13 = this._mosaicPages[i14.page].size;
    return { size: [i14.width, i14.height], tl: [(s15.x + o18) / h13[0], (s15.y + o18) / h13[1]], br: [(s15.x + o18 + a13) / h13[0], (s15.y + o18 + r11) / h13[1]], page: i14.page };
  }
  bind(t22, e15, i14 = 0, s15 = 0) {
    const a13 = this._mosaicPages[i14], r11 = a13.mosaicsData;
    let o18 = a13.texture;
    if (o18 || (o18 = p6(t22, a13.size), a13.texture = o18), o18.setSamplingMode(e15), c8(r11)) t22.bindTexture(o18, s15), a13.dirty && (o18.setData(new Uint8Array(r11.data.buffer)), o18.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(i14));
    else {
      r11.data.loadFrame(o18), t22.bindTexture(o18, s15), o18.generateMipmap();
    }
    a13.dirty = false;
  }
  getTexture(t22, e15 = 0) {
    const i14 = this._mosaicPages[e15], s15 = i14.mosaicsData;
    let a13 = i14.texture;
    if (a13 || (a13 = p6(t22, i14.size), i14.texture = a13), c8(s15)) i14.dirty && (a13.setData(new Uint8Array(s15.data.buffer)), a13.generateMipmap(), has("esri-mosaic-debug") && this._showDebugPage(e15));
    else {
      s15.data.loadFrame(a13), a13.generateMipmap();
    }
    return i14.dirty = false, a13;
  }
  dispose() {
    this._binPack = null;
    for (const t22 of this._mosaicPages) {
      const e15 = t22.texture;
      e15 && e15.dispose();
      const i14 = t22.mosaicsData;
      if (!c8(i14)) {
        i14.data.destroy();
      }
    }
    this._mosaicPages = null, this._mosaicRects.clear();
  }
  static _copyBits(t22, e15, i14, s15, a13, r11, o18, h13, c13, n17, g8) {
    let p7 = s15 * e15 + i14, m6 = h13 * r11 + o18;
    if (g8) {
      m6 -= r11;
      for (let o19 = -1; o19 <= n17; o19++, p7 = ((o19 + n17) % n17 + s15) * e15 + i14, m6 += r11) for (let e16 = -1; e16 <= c13; e16++) a13[m6 + e16] = t22[p7 + (e16 + c13) % c13];
    } else for (let d11 = 0; d11 < n17; d11++) {
      for (let e16 = 0; e16 < c13; e16++) a13[m6 + e16] = t22[p7 + e16];
      p7 += e15, m6 += r11;
    }
  }
  _copy(i14) {
    if (i14.page >= this._mosaicPages.length) return;
    const s15 = this._mosaicPages[i14.page], a13 = s15.mosaicsData;
    if (!c8(s15.mosaicsData)) throw new s2("mapview-invalid-resource", "unsuitable data type!");
    const r11 = i14.spriteData, o18 = a13.data;
    _n._copyBits(r11, i14.spriteSize[0], 0, 0, o18, i14.pageSize[0], i14.rect.x + ti, i14.rect.y + ti, i14.spriteSize[0], i14.spriteSize[1], i14.repeat), s15.dirty = true;
  }
  _allocateImage(t22, r11) {
    t22 += 2 * ti, r11 += 2 * ti;
    const o18 = Math.max(t22, r11);
    if (this._maxItemSize && this._maxItemSize < o18) {
      const e15 = 2 ** Math.ceil(e10(t22)), a13 = 2 ** Math.ceil(e10(r11)), o19 = new t5(0, 0, t22, r11);
      return this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(e15 * a13) }, size: [e15, a13], dirty: true, texture: void 0 }), [o19, this._mosaicPages.length - 1, [e15, a13]];
    }
    const h13 = this._binPack.allocate(t22, r11);
    if (h13.width <= 0) {
      const e15 = this._mosaicPages[this._currentPage];
      return !e15.dirty && c8(e15.mosaicsData) && (e15.mosaicsData.data = null), this._currentPage = this._mosaicPages.length, this._mosaicPages.push({ mosaicsData: { type: "static", data: new Uint32Array(this._pageWidth * this._pageHeight) }, size: [this._pageWidth, this._pageHeight], dirty: true, texture: void 0 }), this._binPack = new t18(this._pageWidth, this._pageHeight), this._allocateImage(t22, r11);
    }
    return [h13, this._currentPage, [this._pageWidth, this._pageHeight]];
  }
  _showDebugSprite([t22, e15], i14) {
    const s15 = document.createElement("canvas");
    s15.width = t22, s15.height = e15, s15.setAttribute("style", `position: absolute; top: ${4 + 204 * g6++}px; right: 208px; width: 200px; height: 200px; border: 1px solid black;`);
    const a13 = s15.getContext("2d"), r11 = new ImageData(t22, e15);
    r11.data.set(new Uint8Array(i14.buffer)), a13.putImageData(r11, 0, 0), document.body.appendChild(s15);
  }
  _showDebugPage(t22) {
    const e15 = this._mosaicPages[t22], { size: [i14, s15], mosaicsData: a13 } = e15;
    if (!c8(a13)) return;
    const r11 = `mosaicDebugPage${t22}`, o18 = document.getElementById(r11) ?? document.createElement("canvas");
    o18.id = r11, o18.width = i14, o18.height = s15, o18.setAttribute("style", `position: absolute; top: ${4 + 204 * t22}px; right: 4px; width: 200px; height: 200px; border: 1px solid black;`);
    const h13 = o18.getContext("2d"), n17 = new ImageData(i14, s15);
    n17.data.set(new Uint8Array(a13.data.buffer)), h13.putImageData(n17, 0, 0), document.body.appendChild(o18);
  }
};
var g6 = 0;
function p6(t22, e15) {
  const i14 = new p();
  return i14.width = e15[0], i14.height = e15[1], i14.wrapMode = D.CLAMP_TO_EDGE, new m3(t22, i14, null);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/animatedFormats/AnimatableTextureResource.js
var a9 = class {
  constructor(t22, a13, h13, e15) {
    this._animation = t22, this._frameData = null;
    const n17 = (t23) => {
      this._frameData = t23, a13.requestRender();
    };
    this.frameCount = this._animation.frameDurations.length, this.width = this._animation.width, this.height = this._animation.height, this._playHandle = f5(this._animation, h13, e15, n17);
  }
  destroy() {
    this._playHandle.remove();
  }
  loadFrame(i14) {
    const a13 = this._frameData;
    if (null == a13) return;
    const h13 = "width" in a13 ? a13.width : a13.codedWidth, e15 = "height" in a13 ? a13.height : a13.codedHeight;
    i14.updateData(0, ti, ti, h13, e15, a13), this._frameData = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/animations/store/AnimationStore.js
var h8 = class {
  constructor() {
    this._entries = new l8(), this._nodes = /* @__PURE__ */ new Map(), this._book = new a10();
  }
  add(t22) {
    let e15 = this._entries.get(t22);
    if (!e15) {
      const s15 = this._book.add(t22), r11 = new Object();
      e15 = { location: s15, references: 0, handle: r11 };
      const o18 = this._entries.set(t22, e15);
      this._nodes.set(r11, o18);
    }
    return e15.references++, e15;
  }
  remove(t22) {
    const e15 = this._nodes.get(t22.handle);
    e15 && e15.payload && (e15.payload.references--, 0 === e15.payload.references && (this._book.remove(e15.payload.location), this._entries.delete(e15), this._nodes.delete(t22.handle)));
  }
  getTexture(t22, e15) {
    return this._book.getTexture(t22, e15);
  }
  destroy() {
    this._book.destroy();
  }
};
var u10 = class _u {
  constructor(t22, e15) {
    this.parent = t22, this.key = e15, this.payload = null, this._children = /* @__PURE__ */ new Map();
  }
  get(t22) {
    return this._children.get(t22);
  }
  ensure(t22) {
    let e15 = this._children.get(t22);
    return e15 || (e15 = new _u(this, t22), this._children.set(t22, e15)), e15;
  }
  delete(t22) {
    this._children.delete(t22);
  }
};
var l8 = class {
  constructor() {
    this._root = new u10(null, NaN);
  }
  set(t22, e15) {
    let s15 = this._root;
    for (const r11 of t22) for (const t23 of r11) s15 = s15.ensure(t23);
    return s15.payload = e15, s15;
  }
  delete(t22) {
    var _a;
    (_a = t22.parent) == null ? void 0 : _a.delete(t22.key);
  }
  get(t22) {
    let e15 = this._root;
    for (const s15 of t22) for (const t23 of s15) {
      const s16 = e15.get(t23);
      if (!s16) return;
      e15 = s16;
    }
    return e15.payload || void 0;
  }
};
var a10 = class {
  constructor() {
    this._pages = [];
  }
  add(t22) {
    0 === this._pages.length && this._pages.push(new _3());
    let e15 = this._pages.length - 1, s15 = this._pages[e15].add(t22);
    if (s15 || (this._pages.push(new _3()), e15 = this._pages.length - 1, s15 = this._pages[e15].add(t22)), !s15) throw new Error("Data allocation failed.");
    return { ...s15, page: e15 };
  }
  remove(t22) {
    this._pages[t22.page].remove(t22);
  }
  getTexture(t22, e15) {
    return this._pages[e15].getTexture(t22);
  }
  destroy() {
  }
};
var _3 = class {
  constructor() {
    this._cursor = { row: 0, column: 0 }, this._columns = 1024, this._rows = 1024, this._data = new Float32Array(this._columns * this._rows * 4), this._texture = null, this._textureCursor = { row: 0, column: 0 };
  }
  add(t22) {
    if (t22.length > this._columns) throw new Error(`The maximum allocation size is ${this._columns} texels.`);
    const e15 = { ...this._cursor };
    if (e15.column += t22.length, e15.column >= this._columns && (e15.column = t22.length, e15.row++), e15.row >= this._rows) return null;
    this._cursor = e15;
    const s15 = { ...this._cursor };
    s15.column -= t22.length;
    let r11 = 4 * (s15.row * this._columns + s15.column);
    for (let o18 = 0; o18 < t22.length; o18++) this._data[r11++] = t22[o18][0], this._data[r11++] = t22[o18][1], this._data[r11++] = t22[o18][2], this._data[r11++] = t22[o18][3];
    return s15;
  }
  remove(t22) {
  }
  getTexture(h13) {
    if (!this._texture) {
      const u16 = new p(this._columns, this._rows);
      u16.pixelFormat = G.RGBA, u16.dataType = U2.FLOAT, u16.wrapMode = D.CLAMP_TO_EDGE, u16.samplingMode = L2.NEAREST, u16.hasMipmap = false;
      const l15 = new a2(h13, u16);
      this._texture = new m3(h13, l15);
    }
    if (this._cursor.row === this._textureCursor.row && this._cursor.column === this._textureCursor.column) return this._texture;
    const u15 = this._textureCursor.row, l14 = this._cursor.row - u15 + 1;
    return this._texture.updateData(0, 0, u15, this._columns, l14, this._data, u15), this._textureCursor.row = this._cursor.row, this._textureCursor.column = this._cursor.column, this._texture;
  }
  destroy() {
    var _a;
    (_a = this._texture) == null ? void 0 : _a.dispose();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureManager.js
var j6 = "arial-unicode-ms-regular";
var v3 = () => n.getLogger("esri.views.2d.engine.webgl.TextureManager");
var $ = (e15, t22, i14) => v3().error(new s2(e15, t22, i14));
var A6 = class _A {
  static fromMosaic(e15, t22) {
    return new _A(e15, t22.page, t22.sdf);
  }
  constructor(e15, t22, i14) {
    this.mosaicType = e15, this.page = t22, this.sdf = i14;
  }
};
var k2 = class {
  constructor(i14) {
    this._requestRender = i14, this._resourceManager = new i7(), this._invalidFontsMap = /* @__PURE__ */ new Map(), this._sdfConverter = new a8(ei), this._bindingInfos = new Array(), this._hashToBindingIndex = /* @__PURE__ */ new Map(), this._ongoingRasterizations = /* @__PURE__ */ new Map(), this._imageRequestQueue = new _({ concurrency: 10, process: async (e15, i15) => {
      s3(i15);
      try {
        return await U(e15, { responseType: "image", signal: i15 });
      } catch (r11) {
        if (!b(r11)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${e15}`, r11);
        throw r11;
      }
    } }), this.animationStore = new h8(), this._spriteMosaic = new n13(2048, 2048, 500), this._glyphSource = new r8(`${s.fontsUrl}/{fontstack}/{range}.pbf`), this._glyphMosaic = new p5(1024, 1024, this._glyphSource), this._rasterizer = new f8(this.resourceManager);
  }
  dispose() {
    this._spriteMosaic.dispose(), this._glyphMosaic.dispose(), this._rasterizer.dispose(), this._sdfConverter.dispose(), this._spriteMosaic = null, this._glyphMosaic = null, this._sdfConverter = null, this._hashToBindingIndex.clear(), this._hashToBindingIndex = null, this._bindingInfos = null, this._ongoingRasterizations.clear(), this._ongoingRasterizations = null, this._imageRequestQueue.clear(), this._imageRequestQueue = null, this._resourceManager.destroy(), this.animationStore.destroy();
  }
  get sprites() {
    return this._spriteMosaic;
  }
  get glyphs() {
    return this._glyphMosaic;
  }
  get resourceManager() {
    return this._resourceManager;
  }
  async rasterizeItem(e15, t22) {
    if (null == e15) return $("mapview-null-resource", "Unable to rasterize null resource"), null;
    if ("animation-info" === e15.type) {
      const { resource: t23 } = e15, i15 = this.animationStore.add(t23), { location: s16 } = i15;
      return { rect: new t5(s16.column, s16.row, t23.length, 1), page: s16.page, type: "sprite", width: t23.length, height: 1, rasterizationScale: 1, sdfPaddingRatio: 0.5, sdfDecodeCoeff: 1, simplePattern: false };
    }
    if ("cim-rasterization-info" !== e15.type) return $("mapview-unexpected-resource", "Unable to rasterize resource"), null;
    const { resource: i14 } = e15;
    if ("text" === i14.type) {
      const e16 = await this._rasterizeText(i14, t22);
      for (const t23 of e16.glyphs) this._setTextureBinding(A4.GLYPH, t23);
      return e16;
    }
    const s15 = await this._rasterizeSprite(i14, t22);
    return s15 && this._setTextureBinding(A4.SPRITE, s15), s15;
  }
  getMosaicInfo(e15, t22, i14 = false) {
    const s15 = this._getTextureBindingInfo(e15, t22, i14);
    return s15 ? { size: s15.size, texture: { texture: s15.texture, unit: "sprite" === s15.type ? U3 : u5 } } : ($("mapview-invalid-resource", `Unable to find resource for ${t22}`), { size: [0, 0], texture: { texture: null, unit: 0 } });
  }
  _getTextureBindingInfo(e15, t22, i14) {
    const s15 = this._bindingInfos[t22 - 1], r11 = s15.page, a13 = i14 ? L2.LINEAR_MIPMAP_LINEAR : L2.LINEAR;
    switch (s15.mosaicType) {
      case A4.SPRITE: {
        const t23 = [this.sprites.getWidth(r11), this.sprites.getHeight(r11)], i15 = this._spriteMosaic.getTexture(e15, r11);
        return i15.setSamplingMode(a13), { type: "sprite", texture: i15, size: t23 };
      }
      case A4.GLYPH: {
        const t23 = [this.glyphs.width, this.glyphs.height], i15 = this._glyphMosaic.getTexture(e15, r11);
        return this._glyphMosaic.bind(e15, a13, r11, u5), i15.setSamplingMode(a13), { type: "glyph", texture: i15, size: t23 };
      }
      default:
        return $("mapview-texture-manager", `Cannot handle unknown type ${s15.mosaicType}`), null;
    }
  }
  _hashMosaic(e15, t22) {
    return 1 | e15 << 1 | (t22.sdf ? 1 : 0) << 2 | t22.page << 3;
  }
  _setTextureBinding(e15, t22) {
    const i14 = this._hashMosaic(e15, t22);
    if (!this._hashToBindingIndex.has(i14)) {
      const s15 = A6.fromMosaic(e15, t22), r11 = this._bindingInfos.length + 1;
      this._hashToBindingIndex.set(i14, r11), this._bindingInfos.push(s15);
    }
    t22.textureBinding = this._hashToBindingIndex.get(i14);
  }
  async _rasterizeText(e15, t22) {
    const { font: s15, textString: a13 } = e15, n17 = f4(s15), o18 = this._invalidFontsMap.has(n17), [c13, h13] = i4(a13), l14 = A2(c13);
    try {
      const e16 = o18 ? j6 : n17;
      has("esri-2d-stabilize-glyphs") && await this._glyphMosaic.preloadASCIIGlyphCache(e16);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(e16, l14, t22), isRightToLeft: h13 };
    } catch (u15) {
      $("mapview-invalid-resource", `Couldn't find font ${n17}. Falling back to Arial Unicode MS Regular`), this._invalidFontsMap.set(n17, true);
      return { type: "glyphs", glyphs: await this._glyphMosaic.getGlyphItems(j6, l14, t22), isRightToLeft: h13 };
    }
  }
  _hashSpriteResource(e15) {
    switch (e15.type) {
      case "path":
        return `path:${e15.path}.${e15.asFill ? 1 : 0}`;
      case "CIMPictureMarker":
        return `${e15.type}:${e15.url}:${e15.size}`;
      case "CIMPictureFill":
        return `${e15.type}:${e15.url}:${e15.height}`;
      case "CIMPictureStroke":
        return `${e15.type}:${e15.url}:${e15.width}`;
      case "dash":
        return `dash:${e15.capStyle}.${q(e15.dashTemplate).join("")}`;
      case "sdf":
        return `sdf:${JSON.stringify(e15.geom)}.${e15.asFill ? 1 : 0}`;
      case "fill-style":
        return `fill_style:${e15.style}`;
      case "animated":
        return JSON.stringify(j3(e15));
      case "CIMHatchFill":
      case "CIMVectorMarker":
        return JSON.stringify(e15);
    }
  }
  async _rasterizeSprite(e15, t22) {
    var _a;
    if (!e15) return null;
    const i14 = l(this._hashSpriteResource(e15));
    if (this._spriteMosaic.has(i14)) return this._spriteMosaic.getSpriteItem(i14);
    if ("url" in e15 && e15.url || "CIMPictureFill" === e15.type || "CIMPictureStroke" === e15.type || "CIMPictureMarker" === e15.type || "CIMVectorMarker" === e15.type) {
      const t23 = [];
      ee.fetchResources({ type: "CIMPointSymbol", symbolLayers: [e15] }, this._resourceManager, t23), t23.length > 0 && await Promise.all(t23);
    }
    switch (e15.type) {
      case "CIMPictureMarker":
        return "CIMMarkerPlacementInsidePolygon" === ((_a = e15.markerPlacement) == null ? void 0 : _a.type) ? this._rasterizeJSONResource(i14, e15) : this._handleAsyncResource(i14, e15, t22);
      case "animated":
      case "CIMPictureFill":
      case "CIMPictureStroke":
      case "path":
        return this._handleAsyncResource(i14, e15, t22);
      case "sdf":
      case "dash":
      case "fill-style":
      case "CIMVectorMarker":
      case "CIMHatchFill":
        return this._rasterizeJSONResource(i14, e15);
    }
  }
  _rasterizeJSONResource(e15, t22) {
    const i14 = this._rasterizer.rasterizeJSONResource(t22);
    if (i14) {
      const { size: s15, image: r11, sdf: a13, simplePattern: n17, rasterizationScale: o18, sdfPaddingRatio: c13, sdfDecodeCoeff: h13 } = i14;
      return this._addItemToMosaic(e15, s15, { type: "static", data: r11 }, F4(t22), a13, n17, o18, c13, h13);
    }
    return null;
  }
  async _handleAsyncResource(e15, t22, i14) {
    if (this._ongoingRasterizations.has(e15)) return this._ongoingRasterizations.get(e15);
    let s15;
    return s15 = "path" === t22.type ? this._handleSVG(t22, e15, i14) : this._handleImage(t22, e15, i14), this._ongoingRasterizations.set(e15, s15), s15.finally(() => this._ongoingRasterizations.delete(e15)), s15;
  }
  async _handleSVG(e15, t22, i14) {
    const s15 = [ei, ei], { asFill: r11 } = e15, a13 = await this._sdfConverter.draw(e15.path, r11, i14);
    return this._addItemToMosaic(t22, s15, { type: "static", data: new Uint32Array(a13.buffer) }, false, true, true);
  }
  async _handleGIFOrPNG(e15, t22, i14) {
    const s15 = e15.url, r11 = this.resourceManager.getResource(s15);
    if (null == r11) return null;
    const { width: a13, height: n17 } = r11;
    if (r11 instanceof HTMLImageElement) {
      if ("animated" === e15.type) return $("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
      const i15 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: s16, sdf: o19, image: c14 } = this._rasterizer.rasterizeImageResource(a13, n17, r11, i15);
      return this._addItemToMosaic(t22, s16, { type: "static", data: c14 }, F4(e15), o19, false);
    }
    let o18, c13, h13;
    "animated" === e15.type ? (o18 = false, c13 = { type: "CIMAnimatedSymbolProperties", playAnimation: e15.playAnimation, reverseAnimation: e15.reverseAnimation, randomizeStartTime: e15.randomizeStartTime, randomizeStartSeed: e15.randomizeStartSeed, startTimeOffset: e15.startTimeOffset, duration: e15.duration, repeatType: e15.repeatType, repeatDelay: e15.repeatDelay }, h13 = e15.startGroup || 0) : (o18 = F4(e15), c13 = { type: "CIMAnimatedSymbolProperties" }, h13 = 0);
    const l14 = new a9(r11, this._requestRender, c13, h13);
    return this._addItemToMosaic(t22, [l14.width, l14.height], { type: "animated", data: l14 }, o18, false, false);
  }
  async _handleImage(e15, t22, i14) {
    const r11 = e15.url;
    if (B4(r11) || N3(r11)) return this._handleGIFOrPNG(e15, t22, i14);
    if ("animated" === e15.type) return $("mapview-unexpected-resource", "Attempt to configure animations for a non-animated image."), null;
    try {
      let s15;
      const a13 = this.resourceManager.getResource(r11);
      if (null != a13 && a13 instanceof HTMLImageElement) s15 = a13;
      else {
        const { data: e16 } = await this._imageRequestQueue.push(r11, { ...i14 });
        s15 = e16;
      }
      if (y(r11)) {
        if ("width" in e15 && "height" in e15) s15.width = u3(e15.width), s15.height = u3(e15.height);
        else if ("cim" in e15) {
          const t23 = e15;
          s15.width = u3(t23.width ?? t23.scaleX * t23.size), s15.height = u3(t23.size);
        }
      }
      if (!s15.width || !s15.height) return null;
      const n17 = s15.width, o18 = s15.height, h13 = "colorSubstitutions" in e15 ? e15.colorSubstitutions : void 0, { size: l14, sdf: u15, image: p7 } = this._rasterizer.rasterizeImageResource(n17, o18, s15, h13);
      return this._addItemToMosaic(t22, l14, { type: "static", data: p7 }, F4(e15), u15, false);
    } catch ($2) {
      if (!b($2)) throw new s2("mapview-invalid-resource", `Could not fetch requested resource at ${r11}. ${$2.message}`);
      throw $2;
    }
  }
  _addItemToMosaic(e15, t22, i14, s15, r11, a13, n17, o18, c13) {
    return this._spriteMosaic.addSpriteItem(e15, t22, i14, s15, r11, a13, n17, o18, c13);
  }
};
function F4(e15) {
  switch (e15.type) {
    case "CIMVectorMarker":
    case "CIMPictureMarker":
      return O4(e15);
    default:
      return true;
  }
}
var G2 = (e15) => null != e15 && e15.startsWith("data:image/gif");
var B4 = (e15) => e15 && (e15.includes(".gif") || G2(e15));
var L6 = (e15) => null != e15 && e15.startsWith("data:image/png");
var N3 = (e15) => e15 && (e15.includes(".png") || L6(e15));
var O4 = (e15) => e15 && "markerPlacement" in e15 && e15.markerPlacement && "CIMMarkerPlacementInsidePolygon" === e15.markerPlacement.type;

// node_modules/@arcgis/core/views/2d/engine/webgl/TextureUploadManager.js
var r9 = class {
  constructor(e15) {
    this._queue = [], this._refreshable = e15;
  }
  destroy() {
    this._queue = [];
  }
  enqueueTextureUpdate(o18, r11) {
    const n17 = L(), h13 = o18, i14 = Ti, a13 = Math.ceil(h13.height / i14);
    s3(r11);
    for (let e15 = 0; e15 < a13; e15++) {
      const t22 = e15 * i14, s15 = e15 === a13 - 1, u15 = s15 ? h13.height - i14 * e15 : i14;
      this._queue.push({ type: "chunk", request: o18, resolver: n17, chunk: e15, chunkOffset: t22, destHeight: u15, chunkIsLast: s15, options: r11 });
    }
    return w(r11, (e15) => n17.reject(e15)), n17.promise;
  }
  upload() {
    let e15 = 0;
    for (; this._queue.length; ) {
      const t22 = performance.now(), s15 = this._queue.shift();
      if (s15) {
        if (null != s15.options.signal && s15.options.signal.aborted) continue;
        switch (s15.type) {
          case "chunk":
            this._uploadChunk(s15);
            break;
          case "no-chunk":
            this._uploadNoChunk(s15);
        }
        const u15 = performance.now() - t22;
        if (e15 += u15, e15 + u15 >= Ui) break;
      }
    }
    this._queue.length && this._refreshable.requestRender();
  }
  _uploadChunk(e15) {
    const { request: t22, resolver: s15, chunkOffset: o18, chunkIsLast: u15, destHeight: r11 } = e15, { data: n17, texture: h13, width: i14 } = t22;
    null != n17 && (h13.updateData(0, 0, o18, i14, r11, n17, o18), u15 && s15.resolve());
  }
  _uploadNoChunk(e15) {
    const { request: t22, resolver: s15 } = e15, { data: o18, texture: u15 } = t22;
    u15.setData(o18), s15.resolve();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/WorldExtentClipRenderer.js
var g7 = r5(-0.5, -0.5);
var b5 = class {
  constructor() {
    this._centerNdc = n2(), this._pxToNdc = n2(), this._worldDimensionsPx = n2(), this._mat3 = e6(), this._initialized = false;
  }
  dispose() {
    this._program = r2(this._program), this._quad = r2(this._quad);
  }
  render(t22, i14, e15) {
    const { context: r11 } = t22, s15 = this._updateGeometry(t22, e15);
    if (null != i14) {
      const { r: t23, g: e16, b: s16, a: o18 } = i14;
      r11.setClearColor(o18 * t23 / 255, o18 * e16 / 255, o18 * s16 / 255, o18);
    } else r11.setClearColor(0, 0, 0, 0);
    if (r11.setStencilFunction(O.ALWAYS, 0, 255), r11.setStencilWriteMask(255), !s15) return r11.setClearStencil(Bi), void r11.clear(r11.gl.STENCIL_BUFFER_BIT | r11.gl.COLOR_BUFFER_BIT);
    r11.setClearStencil(Ci), r11.clear(r11.gl.STENCIL_BUFFER_BIT | r11.gl.COLOR_BUFFER_BIT), this._initialized || this._initialize(r11), r11.setDepthWriteEnabled(false), r11.setDepthTestEnabled(false), r11.setColorMask(false, false, false, false), r11.setBlendingEnabled(false), r11.setStencilOp(I3.KEEP, I3.KEEP, I3.REPLACE), r11.setStencilFunction(O.ALWAYS, Bi, 255), r11.setStencilTestEnabled(true), r11.useProgram(this._program), this._program.setUniformMatrix3fv("u_worldExtent", this._mat3), this._quad.bind(), this._quad.draw(), this._quad.unbind();
  }
  _initialize(t22) {
    if (this._initialized) return;
    const i14 = e8(t22, r6);
    i14 && (this._program = i14, this._quad = new n8(t22, [0, 0, 1, 0, 0, 1, 1, 1]), this._initialized = true);
  }
  _updateGeometry(t22, a13) {
    const { state: n17, pixelRatio: m6 } = t22, { size: c13, rotation: h13 } = n17, d11 = Math.round(c13[0] * m6), _6 = Math.round(c13[1] * m6);
    if (!n17.spatialReference.isWrappable) return false;
    const p7 = u4(h13), f12 = Math.abs(Math.cos(p7)), u15 = Math.abs(Math.sin(p7)), b6 = Math.round(d11 * f12 + _6 * u15), x5 = Math.round(m6 * n17.worldScreenWidth);
    if (b6 <= x5) return false;
    const E6 = d11 * u15 + _6 * f12, S4 = (a13.left - a13.right) * m6 / d11, j7 = (a13.bottom - a13.top) * m6 / _6;
    o4(this._worldDimensionsPx, x5, E6, 1), o4(this._pxToNdc, 2 / d11, -2 / _6, 1), o4(this._centerNdc, S4, j7, 1);
    const C4 = this._mat3;
    return l4(C4, this._centerNdc), f2(C4, C4, this._pxToNdc), 0 !== h13 && h(C4, C4, p7), f2(C4, C4, this._worldDimensionsPx), M2(C4, C4, g7), true;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/blend/BlendTechnique.js
var f9 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Blend, this._backBufferTexture = null, this.shaders = { blend: new D3(), opacity: new v() };
  }
  shutdown() {
    super.shutdown(), null !== this._backBufferTexture && (this._backBufferTexture.dispose(), this._backBufferTexture = null);
  }
  render(t22, r11) {
    const { context: s15, state: i14, pixelRatio: o18, inFadeTransition: n17, painter: a13 } = t22, { size: c13 } = i14, f12 = s15.getBoundFramebufferObject();
    let h13, l14;
    null != f12 ? (h13 = f12.width, l14 = f12.height) : (h13 = Math.round(o18 * c13[0]), l14 = Math.round(o18 * c13[1]));
    const { blendMode: d11 } = r11;
    if ("normal" === d11) {
      const t23 = { shader: this.shaders.opacity, uniforms: { config: { layerTexture: { texture: r11.colorTexture, unit: 0 }, opacity: r11.config.opacity } }, defines: null, optionalAttributes: null, useComputeBuffer: false };
      return a13.setPipelineState(t11), void a13.submitDrawMesh(s15, t23, a13.quadMesh);
    }
    const p7 = this._createOrResizeTexture(t22, h13, l14);
    f12.copyToTexture(0, 0, h13, l14, 0, 0, p7);
    const x5 = { color: { write: [true, true, true, true], blendMode: "custom", blendParameters: { srcRGB: R.ONE, dstRGB: R.ZERO, srcAlpha: R.ONE, dstAlpha: R.ZERO } }, depth: false, stencil: false };
    a13.setPipelineState(x5);
    const b6 = { backbufferTexture: { texture: p7, unit: 0 }, layerTexture: { texture: r11.colorTexture, unit: 1 }, inFadeOpacity: n17 ? 1 : 0, ...r11.config }, T4 = { shader: this.shaders.blend, uniforms: { config: b6 }, defines: { blendMode: d11 }, optionalAttributes: null, useComputeBuffer: false };
    a13.submitDrawMesh(s15, T4, a13.quadMesh);
  }
  _createOrResizeTexture(e15, t22, r11) {
    var _a, _b;
    const { context: s15 } = e15;
    if (null !== this._backBufferTexture && ((_a = this._backBufferTexture.descriptor) == null ? void 0 : _a.width) === t22 && ((_b = this._backBufferTexture.descriptor) == null ? void 0 : _b.height) === r11) return this._backBufferTexture;
    if (null === this._backBufferTexture) {
      const e16 = new p();
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = t22, e16.height = r11, this._backBufferTexture = new m3(s15, e16);
    } else this._backBufferTexture.resize(t22, r11);
    return this._backBufferTexture;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/BlendEffect.js
var n14 = class {
  constructor() {
    this._blendTechnique = new f9();
  }
  dispose(e15) {
    var _a;
    (_a = this._blendTechnique) == null ? void 0 : _a.shutdown();
  }
  draw(e15, n17, d11, i14, o18) {
    this._blendTechnique.render(e15, { colorTexture: n17, config: { opacity: o18, samplingMode: d11 }, blendMode: i14 });
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/Effect.js
var t19 = class {
  constructor() {
    this.name = this.constructor.name;
  }
  createOptions(t22, r11) {
    return null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/FeatureEffect.js
var s12 = class extends t19 {
  constructor(e15) {
    super(), this.name = this.constructor.name, this.defines = [e15];
  }
  dispose() {
  }
  bind({ context: e15, painter: t22 }) {
    this._prev = e15.getBoundFramebufferObject();
    const s15 = t22.getFbos().effect0;
    e15.bindFramebuffer(s15), e15.setColorMask(true, true, true, true), e15.setClearColor(0, 0, 0, 0), e15.clear(e15.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  draw(e15, s15) {
    const { context: r11, painter: o18 } = e15, n17 = o18.getPostProcessingEffects(s15), c13 = r11.getBoundFramebufferObject();
    for (const { postProcessingEffect: t22, effect: f12 } of n17) t22.draw(e15, c13, f12);
    r11.bindFramebuffer(this._prev), r11.setStencilTestEnabled(false), o18.blitTexture(r11, c13.colorTexture, L2.NEAREST), r11.setStencilTestEnabled(true);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightRenderer.js
var c9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.quadGeometry.dispose(), this._resources.quadVAO.dispose(), this._resources.highlightProgram.dispose(), this._resources.blurProgram.dispose(), this._resources = null);
  }
  preBlur(e15, i14) {
    e15.bindTexture(i14, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [1, 0, 1 / this._width, 0]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", t13), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  finalBlur(e15, s15) {
    e15.bindTexture(s15, C2), e15.useProgram(this._resources.blurProgram), this._resources.blurProgram.setUniform4fv("u_direction", [0, 1, 0, 1 / this._height]), this._resources.blurProgram.setUniformMatrix4fv("u_channelSelector", c4), e15.bindVAO(this._resources.quadVAO), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  renderHighlight(e15, s15, i14) {
    e15.bindTexture(s15, C2), e15.useProgram(this._resources.highlightProgram), i14.applyHighlightOptions(e15, this._resources.highlightProgram), e15.bindVAO(this._resources.quadVAO), e15.setBlendingEnabled(true), e15.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), e15.drawArrays(E.TRIANGLE_STRIP, 0, 4), e15.bindVAO();
  }
  _initialize(s15, i14, h13) {
    this._width = i14, this._height = h13;
    const m6 = E3.createVertex(s15, F.STATIC_DRAW, new Int8Array([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]).buffer), c13 = new o7(s15, /* @__PURE__ */ new Map([["a_position", 0], ["a_texcoord", 1]]), /* @__PURE__ */ new Map([["geometry", [new t2("a_position", 2, C.BYTE, 0, 4), new t2("a_texcoord", 2, C.UNSIGNED_BYTE, 2, 4)]]]), /* @__PURE__ */ new Map([["geometry", m6]])), f12 = e8(s15, t14), b6 = e8(s15, r7);
    s15.useProgram(f12), f12.setUniform1i("u_texture", C2), f12.setUniform1i("u_shade", E2), f12.setUniform1f("u_sigma", o10), s15.useProgram(b6), b6.setUniform1i("u_texture", C2), b6.setUniform1f("u_sigma", o10), this._resources = { quadGeometry: m6, quadVAO: c13, highlightProgram: f12, blurProgram: b6 };
  }
  setup(r11, e15, s15) {
    this._resources ? (this._width = e15, this._height = s15) : this._initialize(r11, e15, s15);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/highlight/HighlightSurfaces.js
function i11(i14, h13, u15) {
  const l14 = new p(h13, u15);
  return l14.wrapMode = D.CLAMP_TO_EDGE, new x(i14, l14, new i2(B3.STENCIL_INDEX8, h13, u15));
}
var h9 = class {
  constructor() {
    this._width = void 0, this._height = void 0, this._resources = null;
  }
  dispose() {
    this._resources && (this._resources.sharedBlur1Fbo.dispose(), this._resources.sharedBlur2Fbo.dispose(), this._resources = null);
  }
  _initialize(r11, e15, s15) {
    this._width = e15, this._height = s15;
    const t22 = i11(r11, e15, s15), o18 = i11(r11, e15, s15);
    this._resources = { sharedBlur1Fbo: t22, sharedBlur2Fbo: o18 };
  }
  setup(r11, e15, s15) {
    !this._resources || this._width === e15 && this._height === s15 || this.dispose(), this._resources || this._initialize(r11, e15, s15);
  }
  get sharedBlur1Tex() {
    return this._resources.sharedBlur1Fbo.colorTexture;
  }
  get sharedBlur1Fbo() {
    return this._resources.sharedBlur1Fbo;
  }
  get sharedBlur2Tex() {
    return this._resources.sharedBlur2Fbo.colorTexture;
  }
  get sharedBlur2Fbo() {
    return this._resources.sharedBlur2Fbo;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HighlightEffect.js
var h10 = 4;
var d10 = 4 / h10;
var l9 = class extends t19 {
  constructor() {
    super(...arguments), this.defines = ["highlight"], this._hlRenderer = new c9(), this._width = void 0, this._height = void 0, this._boundFBO = null, this._hlSurfaces = new h9(), this._adjustedWidth = void 0, this._adjustedHeight = void 0, this._blitRenderer = new _2();
  }
  dispose() {
    var _a, _b;
    (_a = this._hlSurfaces) == null ? void 0 : _a.dispose(), (_b = this._hlRenderer) == null ? void 0 : _b.dispose(), this._boundFBO = null;
  }
  bind(e15) {
    const { context: t22, painter: s15 } = e15, { width: r11, height: i14 } = t22.getViewport(), h13 = s15.getFbos().effect0;
    this.setup(e15, r11, i14), t22.bindFramebuffer(h13), t22.setColorMask(true, true, true, true), t22.setClearColor(0, 0, 0, 0), t22.clear(t22.gl.COLOR_BUFFER_BIT);
  }
  unbind() {
  }
  setup({ context: e15 }, t22, s15) {
    this._width = t22, this._height = s15;
    const r11 = t22 % h10, i14 = s15 % h10;
    t22 += r11 < h10 / 2 ? -r11 : h10 - r11, s15 += i14 < h10 / 2 ? -i14 : h10 - i14, this._adjustedWidth = t22, this._adjustedHeight = s15, this._boundFBO = e15.getBoundFramebufferObject();
    const l14 = Math.round(t22 * d10), o18 = Math.round(s15 * d10);
    this._hlRenderer.setup(e15, l14, o18), this._hlSurfaces.setup(e15, l14, o18);
  }
  draw(e15) {
    const { context: t22, passOptions: s15 } = e15, r11 = s15.activeGradient, h13 = t22.getBoundFramebufferObject();
    t22.setViewport(0, 0, this._adjustedWidth * d10, this._adjustedHeight * d10), t22.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t22.setStencilTestEnabled(false), t22.setClearColor(0, 0, 0, 0), t22.clear(t22.gl.COLOR_BUFFER_BIT), this._blitRenderer.render(t22, h13.colorTexture, L2.NEAREST, 1), t22.setStencilTestEnabled(false), t22.setBlendingEnabled(false), t22.setColorMask(false, false, false, true), t22.bindFramebuffer(this._hlSurfaces.sharedBlur2Fbo), t22.setClearColor(0, 0, 0, 0), t22.clear(t22.gl.COLOR_BUFFER_BIT), this._hlRenderer.preBlur(t22, this._hlSurfaces.sharedBlur1Tex), t22.bindFramebuffer(this._hlSurfaces.sharedBlur1Fbo), t22.setClearColor(0, 0, 0, 0), t22.clear(t22.gl.COLOR_BUFFER_BIT), this._hlRenderer.finalBlur(t22, this._hlSurfaces.sharedBlur2Tex), t22.bindFramebuffer(this._boundFBO), t22.setBlendingEnabled(true), t22.setColorMask(true, true, true, true), t22.setViewport(0, 0, this._width, this._height), this._hlRenderer.renderHighlight(t22, this._hlSurfaces.sharedBlur1Tex, r11), this._boundFBO = null;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/HittestEffect.js
var c10 = class extends t19 {
  constructor() {
    super(...arguments), this.name = this.constructor.name, this.defines = ["hittest"];
  }
  dispose() {
    null != this._fbo && this._fbo.dispose();
  }
  createOptions({ pixelRatio: t22 }, r11) {
    if (!r11.length) return null;
    const n17 = r11.shift(), l14 = n17.x, c13 = n17.y;
    this._outstanding = n17;
    const a13 = has("esri-mobile");
    return { type: "hittest", distance: (a13 ? S : W) * t22, smallSymbolDistance: (a13 ? S : X) * t22, smallSymbolSizeThreshold: Y, position: [l14, c13] };
  }
  bind(e15) {
    const { context: s15, attributeView: i14 } = e15;
    if (!i14.size) return;
    const o18 = i14.getBlock(J.GPGPU);
    if (null == o18) return;
    const r11 = o18.getFBO(s15);
    s15.setViewport(0, 0, i14.size, i14.size), s15.bindFramebuffer(r11), s15.setColorMask(true, true, true, true), s15.setClearColor(0, 0, 0, 0), s15.clear(s15.gl.COLOR_BUFFER_BIT | s15.gl.DEPTH_BUFFER_BIT);
  }
  unbind() {
  }
  draw(t22) {
    if (null == this._outstanding) return;
    const e15 = this._outstanding;
    this._outstanding = null, this._resolve(t22, e15.resolvers);
  }
  async _resolve(e15, s15) {
    const { context: i14, attributeView: o18 } = e15, r11 = o18.getBlock(J.GPGPU);
    if (null == r11) return void s15.forEach((t22) => t22.resolve([]));
    const c13 = r11.getFBO(i14), a13 = new Uint8Array(c13.width * c13.height * 4);
    try {
      await c13.readPixelsAsync(0, 0, c13.width, c13.height, G.RGBA, U2.UNSIGNED_BYTE, a13);
    } catch (u15) {
      return void s15.forEach((t22) => t22.resolve([]));
    }
    const h13 = [];
    for (let t22 = 0; t22 < a13.length; t22 += 4) {
      const e16 = t22 / 4;
      a13[t22] && h13.push(e16);
    }
    s15.forEach((t22) => t22.resolve(h13));
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Bloom.js
var a11 = 5;
var u11 = [1, 0];
var l10 = [0, 1];
var m5 = [1, 0.8, 0.6, 0.4, 0.2];
var _4 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
var h11 = class {
  constructor() {
    this._intensityFBO = null, this._compositeFBO = null, this._mipsFBOs = new Array(a11), this._nMips = a11, this._kernelSizeArray = [3, 5, 7, 9, 11], this._size = [0, 0], this._programDesc = { luminosityHighPass: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/luminosityHighPass", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/bloom/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    if (this._quad = r2(this._quad), this._intensityFBO = r2(this._intensityFBO), this._compositeFBO = r2(this._compositeFBO), this._mipsFBOs) {
      for (let t22 = 0; t22 < this._nMips; t22++) this._mipsFBOs[t22] && (this._mipsFBOs[t22].horizontal.dispose(), this._mipsFBOs[t22].vertical.dispose());
      this._mipsFBOs = null;
    }
  }
  draw(t22, i14, r11) {
    const { width: o18, height: n17 } = i14, { context: h13, painter: p7 } = t22, { materialManager: c13 } = p7, d11 = h13.gl, f12 = this._programDesc, { strength: b6, radius: F5, threshold: O7 } = r11;
    this._quad || (this._quad = new n8(h13, [-1, -1, 1, -1, -1, 1, 1, 1])), this._createOrResizeResources(t22, o18, n17), h13.setStencilTestEnabled(false), h13.setBlendingEnabled(true), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilWriteMask(0);
    const B5 = this._quad;
    B5.bind(), h13.bindFramebuffer(this._intensityFBO);
    const g8 = c13.getProgram(f12.luminosityHighPass);
    h13.useProgram(g8), h13.bindTexture(i14.colorTexture, 0), g8.setUniform1i("u_texture", 0), g8.setUniform3fv("u_defaultColor", [0, 0, 0]), g8.setUniform1f("u_defaultOpacity", 0), g8.setUniform1f("u_luminosityThreshold", O7), g8.setUniform1f("u_smoothWidth", 0.01);
    const T4 = [Math.round(o18 / 2), Math.round(n17 / 2)];
    h13.setViewport(0, 0, T4[0], T4[1]), h13.setClearColor(0, 0, 0, 0), h13.clear(d11.COLOR_BUFFER_BIT), B5.draw(), h13.setBlendingEnabled(false);
    let x5 = this._intensityFBO.colorTexture;
    for (let e15 = 0; e15 < this._nMips; e15++) {
      const t23 = c13.getProgram(f12.gaussianBlur, [{ name: "radius", value: this._kernelSizeArray[e15] }]);
      h13.useProgram(t23), h13.bindTexture(x5, e15 + 1), t23.setUniform1i("u_colorTexture", e15 + 1), t23.setUniform2fv("u_texSize", T4), t23.setUniform2fv("u_direction", u11), h13.setViewport(0, 0, T4[0], T4[1]);
      const s15 = this._mipsFBOs[e15];
      h13.bindFramebuffer(s15.horizontal), B5.draw(), x5 = s15.horizontal.colorTexture, h13.bindFramebuffer(s15.vertical), h13.bindTexture(x5, e15 + 1), t23.setUniform2fv("u_direction", l10), B5.draw(), x5 = s15.vertical.colorTexture, T4[0] = Math.round(T4[0] / 2), T4[1] = Math.round(T4[1] / 2);
    }
    h13.setViewport(0, 0, o18, n17);
    const w5 = c13.getProgram(f12.composite, [{ name: "nummips", value: a11 }]);
    h13.bindFramebuffer(this._compositeFBO), h13.useProgram(w5), w5.setUniform1f("u_bloomStrength", b6), w5.setUniform1f("u_bloomRadius", F5), w5.setUniform1fv("u_bloomFactors", m5), w5.setUniform3fv("u_bloomTintColors", _4), h13.bindTexture(this._mipsFBOs[0].vertical.colorTexture, 1), w5.setUniform1i("u_blurTexture1", 1), h13.bindTexture(this._mipsFBOs[1].vertical.colorTexture, 2), w5.setUniform1i("u_blurTexture2", 2), h13.bindTexture(this._mipsFBOs[2].vertical.colorTexture, 3), w5.setUniform1i("u_blurTexture3", 3), h13.bindTexture(this._mipsFBOs[3].vertical.colorTexture, 4), w5.setUniform1i("u_blurTexture4", 4), h13.bindTexture(this._mipsFBOs[4].vertical.colorTexture, 5), w5.setUniform1i("u_blurTexture5", 5), B5.draw(), h13.bindFramebuffer(i14), h13.setBlendingEnabled(true);
    const M6 = c13.getProgram(f12.blit);
    h13.useProgram(M6), h13.bindTexture(this._compositeFBO.colorTexture, 6), M6.setUniform1i("u_texture", 6), h13.setBlendFunction(R.ONE, R.ONE), B5.draw(), B5.unbind(), h13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), h13.setStencilTestEnabled(true);
  }
  _createOrResizeResources(t22, e15, s15) {
    const { context: a13 } = t22;
    if (this._compositeFBO && this._size[0] === e15 && this._size[1] === s15) return;
    this._size[0] = e15, this._size[1] = s15;
    const u15 = [Math.round(e15 / 2), Math.round(s15 / 2)];
    if (this._compositeFBO) this._compositeFBO.resize(e15, s15);
    else {
      const t23 = new p(e15, s15);
      t23.internalFormat = G.RGBA, t23.wrapMode = D.CLAMP_TO_EDGE, this._compositeFBO = new x(a13, t23);
    }
    if (this._intensityFBO) this._intensityFBO.resize(u15[0], u15[1]);
    else {
      const t23 = new p(u15[0], u15[1]);
      t23.internalFormat = G.RGBA, t23.wrapMode = D.CLAMP_TO_EDGE, this._intensityFBO = new x(a13, t23);
    }
    for (let l14 = 0; l14 < this._nMips; l14++) {
      if (this._mipsFBOs[l14]) this._mipsFBOs[l14].horizontal.resize(u15[0], u15[1]), this._mipsFBOs[l14].vertical.resize(u15[0], u15[1]);
      else {
        const t23 = new p(u15[0], u15[1]);
        t23.internalFormat = G.RGBA, t23.wrapMode = D.CLAMP_TO_EDGE, this._mipsFBOs[l14] = { horizontal: new x(a13, t23), vertical: new x(a13, t23) };
      }
      u15[0] = Math.round(u15[0] / 2), u15[1] = Math.round(u15[1] / 2);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Blur.js
var n15 = [1, 0];
var o16 = [0, 1];
var u12 = class {
  constructor() {
    this._blurFBO = null, this._size = [0, 0], this._programDesc = { gaussianBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, radialBlur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/radial-blur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._blurFBO && (this._blurFBO.dispose(), this._blurFBO = null);
  }
  draw(t22, s15, r11) {
    const { context: i14 } = t22, { type: a13, radius: n17 } = r11;
    if (0 === n17) return;
    this._createOrResizeResources(t22), this._quad || (this._quad = new n8(i14, [-1, -1, 1, -1, -1, 1, 1, 1]));
    const o18 = this._quad;
    o18.bind(), "blur" === a13 ? this._gaussianBlur(t22, s15, n17) : this._radialBlur(t22, s15), o18.unbind();
  }
  _gaussianBlur(e15, s15, r11) {
    const { context: i14, state: a13, painter: u15, pixelRatio: l14 } = e15, { size: d11 } = a13, { materialManager: b6 } = u15, c13 = this._programDesc, _6 = this._quad, p7 = [Math.round(l14 * d11[0]), Math.round(l14 * d11[1])], h13 = this._blurFBO, m6 = b6.getProgram(c13.gaussianBlur, [{ name: "radius", value: Math.ceil(r11) }]);
    i14.useProgram(m6), i14.setBlendingEnabled(false), i14.bindFramebuffer(h13), i14.bindTexture(s15.colorTexture, 4), m6.setUniform1i("u_colorTexture", 4), m6.setUniform2fv("u_texSize", p7), m6.setUniform2fv("u_direction", n15), m6.setUniform1f("u_sigma", r11), _6.draw(), i14.bindFramebuffer(s15), i14.setStencilWriteMask(0), i14.setStencilTestEnabled(false), i14.setDepthWriteEnabled(false), i14.setDepthTestEnabled(false), i14.bindTexture(h13 == null ? void 0 : h13.colorTexture, 5), m6.setUniform1i("u_colorTexture", 5), m6.setUniform2fv("u_direction", o16), _6.draw(), i14.setBlendingEnabled(true), i14.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), i14.setStencilTestEnabled(true);
  }
  _radialBlur(e15, s15) {
    const { context: r11, painter: i14 } = e15, { materialManager: a13 } = i14, n17 = this._programDesc, o18 = this._quad, u15 = this._blurFBO;
    r11.bindFramebuffer(u15);
    const l14 = a13.getProgram(n17.radialBlur);
    r11.useProgram(l14), r11.setBlendingEnabled(false), r11.bindTexture(s15.colorTexture, 4), l14.setUniform1i("u_colorTexture", 4), o18.draw(), r11.bindFramebuffer(s15), r11.setStencilWriteMask(0), r11.setStencilTestEnabled(false), r11.setDepthWriteEnabled(false), r11.setDepthTestEnabled(false), r11.setBlendingEnabled(true);
    const d11 = a13.getProgram(n17.blit);
    r11.useProgram(d11), r11.bindTexture(u15 == null ? void 0 : u15.colorTexture, 5), d11.setUniform1i("u_texture", 5), r11.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), o18.draw();
  }
  _createOrResizeResources(e15) {
    const { context: t22, state: n17, pixelRatio: o18 } = e15, { size: u15 } = n17, l14 = Math.round(o18 * u15[0]), d11 = Math.round(o18 * u15[1]);
    if (!this._blurFBO || this._size[0] !== l14 || this._size[1] !== d11) if (this._size[0] = l14, this._size[1] = d11, this._blurFBO) this._blurFBO.resize(l14, d11);
    else {
      const e16 = new p(l14, d11);
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._blurFBO = new x(t22, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Colorize.js
var n16 = class {
  constructor() {
    this._layerFBOTexture = null, this._size = [0, 0], this._programDesc = { vsPath: "post-processing/pp", fsPath: "post-processing/filterEffect", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, t22, s15) {
    const { width: i14, height: o18 } = t22;
    this._createOrResizeResources(e15, i14, o18);
    const { context: a13, painter: n17 } = e15, { materialManager: c13 } = n17, l14 = this._programDesc, u15 = this._quad, _6 = s15.colorMatrix;
    u15.bind();
    const h13 = this._layerFBOTexture;
    a13.bindFramebuffer(t22), t22.copyToTexture(0, 0, i14, o18, 0, 0, h13), a13.setBlendingEnabled(false), a13.setStencilTestEnabled(false);
    const m6 = c13.getProgram(l14);
    a13.useProgram(m6), a13.bindTexture(h13, 2), m6.setUniformMatrix4fv("u_coefficients", _6), m6.setUniform1i("u_colorTexture", 2), u15.draw(), a13.setBlendingEnabled(true), a13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), a13.setStencilTestEnabled(true), u15.unbind();
  }
  _createOrResizeResources(e15, r11, n17) {
    const { context: c13 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== r11 || this._size[1] !== n17) {
      if (this._size[0] = r11, this._size[1] = n17, this._layerFBOTexture) this._layerFBOTexture.resize(r11, n17);
      else {
        const e16 = new p();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = r11, e16.height = n17, this._layerFBOTexture = new m3(c13, e16);
      }
      this._quad || (this._quad = new n8(c13, [-1, -1, 1, -1, -1, 1, 1, 1]));
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/DropShadow.js
var u13 = [1, 0];
var h12 = [0, 1];
var _5 = class {
  constructor() {
    this._layerFBOTexture = null, this._horizontalBlurFBO = null, this._verticalBlurFBO = null, this._size = [0, 0], this._quad = null, this._programDesc = { blur: { vsPath: "post-processing/pp", fsPath: "post-processing/blur/gaussianBlur", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, composite: { vsPath: "post-processing/pp", fsPath: "post-processing/drop-shadow/composite", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) }, blit: { vsPath: "post-processing/pp", fsPath: "post-processing/blit", attributes: /* @__PURE__ */ new Map([["a_position", 0]]) } };
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture), this._horizontalBlurFBO = r2(this._horizontalBlurFBO), this._verticalBlurFBO = r2(this._verticalBlurFBO);
  }
  draw(e15, i14, o18) {
    const { context: a13, state: n17, painter: l14 } = e15, { materialManager: _6 } = l14, c13 = this._programDesc, p7 = i14.width, m6 = i14.height, f12 = [Math.round(p7), Math.round(m6)], { blurRadius: B5, offsetX: d11, offsetY: b6, color: O7 } = o18, F5 = [u3(d11), u3(b6)];
    this._createOrResizeResources(e15, p7, m6, f12);
    const w5 = this._horizontalBlurFBO, T4 = this._verticalBlurFBO;
    a13.setStencilWriteMask(0), a13.setStencilTestEnabled(false), a13.setDepthWriteEnabled(false), a13.setDepthTestEnabled(false);
    const x5 = this._layerFBOTexture;
    i14.copyToTexture(0, 0, p7, m6, 0, 0, x5), this._quad || (this._quad = new n8(a13, [-1, -1, 1, -1, -1, 1, 1, 1])), a13.setViewport(0, 0, f12[0], f12[1]);
    const g8 = this._quad;
    g8.bind(), a13.setBlendingEnabled(false);
    const z3 = _6.getProgram(c13.blur, [{ name: "radius", value: Math.ceil(B5) }]);
    a13.useProgram(z3), a13.bindFramebuffer(w5), a13.bindTexture(i14.colorTexture, 4), z3.setUniform1i("u_colorTexture", 4), z3.setUniform2fv("u_texSize", f12), z3.setUniform2fv("u_direction", u13), z3.setUniform1f("u_sigma", B5), g8.draw(), a13.bindFramebuffer(T4), a13.bindTexture(w5 == null ? void 0 : w5.colorTexture, 5), z3.setUniform1i("u_colorTexture", 5), z3.setUniform2fv("u_direction", h12), g8.draw(), a13.bindFramebuffer(i14), a13.setViewport(0, 0, p7, m6);
    const M6 = _6.getProgram(c13.composite);
    a13.useProgram(M6), a13.bindTexture(T4 == null ? void 0 : T4.colorTexture, 2), M6.setUniform1i("u_blurTexture", 2), a13.bindTexture(x5, 3), M6.setUniform1i("u_layerFBOTexture", 3), M6.setUniform4fv("u_shadowColor", [O7[3] * (O7[0] / 255), O7[3] * (O7[1] / 255), O7[3] * (O7[2] / 255), O7[3]]), M6.setUniformMatrix3fv("u_displayViewMat3", n17.displayMat3), M6.setUniform2fv("u_shadowOffset", F5), g8.draw(), a13.setBlendingEnabled(true), a13.setStencilTestEnabled(true), a13.setBlendFunction(R.ONE, R.ONE_MINUS_SRC_ALPHA), g8.unbind();
  }
  _createOrResizeResources(e15, t22, r11, s15) {
    const { context: u15 } = e15;
    if (!this._horizontalBlurFBO || this._size[0] !== t22 || this._size[1] !== r11) {
      if (this._size[0] = t22, this._size[1] = r11, this._horizontalBlurFBO) this._horizontalBlurFBO.resize(s15[0], s15[1]);
      else {
        const e16 = new p(s15[0], s15[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._horizontalBlurFBO = new x(u15, e16);
      }
      if (this._verticalBlurFBO) this._verticalBlurFBO.resize(s15[0], s15[1]);
      else {
        const e16 = new p(s15[0], s15[1]);
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, this._verticalBlurFBO = new x(u15, e16);
      }
      if (this._layerFBOTexture) this._layerFBOTexture.resize(t22, r11);
      else {
        const e16 = new p();
        e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.width = t22, e16.height = r11, this._layerFBOTexture = new m3(u15, e16);
      }
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/Opacity.js
var l11 = class {
  constructor() {
    this._size = [0, 0], this._layerFBOTexture = null;
  }
  dispose() {
    this._layerFBOTexture = r2(this._layerFBOTexture);
  }
  draw(e15, r11, s15) {
    const { width: i14, height: o18 } = r11;
    this._createOrResizeResources(e15, i14, o18);
    const { context: l14, painter: a13 } = e15, { amount: n17 } = s15, h13 = l14.gl, u15 = this._layerFBOTexture;
    l14.bindFramebuffer(r11), r11.copyToTexture(0, 0, i14, o18, 0, 0, u15), l14.setBlendingEnabled(true), l14.setStencilTestEnabled(false), l14.setDepthTestEnabled(false), l14.setClearColor(0, 0, 0, 0), l14.clear(h13.COLOR_BUFFER_BIT), a13.blitTexture(l14, u15, L2.NEAREST, n17);
  }
  _createOrResizeResources(e15, l14, a13) {
    const { context: n17 } = e15;
    if (!this._layerFBOTexture || this._size[0] !== l14 || this._size[1] !== a13) if (this._size[0] = l14, this._size[1] = a13, this._layerFBOTexture) this._layerFBOTexture.resize(l14, a13);
    else {
      const e16 = new p();
      e16.internalFormat = G.RGBA, e16.wrapMode = D.CLAMP_TO_EDGE, e16.samplingMode = L2.NEAREST, e16.width = l14, e16.height = a13, this._layerFBOTexture = new m3(n17, e16);
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/effects/post-processing/EffectManager.js
function c11(o18) {
  switch (o18) {
    case "bloom":
    case "blur":
    case "opacity":
    case "drop-shadow":
      return o18;
    default:
      return "colorize";
  }
}
var f10 = { colorize: () => new n16(), blur: () => new u12(), bloom: () => new h11(), opacity: () => new l11(), "drop-shadow": () => new _5() };
var i12 = class {
  constructor() {
    this._effectMap = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._effectMap.forEach((o18) => o18.dispose()), this._effectMap.clear();
  }
  getPostProcessingEffects(o18) {
    if (!o18 || 0 === o18.length) return [];
    const e15 = [];
    for (const t22 of o18) {
      const o19 = c11(t22.type);
      let s15 = this._effectMap.get(o19);
      s15 || (s15 = f10[o19](), this._effectMap.set(o19, s15)), e15.push({ postProcessingEffect: s15, effect: t22 });
    }
    return e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/painter/RenderPass.js
var t20 = class {
  constructor(e15, t22) {
    this.brushes = e15, this.name = t22.name, this.drawPhase = t22.drawPhase || E4.MAP, this._targetFn = t22.target, this.effects = t22.effects || [], this.enableDefaultDraw = t22.enableDefaultDraw ?? (() => true), this.forceDrawByDisplayOrder = !!t22.forceDrawByDisplayOrder;
  }
  render(e15) {
    var _a;
    const { context: r11, profiler: t22 } = e15, s15 = this._targetFn(), a13 = this.drawPhase & e15.drawPhase;
    if (t22.recordPassStart(this.name), a13) {
      this.enableDefaultDraw() && this._doRender(e15, s15), t22.recordPassEnd();
      for (const t23 of this.effects) {
        if (!t23.enable()) continue;
        const a14 = t23.apply, n17 = (_a = t23.args) == null ? void 0 : _a.call(t23), i14 = r11.getViewport(), o18 = r11.getBoundFramebufferObject(), d11 = e15.passOptions;
        this._bindEffect(e15, a14, n17), this._doRender(e15, s15, a14.defines), this._drawAndUnbindEffect(e15, a14, i14, o18, d11, n17);
      }
    }
  }
  _doRender(e15, r11, t22) {
    if (null == r11) return;
    const { profiler: s15, context: a13 } = e15;
    for (const n17 of this.brushes) {
      if (s15.recordBrushStart(n17.name), null != n17.brushEffect) {
        const s16 = a13.getViewport(), i14 = a13.getBoundFramebufferObject(), o18 = e15.passOptions;
        this._bindEffect(e15, n17.brushEffect), this._drawWithBrush(n17, e15, r11, t22), this._drawAndUnbindEffect(e15, n17.brushEffect, s16, i14, o18);
      } else this._drawWithBrush(n17, e15, r11, t22);
      s15.recordBrushEnd();
    }
  }
  _drawWithBrush(r11, t22, s15, a13) {
    d(s15) ? (r11.prepareState(t22, a13), r11.drawMany(t22, s15, a13)) : s15.visible && (r11.prepareState(t22, a13), r11.draw(t22, s15, a13));
  }
  _bindEffect(e15, r11, t22) {
    const { profiler: s15 } = e15;
    s15.recordPassStart(this.name + "." + r11.name), r11.bind(e15, t22);
    const a13 = r11.createOptions(e15, t22);
    e15.passOptions = a13;
  }
  _drawAndUnbindEffect(e15, r11, t22, s15, a13, n17) {
    const { profiler: i14, context: o18 } = e15;
    e15.passOptions = a13, i14.recordBrushStart(r11.name), r11.draw(e15, n17), r11.unbind(e15, n17), o18.bindFramebuffer(s15);
    const { x: d11, y: f12, width: h13, height: c13 } = t22;
    o18.setViewport(d11, f12, h13, c13), i14.recordBrushEnd(), i14.recordPassEnd();
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/TechniqueProgramCache.js
var r10 = class {
  constructor() {
    this._programCache = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const r11 of this._programCache.values()) r11.destroy();
    this._programCache.clear();
  }
  getProgram(r11, e15, t22, a13, o18) {
    const s15 = r11.getShaderKey(e15, t22, a13, o18);
    let c13 = this._programCache.get(s15);
    return c13 || (c13 = r11.getProgram(e15, t22, a13, o18), this._programCache.set(s15, c13)), c13;
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/Painter.js
var O5 = class {
  constructor(e15, t22) {
    this.context = e15, this._currentPipelineStateNeedsUpdate = false, this._blitRenderer = new _2(), this._worldExtentRenderer = new b5(), this._brushCache = /* @__PURE__ */ new Map(), this._lastWidth = null, this._lastHeight = null, this._vtlMaterialManager = new p4(), this._blendEffect = new n14(), this._stencilBuf = null, this._prevBeforeLayerFBOStack = [], this._fboPool = [], this.effects = { highlight: new l9(), hittest: new c10(), insideEffect: new s12("inside"), outsideEffect: new s12("outside") }, this._programCache = new r10(), this._shaderState = { shader: null, uniforms: null, defines: null, optionalAttributes: null, useComputeBuffer: false }, this.materialManager = new e14(e15), this.textureManager = new k2(t22), this.textureUploadManager = new r9(t22), this._effectsManager = new i12(), this._quadMesh = o11.fromVertexStream(e15, [0, 0, 1, 0, 0, 1, 1, 1]);
  }
  dispose() {
    if (this._programCache.destroy(), this.materialManager.dispose(), this.textureManager.dispose(), this.textureUploadManager.destroy(), this._blitRenderer = r2(this._blitRenderer), this._worldExtentRenderer = r2(this._worldExtentRenderer), this._quadMesh = u(this._quadMesh), this._brushCache && (this._brushCache.forEach((e15) => e15.dispose()), this._brushCache.clear(), this._brushCache = null), this._fbos) {
      let e15;
      for (e15 in this._fbos) this._fbos[e15] && this._fbos[e15].dispose();
    }
    for (const e15 of this._fboPool) e15.dispose();
    if (this._fboPool.length = 0, this.effects) {
      let e15;
      for (e15 in this.effects) this.effects[e15] && this.effects[e15].dispose();
    }
    this._effectsManager.dispose(), this._blendEffect.dispose(this.context), this._vtlMaterialManager = r2(this._vtlMaterialManager);
  }
  clearShaderCache() {
    this._programCache.destroy(), this._programCache = new r10();
  }
  get blitRenderer() {
    return this._blitRenderer;
  }
  get vectorTilesMaterialManager() {
    return this._vtlMaterialManager;
  }
  get quadMesh() {
    return this._quadMesh;
  }
  getFbos() {
    if (!this._fbos) throw new Error("InternalError: Painter FBOs not initialized");
    return this._fbos;
  }
  acquireFbo(e15, t22) {
    let s15;
    if (this._fboPool.length > 0) s15 = this._fboPool.pop();
    else {
      const r11 = new p(e15, t22);
      r11.samplingMode = L2.NEAREST, r11.wrapMode = D.CLAMP_TO_EDGE, s15 = new x(this.context, r11, this._stencilBuf);
    }
    return s15.width === e15 && s15.height === t22 || s15.resize(e15, t22), s15;
  }
  releaseFbo(e15) {
    this._fboPool.push(e15);
  }
  getSharedStencilBuffer() {
    return this._stencilBuf;
  }
  beforeRenderPhases(e15, t22, s15) {
    const { context: r11 } = e15;
    this._worldExtentRenderer.render(e15, t22, s15);
    const { width: i14, height: n17 } = r11.getViewport();
    if (this.updateFBOs(i14, n17), this._prevFBO = r11.getBoundFramebufferObject(), r11.bindFramebuffer(this.getFbos().output), r11.setColorMask(true, true, true, true), null != t22) {
      const { r: e16, g: s16, b: i15, a: n18 } = t22;
      r11.setClearColor(n18 * e16 / 255, n18 * s16 / 255, n18 * i15 / 255, n18);
    } else r11.setClearColor(0, 0, 0, 0);
    r11.setDepthWriteEnabled(true), r11.setClearDepth(1), r11.clear(r11.gl.COLOR_BUFFER_BIT | r11.gl.DEPTH_BUFFER_BIT), r11.setDepthWriteEnabled(false);
  }
  afterRenderPhases(e15) {
    const { context: t22 } = e15;
    t22.bindFramebuffer(this._prevFBO), t22.setStencilFunction(O.EQUAL, Bi, 255), t22.setStencilTestEnabled(true), t22.setDepthTestEnabled(false), this.blitTexture(t22, this.getFbos().output.colorTexture, L2.NEAREST);
  }
  beforeRenderLayer(e15, t22, s15) {
    const { context: r11, blendMode: i14, effects: n17, drawPhase: a13, requireFBO: o18 } = e15;
    if (o18 || A7(a13, i14, n17, s15)) {
      const e16 = r11.getBoundFramebufferObject();
      this._prevBeforeLayerFBOStack.push(e16);
      const { width: t23, height: s16 } = r11.getViewport(), i15 = this.acquireFbo(t23, s16);
      r11.bindFramebuffer(i15), r11.setColorMask(true, true, true, true), r11.setClearColor(0, 0, 0, 0), r11.setDepthWriteEnabled(true), r11.setClearDepth(1), r11.clear(r11.gl.COLOR_BUFFER_BIT | r11.gl.DEPTH_BUFFER_BIT), r11.setDepthWriteEnabled(false);
    }
    r11.setDepthWriteEnabled(false), r11.setDepthTestEnabled(false), r11.setStencilTestEnabled(true), r11.setClearStencil(t22), r11.setStencilWriteMask(255), r11.clear(r11.gl.STENCIL_BUFFER_BIT);
  }
  afterRenderLayer(e15, t22) {
    const { context: s15, blendMode: r11, effects: i14, requireFBO: n17, drawPhase: o18 } = e15;
    if (n17 || A7(o18, r11, i14, t22)) {
      const n18 = s15.getBoundFramebufferObject();
      null != i14 && i14.length > 0 && o18 === E4.MAP && (s15.setColorMask(true, true, true, true), this._applyEffects(e15, i14, n18)), s15.bindFramebuffer(this._prevBeforeLayerFBOStack.pop()), s15.setStencilTestEnabled(false), s15.setStencilWriteMask(0), s15.setBlendingEnabled(true), s15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), s15.setColorMask(true, true, true, true);
      const l14 = null == r11 || o18 === E4.HIGHLIGHT || o18 === E4.LABEL ? "normal" : r11;
      this._blendEffect.draw(e15, n18.colorTexture, L2.NEAREST, l14, t22), this.releaseFbo(n18);
    }
  }
  renderObject(e15, t22, r11, i14) {
    const n17 = t10[r11];
    if (!n17) return;
    let a13 = this._brushCache.get(n17);
    void 0 === a13 && (a13 = new n17(), this._brushCache.set(n17, a13)), a13.prepareState(e15), a13.draw(e15, t22, i14);
  }
  renderObjects(e15, t22, r11, i14) {
    const n17 = t10[r11];
    if (!n17) return;
    let a13 = this._brushCache.get(n17);
    void 0 === a13 && (a13 = new n17(), this._brushCache.set(n17, a13)), a13.drawMany(e15, t22, i14);
  }
  registerRenderPass(e15) {
    const t22 = e15.brushes.map((e16) => (this._brushCache.has(e16) || this._brushCache.set(e16, new e16()), this._brushCache.get(e16)));
    return new t20(t22, e15);
  }
  blitTexture(e15, t22, s15, r11 = 1) {
    e15.setBlendingEnabled(true), e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA), e15.setColorMask(true, true, true, true), this._blitRenderer.render(e15, t22, s15, r11), this._currentPipelineStateNeedsUpdate = true;
  }
  getPostProcessingEffects(e15) {
    return this._effectsManager.getPostProcessingEffects(e15);
  }
  updateFBOs(e15, t22) {
    if (e15 !== this._lastWidth || t22 !== this._lastHeight) {
      if (this._lastWidth = e15, this._lastHeight = t22, this._fbos) {
        let s16;
        for (s16 in this._fbos) this._fbos[s16].resize(e15, t22);
        return;
      }
      const s15 = new p(e15, t22);
      s15.samplingMode = L2.NEAREST, s15.wrapMode = D.CLAMP_TO_EDGE;
      const r11 = new i2(B3.DEPTH_STENCIL, e15, t22);
      this._stencilBuf = new s7(this.context, r11), this._fbos = { output: new x(this.context, s15, this._stencilBuf), effect0: new x(this.context, s15, this._stencilBuf) };
    }
  }
  _applyEffects(e15, t22, s15) {
    const { context: r11 } = e15, i14 = this._effectsManager.getPostProcessingEffects(t22);
    for (const { postProcessingEffect: n17, effect: a13 } of i14) r11.bindFramebuffer(s15), n17.draw(e15, s15, a13);
    this._currentPipelineStateNeedsUpdate = true;
  }
  setShader(e15) {
    this._shaderState.shader = e15.shader, this._shaderState.uniforms = e15.uniforms, this._shaderState.defines = e15.defines, this._shaderState.optionalAttributes = e15.optionalAttributes, this._shaderState.useComputeBuffer = e15.useComputeBuffer ?? false;
  }
  setPipelineState(e15) {
    e15 !== this._currentPipelineState && (this._currentPipelineState = e15, this._currentPipelineStateNeedsUpdate = true);
  }
  submitDraw(e15, t22) {
    const { shader: s15, uniforms: r11, defines: i14, optionalAttributes: n17 } = this._shaderState, a13 = e15.context, o18 = t22.getAttributePrecisionPackFactors(), l14 = this._programCache.getProgram(s15, o18, r11, i14 ?? {}, n17 ?? {});
    return l14.setUniforms(r11), l14.bind(a13), this.updatePipelineState(a13), this.setStencilRef(a13, t22), t22.draw(e15, s15.locationInfo), l14.cleanupTemporaryTextures(), { vertexShader: l14.vertexShader, fragmentShader: l14.fragmentShader };
  }
  submitDrawMesh(e15, t22, s15, r11) {
    this.submitDrawMeshUntyped(e15, t22, s15, r11);
  }
  submitDrawMeshUntyped(e15, t22, s15, r11) {
    this.setShader(t22);
    const { shader: i14, uniforms: n17, defines: a13, optionalAttributes: o18 } = this._shaderState, l14 = this._programCache.getProgram(i14, {}, n17, a13 ?? {}, o18 ?? {});
    if (l14.setUniforms(n17), l14.bind(e15), this.updatePipelineState(e15), r11) for (const h13 of r11) s15.bind(e15, h13), s15.draw(e15);
    else for (let h13 = 0; h13 < s15.parts.length; h13++) s15.bind(e15, h13), s15.draw(e15);
    s15.unbind(e15), l14.cleanupTemporaryTextures();
  }
  updatePipelineState(e15) {
    this._currentPipelineStateNeedsUpdate && (this._currentPipelineStateNeedsUpdate = false, this._updatePipelineState(e15));
  }
  _updatePipelineState(e15) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { color: t22, depth: s15, stencil: r11 } = this._currentPipelineState;
    if (t22) {
      const { blendMode: s16, write: r12 } = t22;
      switch (e15.setColorMask(...r12), e15.setBlendingEnabled(true), e15.setBlendEquation(T.ADD), s16) {
        case "composite":
          e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
          break;
        case "additive":
          e15.setBlendFunctionSeparate(R.ONE, R.ONE, R.ONE, R.ONE);
          break;
        case "custom": {
          const { blendParameters: s17 } = t22, { dstAlpha: r13, dstRGB: i14, srcAlpha: n17, srcRGB: a13 } = s17;
          e15.setBlendFunctionSeparate(a13, i14, n17, r13);
          break;
        }
        case "delete":
          e15.setBlendEquation(T.REVERSE_SUBTRACT), e15.setBlendFunctionSeparate(R.ONE, R.ONE_MINUS_SRC_ALPHA, R.ONE, R.ONE_MINUS_SRC_ALPHA);
      }
    }
    if (s15) {
      const { test: t23, write: r12 } = s15;
      r12 ? (e15.setDepthWriteEnabled(true), e15.setDepthRange(r12.zNear, r12.zFar)) : e15.setDepthWriteEnabled(false), t23 ? (e15.setDepthTestEnabled(true), e15.setDepthFunction(t23)) : e15.setDepthTestEnabled(false);
    } else e15.setDepthTestEnabled(false), e15.setDepthWriteEnabled(false);
    if (r11) {
      const { test: t23, write: s16 } = r11;
      if (t23) {
        const { compare: s17, mask: r12, op: i14, ref: n17 } = t23;
        e15.setStencilTestEnabled(true), "function" != typeof n17 && e15.setStencilFunctionSeparate(N.FRONT_AND_BACK, s17, n17, r12), e15.setStencilOpSeparate(N.FRONT_AND_BACK, i14.fail, i14.zFail, i14.zPass);
      } else e15.setStencilTestEnabled(false);
      if (s16) {
        const { mask: t24 } = s16;
        e15.setStencilWriteMask(t24);
      } else e15.setStencilWriteMask(0);
    } else e15.setStencilTestEnabled(false), e15.setStencilWriteMask(0);
  }
  setStencilRef(e15, t22) {
    if (null == this._currentPipelineState) throw new Error("Pipeline state not defined. Call setPipelineState before calling submitDraw ");
    const { stencil: s15 } = this._currentPipelineState;
    if (s15) {
      const { test: r11 } = s15;
      if (r11) {
        const { compare: s16, mask: i14, ref: n17 } = r11;
        if ("function" == typeof n17) {
          const r12 = t22.getStencilReference();
          if (null === r12) throw new Error("InternalError: Stencil reference expected for target but not defined");
          e15.setStencilFunctionSeparate(N.FRONT_AND_BACK, s16, r12, i14);
        }
      }
    }
  }
};
function A7(e15, t22, s15, r11) {
  return e15 !== E4.LABEL_ALPHA && e15 !== E4.LABEL && e15 !== E4.HIGHLIGHT && (1 !== r11 || null != t22 && "normal" !== t22 || null != s15 && s15.length > 0);
}

// node_modules/@arcgis/core/views/2d/engine/webgl/TileReshuffleManager.js
var s13 = class {
  constructor() {
    this._candidateTiles = [];
  }
  schedule(s15) {
    this._candidateTiles.includes(s15) || this._candidateTiles.push(s15);
  }
  reshuffle(s15) {
    const e15 = [];
    for (const i14 of this._candidateTiles) s15 > 0 ? (i14.reshuffle(), s15--) : e15.push(i14);
    this._candidateTiles = e15;
  }
};

// node_modules/@arcgis/core/views/2d/engine/Stage.js
var M4 = 2e3;
var O6 = class extends n7 {
  constructor(t22, i14) {
    super(), this.meshWriterRegistry = new j4(), this._trash = /* @__PURE__ */ new Set(), this._renderRemainingTime = 0, this._lastFrameRenderTime = 0, this._renderRequested = r4(false), this.stage = this, this._stationary = true, this._reshuffleManager = new s13(), this._canvas = new c6(t22), this.context = new y3(this._canvas.gl, i14.contextOptions ?? {}), this.painter = new O5(this.context, this), this._cimAnalyzer = new H2(this.painter.textureManager.resourceManager), has("esri-2d-profiler") && (this._debugOutput = document.createElement("div"), this._debugOutput.setAttribute("style", "margin: 24px 64px; position: absolute; color: red;"), t22.appendChild(this._debugOutput));
    const a13 = () => this.highlightGradient;
    this._renderParameters = { drawPhase: 0, state: this.state, pixelRatio: window.devicePixelRatio, stationary: false, globalOpacity: 1, blendMode: null, deltaTime: -1, time: 0, inFadeTransition: false, effects: null, context: this.context, painter: this.painter, timeline: i14.timeline || new e12(), renderingOptions: i14.renderingOptions, requestRender: () => this.requestRender(), allowDelayedRender: false, requireFBO: false, profiler: new n9(this.context, this._debugOutput), dataUploadCounter: 0, get highlightGradient() {
      return a13();
    }, reshuffleManager: this._reshuffleManager, backgroundColor: i14.backgroundColor }, this._taskHandle = A({ render: (e15) => this.renderFrame(e15) }), this._taskHandle.pause(), this._lostWebGLContextHandle = this._canvas.events.on("webgl-context-lost", (t23) => this.emit("webgl-error", { error: new s2("webgl-context-lost", t23.statusMessage) })), this._bufferPool = new i8(), w3();
  }
  destroy() {
    var _a, _b;
    j5(this.context), this.removeAllChildren(), this._emptyTrash(), this._taskHandle = l2(this._taskHandle), this._lostWebGLContextHandle = l2(this._lostWebGLContextHandle), this._canvas.destroy(), (_b = (_a = this._debugOutput) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.removeChild(this._debugOutput), this._bufferPool.destroy(), this.painter.dispose(), this.context.dispose(), this._canvas = null;
  }
  get textureManager() {
    return this.painter.textureManager;
  }
  get backgroundColor() {
    return this._renderParameters.backgroundColor;
  }
  set backgroundColor(e15) {
    this._renderParameters.backgroundColor = e15, this.requestRender();
  }
  get bufferPool() {
    return this._bufferPool;
  }
  get cimAnalyzer() {
    return this._cimAnalyzer;
  }
  get renderingOptions() {
    return this._renderingOptions;
  }
  set renderingOptions(e15) {
    this._renderingOptions = e15, this.requestRender();
  }
  get renderRequested() {
    return this._renderRequested.value;
  }
  get state() {
    return this._state;
  }
  set state(e15) {
    this._state = e15, this.requestRender();
  }
  get stationary() {
    return this._stationary;
  }
  set stationary(e15) {
    this._stationary !== e15 && (this._stationary = e15, this.requestRender());
  }
  trashDisplayObject(e15) {
    this._trash.add(e15), this.requestRender();
  }
  untrashDisplayObject(e15) {
    return this._trash.delete(e15);
  }
  requestRender() {
    this._renderRemainingTime = M4, this.renderRequested || (this._renderRequested.value = true, this._taskHandle.resume());
  }
  renderFrame(e15) {
    const t22 = this._lastFrameRenderTime ? e15.time - this._lastFrameRenderTime : 0;
    this._renderRemainingTime -= t22, this._renderRemainingTime <= 0 && this._taskHandle.pause(), this._lastFrameRenderTime = e15.time, this._renderRequested.value = false, this._renderParameters.state = this._state, this._renderParameters.stationary = this.stationary, this._renderParameters.pixelRatio = window.devicePixelRatio, this._renderParameters.globalOpacity = 1, this._renderParameters.time = e15.time, this._renderParameters.deltaTime = e15.deltaTime, this._renderParameters.effects = null, this.processRender(this._renderParameters), this._emptyTrash();
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  renderChildren(e15) {
    for (const t22 of this.children) t22.beforeRender(e15);
    this._reshuffleManager.reshuffle(ui), this._canvas.render(e15, () => this._renderChildren(this.children, e15));
    for (const t22 of this.children) t22.afterRender(e15);
  }
  _renderChildren(e15, t22) {
    const r11 = this.context;
    this.painter.textureUploadManager.upload(), r11.resetInfo(), t22.profiler.recordStart("drawLayers"), t22.dataUploadCounter = 0, this.painter.beforeRenderPhases(t22, t22.backgroundColor, this.state.padding), t22.drawPhase = E4.MAP;
    for (const s15 of e15) s15.processRender(t22);
    if (this.children.some((e16) => e16.hasHighlight)) {
      t22.drawPhase = E4.HIGHLIGHT;
      for (const r12 of e15) r12.processRender(t22);
    }
    if (this.children.some((e16) => e16.hasLabels)) {
      t22.drawPhase = E4.LABEL;
      for (const r12 of e15) r12.processRender(t22);
    }
    if (has("esri-tiles-debug")) {
      t22.drawPhase = E4.DEBUG;
      for (const r12 of e15) r12.processRender(t22);
    }
    this.painter.afterRenderPhases(t22), t22.profiler.recordEnd("drawLayers"), r11.logInfo();
  }
  doRender(e15) {
    const t22 = this.context, { state: r11, pixelRatio: s15 } = e15;
    this._canvas.resize(e15), t22.setViewport(0, 0, s15 * r11.size[0], s15 * r11.size[1]), t22.setDepthWriteEnabled(true), t22.setStencilWriteMask(255), this.renderChildren(e15);
  }
  async takeScreenshot(e15, t22, r11, s15) {
    const i14 = Math.round(this.state.size[0] * e15.resolutionScale), n17 = Math.round(this.state.size[1] * e15.resolutionScale), a13 = e15.resolutionScale, o18 = this.context, h13 = this._state.clone();
    if (null != s15) {
      const e16 = h13.viewpoint;
      h13.viewpoint.rotation = s15, h13.viewpoint = e16;
    }
    const d11 = { ...this._renderParameters, drawPhase: null, globalOpacity: 1, stationary: true, state: h13, pixelRatio: a13, time: performance.now(), deltaTime: 0, blendMode: null, effects: null, inFadeTransition: false, backgroundColor: r11 }, l14 = new p(i14, n17);
    l14.wrapMode = D.CLAMP_TO_EDGE, l14.internalFormat = P3.RGBA8, l14.isImmutable = true;
    const m6 = new x(o18, l14, new i2(B3.DEPTH_STENCIL, i14, n17)), c13 = o18.getBoundFramebufferObject(), u15 = o18.getViewport();
    o18.bindFramebuffer(m6), o18.setViewport(0, 0, i14, n17), this._renderChildren(t22 ?? this.children, d11);
    const p7 = this._readbackScreenshot(m6, { ...e15.cropArea, y: n17 - (e15.cropArea.y + e15.cropArea.height) });
    o18.bindFramebuffer(c13), o18.setViewport(u15.x, u15.y, u15.width, u15.height), this.requestRender();
    const f12 = await p7;
    let g8;
    return 1 === e15.outputScale ? g8 = f12 : (g8 = new ImageData(Math.round(f12.width * e15.outputScale), Math.round(f12.height * e15.outputScale)), (await import("./screenshotUtils-KGJ3FNZH.js")).resampleHermite(f12, g8, true)), m6.dispose(), g8;
  }
  async _readbackScreenshot(e15, t22) {
    const r11 = (await import("./screenshotUtils-KGJ3FNZH.js")).createEmptyImageData(t22.width, t22.height, document.createElement("canvas"));
    return await e15.readPixelsAsync(t22.x, t22.y, t22.width, t22.height, G.RGBA, U2.UNSIGNED_BYTE, new Uint8Array(r11.data.buffer)), r11;
  }
  _emptyTrash() {
    for (; this._trash.size > 0; ) {
      const e15 = Array.from(this._trash);
      this._trash.clear();
      for (const t22 of e15) t22.processDetach();
    }
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/magnifier/MagnifierTechnique.js
var l12 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Magnifier, this._resourcePixelRatio = 1, this._position = [0, 0, 0, 0], this.shaders = { magnifier: new E5() };
  }
  updateResources(t22, i14, r11, s15) {
    t22.pixelRatio !== this._resourcePixelRatio && this._destroyResources(), this._readbackTexture || this._initializeResources(t22, i14, r11, s15);
    const { context: o18, pixelRatio: a13 } = t22, { factor: n17, offset: u15, position: h13 } = s15, { size: p7 } = t22.state, c13 = s15.size * a13, l14 = 1 / n17, m6 = Math.ceil(l14 * c13);
    this._readbackTexture.resize(m6, m6);
    const x5 = a13 * p7[0], d11 = a13 * p7[1], _6 = 0.5 * m6, T4 = 0.5 * m6, f12 = r3(a13 * h13.x, _6, x5 - _6 - 1), g8 = r3(d11 - a13 * h13.y, T4, d11 - T4 - 1), R3 = f12 - _6, w5 = g8 - T4, b6 = this._readbackTexture;
    o18.bindTexture(b6, 0), o18.gl.copyTexImage2D(b6.descriptor.target, 0, b6.descriptor.pixelFormat, R3, w5, m6, m6, 0);
    const y7 = (f12 + u15.x * a13) / x5 * 2 - 1, M6 = (g8 - u15.y * a13) / d11 * 2 - 1, k3 = c13 / x5 * 2, j7 = c13 / d11 * 2;
    this._position[0] = y7, this._position[1] = M6, this._position[2] = k3, this._position[3] = j7;
  }
  render(e15, t22) {
    const { context: i14, painter: s15 } = e15;
    s15.setPipelineState(t11);
    const o18 = { readbackTexture: { texture: this._readbackTexture, unit: 0 }, maskTexture: { texture: this._maskTexture, unit: 7 }, overlayTexture: { texture: this._overlayTexture, unit: 6 }, drawPos: this._position, ...t22 };
    s15.submitDrawMesh(i14, { shader: this.shaders.magnifier, uniforms: { config: o18 }, defines: null, optionalAttributes: null, useComputeBuffer: false }, s15.quadMesh);
  }
  shutdown() {
    this._destroyResources();
  }
  _initializeResources(e15, t22, r11, s15) {
    const o18 = e15.context;
    this._resourcePixelRatio = e15.pixelRatio;
    const a13 = Math.ceil(s15.size * e15.pixelRatio);
    r11.width = a13, r11.height = a13;
    const l14 = new p();
    l14.internalFormat = G.RGBA, l14.wrapMode = D.CLAMP_TO_EDGE, l14.samplingMode = L2.NEAREST, l14.flipped = true, l14.preMultiplyAlpha = !Pt(r11.src) || !e15.context.driverTest.svgPremultipliesAlpha.result, this._overlayTexture = new m3(o18, l14, r11), t22.width = a13, t22.height = a13, l14.pixelFormat = l14.internalFormat = G.ALPHA, this._maskTexture = new m3(o18, l14, t22);
    const m6 = 1 / s15.factor;
    l14.pixelFormat = l14.internalFormat = G.RGBA, l14.width = l14.height = Math.ceil(m6 * a13), l14.samplingMode = L2.LINEAR, l14.flipped = false, this._readbackTexture = new m3(o18, l14);
  }
  _destroyResources() {
    r2(this._maskTexture), r2(this._overlayTexture), r2(this._readbackTexture);
  }
};

// node_modules/@arcgis/core/views/magnifier/resources.js
async function s14(s15) {
  const r11 = import("./mask-svg-2KFBZHZ7.js"), i14 = import("./overlay-svg-VHDIW4NC.js"), o18 = t7((await r11).default, { signal: s15 }), e15 = t7((await i14).default, { signal: s15 }), m6 = { mask: await o18, overlay: await e15 };
  return s3(s15), m6;
}

// node_modules/@arcgis/core/views/2d/magnifier/MagnifierView2D.js
var c12 = class extends e9 {
  constructor() {
    super(), this._handles = new r(), this._magnifierTechnique = new l12(), this.updatingHandles = new h2(), this.visible = false;
  }
  destroy() {
    this._handles = u(this._handles), this._magnifierTechnique.shutdown(), this._resourcesTask = e(this._resourcesTask);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(e15) {
    this._backgroundColor = e15, this.requestRender();
  }
  get magnifier() {
    return this._magnifier;
  }
  set magnifier(e15) {
    this._magnifier = e15, this._handles.removeAll(), this._handles.add([d3(() => e15.version, () => {
      this.visible = e15.visible && null != e15.position && e15.size > 0, this.requestRender();
    }, P), d3(() => [e15.maskUrl, e15.overlayUrl], () => this._reloadResources()), d3(() => e15.size, () => {
      this._magnifierTechnique.shutdown(), this.requestRender();
    })]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (!this._resourcesTask) return void this._reloadResources();
    if (e15.drawPhase !== E4.MAP || !this._canRender()) return;
    const s15 = this._magnifier;
    if (null == s15.position) return;
    this._magnifierTechnique.updateResources(e15, this._mask, this._overlay, s15);
    const r11 = this.backgroundColor, i14 = r11 ? [r11.a * r11.r / 255, r11.a * r11.g / 255, r11.a * r11.b / 255, r11.a] : [1, 1, 1, 1];
    this._magnifierTechnique.render(e15, { background: i14, maskEnabled: s15.maskEnabled ? 1 : 0, overlayEnabled: s15.overlayEnabled ? 1 : 0 });
  }
  _canRender() {
    return this._mask && this._overlay && null != this._magnifier;
  }
  _reloadResources() {
    this._resourcesTask && this._resourcesTask.abort();
    const r11 = null != this._magnifier ? this._magnifier.maskUrl : null, i14 = null != this._magnifier ? this._magnifier.overlayUrl : null;
    this._resourcesTask = d2(async (s15) => {
      const n17 = null == r11 || null == i14 ? s14(s15) : null, t22 = null != r11 ? U(r11, { responseType: "image", signal: s15 }).then((e15) => e15.data) : n17.then((e15) => e15.mask), a13 = null != i14 ? U(i14, { responseType: "image", signal: s15 }).then((e15) => e15.data) : n17.then((e15) => e15.overlay), [o18, l14] = await Promise.all([t22, a13]);
      this._mask = o18, this._overlay = l14, this._magnifierTechnique.shutdown(), this.requestRender();
    }), this.updatingHandles.addPromise(this._resourcesTask.promise);
  }
};

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/grid/GridTechnique.js
var i13 = class extends t12 {
  constructor() {
    super(...arguments), this.type = e3.Grid, this.shaders = { grid: new S2() };
  }
  render(s15, r11) {
    const { context: t22, painter: i14 } = s15;
    i14.setPipelineState(t11), i14.submitDrawMesh(t22, { shader: this.shaders.grid, uniforms: r11, defines: null, optionalAttributes: null, useComputeBuffer: false }, i14.quadMesh);
  }
};

// node_modules/@arcgis/core/views/2d/grid/constants.js
var o17 = 50;
var t21 = 5;

// node_modules/@arcgis/core/views/2d/grid/gridUtils.js
function a12(e15, t22) {
  return Math.log(e15) / Math.log(t22);
}
function l13(e15, t22, r11) {
  const o18 = 1 === e15 ? 10 : e15;
  return o18 ** (r11 ? Math.round(a12(o17 / t22, o18)) : 0);
}
function f11(e15) {
  const { isGeographic: t22, isWebMercator: r11 } = e15;
  return !t22 && !r11;
}
function u14(i14, a13, l14) {
  const u15 = "number" == typeof i14 ? null : i14, y7 = l14 ?? (u15 == null ? void 0 : u15.spatialReference);
  if (null == y7 || !g(y7) || f11(y7)) return z(y7);
  let g8 = (u15 == null ? void 0 : u15.x) ?? i14, j7 = (u15 == null ? void 0 : u15.y) ?? a13;
  const h13 = 1 / Math.sqrt(2);
  let M6 = g8 + h13, x5 = j7 + h13;
  const { isWebMercator: R3, isGeographic: U6 } = y7;
  let b6 = U6 && !y5(y7) ? g2.WGS84 : y7;
  if (R3) {
    let e15 = new j2({ x: g8, y: j7, spatialReference: y7 });
    j(e15, true, e15), g8 = e15.x, j7 = e15.y, e15 = new j2({ x: M6, y: x5, spatialReference: y7 }), j(e15, true, e15), M6 = e15.x, x5 = e15.y, b6 = g2.WGS84;
  }
  const w5 = new d4({ paths: [[[g8, j7], [M6, x5]]], spatialReference: b6 }), G3 = M(w5, 10);
  let W3;
  try {
    [W3] = R2([G3], "meters");
  } catch {
    return z(y7);
  }
  return W3;
}

// node_modules/@arcgis/core/views/2d/grid/GridView2D.js
var x4 = n3();
var w4 = class extends e9 {
  constructor() {
    super(), this._handles = new r(), this._projectedCenter = null, this._metersPerSRUnit = null, this._technique = new i13(), this._grid = null, this.visible = true;
  }
  destroy() {
    this._handles = u(this._handles), this._technique.shutdown();
  }
  get grid() {
    return this._grid;
  }
  set grid(e15) {
    this._grid = e15, this._handles.removeAll(), this._handles.add([d3(() => e15 == null ? void 0 : e15.center, () => {
      this._projectedCenter = null;
    }, P), d3(() => [e15 == null ? void 0 : e15.center, e15 == null ? void 0 : e15.dynamicScaling, e15 == null ? void 0 : e15.majorLineColor, e15 == null ? void 0 : e15.majorLineInterval, e15 == null ? void 0 : e15.minorLineColor, e15 == null ? void 0 : e15.rotateWithMap, e15 == null ? void 0 : e15.rotation, e15 == null ? void 0 : e15.spacing, e15 == null ? void 0 : e15.units], () => this.requestRender(), P)]);
  }
  _createTransforms() {
    return { displayViewScreenMat3: e6() };
  }
  doRender(e15) {
    if (e15.drawPhase !== E4.MAP || null == this.grid || !this.visible) return;
    const { spacing: t22, units: r11, majorLineInterval: i14, dynamicScaling: s15, majorLineColor: o18, minorLineColor: a13 } = this.grid;
    if (0 === t22) return;
    if (this._updateDerivedValues(e15), null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const { scale: l14, spatialReference: m6 } = e15.state, c13 = I(t22, r11, "meters"), h13 = this._metersPerSRUnit * o8(l14, m6), p7 = c13 / h13;
    if (!s15 && p7 < t21) return;
    const d11 = c13 * l13(i14, p7, s15);
    this._updateTransform(e15, h13, d11), this._technique.render(e15, { transform: { dvs: this.transforms.displayViewScreenMat3 }, config: { pxPerCell: d11 / h13, minorLineColor: q3(a13), majorLineColor: q3(o18), majorLineInterval: i14, halfWidth: 0.25, aaWidth: 0.5 } });
  }
  _updateDerivedValues(e15) {
    if (!this.grid) return;
    const { center: t22 } = this.grid, { spatialReference: r11 } = e15.state;
    this._projectedCenter && s4(this._projectedCenter.spatialReference, r11) || (this._metersPerSRUnit = null, s4(t22.spatialReference, r11) ? this._projectedCenter = t22 : B(t22.spatialReference, r11) ? this._projectedCenter = K(t22, r11) : this.requestRender()), null == this._metersPerSRUnit && null != this._projectedCenter && (this._metersPerSRUnit = u14(this._projectedCenter));
  }
  _updateTransform(e15, r11, i14) {
    const { grid: s15 } = this, { center: n17, rotation: c13, size: j7, spatialReference: _6 } = e15.state;
    if (null == s15 || null == this._projectedCenter || null == this._metersPerSRUnit) return;
    const g8 = r11 * (j7[0] / 2), R3 = r11 * (j7[1] / 2), v4 = this._metersPerSRUnit / i14, U6 = this._projectedCenter, y7 = s5(s15.rotation), S4 = s5(c13), b6 = this.transforms.displayViewScreenMat3;
    m2(b6, -y7);
    const L7 = _6.isWrappable ? P2(U6.x, n17[0], _6) : U6.x, P5 = o3(x4, L7, U6.y), w5 = B2(x4, n17, P5);
    l3(w5, w5, v4), s15.rotateWithMap || I2(w5, w5, i6, -S4), I2(w5, w5, i6, -y7), l3(w5, w5, 1 / s15.majorLineInterval), M5(w5, w5), l3(w5, w5, s15.majorLineInterval), I2(w5, w5, i6, y7), M2(b6, b6, w5), s15.rotateWithMap && h(b6, b6, S4);
    const q4 = o3(x4, g8 / i14, R3 / i14);
    b2(b6, b6, q4);
  }
};
function M5(e15, t22) {
  return e15[0] = t22[0] - Math.trunc(t22[0]), e15[1] = t22[1] - Math.trunc(t22[1]), e15;
}
function q3(e15) {
  const [t22, r11, i14, s15] = e15.toArray().map((e16) => e16 / 255);
  return [t22 * s15, r11 * s15, i14 * s15, s15];
}
export {
  t15 as GraphicContainer,
  F3 as GraphicsView2D,
  w4 as GridView2D,
  a5 as LabelManager,
  c12 as MagnifierView2D,
  y4 as MapViewNavigation,
  O6 as Stage
};
//# sourceMappingURL=mapViewDeps-MMMJKFTO.js.map
