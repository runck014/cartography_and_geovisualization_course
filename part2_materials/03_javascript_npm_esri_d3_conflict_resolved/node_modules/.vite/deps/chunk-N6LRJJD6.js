import {
  o as o10,
  r as r5
} from "./chunk-5CHZW6XY.js";
import {
  B,
  g,
  o as o11
} from "./chunk-BOYBHWD5.js";
import {
  O as O2,
  P as P2,
  d2,
  e2 as e10,
  e3 as e12,
  e4 as e13,
  g as g2,
  l as l2,
  o as o9,
  o2 as o12,
  p3 as p2,
  s2 as s5
} from "./chunk-2NNPNUGA.js";
import {
  f
} from "./chunk-K5MOSV47.js";
import {
  d as d3,
  v
} from "./chunk-SYHMDVRI.js";
import {
  e as e11
} from "./chunk-JW4HK5OB.js";
import {
  e as e9,
  s as s4
} from "./chunk-FATVAQSJ.js";
import {
  a as a6,
  c,
  e as e5,
  n as n6,
  o as o8,
  t as t4
} from "./chunk-W3O5CFJ6.js";
import {
  S as S2,
  e as e6,
  e2 as e7,
  e3 as e8,
  n as n7,
  o2 as o6,
  u
} from "./chunk-HRP7POO2.js";
import {
  s as s3
} from "./chunk-X2UYZD2B.js";
import {
  a as a5,
  o as o7
} from "./chunk-JQJITHTO.js";
import {
  o as o5,
  r as r4,
  t as t3
} from "./chunk-6LGJYARD.js";
import {
  a as a3
} from "./chunk-N42IF4WX.js";
import {
  O,
  a as a4,
  i
} from "./chunk-MA2KDKKH.js";
import {
  e as e4,
  o as o3
} from "./chunk-5FROWG6B.js";
import {
  e as e3
} from "./chunk-NW7VXBHZ.js";
import {
  e as e2
} from "./chunk-L7OHH2HW.js";
import {
  o as o4
} from "./chunk-CTU2XDPA.js";
import {
  n as n3
} from "./chunk-AFULL6KA.js";
import {
  s as s2
} from "./chunk-URFLFG2R.js";
import {
  a as a2,
  m as m2,
  p
} from "./chunk-QJXYURT2.js";
import {
  j
} from "./chunk-D6FJTDNK.js";
import {
  D,
  E,
  G,
  _ as _2,
  t as t2
} from "./chunk-KV3S4QI2.js";
import {
  n as n4
} from "./chunk-ECMDQ4LS.js";
import {
  o
} from "./chunk-LP6TMAPE.js";
import {
  H,
  o as o2
} from "./chunk-RENLZYKC.js";
import {
  n as n5
} from "./chunk-LPNAPHOF.js";
import {
  P,
  d
} from "./chunk-W6D3ECTZ.js";
import {
  _,
  e,
  n as n2
} from "./chunk-6Y2LNRVP.js";
import {
  r as r3
} from "./chunk-6YWQXXBX.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  S
} from "./chunk-GRW2QIBT.js";
import {
  r as r2,
  t
} from "./chunk-R2PAF6JT.js";
import {
  n
} from "./chunk-6WE7SNQY.js";
import {
  l
} from "./chunk-L6CCOEVE.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/PositionAttribute.glsl.js
function o13(o22) {
  o22.attributes.add(e2.POSITION, "vec3"), o22.vertex.code.add(o5`vec3 positionModel() { return position; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js
function v2(r11, o22) {
  r11.include(o13);
  const e23 = r11.vertex;
  e23.include(c, o22), r11.varyings.add("vPositionWorldCameraRelative", "vec3"), r11.varyings.add("vPosition_view", "vec3"), e23.uniforms.add(new e6("transformWorldFromViewTH", (r12) => r12.transformWorldFromViewTH), new e6("transformWorldFromViewTL", (r12) => r12.transformWorldFromViewTL), new e7("transformViewFromCameraRelativeRS", (r12) => r12.transformViewFromCameraRelativeRS), new e8("transformProjFromView", (r12) => r12.transformProjFromView), new o8("transformWorldFromModelRS", (r12) => r12.transformWorldFromModelRS), new o6("transformWorldFromModelTH", (r12) => r12.transformWorldFromModelTH), new o6("transformWorldFromModelTL", (r12) => r12.transformWorldFromModelTL)), e23.code.add(o5`vec3 positionWorldCameraRelative() {
vec3 rotatedModelPosition = transformWorldFromModelRS * positionModel();
vec3 transform_CameraRelativeFromModel = dpAdd(
transformWorldFromModelTL,
transformWorldFromModelTH,
-transformWorldFromViewTL,
-transformWorldFromViewTH
);
return transform_CameraRelativeFromModel + rotatedModelPosition;
}`), e23.code.add(o5`
    void forwardPosition(float fOffset) {
      vPositionWorldCameraRelative = positionWorldCameraRelative();
      if (fOffset != 0.0) {
        vPositionWorldCameraRelative += fOffset * ${o22.spherical ? o5`normalize(transformWorldFromViewTL + vPositionWorldCameraRelative)` : o5`vec3(0.0, 0.0, 1.0)`};
      }

      vPosition_view = transformViewFromCameraRelativeRS * vPositionWorldCameraRelative;
      gl_Position = transformProjFromView * vec4(vPosition_view, 1.0);
    }
  `), r11.fragment.uniforms.add(new e6("transformWorldFromViewTL", (r12) => r12.transformWorldFromViewTL)), e23.code.add(o5`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`), r11.fragment.code.add(o5`vec3 positionWorld() {
return transformWorldFromViewTL + vPositionWorldCameraRelative;
}`);
}
var F = class extends t3 {
  constructor() {
    super(...arguments), this.transformWorldFromViewTH = n2(), this.transformWorldFromViewTL = n2(), this.transformViewFromCameraRelativeRS = e3(), this.transformProjFromView = e4();
  }
};
var W = class extends t3 {
  constructor() {
    super(...arguments), this.transformWorldFromModelRS = e3(), this.transformWorldFromModelTH = n2(), this.transformWorldFromModelTL = n2();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js
function c2(o22, a10) {
  switch (a10.normalType) {
    case a6.Attribute:
    case a6.Compressed:
      o22.include(t4, a10), o22.varyings.add("vNormalWorld", "vec3"), o22.varyings.add("vNormalView", "vec3"), o22.vertex.uniforms.add(new o8("transformNormalGlobalFromModel", (r11) => r11.transformNormalGlobalFromModel), new e7("transformNormalViewFromGlobal", (r11) => r11.transformNormalViewFromGlobal)), o22.vertex.code.add(o5`void forwardNormal() {
vNormalWorld = transformNormalGlobalFromModel * normalModel();
vNormalView = transformNormalViewFromGlobal * vNormalWorld;
}`);
      break;
    case a6.ScreenDerivative:
      o22.vertex.code.add(o5`void forwardNormal() {}`);
      break;
    default:
      n5(a10.normalType);
    case a6.COUNT:
  }
}
var f2 = class extends F {
  constructor() {
    super(...arguments), this.transformNormalViewFromGlobal = e3();
  }
};
var n8 = class extends W {
  constructor() {
    super(...arguments), this.transformNormalGlobalFromModel = e3(), this.toMapSpace = n3();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/materials/pbrUtils.js
function n9({ normalTexture: u7, metallicRoughnessTexture: n18, metallicFactor: r11, roughnessFactor: t17, emissiveTexture: o22, emissiveFactor: s8, occlusionTexture: c8 }) {
  return null == u7 && null == n18 && null == o22 && (null == s8 || H(s8, _)) && null == c8 && (null == t17 || 1 === t17) && (null == r11 || 1 === r11);
}
var t5 = e(1, 1, 0.5);
var o14 = e(0, 0.6, 0.2);
var s6 = e(0, 1, 0.2);

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js
function t6(e23) {
  e23.varyings.add("linearDepth", "float");
}
function i2(e23) {
  e23.vertex.uniforms.add(new e9("nearFar", (e24, a10) => a10.camera.nearFar));
}
function d4(e23) {
  e23.vertex.code.add(o5`float calculateLinearDepth(vec2 nearFar,float z) {
return (-z - nearFar[0]) / (nearFar[1] - nearFar[0]);
}`);
}
function n10(r11, n18) {
  const { vertex: s8 } = r11;
  switch (n18.output) {
    case n7.Color:
    case n7.ColorEmission:
      if (n18.receiveShadows) return t6(r11), void s8.code.add(o5`void forwardLinearDepth() { linearDepth = gl_Position.w; }`);
      break;
    case n7.Shadow:
    case n7.ShadowHighlight:
    case n7.ShadowExcludeHighlight:
    case n7.ViewshedShadow:
      return r11.include(v2, n18), t6(r11), i2(r11), d4(r11), void s8.code.add(o5`void forwardLinearDepth() {
linearDepth = calculateLinearDepth(nearFar, vPosition_view.z);
}`);
  }
  s8.code.add(o5`void forwardLinearDepth() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Offset.glsl.js
function e14(e23) {
  e23.vertex.code.add(o5`vec4 offsetBackfacingClipPosition(vec4 posClip, vec3 posWorld, vec3 normalWorld, vec3 camPosWorld) {
vec3 camToVert = posWorld - camPosWorld;
bool isBackface = dot(camToVert, normalWorld) > 0.0;
if (isBackface) {
posClip.z += 0.0000003 * posClip.w;
}
return posClip;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js
function o15(o22) {
  d4(o22), o22.vertex.code.add(o5`vec4 transformPositionWithDepth(mat4 proj, mat4 view, vec3 pos, vec2 nearFar, out float depth) {
vec4 eye = view * vec4(pos, 1.0);
depth = calculateLinearDepth(nearFar,eye.z);
return proj * eye;
}`), o22.vertex.code.add(o5`vec4 transformPosition(mat4 proj, mat4 view, vec3 pos) {
return proj * (view * vec4(pos, 1.0));
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/InstancedDoublePrecision.glsl.js
var f3 = e3();
function M(r11, n18) {
  const m6 = n18.hasModelTransformation, x2 = n18.instancedDoublePrecision;
  m6 && (r11.vertex.uniforms.add(new e8("model", (e23) => e23.modelTransformation ?? o3)), r11.vertex.uniforms.add(new e7("normalLocalOriginFromModel", (r12) => (j(f3, r12.modelTransformation ?? o3), f3)))), n18.instanced && x2 && (r11.attributes.add(e2.INSTANCEMODELORIGINHI, "vec3"), r11.attributes.add(e2.INSTANCEMODELORIGINLO, "vec3"), r11.attributes.add(e2.INSTANCEMODEL, "mat3"), r11.attributes.add(e2.INSTANCEMODELNORMAL, "mat3"));
  const M3 = r11.vertex;
  x2 && (M3.include(c, n18), M3.uniforms.add(new o6("viewOriginHi", (e23, r12) => o10(o2(O3, r12.camera.viewInverseTransposeMatrix[3], r12.camera.viewInverseTransposeMatrix[7], r12.camera.viewInverseTransposeMatrix[11]), O3)), new o6("viewOriginLo", (e23, r12) => r5(o2(O3, r12.camera.viewInverseTransposeMatrix[3], r12.camera.viewInverseTransposeMatrix[7], r12.camera.viewInverseTransposeMatrix[11]), O3)))), M3.code.add(o5`
    vec3 getVertexInLocalOriginSpace() {
      return ${m6 ? x2 ? "(model * vec4(instanceModel * localPosition().xyz, 1.0)).xyz" : "(model * localPosition()).xyz" : x2 ? "instanceModel * localPosition().xyz" : "localPosition().xyz"};
    }

    vec3 subtractOrigin(vec3 _pos) {
      ${x2 ? o5`
          // Negated inputs are intentionally the first two arguments. The other way around the obfuscation in dpAdd() stopped
          // working for macOS 14+ and iOS 17+.
          // Issue: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/56280
          vec3 originDelta = dpAdd(-instanceModelOriginHi, -instanceModelOriginLo, viewOriginHi, viewOriginLo);
          return _pos - originDelta;` : "return vpos;"}
    }
    `), M3.code.add(o5`
    vec3 dpNormal(vec4 _normal) {
      return normalize(${m6 ? x2 ? "normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz)" : "normalLocalOriginFromModel * _normal.xyz" : x2 ? "instanceModelNormal * _normal.xyz" : "_normal.xyz"});
    }
    `), n18.output === n7.Normal && (p2(M3), M3.code.add(o5`
    vec3 dpNormalView(vec4 _normal) {
      return normalize((viewNormal * ${m6 ? x2 ? "vec4(normalLocalOriginFromModel * (instanceModelNormal * _normal.xyz), 1.0)" : "vec4(normalLocalOriginFromModel * _normal.xyz, 1.0)" : x2 ? "vec4(instanceModelNormal * _normal.xyz, 1.0)" : "_normal"}).xyz);
    }
    `)), n18.hasVertexTangents && M3.code.add(o5`
    vec4 dpTransformVertexTangent(vec4 _tangent) {
      ${m6 ? x2 ? "return vec4(normalLocalOriginFromModel * (instanceModelNormal * _tangent.xyz), _tangent.w);" : "return vec4(normalLocalOriginFromModel * _tangent.xyz, _tangent.w);" : x2 ? "return vec4(instanceModelNormal * _tangent.xyz, _tangent.w);" : "return _tangent;"}
    }`);
}
var O3 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/SymbolColor.glsl.js
function i3(i6, t17) {
  t17.hasSymbolColors ? (i6.include(e5), i6.attributes.add(e2.SYMBOLCOLOR, "vec4"), i6.varyings.add("colorMixMode", "mediump float"), i6.vertex.code.add(o5`int symbolColorMixMode;
vec4 getSymbolColor() {
return decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451;
}
void forwardColorMixMode() {
colorMixMode = float(symbolColorMixMode) + 0.5;
}`)) : (i6.fragment.uniforms.add(new e10("colorMixMode", (o22) => o9[o22.colorMixMode])), i6.vertex.code.add(o5`vec4 getSymbolColor() { return vec4(1.0); }
void forwardColorMixMode() {}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js
var d5;
function o16(o22, v3) {
  switch (v3.textureCoordinateType) {
    case d5.Default:
      return o22.attributes.add(e2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o5`void forwardTextureCoordinates() {
vuv0 = uv0;
}`);
    case d5.Compressed:
      return o22.attributes.add(e2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), void o22.vertex.code.add(o5`vec2 getUV0() {
return uv0 / 16384.0;
}
void forwardTextureCoordinates() {
vuv0 = getUV0();
}`);
    case d5.Atlas:
      return o22.attributes.add(e2.UV0, "vec2"), o22.varyings.add("vuv0", "vec2"), o22.attributes.add(e2.UVREGION, "vec4"), o22.varyings.add("vuvRegion", "vec4"), void o22.vertex.code.add(o5`void forwardTextureCoordinates() {
vuv0 = uv0;
vuvRegion = uvRegion;
}`);
    default:
      n5(v3.textureCoordinateType);
    case d5.None:
      return void o22.vertex.code.add(o5`void forwardTextureCoordinates() {}`);
    case d5.COUNT:
      return;
  }
}
!function(e23) {
  e23[e23.None = 0] = "None", e23[e23.Default = 1] = "Default", e23[e23.Atlas = 2] = "Atlas", e23[e23.Compressed = 3] = "Compressed", e23[e23.COUNT = 4] = "COUNT";
}(d5 || (d5 = {}));

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js
function e15(e23, d8) {
  d8.hasVertexColors ? (e23.attributes.add(e2.COLOR, "vec4"), e23.varyings.add("vColor", "vec4"), e23.vertex.code.add(o5`void forwardVertexColor() { vColor = color; }`), e23.vertex.code.add(o5`void forwardNormalizedVertexColor() { vColor = color * 0.003921568627451; }`)) : e23.vertex.code.add(o5`void forwardVertexColor() {}
void forwardNormalizedVertexColor() {}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js
function t7(o22, a10) {
  f4(o22, a10, new o7("textureAlphaCutoff", (o23) => o23.textureAlphaCutoff));
}
function f4(a10, r11, t17) {
  const s8 = a10.fragment;
  switch (r11.alphaDiscardMode) {
    case i.Blend:
      a10.fragment.code.add(o5`
        #define discardOrAdjustAlpha(color) { if (color.a < ${o5.float(o4)}) { discard; } }
      `);
      break;
    case i.Opaque:
      s8.code.add(o5`void discardOrAdjustAlpha(inout vec4 color) {
color.a = 1.0;
}`);
      break;
    case i.Mask:
      s8.uniforms.add(t17).code.add(o5`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } else { color.a = 1.0; } }`);
      break;
    case i.MaskBlend:
      s8.uniforms.add(t17).code.add(o5`#define discardOrAdjustAlpha(color) { if (color.a < textureAlphaCutoff) { discard; } }`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloat16Encoding.glsl.js
function a7(a10) {
  a10.code.add(o5`const float MAX_RGBA4_FLOAT =
15.0 / 16.0 +
15.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 +
15.0 / 16.0 / 16.0 / 16.0 / 16.0;
const vec4 FIXED_POINT_FACTORS_RGBA4 = vec4(1.0, 16.0, 16.0 * 16.0, 16.0 * 16.0 * 16.0);
vec4 floatToRgba4(const float value) {
float valueInValidDomain = clamp(value, 0.0, MAX_RGBA4_FLOAT);
vec4 fixedPointU4 = floor(fract(valueInValidDomain * FIXED_POINT_FACTORS_RGBA4) * 16.0);
const float toU4AsFloat = 1.0 / 15.0;
return fixedPointU4 * toU4AsFloat;
}
const vec4 RGBA4_2_FLOAT_FACTORS = vec4(
15.0 / (16.0),
15.0 / (16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0),
15.0 / (16.0 * 16.0 * 16.0 * 16.0)
);
float rgba4ToFloat(vec4 rgba) {
return dot(rgba, RGBA4_2_FLOAT_FACTORS);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js
function e17(e23, d8) {
  switch (d8.output) {
    case n7.Shadow:
    case n7.ShadowHighlight:
    case n7.ShadowExcludeHighlight:
    case n7.ViewshedShadow:
      e23.fragment.include(a7), e23.fragment.code.add(o5`float _calculateFragDepth(const in float depth) {
const float SLOPE_SCALE = 2.0;
const float BIAS = 20.0 * .000015259;
float m = max(abs(dFdx(depth)), abs(dFdy(depth)));
return depth + SLOPE_SCALE * m + BIAS;
}
void outputDepth(float _linearDepth) {
fragColor = floatToRgba4(_calculateFragDepth(_linearDepth));
}`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/default/DefaultMaterialAuxiliaryPasses.glsl.js
function h(h4, O5) {
  const { vertex: j2, fragment: w } = h4, b2 = O5.hasColorTexture && O5.alphaDiscardMode !== i.Opaque, { output: C2, normalType: V, hasColorTextureTransform: A2 } = O5;
  switch (C2) {
    case n7.Depth:
      d2(j2, O5), h4.include(o15, O5), h4.include(P2, O5), h4.include(o16, O5), b2 && w.uniforms.add(new s4("tex", (e23) => e23.texture)), j2.main.add(o5`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`), h4.include(t7, O5), w.main.add(o5`
          discardBySlice(vpos);
          ${r4(b2, o5`vec4 texColor = texture(tex, ${A2 ? "colorUV" : "vuv0"});
                 discardOrAdjustAlpha(texColor);`)}`);
      break;
    case n7.Shadow:
    case n7.ShadowHighlight:
    case n7.ShadowExcludeHighlight:
    case n7.ViewshedShadow:
    case n7.ObjectAndLayerIdColor:
      d2(j2, O5), h4.include(o15, O5), h4.include(o16, O5), h4.include(l2, O5), h4.include(e17, O5), h4.include(P2, O5), h4.include(e12, O5), i2(h4), h4.varyings.add("depth", "float"), b2 && w.uniforms.add(new s4("tex", (e23) => e23.texture)), j2.main.add(o5`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
forwardTextureCoordinates();
forwardObjectAndLayerIdColor();`), h4.include(t7, O5), w.main.add(o5`
          discardBySlice(vpos);
          ${r4(b2, o5`vec4 texColor = texture(tex, ${A2 ? "colorUV" : "vuv0"});
                 discardOrAdjustAlpha(texColor);`)}
          ${C2 === n7.ObjectAndLayerIdColor ? o5`outputObjectAndLayerIdColor();` : o5`outputDepth(depth);`}`);
      break;
    case n7.Normal: {
      d2(j2, O5), h4.include(o15, O5), h4.include(t4, O5), h4.include(c2, O5), h4.include(o16, O5), h4.include(l2, O5), b2 && w.uniforms.add(new s4("tex", (e24) => e24.texture)), V === a6.ScreenDerivative && h4.varyings.add("vPositionView", "vec3");
      const e23 = V === a6.Attribute || V === a6.Compressed;
      j2.main.add(o5`
          vpos = getVertexInLocalOriginSpace();
          ${e23 ? o5`vNormalWorld = dpNormalView(vvLocalNormal(normalModel()));` : o5`vPositionView = (view * vec4(vpos, 1.0)).xyz;`}
          vpos = subtractOrigin(vpos);
          vpos = addVerticalOffset(vpos, localOrigin);
          gl_Position = transformPosition(proj, view, vpos);
          forwardTextureCoordinates();`), h4.include(P2, O5), h4.include(t7, O5), w.main.add(o5`
          discardBySlice(vpos);
          ${r4(b2, o5`vec4 texColor = texture(tex, ${A2 ? "colorUV" : "vuv0"});
                 discardOrAdjustAlpha(texColor);`)}

          ${V === a6.ScreenDerivative ? o5`vec3 normal = screenDerivativeNormal(vPositionView);` : o5`vec3 normal = normalize(vNormalWorld);
                     if (gl_FrontFacing == false){
                       normal = -normal;
                     }`}
          fragColor = vec4(0.5 + 0.5 * normal, 1.0);`);
      break;
    }
    case n7.Highlight:
      d2(j2, O5), h4.include(o15, O5), h4.include(o16, O5), h4.include(l2, O5), b2 && w.uniforms.add(new s4("tex", (e23) => e23.texture)), j2.main.add(o5`vpos = getVertexInLocalOriginSpace();
vpos = subtractOrigin(vpos);
vpos = addVerticalOffset(vpos, localOrigin);
gl_Position = transformPosition(proj, view, vpos);
forwardTextureCoordinates();`), h4.include(P2, O5), h4.include(t7, O5), h4.include(g2, O5), w.main.add(o5`
          discardBySlice(vpos);
          ${r4(b2, o5`vec4 texColor = texture(tex, ${A2 ? "colorUV" : "vuv0"});
                 discardOrAdjustAlpha(texColor);`)}
          calculateOcclusionAndOutputHighlight();`);
  }
}

// node_modules/@arcgis/core/views/3d/webgl.js
var n12;
var t8;
!function(e23) {
  e23.OPAQUE = "opaque-color", e23.TRANSPARENT = "transparent-color", e23.COMPOSITE = "composite-color", e23.FINAL = "final-color";
}(n12 || (n12 = {})), function(e23) {
  e23.SSAO = "ssao", e23.LASERLINES = "laserline-color", e23.ANTIALIASING = "aa-color", e23.HIGHLIGHTS = "highlight-color", e23.MAGNIFIER = "magnifier-color", e23.OCCLUDED = "occluded-color", e23.VIEWSHED = "viewshed-color", e23.OPAQUE_ENVIRONMENT = "opaque-environment-color", e23.TRANSPARENT_ENVIRONMENT = "transparent-environment-color";
}(t8 || (t8 = {}));

// node_modules/@arcgis/core/views/3d/webgl/formats.js
var R;
var E2;
!function(R2) {
  R2[R2.RED = 0] = "RED", R2[R2.RG = 1] = "RG", R2[R2.RGBA4 = 2] = "RGBA4", R2[R2.RGBA = 3] = "RGBA", R2[R2.RGBA_MIPMAP = 4] = "RGBA_MIPMAP", R2[R2.R16F = 5] = "R16F", R2[R2.RGBA16F = 6] = "RGBA16F";
}(R || (R = {})), function(R2) {
  R2[R2.DEPTH_STENCIL_TEXTURE = 0] = "DEPTH_STENCIL_TEXTURE", R2[R2.DEPTH16_BUFFER = 1] = "DEPTH16_BUFFER";
}(E2 || (E2 = {}));

// node_modules/@arcgis/core/views/3d/webgl/RenderNode.js
var u2 = class extends b {
  constructor(e23) {
    super(e23), this.view = null, this.consumes = { required: [] }, this.produces = n12.COMPOSITE, this.requireGeometryDepth = false, this._dirty = true;
  }
  initialize() {
    this.addHandles([d(() => this.view.ready, (e23) => {
      var _a;
      e23 && ((_a = this.view._stage) == null ? void 0 : _a.renderer.addRenderNode(this));
    }, P)]);
  }
  destroy() {
    var _a, _b;
    (_b = (_a = this.view._stage) == null ? void 0 : _a.renderer) == null ? void 0 : _b.removeRenderNode(this);
  }
  precompile() {
  }
  render() {
    throw new s("RenderNode:render-function-not-implemented", "render() is not implemented.");
  }
  get camera() {
    return this.view.state.camera.clone();
  }
  get sunLight() {
    return this.bindParameters.lighting.legacy;
  }
  get gl() {
    return this.view._stage.renderView.renderingContext.gl;
  }
  acquireOutputFramebuffer() {
    var _a, _b, _c;
    const e23 = (_b = (_a = this._frameBuffer) == null ? void 0 : _a.getTexture()) == null ? void 0 : _b.descriptor, r11 = this.view._stage.renderer.fboCache.acquire((e23 == null ? void 0 : e23.width) ?? 640, (e23 == null ? void 0 : e23.height) ?? 480, this.produces);
    return (_c = r11.fbo) == null ? void 0 : _c.initializeAndBind(), r11;
  }
  bindRenderTarget() {
    var _a, _b;
    return (_b = (_a = this._frameBuffer) == null ? void 0 : _a.fbo) == null ? void 0 : _b.initializeAndBind(), this._frameBuffer;
  }
  requestRender(e23) {
    var _a;
    e23 === a4.UPDATE && ((_a = this.view._stage) == null ? void 0 : _a.renderView.requestRender(e23)), this._dirty = true;
  }
  resetWebGLState() {
    var _a;
    this.renderingContext.resetState(), this.renderingContext.bindFramebuffer((_a = this._frameBuffer) == null ? void 0 : _a.fbo);
  }
  get fboCache() {
    return this.view._stage.renderer.fboCache;
  }
  get bindParameters() {
    return this.renderContext.bind;
  }
  get renderingContext() {
    return this.view._stage.renderView.renderingContext;
  }
  get renderContext() {
    var _a;
    return (_a = this.view._stage) == null ? void 0 : _a.renderer.renderContext;
  }
  updateAnimation(e23) {
    return !!this._dirty && (this._dirty = false, true);
  }
  doRender(e23) {
    this._frameBuffer = e23.find(({ name: e24 }) => e24 === this.produces);
    try {
      return this.render(e23);
    } finally {
      this._frameBuffer = null;
    }
  }
};
r([m({ constructOnly: true })], u2.prototype, "view", void 0), r([m({ constructOnly: true })], u2.prototype, "consumes", void 0), r([m()], u2.prototype, "produces", void 0), u2 = r([a("esri.views.3d.webgl.RenderNode")], u2);
var c3 = u2;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ScreenSpaceConstants.js
var e18 = 3e5;
var o17 = 5e5;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ReloadableShaderModule.js
var t9 = class {
  constructor(t17, o22) {
    this._module = t17, this._load = o22;
  }
  get() {
    return this._module;
  }
  async reload() {
    return this._module = await this._load(), this._module;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/Program.js
var r6 = class {
  constructor(r11, i6, s8) {
    this._context = r11, this._locations = s8, this._textures = /* @__PURE__ */ new Map(), this._freeTextureUnits = new l({ deallocator: null }), this._glProgram = r11.programCache.acquire(i6.generate("vertex"), i6.generate("fragment"), s8), this._glProgram.stop = () => {
      throw new Error("Wrapped _glProgram used directly");
    }, this.bindPass = i6.generateBindPass(this), this.bindDraw = i6.generateBindDraw(this), this._fragmentUniforms = a2() ? i6.fragmentUniforms : null;
  }
  dispose() {
    this._glProgram.dispose();
  }
  get glName() {
    return this._glProgram.glName;
  }
  get hasTransformFeedbackVaryings() {
    return this._glProgram.hasTransformFeedbackVaryings;
  }
  get compiled() {
    return this._glProgram.compiled;
  }
  setUniform1b(t17, e23) {
    this._glProgram.setUniform1i(t17, e23 ? 1 : 0);
  }
  setUniform1i(t17, e23) {
    this._glProgram.setUniform1i(t17, e23);
  }
  setUniform1f(t17, e23) {
    this._glProgram.setUniform1f(t17, e23);
  }
  setUniform2fv(t17, e23) {
    this._glProgram.setUniform2fv(t17, e23);
  }
  setUniform3fv(t17, e23) {
    this._glProgram.setUniform3fv(t17, e23);
  }
  setUniform4fv(t17, e23) {
    this._glProgram.setUniform4fv(t17, e23);
  }
  setUniformMatrix3fv(t17, e23) {
    this._glProgram.setUniformMatrix3fv(t17, e23);
  }
  setUniformMatrix4fv(t17, e23) {
    this._glProgram.setUniformMatrix4fv(t17, e23);
  }
  setUniform1fv(t17, e23) {
    this._glProgram.setUniform1fv(t17, e23);
  }
  setUniform1iv(t17, e23) {
    this._glProgram.setUniform1iv(t17, e23);
  }
  setUniform2iv(t17, e23) {
    this._glProgram.setUniform2iv(t17, e23);
  }
  setUniform3iv(t17, e23) {
    this._glProgram.setUniform3iv(t17, e23);
  }
  setUniform4iv(t17, e23) {
    this._glProgram.setUniform4iv(t17, e23);
  }
  assertCompatibleVertexAttributeLocations(t17) {
    t17.locations !== this._locations && console.error("VertexAttributeLocations are incompatible");
  }
  stop() {
    this._textures.clear(), this._freeTextureUnits.clear();
  }
  bindTexture(t17, e23) {
    if (null == (e23 == null ? void 0 : e23.glName)) {
      const e24 = this._textures.get(t17);
      return e24 && (this._context.bindTexture(null, e24.unit), this._freeTextureUnit(e24), this._textures.delete(t17)), null;
    }
    let r11 = this._textures.get(t17);
    return null == r11 ? (r11 = this._allocTextureUnit(e23), this._textures.set(t17, r11)) : r11.texture = e23, this._context.useProgram(this), this.setUniform1i(t17, r11.unit), this._context.bindTexture(e23, r11.unit), r11.unit;
  }
  rebindTextures() {
    var _a;
    this._context.useProgram(this), this._textures.forEach((t17, e23) => {
      this._context.bindTexture(t17.texture, t17.unit), this.setUniform1i(e23, t17.unit);
    }), (_a = this._fragmentUniforms) == null ? void 0 : _a.forEach((t17) => {
      "sampler2D" !== t17.type && "samplerCube" !== t17.type || this._textures.has(t17.name) || console.error(`Texture sampler ${t17.name} has no bound texture`);
    });
  }
  _allocTextureUnit(t17) {
    return { texture: t17, unit: 0 === this._freeTextureUnits.length ? this._textures.size : this._freeTextureUnits.pop() };
  }
  _freeTextureUnit(t17) {
    this._freeTextureUnits.push(t17.unit);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderTechnique/ShaderTechnique.js
var n13 = class {
  constructor(o22, s8, a10, n18, l7 = O2) {
    this.release = n18, this.locations = l7, this.primitiveType = E.TRIANGLES, this.key = s8.key, this._program = new r6(o22.rctx, a10.get().build(s8), l7), this._pipeline = this.initializePipeline(s8), this.reload = async (e23) => {
      if (e23 && await a10.reload(), !this.key.equals(s8.key)) throw new Error("Configuration was changed after construction, cannot reload shader");
      r2(this._program), this._program = new r6(o22.rctx, a10.get().build(s8), l7), this._pipeline = this.initializePipeline(s8);
    };
  }
  destroy() {
    this._program = r2(this._program), this._pipeline = null;
  }
  get program() {
    return this._program;
  }
  get compiled() {
    return this.program.compiled;
  }
  ensureAttributeLocations(i6) {
    this.program.assertCompatibleVertexAttributeLocations(i6);
  }
  getPipeline(i6, e23) {
    return this._pipeline;
  }
  initializePipeline(i6) {
    return B({ blending: o11, colorWrite: g });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOBlurTechnique.js
var l3 = class extends n13 {
  constructor(r11, s8, i6) {
    super(r11, s8, new t9(f, () => import("./SSAOBlur.glsl-MKED2M5F.js")), i6);
  }
  initializePipeline() {
    return B({ colorWrite: g });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAONoiseData.js
var e19 = "eXKEvZaUc66cjIKElE1jlJ6MjJ6Ufkl+jn2fcXp5jBx7c6KEflSGiXuXeW6OWs+tfqZ2Yot2Y7Zzfo2BhniEj3xoiXuXj4eGZpqEaHKDWjSMe7palFlzc3BziYOGlFVzg6Zzg7CUY5JrjFF7eYJ4jIKEcyyEonSXe7qUfqZ7j3xofqZ2c4R5lFZ5Y0WUbppoe1l2cIh2ezyUho+BcHN2cG6DbpqJhqp2e1GcezhrdldzjFGUcyxjc3aRjDyEc1h7Sl17c6aMjH92pb6Mjpd4dnqBjMOEhqZleIOBYzB7gYx+fnqGjJuEkWlwnCx7fGl+c4hjfGyRe5qMlNOMfnqGhIWHc6OMi4GDc6aMfqZuc6aMzqJzlKZ+lJ6Me3qRfoFue0WUhoR5UraEa6qMkXiPjMOMlJOGe7JrUqKMjK6MeYRzdod+Sl17boiPc6qEeYBlcIh2c1WEe7GDiWCDa0WMjEmMdod+Y0WcdntzhmN8WjyMjKJjiXtzgYxYaGd+a89zlEV7e2GJfnd+lF1rcK5zc4p5cHuBhL6EcXp5eYB7fnh8iX6HjIKEeaxuiYOGc66RfG2Ja5hzjlGMjEmMe9OEgXuPfHyGhPeEdl6JY02McGuMfnqGhFiMa3WJfnx2l4hwcG1uhmN8c0WMc39og1GBbrCEjE2EZY+JcIh2cIuGhIWHe0mEhIVrc09+gY5+eYBlnCyMhGCDl3drfmmMgX15aGd+gYx+fnuRfnhzY1SMsluJfnd+hm98WtNrcIuGh4SEj0qPdkqOjFF7jNNjdnqBgaqUjMt7boeBhnZ4jDR7c5pze4GGjEFrhLqMjHyMc0mUhKZze4WEa117kWlwbpqJjHZ2eX2Bc09zeId+e0V7WlF7jHJ2l72BfId8l3eBgXyBe897jGl7c66cgW+Xc76EjKNbgaSEjGx4fId8jFFjgZB8cG6DhlFziZhrcIh2fH6HgUqBgXiPY8dahGFzjEmMhEFre2dxhoBzc5SGfleGe6alc7aUeYBlhKqUdlp+cH5za4OEczxza0Gcc4J2jHZ5iXuXjH2Jh5yRjH2JcFx+hImBjH+MpddCl3dreZeJjIt8ZW18bm1zjoSEeIOBlF9oh3N7hlqBY4+UeYFwhLJjeYFwaGd+gUqBYxiEYot2fqZ2ondzhL6EYyiEY02Ea0VjgZB8doaGjHxoc66cjEGEiXuXiXWMiZhreHx8frGMe75rY02Ec5pzfnhzlEp4a3VzjM+EhFFza3mUY7Zza1V5e2iMfGyRcziEhDyEkXZ2Y4OBnCx7g5t2eyBjgV6EhEFrcIh2dod+c4Z+nJ5zjm15jEmUeYxijJp7nL6clIpjhoR5WrZraGd+fnuRa6pzlIiMg6ZzfHx5foh+eX1ufnB5eX1ufnB5aJt7UqKMjIh+e3aBfm5lbYSBhGFze6J4c39oc0mUc4Z+e0V7fKFVe0WEdoaGY02Ec4Z+Y02EZYWBfH6HgU1+gY5+hIWUgW+XjJ57ebWRhFVScHuBfJ6PhBx7WqJzlM+Ujpd4gHZziX6HjHmEgZN+lJt5boiPe2GJgX+GjIGJgHZzeaxufnB5hF2JtdN7jJ57hp57hK6ElFVzg6ZzbmiEbndzhIWHe3uJfoFue3qRhJd2j3xoc65zlE1jc3p8lE1jhniEgXJ7e657vZaUc3qBh52BhIF4aHKDa9drgY5+c52GWqZzbpqJe8tjnM+UhIeMfo2BfGl+hG1zSmmMjKJjZVaGgX15c1lze0mEp4OHa3mUhIWHhDyclJ6MeYOJkXiPc0VzhFiMlKaEboSJa5Jze41re3qRhn+HZYWBe0mEc4p5fnORbox5lEp4hGFjhGGEjJuEc1WEhLZjeHeGa7KlfHx2hLaMeX1ugY5+hIWHhKGPjMN7c1WEho1zhoBzZYx7fnhzlJt5exyUhFFziXtzfmmMa6qMYyiEiXxweV12kZSMeWqXSl17fnhzxmmMrVGEe1mcc4p5eHeGjK6MgY5+doaGa6pzlGV7g1qBh4KHkXiPeW6OaKqafqZ2eXZ5e1V7jGd7boSJc3BzhJd2e0mcYot2h1RoY8dahK6EQmWEWjx7e1l2lL6UgXyBdnR4eU9zc0VreX1umqaBhld7fo2Bc6KEc5Z+hDyEcIeBWtNrfHyGe5qMhMuMe5qMhEGEbVVupcNzg3aHhIF4boeBe0mEdlptc39ofFl5Y8uUlJOGiYt2UmGEcyxjjGx4jFF7a657ZYWBnElzhp57iXtrgZN+tfOEhIOBjE2HgU1+e8tjjKNbiWCDhE15gUqBgYN7fnqGc66ce9d7iYSBj0qPcG6DnGGcT3eGa6qMZY+JlIiMl4hwc3aRdnqBlGV7eHJ2hLZjfnuRhDyEeX6MSk17g6Z+c6aUjHmEhIF4gXyBc76EZW18fGl+fkl+jCxrhoVwhDyUhIqGlL2DlI6EhJd2tdN7eYORhEGMa2Faa6pzc3Bzc4R5lIRznM+UY9eMhDycc5Z+c4p5c4iGY117pb6MgXuPrbJafnx2eYOJeXZ5e657hDyEcziElKZjfoB5eHeGj4WRhGGEe6KGeX1utTStc76EhFGJnCyMa5hzfH6HnNeceYB7hmN8gYuMhIVrczSMgYF8h3N7c5pza5hzjJqEYIRdgYuMlL2DeYRzhGGEeX1uhLaEc4iGeZ1zdl6JhrVteX6Me2iMfm5lWqJzSpqEa6pzdnmchHx2c6OMhNdrhoR5g3aHczxzeW52gV6Ejm15frGMc0Vzc4Z+l3drfniJe+9rWq5rlF1rhGGEhoVwe9OEfoh+e7pac09+c3qBY0lrhDycdnp2lJ6MiYOGhGCDc3aRlL2DlJt5doaGdnp2gYF8gWeOjF2Uc4R5c5Z+jEmMe7KEc4mEeYJ4dmyBe0mcgXiPbqJ7eYB7fmGGiYSJjICGlF1reZ2PnElzbpqJfH6Hc39oe4WEc5eJhK6EhqyJc3qBgZB8c09+hEmEaHKDhFGJc5SGiXWMUpaEa89zc6OMnCyMiXtrho+Be5qMc7KEjJ57dmN+hKGPjICGbmiEe7prdod+hGCDdnmchBx7eX6MkXZ2hGGEa657hm98jFFjY5JreYOJgY2EjHZ2a295Y3FajJ6Mc1J+YzB7e4WBjF2Uc4R5eV12gYxzg1qBeId+c9OUc5pzjFFjgY5+hFiMlIaPhoR5lIpjjIKBlNdSe7KEeX2BfrGMhIqGc65zjE2UhK6EklZ+QmWEeziMWqZza3VzdnR4foh+gYF8n3iJiZhrnKp7gYF8eId+lJ6Me1lrcIuGjKJjhmN8c66MjFF7a6prjJ6UnJ5zezyUfruRWlF7nI5zfHyGe657h4SEe8tjhBx7jFFjc09+c39ojICMeZeJeXt+YzRzjHZ2c0WEcIeBeXZ5onSXkVR+gYJ+eYFwdldzgYF7eX2BjJ6UiXuXlE1jh4SEe1mchLJjc4Z+hqZ7eXZ5bm1zlL6Ue5p7iWeGhKqUY5pzjKJjcIeBe8t7gXyBYIRdlEp4a3mGnK6EfmmMZpqEfFl5gYxzjKZuhGFjhoKGhHx2fnx2eXuMe3aBiWeGvbKMe6KGa5hzYzB7gZOBlGV7hmN8hqZlYot2Y117a6pzc6KEfId8foB5rctrfneJfJ6PcHN2hFiMc5pzjH92c0VzgY2EcElzdmCBlFVzg1GBc65zY4OBboeBcHiBeYJ4ewxzfHx5lIRzlEmEnLKEbk1zfJ6PhmN8eYBljBiEnMOEiXxwezyUcIeBe76EdsKEeX2BdnR4jGWUrXWMjGd7fkl+j4WRlEGMa5Jzho+BhDyEfnqMeXt+g3aHlE1jczClhNN7ZW18eHx8hGFjZW18iXWMjKJjhH57gYuMcIuGWjyMe4ZtjJuExmmMj4WRdntzi4GDhFFzYIRdnGGcjJp7Y0F7e4WEkbCGiX57fnSHa657a6prhBCMe3Z+SmmMjH92eHJ2hK6EY1FzexhrvbKMnI5za4OEfnd+eXuMhImBe897hLaMjN+EfG+BeIOBhF1+eZeJi4GDkXZ2eXKEgZ6Ejpd4c2GHa1V5e5KUfqZuhCx7jKp7lLZrg11+hHx2hFWUoot2nI5zgbh5mo9zvZaUe3qRbqKMfqZ2kbCGhFiM";

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOParameters.js
var r7 = class extends t3 {
  constructor() {
    super(...arguments), this.projScale = 1;
  }
};
var t10 = class extends r7 {
  constructor() {
    super(...arguments), this.intensity = 1;
  }
};
var c4 = class extends t3 {
};
var o18 = class extends c4 {
  constructor() {
    super(...arguments), this.blurSize = n4();
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAOTechnique.js
var t11 = class extends n13 {
  constructor(r11, s8, i6) {
    super(r11, s8, new t9(v, () => import("./SSAO.glsl-TTMZGASE.js")), i6);
  }
  initializePipeline() {
    return B({ colorWrite: g });
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/effects/ssao/SSAO.js
var A = 2;
var O4 = class extends c3 {
  constructor(e23) {
    super(e23), this.consumes = { required: ["normals"] }, this.produces = t8.SSAO, this.isEnabled = () => false, this._enableTime = n(0), this._passParameters = new t10(), this._drawParameters = new o18();
  }
  initialize() {
    const e23 = Uint8Array.from(atob(e19), (e24) => e24.charCodeAt(0)), r11 = new p();
    r11.wrapMode = D.CLAMP_TO_EDGE, r11.pixelFormat = G.RGB, r11.wrapMode = D.REPEAT, r11.hasMipmap = true, r11.width = 32, r11.height = 32, this._passParameters.noiseTexture = new m2(this.renderingContext, r11, e23), this.techniques.precompile(t11), this.techniques.precompile(l3), this.addHandles(d(() => this.isEnabled(), () => this._enableTime = n(0)));
  }
  destroy() {
    this._passParameters.noiseTexture = r2(this._passParameters.noiseTexture);
  }
  render(e23) {
    const s8 = this.bindParameters, t17 = e23.find(({ name: e24 }) => "normals" === e24), o22 = t17 == null ? void 0 : t17.getTexture(), a10 = t17 == null ? void 0 : t17.getTexture(t2), p4 = this.fboCache, d8 = s8.camera, f6 = d8.fullViewport[2], b2 = d8.fullViewport[3], _3 = Math.round(f6 / A), P4 = Math.round(b2 / A), x2 = this.techniques.acquire(t11), q = this.techniques.acquire(l3);
    if (!x2.compiled || !q.compiled) return this._enableTime = n(performance.now()), this.requestRender(a4.UPDATE), x2.release(), q.release(), p4.acquire(_3, P4, t8.SSAO, R.RED);
    0 === this._enableTime && (this._enableTime = n(performance.now()));
    const O5 = this.renderingContext, E3 = this.view.qualitySettings.fadeDuration, v3 = d8.relativeElevation, R2 = r3((o17 - v3) / (o17 - e18), 0, 1), C2 = E3 > 0 ? Math.min(E3, performance.now() - this._enableTime) / E3 : 1, D2 = C2 * R2;
    this._passParameters.normalTexture = o22, this._passParameters.depthTexture = a10, this._passParameters.projScale = 1 / d8.computeScreenPixelSizeAtDist(1), this._passParameters.intensity = 4 * y / d3(d8) ** 6 * D2;
    const V = p4.acquire(f6, b2, "ssao input", R.RG);
    O5.bindFramebuffer(V.fbo), O5.setViewport(0, 0, f6, b2), O5.bindTechnique(x2, s8, this._passParameters, this._drawParameters), O5.screen.draw(), x2.release();
    const M3 = p4.acquire(_3, P4, "ssao blur", R.RED);
    O5.bindFramebuffer(M3.fbo), this._drawParameters.colorTexture = V.getTexture(), o(this._drawParameters.blurSize, 0, A / b2), O5.bindTechnique(q, s8, this._passParameters, this._drawParameters), O5.setViewport(0, 0, _3, P4), O5.screen.draw(), V.release();
    const L2 = p4.acquire(_3, P4, t8.SSAO, R.RED);
    return O5.bindFramebuffer(L2.fbo), O5.setViewport(0, 0, f6, b2), O5.setClearColor(1, 1, 1, 0), O5.clear(_2.COLOR), this._drawParameters.colorTexture = M3.getTexture(), o(this._drawParameters.blurSize, A / f6, 0), O5.bindTechnique(q, s8, this._passParameters, this._drawParameters), O5.setViewport(0, 0, _3, P4), O5.screen.draw(), q.release(), O5.setViewport4fv(d8.fullViewport), M3.release(), C2 < 1 && this.requestRender(a4.UPDATE), L2;
  }
};
r([m()], O4.prototype, "consumes", void 0), r([m()], O4.prototype, "produces", void 0), r([m({ constructOnly: true })], O4.prototype, "techniques", void 0), r([m({ constructOnly: true })], O4.prototype, "isEnabled", void 0), O4 = r([a("esri.views.3d.webgl-engine.effects.ssao.SSAO")], O4);
var y = 0.5;

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js
function t12(t17, o22) {
  const a10 = t17.fragment;
  o22.receiveAmbientOcclusion ? (a10.uniforms.add(new s4("ssaoTex", (e23, s8) => {
    var _a;
    return (_a = s8.ssao) == null ? void 0 : _a.getTexture();
  })), a10.constants.add("blurSizePixelsInverse", "float", 1 / A), a10.code.add(o5`float evaluateAmbientOcclusionInverse() {
vec2 ssaoTextureSizeInverse = 1.0 / vec2(textureSize(ssaoTex, 0));
return texture(ssaoTex, gl_FragCoord.xy * blurSizePixelsInverse * ssaoTextureSizeInverse).r;
}
float evaluateAmbientOcclusion() {
return 1.0 - evaluateAmbientOcclusionInverse();
}`)) : a10.code.add(o5`float evaluateAmbientOcclusionInverse() { return 1.0; }
float evaluateAmbientOcclusion() { return 0.0; }`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/TextureAtlasLookup.glsl.js
function e20(e23) {
  e23.fragment.code.add(o5`vec4 textureAtlasLookup(sampler2D tex, vec2 textureCoordinates, vec4 atlasRegion) {
vec2 atlasScale = atlasRegion.zw - atlasRegion.xy;
vec2 uvAtlas = fract(textureCoordinates) * atlasScale + atlasRegion.xy;
float maxdUV = 0.125;
vec2 dUVdx = clamp(dFdx(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
vec2 dUVdy = clamp(dFdy(textureCoordinates), -maxdUV, maxdUV) * atlasScale;
return textureGrad(tex, uvAtlas, dUVdx, dUVdy);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/attributes/VertexTextureCoordinates.glsl.js
function u3(u7, n18) {
  const { textureCoordinateType: s8 } = n18;
  if (s8 === d5.None || s8 === d5.COUNT) return;
  u7.include(o16, n18);
  const i6 = s8 === d5.Atlas;
  i6 && u7.include(e20), u7.fragment.code.add(o5`
    vec4 textureLookup(sampler2D tex, vec2 uv) {
      return ${i6 ? "textureAtlasLookup(tex, uv, vuvRegion)" : "texture(tex, uv)"};
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLMaterial.js
var t13 = class {
  constructor(e23) {
    this._material = e23.material, this._techniques = e23.techniques, this._output = e23.output;
  }
  dispose() {
  }
  get _stippleTextures() {
    return this._techniques.context.stippleTextures;
  }
  get _markerTextures() {
    return this._techniques.context.markerTextures;
  }
  acquireTechnique(e23, t17) {
    return this._techniques.acquire(e23, this._material.getConfiguration(this._output, t17));
  }
  ensureResources(t17) {
    return O.LOADED;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/lib/GLTextureMaterial.js
var u4 = class extends t13 {
  constructor(t17) {
    super(t17), this._numLoading = 0, this._disposed = false, this._textures = t17.textures, this._textureId = t17.textureId, this._acquire(t17.textureId, (t18) => this._texture = t18), this._acquire(t17.normalTextureId, (t18) => this._textureNormal = t18), this._acquire(t17.emissiveTextureId, (t18) => this._textureEmissive = t18), this._acquire(t17.occlusionTextureId, (t18) => this._textureOcclusion = t18), this._acquire(t17.metallicRoughnessTextureId, (t18) => this._textureMetallicRoughness = t18);
  }
  dispose() {
    super.dispose(), this._texture = t(this._texture), this._textureNormal = t(this._textureNormal), this._textureEmissive = t(this._textureEmissive), this._textureOcclusion = t(this._textureOcclusion), this._textureMetallicRoughness = t(this._textureMetallicRoughness), this._disposed = true;
  }
  ensureResources(t17) {
    return 0 === this._numLoading ? O.LOADED : O.LOADING;
  }
  get textureBindParameters() {
    return new h2(null != this._texture ? this._texture.glTexture : null, null != this._textureNormal ? this._textureNormal.glTexture : null, null != this._textureEmissive ? this._textureEmissive.glTexture : null, null != this._textureOcclusion ? this._textureOcclusion.glTexture : null, null != this._textureMetallicRoughness ? this._textureMetallicRoughness.glTexture : null);
  }
  updateTexture(e23) {
    null != this._texture && e23 === this._texture.id || (this._texture = t(this._texture), this._textureId = e23, this._acquire(this._textureId, (t17) => this._texture = t17));
  }
  _acquire(s8, i6) {
    if (null == s8) return void i6(null);
    const r11 = this._textures.acquire(s8);
    if (S(r11)) return ++this._numLoading, void r11.then((e23) => {
      if (this._disposed) return t(e23), void i6(null);
      i6(e23);
    }).finally(() => --this._numLoading);
    i6(r11);
  }
};
var l4 = class extends t3 {
  constructor(t17 = null) {
    super(), this.textureEmissive = t17;
  }
};
var h2 = class extends l4 {
  constructor(t17 = null, e23 = null, s8 = null, i6 = null, r11 = null, u7, l7) {
    super(s8), this.texture = t17, this.textureNormal = e23, this.textureOcclusion = i6, this.textureMetallicRoughness = r11, this.scale = u7, this.normalTextureTransformMatrix = l7;
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js
var n14;
!function(e23) {
  e23[e23.Disabled = 0] = "Disabled", e23[e23.Normal = 1] = "Normal", e23[e23.Schematic = 2] = "Schematic", e23[e23.Water = 3] = "Water", e23[e23.WaterOnIntegratedMesh = 4] = "WaterOnIntegratedMesh", e23[e23.Simplified = 5] = "Simplified", e23[e23.TerrainWithWater = 6] = "TerrainWithWater", e23[e23.COUNT = 7] = "COUNT";
}(n14 || (n14 = {}));
function m3(l7, u7) {
  const d8 = u7.pbrMode, m6 = l7.fragment;
  if (d8 !== n14.Schematic && d8 !== n14.Disabled && d8 !== n14.Normal) return void m6.code.add(o5`void applyPBRFactors() {}`);
  if (d8 === n14.Disabled) return void m6.code.add(o5`void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
  if (d8 === n14.Schematic) return void m6.code.add(o5`vec3 mrr = vec3(0.0, 0.6, 0.2);
float occlusion = 1.0;
void applyPBRFactors() {}
float getBakedOcclusion() { return 1.0; }`);
  const { hasMetallicRoughnessTexture: p4, hasMetallicRoughnessTextureTransform: h4, hasOcclusionTexture: f6, hasOcclusionTextureTransform: v3, bindType: x2 } = u7;
  (p4 || f6) && l7.include(u3, u7), m6.code.add(o5`vec3 mrr;
float occlusion;`), p4 && m6.uniforms.add(x2 === a3.Pass ? new s4("texMetallicRoughness", (e23) => e23.textureMetallicRoughness) : new s3("texMetallicRoughness", (e23) => e23.textureMetallicRoughness)), f6 && m6.uniforms.add(x2 === a3.Pass ? new s4("texOcclusion", (e23) => e23.textureOcclusion) : new s3("texOcclusion", (e23) => e23.textureOcclusion)), m6.uniforms.add(x2 === a3.Pass ? new e6("mrrFactors", (e23) => e23.mrrFactors) : new o6("mrrFactors", (e23) => e23.mrrFactors)), m6.code.add(o5`
    ${r4(p4, o5`void applyMetallicRoughness(vec2 uv) {
            vec3 metallicRoughness = textureLookup(texMetallicRoughness, uv).rgb;
            mrr[0] *= metallicRoughness.b;
            mrr[1] *= metallicRoughness.g;
          }`)}

    ${r4(f6, "void applyOcclusion(vec2 uv) { occlusion *= textureLookup(texOcclusion, uv).r; }")}

    float getBakedOcclusion() {
      return ${f6 ? "occlusion" : "1.0"};
    }

    void applyPBRFactors() {
      mrr = mrrFactors;
      occlusion = 1.0;

      ${r4(p4, `applyMetallicRoughness(${h4 ? "metallicRoughnessUV" : "vuv0"});`)}
      ${r4(f6, `applyOcclusion(${v3 ? "occlusionUV" : "vuv0"});`)}
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js
function t14(n18) {
  n18.uniforms.add(new e6("mainLightDirection", (i6, n19) => n19.lighting.mainLight.direction));
}
function a8(n18) {
  n18.uniforms.add(new e6("mainLightIntensity", (i6, n19) => n19.lighting.mainLight.intensity));
}
function o19(i6) {
  t14(i6.fragment), a8(i6.fragment), i6.fragment.code.add(o5`vec3 applyShading(vec3 shadingNormalWorld, float shadow) {
float dotVal = clamp(dot(shadingNormalWorld, mainLightDirection), 0.0, 1.0);
return mainLightIntensity * ((1.0 - shadow) * dotVal);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/AnalyticalSkyModel.glsl.js
function t15(t17) {
  const a10 = t17.fragment.code;
  a10.add(o5`vec3 evaluateDiffuseIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float NdotNG)
{
return ((1.0 - NdotNG) * ambientGround + (1.0 + NdotNG) * ambientSky) * 0.5;
}`), a10.add(o5`float integratedRadiance(float cosTheta2, float roughness)
{
return (cosTheta2 - 1.0) / (cosTheta2 * (1.0 - roughness * roughness) - 1.0);
}`), a10.add(o5`vec3 evaluateSpecularIlluminationHemisphere(vec3 ambientGround, vec3 ambientSky, float RdotNG, float roughness)
{
float cosTheta2 = 1.0 - RdotNG * RdotNG;
float intRadTheta = integratedRadiance(cosTheta2, roughness);
float ground = RdotNG < 0.0 ? 1.0 - intRadTheta : 1.0 + intRadTheta;
float sky = 2.0 - ground;
return (ground * ambientGround + sky * ambientSky) * 0.5;
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PiUtils.glsl.js
function t16(t17) {
  const a10 = 3.141592653589793, n18 = 0.3183098861837907;
  t17.vertex.constants.add("PI", "float", a10), t17.fragment.constants.add("PI", "float", a10), t17.fragment.constants.add("LIGHT_NORMALIZATION", "float", n18), t17.fragment.constants.add("INV_PI", "float", n18), t17.fragment.constants.add("HALF_PI", "float", 1.570796326794897), t17.fragment.constants.add("TWO_PI", "float", 6.28318530717958);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRendering.glsl.js
function n15(n18, r11) {
  const l7 = n18.fragment.code;
  n18.include(t16), r11.pbrMode !== n14.Normal && r11.pbrMode !== n14.Schematic && r11.pbrMode !== n14.Simplified && r11.pbrMode !== n14.TerrainWithWater || (l7.add(o5`float normalDistribution(float NdotH, float roughness)
{
float a = NdotH * roughness;
float b = roughness / (1.0 - NdotH * NdotH + a * a);
return b * b * INV_PI;
}`), l7.add(o5`const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);
const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);
const vec2 c2 = vec2(-1.04, 1.04);
vec2 prefilteredDFGAnalytical(float roughness, float NdotV) {
vec4 r = roughness * c0 + c1;
float a004 = min(r.x * r.x, exp2(-9.28 * NdotV)) * r.x + r.y;
return c2 * a004 + r.zw;
}`)), r11.pbrMode !== n14.Normal && r11.pbrMode !== n14.Schematic || (n18.include(t15), l7.add(o5`struct PBRShadingInfo
{
float NdotV;
float LdotH;
float NdotNG;
float RdotNG;
float NdotAmbDir;
float NdotH_Horizon;
vec3 skyRadianceToSurface;
vec3 groundRadianceToSurface;
vec3 skyIrradianceToSurface;
vec3 groundIrradianceToSurface;
float averageAmbientRadiance;
float ssao;
vec3 albedoLinear;
vec3 f0;
vec3 f90;
vec3 diffuseColor;
float metalness;
float roughness;
};`), l7.add(o5`vec3 evaluateEnvironmentIllumination(PBRShadingInfo inputs) {
vec3 indirectDiffuse = evaluateDiffuseIlluminationHemisphere(inputs.groundIrradianceToSurface, inputs.skyIrradianceToSurface, inputs.NdotNG);
vec3 indirectSpecular = evaluateSpecularIlluminationHemisphere(inputs.groundRadianceToSurface, inputs.skyRadianceToSurface, inputs.RdotNG, inputs.roughness);
vec3 diffuseComponent = inputs.diffuseColor * indirectDiffuse * INV_PI;
vec2 dfg = prefilteredDFGAnalytical(inputs.roughness, inputs.NdotV);
vec3 specularColor = inputs.f0 * dfg.x + inputs.f90 * dfg.y;
vec3 specularComponent = specularColor * indirectSpecular;
return (diffuseComponent + specularComponent);
}`), l7.add(o5`float gamutMapChanel(float x, vec2 p){
return (x < p.x) ? mix(0.0, p.y, x/p.x) : mix(p.y, 1.0, (x - p.x) / (1.0 - p.x) );
}`), l7.add(o5`vec3 blackLevelSoftCompression(vec3 inColor, PBRShadingInfo inputs){
vec3 outColor;
vec2 p = vec2(0.02 * (inputs.averageAmbientRadiance), 0.0075 * (inputs.averageAmbientRadiance));
outColor.x = gamutMapChanel(inColor.x, p) ;
outColor.y = gamutMapChanel(inColor.y, p) ;
outColor.z = gamutMapChanel(inColor.z, p) ;
return outColor;
}`));
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientLighting.glsl.js
function r8(n18, g4) {
  const r11 = n18.fragment, o22 = void 0 !== g4.lightingSphericalHarmonicsOrder ? g4.lightingSphericalHarmonicsOrder : 2;
  0 === o22 ? (r11.uniforms.add(new e6("lightingAmbientSH0", (n19, t17) => o2(a9, t17.lighting.sh.r[0], t17.lighting.sh.g[0], t17.lighting.sh.b[0]))), r11.code.add(o5`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 1 === o22 ? (r11.uniforms.add(new e11("lightingAmbientSH_R", (i6, n19) => s2(m4, n19.lighting.sh.r[0], n19.lighting.sh.r[1], n19.lighting.sh.r[2], n19.lighting.sh.r[3])), new e11("lightingAmbientSH_G", (i6, n19) => s2(m4, n19.lighting.sh.g[0], n19.lighting.sh.g[1], n19.lighting.sh.g[2], n19.lighting.sh.g[3])), new e11("lightingAmbientSH_B", (i6, n19) => s2(m4, n19.lighting.sh.b[0], n19.lighting.sh.b[1], n19.lighting.sh.b[2], n19.lighting.sh.b[3]))), r11.code.add(o5`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec4 sh0 = vec4(
0.282095,
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y
);
vec3 ambientLight = vec3(
dot(lightingAmbientSH_R, sh0),
dot(lightingAmbientSH_G, sh0),
dot(lightingAmbientSH_B, sh0)
);
return ambientLight * (1.0 - ambientOcclusion);
}`)) : 2 === o22 && (r11.uniforms.add(new e6("lightingAmbientSH0", (n19, t17) => o2(a9, t17.lighting.sh.r[0], t17.lighting.sh.g[0], t17.lighting.sh.b[0])), new e11("lightingAmbientSH_R1", (i6, n19) => s2(m4, n19.lighting.sh.r[1], n19.lighting.sh.r[2], n19.lighting.sh.r[3], n19.lighting.sh.r[4])), new e11("lightingAmbientSH_G1", (i6, n19) => s2(m4, n19.lighting.sh.g[1], n19.lighting.sh.g[2], n19.lighting.sh.g[3], n19.lighting.sh.g[4])), new e11("lightingAmbientSH_B1", (i6, n19) => s2(m4, n19.lighting.sh.b[1], n19.lighting.sh.b[2], n19.lighting.sh.b[3], n19.lighting.sh.b[4])), new e11("lightingAmbientSH_R2", (i6, n19) => s2(m4, n19.lighting.sh.r[5], n19.lighting.sh.r[6], n19.lighting.sh.r[7], n19.lighting.sh.r[8])), new e11("lightingAmbientSH_G2", (i6, n19) => s2(m4, n19.lighting.sh.g[5], n19.lighting.sh.g[6], n19.lighting.sh.g[7], n19.lighting.sh.g[8])), new e11("lightingAmbientSH_B2", (i6, n19) => s2(m4, n19.lighting.sh.b[5], n19.lighting.sh.b[6], n19.lighting.sh.b[7], n19.lighting.sh.b[8]))), r11.code.add(o5`vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {
vec3 ambientLight = 0.282095 * lightingAmbientSH0;
vec4 sh1 = vec4(
0.488603 * normal.x,
0.488603 * normal.z,
0.488603 * normal.y,
1.092548 * normal.x * normal.y
);
vec4 sh2 = vec4(
1.092548 * normal.y * normal.z,
0.315392 * (3.0 * normal.z * normal.z - 1.0),
1.092548 * normal.x * normal.z,
0.546274 * (normal.x * normal.x - normal.y * normal.y)
);
ambientLight += vec3(
dot(lightingAmbientSH_R1, sh1),
dot(lightingAmbientSH_G1, sh1),
dot(lightingAmbientSH_B1, sh1)
);
ambientLight += vec3(
dot(lightingAmbientSH_R2, sh2),
dot(lightingAmbientSH_G2, sh2),
dot(lightingAmbientSH_B2, sh2)
);
return ambientLight * (1.0 - ambientOcclusion);
}`), g4.pbrMode !== n14.Normal && g4.pbrMode !== n14.Schematic || r11.code.add(o5`const vec3 skyTransmittance = vec3(0.9, 0.9, 1.0);
vec3 calculateAmbientRadiance(float ambientOcclusion)
{
vec3 ambientLight = 1.2 * (0.282095 * lightingAmbientSH0) - 0.2;
return ambientLight *= (1.0 - ambientOcclusion) * skyTransmittance;
}`));
}
var a9 = n2();
var m4 = n3();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SphericalHarmonics.js
var P3 = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/lighting/SceneLighting.js
var l6 = 0.4;
var L = n2();

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js
function h3(i6) {
  i6.constants.add("ambientBoostFactor", "float", l6);
}
function u6(i6) {
  i6.uniforms.add(new o7("lightingGlobalFactor", (i7, n18) => n18.lighting.globalFactor));
}
function p3(g4, p4) {
  const v3 = g4.fragment;
  switch (g4.include(t12, p4), p4.pbrMode !== n14.Disabled && g4.include(n15, p4), g4.include(r8, p4), g4.include(t16), v3.code.add(o5`
    const float GAMMA_SRGB = 2.1;
    const float INV_GAMMA_SRGB = 0.4761904;
    ${p4.pbrMode === n14.Disabled ? "" : "const vec3 GROUND_REFLECTANCE = vec3(0.2);"}
  `), h3(v3), u6(v3), t14(v3), v3.code.add(o5`
    float additionalDirectedAmbientLight(vec3 vPosWorld) {
      float vndl = dot(${p4.spherical ? o5`normalize(vPosWorld)` : o5`vec3(0.0, 0.0, 1.0)`}, mainLightDirection);
      return smoothstep(0.0, 1.0, clamp(vndl * 2.5, 0.0, 1.0));
    }
  `), a8(v3), v3.code.add(o5`vec3 evaluateAdditionalLighting(float ambientOcclusion, vec3 vPosWorld) {
float additionalAmbientScale = additionalDirectedAmbientLight(vPosWorld);
return (1.0 - ambientOcclusion) * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor * mainLightIntensity;
}`), p4.pbrMode) {
    case n14.Disabled:
    case n14.WaterOnIntegratedMesh:
    case n14.Water:
      g4.include(o19), v3.code.add(o5`vec3 evaluateSceneLighting(vec3 normalWorld, vec3 albedo, float shadow, float ssao, vec3 additionalLight) {
vec3 mainLighting = applyShading(normalWorld, shadow);
vec3 ambientLighting = calculateAmbientIrradiance(normalWorld, ssao);
vec3 albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
vec3 totalLight = mainLighting + ambientLighting + additionalLight;
totalLight = min(totalLight, vec3(PI));
vec3 outColor = vec3((albedoLinear / PI) * totalLight);
return pow(outColor, vec3(INV_GAMMA_SRGB));
}`);
      break;
    case n14.Normal:
    case n14.Schematic:
      v3.code.add(o5`const float fillLightIntensity = 0.25;
const float horizonLightDiffusion = 0.4;
const float additionalAmbientIrradianceFactor = 0.02;
vec3 evaluateSceneLightingPBR(vec3 normal, vec3 albedo, float shadow, float ssao, vec3 additionalLight, vec3 viewDir, vec3 normalGround, vec3 mrr, vec4 _emission, float additionalAmbientIrradiance)
{
vec3 viewDirection = -viewDir;
vec3 h = normalize(viewDirection + mainLightDirection);
PBRShadingInfo inputs;
inputs.NdotV = clamp(abs(dot(normal, viewDirection)), 0.001, 1.0);
inputs.NdotNG = clamp(dot(normal, normalGround), -1.0, 1.0);
vec3 reflectedView = normalize(reflect(viewDirection, normal));
inputs.RdotNG = clamp(dot(reflectedView, normalGround), -1.0, 1.0);
inputs.albedoLinear = pow(albedo, vec3(GAMMA_SRGB));
inputs.ssao = ssao;
inputs.metalness = mrr[0];
inputs.roughness = clamp(mrr[1] * mrr[1], 0.001, 0.99);`), v3.code.add(o5`inputs.f0 = (0.16 * mrr[2] * mrr[2]) * (1.0 - inputs.metalness) + inputs.albedoLinear * inputs.metalness;
inputs.f90 = vec3(clamp(dot(inputs.f0, vec3(50.0 * 0.33)), 0.0, 1.0));
inputs.diffuseColor = inputs.albedoLinear * (vec3(1.0) - inputs.f0) * (1.0 - inputs.metalness);`), p4.useFillLights ? v3.uniforms.add(new s5("hasFillLights", (i6, n18) => n18.enableFillLights)) : v3.constants.add("hasFillLights", "bool", false), v3.code.add(o5`vec3 ambientDir = vec3(5.0 * normalGround[1] - normalGround[0] * normalGround[2], - 5.0 * normalGround[0] - normalGround[2] * normalGround[1], normalGround[1] * normalGround[1] + normalGround[0] * normalGround[0]);
ambientDir = ambientDir != vec3(0.0) ? normalize(ambientDir) : normalize(vec3(5.0, -1.0, 0.0));
inputs.NdotAmbDir = hasFillLights ? abs(dot(normal, ambientDir)) : 1.0;
float NdotL = clamp(dot(normal, mainLightDirection), 0.001, 1.0);
vec3 mainLightIrradianceComponent = NdotL * (1.0 - shadow) * mainLightIntensity;
vec3 fillLightsIrradianceComponent = inputs.NdotAmbDir * mainLightIntensity * fillLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(normal, ssao) + additionalLight;
inputs.skyIrradianceToSurface = ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;
inputs.groundIrradianceToSurface = GROUND_REFLECTANCE * ambientLightIrradianceComponent + mainLightIrradianceComponent + fillLightsIrradianceComponent ;`), v3.uniforms.add(new o7("lightingSpecularStrength", (i6, n18) => n18.lighting.mainLight.specularStrength), new o7("lightingEnvironmentStrength", (i6, n18) => n18.lighting.mainLight.environmentStrength)).code.add(o5`vec3 horizonRingDir = inputs.RdotNG * normalGround - reflectedView;
vec3 horizonRingH = normalize(viewDirection + horizonRingDir);
inputs.NdotH_Horizon = dot(normal, horizonRingH);
float NdotH = clamp(dot(normal, h), 0.0, 1.0);
vec3 mainLightRadianceComponent = lightingSpecularStrength * normalDistribution(NdotH, inputs.roughness) * mainLightIntensity * (1.0 - shadow);
vec3 horizonLightRadianceComponent = lightingEnvironmentStrength * normalDistribution(inputs.NdotH_Horizon, min(inputs.roughness + horizonLightDiffusion, 1.0)) * mainLightIntensity * fillLightIntensity;
vec3 ambientLightRadianceComponent = lightingEnvironmentStrength * calculateAmbientRadiance(ssao) + additionalLight;
float normalDirectionModifier = mix(1., min(mix(0.1, 2.0, (inputs.NdotNG + 1.) * 0.5), 1.0), clamp(inputs.roughness * 5.0, 0.0 , 1.0));
inputs.skyRadianceToSurface = (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.groundRadianceToSurface = 0.5 * GROUND_REFLECTANCE * (ambientLightRadianceComponent + horizonLightRadianceComponent) * normalDirectionModifier + mainLightRadianceComponent;
inputs.averageAmbientRadiance = ambientLightIrradianceComponent[1] * (1.0 + GROUND_REFLECTANCE[1]);`), v3.code.add(o5`
        vec3 reflectedColorComponent = evaluateEnvironmentIllumination(inputs);
        vec3 additionalMaterialReflectanceComponent = inputs.albedoLinear * additionalAmbientIrradiance;
        vec3 emissionComponent = _emission.rgb == vec3(0.0) ? _emission.rgb : pow(_emission.rgb, vec3(GAMMA_SRGB));
        vec3 outColorLinear = reflectedColorComponent + additionalMaterialReflectanceComponent + emissionComponent;
        ${p4.pbrMode !== n14.Schematic || p4.hasColorTexture ? o5`vec3 outColor = pow(blackLevelSoftCompression(outColorLinear, inputs), vec3(INV_GAMMA_SRGB));` : o5`vec3 outColor = pow(max(vec3(0.0), outColorLinear - 0.005 * inputs.averageAmbientRadiance), vec3(INV_GAMMA_SRGB));`}
        return outColor;
      }
    `);
      break;
    case n14.Simplified:
    case n14.TerrainWithWater:
      t14(v3), a8(v3), v3.code.add(o5`const float roughnessTerrain = 0.5;
const float specularityTerrain = 0.5;
const vec3 fresnelReflectionTerrain = vec3(0.04);
vec3 evaluatePBRSimplifiedLighting(vec3 n, vec3 c, float shadow, float ssao, vec3 al, vec3 vd, vec3 nup) {
vec3 viewDirection = -vd;
vec3 h = normalize(viewDirection + mainLightDirection);
float NdotL = clamp(dot(n, mainLightDirection), 0.001, 1.0);
float NdotV = clamp(abs(dot(n, viewDirection)), 0.001, 1.0);
float NdotH = clamp(dot(n, h), 0.0, 1.0);
float NdotNG = clamp(dot(n, nup), -1.0, 1.0);
vec3 albedoLinear = pow(c, vec3(GAMMA_SRGB));
float lightness = 0.3 * albedoLinear[0] + 0.5 * albedoLinear[1] + 0.2 * albedoLinear[2];
vec3 f0 = (0.85 * lightness + 0.15) * fresnelReflectionTerrain;
vec3 f90 =  vec3(clamp(dot(f0, vec3(50.0 * 0.33)), 0.0, 1.0));
vec3 mainLightIrradianceComponent = (1. - shadow) * NdotL * mainLightIntensity;
vec3 ambientLightIrradianceComponent = calculateAmbientIrradiance(n, ssao) + al;
vec3 ambientSky = ambientLightIrradianceComponent + mainLightIrradianceComponent;
vec3 indirectDiffuse = ((1.0 - NdotNG) * mainLightIrradianceComponent + (1.0 + NdotNG ) * ambientSky) * 0.5;
vec3 outDiffColor = albedoLinear * (1.0 - f0) * indirectDiffuse / PI;
vec3 mainLightRadianceComponent = normalDistribution(NdotH, roughnessTerrain) * mainLightIntensity;
vec2 dfg = prefilteredDFGAnalytical(roughnessTerrain, NdotV);
vec3 specularColor = f0 * dfg.x + f90 * dfg.y;
vec3 specularComponent = specularityTerrain * specularColor * mainLightRadianceComponent;
vec3 outColorLinear = outDiffColor + specularComponent;
vec3 outColor = pow(outColorLinear, vec3(INV_GAMMA_SRGB));
return outColor;
}`);
      break;
    default:
      n5(p4.pbrMode);
    case n14.COUNT:
  }
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sDrawUniform.js
var o21 = class extends a5 {
  constructor(r11, o22, s8) {
    super(r11, "mat4", a3.Draw, (e23, s9, t17, i6) => e23.setUniformMatrix4fv(r11, o22(s9, t17, i6)), s8);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderModules/Matrix4sPassUniform.js
var e22 = class extends a5 {
  constructor(r11, e23, o22) {
    super(r11, "mat4", a3.Pass, (s8, o23, t17) => s8.setUniformMatrix4fv(r11, e23(o23, t17)), o22);
  }
};

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js
function m5(e23, s8) {
  s8.receiveShadows && (e23.fragment.uniforms.add(new e22("shadowMapMatrix", (e24, s9) => s9.shadowMap.getShadowMapMatrices(e24.origin), 4)), f5(e23));
}
function x(e23, s8) {
  s8.receiveShadows && (e23.fragment.uniforms.add(new o21("shadowMapMatrix", (e24, s9) => s9.shadowMap.getShadowMapMatrices(e24.origin), 4)), f5(e23));
}
function f5(e23) {
  const s8 = e23.fragment;
  s8.include(a7), s8.uniforms.add(new s4("shadowMap", (e24, s9) => s9.shadowMap.depthTexture), new e10("numCascades", (e24, s9) => s9.shadowMap.numCascades), new e11("cascadeDistances", (e24, s9) => s9.shadowMap.cascadeDistances)).code.add(o5`int chooseCascade(float depth, out mat4 mat) {
vec4 distance = cascadeDistances;
int i = depth < distance[1] ? 0 : depth < distance[2] ? 1 : depth < distance[3] ? 2 : 3;
mat = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
return i;
}
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
float readShadowMapDepth(ivec2 uv, sampler2D _depthTex) {
return rgba4ToFloat(texelFetch(_depthTex, uv, 0));
}
float posIsInShadow(ivec2 uv, vec3 lvpos, sampler2D _depthTex) {
return readShadowMapDepth(uv, _depthTex) < lvpos.z ? 1.0 : 0.0;
}
float filterShadow(vec2 uv, vec3 lvpos, ivec2 texSize, sampler2D _depthTex) {
vec2 st = fract(uv * vec2(texSize) + vec2(0.5));
ivec2 base = ivec2(uv * vec2(texSize) - vec2(0.5));
float s00 = posIsInShadow(ivec2(base.x, base.y), lvpos, _depthTex);
float s10 = posIsInShadow(ivec2(base.x + 1, base.y), lvpos, _depthTex);
float s11 = posIsInShadow(ivec2(base.x + 1, base.y + 1), lvpos, _depthTex);
float s01 = posIsInShadow(ivec2(base.x, base.y + 1), lvpos, _depthTex);
return mix(mix(s00, s10, st.x), mix(s01, s11, st.x), st.y);
}
float readShadowMap(const in vec3 _vpos, float _linearDepth) {
mat4 mat;
int i = chooseCascade(_linearDepth, mat);
if (i >= numCascades) { return 0.0; }
vec3 lvpos = lightSpacePosition(_vpos, mat);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) { return 0.0; }
ivec2 size = textureSize(shadowMap, 0);
vec2 uv = cascadeCoordinates(i, size, lvpos);
return filterShadow(uv, lvpos, size, shadowMap);
}`);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/util/MixExternalColor.glsl.js
function i5(i6) {
  i6.include(e13), i6.code.add(o5`
    vec3 mixExternalColor(vec3 internalColor, vec3 textureColor, vec3 externalColor, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      vec3 internalMixed = internalColor * textureColor;
      vec3 allMixed = internalMixed * externalColor;

      if (mode == ${o5.int(n6.Multiply)}) {
        return allMixed;
      }
      if (mode == ${o5.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o5.int(n6.Replace)}) {
        return externalColor;
      }

      // tint (or something invalid)
      float vIn = rgb2v(internalMixed);
      vec3 hsvTint = rgb2hsv(externalColor);
      vec3 hsvOut = vec3(hsvTint.x, hsvTint.y, vIn * hsvTint.z);
      return hsv2rgb(hsvOut);
    }

    float mixExternalOpacity(float internalOpacity, float textureOpacity, float externalOpacity, int mode) {
      // workaround for artifacts in macOS using Intel Iris Pro
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/10475
      float internalMixed = internalOpacity * textureOpacity;
      float allMixed = internalMixed * externalOpacity;

      if (mode == ${o5.int(n6.Ignore)}) {
        return internalMixed;
      }
      if (mode == ${o5.int(n6.Replace)}) {
        return externalOpacity;
      }

      // multiply or tint (or something invalid)
      return allMixed;
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/core/shaderLibrary/output/Emissions.glsl.js
var d6;
!function(e23) {
  e23[e23.None = 0] = "None", e23[e23.Value = 1] = "Value", e23[e23.Texture = 2] = "Texture", e23[e23.COUNT = 3] = "COUNT";
}(d6 || (d6 = {}));
function c7(u7, f6) {
  if (!u(f6.output)) return;
  const { emissionSource: c8, hasEmissiveTextureTransform: x2, bindType: l7 } = f6, p4 = c8 === d6.Texture;
  p4 && (u7.include(u3, f6), u7.fragment.uniforms.add(l7 === a3.Pass ? new s4("texEmission", (e23) => e23.textureEmissive) : new s3("texEmission", (e23) => e23.textureEmissive)));
  const v3 = c8 === d6.Value || p4;
  v3 && u7.fragment.uniforms.add(l7 === a3.Pass ? new e6("emissionFactor", (e23) => e23.emissiveFactor) : new o6("emissionFactor", (e23) => e23.emissiveFactor)), u7.fragment.code.add(o5`
    vec4 getEmissions() {
      vec4 emissions = ${v3 ? "vec4(emissionFactor, 1.0)" : "vec4(0.0)"};
      ${r4(p4, `emissions *= textureLookup(texEmission, ${x2 ? "emissiveUV" : "vuv0"});
         emissions.w = emissions.rgb == vec3(0.0) ? 0.0: emissions.w;`)};
      return emissions;
    }
  `);
}

// node_modules/@arcgis/core/views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js
function d7(d8, f6) {
  d8.include(g2, f6), d8.include(c7, f6), d8.fragment.include(e13);
  const p4 = f6.output === n7.ObjectAndLayerIdColor, c8 = S2(f6.output), g4 = u(f6.output) && f6.oitPass === o12.ColorAlpha, h4 = u(f6.output) && f6.oitPass !== o12.ColorAlpha, m6 = f6.discardInvisibleFragments;
  let C2 = 0;
  (h4 || c8 || g4) && d8.outputs.add("fragColor", "vec4", C2++), c8 && d8.outputs.add("fragEmission", "vec4", C2++), g4 && d8.outputs.add("fragAlpha", "float", C2++), d8.fragment.code.add(o5`
    void outputColorHighlightOID(vec4 finalColor, const in vec3 vWorldPosition) {
      ${r4(p4, o5`finalColor.a = 1.0;`)}

      ${r4(m6, o5`if (finalColor.a < ${o5.float(o4)}){
              discard;
              return;
            }`)}

      finalColor = highlightSlice(finalColor, vWorldPosition);
      ${r4(g4, o5`fragColor = premultiplyAlpha(finalColor);
             fragAlpha = finalColor.a;`)}
      ${r4(h4, "fragColor = finalColor;")}
      ${r4(c8, "fragEmission = getEmissions();")}
      calculateOcclusionAndOutputHighlight();
      ${r4(p4, "outputObjectAndLayerIdColor();")}
    }
  `);
}

export {
  o13 as o,
  c2 as c,
  f2 as f,
  n8 as n,
  t9 as t,
  n13 as n2,
  n9 as n3,
  t5 as t2,
  o14 as o2,
  s6 as s,
  n10 as n4,
  e14 as e,
  o15 as o3,
  M,
  i3 as i,
  d5 as d,
  o16 as o4,
  e15 as e2,
  t7 as t3,
  h,
  u3 as u,
  t12 as t4,
  u4 as u2,
  h2,
  n14 as n5,
  m3 as m,
  t14 as t5,
  a8 as a,
  n15 as n6,
  h3,
  u6 as u3,
  p3 as p,
  m5 as m2,
  x,
  i5 as i2,
  d6 as d2,
  d7 as d3
};
//# sourceMappingURL=chunk-N6LRJJD6.js.map
