import {
  $
} from "./chunk-4WB72ND2.js";
import {
  B,
  m
} from "./chunk-LIUBAYCM.js";
import {
  l,
  u as u2
} from "./chunk-XKMN3LJN.js";
import {
  j as j2
} from "./chunk-2U5JYYSG.js";
import {
  r
} from "./chunk-MGMVRMXQ.js";
import {
  be,
  i
} from "./chunk-BWTCR2DR.js";
import {
  u
} from "./chunk-YVSEBNS4.js";
import {
  j2 as j
} from "./chunk-FG3XOAFD.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import {
  N,
  d
} from "./chunk-E2I7HYXQ.js";

// node_modules/@arcgis/core/smartMapping/statistics/support/utils.js
var $2 = null;
var g2 = /^(?<hh>([0-1][0-9])|([2][0-3])):(?<mm>[0-5][0-9])(:(?<ss>[0-5][0-9]))?([.](?<ms>\d+))?$/;
function j3(e, t, n) {
  return e.x < 0 ? e.x += t : e.x > n && (e.x -= t), e;
}
function x(e, t, n, r2) {
  const l2 = N(n) ? d(n) : null, a = l2 ? Math.round((l2.valid[1] - l2.valid[0]) / t.scale[0]) : null;
  return e.map((e2) => {
    const n2 = new j(e2.geometry);
    return j2(t, n2, n2), e2.geometry = l2 ? j3(n2, a ?? 0, r2[0]) : n2, e2;
  });
}
function w(e, n = 18, r2, o, i2) {
  const s2 = new Float64Array(o * i2);
  n = Math.round(u(n));
  let l2 = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY;
  const u3 = u2(r2);
  for (const { geometry: t, attributes: c } of e) {
    const { x: e2, y: r3 } = t, m2 = Math.max(0, e2 - n), p = Math.max(0, r3 - n), d2 = Math.min(i2, r3 + n), h = Math.min(o, e2 + n), y = +u3(c);
    for (let t2 = p; t2 < d2; t2++) for (let i3 = m2; i3 < h; i3++) {
      const u4 = t2 * o + i3, c2 = l(i3 - e2, t2 - r3, n) * y, m3 = s2[u4] += c2;
      l2 = Math.min(l2, m3), a = Math.max(a, m3);
    }
  }
  return { min: l2, max: a };
}
function I(e) {
  const t = g2.exec(e);
  if (!t) return null;
  const { hh: r2, mm: o, ss: i2, ms: s2 } = t.groups;
  return Number(r2) * r.hours + Number(o) * r.minutes + Number(i2) * r.seconds + Number(s2 || 0);
}
async function b(e, t, n = true) {
  if (!t) return [];
  const { field: o, field2: i2, field3: s2, fieldDelimiter: a, fieldInfos: u3, timeZone: f } = e, c = o && (u3 == null ? void 0 : u3.find((e2) => e2.name.toLowerCase() === o.toLowerCase())), y = !!c && be(c), g3 = !!c && $(c), j4 = e.valueExpression, x2 = e.normalizationType, w2 = e.normalizationField, b2 = e.normalizationTotal, F = [], N2 = e.viewInfoParams;
  let E = null, v = null;
  if (j4) {
    if (!$2) {
      const { arcadeUtils: e2 } = await i();
      $2 = e2;
    }
    $2.hasGeometryOperations(j4) && await $2.enableGeometryOperations(), E = $2.createFunction(j4), v = N2 ? $2.getViewInfo({ viewingMode: N2.viewingMode, scale: N2.scale, spatialReference: new g(N2.spatialReference) }) : null;
  }
  const U = e.fieldInfos, M = !(t[0] && "declaredClass" in t[0] && "esri.Graphic" === t[0].declaredClass) && U ? { fields: U } : null;
  return t.forEach((e2) => {
    const t2 = e2.attributes;
    let r2;
    if (j4) {
      const t3 = M ? { ...e2, layer: M } : e2, n2 = $2.createExecContext(t3, v, f);
      r2 = $2.executeFunction(E, n2);
    } else t2 && (r2 = t2[o], i2 ? (r2 = `${m(r2)}${a}${m(t2[i2])}`, s2 && (r2 = `${r2}${a}${m(t2[s2])}`)) : "string" == typeof r2 && n && (g3 ? r2 = r2 ? new Date(r2).getTime() : null : y && (r2 = r2 ? I(r2) : null)));
    if (x2 && "number" == typeof r2 && isFinite(r2)) {
      const e3 = t2 && parseFloat(t2[w2]);
      r2 = B(r2, x2, e3, b2);
    }
    F.push(r2);
  }), F;
}

export {
  x,
  w,
  I,
  b
};
//# sourceMappingURL=chunk-547Z5YIS.js.map
