import {
  s as s3,
  s2 as s4
} from "./chunk-5TUUVC6K.js";
import {
  a as a3
} from "./chunk-LTKYSPF4.js";
import {
  a as a2,
  d as d2
} from "./chunk-F3IC5LHL.js";
import {
  f as f2,
  x
} from "./chunk-X3DAAXDC.js";
import {
  pt,
  rt
} from "./chunk-OMMWWGIU.js";
import {
  d
} from "./chunk-PVHAAI32.js";
import {
  b as b2
} from "./chunk-F3NUC2RS.js";
import {
  K
} from "./chunk-NYLL2YZF.js";
import {
  f
} from "./chunk-WWNVF22O.js";
import {
  o
} from "./chunk-JOOGZSAP.js";
import {
  w
} from "./chunk-FG3XOAFD.js";
import {
  s3 as s2
} from "./chunk-E2I7HYXQ.js";
import {
  I
} from "./chunk-YFGQMO6E.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  h
} from "./chunk-GRW2QIBT.js";
import {
  n
} from "./chunk-R2PAF6JT.js";
import {
  s2 as s
} from "./chunk-PKLD5YJF.js";
import {
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/rest/query/executeForExtent.js
async function n2(n5, a5, e) {
  const i2 = f(n5), s5 = await x(i2, b2.from(a5), { ...e }), u2 = s5.data.extent;
  return !u2 || isNaN(u2.xmin) || isNaN(u2.ymin) || isNaN(u2.xmax) || isNaN(u2.ymax) ? { count: s5.data.count, extent: null } : { count: s5.data.count, extent: w.fromJSON(u2) };
}

// node_modules/@arcgis/core/rest/query/operations/pbfJSONFeatureSet.js
function o2(e, t) {
  return t;
}
function i(e, t, r2, s5) {
  switch (r2) {
    case 0:
      return u(e, t + s5, 0);
    case 1:
      return "lowerLeft" === e.originPosition ? u(e, t + s5, 1) : l(e, t + s5, 1);
  }
}
function n3(e, t, r2, s5) {
  return 2 === r2 ? u(e, t, 2) : i(e, t, r2, s5);
}
function a4(e, t, r2, s5) {
  return 2 === r2 ? 0 === t ? 0 : u(e, t, 3) : i(e, t, r2, s5);
}
function h2(e, t, r2, s5) {
  return 3 === r2 ? 0 === t ? 0 : u(e, t, 3) : n3(e, t, r2, s5);
}
function u({ translate: e, scale: t }, r2, s5) {
  return e[s5] + r2 * t[s5];
}
function l({ translate: e, scale: t }, r2, s5) {
  return e[s5] - r2 * t[s5];
}
var d3 = class {
  constructor(e) {
    this._options = e, this.geometryTypes = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"], this._previousCoordinate = [0, 0], this._transform = null, this._applyTransform = o2, this._lengths = [], this._currentLengthIndex = 0, this._toAddInCurrentPath = 0, this._vertexDimension = 0, this._mValueOffset = null, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, this._attributesConstructor = class {
    };
  }
  createFeatureResult() {
    return { fields: [], features: [] };
  }
  finishFeatureResult(e) {
    if (this._options.applyTransform && (e.transform = null), this._attributesConstructor = class {
    }, this._coordinateBuffer = null, this._lengths.length = 0, !e.hasZ) return;
    const r2 = o(e.geometryType, this._options.sourceSpatialReference, e.spatialReference);
    if (null != r2) for (const t of e.features) r2(t.geometry);
  }
  createSpatialReference() {
    return {};
  }
  addField(t, r2) {
    const s5 = t.fields;
    n(s5), s5.push(r2);
    const o3 = s5.map((e) => e.name);
    this._attributesConstructor = function() {
      for (const e of o3) this[e] = null;
    };
  }
  addFeature(e, t) {
    e.features.push(t);
  }
  prepareFeatures(e) {
    switch (this._transform = e.transform, this._options.applyTransform && e.transform && (this._applyTransform = this._deriveApplyTransform(e)), this._mValueOffset = null, this._vertexDimension = 2, e.hasZ && this._vertexDimension++, e.hasM && (this._mValueOffset = this._vertexDimension, this._vertexDimension++), e.geometryType) {
      case "esriGeometryPoint":
        this.addCoordinate = (e2, t, r2) => this.addCoordinatePoint(e2, t, r2), this.createGeometry = (e2) => this.createPointGeometry(e2);
        break;
      case "esriGeometryPolygon":
        this.addCoordinate = (e2, t, r2) => this._addCoordinatePolygon(e2, t, r2), this.createGeometry = (e2) => this._createPolygonGeometry(e2);
        break;
      case "esriGeometryPolyline":
        this.addCoordinate = (e2, t, r2) => this._addCoordinatePolyline(e2, t, r2), this.createGeometry = (e2) => this._createPolylineGeometry(e2);
        break;
      case "esriGeometryMultipoint":
        this.addCoordinate = (e2, t, r2) => this._addCoordinateMultipoint(e2, t, r2), this.createGeometry = (e2) => this._createMultipointGeometry(e2);
    }
  }
  createFeature() {
    return this._lengths.length = 0, this._currentLengthIndex = 0, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0, this._coordinateBuffer = null, this._coordinateBufferPtr = 0, { attributes: new this._attributesConstructor() };
  }
  allocateCoordinates() {
  }
  addLength(e, t, r2) {
    0 === this._lengths.length && (this._toAddInCurrentPath = t), this._lengths.push(t);
  }
  addQueryGeometry(e, t) {
    const { queryGeometry: o3, queryGeometryType: i2 } = t, n5 = pt(o3.clone(), o3, false, false, this._transform), a5 = rt(n5, i2, false, false);
    e.queryGeometryType = i2, e.queryGeometry = { ...a5 };
  }
  createPointGeometry(e) {
    const t = { x: 0, y: 0, spatialReference: e.spatialReference };
    return e.hasZ && (t.z = 0), e.hasM && (t.m = 0), t;
  }
  addCoordinatePoint(e, t, r2) {
    const s5 = this._transform;
    switch (t = this._applyTransform(s5, t, r2, 0), r2) {
      case 0:
        e.x = t;
        break;
      case 1:
        e.y = t;
        break;
      case 2:
        "z" in e ? e.z = t : e.m = t;
        break;
      case 3:
        e.m = t;
    }
  }
  _transformPathLikeValue(e, t) {
    let r2 = 0;
    t <= 1 && (r2 = this._previousCoordinate[t], this._previousCoordinate[t] += e);
    const s5 = this._transform;
    return null !== this._mValueOffset && 0 === e && t > 0 && !(t % this._mValueOffset) ? 0 : this._applyTransform(s5, e, t, r2);
  }
  _addCoordinatePolyline(e, t, r2) {
    this._dehydratedAddPointsCoordinate(e.paths, t, r2);
  }
  _addCoordinatePolygon(e, t, r2) {
    this._dehydratedAddPointsCoordinate(e.rings, t, r2);
  }
  _addCoordinateMultipoint(e, t, r2) {
    0 === r2 && e.points.push([]);
    const s5 = this._transformPathLikeValue(t, r2);
    e.points[e.points.length - 1].push(s5);
  }
  _createPolygonGeometry(e) {
    return { rings: [[]], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _createPolylineGeometry(e) {
    return { paths: [[]], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _createMultipointGeometry(e) {
    return { points: [], spatialReference: e.spatialReference, hasZ: !!e.hasZ, hasM: !!e.hasM };
  }
  _dehydratedAddPointsCoordinate(e, t, r2) {
    0 === r2 && 0 == this._toAddInCurrentPath-- && (e.push([]), this._toAddInCurrentPath = this._lengths[++this._currentLengthIndex] - 1, this._previousCoordinate[0] = 0, this._previousCoordinate[1] = 0);
    const s5 = this._transformPathLikeValue(t, r2), o3 = e[e.length - 1];
    0 === r2 && (this._coordinateBufferPtr = 0, this._coordinateBuffer = new Array(this._vertexDimension), o3.push(this._coordinateBuffer)), this._coordinateBuffer[this._coordinateBufferPtr++] = s5;
  }
  _deriveApplyTransform(e) {
    const { hasZ: t, hasM: r2 } = e;
    return t && r2 ? h2 : t ? n3 : r2 ? a4 : i;
  }
};

// node_modules/@arcgis/core/rest/query/executeQueryPBF.js
async function n4(o3, s5, n5) {
  const p = f(o3), i2 = { ...n5 }, u2 = b2.from(s5), m2 = !u2.quantizationParameters, { data: f3 } = await f2(p, u2, new d3({ sourceSpatialReference: u2.sourceSpatialReference, applyTransform: m2 }), i2);
  return f3;
}

// node_modules/@arcgis/core/layers/graphics/sources/support/QueryTask.js
var x2 = class extends b {
  constructor(e) {
    super(e), this.dynamicDataSource = null, this.fieldsIndex = null, this.gdbVersion = null, this.infoFor3D = null, this.pbfSupported = false, this.queryAttachmentsSupported = false, this.sourceSpatialReference = null, this.url = null;
  }
  get parsedUrl() {
    return I(this.url);
  }
  async execute(e, t) {
    const r2 = await this.executeJSON(e, t);
    return this.featureSetFromJSON(e, r2, t);
  }
  async executeJSON(e, t) {
    var _a;
    const r2 = this._normalizeQuery(e), o3 = null != ((_a = e.outStatistics) == null ? void 0 : _a[0]), s5 = has("featurelayer-pbf-statistics"), i2 = !o3 || s5;
    let u2;
    if (this.pbfSupported && i2) try {
      u2 = await n4(this.url, r2, t);
    } catch (a5) {
      if ("query:parsing-pbf" !== a5.name) throw a5;
      this.pbfSupported = false;
    }
    return this.pbfSupported && i2 || (u2 = await a3(this.url, r2, t)), this._normalizeFields(u2.fields), u2;
  }
  async featureSetFromJSON(e, t, r2) {
    if (!this._queryIs3DObjectFormat(e) || null == this.infoFor3D || !t.features) return d.fromJSON(t);
    const { meshFeatureSetFromJSON: s5 } = await h(import("./meshFeatureSet-WSDBVVJD.js"), r2);
    return s5(e, this.infoFor3D, t);
  }
  executeForCount(e, t) {
    return s3(this.url, this._normalizeQuery(e), t);
  }
  executeForExtent(e, t) {
    return n2(this.url, this._normalizeQuery(e), t);
  }
  executeForIds(e, t) {
    return s4(this.url, this._normalizeQuery(e), t);
  }
  async executeRelationshipQuery(e, t) {
    const [{ default: r2 }, { executeRelationshipQuery: s5 }] = await h(Promise.all([import("./RelationshipQuery-RJR4YGM2.js"), import("./executeRelationshipQuery-Y3XC24SB.js")]), t);
    return e = r2.from(e), (this.gdbVersion || this.dynamicDataSource) && ((e = e.clone()).gdbVersion = e.gdbVersion || this.gdbVersion, e.dynamicDataSource = e.dynamicDataSource || this.dynamicDataSource), s5(this.url, e, t);
  }
  async executeRelationshipQueryForCount(e, t) {
    const [{ default: r2 }, { executeRelationshipQueryForCount: s5 }] = await h(Promise.all([import("./RelationshipQuery-RJR4YGM2.js"), import("./executeRelationshipQuery-Y3XC24SB.js")]), t);
    return e = r2.from(e), (this.gdbVersion || this.dynamicDataSource) && ((e = e.clone()).gdbVersion = e.gdbVersion || this.gdbVersion, e.dynamicDataSource = e.dynamicDataSource || this.dynamicDataSource), s5(this.url, e, t);
  }
  async executeAttachmentQuery(e, t) {
    const { executeAttachmentQuery: r2, fetchAttachments: s5, processAttachmentQueryResult: i2 } = await h(import("./queryAttachments-AVYHLTCD.js"), t), u2 = f(this.url);
    return i2(u2, await (this.queryAttachmentsSupported ? r2(u2, e, t) : s5(u2, e, t)));
  }
  async executeBinsQuery(e, t) {
    const { executeBinsQuery: r2 } = await h(import("./executeBinsQuery-2WNTC6T3.js"), t);
    return r2(this.parsedUrl, e, t);
  }
  async executeTopFeaturesQuery(e, t) {
    const { executeTopFeaturesQuery: r2 } = await h(import("./executeTopFeaturesQuery-TLAJB6GD.js"), t);
    return r2(this.parsedUrl, e, this.sourceSpatialReference, t);
  }
  async executeForTopIds(e, t) {
    const { executeForTopIds: r2 } = await h(import("./executeForTopIds-5SAHX6QU.js"), t);
    return r2(this.parsedUrl, e, t);
  }
  async executeForTopExtents(e, t) {
    const { executeForTopExtents: r2 } = await h(import("./executeForTopExtents-OO4HDM6Y.js"), t);
    return r2(this.parsedUrl, e, t);
  }
  async executeForTopCount(e, t) {
    const { executeForTopCount: r2 } = await h(import("./executeForTopCount-AFLWQJMW.js"), t);
    return r2(this.parsedUrl, e, t);
  }
  _normalizeQuery(e) {
    let t = b2.from(e);
    t.sourceSpatialReference = t.sourceSpatialReference || this.sourceSpatialReference, (this.gdbVersion || this.dynamicDataSource) && (t = t === e ? t.clone() : t, t.gdbVersion = e.gdbVersion || this.gdbVersion, t.dynamicDataSource = e.dynamicDataSource ? K.from(e.dynamicDataSource) : this.dynamicDataSource);
    const { infoFor3D: o3 } = this;
    if (null != o3 && this._queryIs3DObjectFormat(e)) {
      t = t === e ? t.clone() : t, t.formatOf3DObjects = null;
      const s5 = a2(o3), i2 = d2(o3);
      for (const e2 of o3.queryFormats) {
        if (e2 === s5) {
          t.formatOf3DObjects = e2;
          break;
        }
        e2 !== i2 || t.formatOf3DObjects || (t.formatOf3DObjects = e2);
      }
      if (!t.formatOf3DObjects) throw new s("query:unsupported-3d-query-formats", "Could not find any supported 3D object query format. Only supported formats are 3D_glb and 3D_gltf");
      if (t.outSpatialReference && !s2(t.outSpatialReference, this.sourceSpatialReference)) throw new s("query:unsupported-out-spatial-reference", "3D object feature services do not support projection of geometries");
      if (null == t.outFields || !t.outFields.includes("*")) {
        t = t === e ? t.clone() : t, null == t.outFields && (t.outFields = []);
        const { originX: r2, originY: s6, originZ: i3, translationX: u2, translationY: a5, translationZ: n5, scaleX: c, scaleY: p, scaleZ: l2, rotationX: m2, rotationY: y, rotationZ: f3, rotationDeg: d4 } = o3.transformFieldRoles;
        t.outFields.push(r2, s6, i3, u2, a5, n5, c, p, l2, m2, y, f3, d4);
      }
    }
    return t;
  }
  _normalizeFields(e) {
    if (null != this.fieldsIndex && null != e) for (const t of e) {
      const e2 = this.fieldsIndex.get(t.name);
      e2 && Object.assign(t, e2.toJSON());
    }
  }
  _queryIs3DObjectFormat(e) {
    return null != this.infoFor3D && true === e.returnGeometry && "xyFootprint" !== e.multipatchOption && !e.outStatistics;
  }
};
r([m({ type: K })], x2.prototype, "dynamicDataSource", void 0), r([m()], x2.prototype, "fieldsIndex", void 0), r([m()], x2.prototype, "gdbVersion", void 0), r([m()], x2.prototype, "infoFor3D", void 0), r([m({ readOnly: true })], x2.prototype, "parsedUrl", null), r([m()], x2.prototype, "pbfSupported", void 0), r([m()], x2.prototype, "queryAttachmentsSupported", void 0), r([m()], x2.prototype, "sourceSpatialReference", void 0), r([m({ type: String })], x2.prototype, "url", void 0), x2 = r([a("esri.layers.graphics.sources.support.QueryTask")], x2);
var j = x2;

export {
  j
};
//# sourceMappingURL=chunk-CFLZHE4P.js.map
