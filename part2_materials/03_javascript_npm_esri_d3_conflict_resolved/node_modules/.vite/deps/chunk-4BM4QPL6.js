import {
  I,
  S as S2,
  V,
  m2 as m4,
  n as n4,
  t5 as t,
  t6 as t2,
  u as u4,
  v,
  x as x2,
  y as y4
} from "./chunk-5PECYTTZ.js";
import {
  b as b3
} from "./chunk-KDQTUT24.js";
import {
  a as a4
} from "./chunk-QLTGZ6EP.js";
import {
  M as M2,
  b as b2,
  n as n2,
  n3,
  p as p2,
  s as s5
} from "./chunk-2O2NCM6Y.js";
import {
  d2 as d4
} from "./chunk-OXCT6NNS.js";
import {
  W as W2,
  Z as Z2,
  ee,
  l2,
  rt,
  u as u3
} from "./chunk-5VEO4IUH.js";
import {
  j,
  x
} from "./chunk-YEDSTDY4.js";
import {
  at,
  ht,
  ot
} from "./chunk-OMMWWGIU.js";
import {
  s as s4
} from "./chunk-KI5F6KDS.js";
import {
  y as y3
} from "./chunk-YAGJS3MX.js";
import {
  N,
  O,
  y as y2
} from "./chunk-P2IB5HBH.js";
import {
  Z
} from "./chunk-RXJCBLN2.js";
import {
  i
} from "./chunk-KDUYQUT4.js";
import {
  M,
  S,
  W,
  X,
  a as a3
} from "./chunk-CGJUTDVJ.js";
import {
  L
} from "./chunk-6B4OMNPA.js";
import {
  s as s3
} from "./chunk-2IGXKE5P.js";
import {
  d as d2
} from "./chunk-W6D3ECTZ.js";
import {
  u as u2
} from "./chunk-YVSEBNS4.js";
import {
  m as m3,
  p,
  s as s2,
  y
} from "./chunk-3L2AYCZY.js";
import {
  a as a2,
  l,
  o
} from "./chunk-VUJERGGB.js";
import {
  m as m2
} from "./chunk-NTI2OCVI.js";
import {
  E,
  u
} from "./chunk-ZCHZRNUG.js";
import {
  d as d3
} from "./chunk-E2I7HYXQ.js";
import {
  b2 as b,
  m
} from "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import {
  d,
  s
} from "./chunk-GRW2QIBT.js";
import {
  n
} from "./chunk-R2PAF6JT.js";
import {
  F,
  has
} from "./chunk-XKQWTZMW.js";

// node_modules/@arcgis/core/views/2d/engine/webgl/shaderGraph/techniques/createGraphicSymbolMeshSchemas.js
async function l3(l4, m5, p3) {
  const u5 = [], h = { scaleInfo: n4(l4), scaleExpression: null };
  for (const e of m5) switch (e.type) {
    case "marker":
      if (e.animationParams) {
        u5.push(...u4(p3.instances.animatedMarker, e, x2, h));
        break;
      }
      u5.push(...m4(p3.instances.marker, e, x2, h));
      break;
    case "fill":
      null == e.spriteRasterizationParam ? u5.push(...S2(p3.instances.fill, e, h)) : u5.push(...V(p3.instances.complexFill, e, false, h));
      break;
    case "line":
      e.spriteRasterizationParam ? u5.push(...y4(p3.instances.texturedLine, e, false, h)) : u5.push(...v(p3.instances.line, e, false, h));
      break;
    case "text":
      u5.push(...I(p3.instances.text, e, x2, h));
  }
  return u5;
}

// node_modules/@arcgis/core/views/2d/layers/features/support/GraphicsReader.js
var c = class _c extends M2 {
  static from(t4, e, r2) {
    return new _c(t4, e, r2);
  }
  constructor(t4, e, r2) {
    super(r2), this._items = t4, this._tile = e, this._index = -1, this._cachedGeometry = null;
    const s6 = e.lod;
    s6.wrap && (this._wrappingInfo = { worldSizeX: s6.worldSize[0] });
  }
  get _current() {
    return this._items[this._index];
  }
  getItem() {
    return this._current;
  }
  getZOrder() {
    return this._current.zOrder;
  }
  getMeshWriters() {
    var _a;
    return ((_a = this._current.symbolResource) == null ? void 0 : _a.symbolInfo.meshWriters) ?? [];
  }
  hasField(t4) {
    return null != this._current.attributes[t4];
  }
  field(t4) {
    return this.readAttribute(t4);
  }
  get geometryType() {
    const t4 = p(this._current.geometry);
    return "esriGeometryPoint" === t4 ? "esriGeometryMultipoint" : t4;
  }
  getCursor() {
    return this.copy();
  }
  copy() {
    const t4 = new _c(this._items, this._tile, this.metadata);
    return this.copyInto(t4), t4;
  }
  copyInto(t4) {
    super.copyInto(t4), t4._cachedGeometry = this._cachedGeometry, t4._index = this._index;
  }
  get fields() {
    throw new Error("Fields reading not supported to graphics.");
  }
  get hasFeatures() {
    return !!this._items.length;
  }
  get hasNext() {
    return this._index + 1 < this._items.length;
  }
  get exceededTransferLimit() {
    throw new Error("InternalError: exceededTransferLimit not implemented for graphics.");
  }
  get hasZ() {
    return false;
  }
  get hasM() {
    return false;
  }
  getInTransform() {
    return this._tile.transform;
  }
  getSize() {
    return this._items.length;
  }
  getAttributeHash() {
    let t4 = "";
    for (const e in this._current.attributes) t4 += this._current.attributes[e];
    return t4;
  }
  getObjectId() {
    return this._items[this._index].objectId;
  }
  getDisplayId() {
    return this._current.displayId;
  }
  setDisplayId(t4) {
    throw new Error("InternalError: Setting displayId not supported for graphics.");
  }
  setIndex(t4) {
    this._index = t4;
  }
  getIndex() {
    return this._index;
  }
  next() {
    for (this._cachedGeometry = null; ++this._index < this._items.length && !this._getExists(); ) ;
    return this._index < this._items.length;
  }
  readGeometryArea() {
    throw new Error("InternalError: readGeometryArea not supported for graphics.");
  }
  _readGeometry() {
    if (!this._cachedGeometry) {
      let t4 = ot(this._current.projectedGeometry, this.hasZ, this.hasM);
      if ("esriGeometryPolyline" === this.geometryType && (t4 = ht(new s4(), t4, this.hasZ, this.hasM, this.geometryType, this._tile.transform.scale[0])), this._cachedGeometry = at(new s4(), t4, this.hasZ, this.hasM, this.geometryType, this._tile.transform), !this._cachedGeometry) return null;
      this._wrapGeometry(this._cachedGeometry);
    }
    return this._cachedGeometry;
  }
  _wrapGeometry(t4) {
    if (!this._wrappingInfo) return;
    const { worldSizeX: e } = this._wrappingInfo;
    if (t4.isPoint) return 1 === e ? (t4.coords.push(a3, 0), t4.coords.push(2 * -a3, 0), void t4.lengths.push(3)) : 2 === e ? (t4.coords.push(2 * a3, 0), t4.coords.push(4 * -a3, 0), void t4.lengths.push(3)) : void this._wrapVertex(t4.coords, 0, 2, e);
    if ("esriGeometryMultipoint" !== this.geometryType) ;
    else {
      if (1 === e) {
        const e2 = t4.coords.slice();
        e2[0] -= 512;
        const r2 = t4.coords.slice();
        r2[0] += 512, t4.coords.push(...e2, ...r2);
        const s6 = t4.lengths[0];
        return void t4.lengths.push(s6, s6);
      }
      this._wrapVertex(t4.coords, 0, 2, e);
    }
  }
  _wrapVertex(t4, e, r2, s6) {
    const i2 = e * r2, o2 = t4[i2];
    o2 < -a3 * (s6 - 2) ? t4[i2] = o2 + a3 * s6 : o2 > a3 * (s6 - 1) && (t4[i2] = o2 - a3 * s6);
  }
  _readX() {
    const t4 = this._readGeometry();
    return null != t4 ? t4.coords[0] : 0;
  }
  _readY() {
    const t4 = this._readGeometry();
    return null != t4 ? t4.coords[1] : 0;
  }
  _readServerCentroid() {
    switch (this.geometryType) {
      case "esriGeometryPolygon": {
        const t4 = l(this._current.projectedGeometry), r2 = new s4([], t4);
        return at(new s4(), r2, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
      case "esriGeometryPolyline": {
        const e = this._current.projectedGeometry, r2 = o(e.paths, this.hasZ), s6 = new s4([], r2);
        return at(new s4(), s6, this.hasZ, this.hasM, this.geometryType, this._tile.transform);
      }
    }
    return null;
  }
  _readAttribute(t4, e) {
    const r2 = this._current.attributes[t4];
    if (void 0 !== r2) return r2;
    const s6 = t4.toLowerCase();
    for (const i2 in this._current.attributes) if (i2.toLowerCase() === s6) return this._current.attributes[i2];
  }
  _readAttributes() {
    return this._current.attributes;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStoreItem.js
var a5 = class _a {
  static fromGraphic(t4, s6, e, i2) {
    return new _a(t4.geometry, s6, t4.attributes, t4.visible, t4.uid, t4.version, e, i2);
  }
  constructor(s6, e, i2, r2, o2, n5, a6, m5) {
    this.geometry = s6, this.symbol = e, this.attributes = i2, this.visible = r2, this.objectId = o2, this._version = n5, this.zOrder = a6, this.displayId = m5, this.bounds = u(), this.prevBounds = u(), this.size = [0, 0, 0, 0];
  }
  get linearCIM() {
    var _a2;
    return (_a2 = this.symbolResource) == null ? void 0 : _a2.symbolInfo.linearCIM;
  }
  get hasAnimations() {
    const { linearCIM: t4 } = this;
    return !!t4 && t4.some((t5) => "animationParams" in t5 && !!t5.animationParams);
  }
  update(s6, e, i2) {
    return (this._version !== s6.version || this.zOrder !== i2 || this.symbol !== e) && (this.prevBounds = this.bounds, this.bounds = u(), this.zOrder = i2, this.geometry = s6.geometry, this.attributes = s6.attributes, this.symbol = e, this.visible = s6.visible, this._version = s6.version, this.symbolResource = null, this.projectedGeometry = null, true);
  }
  async projectAndNormalize(t4) {
    let a6 = this.geometry;
    if (!a6 || !a6.spatialReference || "mesh" === a6.type) return;
    "extent" === a6.type && (a6 = l2(a6)), await x(a6.spatialReference, t4);
    const m5 = a4(a6);
    if (!m5) return;
    const h = j(m5, a6.spatialReference, t4);
    h && m2(h), this.projectedGeometry = m3(h) ? l2(h) : h;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicUpdateMessage.js
var t3 = class {
  constructor(t4, e, d5) {
    this.added = t4, this.updated = e, this.removed = d5;
  }
  hasAnyUpdate() {
    return !!(this.added.length || this.updated.length || this.removed.length);
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicStore.js
var _ = 1e-5;
function f(e, t4) {
  return t4.zOrder - e.zOrder;
}
var b4 = class {
  constructor(e, t4, s6, o2, i2) {
    this._items = /* @__PURE__ */ new Map(), this._boundsDirty = false, this._outSpatialReference = e, this._cimResourceManager = t4, this._hittestDrawHelper = new rt(t4), this._tileInfoView = s6, this._store = i2;
    const r2 = s6.getClosestInfoForScale(o2);
    this._resolution = this._tileInfoView.getTileResolution(r2.level);
  }
  destroy() {
    this._hittestDrawHelper.destroy();
  }
  items() {
    return this._items.values();
  }
  getItem(e) {
    return this._items.get(e);
  }
  async update(e, t4, s6) {
    const o2 = [], i2 = [], r2 = [], n5 = /* @__PURE__ */ new Set(), m5 = [];
    let a6 = 0;
    for (const l4 of e.items) {
      a6++;
      const e2 = l4.uid, r3 = this._items.get(e2), c2 = t4(l4);
      if (n5.add(e2), r3) {
        r3.update(l4, c2, a6) && (i2.push(r3), m5.push(this._updateItem(r3, s6)));
        continue;
      }
      const h = this._store.createDisplayIdForObjectId(e2), d5 = a5.fromGraphic(l4, c2, a6, h);
      m5.push(this._updateItem(d5, s6)), this._items.set(d5.objectId, d5), o2.push(d5);
    }
    for (const [l4, c2] of this._items.entries()) n5.has(l4) || (this._store.releaseDisplayIdForObjectId(l4), this._items.delete(l4), r2.push(c2));
    return await Promise.all(m5), this._index = null, new t3(o2, i2, r2);
  }
  updateLevel(e) {
    this._resolution !== e && (this._index = null, this._boundsDirty = true, this._resolution = e);
  }
  hitTest(e, t4, i2, n5, m5) {
    const a6 = has("esri-mobile"), u5 = a6 ? S : W, p3 = u5 + (a6 ? 0 : X);
    e = L(e, this._tileInfoView.spatialReference);
    const _2 = n5 * window.devicePixelRatio * p3, b5 = u();
    b5[0] = e - _2, b5[1] = t4 - _2, b5[2] = e + _2, b5[3] = t4 + _2;
    const y5 = n5 * window.devicePixelRatio * u5, I2 = u();
    I2[0] = e - y5, I2[1] = t4 - y5, I2[2] = e + y5, I2[3] = t4 + y5;
    const g = 0.5 * n5 * (p3 + u3), j2 = this._searchIndex(e - g, t4 - g, e + g, t4 + g);
    if (!j2 || 0 === j2.length) return [];
    const w = [], x3 = u(), S3 = u();
    for (const s6 of j2) {
      if (!s6.visible) continue;
      const { projectedGeometry: e2, symbolResource: t5 } = s6;
      this._getSymbolBounds(x3, t5, e2, S3, m5), S3[3] = S3[2] = S3[1] = S3[0] = 0, E(x3, b5) && w.push(s6);
    }
    if (0 === w.length) return [];
    const R = this._hittestDrawHelper, z = [];
    for (const s6 of w) {
      const { projectedGeometry: e2, symbolResource: t5 } = s6;
      if (!t5) continue;
      const { textInfo: o2, symbolInfo: i3 } = t5, r2 = i3.cimSymbol;
      R.hitTest(I2, r2.symbol, e2, o2, m5, n5) && z.push(s6);
    }
    return z.sort(f), z.map((e2) => e2.objectId);
  }
  queryItems(e) {
    return 0 === this._items.size ? [] : this._searchForItems(e);
  }
  clear() {
    this._items.clear(), this._index = null;
  }
  async _updateItem(e, t4) {
    await e.projectAndNormalize(this._outSpatialReference), await t4(e);
    const { size: s6 } = e;
    s6[0] = s6[1] = s6[2] = s6[3] = 0, this._getSymbolBounds(e.bounds, e.symbolResource, e.projectedGeometry, e.size, 0);
  }
  _searchIndex(e, s6, o2, i2) {
    return this._boundsDirty && (this._items.forEach((e2) => this._getSymbolBounds(e2.bounds, e2.symbolResource, e2.projectedGeometry, e2.size, 0)), this._boundsDirty = false), this._index || (this._index = i(9, (e2) => ({ minX: e2.bounds[0], minY: e2.bounds[1], maxX: e2.bounds[2], maxY: e2.bounds[3] })), this._index.load(Array.from(this._items.values()))), this._index.search({ minX: e, minY: s6, maxX: o2, maxY: i2 });
  }
  _searchForItems(e) {
    const t4 = this._tileInfoView.spatialReference, o2 = e.bounds, i2 = d3(t4);
    if (i2 && t4.isWrappable) {
      const [t5, r2] = i2.valid, n5 = Math.abs(o2[2] - r2) < _, m5 = Math.abs(o2[0] - t5) < _;
      if ((!n5 || !m5) && (n5 || m5)) {
        const i3 = e.resolution;
        let m6;
        m6 = u(n5 ? [t5, o2[1], t5 + i3 * u3, o2[3]] : [r2 - i3 * u3, o2[1], r2, o2[3]]);
        const a6 = this._searchIndex(o2[0], o2[1], o2[2], o2[3]), l4 = this._searchIndex(m6[0], m6[1], m6[2], m6[3]);
        return [.../* @__PURE__ */ new Set([...a6, ...l4])];
      }
    }
    return this._searchIndex(o2[0], o2[1], o2[2], o2[3]);
  }
  _getSymbolBounds(t4, o2, r2, n5, m5) {
    if (!o2 || !o2.symbolInfo.linearCIM || !r2) return null;
    if (t4 || (t4 = u()), a2(t4, r2), !n5 || 0 === n5[0] && 0 === n5[1] && 0 === n5[2] && 0 === n5[3]) {
      const { textInfo: t5, symbolInfo: s6 } = o2, i2 = s6.cimSymbol;
      n5 || (n5 = [0, 0, 0, 0]);
      const r3 = Z2.getSymbolInflateSize(n5, i2.symbol, this._cimResourceManager, m5, t5);
      n5[0] = u2(r3[0]), n5[1] = u2(r3[1]), n5[2] = u2(r3[2]), n5[3] = u2(r3[3]);
    }
    const l4 = this._resolution, c2 = Z2.safeSize(n5);
    return t4[0] -= c2 * l4, t4[1] -= c2 * l4, t4[2] += c2 * l4, t4[3] += c2 * l4, t4;
  }
};

// node_modules/@arcgis/core/views/2d/layers/graphics/GraphicsView2D.js
var A = class _A {
  static getOrCreate(e, t4, s6) {
    let r2 = t4.get(e.id);
    return r2 || (r2 = new _A(e, s6), t4.set(e.id, r2)), r2;
  }
  static fromItems(e, t4, s6) {
    const r2 = new _A(e, s6);
    for (const i2 of t4) r2.append(i2);
    return r2;
  }
  constructor(e, t4) {
    this.tile = e, this.metadata = t4, this.addedOrModified = [], this.removed = [], this.objectIdMap = null;
  }
  get reader() {
    return this._reader || (this._reader = c.from(this.addedOrModified, this.tile, this.metadata)), this._reader;
  }
  append(e) {
    this.addedOrModified.push(e), e.hasAnimations && (this.objectIdMap = this.objectIdMap || {}, this.objectIdMap[e.displayId] = e.objectId);
  }
};
var O2 = class extends s3(b) {
  constructor(e) {
    super(e), this._attached = false, this._tiles = /* @__PURE__ */ new Map(), this._controller = new AbortController(), this._hashToSymbolInfo = /* @__PURE__ */ new Map(), this._lastCleanup = performance.now(), this._cleanupRequired = true, this.lastUpdateId = -1, this.renderer = null, this._updateTracking = new d4({ debugName: "GraphicsView2D" }), this.updateRequested = false, this.defaultPointSymbolEnabled = true, this._commandQueue = new t2({ process: (e2) => {
      if ("update" === e2.type) return this._update();
      throw new Error("InternalError: Unsupported command");
    } }), this.graphicUpdateHandler = this.graphicUpdateHandler.bind(this);
  }
  destroy() {
    this.container.destroy(), this.view = null, this.renderer = null, this._set("graphics", null), this._controller.abort(), this._graphicStore.clear(), this._graphicStore.destroy(), this._attributeStore = null, this._hashToSymbolInfo.clear(), this._updateTracking.destroy(), this._commandQueue.destroy();
  }
  _initAttributeStore() {
    this._storage = new p2({ spatialReference: this.view.spatialReference, fields: new Z() }), this._attributeStore = new b2({ isLocal: true, update: (e2) => {
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateStart`, { message: e2 }), this.container.attributeView.requestUpdate(e2), this.container.requestRender(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView2D.AttributeStoreView.updateEnd`, { message: e2 });
    } });
    const e = t(null, []);
    this._attributeStore.update(e, this._storage, null), this.container.checkHighlight = () => this._attributeStore.hasHighlight;
  }
  initialize() {
    this._initAttributeStore(), this._metadata = n3.createGraphics(this.view.spatialReference), this._resourceProxy = new s5({ fetch: (e2) => Promise.all(e2.map((e3) => this.view.stage.textureManager.rasterizeItem(e3))), fetchDictionary: (e2) => {
      throw new Error("InternalError: Graphics do not support Dictionary requests");
    } }), this.addHandles([d2(() => this._effectiveRenderer, () => this._pushUpdate()), this.view.graphicsTileStore.on("update", this._onTileUpdate.bind(this)), this.container.on("attach", () => {
      var _a;
      this.addHandles([this.graphics.on("change", () => this._pushUpdate())]), (_a = this._graphicStore) == null ? void 0 : _a.destroy(), this._graphicStore = new b4(this.view.spatialReference, this._cimResourceManager, this.view.featuresTilingScheme, this.view.state.scale, this._attributeStore), this._attached = true, this.requestUpdate(), this._pushUpdate();
    })]), this._updateTracking.addUpdateTracking("CommandQueue", this._commandQueue.updateTracking);
    const e = this.view.graphicsTileStore.tiles;
    this._onTileUpdate({ added: e, removed: [] });
  }
  get _effectiveRenderer() {
    return "function" == typeof this.renderer ? this.renderer() : this.renderer;
  }
  get _cimResourceManager() {
    return this.view.stage.textureManager.resourceManager;
  }
  get updating() {
    const e = !this._attached || this._updateTracking.updating;
    return has("esri-2d-log-updating") && console.log(`Updating GraphicsView2D: ${e}
  -> attaching ${!this._attached}
  -> updateTracking ${this._updateTracking.updating}`), e;
  }
  hitTest(e) {
    if (!this.view || this.view.suspended) return [];
    const { resolution: t4, rotation: r2 } = this.view.state, i2 = this._graphicStore.hitTest(e.x, e.y, 2, t4, r2), o2 = new Set(i2), a6 = this.graphics.items.reduce((e2, t5) => (o2.has(t5.uid) && e2.set(t5.uid, t5), e2), /* @__PURE__ */ new Map());
    return i2.map((e2) => a6.get(e2)).filter(F);
  }
  requestUpdate() {
    this.updateRequested || (this.updateRequested = true, this.requestUpdateCallback()), this.notifyChange("updating");
  }
  processUpdate(e) {
    this.updateRequested && (this.updateRequested = false, this.update(e));
  }
  viewChange() {
    this.requestUpdate();
  }
  setHighlight(e) {
    var _a;
    const t4 = [];
    for (const { objectId: s6, highlightFlags: r2 } of e) {
      const e2 = (_a = this._graphicStore.getItem(s6)) == null ? void 0 : _a.displayId;
      t4.push({ objectId: s6, highlightFlags: r2, displayId: e2 });
    }
    this._attributeStore.setHighlight(t4, e), this._pushUpdate();
  }
  graphicUpdateHandler(e) {
    this._pushUpdate();
  }
  update(e) {
    this.updateRequested = false, this._attached && this._graphicStore.updateLevel(e.state.resolution);
  }
  pushUpdate() {
    this._pushUpdate();
  }
  _pushUpdate() {
    d(this._commandQueue.push({ type: "update" }));
  }
  async _update() {
    try {
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView._update start`);
      const e = await this._graphicStore.update(this.graphics, (e2) => this._getSymbolForGraphic(e2), (e2) => this._ensureSymbolResource(e2));
      for (const s6 of e.updated) this.container.restartAnimation(s6.objectId);
      if (!e.hasAnyUpdate()) return void this._attributeStore.sendUpdates();
      e.removed.length && (this._cleanupRequired = true), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView updateMessage`, e);
      const t4 = this._createTileMessages(e);
      await this._fetchResources(t4), this._write(t4);
      for (const s6 of e.added) this._setFilterState(s6);
      for (const s6 of e.updated) this._setFilterState(s6);
      has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate`, e), this._attributeStore.sendUpdates(), has("esri-2d-update-debug") && console.debug(`[Id: ${this.layerId}] GraphicsView sendUpdate.await`, e);
    } catch (e) {
    }
    this._cleanupSharedResources();
  }
  _createTileMessages(e) {
    const t4 = /* @__PURE__ */ new Map();
    for (const s6 of e.added) {
      const e2 = this.view.graphicsTileStore.getIntersectingTiles(s6.bounds);
      for (const r2 of e2) {
        A.getOrCreate(r2, t4, this._metadata).append(s6);
      }
    }
    for (const s6 of e.updated) {
      const e2 = this.view.graphicsTileStore.getIntersectingTiles(s6.prevBounds), r2 = this.view.graphicsTileStore.getIntersectingTiles(s6.bounds);
      for (const i2 of e2) {
        A.getOrCreate(i2, t4, this._metadata).removed.push(s6.displayId);
      }
      for (const i2 of r2) {
        A.getOrCreate(i2, t4, this._metadata).append(s6);
      }
    }
    for (const s6 of e.removed) {
      const e2 = this.view.graphicsTileStore.getIntersectingTiles(s6.bounds);
      for (const r2 of e2) {
        A.getOrCreate(r2, t4, this._metadata).removed.push(s6.displayId);
      }
    }
    return Array.from(t4.values());
  }
  async _fetchResources(e) {
    for (const { tile: t4, reader: s6 } of e) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t4.id}] GraphicsView fetchResources`, e);
      const r2 = s6.getCursor();
      for (; r2.next(); ) for (const e2 of r2.getMeshWriters()) e2.enqueueRequest(this._resourceProxy, r2, t4.createArcadeEvaluationOptions(this.view.timeZone));
    }
    await this._resourceProxy.fetchEnqueuedResources();
  }
  _write(e) {
    for (const t4 of e) {
      has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t4.tile.id}] GraphicsView write`, t4);
      const e2 = this._writeMeshes(t4);
      let s6 = this._tiles.get(t4.tile.key);
      s6 || (s6 = this._createFeatureTile(t4.tile.key)), has("esri-2d-update-debug") && console.debug(`Id[${this.layerId}] Tile[${t4.tile.id}] GraphicsView onTileData`, t4), this.container.onTileData(s6, { type: "update", modify: e2, remove: t4.removed, end: false, attributeEpoch: this._attributeStore.epoch, objectIdMap: t4.objectIdMap }), this.container.requestRender();
    }
  }
  _writeMeshes(e) {
    const t4 = new n2(e.tile.id), s6 = e.reader.getCursor();
    for (; s6.next(); ) {
      t4.entityStart(s6.getDisplayId(), s6.getZOrder());
      for (const r2 of s6.getMeshWriters()) r2.write(t4, this._resourceProxy, s6, e.tile.createArcadeEvaluationOptions(this.view.timeZone), e.tile.level);
      t4.entityEnd();
    }
    return { ...t4.serialize().message, tileId: e.tile.id };
  }
  _setFilterState(e) {
    const t4 = e.displayId, s6 = this._attributeStore.getHighlightFlags(e.objectId);
    this._attributeStore.setData(t4, 0, 0, s6 | (e.visible ? M : 0));
  }
  _getSymbolForGraphic(e) {
    return null != e.symbol ? e.symbol : null != this._effectiveRenderer ? this._effectiveRenderer.getSymbol(e) : this._getNullSymbol(e);
  }
  async _ensureSymbolResource(e) {
    if (!e.symbol) return;
    const t4 = await this._getSymbolInfo(e.symbol);
    if (!t4) return;
    const s6 = t4.linearCIM.filter((e2) => "text" === e2.type);
    if (s6.length > 0) {
      const r2 = await this._getTextResources(e, s6);
      e.symbolResource = { symbolInfo: t4, textInfo: r2 };
    } else e.symbolResource = { symbolInfo: t4 };
  }
  _getSymbolInfo(e) {
    const t4 = e.hash();
    return this._hashToSymbolInfo.has(t4) || this._hashToSymbolInfo.set(t4, this._createSymbolInfo(t4, e).catch((e2) => null)), this._hashToSymbolInfo.get(t4);
  }
  async _createSymbolInfo(e, t4) {
    const s6 = await this._convertToCIMSymbol(t4), r2 = await this._createLinearCIM(s6);
    return { hash: e, cimSymbol: s6, linearCIM: r2, meshWriters: await this._createMeshWriters(s6, r2) };
  }
  async _convertToCIMSymbol(e) {
    const t4 = W2(e);
    if ("web-style" === t4.type) {
      return (await t4.fetchCIMSymbol()).data;
    }
    return t4;
  }
  async _createLinearCIM(e) {
    return await Promise.all(ee.fetchResources(e.symbol, this._cimResourceManager, [])), this.view.stage.cimAnalyzer.analyzeSymbolReference(e, false);
  }
  async _createMeshWriters(e, t4) {
    s(this._controller.signal);
    const s6 = this.container.instanceStore, r2 = this.view.stage.meshWriterRegistry, i2 = await l3(e, t4, s6);
    return Promise.all(i2.map((e2) => r2.createMeshWriter(this._storage, this._resourceProxy, { tileInfo: this.view.featuresTilingScheme.tileInfo }, e2)));
  }
  _onTileUpdate(e) {
    if (e.added && e.added.length > 0) for (const t4 of e.added) this._updateTracking.addPromise(this._addTile(t4));
    if (e.removed && e.removed.length > 0) for (const t4 of e.removed) this._removeTile(t4.key);
  }
  _createFeatureTile(e) {
    const t4 = this.view.featuresTilingScheme.getTileBounds(u(), e), s6 = this.view.featuresTilingScheme.getTileResolution(e.level), r2 = new b3(e, s6, t4[0], t4[3]);
    return this._tiles.set(e, r2), this.container.addChild(r2), r2;
  }
  async _addTile(e) {
    if (!this._attached) return;
    const t4 = this._graphicStore.queryItems(e);
    if (!t4.length) return;
    const s6 = this._createFeatureTile(e.key), r2 = A.fromItems(e, t4, this._metadata);
    await this._fetchResources([r2]);
    const i2 = this._writeMeshes(r2);
    s6.onMessage({ type: "append", append: i2, clear: false, end: true, attributeEpoch: this._attributeStore.epoch, objectIdMap: r2.objectIdMap });
  }
  _removeTile(e) {
    if (!this._tiles.has(e)) return;
    const t4 = this._tiles.get(e);
    this.container.removeChild(t4), t4.destroy(), this._tiles.delete(e);
  }
  _getNullSymbol(e) {
    const t4 = e.geometry;
    return s2(t4) ? O : y(t4) || m3(t4) ? y2 : this.defaultPointSymbolEnabled ? N : null;
  }
  async _getTextResources(e, t4) {
    const s6 = new Array(), r2 = new Array();
    for (let i2 = 0; i2 < t4.length; i2++) {
      const o3 = t4[i2], { resource: a7, overrides: n6 } = o3.textRasterizationParam;
      if ((n6 == null ? void 0 : n6.length) > 0) {
        const t5 = y3.resolveSymbolOverrides({ type: "CIMSymbolReference", primitiveOverrides: n6, symbol: { type: "CIMPointSymbol", symbolLayers: [{ type: "CIMVectorMarker", enable: true, size: a7.symbol.height, anchorPointUnits: "Relative", frame: { xmin: -5, ymin: -5, xmax: 5, ymax: 5 }, markerGraphics: [{ type: "CIMMarkerGraphic", geometry: { x: 0, y: 0 }, symbol: a7.symbol, textString: a7.textString }], scaleSymbolsProportionally: true, respectFrame: true }] } }, e, this.view.spatialReference, null, p(e.projectedGeometry), null, null);
        t5.then((e2) => {
          const t6 = e2.symbolLayers[0], { textString: s7 } = t6.markerGraphics[0];
          r2.push({ type: "cim-rasterization-info", resource: { type: "text", textString: s7 || "", font: a7.font } }), o3.text = a7.textString = s7 || "";
        }), s6.push(t5);
      } else r2.push({ type: "cim-rasterization-info", resource: a7 });
    }
    s6.length > 0 && await Promise.all(s6);
    const o2 = r2.map((e2) => this.view.stage.textureManager.rasterizeItem(e2)), a6 = await Promise.all(o2);
    n(a6);
    const n5 = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < t4.length; i2++) {
      const e2 = t4[i2];
      n5.set(e2.textRasterizationParam.resource.symbol, { text: e2.text, glyphMosaicItems: a6[i2] });
    }
    return n5;
  }
  _cleanupSharedResources() {
    var _a;
    if (!this._cleanupRequired) return;
    const e = performance.now();
    if (e - this._lastCleanup < 5e3) return;
    this._cleanupRequired = false, this._lastCleanup = e;
    const t4 = /* @__PURE__ */ new Set();
    for (const r2 of this._graphicStore.items()) {
      const e2 = (_a = r2.symbolResource) == null ? void 0 : _a.symbolInfo.hash;
      t4.add(e2);
    }
    const s6 = new Set(this._hashToSymbolInfo.keys());
    for (const r2 of s6.values()) t4.has(r2) || this._hashToSymbolInfo.delete(r2);
  }
};
r([m()], O2.prototype, "_effectiveRenderer", null), r([m({ constructOnly: true })], O2.prototype, "layerId", void 0), r([m({ constructOnly: true })], O2.prototype, "requestUpdateCallback", void 0), r([m()], O2.prototype, "container", void 0), r([m({ constructOnly: true })], O2.prototype, "graphics", void 0), r([m()], O2.prototype, "renderer", void 0), r([m()], O2.prototype, "_updateTracking", void 0), r([m()], O2.prototype, "updating", null), r([m()], O2.prototype, "view", void 0), r([m()], O2.prototype, "updateRequested", void 0), r([m()], O2.prototype, "defaultPointSymbolEnabled", void 0), O2 = r([a("esri.views.2d.layers.graphics.GraphicsView2D")], O2);
var F2 = O2;

export {
  F2 as F
};
//# sourceMappingURL=chunk-4BM4QPL6.js.map
