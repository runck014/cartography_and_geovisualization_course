import {
  C,
  L as L2,
  M as M2,
  X as X2,
  e,
  f2 as f,
  m,
  p,
  p3 as p2,
  s as s2,
  s2 as s4
} from "./chunk-ZOKCILGM.js";
import {
  Rn
} from "./chunk-LC4AEFBR.js";
import "./chunk-KXKYI37N.js";
import "./chunk-ILNUTCMB.js";
import "./chunk-WXDWH77C.js";
import "./chunk-JKRG5WGH.js";
import "./chunk-QV2O4XK2.js";
import {
  D
} from "./chunk-CTOH6SLG.js";
import {
  N
} from "./chunk-2HV3NVV7.js";
import {
  Ae,
  E,
  H,
  Ie,
  K,
  L,
  M,
  O,
  P,
  R,
  U,
  X,
  a,
  ce,
  de,
  e as e2,
  he,
  ie,
  me,
  n as n2,
  r,
  r2,
  s,
  s2 as s3,
  u,
  v,
  w,
  x,
  z
} from "./chunk-6ZMDPECL.js";
import "./chunk-KSR45ZRP.js";
import "./chunk-Q4J5AN2X.js";
import "./chunk-V256VJ5J.js";
import "./chunk-OJRG2YGM.js";
import "./chunk-OMMWWGIU.js";
import "./chunk-JPQIRBN6.js";
import "./chunk-CH3XVKUV.js";
import "./chunk-KI5F6KDS.js";
import "./chunk-BN24XFSK.js";
import "./chunk-RXJCBLN2.js";
import "./chunk-EFVIMN4N.js";
import "./chunk-2EGO74J5.js";
import "./chunk-4SUK447J.js";
import "./chunk-2X7T37AY.js";
import "./chunk-F3NUC2RS.js";
import "./chunk-LE3YW4Y3.js";
import "./chunk-TA32QX7Z.js";
import "./chunk-NYLL2YZF.js";
import "./chunk-NYLBGE62.js";
import "./chunk-QCBTLG25.js";
import "./chunk-SUZN3TAH.js";
import "./chunk-K5RYAJV4.js";
import "./chunk-VEUN2EF3.js";
import "./chunk-MGMVRMXQ.js";
import "./chunk-BWTCR2DR.js";
import "./chunk-SMOTPOZ7.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import "./chunk-TSVUPARM.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-JVEZN6WF.js";
import "./chunk-E2RPCJOE.js";
import "./chunk-NHJGPXZH.js";
import "./chunk-JS7R723S.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-SEG3PRUR.js";
import "./chunk-B6VE32RA.js";
import "./chunk-2M53HYNY.js";
import "./chunk-6YWQXXBX.js";
import "./chunk-Q7TEBZSN.js";
import {
  n
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import {
  g
} from "./chunk-2WXAPZBK.js";
import "./chunk-E2I7HYXQ.js";
import "./chunk-P5H5PJSC.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import "./chunk-H77COA2S.js";
import "./chunk-7LJCT7EA.js";
import "./chunk-MV5XBD6C.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/arcade/arcadeAsyncRuntime.js
var V = 100;
async function _(e3, t) {
  const n3 = [];
  for (let r3 = 0; r3 < t.arguments.length; r3++) n3.push(await Q(e3, t.arguments[r3]));
  return n3;
}
async function z2(e3, t, n3) {
  if (true === t.preparsed) return n3(e3, null, t.arguments);
  return n3(e3, t, await _(e3, t));
}
var Y = class extends r2 {
  constructor(e3, t) {
    super(), this.definition = null, this.context = null, this.definition = e3, this.context = t;
  }
  createFunction(e3) {
    return (...t) => {
      const n3 = { spatialReference: this.context.spatialReference, console: this.context.console, lrucache: this.context.lrucache, timeZone: this.context.timeZone ?? null, exports: this.context.exports, libraryResolver: this.context.libraryResolver, interceptor: this.context.interceptor, localScope: {}, depthCounter: { depth: e3.depthCounter + 1 }, globalScope: this.context.globalScope };
      if (n3.depthCounter.depth > 64) throw new a(e3, r.MaximumCallDepth, null);
      return Le(this.definition, n3, t, null);
    };
  }
  call(e3, t) {
    return J(e3, t, (n3, r3, o) => {
      const a2 = { spatialReference: e3.spatialReference, services: e3.services, console: e3.console, libraryResolver: e3.libraryResolver, exports: e3.exports, lrucache: e3.lrucache, timeZone: e3.timeZone ?? null, interceptor: e3.interceptor, localScope: {}, abortSignal: e3.abortSignal, globalScope: e3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 } };
      if (a2.depthCounter.depth > 64) throw new a(e3, r.MaximumCallDepth, t);
      return Le(this.definition, a2, o, t);
    });
  }
  marshalledCall(e3, t, n3, r3) {
    return r3(e3, t, async (o, a2, i) => {
      const l = { spatialReference: e3.spatialReference, globalScope: n3.globalScope, depthCounter: { depth: e3.depthCounter.depth + 1 }, libraryResolver: e3.libraryResolver, exports: e3.exports, console: e3.console, abortSignal: e3.abortSignal, lrucache: e3.lrucache, timeZone: e3.timeZone ?? null, interceptor: e3.interceptor, localScope: {} };
      return i = i.map((t2) => !v(t2) || t2 instanceof s3 ? t2 : n2(t2, e3, r3)), n2(await Le(this.definition, l, i, t), n3, r3);
    });
  }
};
var H2 = class extends s {
  constructor(e3) {
    super(), this.source = e3;
  }
  async global(e3) {
    const t = this.executingContext.globalScope[e3.toLowerCase()];
    if (t.valueset || (t.value = await Q(this.executingContext, t.node), t.valueset = true), v(t.value) && !(t.value instanceof s3)) {
      const e4 = new s3();
      e4.fn = t.value, e4.parameterEvaluator = J, e4.context = this.executingContext, t.value = e4;
    }
    return t.value;
  }
  setGlobal(e3, t) {
    if (v(t)) throw new a(null, r.AssignModuleFunction, null);
    this.executingContext.globalScope[e3.toLowerCase()] = { value: t, valueset: true, node: null };
  }
  hasGlobal(e3) {
    return void 0 === this.executingContext.exports[e3] && (e3 = e3.toLowerCase()), void 0 !== this.executingContext.exports[e3];
  }
  async loadModule(e3) {
    let t = e3.spatialReference;
    null == t && (t = new g({ wkid: 102100 })), this.moduleScope = Ge({}, e3.customfunctions, e3.timeZone), this.executingContext = { spatialReference: t, services: e3.services, libraryResolver: new s2(e3.libraryResolver._moduleSingletons, this.source.syntax.loadedModules), exports: {}, abortSignal: void 0 === e3.abortSignal || null === e3.abortSignal ? { aborted: false } : e3.abortSignal, globalScope: this.moduleScope, console: e3.console ?? Ze, lrucache: e3.lrucache, timeZone: e3.timeZone ?? null, interceptor: e3.interceptor, localScope: null, depthCounter: { depth: 1 } }, await ge(this.executingContext, this.source.syntax);
  }
};
async function J(e3, t, n3) {
  if (true === t.preparsed) return n3(e3, null, t.arguments);
  return n3(e3, t, await _(e3, t));
}
async function Q(e3, t) {
  t.breakpoint && await t.breakpoint();
  try {
    switch (t.type) {
      case "UpdateExpression":
        return await pe(e3, t);
      case "AssignmentExpression":
        return await de2(e3, t);
      case "TemplateLiteral":
        return await Oe(e3, t);
      case "Identifier":
        return await Ne(e3, t);
      case "MemberExpression":
        return await Re(e3, t);
      case "Literal":
        return t.value;
      case "CallExpression":
        return await ke(e3, t);
      case "UnaryExpression":
        return await Ae2(e3, t);
      case "BinaryExpression":
        return await Ce(e3, t);
      case "LogicalExpression":
        return await je(e3, t);
      case "ArrayExpression":
        return await Me(e3, t);
      case "ObjectExpression":
        return await $(e3, t);
      default:
        throw new a(e3, r.Unrecognized, t);
    }
  } catch (n3) {
    throw u(e3, t, n3);
  }
}
async function X3(e3, t) {
  t.breakpoint && await t.breakpoint();
  try {
    switch (t.type) {
      case "ImportDeclaration":
        return await Se(e3, t);
      case "ExportNamedDeclaration":
        return await xe(e3, t);
      case "VariableDeclaration":
        return await Fe(e3, t, 0);
      case "BlockStatement":
        return await ge(e3, t);
      case "FunctionDeclaration":
        return await be(e3, t);
      case "ReturnStatement":
        return await ve(e3, t);
      case "IfStatement":
        return await me2(e3, t);
      case "ExpressionStatement":
        return await he2(e3, t);
      case "ForStatement":
        return await oe(e3, t);
      case "WhileStatement":
        return await ee(e3, t);
      case "ForInStatement":
        return await fe(e3, t);
      case "BreakStatement":
        return O;
      case "EmptyStatement":
        return M;
      case "ContinueStatement":
        return R;
      default:
        throw new a(e3, r.Unrecognized, t);
    }
  } catch (n3) {
    throw u(e3, t, n3);
  }
}
async function $(e3, t) {
  const n3 = [];
  for (let a2 = 0; a2 < t.properties.length; a2++) {
    const r4 = t.properties[a2], o2 = await Q(e3, r4.value), i = "Identifier" === r4.key.type ? r4.key.name : await Q(e3, r4.key);
    n3[a2] = { key: i, value: o2 };
  }
  const r3 = {}, o = /* @__PURE__ */ new Map();
  for (let a2 = 0; a2 < n3.length; a2++) {
    const s6 = n3[a2];
    if (v(s6.value)) throw new a(e3, r.NoFunctionInDictionary, t);
    if (false === P(s6.key)) throw new a(e3, r.KeyMustBeString, t);
    let c = s6.key.toString();
    const u2 = c.toLowerCase();
    o.has(u2) ? c = o.get(u2) : o.set(u2, c), s6.value === M ? r3[c] = null : r3[c] = s6.value;
  }
  const s5 = new N(r3);
  return s5.immutable = false, s5;
}
async function ee(e3, t) {
  const n3 = { testResult: true, lastAction: M };
  if (n3.testResult = await Q(e3, t.test), false === n3.testResult) return M;
  if (true !== n3.testResult) throw new a(e3, r.BooleanConditionRequired, t);
  for (; true === n3.testResult && (n3.lastAction = await X3(e3, t.body), n3.lastAction !== O) && !(n3.lastAction instanceof w); ) if (n3.testResult = await Q(e3, t.test), true !== n3.testResult && false !== n3.testResult) throw new a(e3, r.BooleanConditionRequired, t);
  return n3.lastAction instanceof w ? n3.lastAction : M;
}
async function te(e3, t, n3) {
  const r3 = await X3(e3, t.body);
  return n3.lastAction = r3, n3.lastAction === O || n3.lastAction instanceof w ? (n3.testResult = false, n3) : null !== t.update ? (await Q(e3, t.update), n3) : n3;
}
async function ne(e3, t, n3) {
  var _a;
  if (null !== t.test) {
    const r3 = await Q(e3, t.test);
    if (true === ((_a = e3.abortSignal) == null ? void 0 : _a.aborted)) throw new a(e3, r.Cancelled, t);
    if (n3.testResult = r3, false === n3.testResult) return n3;
    if (true !== n3.testResult) throw new a(e3, r.BooleanConditionRequired, t);
    return te(e3, t, n3);
  }
  return te(e3, t, n3);
}
function re(e3, t, n3, r3, o, a2) {
  try {
    ne(e3, t, n3).then(() => {
      try {
        true === n3.testResult ? ++a2 > V ? (a2 = 0, setTimeout(() => {
          re(e3, t, n3, r3, o, a2);
        }, 0)) : re(e3, t, n3, r3, o, a2) : n3.lastAction instanceof w ? r3(n3.lastAction) : r3(M);
      } catch (i) {
        o(i);
      }
    }, (e4) => {
      o(e4);
    });
  } catch (i) {
    o(i);
  }
}
async function oe(e3, t) {
  try {
    return null !== t.init && ("VariableDeclaration" === t.init.type ? await X3(e3, t.init) : await Q(e3, t.init)), await new Promise((n3, r3) => {
      re(e3, t, { testResult: true, lastAction: M }, (e4) => {
        n3(e4);
      }, (e4) => {
        r3(e4);
      }, 0);
    });
  } catch (n3) {
    throw n3;
  }
}
function ae(e3, t, n3, r3, o, a2, i, l, s5, c) {
  try {
    if (r3 <= a2) return void l(M);
    o.value = "k" === i ? n3[a2] : a2, X3(e3, t.body).then((u2) => {
      try {
        u2 instanceof w ? l(u2) : u2 === O ? l(M) : ++c > V ? (c = 0, setTimeout(() => {
          ae(e3, t, n3, r3, o, a2 + 1, i, l, s5, c);
        }, 0)) : ae(e3, t, n3, r3, o, a2 + 1, i, l, s5, c);
      } catch (f2) {
        s5(f2);
      }
    }, (e4) => {
      s5(e4);
    });
  } catch (u2) {
    s5(u2);
  }
}
function ie2(e3, t, n3, r3, o, a2, i, l, s5) {
  try {
    if (n3.length() <= o) return void i(M);
    r3.value = "k" === a2 ? n3.get(o) : o, X3(e3, t.body).then((c) => {
      c instanceof w ? i(c) : c === O ? i(M) : ++s5 > V ? (s5 = 0, setTimeout(() => {
        ie2(e3, t, n3, r3, o + 1, a2, i, l, s5);
      }, 0)) : ie2(e3, t, n3, r3, o + 1, a2, i, l, s5);
    }, (e4) => {
      l(e4);
    });
  } catch (c) {
    l(c);
  }
}
function le(e3, t, n3, r3, o, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n3.length) return void r3.resolve(M);
    ae(e3, t, n3, n3.length, o, 0, a2, (e4) => {
      r3.resolve(e4);
    }, (e4) => {
      r3.reject(e4);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function se(e3, t, n3, r3, o, a2) {
  try {
    if (void 0 === a2 && (a2 = "i"), 0 === n3.length()) return void r3.resolve(M);
    ie2(e3, t, n3, o, 0, a2, (e4) => {
      r3.resolve(e4);
    }, (e4) => {
      r3.reject(e4);
    }, 0);
  } catch (i) {
    r3.reject(i);
  }
}
function ce2(e3, t, n3, r3, o) {
  try {
    le(e3, t, n3.keys(), r3, o, "k");
  } catch (a2) {
    r3.reject(a2);
  }
}
function ue(e3, t, n3, r3, o, a2, i, l) {
  try {
    e3.next().then((s5) => {
      try {
        if (null === s5) a2(M);
        else {
          const u2 = D.createFromGraphicLikeObject(s5.geometry, s5.attributes, r3, t.timeZone);
          u2._underlyingGraphic = s5, o.value = u2;
          X3(t, n3.body).then((s6) => {
            try {
              s6 === O ? a2(M) : s6 instanceof w ? a2(s6) : ++l > V ? (l = 0, setTimeout(() => {
                ue(e3, t, n3, r3, o, a2, i, l);
              }, 0)) : ue(e3, t, n3, r3, o, a2, i, l);
            } catch (c) {
              i(c);
            }
          }, (e4) => {
            i(e4);
          });
        }
      } catch (u2) {
        i(u2);
      }
    }, (e4) => {
      i(e4);
    });
  } catch (s5) {
    i(s5);
  }
}
async function fe(t, n3) {
  return new Promise((r3, o) => {
    Q(t, n3.right).then((s5) => {
      try {
        let c;
        c = "VariableDeclaration" === n3.left.type ? X3(t, n3.left) : Promise.resolve(), c.then(() => {
          try {
            const c2 = e("VariableDeclaration" === n3.left.type ? n3.left.declarations[0].id : n3.left);
            let u2 = null;
            if (null != t.localScope && void 0 !== t.localScope[c2] && (u2 = t.localScope[c2]), null === u2 && void 0 !== t.globalScope[c2] && (u2 = t.globalScope[c2]), null === u2) return void o(new a(t, r.InvalidIdentifier, n3));
            E(s5) || P(s5) ? le(t, n3, s5, { reject: o, resolve: r3 }, u2) : X(s5) ? se(t, n3, s5, { reject: o, resolve: r3 }, u2) : s5 instanceof N || U(s5) ? ce2(t, n3, s5, { reject: o, resolve: r3 }, u2) : K(s5) ? ue(s5.iterator(t.abortSignal), t, n3, s5, u2, (e3) => {
              r3(e3);
            }, (e3) => {
              o(e3);
            }, 0) : le(t, n3, [], { reject: o, resolve: r3 }, u2);
          } catch (c2) {
            o(c2);
          }
        }, o);
      } catch (c) {
        o(c);
      }
    }, o);
  });
}
async function pe(t, n3) {
  const r3 = n3.argument;
  if ("CallExpression" === r3.type) throw new a(t, r.NeverReach, n3);
  if ("MemberExpression" === r3.type) {
    const e3 = await Q(t, r3.object);
    let o2, s6;
    if (true === r3.computed) o2 = await Q(t, r3.property);
    else {
      if ("Identifier" !== r3.property.type) throw new a(t, r.Unrecognized, n3);
      o2 = r3.property.name;
    }
    if (E(e3)) {
      if (!z(o2)) throw new a(t, r.ArrayAccessorMustBeNumber, n3);
      if (o2 < 0 && (o2 = e3.length + o2), o2 < 0 || o2 >= e3.length) throw new a(t, r.OutOfBounds, n3);
      s6 = he(e3[o2]), e3[o2] = "++" === n3.operator ? s6 + 1 : s6 - 1;
    } else if (e3 instanceof N) {
      if (false === P(o2)) throw new a(t, r.KeyAccessorMustBeString, n3);
      if (true !== e3.hasField(o2)) throw new a(t, r.FieldNotFound, n3, { key: o2 });
      s6 = he(e3.field(o2)), e3.setField(o2, "++" === n3.operator ? s6 + 1 : s6 - 1);
    } else if (e3 instanceof H2) {
      if (false === P(o2)) throw new a(t, r.ModuleAccessorMustBeString, n3);
      if (true !== e3.hasGlobal(o2)) throw new a(t, r.ModuleExportNotFound, n3);
      s6 = he(await e3.global(o2)), e3.setGlobal(o2, "++" === n3.operator ? s6 + 1 : s6 - 1);
    } else {
      if (!U(e3)) throw X(e3) ? new a(t, r.Immutable, n3) : new a(t, r.InvalidParameter, n3);
      if (false === P(o2)) throw new a(t, r.KeyAccessorMustBeString, n3);
      if (true !== e3.hasField(o2)) throw new a(t, r.FieldNotFound, n3, { key: o2 });
      s6 = he(e3.field(o2)), e3.setField(o2, "++" === n3.operator ? s6 + 1 : s6 - 1);
    }
    return false === n3.prefix ? s6 : "++" === n3.operator ? s6 + 1 : s6 - 1;
  }
  const o = e(r3);
  let s5;
  if (null != t.localScope && void 0 !== t.localScope[o]) return s5 = he(t.localScope[o].value), t.localScope[o] = { value: "++" === n3.operator ? s5 + 1 : s5 - 1, valueset: true, node: n3 }, false === n3.prefix ? s5 : "++" === n3.operator ? s5 + 1 : s5 - 1;
  if (void 0 !== t.globalScope[o]) return s5 = he(t.globalScope[o].value), t.globalScope[o] = { value: "++" === n3.operator ? s5 + 1 : s5 - 1, valueset: true, node: n3 }, false === n3.prefix ? s5 : "++" === n3.operator ? s5 + 1 : s5 - 1;
  throw new a(t, r.InvalidIdentifier, n3);
}
function we(e3, t, n3, r3, o) {
  switch (t) {
    case "=":
      return e3 === M ? null : e3;
    case "/=":
      return he(n3) / he(e3);
    case "*=":
      return he(n3) * he(e3);
    case "-=":
      return he(n3) - he(e3);
    case "+=":
      return P(n3) || P(e3) ? de(n3) + de(e3) : he(n3) + he(e3);
    case "%=":
      return he(n3) % he(e3);
    default:
      throw new a(o, r.UnsupportedOperator, r3);
  }
}
async function de2(t, n3) {
  const r3 = n3.left;
  if ("MemberExpression" === r3.type) {
    const e3 = await Q(t, r3.object);
    let o2;
    if (true === r3.computed) o2 = await Q(t, r3.property);
    else {
      if ("Identifier" !== r3.property.type) throw new a(t, r.InvalidIdentifier, n3);
      o2 = r3.property.name;
    }
    const s5 = await Q(t, n3.right);
    if (E(e3)) {
      if (!z(o2)) throw new a(t, r.ArrayAccessorMustBeNumber, n3);
      if (o2 < 0 && (o2 = e3.length + o2), o2 < 0 || o2 > e3.length) throw new a(t, r.OutOfBounds, n3);
      if (o2 === e3.length) {
        if ("=" !== n3.operator) throw new a(t, r.OutOfBounds, n3);
        e3[o2] = we(s5, n3.operator, e3[o2], n3, t);
      } else e3[o2] = we(s5, n3.operator, e3[o2], n3, t);
    } else if (e3 instanceof N) {
      if (false === P(o2)) throw new a(t, r.KeyAccessorMustBeString, n3);
      if (true === e3.hasField(o2)) e3.setField(o2, we(s5, n3.operator, e3.field(o2), n3, t));
      else {
        if ("=" !== n3.operator) throw new a(t, r.FieldNotFound, n3, { key: o2 });
        e3.setField(o2, we(s5, n3.operator, null, n3, t));
      }
    } else if (e3 instanceof H2) {
      if (false === P(o2)) throw new a(t, r.KeyAccessorMustBeString, n3);
      if (true !== e3.hasGlobal(o2)) throw new a(t, r.ModuleExportNotFound, n3);
      e3.setGlobal(o2, we(s5, n3.operator, await e3.global(o2), n3, t));
    } else {
      if (!U(e3)) throw X(e3) ? new a(t, r.Immutable, n3) : new a(t, r.InvalidParameter, n3);
      if (false === P(o2)) throw new a(t, r.KeyAccessorMustBeString, n3);
      if (true === e3.hasField(o2)) e3.setField(o2, we(s5, n3.operator, e3.field(o2), n3, t));
      else {
        if ("=" !== n3.operator) throw new a(t, r.FieldNotFound, n3, { key: o2 });
        e3.setField(o2, we(s5, n3.operator, null, n3, t));
      }
    }
    return M;
  }
  const o = e(r3);
  if (null != t.localScope && void 0 !== t.localScope[o]) {
    const e3 = await Q(t, n3.right);
    return t.localScope[o] = { value: we(e3, n3.operator, t.localScope[o].value, n3, t), valueset: true, node: n3.right }, M;
  }
  if (void 0 !== t.globalScope[o]) {
    const e3 = await Q(t, n3.right);
    return t.globalScope[o] = { value: we(e3, n3.operator, t.globalScope[o].value, n3, t), valueset: true, node: n3.right }, M;
  }
  throw new a(t, r.InvalidIdentifier, n3);
}
async function he2(e3, t) {
  const n3 = await Q(e3, t.expression);
  return n3 === M ? M : new x(n3);
}
async function me2(e3, t) {
  const n3 = await Q(e3, t.test);
  if (true === n3) return X3(e3, t.consequent);
  if (false === n3) return null !== t.alternate ? X3(e3, t.alternate) : M;
  throw new a(e3, r.BooleanConditionRequired, t);
}
async function ge(e3, t) {
  return ye(e3, t, 0);
}
async function ye(e3, t, n3) {
  if (n3 >= t.body.length) return M;
  const r3 = await X3(e3, t.body[n3]);
  return r3 instanceof w || r3 === O || r3 === R || n3 === t.body.length - 1 ? r3 : ye(e3, t, n3 + 1);
}
async function ve(e3, t) {
  if (null === t.argument) return new w(M);
  const n3 = await Q(e3, t.argument);
  return new w(n3);
}
async function be(t, n3) {
  const r3 = e(n3.id);
  return t.globalScope[r3] = { valueset: true, node: null, value: new Y(n3, t) }, M;
}
async function Se(t, n3) {
  var _a, _b;
  const r3 = e(n3.specifiers[0].local), o = t.libraryResolver.loadLibrary(r3);
  let a2;
  return ((_a = t.libraryResolver._moduleSingletons) == null ? void 0 : _a.has(o.uri)) ? a2 = t.libraryResolver._moduleSingletons.get(o.uri) : (a2 = new H2(o), await a2.loadModule(t), (_b = t.libraryResolver._moduleSingletons) == null ? void 0 : _b.set(o.uri, a2)), t.globalScope[r3] = { value: a2, valueset: true, node: n3 }, M;
}
async function xe(t, n3) {
  if (await X3(t, n3.declaration), "FunctionDeclaration" === n3.declaration.type) t.exports[e(n3.declaration.id)] = "function";
  else if ("VariableDeclaration" === n3.declaration.type) for (const r3 of n3.declaration.declarations) t.exports[e(r3.id)] = "variable";
  return M;
}
async function Fe(e3, t, n3) {
  return n3 >= t.declarations.length ? M : (await Ie2(e3, t.declarations[n3]), n3 === t.declarations.length - 1 || await Fe(e3, t, n3 + 1), M);
}
async function Ie2(t, n3) {
  let r3 = null;
  if (r3 = null === n3.init ? null : await Q(t, n3.init), null !== t.localScope) {
    if (r3 === M && (r3 = null), "Identifier" !== n3.id.type) throw new a(t, r.InvalidIdentifier, n3);
    const o2 = e(n3.id);
    return void (null != t.localScope && (t.localScope[o2] = { value: r3, valueset: true, node: n3.init }));
  }
  if ("Identifier" !== n3.id.type) throw new a(t, r.InvalidIdentifier, n3);
  const o = e(n3.id);
  r3 === M && (r3 = null), t.globalScope[o] = { value: r3, valueset: true, node: n3.init };
}
async function Re(e3, t) {
  const n3 = await Q(e3, t.object);
  if (null === n3) throw new a(e3, r.MemberOfNull, t);
  if (false === t.computed) {
    if ("Identifier" === t.property.type) {
      if (n3 instanceof N || U(n3)) return n3.field(t.property.name);
      if (n3 instanceof n) return p(n3, t.property.name, e3, t);
      if (n3 instanceof H2) {
        if (!n3.hasGlobal(t.property.name)) throw new a(e3, r.InvalidIdentifier, t);
        return n3.global(t.property.name);
      }
      throw new a(e3, r.InvalidMemberAccessKey, t);
    }
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  let r3 = await Q(e3, t.property);
  if (n3 instanceof N || U(n3)) {
    if (P(r3)) return n3.field(r3);
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  if (n3 instanceof H2) {
    if (P(r3)) return n3.global(r3);
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  if (n3 instanceof n) {
    if (P(r3)) return p(n3, r3, e3, t);
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  if (E(n3)) {
    if (z(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n3.length + r3), r3 >= n3.length || r3 < 0) throw new a(e3, r.OutOfBounds, t);
      return n3[r3];
    }
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  if (X(n3)) {
    if (z(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n3.length() + r3), r3 >= n3.length() || r3 < 0) throw new a(e3, r.OutOfBounds, t);
      return n3.get(r3);
    }
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  if (P(n3)) {
    if (z(r3) && isFinite(r3) && Math.floor(r3) === r3) {
      if (r3 < 0 && (r3 = n3.length + r3), r3 >= n3.length || r3 < 0) throw new a(e3, r.OutOfBounds, t);
      return n3[r3];
    }
    throw new a(e3, r.InvalidMemberAccessKey, t);
  }
  throw new a(e3, r.InvalidMemberAccessKey, t);
}
async function Ae2(e3, t) {
  const n3 = await Q(e3, t.argument);
  if (L(n3)) {
    if ("!" === t.operator) return !n3;
    if ("-" === t.operator) return -1 * he(n3);
    if ("+" === t.operator) return 1 * he(n3);
    if ("~" === t.operator) return ~he(n3);
    throw new a(e3, r.UnsupportedUnaryOperator, t);
  }
  if ("-" === t.operator) return -1 * he(n3);
  if ("+" === t.operator) return 1 * he(n3);
  if ("~" === t.operator) return ~he(n3);
  throw new a(e3, r.UnsupportedUnaryOperator, t);
}
async function Me(e3, t) {
  const n3 = [];
  for (let r3 = 0; r3 < t.elements.length; r3++) n3.push(await Q(e3, t.elements[r3]));
  for (let r3 = 0; r3 < n3.length; r3++) {
    if (v(n3[r3])) throw new a(e3, r.NoFunctionInArray, t);
    n3[r3] === M && (n3[r3] = null);
  }
  return n3;
}
async function Ce(e3, t) {
  const n3 = await Q(e3, t.left), r3 = await Q(e3, t.right);
  switch (t.operator) {
    case "|":
    case "<<":
    case ">>":
    case ">>>":
    case "^":
    case "&":
      return Ie(he(n3), he(r3), t.operator);
    case "==":
      return me(n3, r3);
    case "!=":
      return !me(n3, r3);
    case "<":
    case ">":
    case "<=":
    case ">=":
      return ce(n3, r3, t.operator);
    case "+":
      return P(n3) || P(r3) ? de(n3) + de(r3) : he(n3) + he(r3);
    case "-":
      return he(n3) - he(r3);
    case "*":
      return he(n3) * he(r3);
    case "/":
      return he(n3) / he(r3);
    case "%":
      return he(n3) % he(r3);
    default:
      throw new a(e3, r.UnsupportedOperator, t);
  }
}
async function je(e3, t) {
  const n3 = await Q(e3, t.left);
  if (!L(n3)) throw new a(e3, r.LogicalExpressionOnlyBoolean, t);
  switch (t.operator) {
    case "||": {
      if (true === n3) return n3;
      const r3 = await Q(e3, t.right);
      if (L(r3)) return r3;
      throw new a(e3, r.LogicExpressionOrAnd, t);
    }
    case "&&": {
      if (false === n3) return n3;
      const r3 = await Q(e3, t.right);
      if (L(r3)) return r3;
      throw new a(e3, r.LogicExpressionOrAnd, t);
    }
    default:
      throw new a(e3, r.LogicExpressionOrAnd, t);
  }
}
async function Ne(t, n3) {
  const r3 = e(n3);
  if (null != t.localScope && void 0 !== t.localScope[r3]) {
    const e3 = t.localScope[r3];
    if (true === e3.valueset) return e3.value;
    if (null !== e3.d) return e3.d;
    e3.d = Q(t, e3.node);
    const n4 = await e3.d;
    return e3.value = n4, e3.valueset = true, n4;
  }
  if (void 0 !== t.globalScope[r3]) {
    const e3 = t.globalScope[r3];
    if (true === e3.valueset) return e3.value;
    if (null !== e3.d) return e3.d;
    e3.d = Q(t, e3.node);
    const n4 = await e3.d;
    return e3.value = n4, e3.valueset = true, n4;
  }
  throw new a(t, r.InvalidIdentifier, n3);
}
async function ke(t, n3) {
  if ("MemberExpression" === n3.callee.type) {
    const e3 = await Q(t, n3.callee.object);
    if (!(e3 instanceof H2)) throw new a(t, r.FunctionNotFound, n3);
    const r4 = false === n3.callee.computed ? n3.callee.property.name : await Q(t, n3.callee.property);
    if (!e3.hasGlobal(r4)) throw new a(t, r.FunctionNotFound, n3);
    const o = await e3.global(r4);
    if (!v(o)) throw new a(t, r.CallNonFunction, n3);
    return o.call(t, n3);
  }
  if ("Identifier" !== n3.callee.type) throw new a(t, r.FunctionNotFound, n3);
  const r3 = e(n3.callee);
  if (null != t.localScope && void 0 !== t.localScope[r3]) {
    const e3 = t.localScope[r3];
    if (v(e3.value)) return e3.value.call(t, n3);
    throw new a(t, r.CallNonFunction, n3);
  }
  if (void 0 !== t.globalScope[r3]) {
    const e3 = t.globalScope[r3];
    if (v(e3.value)) return e3.value.call(t, n3);
    throw new a(t, r.CallNonFunction, n3);
  }
  throw new a(t, r.FunctionNotFound, n3);
}
async function Oe(e3, t) {
  let n3 = "", r3 = 0;
  for (const o of t.quasis) if (n3 += o.value ? o.value.cooked : "", false === o.tail) {
    if (t.expressions[r3]) {
      const o2 = await Q(e3, t.expressions[r3]);
      if (v(o2)) throw new a(e3, r.NoFunctionInTemplateLiteral, t);
      n3 += de(o2);
    }
    r3++;
  }
  return n3;
}
var Ee = {};
async function Be(e3, t, n3, r3) {
  const o = await Q(e3, t.arguments[n3]);
  if (me(o, r3)) return Q(e3, t.arguments[n3 + 1]);
  const a2 = t.arguments.length - n3;
  return 1 === a2 ? Q(e3, t.arguments[n3]) : 2 === a2 ? null : 3 === a2 ? Q(e3, t.arguments[n3 + 2]) : Be(e3, t, n3 + 2, r3);
}
async function Ke(e3, t, n3, r3) {
  if (true === r3) return Q(e3, t.arguments[n3 + 1]);
  if (3 === t.arguments.length - n3) return Q(e3, t.arguments[n3 + 2]);
  const o = await Q(e3, t.arguments[n3 + 2]);
  if (false === L(o)) throw new a(e3, r.ModuleExportNotFound, t.arguments[n3 + 2]);
  return Ke(e3, t, n3 + 2, o);
}
async function Le(t, n3, r3, o) {
  const a2 = t.body;
  if (r3.length !== t.params.length) throw new a(n3, r.WrongNumberOfParameters, null);
  for (let i = 0; i < r3.length; i++) {
    const o2 = t.params[i];
    "Identifier" === o2.type && null != n3.localScope && (n3.localScope[e(o2)] = { d: null, value: r3[i], valueset: true, node: null });
  }
  const s5 = await X3(n3, a2);
  if (s5 instanceof w) return s5.value;
  if (s5 === O) throw new a(n3, r.UnexpectedToken, o);
  if (s5 === R) throw new a(n3, r.UnexpectedToken, o);
  return s5 instanceof x ? s5.value : s5;
}
C(Ee, z2), X2(Ee, z2), M2(Ee, z2), L2(Ee, z2), f(Ee, z2), Rn({ functions: Ee, compiled: false, signatures: null, evaluateIdentifier: null, mode: "async", standardFunction: z2, standardFunctionAsync: J }), Ee.iif = async function(e3, t) {
  ie(null === t.arguments ? [] : t.arguments, 3, 3, e3, t);
  const n3 = await Q(e3, t.arguments[0]);
  if (false === L(n3)) throw new a(e3, r.BooleanConditionRequired, t);
  return Q(e3, n3 ? t.arguments[1] : t.arguments[2]);
}, Ee.defaultvalue = async function(e3, t) {
  ie(null === t.arguments ? [] : t.arguments, 2, 3, e3, t);
  const n3 = await Q(e3, t.arguments[0]);
  if (3 === t.arguments.length) {
    const o = await Q(e3, t.arguments[1]), a2 = m(n3, o);
    return null != a2 && "" !== a2 ? a2 : Q(e3, t.arguments[2]);
  }
  return null == n3 || "" === n3 ? Q(e3, t.arguments[1]) : n3;
}, Ee.decode = async function(e3, t) {
  if (t.arguments.length < 2) throw new a(e3, r.WrongNumberOfParameters, t);
  if (2 === t.arguments.length) return Q(e3, t.arguments[1]);
  if ((t.arguments.length - 1) % 2 == 0) throw new a(e3, r.WrongNumberOfParameters, t);
  return Be(e3, t, 1, await Q(e3, t.arguments[0]));
}, Ee.when = async function(e3, t) {
  if (t.arguments.length < 3) throw new a(e3, r.WrongNumberOfParameters, t);
  if (t.arguments.length % 2 == 0) throw new a(e3, r.WrongNumberOfParameters, t);
  const n3 = await Q(e3, t.arguments[0]);
  if (false === L(n3)) throw new a(e3, r.BooleanConditionRequired, t.arguments[0]);
  return Ke(e3, t, 0, n3);
};
var Ue = { fixSpatialReference: Ae, parseArguments: _, standardFunction: z2, standardFunctionAsync: J, evaluateIdentifier: Ne };
for (const We in Ee) Ee[We] = { value: new e2(Ee[We]), valueset: true, node: null };
var De = function() {
};
function Ge(e3, t, n3) {
  const r3 = new De();
  null == e3 && (e3 = {}), null == t && (t = {});
  const o = new N({ newline: "\n", tab: "	", singlequote: "'", doublequote: '"', forwardslash: "/", backwardslash: "\\" });
  o.immutable = false, r3.textformatting = { value: o, valueset: true, node: null };
  for (const a2 in t) r3[a2] = { value: new e2(t[a2]), native: true, valueset: true, node: null };
  for (const a2 in e3) r3[a2] = { value: H(e3[a2]) ? D.createFromGraphic(e3[a2], n3) : e3[a2], valueset: true, node: null };
  return r3;
}
function Ze(e3) {
  console.log(e3);
}
De.prototype = Ee, De.prototype.infinity = { value: Number.POSITIVE_INFINITY, valueset: true, node: null }, De.prototype.pi = { value: Math.PI, valueset: true, node: null };
var Pe = Ue;
function qe(e3) {
  const t = { mode: "async", compiled: false, functions: {}, signatures: [], standardFunction: z2, standardFunctionAsync: J, evaluateIdentifier: Ne };
  for (let n3 = 0; n3 < e3.length; n3++) e3[n3].registerFunctions(t);
  for (const n3 in t.functions) Ee[n3] = { value: new e2(t.functions[n3]), valueset: true, node: null }, De.prototype[n3] = Ee[n3];
  for (let n3 = 0; n3 < t.signatures.length; n3++) s4(t.signatures[n3], "async");
}
async function Te(e3, t) {
  let r3 = t.spatialReference;
  null == r3 && (r3 = new g({ wkid: 102100 }));
  let o = null;
  e3.usesModules && (o = new s2(/* @__PURE__ */ new Map(), e3.loadedModules));
  const a2 = Ge(t.vars, t.customfunctions, t.timeZone), s5 = { spatialReference: r3, services: t.services, exports: {}, libraryResolver: o, abortSignal: void 0 === t.abortSignal || null === t.abortSignal ? { aborted: false } : t.abortSignal, globalScope: a2, console: t.console ?? Ze, timeZone: t.timeZone ?? null, lrucache: t.lrucache, interceptor: t.interceptor, localScope: null, depthCounter: { depth: 1 } }, c = await ge(s5, e3);
  if (c instanceof w || c instanceof x) {
    const e4 = c.value;
    if (e4 === M) return null;
    if (v(e4)) throw new a(s5, r.IllegalResult, null);
    return e4;
  }
  if (c === M) return null;
  if (c === O) throw new a(s5, r.IllegalResult, null);
  if (c === R) throw new a(s5, r.IllegalResult, null);
  throw new a(s5, r.NeverReach, null);
}
qe([p2]);
export {
  Te as executeScript,
  qe as extend,
  Pe as functionHelper
};
//# sourceMappingURL=arcadeAsyncRuntime-X4EZGVVS.js.map
