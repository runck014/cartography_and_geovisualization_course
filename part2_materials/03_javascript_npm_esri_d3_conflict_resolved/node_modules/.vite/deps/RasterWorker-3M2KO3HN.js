import {
  T,
  a as a2,
  c,
  y
} from "./chunk-66IRR373.js";
import {
  ie,
  v,
  w as w2
} from "./chunk-V4ENL6LP.js";
import {
  _,
  h2 as h,
  j as j2,
  m3 as m
} from "./chunk-5XQEH26Y.js";
import {
  D,
  E,
  R,
  U,
  W,
  f2 as f,
  g,
  s3 as s2,
  u3 as u
} from "./chunk-7PP3YNSG.js";
import "./chunk-UFFVFTYV.js";
import "./chunk-KKH7HGO3.js";
import "./chunk-RN66FJAW.js";
import "./chunk-AFULL6KA.js";
import "./chunk-URFLFG2R.js";
import "./chunk-4NJWIUZG.js";
import "./chunk-QCBTLG25.js";
import "./chunk-SUZN3TAH.js";
import {
  s
} from "./chunk-XGYM66XX.js";
import "./chunk-JOOGZSAP.js";
import "./chunk-J6GHQIZ2.js";
import "./chunk-Y2XCZQML.js";
import "./chunk-EZXLBRAS.js";
import "./chunk-2PK57UYA.js";
import "./chunk-3L2AYCZY.js";
import {
  r as r2
} from "./chunk-TSVUPARM.js";
import "./chunk-VUJERGGB.js";
import "./chunk-NTI2OCVI.js";
import "./chunk-ZCHZRNUG.js";
import "./chunk-G6REFQRQ.js";
import "./chunk-2TEGRXBS.js";
import "./chunk-6Y2LNRVP.js";
import "./chunk-5YRJ4YFE.js";
import "./chunk-6YWQXXBX.js";
import {
  j2 as j,
  w
} from "./chunk-FG3XOAFD.js";
import "./chunk-GN5RE63N.js";
import "./chunk-2WXAPZBK.js";
import "./chunk-E2I7HYXQ.js";
import "./chunk-WTNHDCCU.js";
import "./chunk-7O7KFKCG.js";
import "./chunk-TVTRNT6K.js";
import "./chunk-CRH37WFF.js";
import "./chunk-YFGQMO6E.js";
import "./chunk-HAF6QJ32.js";
import "./chunk-H77COA2S.js";
import {
  a4 as a
} from "./chunk-7LJCT7EA.js";
import {
  r
} from "./chunk-MV5XBD6C.js";
import "./chunk-GRW2QIBT.js";
import "./chunk-R2PAF6JT.js";
import "./chunk-6WE7SNQY.js";
import "./chunk-L6CCOEVE.js";
import "./chunk-PKLD5YJF.js";
import "./chunk-XKQWTZMW.js";
import "./chunk-A4OFG7JM.js";

// node_modules/@arcgis/core/layers/support/rasterTransforms/IdentityTransform.js
var e;
var a3 = e = class extends a2 {
  constructor() {
    super(...arguments), this.type = "identity";
  }
  clone() {
    return new e();
  }
};
r([r2({ IdentityXform: "identity" })], a3.prototype, "type", void 0), a3 = e = r([a("esri.layers.support.rasterTransforms.IdentityTransform")], a3);
var p = a3;

// node_modules/@arcgis/core/layers/support/rasterTransforms/utils.js
var o = { GCSShiftXform: c, IdentityXform: p, PolynomialXform: y };
var e2 = Object.keys(o);
function i(r3) {
  const t = r3 == null ? void 0 : r3.type;
  if (!t) return null;
  const n = o[r3 == null ? void 0 : r3.type];
  if (n) {
    const t2 = new n();
    return t2.read(r3), t2;
  }
  return null;
}

// node_modules/@arcgis/core/layers/support/RasterWorker.js
var J = class {
  convertVectorFieldData(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = f(t, r3.type);
    return Promise.resolve(null != s3 ? s3.toJSON() : null);
  }
  computeStatisticsHistograms(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = m(t);
    return Promise.resolve(s3);
  }
  async decode(r3) {
    const e3 = await j2(r3.data, r3.options);
    return e3 && e3.toJSON();
  }
  symbolize(r3) {
    r3.pixelBlock = g.fromJSON(r3.pixelBlock), r3.extent = r3.extent ? w.fromJSON(r3.extent) : null;
    const t = this.symbolizer.symbolize(r3);
    return Promise.resolve(null != t ? t.toJSON() : null);
  }
  async updateSymbolizer(r3) {
    var _a;
    this.symbolizer = _.fromJSON(r3.symbolizerJSON), r3.histograms && "rasterStretch" === ((_a = this.symbolizer) == null ? void 0 : _a.rendererJSON.type) && (this.symbolizer.rendererJSON.histograms = r3.histograms);
  }
  async updateRasterFunction(r3) {
    this.rasterFunction = T(r3.rasterFunctionJSON);
  }
  async process(r3) {
    var _a;
    const t = this.rasterFunction.process({ extent: w.fromJSON(r3.extent), primaryPixelBlocks: r3.primaryPixelBlocks.map((r4) => null != r4 ? g.fromJSON(r4) : null), primaryPixelSizes: (_a = r3.primaryPixelSizes) == null ? void 0 : _a.map((r4) => null != r4 ? j.fromJSON(r4) : null), primaryRasterIds: r3.primaryRasterIds });
    return null != t ? t.toJSON() : null;
  }
  stretch(r3) {
    const t = this.symbolizer.simpleStretch(g.fromJSON(r3.srcPixelBlock), r3.stretchParams);
    return Promise.resolve(t == null ? void 0 : t.toJSON());
  }
  estimateStatisticsHistograms(r3) {
    const t = h(g.fromJSON(r3.srcPixelBlock));
    return Promise.resolve(t);
  }
  split(r3) {
    const t = W(g.fromJSON(r3.srcPixelBlock), r3.tileSize, r3.maximumPyramidLevel ?? 0, false === r3.useBilinear);
    return t && t.forEach((r4, e3) => {
      t.set(e3, r4 == null ? void 0 : r4.toJSON());
    }), Promise.resolve(t);
  }
  clipTile(r3) {
    const t = g.fromJSON(r3.pixelBlock), s3 = E({ ...r3, pixelBlock: t });
    return Promise.resolve(s3 == null ? void 0 : s3.toJSON());
  }
  async mosaicAndTransform(r3) {
    const t = r3.srcPixelBlocks.map((r4) => r4 ? new g(r4) : null), s3 = U(t, r3.srcMosaicSize, { blockWidths: r3.blockWidths, alignmentInfo: r3.alignmentInfo, clipOffset: r3.clipOffset, clipSize: r3.clipSize });
    let o2, l = s3;
    return r3.coefs && (l = D(s3, r3.destDimension, r3.coefs, r3.sampleSpacing, r3.interpolation)), r3.projectDirections && r3.gcsGrid && (o2 = R(r3.destDimension, r3.gcsGrid), l = u(l, r3.isUV ? "vector-uv" : "vector-magdir", o2)), { pixelBlock: l == null ? void 0 : l.toJSON(), localNorthDirections: o2 };
  }
  async createFlowMesh(r3, e3) {
    const t = { data: new Float32Array(r3.flowData.buffer), mask: new Uint8Array(r3.flowData.maskBuffer), width: r3.flowData.width, height: r3.flowData.height }, { vertexData: s3, indexData: o2 } = await s2(r3.meshType, r3.simulationSettings, t, e3.signal);
    return { result: { vertexBuffer: s3.buffer, indexBuffer: o2.buffer }, transferList: [s3.buffer, o2.buffer] };
  }
  async getProjectionOffsetGrid(e3) {
    const t = w.fromJSON(e3.projectedExtent), s3 = w.fromJSON(e3.srcBufferExtent);
    let o2 = null;
    e3.datumTransformationSteps && (o2 = new s({ steps: e3.datumTransformationSteps })), (e3.includeGCSGrid || w2(t.spatialReference, s3.spatialReference, o2)) && await v();
    const i2 = e3.rasterTransform ? i(e3.rasterTransform) : null;
    return ie({ ...e3, projectedExtent: t, srcBufferExtent: s3, datumTransformation: o2, rasterTransform: i2 });
  }
};
export {
  J as default
};
//# sourceMappingURL=RasterWorker-3M2KO3HN.js.map
