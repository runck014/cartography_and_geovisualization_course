import posix from 'path/posix';

declare const existsAsync: (file: string) => Promise<boolean>;
/** Wrapper for execSync to execute shell commands */
declare const sh: (command: string, cwd?: string) => string;
declare function createFileIfNotExists(filePath: string, content: string): Promise<void>;
/**
 * Climb the directory tree upward, until found a directory that contains the
 * target file, and return resulting full path
 */
declare function findPath(target: string, startDirectory?: string): string | undefined;
/**
 * Climb the directory tree upward, until found a directory that contains the
 * target file, and return resulting full path
 */
declare function asyncFindPath(target: string, startDirectory?: string): Promise<string | undefined>;

/**
 * This is called "isPosix" rather than "isNotWindows" because even if we are
 * on Windows, we could be running in a POSIX environment (e.g. WSL2)
 */
declare const isPosix: boolean;
declare const toPosixPathSeparators: (relativePath: string) => string;
/**
 * On Windows, replace all `/` in the path back with `\\`. Do this only if you
 * wish to output the path in the console or error message.
 * On POSIX system (macOS, Linux, ...), this does not change the path (because
 * inside the compiler we use `/` everywhere).
 */
declare const toSystemPathSeparators: (relativePath: string) => string;
declare const getCwd: () => string;
declare const path: typeof posix & {
    sep: "/";
};
declare const exportsForTests: {
    toWin32PathSeparators: (relativePath: string) => string;
};

/**
 * A subset of the package.json typing that is interesting to Lumina.
 *
 * The full package.json type is insanely large (20k lines):
 * https://github.com/ffflorian/schemastore-updater/blob/main/schemas/package/index.d.ts#L20067
 */
type MiniPackageJson = {
    "name": string;
    "version": string;
    "dependencies"?: Record<string, string>;
    "devDependencies"?: Record<string, string>;
    "peerDependencies"?: Record<string, string>;
    "css.customData"?: string[];
    "customElements"?: string;
    "html.customData"?: string[];
    "web-types"?: string;
};
declare function retrievePackageJson(location?: string): MiniPackageJson;
declare function asyncRetrievePackageJson(location?: string): Promise<MiniPackageJson>;
/**
 * Returns an absolute path to the root of a package in node_modules, without
 * trailing slash.
 */
declare function fetchPackageLocation(packageName: string, cwd?: string): Promise<string>;

/**
 * Detect if current repository/monorepo uses npm, yarn or pnpm
 */
declare function detectPackageManager(cwd?: string): string;

export { type MiniPackageJson, asyncFindPath, asyncRetrievePackageJson, createFileIfNotExists, detectPackageManager, existsAsync, exportsForTests, fetchPackageLocation, findPath, getCwd, isPosix, path, retrievePackageJson, sh, toPosixPathSeparators, toSystemPathSeparators };
