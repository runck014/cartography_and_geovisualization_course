"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  asyncFindPath: () => asyncFindPath,
  asyncRetrievePackageJson: () => asyncRetrievePackageJson,
  createFileIfNotExists: () => createFileIfNotExists,
  detectPackageManager: () => detectPackageManager,
  existsAsync: () => existsAsync,
  exportsForTests: () => exportsForTests,
  fetchPackageLocation: () => fetchPackageLocation,
  findPath: () => findPath,
  getCwd: () => getCwd,
  isPosix: () => isPosix,
  path: () => path,
  retrievePackageJson: () => retrievePackageJson,
  sh: () => sh,
  toPosixPathSeparators: () => toPosixPathSeparators,
  toSystemPathSeparators: () => toSystemPathSeparators
});
module.exports = __toCommonJS(src_exports);
var import_node_fs3 = require("fs");
var import_node_path = require("path");

// src/file.ts
var import_node_fs = require("fs");
var import_promises = require("fs/promises");
var import_node_child_process = require("child_process");
var import_path = require("path");
var import_node_url = require("url");
var existsAsync = async (file) => await (0, import_promises.access)(file, import_promises.constants.F_OK).then(() => true).catch(() => false);
var sh = (command, cwd) => (0, import_node_child_process.execSync)(command.trim(), { encoding: "utf8", cwd }).trim();
async function createFileIfNotExists(filePath, content) {
  await (0, import_promises.mkdir)((0, import_path.dirname)(filePath), { recursive: true });
  if (!await existsAsync(filePath)) {
    await (0, import_promises.writeFile)(filePath, content, { encoding: "utf8" });
  }
}
function findPath(target, startDirectory = process.cwd()) {
  const resolvedStartDirectory = startDirectory.startsWith("file:///") ? (0, import_path.dirname)((0, import_node_url.fileURLToPath)(startDirectory)) : (0, import_path.resolve)(startDirectory);
  const parentPath = resolvedStartDirectory.split(import_path.sep);
  while (parentPath.length > 2) {
    const fullPath = (0, import_path.join)(
      ...import_path.sep === "/" ? ["/"] : [],
      ...parentPath,
      target
    );
    if ((0, import_node_fs.existsSync)(fullPath)) {
      return fullPath;
    }
    parentPath.pop();
  }
  return void 0;
}
async function asyncFindPath(target, startDirectory = process.cwd()) {
  const resolvedStartDirectory = startDirectory.startsWith("file:///") ? (0, import_path.dirname)((0, import_node_url.fileURLToPath)(startDirectory)) : (0, import_path.resolve)(startDirectory);
  const parentPath = resolvedStartDirectory.split(import_path.sep);
  while (parentPath.length > 2) {
    const fullPath = (0, import_path.join)(
      ...import_path.sep === "/" ? ["/"] : [],
      ...parentPath,
      target
    );
    if (await existsAsync(fullPath)) {
      return fullPath;
    }
    parentPath.pop();
  }
  return void 0;
}

// src/path.ts
var import_path2 = require("path");
var import_posix = __toESM(require("path/posix"), 1);
var import_win32 = __toESM(require("path/win32"), 1);
var isPosix = import_path2.sep === import_posix.default.sep;
var toPosixPathSeparators = (relativePath) => relativePath.includes(import_win32.default.sep) ? relativePath.replaceAll(import_win32.default.sep, import_posix.default.sep) : relativePath;
var toWin32PathSeparators = (relativePath) => relativePath.includes(import_posix.default.sep) ? relativePath.replaceAll(import_posix.default.sep, import_win32.default.sep) : relativePath;
var toSystemPathSeparators = isPosix ? (path2) => path2 : toWin32PathSeparators;
var getCwd = isPosix ? process.cwd : () => toPosixPathSeparators(process.cwd());
var path = isPosix ? import_posix.default : {
  ...import_win32.default,
  sep: import_posix.default.sep,
  join(...paths) {
    const result = import_win32.default.join(...paths);
    return toPosixPathSeparators(result);
  },
  normalize(path2) {
    const result = import_win32.default.normalize(path2);
    return toPosixPathSeparators(result);
  },
  relative(from, to) {
    const result = import_win32.default.relative(from, to);
    return toPosixPathSeparators(result);
  },
  dirname(path2) {
    const result = import_win32.default.dirname(path2);
    return toPosixPathSeparators(result);
  },
  resolve(...paths) {
    const result = import_win32.default.resolve(...paths);
    return toPosixPathSeparators(result);
  },
  toNamespacedPath(path2) {
    const result = import_win32.default.toNamespacedPath(path2);
    return toPosixPathSeparators(result);
  }
};
var exportsForTests = { toWin32PathSeparators };

// src/packageJson.ts
var import_node_fs2 = require("fs");
var import_promises2 = require("fs/promises");
var cachedPackageJson = {};
var cachedPackageJsonPromises = {};
var rootPackageJsonLocation;
function retrievePackageJson(location) {
  const packageJsonPath = location ? path.resolve(location, "package.json") : rootPackageJsonLocation ??= findPath("package.json");
  cachedPackageJson[packageJsonPath] ??= JSON.parse((0, import_node_fs2.readFileSync)(packageJsonPath, "utf-8"));
  return cachedPackageJson[packageJsonPath];
}
async function asyncRetrievePackageJson(location = getCwd()) {
  const packageJsonPath = path.resolve(location, "package.json");
  if (packageJsonPath in cachedPackageJson) {
    return cachedPackageJson[packageJsonPath];
  }
  cachedPackageJsonPromises[packageJsonPath] ??= asyncReadPackageJson(packageJsonPath);
  const result = await cachedPackageJsonPromises[packageJsonPath];
  cachedPackageJson[packageJsonPath] ??= result;
  return result;
}
var asyncReadPackageJson = async (location) => JSON.parse(await (0, import_promises2.readFile)(location, "utf-8"));
var cachedPackageLocation = {};
var cachedPackageLocationPromises = {};
async function fetchPackageLocation(packageName, cwd) {
  if (packageName in cachedPackageLocation) {
    return cachedPackageLocation[packageName];
  }
  cachedPackageLocationPromises[packageName] ??= asyncFindPath(
    path.join("node_modules", packageName, "package.json"),
    cwd
  ).then((packageJsonLocation) => {
    if (packageJsonLocation === void 0) {
      throw new Error(
        `@arcgis/lumina-compiler: Unable to resolve package.json location for "${packageName}" package. Current working directory: ${process.cwd()}`
      );
    }
    return path.dirname(packageJsonLocation);
  });
  const result = await cachedPackageLocationPromises[packageName];
  cachedPackageLocation[packageName] ??= result;
  return cachedPackageLocation[packageName];
}

// src/index.ts
function detectPackageManager(cwd = process.cwd()) {
  let packageManager = void 0;
  {
    const pathParts = cwd.split(import_node_path.sep);
    while (pathParts.length > 1) {
      const packageJson = (0, import_node_path.join)(pathParts.join(import_node_path.sep), "package.json");
      pathParts.pop();
      if (!(0, import_node_fs3.existsSync)(packageJson)) {
        continue;
      }
      const contents = JSON.parse((0, import_node_fs3.readFileSync)(packageJson, "utf8"));
      if (typeof contents !== "object" || Array.isArray(contents)) {
        continue;
      }
      if (typeof contents.packageManager === "string") {
        packageManager ??= contents.packageManager.match(/\w+/u)?.[0] ?? packageManager;
      }
    }
  }
  packageManager ??= "npm";
  return packageManager;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  asyncFindPath,
  asyncRetrievePackageJson,
  createFileIfNotExists,
  detectPackageManager,
  existsAsync,
  exportsForTests,
  fetchPackageLocation,
  findPath,
  getCwd,
  isPosix,
  path,
  retrievePackageJson,
  sh,
  toPosixPathSeparators,
  toSystemPathSeparators
});
