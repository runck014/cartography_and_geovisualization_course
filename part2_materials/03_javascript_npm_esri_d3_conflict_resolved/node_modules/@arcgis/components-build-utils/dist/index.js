// src/index.ts
import { existsSync as existsSync2, readFileSync as readFileSync2 } from "node:fs";
import { join as join2, sep as sep3 } from "node:path";

// src/file.ts
import { existsSync } from "node:fs";
import { access, constants, mkdir, writeFile } from "node:fs/promises";
import { execSync } from "node:child_process";
import { dirname, join, resolve, sep } from "path";
import { fileURLToPath } from "node:url";
var existsAsync = async (file) => await access(file, constants.F_OK).then(() => true).catch(() => false);
var sh = (command, cwd) => execSync(command.trim(), { encoding: "utf8", cwd }).trim();
async function createFileIfNotExists(filePath, content) {
  await mkdir(dirname(filePath), { recursive: true });
  if (!await existsAsync(filePath)) {
    await writeFile(filePath, content, { encoding: "utf8" });
  }
}
function findPath(target, startDirectory = process.cwd()) {
  const resolvedStartDirectory = startDirectory.startsWith("file:///") ? dirname(fileURLToPath(startDirectory)) : resolve(startDirectory);
  const parentPath = resolvedStartDirectory.split(sep);
  while (parentPath.length > 2) {
    const fullPath = join(
      ...sep === "/" ? ["/"] : [],
      ...parentPath,
      target
    );
    if (existsSync(fullPath)) {
      return fullPath;
    }
    parentPath.pop();
  }
  return void 0;
}
async function asyncFindPath(target, startDirectory = process.cwd()) {
  const resolvedStartDirectory = startDirectory.startsWith("file:///") ? dirname(fileURLToPath(startDirectory)) : resolve(startDirectory);
  const parentPath = resolvedStartDirectory.split(sep);
  while (parentPath.length > 2) {
    const fullPath = join(
      ...sep === "/" ? ["/"] : [],
      ...parentPath,
      target
    );
    if (await existsAsync(fullPath)) {
      return fullPath;
    }
    parentPath.pop();
  }
  return void 0;
}

// src/path.ts
import { sep as sep2 } from "path";
import posix from "path/posix";
import win32 from "path/win32";
var isPosix = sep2 === posix.sep;
var toPosixPathSeparators = (relativePath) => relativePath.includes(win32.sep) ? relativePath.replaceAll(win32.sep, posix.sep) : relativePath;
var toWin32PathSeparators = (relativePath) => relativePath.includes(posix.sep) ? relativePath.replaceAll(posix.sep, win32.sep) : relativePath;
var toSystemPathSeparators = isPosix ? (path2) => path2 : toWin32PathSeparators;
var getCwd = isPosix ? process.cwd : () => toPosixPathSeparators(process.cwd());
var path = isPosix ? posix : {
  ...win32,
  sep: posix.sep,
  join(...paths) {
    const result = win32.join(...paths);
    return toPosixPathSeparators(result);
  },
  normalize(path2) {
    const result = win32.normalize(path2);
    return toPosixPathSeparators(result);
  },
  relative(from, to) {
    const result = win32.relative(from, to);
    return toPosixPathSeparators(result);
  },
  dirname(path2) {
    const result = win32.dirname(path2);
    return toPosixPathSeparators(result);
  },
  resolve(...paths) {
    const result = win32.resolve(...paths);
    return toPosixPathSeparators(result);
  },
  toNamespacedPath(path2) {
    const result = win32.toNamespacedPath(path2);
    return toPosixPathSeparators(result);
  }
};
var exportsForTests = { toWin32PathSeparators };

// src/packageJson.ts
import { readFileSync } from "node:fs";
import { readFile } from "node:fs/promises";
var cachedPackageJson = {};
var cachedPackageJsonPromises = {};
var rootPackageJsonLocation;
function retrievePackageJson(location) {
  const packageJsonPath = location ? path.resolve(location, "package.json") : rootPackageJsonLocation ??= findPath("package.json");
  cachedPackageJson[packageJsonPath] ??= JSON.parse(readFileSync(packageJsonPath, "utf-8"));
  return cachedPackageJson[packageJsonPath];
}
async function asyncRetrievePackageJson(location = getCwd()) {
  const packageJsonPath = path.resolve(location, "package.json");
  if (packageJsonPath in cachedPackageJson) {
    return cachedPackageJson[packageJsonPath];
  }
  cachedPackageJsonPromises[packageJsonPath] ??= asyncReadPackageJson(packageJsonPath);
  const result = await cachedPackageJsonPromises[packageJsonPath];
  cachedPackageJson[packageJsonPath] ??= result;
  return result;
}
var asyncReadPackageJson = async (location) => JSON.parse(await readFile(location, "utf-8"));
var cachedPackageLocation = {};
var cachedPackageLocationPromises = {};
async function fetchPackageLocation(packageName, cwd) {
  if (packageName in cachedPackageLocation) {
    return cachedPackageLocation[packageName];
  }
  cachedPackageLocationPromises[packageName] ??= asyncFindPath(
    path.join("node_modules", packageName, "package.json"),
    cwd
  ).then((packageJsonLocation) => {
    if (packageJsonLocation === void 0) {
      throw new Error(
        `@arcgis/lumina-compiler: Unable to resolve package.json location for "${packageName}" package. Current working directory: ${process.cwd()}`
      );
    }
    return path.dirname(packageJsonLocation);
  });
  const result = await cachedPackageLocationPromises[packageName];
  cachedPackageLocation[packageName] ??= result;
  return cachedPackageLocation[packageName];
}

// src/index.ts
function detectPackageManager(cwd = process.cwd()) {
  let packageManager = void 0;
  {
    const pathParts = cwd.split(sep3);
    while (pathParts.length > 1) {
      const packageJson = join2(pathParts.join(sep3), "package.json");
      pathParts.pop();
      if (!existsSync2(packageJson)) {
        continue;
      }
      const contents = JSON.parse(readFileSync2(packageJson, "utf8"));
      if (typeof contents !== "object" || Array.isArray(contents)) {
        continue;
      }
      if (typeof contents.packageManager === "string") {
        packageManager ??= contents.packageManager.match(/\w+/u)?.[0] ?? packageManager;
      }
    }
  }
  packageManager ??= "npm";
  return packageManager;
}
export {
  asyncFindPath,
  asyncRetrievePackageJson,
  createFileIfNotExists,
  detectPackageManager,
  existsAsync,
  exportsForTests,
  fetchPackageLocation,
  findPath,
  getCwd,
  isPosix,
  path,
  retrievePackageJson,
  sh,
  toPosixPathSeparators,
  toSystemPathSeparators
};
