/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.31/esri/copyright.txt for details.
 * v4.31.6
 */
import { r as registerInstance, c as createEvent, g as getElement, h } from './index-1731abba.js';
import { n as newWidgetsBuildingExplorer, i as importCoreReactiveUtils, a as newWebScene, b as newViewsSceneView } from './index-a1e05d0a.js';
import { m as makeWidgetController } from './useWidget-a0180c4c.js';
import { u as usePropertyChange, l as load } from './index-b8c7454b.js';
import { u as useControllerManager, r as readonly, g as getSet, a as accessorSupport, m as makeAccessorController } from './index-e7ca9269.js';
import { p as parseCenter, a as parsePoint, b as areCamerasEqual, i as isNotSameEnvironment, c as isNotSameViewpoint } from './component-utils-7177db90.js';

const buildingExplorerCss = "";
const ArcgisBuildingExplorerStyle0 = buildingExplorerCss;

const useBuildingExplorerWidget = makeWidgetController(newWidgetsBuildingExplorer);
const ArcgisBuildingExplorer = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisReady = createEvent(this, "arcgisReady", 7);
        this.arcgisPropertyChange = createEvent(this, "arcgisPropertyChange", 7);
        this.manager = useControllerManager(this);
        this.widget = useBuildingExplorerWidget(this);
        this.viewModel = this.widget.viewModel;
        this.arcgisPropertyChange = usePropertyChange()("level", "phase", "state");
        this.autoDestroyDisabled = false;
        this.icon = this.widget.icon;
        this.label = this.widget.label;
        this.layers = this.widget.layers;
        this.headingLevel = this.widget.headingLevel;
        this.level = this.viewModel.level;
        this.phase = this.viewModel.phase;
        this.state = this.viewModel.state;
        this.hideLevels = this.widget.visibleElements.levels;
        this.hidePhases = this.widget.visibleElements.phases;
        this.hideDisciplines = this.widget.visibleElements.disciplines;
        this.position = "bottom-left";
        this.referenceElement = undefined;
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    /** Permanently destroy the component */
    async destroy() {
        await this.manager.destroy();
    }
    get el() { return getElement(this); }
};
ArcgisBuildingExplorer.style = ArcgisBuildingExplorerStyle0;

const sceneCss = ".arcgis-scene{padding:0;margin:0;height:100%;width:100%}";
const ArcgisSceneStyle0 = sceneCss;

const useWebScene = makeAccessorController(newWebScene);
const useSceneView = makeAccessorController(newViewsSceneView);
const ArcgisScene = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.arcgisViewReadyChange = createEvent(this, "arcgisViewReadyChange", 7);
        this.arcgisViewChange = createEvent(this, "arcgisViewChange", 7);
        this.arcgisViewClick = createEvent(this, "arcgisViewClick", 7);
        this.arcgisViewDoubleClick = createEvent(this, "arcgisViewDoubleClick", 7);
        this.arcgisViewDrag = createEvent(this, "arcgisViewDrag", 7);
        this.arcgisViewHold = createEvent(this, "arcgisViewHold", 7);
        this.arcgisViewImmediateClick = createEvent(this, "arcgisViewImmediateClick", 7);
        this.arcgisViewImmediateDoubleClick = createEvent(this, "arcgisViewImmediateDoubleClick", 7);
        this.arcgisViewKeyDown = createEvent(this, "arcgisViewKeyDown", 7);
        this.arcgisViewKeyUp = createEvent(this, "arcgisViewKeyUp", 7);
        this.arcgisViewLayerviewCreate = createEvent(this, "arcgisViewLayerviewCreate", 7);
        this.arcgisViewLayerviewCreateError = createEvent(this, "arcgisViewLayerviewCreateError", 7);
        this.arcgisViewLayerviewDestroy = createEvent(this, "arcgisViewLayerviewDestroy", 7);
        this.arcgisViewMouseWheel = createEvent(this, "arcgisViewMouseWheel", 7);
        this.arcgisViewPointerDown = createEvent(this, "arcgisViewPointerDown", 7);
        this.arcgisViewPointerEnter = createEvent(this, "arcgisViewPointerEnter", 7);
        this.arcgisViewPointerLeave = createEvent(this, "arcgisViewPointerLeave", 7);
        this.arcgisViewPointerMove = createEvent(this, "arcgisViewPointerMove", 7);
        this.arcgisViewPointerUp = createEvent(this, "arcgisViewPointerUp", 7);
        this.manager = useControllerManager(this);
        this.reactiveUtils = load(importCoreReactiveUtils);
        /**
         * This WebMap will be created only if user did not provide a map. Otherwise,
         * it will be equal to this.view.map
         */
        this._map = useWebScene(this, { editConstructorProperties: this._editMapProperties });
        //--------------------------------------------------------------------------
        //
        //  Private Methods
        //
        //--------------------------------------------------------------------------
        this._setChildElement = (el) => {
            this.el.childElem = el;
        };
        this.autoDestroyDisabled = false;
        this.view = readonly(useSceneView(this, { editConstructorProperties: this._editViewProperties }));
        this.map = this.view.map;
        this.allLayerViews = this.view.allLayerViews;
        this.alphaCompositingEnabled = this.view.alphaCompositingEnabled;
        this.analyses = this.view.analyses;
        this.basemapView = this.view.basemapView;
        this.basemap = this._map.basemap;
        this.camera = getSet(undefined, {
            get: () => this.view.camera,
            set: (newValue, oldValue) => {
                if (!this.ready) {
                    return newValue;
                }
                if (!areCamerasEqual(oldValue, newValue)) {
                    this.view.camera = newValue;
                }
                return this.view.camera;
            },
        });
        this.cameraFov = getSet(undefined, {
            get: (value) => this.view.camera?.fov ?? value,
            set: (newValue) => {
                if (!this.ready) {
                    return newValue;
                }
                if (newValue != null) {
                    this._mutateCamera((camera) => {
                        camera.fov = newValue;
                    });
                }
                return this.view.camera?.fov;
            },
        });
        this.cameraHeading = getSet(undefined, {
            get: (value) => this.view.camera?.heading ?? value,
            set: (newValue) => {
                if (!this.ready) {
                    return newValue;
                }
                if (newValue != null) {
                    this._mutateCamera((camera) => {
                        camera.heading = newValue;
                    });
                }
                return this.view.camera?.heading;
            },
        });
        this.cameraPosition = getSet(undefined, {
            get: (value) => this.view.camera?.position ?? value,
            set: (newValue) => {
                if (!this.ready) {
                    return newValue;
                }
                const parsed = parsePoint(this.view.camera?.position, newValue);
                if (parsed) {
                    this._mutateCamera((camera) => {
                        camera.position = parsed;
                    });
                }
                return this.view.camera?.position;
            },
        });
        this.cameraTilt = getSet(undefined, {
            get: (value) => this.view.camera?.tilt ?? value,
            set: (newValue) => {
                if (!this.ready) {
                    return newValue;
                }
                if (newValue != null) {
                    this._mutateCamera((camera) => {
                        camera.tilt = newValue;
                    });
                }
                return this.view.camera?.tilt;
            },
        });
        this.center = getSet(undefined, {
            get: (value) => this.view.center ?? value,
            set: (newValue) => {
                const parsed = parseCenter(newValue, this.ready ? this.view : undefined);
                if (!this.ready) {
                    return parsed;
                }
                this.view.center = parsed;
                return this.view.center;
            },
        });
        this.clippingArea = getSet(this.view.clippingArea, {
            set: (newValue, oldValue) => (oldValue?.equals(newValue) ? oldValue : newValue),
        });
        this.constraints = this.view.constraints;
        this.environment = getSet(this.view.environment, {
            set: (newValue, oldValue) => (isNotSameEnvironment(oldValue, newValue) ? newValue : oldValue),
        });
        this.extent = getSet(undefined, {
            get: (extent) => this.view.extent ?? extent,
            set: (newValue, oldValue) => {
                if (!this.view.ready) {
                    return newValue;
                }
                if (newValue && !oldValue?.equals(newValue)) {
                    this.view.extent = newValue;
                }
                return this.view.extent;
            },
        });
        this.fatalError = this.view.fatalError;
        this.floors = this.view.floors;
        this.gamepad = getSet(undefined, {
            get: () => (this.ready ? this.view.input.gamepad : undefined),
            set: "ignore",
        });
        this.graphics = this.view.graphics;
        this.ground = this._map.ground;
        this.groundView = this.view.groundView;
        this.highlightOptions = this.view.highlightOptions;
        this.interacting = getSet(false, {
            get: () => this.view.interacting,
            set: "ignore",
        });
        this.itemId = getSet(undefined, {
            get: (value) => this._map.portalItem?.id ?? value,
            set: (newValue) => {
                // SceneView does not react to WebScene.portalItem change, so we have to recreate it
                if (this.ready) {
                    accessorSupport
                        .reCreate(this._map, this)
                        .then(() => {
                        this.view.map = this._map;
                    })
                        .catch(console.error);
                }
                return newValue;
            },
        });
        this.layerViews = this.view.layerViews;
        this.magnifier = this.view.magnifier;
        this.navigating = getSet(false, {
            get: () => this.view.navigating,
            set: "ignore",
        });
        this.navigation = this.view.navigation;
        this.padding = this.view.padding;
        this.performanceInfo = getSet(undefined, {
            get: () => this.view.performanceInfo,
            set: "ignore",
        });
        this.popup = this.view.popup;
        this.popupDisabled = this.view.popupEnabled;
        this.qualityProfile = this.view.qualityProfile;
        this.ready = this.view.ready;
        this.resolution = getSet(undefined, {
            get: () => this.view.resolution,
            set: "ignore",
        });
        this.scale = getSet(undefined, {
            get: (scale) => this.view.scale ?? scale,
            set: (newValue) => {
                if (this.ready) {
                    this.view.scale = newValue;
                }
                return newValue;
            },
        });
        this.spatialReference = getSet(this.view.spatialReference, {
            set: (newValue, oldValue) => (oldValue?.equals(newValue) ? oldValue : newValue),
        });
        this.stationary = getSet(true, {
            get: () => this.view.stationary,
            set: "ignore",
        });
        this.suspended = this.view.suspended;
        this.theme = this.view.theme;
        this.timeExtent = this.view.timeExtent;
        this.toMap = readonly((...args) => this.view.toMap(...args));
        this.toScreen = readonly((...args) => this.view.toScreen(...args));
        this.updating = this.view.updating;
        this.viewingMode = this.view.viewingMode;
        this.viewpoint = getSet(undefined, {
            get: () => this.view.viewpoint,
            set: (newValue, oldValue) => (isNotSameViewpoint(oldValue, newValue) ? newValue : oldValue),
        });
        this.zoom = getSet(undefined, {
            get: (zoom) => this.view.zoom ?? zoom,
            set: (newValue) => {
                if (this.ready) {
                    this.view.zoom = newValue;
                }
                return newValue;
            },
        });
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    /**
     * Adds a layer to the map layers collection.
     */
    async addLayer(layer, index) {
        this.map?.add(layer, index);
    }
    /**
     * Adds a layer or array of layers to the map layers collection.
     */
    async addLayers(layers, index) {
        this.map?.addMany(layers, index);
    }
    /**
     * Closes the popup.
     */
    async closePopup() {
        this.view?.closePopup();
    }
    /**
     * Destroys the view, and any associated resources, including its map, popup, and UI elements.
     */
    async destroy() {
        await this.manager.destroy();
    }
    /**
     * Sets the view to a given target.
     */
    async goTo(target, options) {
        return (await this.view?.goTo(target, options));
    }
    /**
     * Returns hit test results from each layer that intersects the specified screen coordinates.
     */
    async hitTest(screenPoint, options) {
        return await this.view?.hitTest(screenPoint, options);
    }
    /**
     * Opens the popup at the given location with content defined either explicitly with content or driven
     * from the PopupTemplate of input features.
     */
    async openPopup(options) {
        await this.view?.openPopup(options);
    }
    /**
     * Create a screenshot of the current view.
     */
    async takeScreenshot(options) {
        return await this.view?.takeScreenshot(options);
    }
    /**
     * Call this method to clear any fatal errors resulting from a lost WebGL context.
     */
    async tryFatalErrorRecovery() {
        this.view?.tryFatalErrorRecovery();
    }
    async whenAnalysisView(analysis) {
        return await this.view?.whenAnalysisView(analysis);
    }
    /**
     * Gets the LayerView created on the view for the given layer.
     */
    async whenLayerView(layer) {
        return await this.view?.whenLayerView(layer);
    }
    //--------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    componentDidLoad() {
        this.view.container ??= this.el.childElem;
        const { watch } = this.reactiveUtils;
        this.manager.onLifecycle(() => [
            watch(() => this.view.stationary, () => {
                this.arcgisViewChange.emit();
            }, { initial: true }),
            watch(() => this.view.ready, () => this.arcgisViewReadyChange.emit(), { initial: this.view.ready }),
        ]);
        accessorSupport.reEmitAccessorEvents(this.manager, this.view, this.reactiveUtils, "arcgisView");
    }
    render() {
        return h("div", { key: '9e1393b9ac8da70c9e35a8267d0261689b50e075', class: "arcgis-scene", ref: this._setChildElement });
    }
    _editMapProperties(mapProperties) {
        // If user provided a map, use that. Otherwise, a WebScene will be created by usWebScene
        if (this.map) {
            this._map = this.map;
        }
        if (this.itemId) {
            mapProperties.portalItem = { id: this.itemId };
        }
        else if (!this.basemap) {
            mapProperties.basemap = "topo-vector";
        }
        else if (this.basemap === "none") {
            mapProperties.basemap = undefined;
            this.basemap = null;
        }
        // See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/1244#issuecomment-4922799
        const { basemap, ...rest } = mapProperties;
        if (!basemap) {
            mapProperties = rest;
        }
        return mapProperties;
    }
    _editViewProperties(properties) {
        // Don't overwrite UI if a custom one was already provided
        if (!this.view.ui) {
            properties.ui = {
                components: ["attribution"],
            };
        }
        // If user did not provide a map, use the WebScene we created
        properties.map ??= this._map;
        /*
         * The following properties are not two-way bound like others as they change
         * too often. Instead, they are assigned to getters to always get freshest
         * value without triggering re-render. But that means, useAccessor is not
         * aware of these properties, so we have to pass them manually here:
         */
        const center = parseCenter(this.center, undefined);
        if (center) {
            properties.center = center;
        }
        if (this.viewpoint) {
            properties.viewpoint = this.viewpoint;
        }
        if (this.scale !== undefined) {
            properties.scale = this.scale;
        }
        if (this.extent) {
            properties.extent = this.extent;
        }
        if (this.camera) {
            properties.camera = this.camera;
        }
        const cameraPosition = parsePoint(undefined, this.cameraPosition);
        if (cameraPosition) {
            properties.camera ??= {};
            properties.camera.position = cameraPosition;
        }
        if (this.cameraHeading != null) {
            properties.camera ??= {};
            properties.camera.heading = this.cameraHeading;
        }
        if (this.cameraTilt != null) {
            properties.camera ??= {};
            properties.camera.tilt = this.cameraTilt;
        }
        if (this.cameraFov != null) {
            properties.camera ??= {};
            properties.camera.fov = this.cameraFov;
        }
        if (this.zoom !== undefined) {
            properties.zoom = this.zoom;
        }
        return properties;
    }
    _mutateCamera(mutator) {
        const camera = this.view.camera.clone();
        mutator(camera);
        if (!areCamerasEqual(this.view.camera, camera)) {
            this.view.camera = camera;
        }
    }
    get el() { return getElement(this); }
};
ArcgisScene.style = ArcgisSceneStyle0;

export { ArcgisBuildingExplorer as arcgis_building_explorer, ArcgisScene as arcgis_scene };
