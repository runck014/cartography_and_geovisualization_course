/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../renderers/PointCloudClassBreaksRenderer.js";import"../../renderers/PointCloudRenderer.js";import e from"../../renderers/PointCloudRGBRenderer.js";import i from"../../renderers/PointCloudStretchRenderer.js";import"../../renderers/PointCloudUniqueValueRenderer.js";import r from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as a}from"../../core/colorUtils.js";import o from"../../core/Error.js";import{clone as n}from"../../core/lang.js";import{ensureClass as l}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import t from"../../renderers/support/AuthoringInfo.js";import u from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as d,createColorStops as m}from"../../renderers/support/utils.js";import c from"../../renderers/visualVariables/ColorVariable.js";import p from"../../renderers/visualVariables/support/ColorStop.js";import f from"../../renderers/visualVariables/support/VisualVariableLegendOptions.js";import y from"../heuristics/ageUnit.js";import v from"../heuristics/outline.js";import h from"../heuristics/sizeRange.js";import{spliceVisualVariables as w,findColorVVIndex as b,findOutlineVVIndex as g,findScaleDependentSizeVVIndex as T,updateAuthoringInfoVisualVariable as x,processRegenerateParams as z,getRendererToUpdate as E,getStyleType as V,hasOutlineVV as I,hasScaleDependentSizeVV as S}from"./support/regenerateUtils.js";import{getSummaryStatistics as M,errorCallback as j,getClassBreaks as B,getPointSizeAlgorithm as O,getTitleAndExpressionForAgeRenderer as k,updateAgeRendererAuthoringInfoVV as C,verifyBasicFieldValidity as F,isValidPointSize as R,getDefaultDataRange as q,createDefaultStopValues as U,createStopValues as P,getDataRange as D,createDataValues as L,createSymbol as $,getSymbolSizeFromScheme as A,getSymbolOutlineFromScheme as G,getBasemapInfo as W}from"./support/utils.js";import{verifyDates as H,supportedAgeUnits as J}from"../statistics/support/ageUtils.js";import{verifyBinningParams as K}from"../support/binningUtils.js";import{isAnyDateField as N,getFieldsList as Q,getNormalizationType as X}from"../support/utils.js";import{binningCapableLayerTypes as Y,featureCapableLayerTypes as Z,createLayerAdapter as _,getLayerTypeLabels as ee,LayerType as ie}from"../support/adapters/support/layerUtils.js";import{cloneScheme as re,getSchemes as ae,getSchemeById as oe}from"../symbology/color.js";const ne="high-to-low",le=2**53-1,se=5;async function te(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new o("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new o("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-visual-variable");const i={...e},r=e.forBinning?Y:Z,a=_(i.layer,r,e.forBinning);if(!a)throw new o("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);if("mesh"!==a.geometryType&&i.worldScale&&(!i.view||"3d"!==i.view.type))throw new o("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await Q({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),s=F(a,l,"color-visual-variable:invalid-parameters");if(s)throw s;return{...i,layer:a}}async function ue(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new o("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new o("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-continuous-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=e.forBinning?Y:Z,a=_(i.layer,r,e.forBinning);if(!a)throw new o("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);const l=a.geometryType;if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&i.sizeOptimizationEnabled,"mesh"===l)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==l)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await Q({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),t=F(a,s,"color-continuous-renderer:invalid-parameters");if(t)throw t;return{...i,layer:a}}async function de(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new o("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new o("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-class-breaks-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0,i.classificationMethod??="equal-interval",i.normalizationType=X(i);const r=e.forBinning?Y:Z,a=_(i.layer,r,e.forBinning);if(!a)throw new o("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(!(null!=i.minValue&&null!=i.maxValue)&&(null!=i.minValue||null!=i.maxValue))throw new o("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);const l=a.geometryType;if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else{if("3d-volumetric-uniform"===i.symbolType&&"point"!==l)throw new o("color-class-breaks-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await Q({field:i.field,normalizationField:i.normalizationField}),t=F(a,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return{...i,layer:a}}function me(e){const i={...e};delete i.basemap,delete i.colorScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}async function ce(e){if(!e?.layer)throw new o("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const i={...e,layer:e.layer},r=[ie.PointCloudLayer],a=_(i.layer,r);if(!a)throw new o("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(i.layer=a,i.density=i.density||25,i.size=i.size||"100%",!R(i.size))throw new o("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=i.signal?{signal:i.signal}:null;return await a.load(n),i}async function pe(e){if(!e?.layer||!e.field)throw new o("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const i=e.field.toLowerCase();if("intensity"!==i&&"elevation"!==i)throw new o("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const r={...e,layer:e.layer,field:e.field},a=[ie.PointCloudLayer],n=_(r.layer,a);if(!n)throw new o("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(a).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!R(r.size))throw new o("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=r.signal?{signal:r.signal}:null;return await n.load(l),r}function fe(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric");delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const a=i;return a.worldScale=r,a}async function ye(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new o("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const r=_(i.layer,Z);if(!r)throw new o("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+ee(Z).join(", "));const a=null!=i.signal?{signal:i.signal}:null;await r.load(a);const n=r.geometryType;if(i.outlineOptimizationEnabled="polygon"===n&&i.outlineOptimizationEnabled,i.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&i.sizeOptimizationEnabled,"mesh"===n)i.symbolType="3d-volumetric",i.colorMixMode=i.colorMixMode||"replace",i.edgesType=i.edgesType||"none";else if("3d-volumetric-uniform"===i.symbolType&&"point"!==n)throw new o("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new o("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const l=H(r,i.startTime,i.endTime,"color-age-renderer:invalid-parameters");if(l)throw l;if(i.unit&&!J.includes(i.unit))throw new o("color-age-renderer:invalid-unit",`Supported units are: ${J.join(", ")}`);return{...i,layer:r}}async function ve(e){const i="regenerate-color-visual-variable";await z(e,i);const r=await E(e);if("class-breaks"!==r?.type)throw new o(`${i}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a color visual variable");const a=r.authoringInfo,n=a?.visualVariables.find((e=>"color"===e.type)),l=r.visualVariables?.find((e=>"color"===e.type));if(!l)throw new o(`${i}:invalid-parameters`,"Renderer does not have a color visual variable");const{field:s,normalizationField:t,valueExpression:u,valueExpressionTitle:d}=l,m="univariate-color-size"===a?.type?a?.univariateTheme:n?.theme,{layer:c,forBinning:p,filter:f,view:y,signal:v}=e,h=await te({layer:c,field:s,valueExpression:u,valueExpressionTitle:d,normalizationField:t,theme:m,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:h,renderer:r}}async function he(e){const i="regenerate-color-continuous-renderer";await z(e,i);const r=await E(e),a=V(r);if(!a||!["color-continuous","color-size"].includes(a))throw new o(`${i}:invalid-renderer`,"Renderer is invalid");const{authoringInfo:n,field:l,normalizationField:s,valueExpression:t,valueExpressionTitle:u}=r,d=n?.visualVariables.find((e=>"color"===e.type)),m=d?.theme,{layer:c,forBinning:p,filter:f,view:y,signal:v}=e,h=I(r),w=S(r),b=await ue({layer:c,field:l,valueExpression:t,valueExpressionTitle:u,normalizationField:s,theme:m,outlineOptimizationEnabled:h,sizeOptimizationEnabled:w,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:b,renderer:r}}async function we(e){const i="regenerate-color-class-breaks-renderer";await z(e,i);const r=await E(e);if("color-class-breaks"!==V(r))throw new o(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a,field:n,normalizationField:l,normalizationType:s,normalizationTotal:t,valueExpression:u,valueExpressionTitle:d}=r,{classificationMethod:m,standardDeviationInterval:c}=a,p=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:h,signal:w}=e,b=I(r),g=await de({layer:f,field:n,valueExpression:u,valueExpressionTitle:d,normalizationType:s,normalizationField:l,normalizationTotal:t,classificationMethod:m,standardDeviationInterval:c,numClasses:p,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:h,signal:w});return{...e,creatorParameters:g,renderer:r}}async function be(e){const i="regenerate-color-age-renderer";await z(e,i);const r=await E(e);if("color-age"!==V(r))throw new o(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:a}=r,n=a?.visualVariables.find((e=>"color"===e.type)),l=n.startTime,s=n.endTime,t=n.units,u=n.theme,{layer:d,filter:m,view:c,signal:p}=e,f=I(r),y=S(r),v=await ye({layer:d,startTime:l,endTime:s,unit:t,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:m,view:c,signal:p});return{...e,creatorParameters:v,renderer:r}}async function ge(e,i){let r=e.colorScheme,a=null,o=null;const{view:n}=e,l=await W(e.basemap,n);if(a=null!=l.basemapId?l.basemapId:null,o=null!=l.basemapTheme?l.basemapTheme:null,r)return{scheme:re(r),basemapId:a,basemapTheme:o};const s=e.theme||ne,t=ae({theme:s,basemapTheme:o,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(t)if(a=t.basemapId,o=t.basemapTheme,e.schemeId){const i=s+"/"+a+"/"+e.schemeId;r=oe({id:i,geometryType:e.geometryType})}else r=t.primaryScheme;return{scheme:r,basemapId:a,basemapTheme:o}}async function Te(e,i){const r=i.layer,n=await ge({basemap:i.basemap,colorScheme:i.colorScheme,geometryType:r.geometryType,schemeId:"elevation"===i.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),l=n.scheme;if(!l)throw new o("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const s=a(l.colors,se);if(s.length<se)throw new o("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const t=q(e,!1,!0),u=t?U(t[0],t[1],5):P(e);return{stops:m({values:u,isDate:!1,colors:s,labelIndexes:[0,2,4]}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:e,defaultValuesUsed:!!t,colorScheme:re(l)}}function xe(e,i,r,a){const o=D(e,i,r,!0);return{values:L(o,e,i,a),defaultValuesUsed:o.defaultValuesUsed}}async function ze(e,i,r,n){const{field:s,theme:d}=e,m=await ge({basemap:e.basemap,theme:e.theme,geometryType:r,colorScheme:e.colorScheme,worldScale:e.worldScale,view:e.view}),y=m.scheme;if(!y)throw new o("color-visual-variable:insufficient-info","Unable to find color scheme");const v=a(y.colors,se);if(v.length<se)throw new o("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const h=y.id.includes("seq-"),{values:w,defaultValuesUsed:b}=xe(i,d,n,h),g=a(v,se),T=new c({field:s??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationField:e.normalizationField,stops:w.map(((e,i)=>new p({value:e,color:g[i]}))),legendOptions:l(f,e.legendOptions)}),x=new u({type:"color",minSliderValue:null!=e.minValue?e.minValue:i.min,maxSliderValue:null!=e.maxValue?e.maxValue:i.max,theme:y.theme}),z=new t({visualVariables:[x]});return{basemapId:m.basemapId,basemapTheme:m.basemapTheme,visualVariable:T,statistics:i,defaultValuesUsed:b,colorScheme:re(y),authoringInfo:z}}async function Ee(e,i,a,o,n,l,t){const u=await s("esri/smartMapping/t9n/smartMapping"),{field:d,defaultSymbolEnabled:m}=t,c=re(e.colorScheme),p=i?.opacity,f=[e.visualVariable.clone()];i?.visualVariables?.length&&f.push(...i.visualVariables.map((e=>e.clone()))),a?.minSize&&f.push(a.minSize);return{renderer:new r({classBreakInfos:[{minValue:-le,maxValue:le,symbol:$(l,{type:t.symbolType,color:c.noDataColor,size:A(c,l),outline:G(c,l,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:m?u.other:null,defaultSymbol:m?$(l,{type:t.symbolType,color:c.noDataColor,size:A(c,l),outline:G(c,l,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:d,normalizationType:o,normalizationField:n,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:re(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function Ve(e){const i=await te(e),{view:r,field:a,valueExpression:o,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:u,filter:d,statistics:m}=i,c=t?"field":void 0,p=await(m??M({layer:s,field:a,valueExpression:o,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:c,normalizationField:t,minValue:n,maxValue:l,filter:d,view:r,signal:u})),f=s,y=a&&"function"!=typeof a?f.getField(a):null;return ze(i,p,f.geometryType,N(y))}async function Ie(e){const{view:i,filter:r,creatorParameters:a,renderer:n,signal:l}=await ve(e),s=n.authoringInfo?.clone(),t=s?.visualVariables.find((e=>"color"===e.type)),u=n.visualVariables?.find((e=>"color"===e.type)),{field:d,normalizationField:m,valueExpression:c,theme:p,layer:f}=a,y=await M({layer:f,field:d,valueExpression:c,normalizationField:m,filter:r,view:i,signal:l}),v=d&&"function"!=typeof d?f.getField(d):null,{values:h}=xe(y,p,N(v),"high-to-low"===p);if(h.length!==u.stops.length)throw new o("regenerate-color-visual-variable:invalid-parameters","Visual variable is invalid");return u.stops.forEach(((e,i)=>e.value=h[i])),t&&(t.minSliderValue=y.min,t.maxSliderValue=y.max),{visualVariable:u,authoringInfo:s,statistics:y}}function Se(e,i){const r=e.colorsForClassBreaks;if(r?.length)for(const a of r)if(a.numClasses===i)return n(a.colors);return a(e.colors,i)}async function Me(e,i){const a=await s("esri/smartMapping/t9n/smartMapping"),n=e.layer,l=e.defaultSymbolEnabled,u=n.geometryType,m=e.classificationMethod,c="standard-deviation"===m,p=await ge({basemap:e.basemap,geometryType:u,theme:c?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),f=p.scheme,{result:y,outlineResult:v}=i,h=y.classBreakInfos,w=e.normalizationType;if(!f)throw new o("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const b=Se(f,h.length);if(!b||b.length!==h.length)throw new o("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=v?.opacity,T=new r({classBreakInfos:h.map(((i,r)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:$(u,{type:e.symbolType,color:b[r],size:A(f,u),outline:G(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:i.label}))),defaultLabel:l?a.other:null,defaultSymbol:l?$(u,{type:e.symbolType,color:f.noDataColor,size:A(f,u),outline:G(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?y.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new t({type:"class-breaks-color",classificationMethod:m,standardDeviationInterval:e.standardDeviationInterval})});return c||d({classBreakInfos:T.classBreakInfos,classificationMethod:m,normalizationType:w,round:!0}),v?.visualVariables?.length&&(T.visualVariables=v.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:re(f),classBreaksResult:y,defaultValuesUsed:i.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function je(e){const i=await ue(e),{layer:r,view:a,signal:o,filter:n}=i,[l,s,t]=await Promise.all([Ve(fe(i)),i.outlineOptimizationEnabled?v({layer:r,view:a,signal:o,filter:n}).catch(j):null,i.sizeOptimizationEnabled?h({layer:r,view:a,signal:o,filter:n}).catch(j):null]),u=i.normalizationField;return Ee(l,s,t,u?"field":void 0,u,r.geometryType,i)}async function Be(e){const{renderer:i,view:r,signal:a,filter:o,creatorParameters:n}=await he(e),{layer:l,outlineOptimizationEnabled:s,sizeOptimizationEnabled:t}=n,[u,d,m]=await Promise.all([Ie(e),s?v({layer:l,view:r,signal:a,filter:o}).catch(j):null,t?h({layer:l,view:r,signal:a,filter:o}).catch(j):null]);return w(i,u.visualVariable,b),w(i,d?.visualVariables,g),w(i,m?.minSize,T),x(i,u.authoringInfo,"color"),{renderer:i}}async function Oe(e){const i=await de(e);return Me(i,await B(me(i),i.outlineOptimizationEnabled))}async function ke(e){const{renderer:i,creatorParameters:r}=await we(e),{normalizationType:a,outlineOptimizationEnabled:n,classificationMethod:l}=r,{result:s,outlineResult:t}=await B(me(r),n),u=s.classBreakInfos;if(r.numClasses!==u.length)throw new o("regenerate-color-class-breaks-renderer:insufficient-info","The number of class breaks generated does not match the number of class breaks in the renderer.");return i.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),i.normalizationTotal="percent-of-total"===a?s.normalizationTotal:void 0,"standard-deviation"!==l&&d({classBreakInfos:i.classBreakInfos,classificationMethod:l,normalizationType:a,round:!0}),w(i,t?.visualVariables,g),{renderer:i}}function Ce(i){return ce(i).then((i=>({renderer:new e({field:"RGB",pointsPerInch:i.density??void 0,pointSizeAlgorithm:O(i.size)})})))}async function Fe(e){const r=await pe(e),a=r.statistics??await M({layer:r.layer,field:r.field,signal:r.signal}),o=await Te(a,r);return{renderer:new i({field:r.field,pointsPerInch:r.density??void 0,pointSizeAlgorithm:O(r.size),stops:o.stops}),basemapId:o.basemapId,basemapTheme:o.basemapTheme,statistics:o.statistics,defaultValuesUsed:o.defaultValuesUsed,colorScheme:o.colorScheme}}async function Re(e){const i=await ye(e),{defaultSymbolEnabled:r,view:a,startTime:o,endTime:n,symbolType:l,colorMixMode:s,edgesType:t,minValue:u,maxValue:d,signal:m,filter:c}=i,p=i.layer,[f,w,b]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:y({view:a,layer:p,startTime:o,endTime:n,minValue:u,maxValue:d,signal:m,filter:c}),i.outlineOptimizationEnabled?v({layer:p,view:a,signal:m,filter:c}).catch(j):null,i.sizeOptimizationEnabled?h({layer:p,view:a,signal:m,filter:c}).catch(j):null]),{unit:g,statistics:T}=f,{valueExpression:x,title:z}=await k(i,g),E=await Ve(fe({layer:p,basemap:i.basemap,valueExpression:x,symbolType:l,statistics:T,legendOptions:{title:z},colorScheme:i.colorScheme,theme:i.theme,view:a,minValue:i.minValue,maxValue:i.maxValue,filter:c,signal:m})),V={layer:p,valueExpression:x,defaultSymbolEnabled:r,symbolType:l,colorMixMode:s,edgesType:t},I=await Ee(E,w,b,null,null,p.geometryType,V),S=I.renderer.authoringInfo?.visualVariables;return S?.forEach((e=>C(e,o,n,g))),{...I,unit:g}}async function qe(e){const{renderer:i,creatorParameters:r}=await be(e),{layer:a,outlineOptimizationEnabled:o,sizeOptimizationEnabled:n,startTime:l,endTime:s,theme:t,view:u,signal:d,filter:m}=r,[c,p,f]=await Promise.all([y({view:u,layer:a,startTime:l,endTime:s,signal:d,filter:m}),o?v({layer:a,view:u,signal:d,filter:m}).catch(j):null,n?h({layer:a,view:u,signal:d,filter:m}).catch(j):null]),{unit:x,statistics:z}=c,{valueExpression:E,title:V}=await k(r,x),I=await Ve(fe({layer:a,valueExpression:E,statistics:z,legendOptions:{title:V},theme:t,view:u,filter:m,signal:d}));w(i,I.visualVariable,b),w(i,p?.visualVariables,g),w(i,f?.minSize,T),i.authoringInfo=I.authoringInfo.clone();const S=i.authoringInfo?.visualVariables;return S?.forEach((e=>C(e,l,s,x))),{renderer:i}}export{Re as createAgeRenderer,Oe as createClassBreaksRenderer,je as createContinuousRenderer,Fe as createPCContinuousRenderer,Ce as createPCTrueColorRenderer,Ve as createVisualVariable,qe as regenerateAgeRenderer,ke as regenerateClassBreaksRenderer,Be as regenerateContinuousRenderer,Ie as regenerateVisualVariable};
