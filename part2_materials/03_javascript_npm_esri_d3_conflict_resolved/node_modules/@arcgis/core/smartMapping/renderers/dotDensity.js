/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as r}from"../../core/colorUtils.js";import t from"../../core/Error.js";import{getResolutionForScale as i}from"../../geometry/support/scaleUtils.js";import a from"../../renderers/support/AuthoringInfo.js";import n from"../heuristics/outline.js";import{roundValue as s}from"./support/dotDensityUtils.js";import{spliceVisualVariables as l,findOutlineVVIndex as o,processRegenerateParams as u,getRendererToUpdate as d,getStyleType as m,hasOutlineVV as p}from"./support/regenerateUtils.js";import{errorCallback as c,getSymbolOutlineFromScheme as f,verifyBasicFieldValidity as y,getBasemapInfo as b}from"./support/utils.js";import g from"../statistics/spatialStatistics.js";import w from"../statistics/summaryStatisticsForAttributes.js";import v from"../statistics/support/attributeDensity.js";import{verifyBinningParams as h}from"../support/binningUtils.js";import{getFieldsList as S}from"../support/utils.js";import{LayerType as V,binningCapableLayerTypes as j,createLayerAdapter as E,getLayerTypeLabels as x}from"../support/adapters/support/layerUtils.js";import{cloneScheme as T,getSchemes as D}from"../symbology/dotDensity.js";const I=500;async function z(e){const r=e.view;if(!(e?.layer&&r&&e.attributes?.length))throw new t("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new t("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");e.forBinning&&h(e,"dot-density-renderer");const i={...e,view:r,layer:e.layer,attributes:e.attributes},a=[V.FeatureLayer,V.OGCFeatureLayer,V.GeoJSONLayer,V.WFSLayer],n=e.forBinning?j:a,s=E(i.layer,n,e.forBinning);if(!s)throw new t("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+x(n).join(", "));i.dotBlendingEnabled??=!0,i.dotValueOptimizationEnabled??=!0;const l=null!=i.signal?{signal:i.signal}:null;await Promise.all([r.when(),s.load(l)]);if("polygon"!==s.geometryType)throw new t("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");const o=[],u=i.attributes;for(const t of u){const e=await S({field:t.field,valueExpression:t.valueExpression});o.push(...e)}const d=y(s,o.filter(Boolean),"dot-density-renderer:invalid-parameters");if(d)throw d;return{...i,layer:s}}async function O(e){const r="regenerate-dot-density-renderer";await u(e,r);const i=await d(e);if("dot-density"!==m(i))throw new t(`${r}:invalid-parameters`,"Renderer is invalid");const{layer:a,forBinning:n,filter:s,view:l,signal:o}=e,c=p(i),f=i.attributes.map((e=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle}))),y=await z({layer:a,attributes:f,dotValueOptimizationEnabled:null!=i.referenceScale,outlineOptimizationEnabled:c,forBinning:n,filter:s,view:l,signal:o});return{...e,creatorParameters:y,renderer:i}}async function R(e){let r=e.dotDensityScheme,t=null,i=null;const a=await b(e.basemap,e.view);if(t=null!=a.basemapId?a.basemapId:null,i=null!=a.basemapTheme?a.basemapTheme:null,r)return{scheme:T(r),basemapId:t,basemapTheme:i};const n=D({numColors:e.attributes.length,basemapTheme:i});return n&&(r=n.primaryScheme,t=n.basemapId,i=n.basemapTheme),{scheme:r,basemapId:t,basemapTheme:i}}function B(e){return{dotValue:1,referenceScale:e.scale,minSliderValue:1,maxSliderValue:100}}async function U(e){const{view:r,layer:t,attributes:a,signal:n,filter:l}=e,o=await t.getSampleFeatures({view:r,sampleSize:I,returnGeometry:!0,filter:l,signal:n},"json"),[u,d]=await Promise.all([g({features:o,geometryType:t.geometryType}),w({layer:t,attributes:a,filter:l,includeZeros:!1,includeNegatives:!1,view:r,signal:n})]),m=null!=u&&"avgSize"in u&&u.avgSize,p=d.avg;if(!m||!p)return B(r);const c=i(r.scale,r.spatialReference);return{dotValue:s(p/(m*m/(c*c)*.1))||1,referenceScale:r.scale,minSliderValue:1,maxSliderValue:s(p)}}async function F(e){const{view:r,layer:t,attributes:a,signal:n,filter:l}=e,o=[];for(const i of a){const e=await S({field:i.field,valueExpression:i.valueExpression});o.push(...e)}const u=await t.getSampleFeatures({view:r,sampleSize:I,requiredFields:o,filter:l,returnGeometry:!0,signal:n},"json"),{minDensity:d,maxDensity:m,avgDensity:p}=await v({features:u,attributes:a,includeZeros:!1,includeNegatives:!1,view:r});if(!p||!d||!m)return B(r);const c=i(r.scale,r.spatialReference),f=c*c,y=s(d*f),b=s(m*f);let g=s(p*f*10)||1;return g>b&&(g=b),{dotValue:g,referenceScale:r.scale,minSliderValue:y,maxSliderValue:b}}async function P(i){const s=await z(i),l=s.layer,o=l.geometryType,u=await R(s),d=u?.scheme;if(!d)throw new t("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const m=s.view,p=s.filter,y={layer:l,view:m,filter:p,attributes:s.attributes,signal:s.signal},b={layer:s.layer,view:m,filter:p,signal:s.signal},[g,w]=await Promise.all([s.trueDensity?F(y):U(y),s.outlineOptimizationEnabled?n(b).catch(c):null]),{dotValue:v,referenceScale:h,minSliderValue:S,maxSliderValue:V}=g,j=r(d.colors,s.attributes.length),E=s.attributes.map(((e,r)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:j[r]}))),x=new e({attributes:E,dotBlendingEnabled:s.dotBlendingEnabled,outline:w?f(d,o,w.opacity):null,dotValue:v,referenceScale:s.dotValueOptimizationEnabled?h:null,legendOptions:s.legendOptions});return w?.visualVariables.length&&(x.visualVariables=w.visualVariables.map((e=>e.clone()))),x.authoringInfo=new a({type:"dot-density",minSliderValue:S,maxSliderValue:V}),{renderer:x,dotDensityScheme:d,basemapId:u.basemapId,basemapTheme:u.basemapTheme}}async function L(e){const{creatorParameters:r,renderer:t}=await O(e),{layer:i,attributes:a,outlineOptimizationEnabled:s,view:u,signal:d,filter:m}=r,p={layer:i,view:u,filter:m,attributes:a,signal:d},[f,y]=await Promise.all([r.trueDensity?F(p):U(p),s?n({layer:i,view:u,signal:d,filter:m}).catch(c):null]),{dotValue:b,referenceScale:g,minSliderValue:w,maxSliderValue:v}=f;return t.dotValue=b,t.referenceScale=r.dotValueOptimizationEnabled?g:null,t.authoringInfo&&(t.authoringInfo.minSliderValue=w,t.authoringInfo.maxSliderValue=v),l(t,y?.visualVariables,o),{renderer:t}}export{P as createRenderer,L as regenerateRenderer};
