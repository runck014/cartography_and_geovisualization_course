/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/PieChartRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import"../../core/Logger.js";import{createUniqueColors as i}from"../../core/colorUtils.js";import r from"../../core/Error.js";import{toPt as a}from"../../core/screenUtils.js";import{ensureClass as n}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as s}from"../../intl/messages.js";import l from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as m}from"../../renderers/support/utils.js";import u from"../../renderers/visualVariables/SizeVariable.js";import{castSizeFromStringOrNumber as d}from"../../renderers/visualVariables/support/castSizeVariable.js";import p from"../../renderers/visualVariables/support/SizeVariableLegendOptions.js";import{TransformationType as c}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import f from"../heuristics/ageUnit.js";import y from"../heuristics/outline.js";import v from"../heuristics/referenceSize.js";import z from"../heuristics/sizeRange.js";import{getReferenceSizeStops as w,createPrimitiveOverrides as b,updateReferenceSizeSymbol as h,createReferenceSizeSymbol as g}from"./support/referenceSizeUtils.js";import{isSizeVV as S,getAuthoringInfoVisualVariable as x,spliceVisualVariables as E,findSizeVVIndex as T,findOutlineVVIndex as V,updateAuthoringInfoVisualVariable as I,processRegenerateParams as O,getRendererToUpdate as j,getStyleType as k,hasScaleDependentSizeVV as B,hasOutlineVV as F}from"./support/regenerateUtils.js";import{getSummaryStatistics as R,errorCallback as q,getClassBreaks as D,getTitleAndExpressionForAgeRenderer as U,updateAgeRendererAuthoringInfoVV as G,verifyBasicFieldValidity as P,getDataRange as M,getSizeRangeForAxis as C,createSymbol as $,getSymbolOutlineFromScheme as A,getSymbolSizeFromScheme as L,getBasemapInfo as W}from"./support/utils.js";import{verifyDates as H,supportedAgeUnits as J}from"../statistics/support/ageUtils.js";import{verifyBinningParams as K}from"../support/binningUtils.js";import{getFieldsList as N,getNormalizationType as Q,isAnyDateField as X}from"../support/utils.js";import{binningCapableLayerTypes as Y,featureCapableLayerTypes as Z,createLayerAdapter as _,getLayerTypeLabels as ee}from"../support/adapters/support/layerUtils.js";import{cloneScheme as ie,getSchemes as re}from"../symbology/size.js";import{getColorFromSymbol as ae}from"../../symbols/support/utils.js";const ne=2**53-1;async function se(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new r("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new r("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&K(e,"size-visual-variable");const i={...e},a=e.forBinning?Y:Z,n=_(i.layer,a,e.forBinning);if(!n)throw new r("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+ee(a).join(", "));"height"===i.axis&&(i.sizeOptimizationEnabled=!1);const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new r("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(i.worldScale){if("polyline"===l||"polygon"===l)throw new r("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!i.view||"3d"!==i.view.type)throw new r("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new r("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");const t=await N({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),o=P(n,t,"size-visual-variable:invalid-parameters");if(o)throw o;return await te(i),{...i,layer:n}}async function le(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new r("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new r("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"size-continuous-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0;const a=e.forBinning?Y:Z,n=_(i.layer,a,e.forBinning);if(!n)throw new r("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(a).join(", "));const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="reference-size"!==i.theme&&"polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new r("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new r("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new r("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===i.theme&&!e.forBinning&&"polygon"!==l)throw new r("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");const o=await N({field:i.field,normalizationField:i.normalizationField,valueExpression:i.valueExpression}),m=P(n,o,"size-continuous-renderer:invalid-parameters");if(m)throw m;return await te(i),{...i,layer:n}}async function te(e){const i=e.layer;if(("polygon"===i.geometryType||e.forBinning)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await v({layer:i,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function oe(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new r("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:i,forBinning:a}=e,n=e.forBinning?Y:Z,s=_(e.layer,n,e.forBinning);if(!s)throw new r("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+ee(n).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new r("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new r("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some((e=>"reference-size"===e.theme)))throw new r("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const m=e.isGrid??(await v({view:i,layer:l,forBinning:a}))?.isGrid;return{...e,isGrid:m,renderer:t,layer:s}}async function me(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new r("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new r("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"size-class-breaks-renderer");const i={...e};i.symbolType=i.symbolType||"2d",i.defaultSymbolEnabled??=!0,i.classificationMethod??="equal-interval",i.normalizationType=Q(i);const a=e.forBinning?Y:Z,n=_(i.layer,a,e.forBinning);if(!n)throw new r("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ee(a).join(", "));if(!(null!=i.minValue&&null!=i.maxValue)&&(null!=i.minValue||null!=i.maxValue))throw new r("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=i.signal?{signal:i.signal}:null;await n.load(s);const l=n.geometryType,t=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===l&&i.outlineOptimizationEnabled,"mesh"===l)throw new r("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new r("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new r("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await N({field:i.field,normalizationField:i.normalizationField}),m=P(n,o,"size-class-breaks-renderer:invalid-parameters");if(m)throw m;return{...i,layer:n}}function ue(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const r=i;return r.analyzeData=!(null!=i.minValue&&null!=i.maxValue),r}function de(e){const i={...e},r=!!i.symbolType?.includes("3d-volumetric"),a=i;return a.worldScale=r,r&&(a.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,a}async function pe(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new r("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const i={...e};i.symbolType??="2d",i.defaultSymbolEnabled??=!0;const a=_(i.layer,Z);if(!a)throw new r("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+ee(Z).join(", "));const n=null!=i.signal?{signal:i.signal}:null;await a.load(n);const s=a.geometryType,l=i.symbolType.includes("3d");if(i.outlineOptimizationEnabled="polygon"===s&&i.outlineOptimizationEnabled,"mesh"===s)throw new r("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new r("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(i.symbolType.includes("3d-volumetric")&&(!i.view||"3d"!==i.view.type))throw new r("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=H(a,i.startTime,i.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(i.unit&&!J.includes(i.unit))throw new r("size-age-renderer:invalid-unit",`Supported units are: ${J.join(", ")}`);return{...i,layer:a}}async function ce(e){const i="regenerate-size-visual-variables";O(e,i);const a=await j(e),n=k(a);if(!n||!["size-continuous","univariate-color-size","color-size","relationship-size","type-size"].includes(n))throw new r(`${i}:invalid-parameters`,"Renderer is invalid");const s=x(a,"size");if(!s)throw new r(`${i}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const l=s.theme,t="reference-size"===l,o=a.visualVariables?.find(S);if(!o&&!t)throw new r(`${i}:invalid-parameters`,"Renderer does not have a size visual variable");let m=s.field,u=s.normalizationField,d=null,p=null;m||(o?.field?(m=o.field,u=o.normalizationField):a.field?(m=a.field,u=a.normalizationField):(d=o?.valueExpression??a.valueExpression,p=o?.valueExpressionTitle??a.valueExpressionTitle));const{layer:c,forBinning:f,filter:y,view:v,signal:z}=e,w=B(a),b=await se({layer:c,field:m,valueExpression:d,valueExpressionTitle:p,normalizationField:u,theme:l,sizeOptimizationEnabled:w,forBinning:f,filter:y,view:v,signal:z});return{...e,creatorParameters:b,renderer:a}}async function fe(e){const i="regenerate-size-continuous-renderer";O(e,i);const a=await j(e),n=k(a);if(!n||!["size-continuous","univariate-color-size"].includes(n))throw new r(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:s,field:l,normalizationField:t,valueExpression:o,valueExpressionTitle:m}=a,u=s?.visualVariables.find((e=>"size"===e.type)),d=u.theme,{layer:p,forBinning:c,filter:f,view:y,signal:v}=e,z=F(a),w=B(a),b=await le({layer:p,field:l,valueExpression:o,valueExpressionTitle:m,normalizationField:t,theme:d,outlineOptimizationEnabled:z,sizeOptimizationEnabled:w,forBinning:c,filter:f,view:y,signal:v});return{...e,creatorParameters:b,renderer:a}}async function ye(e){const i="regenerate-size-class-breaks-renderer";await O(e,i);const a=await j(e);if("size-class-breaks"!==k(a))throw new r(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:m,valueExpressionTitle:u}=a,{classificationMethod:d,standardDeviationInterval:p}=n,c=a.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:z,signal:w}=e,b=F(a),h=await me({layer:f,field:s,valueExpression:m,valueExpressionTitle:u,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:d,standardDeviationInterval:p,numClasses:c,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:z,signal:w});return{...e,creatorParameters:h,renderer:a}}async function ve(e){const i="regenerate-size-age-renderer";await O(e,i);const a=await j(e);if("size-age"!==k(a))throw new r(`${i}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n}=a,s=n?.visualVariables.find((e=>"size"===e.type)),l=s.startTime,t=s.endTime,o=s.units,m=s.theme,{layer:u,filter:d,view:p,signal:c}=e,f=F(a),y=B(a),v=await pe({layer:u,startTime:l,endTime:t,unit:o,theme:m,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:d,view:p,signal:c});return{...e,creatorParameters:v,renderer:a}}async function ze(e){let i=e.sizeScheme,r=null,a=null;const n=await W(e.basemap,e.view);if(r=null!=n.basemapId?n.basemapId:null,a=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:ie(i),basemapId:r,basemapTheme:a};const s=re({basemapTheme:a,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,r=s.basemapId,a=s.basemapTheme),{scheme:i,basemapId:r,basemapTheme:a}}function we(e,i){switch(i){case"point":case"multipoint":{const i=e;return[d(i.minSize),d(i.maxSize)]}case"polyline":{const i=e;return[d(i.minWidth),d(i.maxWidth)]}case"polygon":{const i=e;return[d(i.marker.minSize),d(i.marker.maxSize)]}}}function be(e,i){e.transformationType===c.ClampedLinear&&"below"===i&&e.flipSizes()}async function he(e,i,r,a,n){return"reference-size"===r&&i?[1,i.size]:e?[e.minSize,e.maxSize]:we(a,n)}function ge(e,i,r){return"reference-size"===r&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function Se(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,r=0,a=0,n=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,m=0!==s?o/s:0,u=l>a&&l<n&&t<2*n&&m<.5,d=l>r&&l<i&&t<2*i&&m<.5;return{minDataValue:u?a:d?r:l,maxDataValue:u?n:d?i:s+2*o,defaultValuesUsed:!1}}const{theme:r,field:a}=i,n=i.layer,s=a&&!("function"==typeof a)?n.getField(a):null,l=X(s);return M(e,r,l,"above"===r||"below"===r)}async function xe(e,i,a,s){const{theme:m,field:d,normalizationField:c,minValue:f,maxValue:y,axis:v}=e,z=e.layer.geometryType,b=await ze({basemap:e.basemap,geometryType:z,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=b.scheme;if(!h)throw new r("size-visual-variable:insufficient-info","Unable to find size scheme");const g=await he(a,s,m,h,z),{minDataValue:S,maxDataValue:x,defaultValuesUsed:E}=Se(i,e),T=[],V="height"===v,I=V?v:void 0,O=g[0];let j=g[1];if(V&&"number"==typeof O&&"number"==typeof j){const e=C({minSize:O,maxSize:j},I);T.push(new u({axis:"width-and-depth",minSize:e.minSize})),j=e.maxSize}const k=new u({field:d??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:c,axis:I,minSize:O,maxSize:j,minDataValue:S,maxDataValue:x,legendOptions:n(p,e.legendOptions)});be(k,m),T.unshift(k);const B=new o("reference-size"===m?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:w(k).map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),theme:m,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=f?f:i.min,maxSliderValue:null!=y?y:i.max}:{type:"size",theme:m,minSliderValue:null!=f?f:i.min,maxSliderValue:null!=y?y:i.max}),F=new l({visualVariables:[B]});return{basemapId:b.basemapId,basemapTheme:b.basemapTheme,visualVariables:T,statistics:i,isGrid:s?.isGrid,defaultValuesUsed:E,sizeScheme:ie(h),authoringInfo:F}}async function Ee(i,r,a,n,l){const t=await s("esri/smartMapping/t9n/smartMapping"),o=l.layer,m=l.field,u=o.geometryType,d=l.defaultSymbolEnabled,p=ie(i.sizeScheme),c="polygon"===u,f=c?p.marker:p,y=c?p.background:null,v=c?"point":u,z=r?.opacity,h=i.isGrid,S="reference-size"===l.theme,x=S?[]:i.visualVariables.map((e=>e.clone()));r?.visualVariables?.length&&x.push(...r.visualVariables.map((e=>e.clone())));const E=S?b({view:l.view,field:m,normalizationField:n,sizeStops:w(i.visualVariables[0]),sizeByScaleEnabled:h||!!l.sizeOptimizationEnabled}):null;return{renderer:new e({backgroundFillSymbol:!h&&y?$(u,{type:l.symbolType,color:y.color,outline:A(y,u,z)}):null,classBreakInfos:[{minValue:-ne,maxValue:ne,symbol:E?g({type:l.referenceSizeOptions?.symbolStyle||"circle",color:f.color,primitiveOverrides:E}):$(v,{type:l.symbolType,color:f.color,size:L(f,v),outline:A(f,v,z)})}],defaultLabel:d?t.other:null,defaultSymbol:d&&!S?$(v,{type:l.symbolType,color:f.noDataColor,size:L(f,v,!0),outline:A(f,v,z)}):null,field:m,normalizationField:n,normalizationType:a,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:x,authoringInfo:i.authoringInfo?.clone()}),visualVariables:i.visualVariables.map((e=>e.clone())),statistics:i.statistics,defaultValuesUsed:i.defaultValuesUsed,isGrid:h,sizeScheme:ie(i.sizeScheme),basemapId:i.basemapId,basemapTheme:i.basemapTheme}}function Te(e,i){const r=a(e.minSize),n=(a(e.maxSize)-r)/(i>=4?i-1:i),s=[];for(let a=0;a<i;a++)s.push(r+n*a);return s}async function Ve(i,r){const a=await s("esri/smartMapping/t9n/smartMapping"),n=i.layer,t=i.defaultSymbolEnabled,o=n.geometryType,u="polygon"===o,d=i.symbolType?.includes("3d-volumetric"),p=await ze({basemap:i.basemap,geometryType:o,sizeScheme:i.sizeScheme,worldScale:d,view:i.view}),c=p.scheme,{result:f,outlineResult:y}=r,v=f?.classBreakInfos??[],z=i.classificationMethod,w=i.normalizationType,b=u?c.marker:c,h=u?c.background:null,g=u?"point":o,S=we(b,g),x=d?C({minSize:S[0],maxSize:S[1]},"height"):null,E=Te({minSize:S[0],maxSize:x?x.maxSize:S[1]},v.length),T=y?.opacity,V=new e({backgroundFillSymbol:h&&$(o,{type:i.symbolType,color:h.color,outline:A(h,o,T)}),classBreakInfos:v.map(((e,r)=>({minValue:e.minValue,maxValue:e.maxValue,symbol:$(g,{type:i.symbolType,color:b.color,size:E[r],widthAndDepth:x?.minSize,outline:A(b,g,T)}),label:e.label}))),defaultLabel:t?a.other:null,defaultSymbol:t?$(g,{type:i.symbolType,color:b.noDataColor,size:L(b,g,!0),widthAndDepth:x?.minSize,outline:A(b,g,T)}):null,field:i.field,valueExpression:i.valueExpression,valueExpressionTitle:i.valueExpressionTitle,normalizationType:w,normalizationField:i.normalizationField,normalizationTotal:"percent-of-total"===w?f?.normalizationTotal:void 0,legendOptions:i.legendOptions,authoringInfo:new l({type:"class-breaks-size",classificationMethod:z,standardDeviationInterval:i.standardDeviationInterval})});return"standard-deviation"!==z&&m({classBreakInfos:V.classBreakInfos,classificationMethod:z,normalizationType:w,round:!0}),y?.visualVariables?.length&&(V.visualVariables=y.visualVariables.map((e=>e.clone()))),{renderer:V,sizeScheme:ie(c),classBreaksResult:f,defaultValuesUsed:!!r.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function Ie(e){const i=await se(e),{view:r,field:a,valueExpression:n,minValue:s,maxValue:l,layer:t,normalizationField:o,signal:m,statistics:u,filter:d}=i,p=o?"field":void 0,[c,f]=await Promise.all([u??R({layer:t,field:a,valueExpression:n,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:p,normalizationField:o,filter:d,minValue:s,maxValue:l,view:r,signal:m}),i.sizeOptimizationEnabled?z({view:r,layer:t,signal:m,filter:d}).catch(q):null]);return xe(i,c,f,i.referenceSizeResult)}async function Oe(e){const{view:i,filter:r,renderer:a,signal:n,creatorParameters:s}=await ce(e),{field:l,normalizationField:o,valueExpression:m,theme:d,layer:p,sizeOptimizationEnabled:c,referenceSizeResult:f,valueExpressionTitle:y}=s,v=o?"field":void 0,[b,h]=await Promise.all([R({layer:p,field:l,valueExpression:m,normalizationField:o,normalizationType:v,filter:r,view:i,signal:n}),c?z({view:i,layer:p,signal:n,filter:r}).catch(q):null]),g=ge(h,f,d),{minDataValue:E,maxDataValue:T}=Se(b,{theme:d,layer:p,field:l}),V=a.visualVariables?.find(S),I=(V?.stops?null:V)??new u({field:l??void 0,valueExpression:m,valueExpressionTitle:y,valueUnit:"unknown",normalizationField:o});g&&(I.minSize=g[0],I.maxSize=g[1]),I.minDataValue=E,I.maxDataValue=T,be(I,d);const O=x(a,"size");return O.minSliderValue=b.min,O.maxSliderValue=b.max,"reference-size"===d&&(O.sizeStops=w(I).map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),O.referenceSizeScale=f?.isGrid||c?i?.scale:void 0),{visualVariables:"reference-size"===d?[]:[I],isGrid:!!f?.isGrid,authoringInfo:a.authoringInfo?.clone(),statistics:b}}async function je(e){const i=await le(e),r={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[a,n]=await Promise.all([Ie(de(i)),i.outlineOptimizationEnabled?y(r).catch(q):null]),s=i.normalizationField;return Ee(a,n,s?"field":void 0,s,i)}async function ke(e){const{renderer:i,view:r,signal:a,filter:n,creatorParameters:s,forBinning:l}=await fe(e),{layer:t,outlineOptimizationEnabled:o,theme:m,referenceSizeResult:u}=s,[d,p]=await Promise.all([Oe({...e,referenceSizeResult:u}),o?y({layer:t,view:r,filter:n,signal:a}).catch(q):null]),c=d.isGrid,f="reference-size"===m;E(i,d.visualVariables,T),E(i,p?.visualVariables,V),I(i,d.authoringInfo,"size");const v=d.statistics;if(!f)return{renderer:i,statistics:v};return{renderer:await Be({layer:t,renderer:i,view:r,forBinning:l,sizeStops:x(i,"size","reference-size")?.sizeStops,isGrid:c}),isGrid:c,statistics:v}}async function Be(e){const{layer:a,referenceSizeOptions:n,renderer:s,sizeScheme:o,sizeStops:m,typeScheme:u,view:d,isGrid:p}=await oe(e),c=s.clone();c.authoringInfo??=new l;const f=c.authoringInfo.visualVariables.find((e=>"reference-size"===e.theme)),y=e.field??f?.field,v=e.normalizationField??f?.normalizationField;if(!y)throw new r("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const z=b({view:d,field:y,normalizationField:v,sizeStops:m,sizeByScaleEnabled:p||!!e.sizeOptimizationEnabled}),w=n?.symbolStyle||f?.referenceSizeSymbolStyle||"circle";if("class-breaks"===c.type){const e="polygon"===("geometryType"in a?a.geometryType:null)&&o&&"marker"in o?o.marker:null;c.classBreakInfos.forEach((i=>{const r=e?.color??ae(i.symbol,1);"cim"===i.symbol.type?h(i.symbol,{type:w,color:r,primitiveOverrides:z}):r&&(i.symbol=g({type:w,color:r,primitiveOverrides:z}))}))}else if("unique-value"===c.type){const e=c.uniqueValueGroups,r="polygon"===("geometryType"in a?a.geometryType:null)&&u&&"colors"in u?u.colors:null,n=r?i(r,c.uniqueValueInfos?.length??0):null;let s=0;if(e){for(const i of e)for(const e of i.classes??[]){const i=n?n[s]:ae(e.symbol,1);"cim"===e.symbol?.type?h(e.symbol,{type:w,color:i,primitiveOverrides:z}):i&&(e.symbol=g({type:w,color:i,primitiveOverrides:z})),s++}c.uniqueValueGroups=e}}return f&&(f.field=y,f.normalizationField=v,f.sizeStops=m.map((({label:e,size:i,value:r})=>new t({label:e,size:i,value:r}))),f.referenceSizeScale=p||e.sizeOptimizationEnabled?d.scale:void 0,f.referenceSizeSymbolStyle=w),c}async function Fe(e){const i=await me(e);return Ve(i,await D(ue(i),i.outlineOptimizationEnabled))}async function Re(e){const{renderer:i,creatorParameters:a}=await ye(e),{outlineOptimizationEnabled:n,normalizationType:s,classificationMethod:l}=a,{result:t,outlineResult:o}=await D(ue(a),n),u=t.classBreakInfos;if(a.numClasses!==u.length)throw new r("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return i.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),i.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&m({classBreakInfos:i.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),E(i,o?.visualVariables,V),{renderer:i}}async function qe(e){const i=await pe(e),{defaultSymbolEnabled:r,view:a,startTime:n,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:m,filter:u,layer:d}=i,[p,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await f({view:a,layer:d,startTime:n,endTime:s,minValue:t,maxValue:o,signal:m,filter:u}),i.outlineOptimizationEnabled?y({layer:d,view:a,filter:u,signal:m}).catch(q):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await U(i,v),h=await Ie(de({layer:d,basemap:i.basemap,valueExpression:w,symbolType:l,statistics:z,legendOptions:{title:b},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:u,signal:m})),g={layer:d,valueExpression:w,defaultSymbolEnabled:r,symbolType:l},S=await Ee(h,c,null,null,g),x=S.renderer.authoringInfo?.visualVariables;return x?.forEach((e=>G(e,n,s,v))),{...S,unit:v}}async function De(e){const{renderer:i,creatorParameters:r}=await ve(e),{layer:a,outlineOptimizationEnabled:n,sizeOptimizationEnabled:s,startTime:l,endTime:t,theme:o,view:m,signal:u,filter:d}=r,[p,c]=await Promise.all([f({view:m,layer:a,startTime:l,endTime:t,signal:u,filter:d}),n?y({layer:a,view:m,filter:d,signal:u}).catch(q):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await U(r,v),h=await Ie(de({layer:a,valueExpression:w,statistics:z,legendOptions:{title:b},sizeOptimizationEnabled:s,theme:o,view:m,filter:d,signal:u}));E(i,h.visualVariables,T),E(i,c?.visualVariables,V),i.authoringInfo=h.authoringInfo.clone();const g=i.authoringInfo?.visualVariables;return g?.forEach((e=>G(e,l,t,v))),{renderer:i}}export{qe as createAgeRenderer,Fe as createClassBreaksRenderer,je as createContinuousRenderer,Ie as createVisualVariables,De as regenerateAgeRenderer,Re as regenerateClassBreaksRenderer,ke as regenerateContinuousRenderer,Oe as regenerateVisualVariables,Be as updateRendererWithReferenceSize};
