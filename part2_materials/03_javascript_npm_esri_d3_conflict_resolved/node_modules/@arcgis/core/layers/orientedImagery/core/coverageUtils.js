/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import"../../../geometry.js";import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{create as t}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{transpose as n}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{a as o,g as a}from"../../../chunks/vec32.js";import i from"../../../geometry/Circle.js";import c from"../../../geometry/Mesh.js";import{projectWithZConversion as s}from"../../../geometry/projection.js";import{earth as f}from"../../../geometry/support/Ellipsoid.js";import l from"../../../geometry/support/MeshComponent.js";import{MeshVertexAttributes as m}from"../../../geometry/support/MeshVertexAttributes.js";import{intersectRay as u,create as h,fromArray as p}from"../../../geometry/support/plane.js";import{isWebMercator as y}from"../../../geometry/support/spatialReferenceUtils.js";import{getWebMercatorScalingFactor as g,createRotationMatrixFromHPR as x,transformMat3 as d,scaleAndAddWithFactor as w,scaleWithFactor as M,computeHFOVAndVFOV as R,projectiveTransform as j}from"../transformations/utils.js";import v from"../../../geometry/Polygon.js";import P from"../../../geometry/SpatialReference.js";import D from"../../../geometry/Multipoint.js";const b=Math.PI/180;function A(e){return e.isSpherical?H(e):I(e)}function I(e){const{horizontalFieldOfView:t,verticalFieldOfView:r,geometry:n,cameraHeading:o}=e,a=g(n.y,n.spatialReference);let i=e.cameraPitch,c=e.cameraRoll??0,s=150;t>150&&(i=90,c=0,s=5);const f=Math.ceil(t/s),l=z(f,o,t);let m=e.farDistance?e.farDistance*a:e.cameraHeight*a/Math.cos(i*b);e.cameraPitch+r/2>=90&&(m=(e.farDistance||20)*a);const u=new v({spatialReference:n?.spatialReference});u.imageID=e.objectId;let h=null;for(const p of l)h=V(p,i,e.cameraHeight,n,m,a,r,t,f,u,c,e.nearDistance);return h.imageID=e.objectId,{polygon:u,frustum:h}}function z(e,t,r){const n=[];if(e%2==0)for(let o=0;o<e/2;o++)n.push(t-r/e*(o+.5),t+r/e*(o+.5));else{n.push(t);for(let o=1;o<e/2;o++)n.push(t-r/e*o,t+r/e*o)}return n.sort(),n}function V(e,i,c,s,f,l,m,u,h,p,y=0,g=0){const R=n(t(),x([e,i,y??0])),j=q({cameraHeight:c,cameraPitch:i,farDistance:f,location:s,horizontalFieldOfView:u,nearDistance:g,verticalFieldOfView:m},R),v=d([0,0,-1],R),{x:P,y:D}=s,A=w([P,D,c],v,f,l),I=2*Math.tan(m*b/2)*f,z=2*Math.tan(u/h*b/2)*f,V=d([0,1,0],R),H=d([1,0,0],R),O=M(V,I/2,l),S=M(H,z/2,l),C=o(r(),O,S),U=a(r(),O,S),E=F([a(r(),A,C),a(r(),A,U),o(r(),A,C),o(r(),A,U)],c,s,l);return E.push(E[0]),p.addRing(E),j}function F(e,t,r,n){return e.map((e=>C(e,t,r,n)))}function H(e){const{geometry:t,farDistance:r,objectId:n,nearDistance:o,cameraHeight:a}=e,s=g(t.y,t.spatialReference),f=new i({center:t.clone(),radius:r*s});if(f.imageID=n,o){const e=new i({center:t.clone(),radius:o*s});f.addRing(e.rings[0])}const l=t.clone();l.z=a-r*s;const m=c.createSphere(l,{size:2*r*s});return m.imageID=n,{polygon:f,frustum:m}}function O(e,t){return e.contains(t)}function S(e,t){return Math.sign(e)!==Math.sign(t)}function q(e,t,n){const{cameraHeight:i,cameraPitch:s,farDistance:f,location:l,horizontalFieldOfView:u,nearDistance:h,verticalFieldOfView:p}=e,y=E(l),g=s+p/2>=90==!1,x=2*Math.tan(p*b/2)*h,R=2*Math.tan(u*b/2)*h,j=2*Math.tan(p*b/2)*f,v=2*Math.tan(u*b/2)*f;let P,D;D=[0,0,-1],D=d(D,t),P=w([l.x,l.y,i],D,f,y),g&&(P[2]=0);const A=w([l.x,l.y,i],D,h,y);let I=[0,1,0];I=d(I,t);let z=[1,0,0];z=d(z,t);let V=[],F=[];h?(F=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],V=V.concat(a(r(),A,o(r(),M(I,x/2,y),M(z,R/2,y)))),V=V.concat(a(r(),A,a(r(),M(I,x/2,y),M(z,R/2,y)))),V=V.concat(o(r(),A,o(r(),M(I,x/2,y),M(z,R/2,y)))),V=V.concat(o(r(),A,a(r(),M(I,x/2,y),M(z,R/2,y))))):(V=[l.x,l.y,i],F=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),V=V.concat(a(r(),P,o(r(),M(I,j/2,y),M(z,v/2,y)))),V=V.concat(a(r(),P,a(r(),M(I,j/2,y),M(z,v/2,y)))),V=V.concat(o(r(),P,o(r(),M(I,j/2,y),M(z,v/2,y)))),V=V.concat(o(r(),P,a(r(),M(I,j/2,y),M(z,v/2,y))));const H=new m({position:Float64Array.from(V)});return new c({vertexAttributes:H,components:F,spatialReference:l.spatialReference})}function C(e,t,n,a){{const i=Math.sqrt((e[2]-t)**2+(Math.sqrt((e[0]-n.x)**2+(e[1]-n.y)**2)/a)**2)*a,c=M(o(r(),[e[0],e[1],e[2]],[n.x,n.y,t]),1/i,1/a),s=t/(t-e[2]),f={x:(1-s)*n.x+s*e[0],y:(1-s)*n.y+s*e[1],z:(1-s)*t+s*e[2]},l=Math.sqrt((f.z-t)**2+(Math.sqrt((f.x-n.x)**2+(f.y-n.y)**2)/a)**2)*a,m=M(o(r(),[f.x,f.y,f.z],[n.x,n.y,t]),1/l,1/a);return S(c[0],m[0])&&S(c[1],m[1])&&S(c[2],m[2])||e[2]>=0?[e[0],e[1],0]:[f.x,f.y,f.z]}}function U(e){const{spatialReference:t,x:r,y:n}=e.geometry,{cameraHeading:o,cameraPitch:a,farDistance:i,nearDistance:c}=e,s=E(e.geometry),f=new v({spatialReference:t}),l=Math.abs(1.44*i*s);let m=Math.abs(1.44*c*s);(a<20||null==o)&&(m=l);const u=[];return u[0]={x:r+l*Math.sin((o-45)*b),y:n+l*Math.cos((o-45)*b)},u[1]={x:r+l*Math.sin((o+45)*b),y:n+l*Math.cos((o+45)*b)},u[2]={x:r+m*Math.sin((o+135)*b),y:n+m*Math.cos((o+135)*b)},u[3]={x:r+m*Math.sin((o+225)*b),y:n+m*Math.cos((o+225)*b)},f.addRing([[u[0].x,u[0].y,0],[u[1].x,u[1].y,0],[u[2].x,u[2].y,0],[u[3].x,u[3].y,0],[u[0].x,u[0].y,0]]),f}function E(e){return e&&y(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/f.radius))):1}function k(e,t){const n=1+t/100;if("esri.geometry.Circle"===e.declaredClass){const{radius:t,center:r}=e,o=new i({radius:t*n,center:r});return e.rings.length>1&&o.addRing(e.rings[1]),o}if("esri.geometry.Polygon"===e.declaredClass){const t=new v({spatialReference:e.spatialReference}),a=e.centroid;if(a){const i=[];for(let t=0;t<e.rings[0].length;t++){const c=Math.sqrt((a.x-e.rings[0][t][0])**2+(a.y-e.rings[0][t][1])**2),s=M(o(r(),[e.rings[0][t][0],e.rings[0][t][1],0],[a.x,a.y,0]),1/c,1),f=w([a.x,a.y,0],s,c*n,1);i.push({x:f[0],y:f[1]})}t.addRing([[i[0].x,i[0].y,0],[i[1].x,i[1].y,0],[i[2].x,i[2].y,0],[i[3].x,i[3].y,0],[i[0].x,i[0].y,0]])}return t}return e}async function L(e,t,r){const{cameraHeight:n,cameraLocation:o,cameraPitch:a,frustumVertices:i,horizontalFieldOfView:c,imageHeight:s,imageWidth:f,inSRS:l,outSRS:m,verticalFieldOfView:u,cameraRoll:h,options:p}=r,y=new P(l),g=new P(m),x=R(c,u,h??0),d=i.length>15;return a+x.vfov/2>=90?await K(i,e,f,s,y,g,d,p):await W(i,e,t,o,n,d,y,g,p)}async function W(e,t,r,n,o,a,i,s,f){const l=B(e,t,r,n,o);if(!l)return;const{farPlane:u,nearPlane:h}=l,p=await N([...h?.vertexPositions??e.slice(0,3),...u.vertexPositions],i,s,f),y=Z(p);return new c({vertexAttributes:new m({position:p}),components:Y(a?T(y,!0):X(y,!0)),spatialReference:s})}function B(e,t,r,n,o){const a=Q(e),i=Q(e,"near");if(!a)return;const c=t.length;for(let s=0;s<c;s++){const e=Array.from(r[s]),t=[e[0]-n[0],e[1]-n[1],e[2]-(n[2]??o)];J(n,t,s,i),G(n,t,s,a)}return{farPlane:a,nearPlane:i}}function G(e,t,n,o){const{coefficients:a,vertexPositions:i}=o,c=r();u(a,{origin:e,direction:t},c)&&i.splice(3*n,3,...c)}function J(e,t,n,o){if(!o)return;const a=r();u(o.coefficients,{origin:e,direction:t},a)&&o.vertexPositions.splice(3*n,3,...a)}async function K(e,t,r,n,o,a,i,s){let f,l=i?new Array:[e[0],e[1],e[2]],u=new Array;for(const c of t)i?(f=j([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]]]),l=l.concat(...f),f=j([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[12],e[13],e[14]],[e[15],e[16],e[17]],[e[18],e[19],e[20]],[e[21],e[22],e[23]]]),u=u.concat(...f)):(f=j([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]],[e[12],e[13],e[14]]]),l=l.concat(...f));l=l.concat(u);const h=await N(l,o,a,s),p=Z(h);return new c({vertexAttributes:new m({position:h}),components:Y(i?T(p,!0):X(p,!0)),spatialReference:a})}async function N(t,r,n,o){if(r.equals(n))return t;const a=t.reduce(((e,t,r)=>{const n=Math.floor(r/3);return e[n]||(e[n]=new Array),e[n].push(t),e}),new Array),{points:i}=await s(new D(a,r),n,o);return e(o),i.flat()}function Q(e,t="far"){const r=h();let n;switch(t){case"far":if(n=Array.from(15===e.length?e.slice(3):e.slice(12)),p(r,n,!0))return{coefficients:r,vertexPositions:n};break;case"near":if(n=Array.from(e.slice(0,12)),15===e.length||!p(r,n,!0))return;return{coefficients:r,vertexPositions:n}}}const T=(e,t=!1)=>{if(t&&e-2<=4||e<=4||e%2!=0)throw new Error("Invalid number of vertices");const r=[],n=e/2,o=Math.round((t?e-2:e)/2);for(let a=0;a<o;a++){const o=a+n,i=t?o+1:o,c=i%e,s=(t?o:i+1)%e;r.push({faces:new Uint32Array([a,s,c,a,a+1,c])})}return r};function X(e,t=!1){if(e<3||t&&e-1<3)throw new Error("Invalid number of vertices");const r=[],n=t?e-2:e-1;for(let o=0;o<n;o++)r.push({faces:new Uint32Array([0,o+1,o+2])});return r}const Y=e=>e.map((e=>new l(e))),Z=e=>e.length/3;export{O as checkIfPolygonContainsSelectedPoint,U as computePolygonForInspection,A as createCoveragePolygon,F as limitZToGround,N as projectVertices,k as resizePolygon,L as updateFrustum};
