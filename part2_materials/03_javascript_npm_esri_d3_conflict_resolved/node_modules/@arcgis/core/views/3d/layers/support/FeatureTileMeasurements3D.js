/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{G as t,i,n as o,f as r,h as s,c as a,F as l,b as n}from"../../../../chunks/vec32.js";import{create as c,freeze as u,ZEROS as h}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{distance as d}from"../../../../geometry/support/aaBoundingRect.js";import{intersectsRay as f,intersectsPoint as m}from"../../../../geometry/support/frustum.js";import{fromValues as p}from"../../../../geometry/support/ray.js";import{ViewingMode as _}from"../../../ViewingMode.js";import{Visibility as S}from"./FeatureTileDescriptor.js";import{FeatureTileVisibility3D as b,globalTileLevelThreshold as M}from"./FeatureTileVisibility3D.js";import v from"../../webgl/RenderCamera.js";class g{constructor(e){this._camera=new v,this._focusOnMap=[0,0],this._renderCoordsHelper=e.renderCoordsHelper,this._tilingScheme=e.tilingScheme,this._visibility=new b(e.renderCoordsHelper,e.getIsGroundOpaque)}begin(e,t,i){this._camera.copyFrom(e),this._surfaceElevation=i,this._focusOnMap[0]=t.x,this._focusOnMap[1]=t.y,this._visibility.begin(this._camera)}end(){this._visibility.end()}updateTile(e){const{measures:t}=e;t.visibility=this._visibility.calculate(e),t.distance=d(e.extent,this._focusOnMap),t.visibility!==S.INVISIBLE&&this._updateSplitDecisionAndLod(e)}_calculateTileShouldSplitGlobal(e){const l=this._camera,{eye:n}=l,c=t(n),u=this._renderCoordsHelper,h=u.referenceEllipsoid.radius;if(c>2*h)return e.measures.effectiveLevelForLod=0,!1;const d=e.lij[0];if(d<=M)return e.measures.effectiveLevelForLod=d,!0;const f=y,{extent:m}=e,{_surfaceElevation:p}=this;i(f[0],m[0],m[1],p),i(f[1],m[2],m[1],p),i(f[2],m[2],m[3],p),i(f[3],m[0],m[3],p);const _=i(C,.5*(m[0]+m[2]),.5*(m[1]+m[3]),p),S=this._tilingScheme.spatialReference;for(let t=0;t<4;++t)u.toRenderCoords(f[t],S,f[t]);u.toRenderCoords(_,S,_);const b=o(j,_),v=r(n,b),g=s(L,b,v),T=t(n)-h;return a(F.origin,R),a(F.direction,b),this._calculateTileShouldSplitCommon(e,f,_,F,T,g)}_calculateTileShouldSplitLocal(e){const t=y,{extent:o}=e,{_surfaceElevation:r}=this;i(t[0],o[0],o[1],r),i(t[1],o[2],o[1],r),i(t[2],o[2],o[3],r),i(t[3],o[0],o[3],r);const s=this._tilingScheme.spatialReference;for(let i=0;i<4;++i)this._renderCoordsHelper.toRenderCoords(t[i],s,t[i]);const l=i(C,.5*(t[0][0]+t[2][0]),.5*(t[0][1]+t[2][1]),.25*(t[0][2]+t[1][2]+t[2][2]+t[3][2])),n=i(j,l[0],l[1],0),{eye:c,far:u}=this._camera,h=i(L,n[0],n[1],c[2]),d=c[2];i(F.origin,n[0],n[1],c[2]-2*u),a(F.direction,T);const f=c[2]-2*u;return this._calculateTileShouldSplitCommon(e,t,l,F,d,h,x,f)}_calculateTileShouldSplitCommon(t,i,o,s,a,u,h,d){const _=Math.max(l(i[0],i[2]),l(i[1],i[3]),l(i[0],o)+l(o,i[2])),S=this._camera,{eye:b,near:M,far:v,fovY:g,viewForward:y}=S,C=e(r(s.direction,y),.1,1),j=r(b,y),L=r(o,y)-j,T=2*Math.tan(.5*g),x=e=>e<=M?1:1/(e*T),R=Math.abs(a)/_,F=x(L),H=t.lij[0],E=l(b,o);let O=0,D=1/0;for(const e of i){const t=l(b,e);D=Math.min(D,t),O=Math.max(O,t)}const{perScreenPixelRatio:I}=S,V=e=>Math.max(0,H-2,H+Math.ceil(Math.log2(.002*e/I))),A=1,B=300*e(C,.1,1),k=.8,q=.7,N=l(u,b)>q*_,P=L<M,Q=e=>A*_/e,U=V(N?Q(E):P?B*_/Math.abs(a):k*F*_),Y=U+(D-M>.33*(v-M)?-1:0);if(t.measures.effectiveLevelForLod=Y,H+2<Y)return!0;if(H>=Y)return!1;const{frustum:z}=S,J=R<G;if(l(u,b)<M)return J;const K=f(z,s);if(N){const e=V(Q(D)),t=V(Q(O));if(Math.abs(e-t)>2||Math.abs(U-t)>2||Math.abs(U-e)>2)return!0}else{const e=l(b,o),t=.5*_/Math.SQRT2;if(H<=Y+3||e/t>.6)return!0}if(!this.isGlobalMode&&N&&h&&void 0!==d){let e=0;for(let t=0;t<4;++t){const o=h[t],r=d,s=c();n(s,i[t],o,r);const a=p(s,o);f(z,a)&&++e}if(e>=3||e>=2&&K)return!1;if(e<=2&&!K&&H<U+1)return!0}const W=m(z,o);let X=0;for(let e=0;e<4;++e){const t=i[e];X+=m(z,t)?1:0}if(W&&X>=2)return!1;if(!W&&!K&&X<=1&&H<Y)return J;let Z=L;for(let e=0;e<4;++e){const t=i[e],o=r(t,y)-j;Z=Math.min(Z,o)}if(Z<=M)return J;return!(x(Z)*_<.3)&&(H<Y&&F*_>w&&X<=2&&!W&&!K)}_updateSplitDecisionAndLod(e){e.measures.shouldSplit=this.isGlobalMode?this._calculateTileShouldSplitGlobal(e):this._calculateTileShouldSplitLocal(e),e.updateResolution()}get isGlobalMode(){return this._renderCoordsHelper.viewingMode===_.Global}}const y=[c(),c(),c(),c()],C=c(),j=c(),L=c(),T=u(0,0,1),x=[T,T,T,T],R=h,F=p(h,T),G=1,w=.9;export{g as FeatureTileMeasurements3D};
