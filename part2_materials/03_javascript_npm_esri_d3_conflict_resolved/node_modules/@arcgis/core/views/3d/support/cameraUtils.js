/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.31/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as i,asinClamped as o}from"../../../core/mathUtils.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{h as c,g as l,l as s,j as u,F as f,c as m}from"../../../chunks/vec32.js";import{clone as p,create as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../geometry/ellipsoidUtils.js";import y from"../../../geometry/Point.js";import{projectWithZConversion as g,project as v}from"../../../geometry/projection.js";import w from"../../../geometry/SpatialReference.js";import{projectPointToVector as R,projectPointToVectorAsync as T}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as x,projectVectorToPointAsync as S}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as M}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as j}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as C}from"../camera/intersectionUtils.js";import{c as z}from"../../../chunks/cameraUtilsPlanar.js";import{c as A}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as b}from"./earthUtils.js";import{getElevationAtPoint as U}from"./ElevationProvider.js";import{isSpatialReferenceSupported as L}from"../../support/spatialReferenceSupport.js";const D=()=>n.getLogger("esri.views.3d.support.cameraUtils"),P=39.37,H=96,O=H*P,E=1,G=8,F=5,I=1,J={heading:0,tilt:0},q=d(),k=new t(-20037508.342788905,20037508.342788905),V=new t(-180,180);var X;function K(e){return e.spatialReference??w.WGS84}function W({state:e}){return e.isGlobal?A:z}function Y(e,t,n,r,i){return W(e).headingTiltToDirectionUp(t,n,r,i)}function N(e,t){if(null==t)return null;const n=e.renderSpatialReference,i=W(e).headingTiltToDirectionUp,o=d();if(!R(t.position,o,n))return null;const a=i(o,t.heading,t.tilt);c(a.direction,a.direction,e.state.camera.distance),l(a.direction,a.direction,o);const s=C(e,o,a.direction,a.up);return s.fov=r(t.fov),s.row=t.layout.row,s.rows=t.layout.rows,s.column=t.layout.column,s.columns=t.layout.columns,s}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(X||(X={}));const Z=d();function B(t,n,r){const o=t.renderSpatialReference,a=ue(t,n.eye,n.viewForward,n.up,J);let c=K(t);return M(n.eye,o,Z,c)||(c=w.WGS84,M(n.eye,o,Z,c)),null==r?r=new e(new y(Z,c),a.heading,a.tilt,i(n.fov)):(r.position.x=Z[0],r.position.y=Z[1],r.position.z=Z[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=i(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function Q(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;return n.width/2/n.pixelRatio/(H*P/(t/=r))/Math.tan(n.fovX/2)}function $(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,i=t*Math.tan(n.fovX/2),o=n.width/2/n.pixelRatio;return O/(o/i)*r}function _(e,t,n,r){const i=r.levelAtScale(t),o=te(ue(e,n.eye,n.viewForward,n.up).tilt),a=Math.max(i-o,0);return r.scaleAtLevel(a)}function ee(e,t,n){const r=n.levelAtScale(e),i=te(t);return n.scaleAtLevel(r+i)}function te(e){return 2*((e>90?180-e:e)/90)**2}function ne(e,t,n){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;if(null==n){const t=e.pointsOfInterest?.cameraOnSurface?.renderLocation;n=(t&&e.renderCoordsHelper?.getAltitude(t))??0}const i=h(e.spatialReference).radius,o=e.state.viewingMode===j.Local?t.eye[2]:s(t.eye)-i;return _(e,$(e,Math.abs(o-n)),t,r)}function re(e,t,n){const r=N(e,t);return r?ne(e,r,n):0}const ie=1,oe=100;function ae(e,t,n,a,c){if(0===t)return 0;const l=u(n.eye,a),f=e.basemapTerrain?.tilingScheme;if(!f)return D().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),l;let m=l;const p=ue(e,n.eye,n.viewForward,n.up),d=p.tilt>90;if(e.state.viewingMode===j.Local){const i=(Q(e,ee(t,p.tilt,f))-Math.abs(n.eye[2]-c[2]))/Math.cos(r(p.tilt));m=d?m-i:m+i}else{let y=1/0,g=0,v=he(e,p.heading,p.tilt,a,l,X.ADJUST);if(!v)return m;const w=s(c);for(;y>ie&&g<oe;){const c=s(v.eye),l=d?180-v.tilt:v.tilt,R=r(l),T=Math.sin(R)*c,x=Math.cos(R)*c,S=Q(e,ee(t,v.tilt,f)),M=d?w-S:w+S,j=o(T/M),C=Math.cos(j)*M-x,z=u(v.eye,a);m=d?z-C:z+C,v=he(e,p.heading,p.tilt,a,m,X.ADJUST);const A=Ee(e,v,i(n.fov));if(!v||!A)return m;const b=re(e,A,w-h(e.spatialReference).radius);y=Math.abs(t-b),++g}}return m}async function ce(e,t,n,r,i,o){return se(e,t,Q(e,n),r,i,o)}function le(e,t,n,r,i,o){return Ee(e,he(e,r.heading,r.tilt,t,n,i),r.fov,o)}async function se(e,t,n,r,i,o){const c=await ye(e,r.heading,r.tilt,t,n,i,o);return a(o),Ge(e,c,r.fov,o)}function ue(e,t,n,r,i){return W(e).directionToHeadingTilt(t,n,r,i)}function fe(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,q,e.spatialReference)&&e.elevationProvider&&(U(e.elevationProvider,q)??0)>q[2]-I)}async function me(e,t,n){if(fe(e,t))return!0;const{elevationProvider:r,spatialReference:i,renderCoordsHelper:o}=e;if(null==r||!o.fromRenderCoords(t,q,i))return!1;const[c,l,s]=q,u=await r.queryElevation(c,l,s,i,"ground",n)??0;return a(n),u>s-I}async function pe(e,t,n){const r=d();if(null==t)return m(r,e.state.camera.center);if(t instanceof y){const{renderSpatialReference:i,basemapTerrain:o,elevationProvider:c}=e,l=t.spatialReference;if(await T(t,r,i,0,{signal:n}),a(n),null==t.z&&null!=o&&null!=c){const i=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);a(n),null!=i&&e.renderCoordsHelper.setAltitude(r,i)}return r}return m(r,t)}function de(e,t){const n=d();if(null==t)return m(n,e.state.camera.center);if(t instanceof y){if(!R(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:i}=e;if(null==t.z&&null!=r&&null!=i){const r=U(i,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return m(n,t)}function he(e,t,n,r,i,o){return ge(e,t,n,r instanceof y?r:null,de(e,r),i,o)}async function ye(e,t,n,r,i,o,c){const l=r instanceof y?r:null,s=await pe(e,r,c);return a(c),ve(e,t,n,l,s,i,o,c)}function ge(e,t,n,r,i,o,a){if(null==i)return null;if(!r&&(r=new y({spatialReference:K(e)}),!x(i,e.renderSpatialReference,r)))return null;const c=we(e,t,n,i,o,a);if(Re(e,n,a)&&fe(e,c.eye)){const{tilt:a,mode:c}=Te(e,n,i,o);return ge(e,t,a,r,i,o,c)}return xe(c,i)}async function ve(e,t,n,r,i,o,c,l){r||(r=new y({spatialReference:K(e)}),await S(i,e.renderSpatialReference,r,{signal:l})||(r=null)),a(l);const s=we(e,t,n,i,o,c);if(Re(e,n,c)&&await me(e,s.eye,l)){a(l);const{tilt:c,mode:s}=Te(e,n,i,o);return ve(e,t,c,r,i,o,s,l)}return xe(s,i)}function we(e,t,n,r,i,o){const a=Ue(e,t,n,r,i=Math.max(i,e.state.constraints.minimumPoiDistance),o);return(0,W(e).eyeForCenterWithHeadingTilt)(r,i,a.heading,a.tilt)}function Re(e,t,n){const r=e.map.ground.navigationConstraint;return n===X.ADJUST&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function Te(e,t,n,r){const i=He(e,n,r,Pe(e,r,t,n));return{tilt:i,mode:t-i<1?X.LOCKED:X.ADJUST}}function xe(e,t){return{...e,center:p(t)}}function Se(e,t){const{state:n,spatialReference:r}=e,i=t.spatialReference;return n.isGlobal&&L(i,j.Global)||n.isLocal&&r.equals(i)}function Me(e,t){let n,r,i;if(e.state.isGlobal){const e=new y(t.xmin,t.ymin,t.spatialReference),o=new y(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?V:k;n=new y({x:a.center(e.x,o.x),y:(o.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=h(t.spatialReference),l=b(n,e,o);r=l.lon,i=l.lat,a.diff(e.x,o.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),i=Math.min(i,c.halfCircumference)}else{const o=e.renderSpatialReference??t.spatialReference;o.equals(t.spatialReference)||(t=v(t,o)),r=t.xmax-t.xmin,i=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new y({x:t.xmin+.5*r,y:t.ymin+.5*i,z:a,spatialReference:o})}const o=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),l=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*i*l,.5*o*s)/E}}async function je(e,t,n,r,i,o){const c=Se(e,t)?t:await g(t,e.spatialReference,{signal:o});a(o);const{center:l,distance:s}=Me(e,c),u=await ye(e,n,r,l,s,i,o);return a(o),Ge(e,u,e.camera.fov,o)}function Ce(e,t,n,r,i,o){let a;try{a=Se(e,t)?t:v(t,e.spatialReference)}catch(u){return null}const{center:c,distance:l}=Me(e,a),s=he(e,n,r,c,l,i);return null==s?null:Ee(e,s,e.camera.fov,o)}function ze(e,t,n){const r=e.renderSpatialReference,i=new y({spatialReference:K(e)});if(!x(n,r,i))return null;const o=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=f(t.eye,n),l=2*c*o*E,s=2*c*a*E;return W(e).toExtent(e,i,l,s)}function Ae(e,t){return W(e).toArea(e,t)}function be(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>G)return!0;const i=t,o=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return u(i,o)/(Math.tan(.5*e.state.camera.fov)*r)>F}function Ue(e,t,n,r,i,o){let a=0;return o===X.ADJUST&&be(e,r,i)?(t=0,a=De(e,i,n,r)):a=Oe(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=He(e,r,i,a)}}const Le=.7;function De(e,t,n,r){const i=Oe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);o.max=Math.min(o.max,.5*Math.PI);const a=o.min*(1-Le)+o.max*Le;return Math.min(i,a)}function Pe(e,t,n,r){let i=Oe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);return i=Math.min(i,.5*Math.PI),o.min*(1-Le)+i*Le}function He(e,t,n,r){return W(e).lookAtTiltToEyeTilt(r,t,n)}function Oe(e,t,n,r){return W(e).eyeTiltToLookAtTilt(r,t,n)}function Ee(t,n,r,i){if(null==n)return null;const o=t.renderSpatialReference,a=new y({spatialReference:K(t)});return x(n.eye,o,a)?(i??=new e,i.position=a,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i):null}async function Ge(t,n,r,i){const o=t.renderSpatialReference,c=new y({spatialReference:K(t)});return await S(n.eye,o,c,{signal:i}),a(i),new e(c,n.heading,n.tilt,r)}function Fe(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);D().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Ie(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);D().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{X as OrientationMode,_ as applyTiltAdjustToScale,ue as directionToHeadingTilt,$ as distanceToScale,re as externalCameraToScale,N as externalToInternal,se as fromCenterDistanceAsync,le as fromCenterDistanceSync,ce as fromCenterScale,je as fromExtentAsync,Ce as fromExtentSync,ye as getObserverForPointAtDistanceAsync,he as getObserverForPointAtDistanceSync,K as getViewSR,Y as headingTiltToDirectionUp,ne as internalCameraToScale,B as internalToExternal,ee as removeTiltAdjustFromScale,ie as scaleErrorThreshold,Q as scaleToDistance,ae as scaleToTargetDistance,Fe as scaleToZoom,Ae as toArea,ze as toExtent,Ie as zoomToScale};
