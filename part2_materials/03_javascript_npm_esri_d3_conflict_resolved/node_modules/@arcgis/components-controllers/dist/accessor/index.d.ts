import { d as GenericController, B as BaseComponent, b as Controller, E as EventEmitter } from '../Controller-B1uyOIYH.js';
import '@arcgis/components-utils';
import '@stencil/core';
import 'lit';
import '@stencil/core/internal';

/**
 * Do two-way binding between an instance of an Accessor and component's
 * properties
 *
 * @remarks
 * For disambiguation, in this file "prop" refers to a reactive property on the
 * web component, and "property" refers to a property on the Accessor instance.
 */

type Requires<Props, Accessor extends __esri.Accessor> = BaseComponent & Pick<Accessor, keyof Accessor & keyof Props> & {
    reactiveUtils?: typeof __esri.reactiveUtils;
    autoDestroyDisabled: boolean;
    destroy: () => Promise<void>;
};
/**
 * Given an Accessor class, create a controller that will do two-way binding of
 * props between the component and the Accessor
 *
 * See 4.accessor.tsx for documentation & examples
 */
declare const makeAccessorController: <Props, Accessor extends __esri.Accessor, OmitProps extends string = never>(loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
    /**
     * By default, to ensure that you didn't accidentally forget to bind any
     * of the Accessor's properties on your component, every property that
     * is accepted by the Accessor's constructor will be required to be bound
     * on your component. If you do not wish to bind certain properties
     * (or you wish to bind them but with a different type), you can omit
     * them using this option.
     *
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * ```tsx
     * \@State() timeZone = this.viewModel.timeZone;
     * ```
     *
     * @remarks
     * This option affects the TypeScript error checking only - it has
     * no runtime impact. Thus, if you wish to save a few bytes in the
     * bundle, rather than simply setting this property like
     * `makeAccessorController(..., { omitProps: ["propName"] })`, you can
     * set it like this:
     * `makeAccessorController(..., {} as { omitProps: ["propName"] })`
     */
    omitProps: OmitProps[];
}) => (component: Requires<Omit<Props, OmitProps>, Accessor>, options?: {
    editConstructorProperties(props: Props): Promise<Props> | Props;
}) => Accessor;
declare class AccessorController<Props, Accessor extends __esri.Accessor, ExtraRequires = Record<never, never>> extends GenericController<Accessor, ExtraRequires & Requires<Props, Accessor>> {
    private _loadAccessor;
    private _options?;
    reactiveUtils: __esri.reactiveUtils;
    protected _instance: Accessor;
    protected _watchedProperties: Map<string, string & keyof Props>;
    private _instancePropName;
    private _isBinding;
    /**
     * (development only) Allow these props to mismatch the name of the Accessor's property
     * to avoid collisions
     *
     * @internal
     */
    static allowedPropNameMismatches?: Set<string>;
    constructor(component: ExtraRequires & Requires<Props, Accessor>, _loadAccessor: ((props: Props) => Accessor | Promise<Accessor>) | (new (props: Props) => Accessor), _options?: {
        editConstructorProperties?(props: Props): Promise<Props> | Props;
    } | undefined);
    hostConnected(): void;
    hostLoad(): Promise<void>;
    private _gatherParameters;
    private _createInstance;
    private _isAccessorConstructor;
    hostDestroy(): void;
    reCreate(): Promise<void>;
}
declare const accessorSupport: {
    makeGetterProxy: (component: BaseComponent, watchedProperties: Map<string, string>, isBinding?: {
        value: boolean;
    }, allowedPropNameMismatches?: Set<string>) => unknown;
    watchComponentUpdates<T>(controller: Controller<T> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    watchAccessorUpdates<T_1>(controller: Controller<T_1> & {
        reactiveUtils: __esri.reactiveUtils;
    }, instance: __esri.Accessor, watchedProperties: Map<string, string>): void;
    reEmitAccessorEvents<T_2>(controller: Controller<T_2>, instance: __esri.Accessor, reactiveUtils: __esri.reactiveUtils, prefix: string): void;
    reCreate(instance: __esri.Accessor, component: BaseComponent): Promise<void>;
};

/**
 * Re-emit an event from the accessor instance on the component
 *
 * @example
 * ```tsx
 * arcgisGo = reEmitEvent<__esri.HomeViewModelGoEvent>(() => this.viewModel, "go");
 * ```
 *
 * @remarks
 * `reEmitEvent()` only works in Lumina. Consult documentation for equivalent
 * Stencil pattern.
 */
declare function reEmitEvent<T>(getEventedAccessor: () => __esri.Evented, eventName: string): EventEmitter<T>;

/**
 * If this controller is present on the component, reactiveUtils integration
 * will be enabled. With that, you can use reactiveUtils.watch() and other
 * methods to watch for changes on the component's Props and State.
 */
declare function useReactiveUtilsIntegration(): void;

export { AccessorController, accessorSupport, makeAccessorController, reEmitEvent, useReactiveUtilsIntegration };
