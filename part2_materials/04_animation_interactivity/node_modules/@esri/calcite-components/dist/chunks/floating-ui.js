import { autoUpdate as T, computePosition as W, shift as _, hide as B, flip as P, offset as H, autoPlacement as L, arrow as N, platform as v } from "@floating-ui/dom";
import { debounce as z } from "lodash-es";
import { offsetParent as G } from "composed-offset-position";
import { D as w, i as E } from "./runtime.js";
import { g as V } from "./dom.js";
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.0.3 */
(function() {
  if (E()) {
    const e = v.getOffsetParent;
    v.getOffsetParent = (n) => e(n, G);
  }
})();
function U(t) {
  const e = window.devicePixelRatio || 1;
  return Math.round(t * e) / e;
}
const O = (
  /* we export arrow function to allow us to spy on it during testing */
  async (t, {
    referenceEl: e,
    floatingEl: n,
    overlayPositioning: i = "absolute",
    placement: a,
    flipDisabled: s,
    flipPlacements: o,
    offsetDistance: l,
    offsetSkidding: r,
    arrowEl: g,
    type: D
  }) => {
    if (!e || !n)
      return;
    const m = V(n) === "rtl", {
      x: R,
      y: S,
      placement: b,
      strategy: k,
      middlewareData: p
    } = await W(e, n, {
      strategy: i,
      placement: a === "auto" || a === "auto-start" || a === "auto-end" ? void 0 : M(a, m),
      middleware: J({
        placement: a,
        flipDisabled: s,
        flipPlacements: o?.map((c) => M(c, m)),
        offsetDistance: l,
        offsetSkidding: r,
        arrowEl: g,
        type: D
      })
    });
    if (g && p.arrow) {
      const { x: c, y: j } = p.arrow, u = b.split("-")[0], y = c != null ? "left" : "top", C = Q[u], I = { left: "", top: "", bottom: "", right: "" };
      "floatingLayout" in t && (t.floatingLayout = u === "left" || u === "right" ? "horizontal" : "vertical"), Object.assign(g.style, {
        ...I,
        [y]: `${y == "left" ? c : j}px`,
        [u]: "100%",
        transform: C
      });
    }
    const h = p.hide?.referenceHidden ? "hidden" : null, $ = h ? "none" : null;
    n.setAttribute(q, b), Object.assign(n.style, {
      pointerEvents: $,
      position: k,
      transform: `translate(${U(R)}px,${U(S)}px)`,
      visibility: h
    });
  }
), q = "data-placement", F = [
  "top",
  "bottom",
  "right",
  "left",
  "top-start",
  "top-end",
  "bottom-start",
  "bottom-end",
  "right-start",
  "right-end",
  "left-start",
  "left-end",
  "leading",
  "trailing",
  "leading-start",
  "leading-end",
  "trailing-start",
  "trailing-end"
], ot = "bottom-start", rt = "bottom-end", st = {
  animation: "calcite-floating-ui-anim",
  animationActive: "calcite-floating-ui-anim--active"
};
function J({
  placement: t,
  flipDisabled: e,
  flipPlacements: n,
  offsetDistance: i,
  offsetSkidding: a,
  arrowEl: s,
  type: o
}) {
  const l = [_(), B()];
  if (o === "menu")
    return [
      ...l,
      P({
        fallbackPlacements: n || ["top-start", "top", "top-end", "bottom-start", "bottom", "bottom-end"]
      })
    ];
  if (o === "popover" || o === "tooltip") {
    const r = [
      ...l,
      H({
        mainAxis: typeof i == "number" ? i : 0,
        crossAxis: typeof a == "number" ? a : 0
      })
    ];
    return t === "auto" || t === "auto-start" || t === "auto-end" ? r.push(
      L({ alignment: t === "auto-start" ? "start" : t === "auto-end" ? "end" : null })
    ) : e || r.push(P(n ? { fallbackPlacements: n } : {})), s && r.push(
      N({
        element: s
      })
    ), r;
  }
  return [];
}
function lt(t, e) {
  const n = t.filter(
    (i) => F.includes(i)
  );
  return n.length !== t.length && console.warn(
    `${e.tagName}: Invalid value found in: flipPlacements. Try any of these: ${F.map((i) => `"${i}"`).join(", ").trim()}`,
    { el: e }
  ), n;
}
function M(t, e = !1) {
  const n = ["left", "right"];
  return e && n.reverse(), t.replace(/leading/gi, n[0]).replace(/trailing/gi, n[1]);
}
async function ft(t, e, n = !1) {
  if (!t.open || !e.floatingEl || !e.referenceEl)
    return;
  if (Object.assign(e.floatingEl.style, {
    display: "block",
    // initial positioning based on https://floating-ui.com/docs/computePosition#initial-layout
    position: e.overlayPositioning ?? "absolute"
  }), !f.get(t))
    return A(t);
  await (n ? K(t) : O)(t, e);
}
function K(t) {
  let e = d.get(t);
  return e || (e = z(O, w.reposition, {
    leading: !0,
    maxWait: w.reposition
  }), d.set(t, e), e);
}
const Q = {
  top: "",
  left: "rotate(-90deg)",
  bottom: "rotate(180deg)",
  right: "rotate(90deg)"
}, f = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
async function A(t) {
  const { referenceEl: e, floatingEl: n } = t;
  if (!n.isConnected)
    return;
  const i = E() ? T : (o, l, r) => (r(), () => {
  });
  f.set(t, { state: "pending" });
  let a;
  const s = i(
    e,
    n,
    // callback is invoked immediately
    () => {
      const o = t.reposition();
      a || (a = o);
    }
  );
  return f.set(t, { state: "active", cleanUp: s }), a;
}
function X(t) {
  const { floatingEl: e } = t;
  e && Object.assign(e.style, {
    display: "",
    pointerEvents: "",
    position: "",
    transform: "",
    visibility: ""
  });
}
async function ct(t) {
  const { floatingEl: e, referenceEl: n } = t;
  if (X(t), !(!e || !n) && (Y(t), !!t.open))
    return A(t);
}
function Y(t) {
  const { floatingEl: e, referenceEl: n } = t;
  if (!e || !n)
    return;
  const i = f.get(t);
  i?.state === "active" && i.cleanUp(), f.delete(t), d.get(t)?.cancel(), d.delete(t);
}
const x = 4, ut = Math.ceil(Math.hypot(x, x));
export {
  st as F,
  Y as a,
  ot as b,
  ct as c,
  ut as d,
  rt as e,
  lt as f,
  X as h,
  ft as r
};
