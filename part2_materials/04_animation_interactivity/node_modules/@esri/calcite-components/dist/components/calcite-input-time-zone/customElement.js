import { c as M } from "../../chunks/runtime.js";
import { ref as R } from "lit-html/directives/ref.js";
import { repeat as L } from "lit-html/directives/repeat.js";
import { keyed as k } from "lit-html/directives/keyed.js";
import { html as v, nothing as Z } from "lit";
import { LitElement as V, createEvent as g, stringOrBoolean as _, safeClassMap as U } from "@arcgis/lumina";
import { c as N, d as G } from "../../chunks/label.js";
import { u as H, I as q } from "../../chunks/interactive.js";
import { c as W } from "../../chunks/loadable.js";
import { c as j, a as A, d as K, H as J } from "../../chunks/form.js";
import { u as Q } from "../../chunks/useT9n.js";
import { g as X } from "../../chunks/locale.js";
import { css as Y } from "@lit/reactive-element/css-tag.js";
/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.
v3.0.3 */
const ee = {
  offset: "offset"
}, te = 60;
function x(t) {
  return t.replace(":15", ".25").replace(":30", ".5").replace(":45", ".75").replace("âˆ’", "-");
}
function oe(t, e) {
  const o = O(t, "en-US", e).replace("GMT", "");
  return o === "" ? 0 : Number(x(o)) * te;
}
function se() {
  return (/* @__PURE__ */ new Date()).getTimezoneOffset() * -1;
}
function ae() {
  return new Intl.DateTimeFormat().resolvedOptions().timeZone;
}
async function ie(t) {
  if (t === "offset")
    return (o) => o;
  const { normalize: e } = await import("timezone-groups/utils/time-zones");
  return e;
}
async function ne(t, e, o, s, n) {
  if (o === "name") {
    const { groupByName: a } = await import("timezone-groups/groupByName");
    return (await a()).map(({ label: i }) => ({
      label: i,
      value: i,
      metadata: {
        filterValue: i
      }
    })).filter((i) => !!i).sort();
  }
  const r = n === "user" ? t : (
    // we use locales that will always yield a short offset that matches `standardTime`
    n === "utc" ? "fr" : "en-GB"
  ), f = s.getTime();
  if (o === "region") {
    const [{ groupByRegion: a }, { getCountry: c, global: i }] = await Promise.all([
      import("timezone-groups/groupByRegion"),
      import("timezone-groups/utils/region")
    ]);
    return (await a()).map(({ label: m, tzs: u }) => (u.sort((d, h) => {
      const T = I(d, e), C = I(h, e), p = "Etc/GMT";
      if (d.startsWith(p) && h.startsWith(p)) {
        const b = d.substring(p.length), F = h.substring(p.length), E = b === "" ? 0 : parseInt(b);
        return (F === "" ? 0 : parseInt(F)) - E;
      }
      return T.localeCompare(C);
    }), {
      label: $(e, m),
      items: u.map((d) => {
        const h = x(
          O(d, r, f)
        ), T = I(d, e), C = m === i ? (
          // we rely on the label for search since GMT items have their signs inverted (see https://en.wikipedia.org/wiki/Tz_database#Area)
          // in addition to the label we also add "Global" and "Etc" to allow searching for these items
          `${I(i, e)} Etc`
        ) : D(d), p = c(d), b = $(e, p);
        return {
          label: T,
          value: d,
          metadata: {
            country: b === T ? void 0 : b,
            filterValue: C,
            offset: h
          }
        };
      })
    })).sort(
      (m, u) => m.label === i ? -1 : u.label === i ? 1 : m.label.localeCompare(u.label)
    );
  }
  const [{ groupByOffset: y }, { DateEngine: P }] = await Promise.all([
    import("timezone-groups/groupByOffset"),
    import("timezone-groups/groupByOffset/strategy/native")
  ]), w = await y({
    dateEngine: new P(),
    groupDateRange: 1,
    startDate: new Date(f).toISOString()
  }), z = new Intl.ListFormat(t, { style: "long", type: "conjunction" }), S = ["Factory", "Etc/UTC"];
  return w.forEach((a) => {
    const c = [];
    let i = 0;
    a.tzs.forEach((l, m) => {
      S.includes(l) && i++, c[m] = i;
    }), a.tzs = a.tzs.filter((l) => !S.includes(l)), a.labelTzIdx = a.labelTzIdx.map((l) => l - c[l]).filter((l) => l >= 0 && l < a.tzs.length);
  }), w.map(({ labelTzIdx: a, tzs: c }) => {
    const i = c[0], l = x(
      O(i, r, f)
    ), m = oe(i, f), u = a.map((h) => I(c[h], e));
    return {
      label: ce(e, l, z.format(u)),
      value: m,
      metadata: {
        filterValue: c.map((h) => D(h))
      }
    };
  }).filter((a) => !!a).sort((a, c) => a.value - c.value);
}
function I(t, e) {
  return e[t] || re(t);
}
function le(t, e, o) {
  return o.timeZoneRegionLabel.replace("{city}", t).replace("{country}", $(o, e));
}
function $(t, e) {
  return t[e] || e;
}
function re(t) {
  return t.split("/").pop();
}
function D(t) {
  return t.replace(/_/g, " ");
}
function ce(t, e, o) {
  return t.timeZoneLabel.replace("{offset}", e).replace("{cities}", o);
}
function O(t, e, o = Date.now()) {
  return t === "Factory" && (t = "Etc/GMT"), X(e, { timeZone: t, timeZoneName: "shortOffset" }).formatToParts(o).find(({ type: r }) => r === "timeZoneName").value;
}
function me(t) {
  return t.items !== void 0;
}
function de(t) {
  return me(t[0]) ? t.flatMap((e) => e.items) : t;
}
function B(t, e, o) {
  return o == null ? null : de(t).find(
    (s) => (
      // intentional == to match string to number
      s[e] == o
    )
  );
}
const he = Y`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:block}.offset{white-space:nowrap}:host([hidden]){display:none}[hidden]{display:none}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}::slotted(input[slot=hidden-form-input]){margin:0!important;opacity:0!important;outline:none!important;padding:0!important;position:absolute!important;inset:0!important;transform:none!important;-webkit-appearance:none!important;z-index:-1!important}`;
class fe extends V {
  constructor() {
    super(...arguments), this.clearable = !1, this.disabled = !1, this.maxItems = 0, this.messages = Q({ blocking: !0 }), this.mode = "offset", this.offsetStyle = "user", this.open = !1, this.overlayPositioning = "absolute", this.readOnly = !1, this.required = !1, this.scale = "m", this.status = "idle", this.validity = {
      valid: !1,
      badInput: !1,
      customError: !1,
      patternMismatch: !1,
      rangeOverflow: !1,
      rangeUnderflow: !1,
      stepMismatch: !1,
      tooLong: !1,
      tooShort: !1,
      typeMismatch: !1,
      valueMissing: !1
    }, this.calciteInputTimeZoneBeforeClose = g({ cancelable: !1 }), this.calciteInputTimeZoneBeforeOpen = g({ cancelable: !1 }), this.calciteInputTimeZoneChange = g({ cancelable: !1 }), this.calciteInputTimeZoneClose = g({ cancelable: !1 }), this.calciteInputTimeZoneOpen = g({ cancelable: !1 });
  }
  static {
    this.properties = { clearable: 7, disabled: 7, form: 3, maxItems: 11, messageOverrides: 0, mode: 3, name: 3, offsetStyle: 3, open: 7, overlayPositioning: 3, readOnly: 7, referenceDate: 1, required: 7, scale: 3, status: 3, validationIcon: [3, { converter: _ }], validationMessage: 1, validity: 0, value: 1 };
  }
  static {
    this.shadowRootOptions = { mode: "open", delegatesFocus: !0 };
  }
  static {
    this.styles = he;
  }
  /**
   * The component's value, where the value is the time zone offset or the difference, in minutes, between the selected time zone and UTC.
   *
   * If no value is provided, the user's time zone offset will be selected by default.
   *
   * @see [Identifying time zones and zone offsets](https://www.w3.org/International/core/2005/09/timezone.html#:~:text=What%20is%20a%20%22zone%20offset,or%20%22%2D%22%20from%20UTC).
   */
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e;
  }
  // #endregion
  // #region Public Methods
  /** Sets focus on the component. */
  async setFocus() {
    await W(this), await this.comboboxEl.setFocus();
  }
  // #endregion
  // #region Lifecycle
  connectedCallback() {
    super.connectedCallback(), j(this), N(this);
  }
  async load() {
    this.normalizer = await ie(this.mode), await this.updateTimeZoneItems();
    const e = this.value, o = this.normalizeValue(e);
    this.value = o || (e === "" ? o : void 0), this.updateTimeZoneSelection();
    const s = this.selectedTimeZoneItem ? `${this.selectedTimeZoneItem.value}` : "";
    A(this, s), this.value = s;
  }
  willUpdate(e) {
    e.has("value") && this.hasUpdated && this.handleValueChange(this.value, e.get("value")), (e.has("messages") || e.has("mode") && (this.hasUpdated || this.mode !== "offset") || e.has("referenceDate")) && this.handleTimeZoneItemPropsChange(), e.has("open") && (this.hasUpdated || this.open !== !1) && this.openChanged();
  }
  updated() {
    H(this);
  }
  loaded() {
    this.overrideSelectedLabelForRegion(this.open), this.openChanged();
  }
  disconnectedCallback() {
    super.disconnectedCallback(), K(this), G(this);
  }
  // #endregion
  // #region Private Methods
  async handleTimeZoneItemPropsChange() {
    !this.timeZoneItems || !this.hasUpdated || (await this.updateTimeZoneItems(), this.updateTimeZoneSelection());
  }
  openChanged() {
    this.comboboxEl && (this.comboboxEl.open = this.open);
  }
  async handleValueChange(e, o) {
    const s = this.normalizeValue(e);
    if (!s) {
      if (this.clearable) {
        this._value = s, this.selectedTimeZoneItem = null;
        return;
      }
      this._value = o, this.selectedTimeZoneItem = this.findTimeZoneItem(o);
      return;
    }
    const n = this.findTimeZoneItem(s);
    if (!n) {
      this._value = o;
      return;
    }
    this._value = s, this.selectedTimeZoneItem = n, s !== e && (await this.updateComplete, this.overrideSelectedLabelForRegion(this.open));
  }
  onLabelClick() {
    this.setFocus();
  }
  setComboboxRef(e) {
    this.comboboxEl = e;
  }
  /**
   * Helps override the selected item's label for region mode outside of item rendering logic to avoid flickering text change
   *
   * @param open
   * @private
   */
  overrideSelectedLabelForRegion(e) {
    if (this.mode !== "region" || !this.selectedTimeZoneItem)
      return;
    const { label: o, metadata: s } = this.selectedTimeZoneItem;
    this.comboboxEl.selectedItems[0].textLabel = !s.country || e ? o : le(o, s.country, this.messages);
  }
  onComboboxBeforeClose(e) {
    e.stopPropagation(), this.overrideSelectedLabelForRegion(!1), this.calciteInputTimeZoneBeforeClose.emit();
  }
  onComboboxBeforeOpen(e) {
    e.stopPropagation(), this.overrideSelectedLabelForRegion(!0), this.calciteInputTimeZoneBeforeOpen.emit();
  }
  onComboboxChange(e) {
    e.stopPropagation();
    const s = e.target.selectedItems[0];
    if (!s) {
      this._value = "", this.selectedTimeZoneItem = null, this.calciteInputTimeZoneChange.emit();
      return;
    }
    const n = this.findTimeZoneItemByLabel(s.getAttribute("data-label")), r = `${n.value}`;
    this.value === r && n.label === this.selectedTimeZoneItem.label || (this._value = r, this.selectedTimeZoneItem = n, this.calciteInputTimeZoneChange.emit());
  }
  onComboboxClose(e) {
    e.stopPropagation(), this.open = !1, this.calciteInputTimeZoneClose.emit();
  }
  onComboboxOpen(e) {
    this.open = !0, e.stopPropagation(), this.calciteInputTimeZoneOpen.emit();
  }
  findTimeZoneItem(e) {
    return B(this.timeZoneItems, "value", e);
  }
  findTimeZoneItemByLabel(e) {
    return B(this.timeZoneItems, "label", e);
  }
  async updateTimeZoneItems() {
    this.timeZoneItems = await this.createTimeZoneItems();
  }
  updateTimeZoneSelection() {
    if (this.value === "" && this.clearable) {
      this.selectedTimeZoneItem = null;
      return;
    }
    const e = this.mode === "offset" ? se() : ae(), o = this.value === "" || !this.value ? e : this.value;
    this.selectedTimeZoneItem = this.findTimeZoneItem(o) || this.findTimeZoneItem(e);
  }
  async createTimeZoneItems() {
    return !this.messages._lang || !this.messages ? [] : ne(this.messages._lang, this.messages, this.mode, this.referenceDate instanceof Date ? this.referenceDate : new Date(this.referenceDate ?? Date.now()), this.offsetStyle);
  }
  normalizeValue(e) {
    return e = e === void 0 ? "" : e, e && this.normalizer(e);
  }
  // #endregion
  // #region Rendering
  render() {
    return q({ disabled: this.disabled, children: v`<calcite-combobox .clearDisabled=${!this.clearable} .disabled=${this.disabled} .label=${this.messages.chooseTimeZone} lang=${this.messages._lang ?? Z} .maxItems=${this.maxItems} @calciteComboboxBeforeClose=${this.onComboboxBeforeClose} @calciteComboboxBeforeOpen=${this.onComboboxBeforeOpen} @calciteComboboxChange=${this.onComboboxChange} @calciteComboboxClose=${this.onComboboxClose} @calciteComboboxOpen=${this.onComboboxOpen} .overlayPositioning=${this.overlayPositioning} .placeholder=${this.mode === "name" ? this.messages.namePlaceholder : this.mode === "offset" ? this.messages.offsetPlaceholder : this.messages.regionPlaceholder} placeholder-icon=search .readOnly=${this.readOnly} .scale=${this.scale} .selectionMode=${this.clearable ? "single" : "single-persist"} .status=${this.status} .validationIcon=${this.validationIcon} .validationMessage=${this.validationMessage} ${R(this.setComboboxRef)}>${this.renderItems()}</calcite-combobox>${J({ component: this })}` });
  }
  renderItems() {
    return this.mode === "region" ? this.renderRegionItems() : L(this.timeZoneItems, ({ label: e }) => e, (e) => {
      const o = this.selectedTimeZoneItem === e, { label: s, metadata: n, value: r } = e;
      return v`<calcite-combobox-item data-label=${s ?? Z} .metadata=${n} .selected=${o} .textLabel=${s} .value=${r}></calcite-combobox-item>`;
    });
  }
  renderRegionItems() {
    return this.timeZoneItems.flatMap(({ label: e, items: o }) => k(e, v`<calcite-combobox-item-group .label=${e}>${L(o, ({ label: s }) => s, (s) => {
      const n = this.selectedTimeZoneItem === s, { label: r, metadata: f, value: y } = s;
      return v`<calcite-combobox-item data-label=${r ?? Z} .description=${f.country} .metadata=${f} .selected=${n} .textLabel=${r} .value=${y}><span class=${U(ee.offset)} slot=content-end>${f.offset}</span></calcite-combobox-item>`;
    })}</calcite-combobox-item-group>`));
  }
}
M("calcite-input-time-zone", fe);
export {
  fe as InputTimeZone
};
