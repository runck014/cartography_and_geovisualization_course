"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/accessor/index.ts
var accessor_exports = {};
__export(accessor_exports, {
  AccessorController: () => AccessorController,
  accessorSupport: () => accessorSupport,
  makeAccessorController: () => makeAccessorController,
  reEmitEvent: () => reEmitEvent
});
module.exports = __toCommonJS(accessor_exports);

// src/Controller.ts
var import_components_utils3 = require("@arcgis/components-utils");

// src/types.ts
var controllerSymbol = Symbol.for("controller");

// src/ControllerInternals.ts
var import_components_utils2 = require("@arcgis/components-utils");

// package.json
var name = "@arcgis/components-controllers";

// src/utils.ts
var import_components_utils = require("@arcgis/components-utils");
var isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);
var devOnlySetPersistentControllerData = process.env.NODE_ENV !== "production" && (0, import_components_utils.isEsriInternalEnv)() ? (controller, data) => {
  const manager = controller.component.manager;
  const controllers = "_controllers" in manager ? manager._controllers : void 0;
  if (controllers === void 0) {
    return void 0;
  }
  const index = Array.from(controllers).indexOf(controller);
  if (index === -1) {
    return;
  }
  const devOnlyControllerData = Symbol.for(`${name}: devOnlyControllerData`);
  const el = controller.component.el;
  el[devOnlyControllerData] ?? (el[devOnlyControllerData] = {});
  el[devOnlyControllerData][index] = data;
} : void 0;
var devOnlyGetPersistentControllerData = process.env.NODE_ENV !== "production" && (0, import_components_utils.isEsriInternalEnv)() ? (controller) => {
  const manager = controller.component.manager;
  const controllers = "_controllers" in manager ? manager._controllers : void 0;
  if (controllers === void 0) {
    return void 0;
  }
  const index = Array.from(controllers).indexOf(controller);
  const devOnlyControllerData = Symbol.for(`${name}: devOnlyControllerData`);
  const el = controller.component.el;
  return el[devOnlyControllerData]?.[index];
} : void 0;

// src/ControllerInternals.ts
var ambientComponent;
function setAmbientComponent(component) {
  if (ambientComponent === component) {
    return;
  }
  ambientComponent = component;
  queueMicrotask(() => {
    if (ambientComponent === component) {
      ambientComponent = void 0;
    }
  });
}
function retrieveComponent(name2) {
  if (process.env.NODE_ENV !== "production" && ambientComponent === void 0) {
    throw new Error(
      [
        `Unable to find out which component ${name2 || "this"} controller `,
        "belongs to. Possible causes:\n",
        "- You might also have multiple versions of ",
        "@arcgis/components-controllers package installed\n",
        ...(0, import_components_utils2.isEsriInternalEnv)() ? [
          "- You tried to create controller outside the component. If so, ",
          "please wrap your controller definition in an arrow function (like",
          "`const myController = ()=>makeController(...);`) and call that",
          "function inside the component (`my = myController();`), or ",
          "define your controller using makeGenericController/GenericController ",
          "instead.\n",
          "- You tried to create a controller inside an async function. ",
          "This is allowed without calling controller.use(). Make sure you ",
          "use it like `await controller.use(useController())`."
        ] : []
      ].join("")
    );
  }
  return ambientComponent;
}
var ambientControllers = [];
function setParentController(controller) {
  if (controller === void 0) {
    ambientControllers = [];
    return;
  }
  const index = ambientControllers.indexOf(controller);
  ambientControllers = index === -1 ? [...ambientControllers, controller] : ambientControllers.slice(0, index + 1);
  queueMicrotask(() => {
    ambientControllers = [];
  });
}
function retrieveParentControllers() {
  return ambientControllers;
}
var ambientChildController;
function setAmbientChildController(controller) {
  if (ambientChildController === controller) {
    return;
  }
  ambientChildController = controller;
  queueMicrotask(() => {
    if (ambientChildController === controller) {
      ambientChildController = void 0;
    }
  });
}
function retrieveAmbientChildController() {
  const controller = ambientChildController;
  ambientChildController = void 0;
  return controller;
}
var use = async (value, watchExports) => {
  const controller = useRefSync(value);
  if (controller === void 0) {
    if (process.env.NODE_ENV !== "production" && (0, import_components_utils2.isEsriInternalEnv)() && typeof watchExports === "function") {
      throw new Error(
        `Unable to resolve a controller from the provided value, so can't watch it's exports. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
      );
    }
    return value;
  }
  await controller.ready;
  if (typeof watchExports === "function") {
    if (process.env.NODE_ENV !== "production" && (0, import_components_utils2.isEsriInternalEnv)() && controller.watchExports === void 0) {
      throw new Error(`The controller must implement watchExports method to support watching exports`);
    }
    const unsubscribe = controller.watchExports(
      (exports2) => watchExports(exports2, unsubscribe)
    );
  }
  return controller.exports;
};
var useRef = async (value) => {
  const controller = useRefSync(value);
  if (process.env.NODE_ENV !== "production" && (0, import_components_utils2.isEsriInternalEnv)() && controller === void 0) {
    throw new Error(
      `Unable to resolve a controller from the provided value. The value you passed is not a controller and not a controller exports. If your controller exports a literal value, try making your controller export an object instead`
    );
  }
  await controller.ready;
  return controller;
};
var useRefSync = (value) => {
  const component = retrieveComponent();
  const controller = component.manager.internals.resolveExports(value);
  if (controller !== void 0) {
    return controller;
  }
  if (isController(value)) {
    return value;
  }
  const ambientChildController2 = retrieveAmbientChildController();
  if (ambientChildController2 !== void 0) {
    return ambientChildController2;
  }
  return void 0;
};
var shouldBypass = {
  setter: false,
  getter: false,
  readOnly: false
};

// src/Controller.ts
var _a;
_a = controllerSymbol;
var Controller = class {
  constructor(component) {
    this._callbacks = {
      hostConnected: [],
      hostDisconnected: [],
      hostLoad: [],
      hostLoaded: [],
      hostUpdate: [],
      hostUpdated: [],
      hostDestroy: [],
      hostLifecycle: []
    };
    this._ready = new import_components_utils3.Deferred();
    this._lifecycleCleanups = [];
    this.connectedCalled = false;
    this._loadCalled = false;
    this.loadedCalled = false;
    this[_a] = true;
    this.ready = this._ready.promise;
    /*
     * Setting default exports to "this" so that controllers that don't use
     * exports/proxyExports(), could still be used as if they did
     * (i.e with controller.use)
     */
    this._exports = makeProvisionalValue(this);
    this._exportWatchers = /* @__PURE__ */ new Set();
    const resolvedComponent = toControllerHost(component ?? retrieveComponent(new.target.name));
    if (process.env.NODE_ENV !== "production") {
      Object.defineProperty(this, "component", {
        writable: false,
        enumerable: false,
        configurable: true,
        value: resolvedComponent
      });
      if ("hostDestroy" in this) {
        this.component.manager.ensureHasDestroy?.();
      }
    } else {
      this.component = resolvedComponent;
    }
    this.component.addController(this);
    const manager = this.component.manager;
    const isInControllerManager = manager === void 0;
    if (!isInControllerManager) {
      setParentController(this);
      queueMicrotask(() => this.catchUpLifecycle());
    }
  }
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    const { manager } = this.component;
    const connectedWillStillHappen = !manager.connectedCalled;
    if (!connectedWillStillHappen && !this.connectedCalled) {
      this.triggerConnected();
    }
    const loadWillStillHappen = !manager._loadCalled;
    if (loadWillStillHappen) {
      return;
    }
    this.triggerLoad().then(() => {
      const loadedWillStillHappen = !manager.loadedCalled;
      if (loadedWillStillHappen) {
        return;
      }
      this.triggerLoaded();
    }).catch(console.error);
  }
  get exports() {
    return this._exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports2) {
    const oldExports = this._exports;
    if (oldExports !== exports2) {
      this._exports = exports2;
      this._exportWatchers.forEach(import_components_utils3.safeCall);
      if (this.connectedCalled && this.assignedProperty !== false) {
        this.component.requestUpdate(this.assignedProperty, oldExports);
      }
    }
    this._ready.resolve(exports2);
  }
  setProvisionalExports(exports2, proxy2 = true) {
    this._exports = proxy2 ? makeProvisionalValue(exports2) : exports2;
    this._exportWatchers.forEach(import_components_utils3.safeCall);
  }
  watchExports(callback) {
    const safeCallback = () => callback(this._exports);
    this._exportWatchers.add(safeCallback);
    return () => void this._exportWatchers.delete(safeCallback);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    setAmbientComponent(this.component);
    return use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    setAmbientComponent(this.component);
    return useRef;
  }
  /**
   * Like useRef, but doesn't wait for the controller to get ready
   *
   * @internal
   */
  get useRefSync() {
    setAmbientComponent(this.component);
    return useRefSync;
  }
  controllerRemoved() {
    if (this.component.el.isConnected) {
      this.triggerDisconnected();
    }
    this.triggerDestroy();
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this._callbacks.hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this._callbacks.hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this._callbacks.hostLoad.push(callback);
  }
  onLoaded(callback) {
    this._callbacks.hostLoaded.push(callback);
  }
  onUpdate(callback) {
    this._callbacks.hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this._callbacks.hostUpdated.push(callback);
  }
  onDestroy(callback) {
    if (process.env.NODE_ENV !== "production" && (0, import_components_utils3.isEsriInternalEnv)()) {
      this.component.manager.ensureHasDestroy?.();
    }
    this._callbacks.hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this._callbacks.hostLifecycle.push(callback);
    if (this.connectedCalled && this.component.el.isConnected) {
      this._callLifecycle(callback);
    }
  }
  // Call each lifecycle hook
  /** @internal */
  triggerConnected() {
    const genericController = this;
    if (genericController.hostConnected) {
      (0, import_components_utils3.safeCall)(genericController.hostConnected, genericController);
    }
    this._callbacks.hostConnected.forEach(import_components_utils3.safeCall);
    this.triggerLifecycle();
    this.connectedCalled = true;
  }
  /** @internal */
  triggerDisconnected() {
    const genericController = this;
    if (genericController.hostDisconnected) {
      (0, import_components_utils3.safeCall)(genericController.hostDisconnected, genericController);
    }
    this._callbacks.hostDisconnected.forEach(import_components_utils3.safeCall);
    this._lifecycleCleanups.forEach(import_components_utils3.safeCall);
    this._lifecycleCleanups = [];
  }
  /** @internal */
  async triggerLoad() {
    if (this._loadCalled) {
      return;
    }
    this._loadCalled = true;
    const genericController = this;
    if (genericController.hostLoad) {
      await (0, import_components_utils3.safeAsyncCall)(genericController.hostLoad, genericController);
    }
    if (this._callbacks.hostLoad.length > 0) {
      await Promise.allSettled(this._callbacks.hostLoad.map(import_components_utils3.safeAsyncCall));
    }
    this._ready.resolve(this._exports);
  }
  /** @internal */
  triggerLoaded() {
    if (this.loadedCalled) {
      return;
    }
    const genericController = this;
    if (genericController.hostLoaded) {
      (0, import_components_utils3.safeCall)(genericController.hostLoaded, genericController);
    }
    this._callbacks.hostLoaded.forEach(import_components_utils3.safeCall);
    this.loadedCalled = true;
  }
  /** @internal */
  triggerUpdate(changes) {
    const genericController = this;
    if (genericController.hostUpdate) {
      (0, import_components_utils3.safeCall)(genericController.hostUpdate, genericController, changes);
    }
    this._callbacks.hostUpdate.forEach(callUpdate, changes);
  }
  /** @internal */
  triggerUpdated(changes) {
    const genericController = this;
    if (genericController.hostUpdated) {
      (0, import_components_utils3.safeCall)(genericController.hostUpdated, genericController, changes);
    }
    this._callbacks.hostUpdated.forEach(callUpdate, changes);
  }
  /** @internal */
  triggerDestroy() {
    const genericController = this;
    if (genericController.hostDestroy) {
      (0, import_components_utils3.safeCall)(genericController.hostDestroy, genericController);
    }
    this._callbacks.hostDestroy.forEach(import_components_utils3.safeCall);
  }
  /** @internal */
  triggerLifecycle() {
    const genericController = this;
    if (genericController.hostLifecycle) {
      this._callLifecycle(() => genericController.hostLifecycle());
    }
    this._callbacks.hostLifecycle.forEach(this._callLifecycle, this);
  }
  _callLifecycle(callback) {
    setAmbientComponent(this.component);
    const cleanupRaw = (0, import_components_utils3.safeCall)(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function") {
        this._lifecycleCleanups.push(cleanup2);
      } else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function") {
        this._lifecycleCleanups.push(cleanup2.remove);
      }
    });
  }
};
function callUpdate(callback) {
  (0, import_components_utils3.safeCall)(callback, void 0, this);
}
var GenericController = Controller;
function makeProvisionalValue(base) {
  if (typeof base !== "object" && typeof base !== "function" || base === null) {
    return base;
  }
  const proxy2 = new Proxy(base, {
    get(target, prop, receiver) {
      if (cyclical.has(prop) && prop in target && target[prop] === proxy2) {
        return void 0;
      }
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol") {
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      }
      if (process.env.NODE_ENV !== "production" && (0, import_components_utils3.isEsriInternalEnv)()) {
        if (process.env.NODE_ENV === "test" && (prop.startsWith("$$") || prop.startsWith("@@") || prop === "nodeType" || prop === "tagName" || prop === "toJSON" || prop === "hasAttribute")) {
          return;
        }
        console.error(
          `Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`
        );
      }
      return void 0;
    },
    set: (target, prop, newValue, receiver) => {
      if (process.env.NODE_ENV !== "production" && (0, import_components_utils3.isEsriInternalEnv)()) {
        console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      }
      return Reflect.set(target, prop, newValue, receiver);
    }
  });
  return proxy2;
}
var cyclical = /* @__PURE__ */ new Set(["exports", "_exports"]);
var accessBeforeLoad = process.env.NODE_ENV !== "production" && (0, import_components_utils3.isEsriInternalEnv)() ? [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("") : void 0;
function toControllerHost(component) {
  if (process.env.NODE_ENV !== "production" && (0, import_components_utils3.isEsriInternalEnv)()) {
    if ("addController" in component) {
      return component;
    } else {
      throw new Error(
        "Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line"
      );
    }
  } else {
    return component;
  }
}

// src/getSet.ts
var import_components_utils7 = require("@arcgis/components-utils");

// src/trackPropKey.ts
var import_components_utils6 = require("@arcgis/components-utils");

// src/framework.ts
var import_components_utils4 = require("@arcgis/components-utils");
var getMemberType = (component, name2) => component.manager.internals.members?.[name2]?.[0];

// src/ComponentInternals.ts
var import_components_utils5 = require("@arcgis/components-utils");
var customAccessor = Symbol();
var nothing = process.env.NODE_ENV !== "production" ? Symbol.for(
  // Use Symbol.for in dev mode to make it easier to maintain state when doing HMR.
  `${name}: nothing`
) : (
  // eslint-disable-next-line symbol-description
  Symbol()
);

// src/trackPropKey.ts
function trackPropKey(component, onResolved, defaultValue) {
  const internals = component.manager.internals;
  if (internals.trackedValue !== nothing && internals.trackedValue !== defaultValue) {
    internals.firePropTrackers(void 0, void 0);
  }
  if (internals.keyTrackers.length === 0) {
    queueMicrotask(() => internals.firePropTrackers(void 0, void 0));
  }
  internals.trackedValue = defaultValue;
  internals.keyTrackers.push((key, value) => (0, import_components_utils6.safeCall)(onResolved, void 0, defaultValue === value ? key : void 0));
  return defaultValue;
}

// src/getSet.ts
function bypassSetter(callback) {
  shouldBypass.setter = true;
  try {
    return callback();
  } finally {
    shouldBypass.setter = false;
  }
}
function bypassGetter(callback) {
  shouldBypass.getter = true;
  try {
    return callback();
  } finally {
    shouldBypass.getter = false;
  }
}

// src/readonly.ts
function bypassReadOnly(callback) {
  shouldBypass.readOnly = true;
  try {
    return callback();
  } finally {
    shouldBypass.readOnly = false;
  }
}

// src/trackPropertyKey.ts
var import_components_utils8 = require("@arcgis/components-utils");
function trackPropertyKey(object, onResolved, defaultValue) {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0) {
    queueMicrotask(keyTrackResolve);
  }
  keyTrackMap ?? (keyTrackMap = /* @__PURE__ */ new Map());
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => (0, import_components_utils8.safeCall)(onResolved, null, key2);
    const key = keys2[keyCount];
    if (key === void 0) {
      callback(void 0);
    } else if (object[key] === defaultValue) {
      callback(key);
    } else {
      callback(void 0);
    }
  });
  return defaultValue;
}
var keyTrackMap = void 0;
function keyTrackResolve() {
  Array.from(keyTrackMap?.entries() ?? []).forEach(([object, { callbacks }]) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
}

// src/trackKey.ts
function trackKey(hostsCandidates = [
  retrieveComponent(),
  ...retrieveParentControllers()
], onResolved, defaultValue) {
  const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
  let leftToResolve = candidateHosts.length + 1;
  const resolved = (resolution) => {
    leftToResolve -= 1;
    if (resolution !== void 0) {
      leftToResolve = Math.min(leftToResolve, 0);
    }
    if (leftToResolve === 0) {
      onResolved(resolution);
    }
  };
  candidateHosts.forEach(
    (host) => trackPropertyKey(
      host,
      (key) => resolved(
        key === void 0 ? void 0 : {
          key,
          host,
          isReactive: false
        }
      ),
      defaultValue
    )
  );
  const component = candidateHosts.find(
    (host) => "manager" in host && typeof host.manager === "object" && host.manager.component === host
  );
  if (component) {
    trackPropKey(
      component,
      (key) => resolved(
        key === void 0 ? void 0 : {
          key,
          host: component,
          isReactive: true
        }
      ),
      defaultValue
    );
  }
  return defaultValue;
}

// src/useWatch.ts
var import_components_utils9 = require("@arcgis/components-utils");
function watch(component, property, callback) {
  var _a2;
  const genericProperty = property;
  if (process.env.NODE_ENV !== "production" && (0, import_components_utils9.isEsriInternalEnv)()) {
    const type = getMemberType(component, genericProperty);
    if (type === void 0) {
      throw new Error(
        component.manager.isLit ? `Trying to watch a non-@property, non-@state property "${genericProperty}". Either convert it into a @state() to be able to use watch() on it, or use the get/set syntax` : `Trying to watch a non-@Prop, non-@State property "${genericProperty}". Convert it into a @State() or @Prop property if you need to use watch() on it`
      );
    }
  }
  const internals = component.manager.internals;
  (_a2 = internals.allWatchers)[genericProperty] ?? (_a2[genericProperty] = []);
  const watchers = internals.allWatchers[genericProperty];
  const genericCallback = callback;
  const safeCallback = (newValue, oldValue, propertyName) => (0, import_components_utils9.safeCall)(genericCallback, null, newValue, oldValue, propertyName);
  watchers.push(safeCallback);
  return () => {
    const index = watchers.indexOf(safeCallback);
    if (index !== -1) {
      watchers.splice(index, 1);
    }
  };
}

// src/proxyExports.ts
var proxyExports = (Class) => (...args) => {
  const ambientControllers2 = retrieveParentControllers();
  const instance = new Class(...args);
  const initialExports = instance.exports;
  setParentController(ambientControllers2.at(-1));
  const internals = instance.component.manager.internals;
  internals.markExports(instance, initialExports);
  instance.watchExports((exports2) => internals.markExports(instance, exports2));
  setAmbientChildController(instance);
  const hostCandidates = [instance.component, ...ambientControllers2].reverse();
  return trackKey(
    hostCandidates,
    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution, initialExports),
    initialExports
  );
};
function setProxy(controller, { host, key, isReactive: assignedToProp }, initialExports) {
  const genericHost = host;
  const controllerValueChanged = genericHost[key] !== controller.exports;
  const hostValueChanged = genericHost[key] !== initialExports;
  const controllerUpdatedExports = initialExports !== controller.exports;
  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports) {
    genericHost[key] = controller.exports;
  }
  const isProxyExportsOnComponent = host === controller.component;
  if (isProxyExportsOnComponent) {
    if (assignedToProp) {
      const internals = controller.component.manager.internals;
      if (hostValueChanged) {
        internals.markExports(controller, genericHost[key]);
      }
      watch(controller.component, key, (value) => {
        if (value !== controller.exports) {
          internals.markExports(controller, value);
        }
      });
    }
    controller.assignedProperty = assignedToProp ? void 0 : key;
  }
  controller.watchExports(() => {
    if (genericHost[key] === controller.exports) {
      return;
    }
    const manager = controller.component.manager;
    const isReadOnly = manager.internals.setters[key]?.includes(manager.internals.readonlySetter);
    if (isReadOnly) {
      bypassReadOnly(() => {
        genericHost[key] = controller.exports;
      });
    } else {
      genericHost[key] = controller.exports;
    }
  });
}

// src/accessor/utils.ts
var import_core_adapter = require("@arcgis/core-adapter");
var reactiveUtils;
async function loadReactiveUtils() {
  reactiveUtils ?? (reactiveUtils = (0, import_core_adapter.importCoreReactiveUtils)());
  return await reactiveUtils;
}

// src/accessor/useAccessor.ts
var import_components_utils10 = require("@arcgis/components-utils");
var makeAccessorController = (loadAccessor, _options) => (component, options) => proxy(component, loadAccessor, options);
var AccessorController = class extends GenericController {
  constructor(component, _loadAccessor, _options) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this._options = _options;
    // A mapping from bound component's "prop" name to Accessor instance's "property"
    this._watchedProperties = /* @__PURE__ */ new Map();
    this._isBinding = { value: true };
    this.setProvisionalExports(
      accessorSupport.makeGetterProxy(
        component,
        this._watchedProperties,
        this._isBinding,
        this.constructor.allowedPropNameMismatches
      )
    );
    trackPropKey(
      component,
      (resolved) => {
        if (resolved) {
          this._instancePropName = resolved;
        }
      },
      this.exports
    );
  }
  hostConnected() {
    this._isBinding.value = false;
  }
  async hostLoad() {
    this.reactiveUtils = await loadReactiveUtils();
    const component = this.component;
    const parameters = this._gatherParameters();
    const finalParameters = this._options?.editConstructorProperties?.call(component, parameters) ?? parameters;
    const awaitedParameters = finalParameters instanceof Promise ? await finalParameters : finalParameters;
    const genericComponent = component;
    const existingInstance = typeof this._instancePropName === "string" ? genericComponent[this._instancePropName] : void 0;
    const hasInstance = existingInstance != null && existingInstance !== this.exports;
    if (hasInstance) {
      this._instance = existingInstance;
      existingInstance.set(awaitedParameters);
    } else {
      this._instance = await this._createInstance(awaitedParameters);
    }
    if (component.manager.destroyed) {
      return;
    }
    accessorSupport.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorSupport.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  _gatherParameters() {
    const data = Object.fromEntries(
      Array.from(
        this._watchedProperties,
        ([prop, property]) => [property, this.component[prop]]
      ).filter(([, value]) => value !== void 0)
    );
    const props = process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)() ? filterWatchedProperties?.(this, data) ?? data : data;
    return props;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor)) {
      return new this._loadAccessor(parameters);
    } else {
      return await this._loadAccessor(parameters);
    }
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
  hostDestroy() {
    if (this._instance) {
      this._instance.destroy();
    }
  }
  async reCreate() {
    this.hostDestroy();
    await this.hostLoad();
  }
};
var proxy = proxyExports(AccessorController);
var accessorSupport = {
  makeGetterProxy: (component, watchedProperties, isBinding, allowedPropNameMismatches) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype) {
          return value;
        }
        const hasProp = prop in target;
        const doBinding = isBinding?.value ?? true;
        if (hasProp || !doBinding) {
          return value;
        }
        if (watchedProperties.has(prop)) {
          if (process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)() && !component.manager.isLit) {
            throw new Error(
              `Tried to bind "${prop.toString()}" prop twice. This might also happen if you are trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
            );
          }
          return;
        }
        return trackKey(
          component,
          (resolved) => {
            if (process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)()) {
              if (resolved === void 0) {
                if (component.manager.isLit) {
                  return;
                }
                throw new Error(
                  `Unable to resolve what property is "${prop.toString()}" being bound too. Check documentation for useAccessor to ensure proper usage. Make sure you are not trying to access the accessor instance before ${component.manager.isLit ? "load" : "componentWillLoad"}()`
                );
              }
              const isFlippingBoolean = resolved.key.toLowerCase().includes("disable");
              const collidesWithNativeProp = prop in HTMLElement.prototype;
              const collidesWithCustomProp = allowedPropNameMismatches?.has(prop) === true;
              if (resolved.key !== prop && !collidesWithNativeProp && !collidesWithCustomProp && !isFlippingBoolean) {
                throw new Error(
                  `Tried to bind "${resolved?.key}" property to "${prop.toString()}" - property names must match`
                );
              }
              if (!resolved.isReactive) {
                throw new Error(
                  component.manager.isLit ? `For two-way binding with Accessor to work, the property on your component must have @property() or @state() decorator. "${prop.toString()}" has neither` : `For two-way binding with Accessor to work, the property on your component must have @Prop() or @State() decorator. "${prop.toString()}" has neither`
                );
              }
            }
            if (resolved !== void 0) {
              watchedProperties.set(resolved.key, prop);
            }
          },
          value
        );
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    function getter(_value, propName) {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      return flipBoolean ? !value : value;
    }
    const setter = (newValue, _oldValue, propName) => {
      const propertyName = watchedProperties.get(propName);
      const value = instance[propertyName];
      const flipBoolean = typeof value === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
      const currentValue = flipBoolean ? !value : component.manager.isLit ? value ?? void 0 : value;
      if (currentValue === newValue) {
        return newValue;
      }
      instance[propertyName] = flipBoolean ? !newValue : newValue;
      const finalValue = instance[propertyName];
      return flipBoolean ? !finalValue : finalValue;
    };
    const component = controller.component;
    const internals = component.manager.internals;
    watchedProperties.forEach((_propName, propertyName) => {
      internals.accessorGetter[propertyName] = getter;
      internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    const genericComponent = component;
    const genericInstance = instance;
    const readonlyProps = findReadOnlyAccessorProps(instance);
    if (process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)()) {
      setReadonlyProps?.(controller, readonlyProps);
    }
    bypassGetter(
      () => (
        // Careful: Map's forEach callback arguments are (value, key), not (key, value)
        watchedProperties.forEach((propertyName, propName) => {
          if (process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)() && !(propertyName in instance)) {
            throw new Error(`"${propertyName}" does not exist on the accessor instance`);
          }
          if (readonlyProps.has(propertyName)) {
            return;
          }
          const domValue = genericComponent[propName];
          let modelValue = genericInstance[propertyName];
          if (component.manager.isLit) {
            modelValue ?? (modelValue = void 0);
          }
          const flipBoolean = typeof domValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
          const resolvedDomValue = flipBoolean ? !domValue : domValue;
          if (resolvedDomValue != null && modelValue !== resolvedDomValue) {
            genericInstance[propertyName] = resolvedDomValue;
          }
        })
      )
    );
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return Array.from(
        watchedProperties,
        ([propName, propertyName]) => controller.reactiveUtils.watch(
          () => genericInstance[propertyName],
          () => {
            const newValue = genericInstance[propertyName];
            const flipBoolean = typeof newValue === "boolean" && propertyName !== propName && propName.toLowerCase().includes("disable");
            const resolvedNewValue = flipBoolean ? !newValue : newValue;
            bypassSetter(() => {
              genericComponent[propName] = resolvedNewValue;
            });
          },
          { initial: true }
        )
      );
    });
  },
  // REFACTOR: remove this once Stencil is no longer supported
  reEmitAccessorEvents(controller, instance, reactiveUtils2, prefix) {
    const isEvented = "on" in instance && typeof instance.on === "function";
    if (!isEvented) {
      return;
    }
    const toListen = Object.entries(controller.component).map(([key, unknown]) => {
      const value = unknown;
      if (!key.startsWith(prefix) || key === prefix || typeof value !== "object" || value === null || !("emit" in value) || typeof value.emit !== "function") {
        return void 0;
      }
      const emit = value.emit;
      const trimmedEventName = key.slice(prefix.length);
      const camelCaseEventName = (0, import_components_utils10.camelToKebab)(trimmedEventName);
      const eventName = camelCaseEventName.toLowerCase();
      return [eventName, emit];
    }).filter(import_components_utils10.isNotUndefined);
    if (toListen.length === 0) {
      return;
    }
    const eventTarget = instance;
    const getEventTarget = () => eventTarget;
    controller.onLifecycle(() => {
      if (instance.destroyed) {
        return;
      }
      return toListen.map(([eventName, emit]) => reactiveUtils2.on(getEventTarget, eventName, emit));
    });
  },
  async reCreate(instance, component) {
    const accessorController = component.manager.useRefSync(instance);
    if (accessorController === void 0) {
      if (process.env.NODE_ENV !== "production") {
        console.error("Unable to resolve the useAccessor controller from the provided value");
      }
      return;
    }
    await accessorController.reCreate();
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
var setReadonlyProps = process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)() ? (controller, properties) => {
  devOnlySetPersistentControllerData?.(controller, properties);
} : void 0;
var filterWatchedProperties = process.env.NODE_ENV !== "production" && (0, import_components_utils10.isEsriInternalEnv)() ? (controller, data) => {
  const readonlyProperties = devOnlyGetPersistentControllerData?.(controller);
  if (readonlyProperties instanceof Set) {
    return Object.fromEntries(Object.entries(data).filter(([key]) => !readonlyProperties.has(key)));
  }
  return data;
} : void 0;

// src/accessor/reEmitEvent.ts
var import_components_utils11 = require("@arcgis/components-utils");
function reEmitEvent(getEventedAccessor, eventName) {
  const component = retrieveComponent();
  if (process.env.NODE_ENV !== "production" && (0, import_components_utils11.isEsriInternalEnv)() && !component.manager.isLit) {
    throw new Error(
      "reEmitEvent is only supported in Lumina components. Consult documentation for equivalent Stencil pattern."
    );
  }
  const manager = component.manager;
  const reactiveUtils2 = loadReactiveUtils();
  manager.onLoaded(() => {
    void reactiveUtils2.then(
      (reactiveUtils3) => manager.onLifecycle(() => reactiveUtils3.on(getEventedAccessor, eventName, emitter.emit))
    );
  });
  const emitter = component.constructor.$createEvent();
  if (process.env.NODE_ENV !== "production" && (0, import_components_utils11.isEsriInternalEnv)()) {
    if (typeof emitter !== "object" || emitter === null || !("emit" in emitter) || typeof emitter.emit !== "function") {
      throw new Error(`Expected to find $createEvent static property on Lumina's LitElement`);
    }
  }
  return emitter;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccessorController,
  accessorSupport,
  makeAccessorController,
  reEmitEvent
});
