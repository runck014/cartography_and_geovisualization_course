import {
  ComponentInternals,
  Controller,
  GenericController,
  bypassGetter,
  bypassReadOnly,
  bypassSetter,
  controllerSymbol,
  devOnlySetPersistentControllerData,
  dynamicGetSet,
  elementToInstance,
  getSet,
  isController,
  keyTrackResolve,
  proxyExports,
  readonly,
  retrieveComponent,
  retrieveParentControllers,
  setAmbientComponent,
  setParentController,
  trackKey,
  trackPropKey,
  trackPropertyKey,
  watch
} from "./chunk-PP2BAVRW.js";
import {
  retrieveComponentMembers
} from "./chunk-XKVBN44N.js";

// src/ControllerManager.ts
import { Deferred, isEsriInternalEnv, safeAsyncCall, safeCall } from "@arcgis/components-utils";
import { devToolsAwareTimeout } from "@arcgis/components-utils";
var useControllerManager = (component, forceUpdate) => new ControllerManager(component, forceUpdate);
var ControllerManager = class extends GenericController {
  constructor(component, forceUpdate) {
    const isLit = "addController" in component;
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && !isLit) {
      Object.defineProperty(component.el, "__component", {
        value: component
      });
      ({});
    }
    const controllers = /* @__PURE__ */ new Set();
    function addController(controller) {
      controllers.add(controller);
      if (!(controllerSymbol in controller) && component.renderRoot && component.el.isConnected) {
        controller.hostConnected?.();
      }
    }
    function removeController(controller) {
      void controllers.delete(controller);
      controller.controllerRemoved?.();
    }
    const controllerHost = component;
    controllerHost.addController = addController;
    controllerHost.removeController = removeController;
    if (!isLit) {
      const update = forceUpdate ?? component.constructor.__forceUpdate;
      controllerHost.requestUpdate = () => update(component);
    }
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      const stencilToLitMapping = {
        componentDidLoad: "loaded",
        componentDidRender: "updated",
        componentDidUpdate: "updated",
        componentShouldUpdate: "shouldUpdate",
        componentWillLoad: "load",
        componentWillRender: "willUpdate",
        componentWillUpdate: "willUpdate"
      };
      Object.entries(stencilToLitMapping).forEach(([stencilMethod, litMethod]) => {
        if (isLit && stencilMethod in component) {
          throw new Error(
            `Unexpected ${stencilMethod}() in a Lit component ${component.el.tagName.toLowerCase()}. In Lit, you should use ${litMethod}() instead`
          );
        }
        if (!isLit && litMethod in component) {
          throw new Error(
            `Unexpected ${litMethod}() in a Stencil component ${component.el.tagName.toLowerCase()}. In Stencil, you should use ${litMethod}() instead`
          );
        }
      });
      if (isLit) {
        let i = 0;
        let isLitElementClass = false;
        for (let prototype = component; !isLitElementClass; i++) {
          if (prototype === null) {
            throw new Error("Expected controllers to be used in a LitElement class");
          }
          if (Object.hasOwn(prototype, "_load")) {
            isLitElementClass = true;
            break;
          }
          prototype = Object.getPrototypeOf(prototype);
        }
        if (i < 1) {
          throw new Error(
            "It looks like you are trying to call useControllerManager in a component that uses LitElement imported from 'lit'. useControllerManager should only be used in the LitElement coming from `@arcgis/lumina`"
          );
        }
      }
    }
    super(component);
    /** @internal */
    this.internals = new ComponentInternals(this.component);
    this.destroyed = false;
    this._updatePromise = new Deferred();
    this._originalLifecycles = {};
    this.isLit = isLit;
    this.component.manager = this;
    retrieveComponentMembers(component, isLit);
    this._controllers = controllers;
    this.exports = void 0;
    this.hasDestroy = autoDestroyDisabledPropName in this.component && typeof this.component.destroy === "function";
    this._bindLifecycleMethods();
    const internals = this.internals;
    Object.keys(internals.members).forEach((name) => {
      internals.accessorGetter[name] = defaultGetterSetter;
      internals.accessorSetter[name] = defaultGetterSetter;
      internals.getSetProxy(name);
    });
    if (isLit) {
      this.internals.enabledWatchers = this.internals.allWatchers;
    } else {
      Object.defineProperty(component, "updateComplete", {
        get: async () => await this._updatePromise.promise
      });
    }
    queueMicrotask(internals.enableReadonly);
    setAmbientComponent(component);
    elementToInstance.set(component.el, component);
    elementToInstance.set(component, component);
  }
  _bindLifecycleMethods() {
    const component = this.component;
    const isLit = this.isLit;
    const isStencilDistBuild = component.el === component;
    this._originalLifecycles = {
      // These component's callbacks will be called by Lit, so we don't have to
      _connectedCallback: isLit || isStencilDistBuild ? void 0 : component.connectedCallback,
      _disconnectedCallback: isLit || isStencilDistBuild ? void 0 : component.disconnectedCallback,
      _load: isLit ? component.load : component.componentWillLoad,
      _loaded: isLit ? component.loaded : component.componentDidLoad,
      _willUpdate: isLit ? void 0 : component.componentWillUpdate,
      _updated: isLit ? void 0 : component.componentDidUpdate,
      _destroy: component.destroy
    };
    const hostConnected = this._connectedCallback.bind(this);
    const hostDisconnected = this._disconnectedCallback.bind(this);
    const hostUpdate = this._update.bind(this);
    const hostUpdated = this._updated.bind(this);
    if (isLit) {
      component.constructor.prototype.addController.call(component, {
        // Lit will call these callbacks
        hostConnected,
        hostDisconnected,
        hostUpdate,
        hostUpdated
      });
    } else {
      component.connectedCallback = hostConnected;
      component.disconnectedCallback = hostDisconnected;
      component.componentWillLoad = this._load.bind(this);
      component.componentDidLoad = this._loaded.bind(this);
      component.componentWillUpdate = hostUpdate;
      component.componentDidUpdate = hostUpdated;
    }
    if (this.hasDestroy) {
      component.destroy = this.destroy.bind(this);
    }
  }
  /**
   * Private because this is not supposed to be called by Component directly.
   * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
   * calling lifecycle methods twice.
   *
   * @internal
   */
  _connectedCallback() {
    if (this.destroyed) {
      const tagName = this.component.el.tagName.toLowerCase();
      this.component.el.remove();
      throw new Error(
        `The ${tagName} component has already been destroyed. It cannot be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${autoDestroyDisabledPropName} prop.`
      );
    }
    if (this._autoDestroyTimeout !== void 0) {
      clearTimeout(this._autoDestroyTimeout);
    }
    const internals = this.internals;
    internals.enabledWatchers = internals.allWatchers;
    keyTrackResolve();
    internals.enableReadonly?.();
    this._controllers.forEach(callConnected);
    this._originalLifecycles._connectedCallback?.call(this.component);
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      devOnlySetPersistentControllerData?.(this, true);
    }
  }
  /** @internal */
  _disconnectedCallback() {
    if (this.destroyed) {
      return;
    }
    this._controllers.forEach(callDisconnected);
    this._originalLifecycles._disconnectedCallback?.call(this.component);
    if (this.hasDestroy) {
      this._setAutoDestroyTimeout();
    }
  }
  /** @internal */
  async _load() {
    await Promise.allSettled(Array.from(this._controllers, callLoad));
    await this._originalLifecycles._load?.call(this.component);
    if (this.hasDestroy) {
      watch(this.component, autoDestroyDisabledPropName, () => this._setAutoDestroyTimeout());
    }
  }
  /** @internal */
  _loaded() {
    this._controllers.forEach(callLoaded);
    this._originalLifecycles._loaded?.call(this.component);
  }
  _update() {
    const maybeLitComponent = this.component;
    this._controllers.forEach(callUpdate, maybeLitComponent.$changes);
    return this._originalLifecycles._willUpdate?.call(this.component);
  }
  _updated() {
    const maybeLitComponent = this.component;
    this._controllers.forEach(callUpdated, maybeLitComponent.$changes);
    this._originalLifecycles._updated?.call(this.component);
    if (this.isLit) {
      maybeLitComponent.$changes = /* @__PURE__ */ new Map();
    } else {
      const updatePromise = this._updatePromise;
      this._updatePromise = new Deferred();
      updatePromise.resolve(true);
    }
  }
  async destroy() {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      this.ensureHasDestroy?.();
    }
    if (this.destroyed) {
      return;
    }
    if (this.component.el.isConnected) {
      this.hasDestroy = false;
      try {
        this.component.el.remove();
      } finally {
        this.hasDestroy = true;
      }
    }
    this._autoDestroyTimeout = void 0;
    this.destroyed = true;
    this._controllers.forEach(callDestroy);
    this._controllers.clear();
    await this._originalLifecycles._destroy?.call(this.component);
  }
  _setAutoDestroyTimeout() {
    if (this._autoDestroyTimeout !== void 0) {
      clearTimeout(this._autoDestroyTimeout);
    }
    if (!this.component.el.isConnected && !this.component.autoDestroyDisabled) {
      const destroy = () => void this.destroy().catch(console.error);
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && autoDestroyOnDisconnectTimeout === 0) {
        queueMicrotask(destroy);
      } else {
        this._autoDestroyTimeout = devToolsAwareTimeout(destroy, autoDestroyOnDisconnectTimeout);
      }
    }
  }
};
if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
  ControllerManager.prototype.ensureHasDestroy = function ensureHasDestroy() {
    if (!this.hasDestroy) {
      throw new Error(
        `
          If the component uses a controller that uses destroy() method, then the
          component must have the following properties:
          /**
           * If true, the component will not be destroyed automatically when it is
           * disconnected from the document. This is useful when you want to move the
           * component to a different place on the page, or temporarily hide it. If this
           * is set, make sure to call the \`destroy\` method when you are done to prevent
           * memory leaks.
           */
          @${this.isLit ? "property" : "Prop"}() ${autoDestroyDisabledPropName} = false;
          
          /** Permanently destroy the component */
          @${this.isLit ? "method" : "Method"}()
          async destroy(): Promise<void> {
            await this.manager.destroy();
          }
          `.trim().split("\n").map((line) => line.trim()).join("\n")
      );
    }
  };
}
var autoDestroyDisabledPropName = "autoDestroyDisabled";
var autoDestroyOnDisconnectTimeout = 1e3;
var exportsForTests = process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? {
  setAutoDestroyOnDisconnectTimeout: (timeout) => {
    autoDestroyOnDisconnectTimeout = timeout;
  }
} : void 0;
var defaultGetterSetter = (value) => value;
function callConnected(controller) {
  if ("triggerConnected" in controller) {
    controller.triggerConnected();
  } else {
    safeCall(controller.hostConnected, controller);
  }
}
function callDisconnected(controller) {
  if ("triggerDisconnected" in controller) {
    controller.triggerDisconnected();
  } else {
    safeCall(controller.hostDisconnected, controller);
  }
}
async function callLoad(controller) {
  if ("triggerLoad" in controller) {
    await controller.triggerLoad();
  } else {
    await safeAsyncCall(controller.hostLoad, controller);
  }
}
function callLoaded(controller) {
  if ("triggerLoaded" in controller) {
    controller.triggerLoaded();
  } else {
    safeCall(controller.hostLoaded, controller);
  }
}
function callUpdate(controller) {
  if ("triggerUpdate" in controller) {
    controller.triggerUpdate(this);
  } else {
    safeCall(controller.hostUpdate, controller, this);
  }
}
function callUpdated(controller) {
  if ("triggerUpdated" in controller) {
    controller.triggerUpdated(this);
  } else {
    safeCall(controller.hostUpdated, controller, this);
  }
}
function callDestroy(controller) {
  if ("triggerDestroy" in controller) {
    controller.triggerDestroy();
  } else {
    safeCall(controller.hostDestroy, controller);
  }
}

// src/functional.ts
var makeController = (constructor) => proxy(void 0, constructor);
var makeGenericController = (constructor) => (component) => proxy(
  component,
  /**
   * GenericController is identical to Controller, in all except for typing.
   * So dying a type-cast here so as not to needlessly add one more object
   * to the prototype chain
   */
  constructor
);
var FunctionalController = class extends Controller {
  constructor(component, constructor) {
    super(component);
    const originalExports = this.exports;
    try {
      setAmbientComponent(this.component);
      const value = constructor(this.component, this);
      const constructorChangedExports = this.exports !== originalExports;
      if (value instanceof Promise) {
        if (!constructorChangedExports) {
          this.setProvisionalExports(value);
        }
        const resolved = value.then((result) => {
          this.exports = result;
          super.catchUpLifecycle();
        }).catch((error) => {
          this._ready.reject(error);
          console.error(error);
        });
        this.onLoad(async () => await resolved);
      } else {
        if (!constructorChangedExports || value !== void 0) {
          this.exports = value;
        }
        queueMicrotask(() => super.catchUpLifecycle());
      }
    } catch (error) {
      this._ready.reject(error);
      console.error(error);
    }
  }
  /** Noop - will be called in the constructor instead */
  catchUpLifecycle() {
    return;
  }
};
var proxy = proxyExports(FunctionalController);

// src/useWatchAttributes.ts
var useWatchAttributes = (attributes, callback) => new AttributeWatchController(attributes, callback);
var AttributeWatchController = class extends Controller {
  constructor(_attributes, _callback) {
    super();
    this._attributes = _attributes;
    this._callback = _callback;
    this._observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (_attributes.includes(mutation.attributeName)) {
          _callback.call(
            this.component,
            this.component.el.getAttribute(mutation.attributeName),
            mutation.oldValue,
            mutation.attributeName
          );
        }
      });
    });
  }
  hostConnected() {
    this._attributes.forEach((attribute) => {
      if (this.component.el.hasAttribute(attribute)) {
        this._callback.call(this.component, null, this.component.el.getAttribute(attribute), attribute);
      }
    });
    this._observer.observe(this.component.el, {
      attributes: true,
      attributeOldValue: true,
      attributeFilter: this._attributes
    });
  }
  hostDisconnected() {
    this._observer.disconnect();
  }
};

// src/load.ts
var load = makeController;

// src/toFunction.ts
var toFunction = (Class) => (...args) => {
  const ambientControllers = retrieveParentControllers();
  const instance = new Class(...args);
  setParentController(ambientControllers.at(-1));
  return instance;
};

// src/useMedia.ts
var useMedia = (query) => makeController((_component, controller) => {
  const media = globalThis.matchMedia(query);
  function changed() {
    controller.exports = media.matches;
  }
  changed();
  controller.onLifecycle(() => {
    media.addEventListener("change", changed);
    return () => media.removeEventListener("change", changed);
  });
  return void 0;
});

// src/useDirection.ts
import { getElementAttribute, isEsriInternalEnv as isEsriInternalEnv2, observeAncestorsMutation } from "@arcgis/components-utils";
var defaultDirection = "ltr";
var useDirection = () => makeController((component, controller) => {
  controller.exports = defaultDirection;
  controller.onLifecycle(() => {
    function callback() {
      const dir = getElementAttribute(component.el, "dir", defaultDirection);
      controller.exports = dir === "rtl" ? "rtl" : "ltr";
    }
    callback();
    return observeAncestorsMutation(component.el, ["dir"], callback);
  });
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv2()) {
    trackKey(
      component,
      (resolved) => {
        if (resolved?.key === "dir") {
          throw new Error(
            `Do not assign this controller to a prop called \`dir\` as that will overwrite the \`dir\` attribute on the host element - component should not be setting the \`dir\` attribute on itself. Instead, assign this controller to a property called \`direction\`.`
          );
        }
      },
      controller.exports
    );
  }
  return void 0;
});

// src/useT9n.ts
import { getElementLocales, startLocaleObserver } from "@arcgis/components-utils";
var makeT9nController = (getAssetPath) => (options = {}) => (
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  makeController((component, controller) => {
    const locale = getElementLocales(component.el);
    const pending = {
      _lang: locale.lang,
      _t9nLocale: locale.t9nLocale,
      _loading: true
    };
    const componentWithOverrides = component;
    controller.onLifecycle(
      () => startLocaleObserver(
        component.el,
        () => getAssetPath("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          const withoutOverrides = {
            ...t9nStrings,
            _lang: lang,
            _t9nLocale: t9nLocale,
            _loading: false
          };
          controller.exports = withoutOverrides;
          const label = t9nStrings.componentLabel;
          if (typeof label === "string" && "label" in component && component.label == null) {
            component.label ?? (component.label = label);
          }
          applyOverrides(componentWithOverrides.messageOverrides);
        },
        options.name
      )
    );
    function applyOverrides(messageOverrides) {
      const currentValue = controller.exports;
      const rawMessages = currentValue._original ?? currentValue;
      const updated = deepMerge(rawMessages, messageOverrides);
      if (messageOverrides) {
        updated._original = rawMessages;
      }
      controller.exports = updated;
    }
    if ("messageOverrides" in componentWithOverrides) {
      controller.onLifecycle(() => watch(componentWithOverrides, "messageOverrides", applyOverrides));
    }
    if (options.blocking) {
      controller.setProvisionalExports(pending, false);
      return controller.ready;
    } else {
      return pending;
    }
  })
);
function deepMerge(original, overwrites) {
  if (!overwrites) {
    return original;
  }
  const merged = { ...original };
  Object.entries(overwrites).forEach(([key, value]) => {
    if (typeof value === "object") {
      merged[key] = deepMerge(original[key], value);
    } else {
      merged[key] = value ?? original[key];
    }
  });
  return merged;
}

// src/usePropertyChange.ts
import { isEsriInternalEnv as isEsriInternalEnv3 } from "@arcgis/components-utils";
var usePropertyChange = (_component) => propertyChangeController;
var eventName = "arcgisPropertyChange";
function propertyChangeController(...toWatch) {
  const component = retrieveComponent();
  const eventedComponent = component;
  let eventEmitter = eventedComponent[eventName];
  if (component.manager.isLit) {
    eventEmitter = component.constructor.$createEvent(eventName, void 0, component);
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv3()) {
      if (typeof eventEmitter !== "object" || eventEmitter === null || !("emit" in eventEmitter) || typeof eventEmitter.emit !== "function") {
        throw new Error(`Expected to find $createEvent static property on Lumina's LitElement"`);
      }
    }
  }
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv3()) {
    if (typeof eventEmitter !== "object" || eventEmitter === null || !("emit" in eventEmitter) || typeof eventEmitter.emit !== "function") {
      throw new Error(
        `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property that has an @Event() decorator`
      );
    }
    const allProps = new Set(
      Object.entries(component.manager.internals.members).filter(([_name, [propType]]) => (propType & 31 /* Prop */) !== 0).map(([name]) => name)
    );
    toWatch.forEach((prop) => {
      if (!allProps.has(prop)) {
        throw new Error(
          prop in component ? `For usePropertyChange to emit event on "${prop}" property change, you should add @${component.manager.isLit ? "property" : "Prop"}() to ${prop} in ${component.el.tagName.toLowerCase()}` : `usePropertyChange can't emit event on "${prop}" property change as such property does not exist in ${component.el.tagName.toLowerCase()}`
        );
      }
    });
  }
  component.manager.onLoad(
    () => component.manager.onLifecycle(
      () => toWatch.map(
        (name) => (
          // Casting to 'el' to simplify dynamic prop name typing
          watch(component, name, () => eventEmitter.emit({ name }))
        )
      )
    )
  );
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv3() && component.manager.isLit) {
    trackKey(
      component,
      (resolution) => {
        if (resolution === void 0 || resolution.isReactive || resolution.key !== eventName) {
          throw new Error(
            `For consistency, usePropertyChange must be assigned to an arcgisPropertyChange property and that property should not have @property() or @state() decorators: arcgisPropertyChange = usePropertyChange<this>()("prop1", "prop2");`
          );
        }
      },
      eventEmitter
    );
  }
  return eventEmitter;
}
export {
  Controller,
  GenericController,
  bypassGetter,
  bypassReadOnly,
  bypassSetter,
  controllerSymbol,
  dynamicGetSet,
  getSet,
  isController,
  keyTrackResolve,
  load,
  makeController,
  makeGenericController,
  makeT9nController,
  proxyExports,
  readonly,
  retrieveComponent,
  toFunction,
  trackKey,
  trackPropKey,
  trackPropertyKey,
  useControllerManager,
  useDirection,
  useMedia,
  usePropertyChange,
  useWatchAttributes,
  watch
};
