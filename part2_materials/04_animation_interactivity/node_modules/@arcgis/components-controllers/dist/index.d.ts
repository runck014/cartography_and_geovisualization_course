import { B as BaseComponent, a as BaseController, T as TrackKeyResolution, C as ControllerHost, b as Controller, G as GenericControllerType, c as ControllerLifecycleMethods, E as EventEmitter } from './Controller-oDdp0LxM.js';
export { e as ControllerManager, d as GenericController, g as LitElementWithChangedPropertiesMap, L as LitElementWithCreateEventFactory, h as LuminaPropertyDeclaration, S as StencilLifecycles, U as Use, f as controllerSymbol, r as retrieveComponent, u as useControllerManager } from './Controller-oDdp0LxM.js';
import { GenericT9nStrings, LocaleObserver } from '@arcgis/components-utils';
import 'lit';

/**
 * A magical solution to finding out what property name a given controller
 * on a given object was assigned to.
 *
 * @remarks
 * This does not work for properties that have \@Prop() or \@State()
 * decorator - for those, use manager.trackPropKey() instead.
 *
 * @example
 * function trackMe<T>(defaultValue:T, component:BaseComponent):T {
 *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);
 *   return defaultValue;
 * }
 *
 * class MyComponent extends BaseComponent {
 *   // Will console log "myProp"
 *   myProp = trackMe('a', this);
 * }
 *
 */
declare function trackPropertyKey<T>(object: BaseComponent | BaseController, onResolved: (key: string | undefined) => void, defaultValue: T): T;
/**
 * Resolve all pending trackPropertyKey() calls. This must be called after a
 * property you are trying to resolve had it's default value set, thus after
 * constructor. At the start of connectedCallback is a perfect place.
 */
declare function keyTrackResolve(): void;

/**
 * Like manager.trackPropertyKey(), but for props that have \@State() or \@Prop()
 * decorator
 *
 * @example
 * function trackMe() {
 *   const component = retrieveComponent();
 *   const defaultValue = 'some value';
 *   return trackPropKey(component, (key)=>console.log(key), defaultValue);
 * }
 *
 * class MyComponent extends BaseComponent {
 *   // Will console log "myProp"
 *   @Prop() myProp = trackMe();
 *
 *   // Will console log "myState"
 *   @State() myState = trackMe();
 * }
 */
declare function trackPropKey<T>(component: BaseComponent, onResolved: (key: string | undefined) => void, defaultValue: T): T;

/**
 * A combination of trackPropertyKey() and trackPropKey(). For usage when
 * you want to track a property, but don't know if it will be defined with the
 * \@Prop() decorator or not
 */
declare function trackKey<T>(hostsCandidates: ((BaseComponent | BaseController)[] | BaseComponent | BaseController) | undefined, onResolved: (resolution: TrackKeyResolution | undefined) => void, defaultValue: T): T;

/**
 * Controller is a function that takes a component instance and then can
 * export some values to the component, or hook into component's lifecycle
 *
 * See controllers documentation for many example controllers and their usages
 */
declare const makeController: <Exports>(constructor: (component: BaseComponent & ControllerHost, controller: Controller<Exports>) => Exports | Promise<Exports>) => Exports;
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in the BaseComponent, use
 * makeGenericController
 *
 * When using a controller created using makeGenericController(), consumer must
 * pass in "this" explicitly for proper type-checking. If controller was
 * created using makeController(), that is not necessary
 */
declare const makeGenericController: <Exports, Component = BaseComponent>(constructor: (component: BaseComponent & Component & ControllerHost, controller: GenericControllerType<Exports, Component>) => Exports | Promise<Exports>) => (component: BaseComponent & Component) => Exports;

/**
 * Make a @Prop() or @State() readonly (prevent overwriting default value).
 *
 * For internal properties, prefer TypeScript's "readonly" modifier instead.
 *
 * @example
 * ```ts
 * // Defining readonly prop
 * @Prop({ reflect: true }) prop = readonly('a');
 * ```
 *
 * @example
 * ```ts
 * // Overwriting readonly prop internally
 * bypassReadOnly(()=>{
 *   this.prop = 'b';
 * });
 * ```
 *
 */
declare function readonly<T>(value: T): T;
/**
 * Like bypassSetter(), but only bypasses readonly(), rather that
 * all setters set using getSet()
 */
declare function bypassReadOnly<T = void>(callback: () => T): T | void;

/**
 * Listen for any component's @State()/@Prop() change, and mutate it's
 * value before it is set.
 * This is necessary because Stencil's Compiler does not support get/set for
 * @State()/@Prop().
 * For private component properties, you should use regular get/set syntax.
 *
 * @example
 * ```tsx
 * @Prop() exampleProp = getSet(defaultValue,{get,set})
 * @Prop() someProp = getSet(
 *   undefined as string | undefined,
 *   {
 *     get: (value)=>value.trim(),
 *     set: (newValue,oldValue) => newValue.trim() ?? oldValue
 *   }
 * )
 * ```
 *
 * @remarks
 * Unlike a native get/set, the get function receives the current attribute
 * value, and can modify it before returning it (or can disregard the current
 * value and get it from elsewhere instead).
 * Similarly, setter is called with the new and old value, and is expected to
 * return the final new value (or return the old value to undo the change)
 */
declare function getSet<T>(
/**
 * Default value is used only if user did not set a value in the DOM before
 * component was loaded
 */
defaultValue: T, getSet: {
    get?(newValue: T, propertyName: string): T;
    set(newValue: T, oldValue: T, propertyName: string): T;
} | {
    get(newValue: T, propertyName: string): T;
    set?(newValue: T, oldValue: T, propertyName: string): T;
} | {
    get(newValue: T, propertyName: string): T;
    set: "ignore";
}): T;
/**
 * Like getSet(), but can be called on any component's
 * state/prop from anywhere, rather than just from the default value
 */
declare const dynamicGetSet: <Component extends BaseComponent, Property extends keyof (BaseComponent & Component)>(component: Component, property: Property, getSet: {
    get?(newValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
    set(newValue: (BaseComponent & Component)[Property], oldValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
} | {
    get(newValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
    set?(newValue: (BaseComponent & Component)[Property], oldValue: (BaseComponent & Component)[Property], propertyName: Property): (BaseComponent & Component)[Property];
}) => void;
/**
 * If you need to set a prop/state without triggering the custom setter you
 * defined with getSet()/dynamicGetSet()/readonly(), set the value inside
 * of this function
 *
 * @example
 * ```tsx
 * @Prop() readOnly = readOnly(true);
 *
 * someAction(): void {
 *   bypassSetter(()=>{
 *     this.readOnly = false;
 *   });
 * }
 * ```
 *
 */
declare function bypassSetter<T = void>(callback: () => T): T | void;
/**
 * Property reads inside of this function will bypass any custom getter you
 * may have, and read the value directly from what's stored in Stencil/Lit.
 *
 * This also bypasses reactiveUtils integration - reading a property inside of
 * bypassGetter won't make that property tracked.
 *
 * @example
 * ```tsx
 * reactiveUtils.watch(
 *   ()=>{
 *     bypassGetter(()=>{
 *       console.log(this.someProp);
 *     });
 *     return this.prop;
 *   },
 *   console.log
 * );
 * ```
 */
declare function bypassGetter<T = void>(callback: () => T): T | void;

/**
 * Dynamically set a watcher for any reactive property
 *
 * @example
 * ```ts
 * this.manager.onLifecycle(()=>
 *   watch(this, "myProp", (newValue,oldValue)=>console.log(newValue,oldValue))
 * )
 * ```
 *
 * @remarks
 * If you are in Lit, you should prefer the willUpdate() lifecycle method
 * over watch(). willUpdate() is going to be more memory-efficient, and more
 * flexible (can watch multiple props at once or provide dynamic prop name)
 *
 * ```ts
 * willUpdate(changes: PropertyValues<this>) {
 *   if (changes.has('firstName') || changes.has('lastName')) {
 *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
 *   }
 * }
 * ```
 */
declare function watch<Component extends BaseComponent, Property extends keyof Component>(component: Component, property: Property, callback: (newValue: Component[Property], oldValue: Component[Property], property: Property) => void): () => void;

/**
 * Watch when given attributes change on the component element.
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/useWatchAttributes
 */
declare const useWatchAttributes: <T extends string>(attributes: readonly T[], callback: (newValue: string | null, oldValue: string | null, attribute: T) => void) => Controller;

/**
 * Load a value from a promise and provide it to the component
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/load
 */
declare const load: <T>(loader: () => Promise<T>) => T;

/**
 * If you wish to directly expose the "exports" property of your controller,
 * rather than the entire controller class, wrap your class definition in
 * "proxyExports".
 *
 * This is especially convenient when your exports is not an object, or it is a
 * dynamically created object, and so you don't want your Controller's methods
 * interfering with the keys on the exported value.
 *
 * "proxyExports" is the default behavior for all controllers declared using
 * the makeController()/makeGenericController() function
 *
 * @remarks
 * If using readonly(), and controller updates its exports, the readonly prop
 * will still get updated
 *
 * @remarks
 * (Advanced) If you wish to use proxyExports() in a class that does not
 * extend Controller class and does not have a useControllerManager(), then your
 * class must subclass a class with the following constructor:
 * `constructor() { setAmbientController(this); }`. This
 * is necessary for proxyExports() to receive a reference to your object
 * implicitly, and before any of your default values are assigned.
 */
declare const proxyExports: <Exports, const Parameters extends unknown[]>(Class: new (...args: Parameters) => ControllerLifecycleMethods & Pick<Controller<Exports>, "component" | "exports" | "watchExports">) => ((...args: Parameters) => Exports);

/**
 * A tiny helper for using a class-based controller as if it's a function.
 * Main advantage of this is that it's a bit shorter to type.
 *
 * This utility can be used for converting non-controller classes to functions
 * too
 */
declare const toFunction: <T, const P extends unknown[]>(Class: new (...args: P) => T) => ((...args: P) => T);

/**
 * Lets you query whether a given CSS media query applies to the page (i.e.
 * whether user asked to use reduced motion, or whether the screen size is above
 * certain threshold).
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/useMedia
 */
declare const useMedia: (query: string) => boolean;

type Direction = "ltr" | "rtl";
/**
 * Finds the closest "dir" attribute to current component and returns it's value.
 * Watches for changes to "dir" and will re-render your component if needed.
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/useDirection
 */
declare const useDirection: () => Direction;

type T9nMeta<T9nStrings extends GenericT9nStrings> = {
    _lang: LocaleObserver["lang"];
    _t9nLocale: LocaleObserver["t9nLocale"];
    _loading: boolean;
    /**
     * The "_overrides" property won't actually exist at runtime and exists only
     * to simplify typing like so:
     *
     * @example
     * ```ts
     * // Type of the messageOverrides is set automatically based on _overrides:
     *   @Prop() messageOverrides?: typeof this.messages._overrides;
     * ```
     */
    _overrides: DeepPartial<T9nStrings>;
    /**
     * If messageOverrides are in effect, this will contain original strings
     */
    _original?: T9nStrings;
};
type DeepPartial<T> = T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T;
type Options = {
    readonly name?: string | null;
    /** @default false */
    readonly blocking?: boolean;
};
interface UseT9n {
    <Strings extends GenericT9nStrings>(options: Options & {
        readonly blocking: true;
    }): Strings & T9nMeta<Strings>;
    <Strings extends GenericT9nStrings>(options?: Options & {
        readonly blocking?: false;
    }): Partial<Strings> & T9nMeta<Strings>;
}
/**
 * Load component's localization strings.
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/useT9n
 */
declare const makeT9nController: (getAssetPath: (path: string) => string) => UseT9n;

type PropertyChangeController<Component extends BaseComponent> = <ToWatch extends keyof Component>(...toWatch: ToWatch[]) => EventEmitter<{
    name: ToWatch & string;
}>;
/**
 * Let user easily set watchers for component properties.
 *
 * Documentation: https://qawebgis.esri.com/components/lumina/controllers/usePropertyChange
 */
declare const usePropertyChange: <Component extends BaseComponent>(_component?: BaseComponent) => PropertyChangeController<Component>;

declare const isController: (value: unknown) => value is ControllerLifecycleMethods;

export { BaseComponent, BaseController, Controller, ControllerHost, ControllerLifecycleMethods, EventEmitter, GenericControllerType, type T9nMeta, type UseT9n, bypassGetter, bypassReadOnly, bypassSetter, dynamicGetSet, getSet, isController, keyTrackResolve, load, makeController, makeGenericController, makeT9nController, proxyExports, readonly, toFunction, trackKey, trackPropKey, trackPropertyKey, useDirection, useMedia, usePropertyChange, useWatchAttributes, watch };
