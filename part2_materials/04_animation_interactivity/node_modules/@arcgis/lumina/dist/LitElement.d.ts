import type { CSSResultGroup, CSSResultOrNative, PropertyValues } from "lit";
import { LitElement as OriginalLitElement } from "lit";
import type { LuminaPropertyDeclaration } from "@arcgis/components-controllers";
import type { Runtime } from "./runtime";
import type { ProxyComponent } from "./lazyLoad";
import type { ToElement } from "./jsx/types";
type ComponentLifecycle = {
    connectedCallback?: () => void;
    disconnectedCallback?: () => void;
    load?: () => Promise<void> | void;
    loaded?: () => void;
};
/**
 * Base Lit class that should be used by all components instead of the original
 * Lit element.
 *
 * This class:
 * - Handles being used in a lazy-loading build
 * - Connects to the Controller Manager
 * - Provides load/loaded lifecycle hooks
 *   (like componentWillLoad and componentDidLoad in Stencil)
 * - Provides a .listen() method like Stencil's \@Listen decorator
 *
 * @remarks
 * Even though all components will extend this class, it is not exposed in the
 * public typings as we do not want to expose internal methods like
 * addController() and connectedCallback() to the public typings.
 *
 * Instead, `@arcgis/lumina-compiler` will make it appear that your component
 * extends `PublicLitElement`.
 *
 * `PublicLitElement` will never be called at runtime - it exists for typings
 * only.
 */
export declare class LitElement extends OriginalLitElement implements ComponentLifecycle {
    /** @internal */
    static runtime: Runtime;
    static tagName: string;
    /**
     * Customize Lit's default style handling to support non-shadow-root styles
     */
    static finalizeStyles(styles?: CSSResultGroup): CSSResultOrNative[];
    static createProperty(name: PropertyKey, 
    /**
     * While in vanilla Lit this type is always LuminaPropertyDeclaration,
     * in Lumina it is always number or
     * [number,LuminaPropertyDeclaration], so we don't even check for the
     * LuminaPropertyDeclaration case. LuminaPropertyDeclaration is here
     * only to satisfy the type checker.
     */
    options?: LuminaPropertyDeclaration | number | [number, LuminaPropertyDeclaration]): void;
    /**
     * Since we can't pass arguments to web component constructor, before lazy
     * loading logic calls document.createElement(), it temporary sets this static
     * property.
     *
     * @internal
     * */
    static lazy: ProxyComponent | undefined;
    static readonly lumina = true;
    /**
     * In lazy build, the actual DOM element differs from the class instance:
     * - "this.el" is a proxy custom element - it's physically present in the DOM
     *   even before the Lit component is loaded.
     * - "this" is the actual Lit component - in case of Lazy builds, it's
     *   never directly attached to the DOM. Instead, all interactions with the
     *   proxy are forwarded to the actual Lit component. And, when Lit wants to
     *   render, it renders into the shadow root of the proxy.
     *
     * "this.el" should be used instead of "this" for all things involving the
     * DOM (addEventListener, querySelector, children, setAttribute,
     * MutationObserver, etc...)
     *
     * @example
     * ```ts
     * // Generally, you shouldn't have to write logic specific to lazy or non-lazy
     * // build, but if you have to, you can detect if you are in a lazy build like so:
     * const isLazy = this.el !== this;
     * ```
     */
    el: ToElement<this>;
    /**
     * Controller Manager orchestrates all controllers used by this component,
     * connecting their lifecycle hooks and providing context information.
     */
    manager: import("@arcgis/components-controllers").ControllerManager<never>;
    /**
     * Map with keys for any properties that have changed since the last
     * update cycle with previous values.
     *
     * Do not access this directly as this value is only set during the update
     * lifecycle. Instead, use the `changes` property that is provided
     * to the shouldUpdate(), willUpdate() and didUpdate() lifecycle hooks.
     *
     * @internal
     *
     * @remarks
     * The name does not start with `_` because in the future we may configure the
     * minifier to mangle such properties - but this property is accessed from
     * outside this package, so should not be mangled.
     */
    $changes: PropertyValues;
    /** @internal */
    _postLoad: ProxyComponent["_postLoad"];
    /**
     * Direct offspring that should be awaited before loaded() is emitted.
     *
     * `attachToAncestor()` will add elements to this array
     *
     * @internal
     */
    _offspring: ProxyComponent["_offspring"];
    /**
     * Promise that resolves once parent's load() completed. False if there is no
     * parent
     *
     * @internal
     */
    _ancestorLoad: ProxyComponent["_ancestorLoad"];
    private _originalShouldUpdate?;
    private _enableUpdating;
    private _postLoaded;
    constructor();
    connectedCallback(): void;
    /**
     * Overwrite Lit's default behavior of attaching shadow root to the lit
     * element, and instead use this.el to support lazy builds.
     *
     * Also, support the case when component asked to not use shadow root
     */
    protected createRenderRoot(): DocumentFragment | HTMLElement;
    /** Do asynchronous component load */
    private _load;
    /**
     * Overwriting default shouldUpdate simply to get access to
     * "changedProperties" so that we can later provide it to ControllerManager
     */
    protected shouldUpdate(_changedProperties: PropertyValues): boolean;
    /**
     * A helper for setting event listener on the current component.
     *
     * The event listener will be removed automatically when component
     * disconnects, and added back if component re-comments, thus you don't have
     * to clean it up manually.
     *
     * @remarks
     * This listens for any event on the component or one of it's children.
     * If you only want to listen for events originating from the component itself
     * use `const isSelf = event.target === this.el;` to check.
     *
     * @example
     * ```tsx
     * constructor() {
     *   // Handle click will only be called while component is connected
     *   this.listen('click', this.handleClick);
     * }
     * handleClick(event: MouseEvent):void {
     *   console.log('clicked');
     * }
     * ```
     */
    listen<K extends keyof HTMLElementEventMap>(name: K, listener: (this: this, event: HTMLElementEventMap[K]) => unknown, options?: AddEventListenerOptions | boolean): void;
    listen(name: string, listener: (this: this, event: Event) => unknown, options?: AddEventListenerOptions | boolean): void;
    listen<EventType extends Event = CustomEvent<"Provide type like this.listenOn<ToEvents<ArcgisCounter>['arcgisClick']>() to get type-checked payload type">>(name: string, 
    /**
     * The "NoInfer" here forces type argument to be specified explicitly.
     * Without it, the following would be allowed:
     * ```tsx
     * this.listen("focus",(event:NotFocusEvent)=>{....})
     * ```
     */
    listener: (this: this, event: NoInfer<EventType>) => unknown, options?: AddEventListenerOptions | boolean): void;
    /**
     * A helper for setting even listener on any element (or window / document).
     *
     * The event listener will be removed automatically when component
     * disconnects, and added back if component re-comments, thus you don't have
     * to clean it up manually.
     *
     * Use cases:
     * - Listening for pointer events on the top-most element
     * - Listening to events that are emitted exclusively on document/window/body
     * - Imperatively listening for events on children components
     * - Listening for events on non-Element objects (like Worker, WebSocket, etc)
     * - Your component could emit a custom event, and then listen for that event
     *   on the window. This lets consumer of the component handle the event and
     *   stop propagation - and if they didn't and event reached the window, your
     *   component can handle the event itself using the default behavior.
     *
     * @example
     * ```tsx
     * constructor() {
     *   // Handle click will only be called while component is connected
     *   this.listenOn(window, 'click', this.handleWindowClick);
     * }
     * handleWindowClick(event: MouseEvent):void {
     *   console.log('clicked');
     * }
     * ```
     */
    listenOn<Name extends keyof WindowEventMap>(target: Window, name: Name, listener: Listener<this, WindowEventMap[Name] & {
        currentTarget: Window;
    }>, options?: AddEventListenerOptions | boolean): void;
    listenOn<Name extends keyof DocumentEventMap>(target: Document, name: Name, listener: Listener<this, DocumentEventMap[Name] & {
        currentTarget: Document;
    }>, options?: AddEventListenerOptions | boolean): void;
    listenOn<Name extends keyof HTMLElementEventMap>(target: HTMLElement, name: Name, listener: Listener<this, HTMLElementEventMap[Name] & {
        currentTarget: HTMLElement;
    }>, options?: AddEventListenerOptions | boolean): void;
    listenOn<EventType extends Event = CustomEvent<"Provide type like this.listenOn<ToEvents<ArcgisCounter>['arcgisClick']>() to get type-checked payload type">, Target = EventTarget>(target: Target, name: string, 
    /**
     * The "NoInfer" here forces type argument to be specified explicitly.
     * Without it, the following would be allowed:
     * ```tsx
     * this.listen("focus",(event:NotFocusEvent)=>{....})
     * ```
     */
    listener: Listener<this, NoInfer<EventType> & {
        currentTarget: Target;
    }>, options?: AddEventListenerOptions | boolean): void;
    /**
     * Create a promise that resolves once component is fully loaded.
     *
     * @example
     * const map = document.createElement('arcgis-map');
     * document.body.append(map);
     * map.componentOnReady().then(() => {
     *   console.log('Map is ready to go!');
     * });
     */
    componentOnReady(): Promise<this>;
}
type Listener<ThisType, EventType> = ((this: ThisType, event: EventType) => unknown) | {
    handleEvent(event: EventType): unknown;
};
/**
 * List of tag names defined by this library.
 *
 * @private
 */
export type GlobalThisWithOwnTagNames = typeof globalThis & {
    devOnly$ownTagNames?: Set<string>;
};
export {};
