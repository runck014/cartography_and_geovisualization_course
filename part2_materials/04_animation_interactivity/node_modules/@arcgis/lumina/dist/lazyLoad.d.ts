import { Deferred } from "@arcgis/components-utils";
import type { LitElement } from "./LitElement";
import type { Runtime } from "./runtime";
import type { ControllerManager } from "@arcgis/components-controllers";
/**
 * Defines lazy-loading proxy components for all web components in this package.
 *
 * As soon as a proxied web component is created (e.g. by adding it to the DOM),
 * it will start loading the actual web component source code.
 */
export interface DefineCustomElements {
    (_window?: Window, options?: LazyLoadOptions): void;
    (options?: LazyLoadOptions): void;
}
export type LazyLoadOptions = {
    readonly resourcesUrl?: string;
};
interface CommonInterface extends HTMLElement {
    componentOnReady: () => Promise<this>;
}
export declare const makeDefineCustomElements: (runtime: Runtime, structure: Readonly<Record<string, CompactMeta>>) => DefineCustomElements;
/**
 * Use compact meta to reduce bundle size (otherwise, it would be ~65kb for
 * map-components). Also, the meta is a string to speed-up parsing
 * (browsers parse strings much faster).
 * See https://twitter.com/mathias/status/1143551692732030979
 */
type CompactMeta = readonly [load: () => Promise<Record<string, typeof LitElement>>, compact?: string];
/**
 * If this file is run from a Node.js environment, HTMLElement won't be defined.
 * Falling back to uselessly extending parseCondensedProp in that case
 * (that particular function chosen just because it already exists, rather than
 * needlessly creating mock class/function)
 * That will error if you try to instantiate a ProxyComponent in Node.js, but
 * that is expected - if you need to instantiate ProxyComponent, HTMLElement
 * must be defined
 */
declare const HtmlElement: {
    new (): HTMLElement;
    prototype: HTMLElement;
};
/**
 * A web-component that, once connected to the page, starts loading the actual
 * component, and set's up two-way forwarding of attributes and methods.
 *
 * It also makes the actual component render it's content in this 'proxy'
 * component, so as to have identical DOM structure for lazy vs non-lazy builds
 * (otherwise, css selectors may break)
 *
 * @internal
 */
export declare abstract class ProxyComponent extends HtmlElement {
    static observedAttributes?: readonly string[];
    /** @internal */
    static _loadPromise: Promise<Record<string, typeof LitElement>> | undefined;
    /** @internal */
    static _LitConstructor?: typeof LitElement;
    /**
     * A list of instances of this component. This allows hot module replacement
     * to update all proxy component to use a new LitElement instance.
     *
     * @internal
     */
    static _hmrInstances: WeakRef<ProxyComponent>[] | undefined;
    /** @internal */
    static _hmrIndex: number | undefined;
    /** @internal */
    static _properties?: readonly string[];
    /** @internal */
    static _asyncMethods?: readonly string[];
    /** @internal */
    static _syncMethods?: readonly string[];
    protected static _name: string;
    static readonly lumina = true;
    /** @internal */
    static _initializePrototype(): void;
    private static _bindProp;
    private static _bindAsync;
    private static _bindSync;
    /**
     * On HMR, preserve the values of all properties that at least once were set
     * by someone other than component itself.
     *
     * @internal
     */
    _hmrSetProps: Set<PropertyKey>;
    /** @internal */
    _hmrSetAttributes: Set<string>;
    /** @internal */
    _litElement: LitElement | undefined;
    /** @internal */
    _store: LitElement | Record<string, unknown>;
    /**
     * If attributeChangedCallback() is called before the LitElement is loaded,
     * store the attributes here, and replay later
     */
    private _pendingAttributes;
    /**
     * Resolved once LitElement's load() is complete.
     * Not read inside of this class, but needed for LitElement to determine if
     * it's closest ancestor finished load()
     */
    _postLoad: Deferred<void>;
    /**
     * Resolved once LitElement's loaded() is complete
     */
    _postLoaded: Deferred<void>;
    /**
     * Direct offspring that should be awaited before loaded() is emitted
     */
    _offspring: (CommonInterface & {
        manager?: LitElement["manager"];
    })[];
    /**
     * Promise that resolves once parent's load() completed. False if there is no
     * parent
     */
    _ancestorLoad?: Promise<void> | false;
    get manager(): ControllerManager | undefined;
    constructor();
    /**
     * Until the custom element is registered on the page, an instance of that
     * element can be constructed and some properties on that instance set.
     *
     * These properties are set before the element prototype is set to this proxy
     * class and thus none of our getters/setters are yet registered - such
     * properties will be set by JavaScript on the instance directly.
     *
     * Once element is registered, the properties set in the meanwhile will shadow
     * the getter/setters, and thus break reactivity. The fix is to delete these
     * properties from the instance, and re-apply them once accessors are set.
     *
     * @example
     * ```ts
     * import { defineCustomElements } from '@arcgis/map-components';
     * const map = document.createElement('arcgis-map');
     * // This will shadow the getter/setters
     * map.itemId = '...';
     * // This finally defines the custom elements and sets the property accessors
     * defineCustomElements();
     * ```
     *
     * @remarks
     * This is an equivalent of the __saveInstanceProperties method in Lit's
     * ReactiveElement. Lit takes care of this on LitElement, but we have to take
     * care of this on the lazy proxy
     */
    protected _saveInstanceProperties(): void;
    attributeChangedCallback(name: string, oldValue: string | null, newValue: string | null): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    /**
     * Create a promise that resolves once component is fully loaded
     */
    componentOnReady(): Promise<this>;
    /** @internal */
    _initializeComponent(module: Record<string, typeof LitElement>): void;
    /**
     * Implemented on the proxy for compatibility with Lit Context.
     */
    addController(): void;
    /**
     * Implemented on the proxy for compatibility with Lit Context.
     */
    requestUpdate(): void;
}
/** @private */
export type GlobalThisWithPuppeteerEnv = typeof globalThis & {
    devOnly$createdElements?: WeakRef<ProxyComponent>[];
};
export {};
