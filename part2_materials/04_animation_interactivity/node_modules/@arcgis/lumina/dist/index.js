import {
  attachToAncestor,
  makeDefineCustomElements,
  noShadowRoot
} from "./chunk-NO7HOBNA.js";
import "./chunk-PGHUBTOM.js";

// src/context.ts
import { retrieveComponent } from "@arcgis/components-controllers";
import { ContextConsumer, ContextProvider } from "@lit/context";
function useContextProvider(options) {
  const component = retrieveComponent();
  const controller = new ContextProvider(component.el, options);
  component.addController(controller);
  return controller;
}
function useContextConsumer(options) {
  const component = retrieveComponent();
  const controller = new ContextConsumer(component.el, options);
  component.addController(controller);
  return controller;
}

// src/createEvent.ts
import { retrieveComponent as retrieveComponent2, keyTrackResolve, trackKey } from "@arcgis/components-controllers";
import { isEsriInternalEnv } from "@arcgis/components-utils";
var createEventFactory = (eventName = "", options = {}, component = retrieveComponent2()) => {
  const emitter = {
    emit: (payload) => {
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && !component.el.isConnected) {
        console.warn(
          `Trying to emit an ${eventName} event on a disconnected element ${component.el.tagName.toLowerCase()}`
        );
      }
      if (eventName === "") {
        keyTrackResolve();
        if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && eventName === "") {
          throw new Error("Unable to resolve event name from property name");
        }
      }
      const event = new CustomEvent(eventName, {
        detail: payload,
        cancelable: true,
        bubbles: true,
        composed: true,
        ...options
      });
      component.el.dispatchEvent(event);
      return event;
    }
  };
  if (eventName === "") {
    trackKey(
      void 0,
      (resolution) => {
        if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && resolution === void 0) {
          throw new Error(`createEvent must be called in property default value only`);
        }
        eventName = resolution.key;
      },
      emitter
    );
  }
  return emitter;
};
var createEvent = createEventFactory.bind(null, "");

// src/decorators.ts
import { state } from "@lit/reactive-element/decorators/state.js";
import { property as litProperty } from "@lit/reactive-element/decorators/property.js";
var property = litProperty;
var method = void 0;

// src/LitElement.ts
import { Deferred, camelToKebab, isEsriInternalEnv as isEsriInternalEnv2 } from "@arcgis/components-utils";
import { LitElement as OriginalLitElement, isServer } from "lit";
import { useControllerManager } from "@arcgis/components-controllers";
var emptyFunction = () => void 0;
var LitElement = class _LitElement extends OriginalLitElement {
  constructor() {
    super();
    /**
     * In lazy build, the actual DOM element differs from the class instance:
     * - "this.el" is a proxy custom element - it's physically present in the DOM
     *   even before the Lit component is loaded.
     * - "this" is the actual Lit component - in case of Lazy builds, it's
     *   never directly attached to the DOM. Instead, all interactions with the
     *   proxy are forwarded to the actual Lit component. And, when Lit wants to
     *   render, it renders into the shadow root of the proxy.
     *
     * "this.el" should be used instead of "this" for all things involving the
     * DOM (addEventListener, querySelector, children, setAttribute,
     * MutationObserver, etc...)
     *
     * @example
     * ```ts
     * // Generally, you shouldn't have to write logic specific to lazy or non-lazy
     * // build, but if you have to, you can detect if you are in a lazy build like so:
     * const isLazy = this.el !== this;
     * ```
     */
    this.el = this.constructor.lazy ?? this;
    /**
     * Controller Manager orchestrates all controllers used by this component,
     * connecting their lifecycle hooks and providing context information.
     */
    this.manager = useControllerManager(this);
    /** @internal */
    this._postLoad = this.constructor.lazy?._postLoad ?? new Deferred();
    /**
     * Direct offspring that should be awaited before loaded() is emitted.
     *
     * `attachToAncestor()` will add elements to this array
     *
     * @internal
     */
    this._offspring = this.constructor.lazy?._offspring ?? [];
    this._postLoaded = this.constructor.lazy?._postLoaded ?? new Deferred();
    this._enableUpdating = this.enableUpdating;
    this.enableUpdating = emptyFunction;
    const ourShouldUpdate = _LitElement.prototype.shouldUpdate;
    if (this.shouldUpdate !== ourShouldUpdate) {
      this._originalShouldUpdate = this.shouldUpdate;
      this.shouldUpdate = ourShouldUpdate;
    }
    if (process.env.NODE_ENV !== "production") {
      const isOwnComponent = globalThis.devOnly$ownTagNames?.has(
        this.el.tagName.toLowerCase()
      );
      const constructor = this.constructor;
      const warningsWereCustomized = constructor.enabledWarnings !== OriginalLitElement.enabledWarnings;
      if (!isOwnComponent && !warningsWereCustomized) {
        constructor.disableWarning?.("change-in-update");
      }
      if (isEsriInternalEnv2()) {
        globalThis.devOnly$luminaComponentRefCallback?.(this);
      }
    }
    if (isServer) {
      this.el.setAttribute(this.constructor.runtime.hydratedAttribute, "");
    }
  }
  /**
   * Customize Lit's default style handling to support non-shadow-root styles
   */
  static finalizeStyles(styles) {
    if (process.env.NODE_ENV === "test" && Array.isArray(styles)) {
      styles = styles.filter(Boolean);
    }
    const finalizedStyles = super.finalizeStyles(styles);
    const useLightDom = this.shadowRootOptions === noShadowRoot;
    return this.runtime?.commonStyles === void 0 || useLightDom ? finalizedStyles : [this.runtime.commonStyles, ...finalizedStyles];
  }
  static createProperty(name, options) {
    const flags = typeof options === "number" ? options : Array.isArray(options) ? options[0] : 0;
    const rest = Array.isArray(options) ? options[1] : void 0;
    super.createProperty(name, {
      /**
       * By default to infer attribute name from property name, Lit just
       * converts property name to lowercase. That is consistent with
       * native DOM attributes.
       *
       * However, that is not consistent with Stencil and would be a
       * breaking change for us. Also, kebab-case is more common among the
       * web components. But the most important reason is that we have
       * some pretty long attribute names, which would be utterly
       * unreadable in lowercase.
       *
       * Also, if browsers add new attributes, that may cause a conflict
       * with our attributes.
       *
       * Thus, overwriting Lit's default behavior to use kebab-case:
       */
      attribute: !!(flags & 1 /* ATTRIBUTE */) && typeof name === "string" ? camelToKebab(name) : false,
      reflect: !!(flags & 2 /* REFLECT */),
      type: flags & 4 /* BOOLEAN */ ? Boolean : flags & 8 /* NUMBER */ ? Number : void 0,
      /**
       * At the moment in Lit, state:true just means attribute:false, so this
       * line is technically redundant, but let's keep it here just in case Lit
       * will add more meaning to state:true in the future.
       */
      state: !!(flags & 16 /* STATE */),
      // Controllers add this option to Lit
      readOnly: !!(flags & 32 /* READ_ONLY */),
      noAccessor: !!(flags & 64 /* NO_ACCESSOR */),
      ...rest
    });
  }
  static {
    this.lumina = true;
  }
  connectedCallback() {
    if (this.el.hasAttribute("defer-hydration")) {
      return;
    }
    const isFirstCall = !this.manager.connectedCalled;
    super.connectedCallback();
    if (isFirstCall) {
      queueMicrotask(
        // eslint-disable-next-line @typescript-eslint/no-misused-promises, @typescript-eslint/promise-function-async
        () => this._load().catch((error) => {
          this._postLoaded.reject(error);
          setTimeout(() => {
            throw error;
          });
        })
      );
    }
  }
  /**
   * Overwrite Lit's default behavior of attaching shadow root to the lit
   * element, and instead use this.el to support lazy builds.
   *
   * Also, support the case when component asked to not use shadow root
   */
  createRenderRoot() {
    const existingShadowRoot = this.el.shadowRoot;
    const Class = this.constructor;
    const options = Class.shadowRootOptions;
    const useLightDom = options === noShadowRoot;
    const renderRoot = existingShadowRoot ?? (useLightDom ? this.el : this.el.attachShadow(options));
    Object.defineProperty(this, "shadowRoot", {
      // Create shadow root on the proxy instance, to make Lit render content there
      value: renderRoot
    });
    if (existingShadowRoot) {
      if (process.env.NODE_ENV === "production") {
        OriginalLitElement.prototype.createRenderRoot.call(this);
      }
      return existingShadowRoot;
    }
    if (this.isConnected) {
      const domRoot = renderRoot.getRootNode();
      if (process.env.NODE_ENV === "test") {
        domRoot.adoptedStyleSheets ??= [];
      }
      domRoot.adoptedStyleSheets = [
        ...domRoot.adoptedStyleSheets,
        ...Class.elementStyles.map((stylesheet) => "styleSheet" in stylesheet ? stylesheet.styleSheet : stylesheet)
      ];
    }
    return renderRoot;
  }
  /** Do asynchronous component load */
  async _load() {
    const parentLoadPromise = this.el._ancestorLoad ?? attachToAncestor(this.el);
    if (parentLoadPromise) {
      await parentLoadPromise;
    }
    await this.manager._load();
    this._enableUpdating(true);
    this.performUpdate();
    this._postLoad.resolve();
    await Promise.resolve();
    const pendingChildren = this._offspring.filter((loaded) => !loaded.manager?.loadedCalled);
    if (pendingChildren.length) {
      await Promise.allSettled(pendingChildren.map(async (child) => await child.componentOnReady()));
    }
    this._offspring.length = 0;
    this.el.setAttribute(this.constructor.runtime.hydratedAttribute, "");
    this.manager._loaded();
    this._postLoaded.resolve();
  }
  /**
   * Overwriting default shouldUpdate simply to get access to
   * "changedProperties" so that we can later provide it to ControllerManager
   */
  shouldUpdate(_changedProperties) {
    this.$changes = _changedProperties;
    return this._originalShouldUpdate?.(_changedProperties) ?? true;
  }
  listen(name, listener, options) {
    const boundListener = listener?.bind(this) ?? listener;
    this.manager.onLifecycle(() => {
      this.el.addEventListener(name, boundListener, options);
      return () => this.el.removeEventListener(name, boundListener, options);
    });
  }
  listenOn(target, name, listener, options) {
    const boundListener = listener?.bind(this) ?? listener;
    this.manager.onLifecycle(() => {
      target.addEventListener(name, boundListener, options);
      return () => target.removeEventListener(name, boundListener, options);
    });
  }
  /**
   * Create a promise that resolves once component is fully loaded.
   *
   * @example
   * const map = document.createElement('arcgis-map');
   * document.body.append(map);
   * map.componentOnReady().then(() => {
   *   console.log('Map is ready to go!');
   * });
   */
  async componentOnReady() {
    await this._postLoaded.promise;
    return this;
  }
};
LitElement.$createEvent = createEventFactory;
if (process.env.NODE_ENV !== "production" && isEsriInternalEnv2()) {
  const globalWithLit = globalThis;
  globalWithLit.litIssuedWarnings ??= /* @__PURE__ */ new Set();
  globalWithLit.litIssuedWarnings.add(
    "Overriding ReactiveElement.createProperty() is deprecated. The override will not be called with standard decorators See https://lit.dev/msg/no-override-create-property for more information."
  );
}

// src/runtime.ts
import { isEsriInternalEnv as isEsriInternalEnv3 } from "@arcgis/components-utils";
function makeRuntime(options) {
  let assetPath;
  const setAssetPath = (path) => {
    assetPath = new URL(
      path,
      /**
       * setAssetPath() is called in global scope whenever Lumina runtime is
       * imported. Thus we need to carefully handle different environments.
       *
       * Need `|| undefined` because Stencil's unit tests mock-dock defines
       * `location.href` as empty string, which crashes `new URL()`. Stencil's
       * test environment does not define `NODE_ENV` by default, so we have to
       * add a few bytes to production.
       *
       * For happy-dom and jsdom, we are assuming that `NODE_ENV` is set.
       * Depending on configuration, `location?.href` is either undefined (not
       * an exception) or `about:blank` (an exception - thus handling that case
       * explicitly).
       *
       * For Node.js without a DOM environment, `location?.href` is undefined so
       * all is good.
       */
      process.env.NODE_ENV === "test" ? globalThis.location?.href === "about:blank" ? void 0 : globalThis.location?.href || void 0 : globalThis.location?.href || void 0
    ).href;
  };
  const runtime = {
    ...options,
    // FEATURE: research https://vitejs.dev/guide/build.html#advanced-base-options
    getAssetPath(suffix) {
      const assetUrl = new URL(suffix, assetPath);
      return assetUrl.origin !== globalThis.location?.origin ? assetUrl.href : assetUrl.pathname;
    },
    setAssetPath,
    customElement(tagName, component) {
      component.runtime = runtime;
      component.tagName = tagName;
      if (!customElements.get(tagName)) {
        customElements.define(tagName, component);
      }
    }
  };
  setAssetPath(options.defaultAssetPath);
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv3()) {
    globalThis.devOnly$luminaRuntime = runtime;
  }
  return runtime;
}

// src/jsx/types.ts
var Fragment = void 0;
var bindAttribute = void 0;
var bindBooleanAttribute = void 0;
var bindProperty = void 0;
var bindEvent = void 0;

// src/jsx/directives.ts
import { classMap } from "lit-html/directives/class-map.js";
import { styleMap } from "lit/directives/style-map.js";
import { directive as litDirective } from "lit-html/directive.js";
import { live as litLive } from "lit-html/directives/live.js";
var safeClassMap = (parameters) => typeof parameters === "object" && parameters != null ? classMap(parameters) : parameters;
var safeStyleMap = (parameters) => typeof parameters === "object" && parameters != null ? styleMap(parameters) : parameters;
var directive = litDirective;
var live = litLive;

// src/jsx/utils.ts
import { noChange as litNoChange, nothing as litNothing } from "lit-html";
var nothing = litNothing;
var noChange = litNoChange;
function setAttribute(element, attributeName, value) {
  if (value == null) {
    element.removeAttribute(attributeName);
  } else {
    element.setAttribute(attributeName, value);
  }
}
var stringOrBoolean = {
  toAttribute: (value) => value === true ? "" : value === false ? null : value
};

// src/wrappersUtils.ts
var emptyObject = {};
var makeReactWrapperFactory = (react, createComponent) => (options) => {
  const tagName = options.tagName;
  let customElementPrototype = emptyObject;
  const elementClass = {
    name: tagName,
    /**
     * Lit's createComponent tries to access the elementClass.prototype in
     * global scope (in development mode). The elementClass may not be defined
     * yet (because we are in a lazy loading build, or because current app
     * doesn't import a given custom element as it doesn't use it).
     *
     * Thus, we return an empty object as a fake prototype.
     *
     * Right after the call to `createComponent`, we set to
     * customElementPrototype undefined so that the next access of
     * `.prototype` tries to get the real prototype.
     * `createPrototypeProxy()` is called, this small proxy delays retrieving the custom
     * element prototype until it is actually needed, and caches the result for future calls.
     */
    get prototype() {
      if (customElementPrototype === void 0) {
        customElementPrototype = customElements.get(tagName)?.prototype;
        if (!customElementPrototype) {
          throw new Error(`Custom element "${tagName}" not found`);
        }
        Object.defineProperty(elementClass, "prototype", { value: customElementPrototype });
      }
      return customElementPrototype;
    }
  };
  const result = createComponent({
    ...options,
    react,
    elementClass
  });
  customElementPrototype = void 0;
  return result;
};
var getReactWrapperOptions = (tagNameAndElement, events) => ({ tagName: tagNameAndElement, events });
export {
  Fragment,
  LitElement,
  bindAttribute,
  bindBooleanAttribute,
  bindEvent,
  bindProperty,
  createEvent,
  directive,
  getReactWrapperOptions,
  live,
  makeDefineCustomElements,
  makeReactWrapperFactory,
  makeRuntime,
  method,
  noChange,
  noShadowRoot,
  nothing,
  property,
  safeClassMap,
  safeStyleMap,
  setAttribute,
  state,
  stringOrBoolean,
  useContextConsumer,
  useContextProvider
};
