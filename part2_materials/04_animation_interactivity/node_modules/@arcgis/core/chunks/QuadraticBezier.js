/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{i as t,t as e,g as s,n,G as i,s as r,u as o,b as a,c as h,f as m,e as u,w as l,h as c,k as g,m as d,o as _,l as p}from"./Geometry.js";import{j as f,k as P,l as y,m as x,r as C,n as v,o as b,O as E,p as S,q as D,t as w,E as A,u as T,V as I,v as M,h as Y,w as X,P as N,A as q,B as F,x as V,y as L,z as R,D as z,F as k,G as B,H as G,S as W,T as j}from"./Envelope.js";import{i as Z,A as H,E as U,d as O,B as Q,P as J,a as K,C as $,b as tt,D as et,F as st,G as nt,H as it,g as rt,q as ot,I as at,J as ht,L as mt,N as ut,c as lt,K as ct,j as gt,O as dt,m as _t,Q as pt,R as ft,T as Pt,U as yt,V as xt,W as Ct,M as vt,X as bt,Y as Et,Z as St,_ as Dt,$ as wt,a0 as At,s as Tt,a1 as It,a2 as Mt,a3 as Yt,a4 as Xt,a5 as Nt,l as qt,a6 as Ft,a7 as Vt,a8 as Lt,a9 as Rt,aa as zt,v as kt,e as Bt,w as Gt,ab as Wt,ac as jt,ad as Zt,ae as Ht,n as Ut,af as Ot,ag as Qt,o as Jt,ah as Kt,ai as $t,u as te,aj as ee,ak as se,al as ne,am as ie,an as re}from"./Point2D.js";import{Envelope2D as oe}from"./Envelope2D.js";import{T as ae}from"./Transformation2D.js";import{G as he}from"./SimpleGeometryCursor.js";class me{constructor(){this.posStream=null,this.streams=null}get(t){return t>0?this.streams[t-1]:this.posStream}set(t,e){t>0?this.streams[t-1]=e:this.posStream=e}destroyAndSetSize(t){if(this.streams=null,t>1){this.streams=new Array(t-1);for(let e=0;e<t-1;++e)this.streams[e]=null}this.posStream=null}swap(t){[this.streams,t.streams]=[t.streams,this.streams],[this.posStream,t.posStream]=[t.posStream,this.posStream]}empty(){return null===this.posStream&&null===this.streams}}function ue(t,s,n,i,r){(s<0||n<0||i<1||s+i*(n-1)+1>t.size())&&e("Index out of bound");for(let e=s,o=s+i*(n-1)+1;e<o;e+=i)t.writeAsDbl(e,r(t.readAsDbl(e)))}function le(t,e,s){if(t)for(let n=e.length-1;n>=0;--n)s(e[n]);else e.forEach(s)}function ce(t,e){let s=H(t);const n=e.length/Z();for(let i=0;i<e.length;++i){const t=Math.trunc(s*n);s=H(s);const i=Math.trunc(s*n),r=e[t];e[t]=e[i],e[i]=r}}function ge(t,e,s){if(0===t.length)return;let n=0,i=0;for(++i;i!==t.length;++i)e(t[n],t[i])||(s(n,i),n=i);s(n,i)}function de(t,e,s,n,i){$(t,e,n-e,((t,e)=>i(t,e)?-1:1))}function _e(t,e,s){if(!(s<=e))for(;e<s;)t[s]=tt(t[e],t[e]=t[s]),e++,s--}function pe(t,e,s,n){_e(t,e,s-1),_e(t,s,n-1),t.reverse()}function fe(t,e,s){const n=t.getDescription().getTotalComponentCount();t.setX(e[0]),t.setY(e[1]),K(t.getAttributeArray(),e,0,2,n-2)}var Pe=I;const ye="can not assign an empty point to a vertex";class xe{constructor(t){if(this.m_accelerators=null,void 0!==t&&t.move)this.m_description=t.move.m_description,t.move.m_description=f(),this.m_vertexAttributes=t.move.m_vertexAttributes,t.move.m_vertexAttributes=new me,this.m_envelopeData=t.move.m_envelopeData,t.move.m_envelopeData=new P,this.m_pointCount=t.move.m_pointCount,this.m_reservedPointCount=t.move.m_reservedPointCount,this.m_flags=t.move.m_flags,this.m_bFillRule=t.move.m_bFillRule,this.m_bPathStarted=t.move.m_bPathStarted,this.m_bPolygon=t.move.m_bPolygon,this.m_simpleTolerance=t.move.m_simpleTolerance;else{const e=void 0!==t&&t.vd?t.vd:f();this.m_description=e,this.m_vertexAttributes=new me,this.m_envelopeData=new P,this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_flags=4063,this.m_bFillRule=this.m_bPathStarted=this.m_bPolygon=!1,this.m_simpleTolerance=0,void 0!==t&&t.copy&&t.copy.copyTo(this)}}equalsBase(e,s){if(!t(e.getGeometryType()))return!1;const n=e;if(this===n)return!0;if(!this.m_description.equals(n.getDescription()))return!1;if(this.isEmptyImpl()!==n.isEmptyImpl())return!1;if(this.isEmptyImpl())return!0;const i=this.getPointCount();if(i!==n.getPointCount())return!1;for(let t=0;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),r=this.getAttributeStreamRef(e),o=n.getAttributeStreamRef(e),a=Pe.getComponentCount(e);if(!r.equals(o,0,i*a,s))return!1}if(s){if(!this.equalsImplTol(e,s))return!1}else if(!this.equalsImpl(e))return!1;return!0}transformAttribute(t,e,s,n,i){this.addAttribute(t),this.isEmpty()||0===s&&1===n||(ue(this.getAttributeStreamRef(t),e,this.getPointCount(),Pe.getComponentCount(t),M(s,n,i)),this.notifyModified())}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=y(e,t);this.assignVertexDescription(s)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=x(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=C(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=f();t!==this.m_description&&this.assignVertexDescription(t)}getAttributeStreamRef(t){this.throwIfEmpty(),this.m_description.hasAttribute(t)||e("AttributeStream : Geometry does not have the attribute");const s=this.m_description.getAttributeIndex(t);return this.m_vertexAttributes.get(s)}setAttributeStreamRef(t,s){s||e("stream"),s&&Pe.getPersistence(t)!==s.getPersistence()&&e(""),this.addAttribute(t);const n=this.m_description.getAttributeIndex(t);this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_vertexAttributes.set(n,s),this.notifyModifiedFlags(2001)}notifyModifiedFlags(t){65535===t&&(this.m_reservedPointCount=-1,this.notifyModifiedAllImpl()),this.setDirtyFlagProtected(t,!0),this.clearAccelerators(),32&t&&this.verifyAllStreamsAfterSizeChange()}notifyModified(){this.notifyModifiedFlags(2001)}getPointCount(){return this.m_pointCount}getPointByVal(t,e){const s=e;s.assignVertexDescription(this.m_description);for(let n=0;n<this.m_description.getAttributeCount();n++){const e=this.m_description.getSemantics(n);for(let i=0,r=Pe.getComponentCount(e);i<r;i++){const o=this.m_vertexAttributes.get(n).readAsDbl(r*t+i);s.setAttributeBasic(e,i,o)}}}setPointByVal(t,s){const n=s;n.isEmpty()&&e(ye);const i=n.getDescription();i!==this.m_description&&this.mergeVertexDescription(i);const r=this.m_vertexAttributes.get(0);r.write(2*t,n.getX()),r.write(2*t+1,n.getY());for(let e=1,o=this.m_description.getAttributeCount();e<o;e++){const s=this.m_description.getSemantics(e),i=Pe.getComponentCount(s);for(let r=0;r<i;r++){const o=n.getAttributeAsDbl(s,r);this.m_vertexAttributes.get(e).writeAsDbl(t*i+r,o)}}this.notifyModifiedFlags(2001)}setPointByValFromArray(t,e,n,i){s(0)}getPointByValAsArray(t,e,n,i){s(0)}isEmpty(){return this.isEmptyImpl()}isEmptyImpl(){return 0===this.m_pointCount}getAttributeAsDbl(t,e,s){const i=Pe.getComponentCount(t);s>=i&&n("");const r=this.m_description.getAttributeIndex(t);return r>=0?this.m_vertexAttributes.get(r).readAsDbl(e*i+s):Pe.getDefaultValue(t)}queryAttributeAsDbl(t,e,s,i){const r=Pe.getComponentCount(t);i<r&&n("");const o=this.m_description.getAttributeIndex(t);if(o>=0){const t=e*r,n=this.m_vertexAttributes.get(o);for(let e=0;e<r;e++)s[e]=n.readAsDbl(t+e)}else{const e=Pe.getDefaultValue(t);for(let t=0;t<r;t++)s[t]=e}}getAttributeAsInt(t,e,s){return Math.trunc(this.getAttributeAsDbl(t,e,s))}queryAttributeAsInt(t,e,n,i){s(0)}setAttribute(t,e,s,i){const r=Pe.getComponentCount(t);s>=r&&n(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001),this.m_vertexAttributes.get(o).writeAsDbl(e*r+s,i)}setAttributeFromArray(t,e,s,i){(e<0||e>=this.m_pointCount)&&n("");const r=Pe.getComponentCount(t);i!==r&&n(""),this.addAttribute(t);const o=this.m_description.getAttributeIndex(t);this.notifyModifiedFlags(2001);const a=this.m_vertexAttributes.get(o);for(let n=0;n<r;++n)a.writeAsDbl(e*r+n,s[n])}getXY(t){return this.m_vertexAttributes.get(0).readPoint2D(2*t)}queryXY(t,e){return this.m_vertexAttributes.get(0).queryPoint2D(2*t,e)}setXY(t,e){this.m_vertexAttributes.get(0).writePoint2D(2*t,e),this.notifyModifiedFlags(2001)}setXYCoords(t,e,s){const n=this.m_vertexAttributes.get(0);n.write(2*t,e),n.write(2*t+1,s),this.notifyModifiedFlags(2001)}getXYZ(t){const e=this.m_vertexAttributes.get(0),s=Y.getNAN();return s.x=e.read(2*t),s.y=e.read(2*t+1),this.m_description.hasAttribute(1)?s.z=this.m_vertexAttributes.get(1).read(t):s.z=Pe.getDefaultValue(1),s}setXYZ(t,e){this.addAttribute(1),this.notifyModifiedFlags(2001);const s=this.m_vertexAttributes.get(0);s.write(2*t,e.x),s.write(2*t+1,e.y);this.m_vertexAttributes.get(1).write(t,e.z)}queryEnvelope(t){t instanceof oe||t instanceof v?this.updateEnvelope(t):(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t))}queryLooseEnvelope(t){this.updateLooseEnvelope(t)}queryInterval(t,e){const s=U.constructEmpty();return this.isEmptyImpl()||(this.updateAllDirtyIntervals(!0),this.m_envelopeData.queryInterval(this.m_description,t,e,s)),s}setAttributeBasic(t,e,s){this.setAttributeImpl(t,e,s)}setAttributeImpl(t,e,s){if(this.addAttribute(t),this.isEmpty())return;let n=!1;const i=Pe.getComponentCount(t),r=this.getAttributeStreamRef(t),o=Number.isNaN(s);if(1===r.getPersistence()){const t=r;for(let r=e,a=this.m_pointCount*i;r<a;r+=i){const e=t.read(r);(o||e===s)&&Number.isNaN(e)||(t.write(r,s),n=!0)}}else for(let a=e,h=this.m_pointCount*i;a<h;a+=i){r.readAsDbl(a)!==s&&(r.writeAsDbl(a,s),n=!0)}n&&this.notifyModifiedFlags(2001)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;let s=!1;const n=Pe.getComponentCount(t),i=this.getAttributeStreamRef(t);for(let r=0;r<n;r++)if(1===i.getPersistence()){const t=i;for(let i=0,r=this.m_pointCount*n;i<r;i++){const n=t.read(i);Number.isNaN(n)&&(t.write(i,e),s=!0)}}else for(let t=0,o=this.m_pointCount*n;t<o;t++){const n=i.readAsDbl(t);Number.isNaN(n)&&(i.writeAsDbl(t,e),s=!0)}s&&this.notifyModifiedFlags(2001)}calculateLength3D(t){return s(0),0}setEnvelopeForImport(t){this.m_description.equals(t.getDescription())||e(""),this.m_envelopeData=new P({moveEnv:t}),this.setDirtyFlagProtected(192,!1)}copyTo(t){t.getGeometryType()!==this.getGeometryType()&&e(""),this!==t&&this.copyToUnchecked(t,!1)}queryCoordinates(t,s,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+s),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&e(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);for(let e=2*n,a=2*r,h=0;e<a;e+=2,h++)o.queryPoint2D(e,t[h]);return r}queryCoordinates3D(t,s,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+s),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&e(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=Pe.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let u=0;for(let e=n;e<r;e++,u++)t[u].x=o.read(2*e),t[u].y=o.read(2*e+1),t[u].z=m?a.read(e):h;return r}clearAndSetDirtyFlagProtected(t,e){let s=0;const n=t&~e,i=e|n;s=this.m_flags,(s&i)!==e&&(this.m_flags=s&~n|e)}getIsSimple(t,e){e[0]=0;let s=-1;const n=this.m_flags,i=this.m_simpleTolerance;if(!(1&n)){s=(14&n)>>1,e[0]=i,i<t&&(s=-1)}return s}setIsSimple(t,e,n=!1){if(2===t?s(this.getGeometryType()===i.enumPolyline):1===t?s(this.getGeometryType()===i.enumMultiPoint||this.getGeometryType()===i.enumPolyline):3===t&&s(this.getGeometryType()===i.enumPolygon),-1===t)this.setDirtyFlagProtected(17,!0);else{let s=t<<1;n||(s|=16);const i=31;this.clearAndSetDirtyFlagProtected(i,s),this.m_simpleTolerance!==e&&(this.m_simpleTolerance=e)}}attributeStreamIsAllocated(t){this.throwIfEmpty();const e=this.m_description.getAttributeIndex(t);return e>=0&&null!==this.m_vertexAttributes.get(e)}capacity(){return-1===this.m_reservedPointCount&&0===this.m_pointCount?0:this.m_reservedPointCount}getDescriptionImpl(){return this.m_description}copyToUnchecked(t,e=!1){e&&this.hasDirtyFlag(32)&&r("Cannot do shallow clone on unprepared geometry");const n=t,o=this.getGeometryType(),a=n.getGeometryType();s(o===a||o===i.enumPolygon&&a===i.enumPolyline,"failure in copyToUnchcked"),n.clearAccelerators(),n.m_description=this.m_description,n.m_vertexAttributes.destroyAndSetSize(0),n.m_envelopeData.releaseAttributes();const h=this.m_description.getAttributeCount(),m=new me;if(!this.m_vertexAttributes.empty()){m.destroyAndSetSize(h);for(let t=0;t<h;t++)if(this.m_vertexAttributes.get(t))if(e)m.set(t,this.m_vertexAttributes.get(t));else{const e=Pe.getComponentCount(this.m_description.getSemantics(t));m.set(t,this.m_vertexAttributes.get(t).restrictedClone(this.getPointCount()*e))}}if(this.m_envelopeData.copyToIfNotNull(this.m_description,n.m_envelopeData),n.m_flags=this.m_flags,n.m_simpleTolerance=this.m_simpleTolerance,o!==a){const t=[Number.NaN];n.getIsSimple(0,t)>=3?n.setIsSimple(1,t[0]):n.setIsSimple(-1,0)}n.m_vertexAttributes.swap(m),m.destroyAndSetSize(0),n.m_pointCount=this.m_pointCount,n.hasDirtyFlag(32)?(s(!e),n.m_reservedPointCount=-1):n.m_reservedPointCount=n.m_pointCount;try{this.copyToImpl(n,e)}catch(u){throw n.setEmpty(),u}n.verifyAllStreamsAfterSizeChange()}buildRasterizedGeometryAccelerator(t,e){return!1}getAccelerators(){return this.m_accelerators}clearAccelerators(){this.m_accelerators&&this.m_accelerators.release(),this.m_accelerators=null}ensureUniqueAccelerators(){if(this.m_accelerators&&!this.m_accelerators.uniqueUse()){const t=this.m_accelerators.clone();this.m_accelerators.release(),this.m_accelerators=t}}interpolateTwoVertices(t,e,i,r){(t<0||t>=this.m_pointCount)&&n(""),(e<0||e>=this.m_pointCount)&&n(""),r.assignVertexDescription(this.m_description);const o=O(Pe.maxComponentCount(),Number.NaN),a=O(Pe.maxComponentCount(),Number.NaN),h=b();let m=0;for(let n=0;n<this.m_description.getAttributeCount();n++){const r=this.m_description.getSemantics(n),u=Pe.getInterpolation(r),l=Pe.getComponentCount(r),c=Pe.getDefaultValue(r);this.queryAttributeAsDbl(r,t,o,l),this.queryAttributeAsDbl(r,e,a,l),s(m+l<=E),Q(u,o,a,h,m,l,i,c),m+=l}fe(r,h)}getShortestDistance(t,e){return J.distance(this.getXY(t),this.getXY(e))}getShortestSqrDistance(t,e){return J.sqrDistance(this.getXY(t),this.getXY(e))}resizeImpl(t){if(t<0&&e(),(t=Math.ceil(t))===this.m_pointCount)return;this.m_pointCount=t;const s=this.m_pointCount<=this.m_reservedPointCount?2001:4095;this.notifyModifiedFlags(s)}assignVertexDescriptionImpl(t){if(!this.m_vertexAttributes.empty()){const e=S();D(t,this.m_description,e);const s=new me;s.destroyAndSetSize(t.getAttributeCount());for(let n=0;n<t.getAttributeCount();n++){const t=e[n];-1!==t?s.set(n,this.m_vertexAttributes.get(t)):this.m_reservedPointCount=-1}s.swap(this.m_vertexAttributes)}this.m_description=t,this.m_envelopeData.releaseAttributes(),this.notifyModifiedFlags(4095)}hasDirtyFlag(t){return!!(this.m_flags&t)}setDirtyFlagProtected(t,e){e?this.m_flags|=t:this.m_flags&=~t}notifyModifiedAllImpl(){}verifyAllStreamsAfterSizeChange(){this.hasDirtyFlag(32)&&this.verifyAllStreamsAfterSizeChangeImpl()}verifyAllStreamsAfterSizeChangeImpl(){if(this.hasDirtyFlag(32)){if(this.m_reservedPointCount<this.m_pointCount){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),this.m_reservedPointCount=Number.MAX_SAFE_INTEGER;let t=0;t=this.m_pointCount<4?3:this.m_pointCount<=128?2*this.m_pointCount:Math.trunc((4*this.m_pointCount+2)/3);for(let e=0;e<this.m_description.getAttributeCount();e++){const s=this.m_description.getSemantics(e);let n=0;if(null!==this.m_vertexAttributes.get(e)){const i=Pe.getComponentCount(s);n=this.m_vertexAttributes.get(e).size()/i,n<this.m_pointCount&&(this.m_vertexAttributes.get(e).resize(t*i,Pe.getDefaultValue(s)),n=t)}else this.m_vertexAttributes.set(e,w(s,t)),n=t;n<this.m_reservedPointCount&&(this.m_reservedPointCount=n)}}this.verifyStreamsAfterSizeChangeExtraImpl(),this.setDirtyFlagProtected(32,!1)}}verifyStreamsAfterSizeChangeExtraImpl(){}updateAllDirtyIntervals(t){if(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128)){if(this.isEmpty())return this.hasDirtyFlag(192)&&this.m_envelopeData.setEmpty(this.m_description),void this.setDirtyFlagProtected(192,!1);const e=this.updateXYImpl(t),s=new A({vd:this.m_description});s.setEnvelope(e);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),n=Pe.getComponentCount(e),i=this.m_vertexAttributes.get(t);for(let t=0;t<n;t++){const r=new U;r.setEmpty();for(let e=0;e<this.m_pointCount;e++){const s=i.readAsDbl(e*n+t);r.mergeCoordinate(s)}s.setIntervalEnvelope(e,t,r)}}(t?this.hasDirtyFlag(192):this.hasDirtyFlag(128))&&(this.m_envelopeData=new P({moveEnv:s}),this.clearDirtyIntervalsFlag(t))}}updateXYImpl(t){const e=oe.constructEmpty(),s=this.m_vertexAttributes.get(0);return e.mergePointsInterleaved(s,0,this.m_pointCount),e}updateEnvelope3D(t){s(0)}updateLooseEnvelope(t){this.updateAllDirtyIntervals(!1),t instanceof oe?t.assign(this.m_envelopeData.m_envelope2D):this.m_envelopeData.queryEnvelope3D(this.m_description,t)}updateEnvelope(t){this.updateAllDirtyIntervals(!0),t.assign(this.m_envelopeData.m_envelope2D)}setEmptyImpl(){this.m_pointCount=0,this.m_reservedPointCount=-1,this.m_vertexAttributes.destroyAndSetSize(0),this.notifyModifiedFlags(4095)}clearDirtyIntervalsFlag(t){this.setDirtyFlagProtected(192,!1)}reserveImpl(t,s){if(t<0&&e(""),0===t)return;let n=t=Math.ceil(t);if(this.m_reservedPointCount<n){this.m_vertexAttributes.empty()&&this.m_vertexAttributes.destroyAndSetSize(this.m_description.getAttributeCount()),s?(null===this.m_vertexAttributes.get(0)&&this.m_vertexAttributes.set(0,T(0,0)),this.m_vertexAttributes.get(0).resizeRounded(2*n),n=this.m_vertexAttributes.get(0).size()>>1):null===this.m_vertexAttributes.get(0)?this.m_vertexAttributes.set(0,T(0,n)):this.m_vertexAttributes.get(0).resize(2*n);for(let t=1;t<this.m_description.getAttributeCount();t++){const e=this.m_description.getSemantics(t),s=Pe.getComponentCount(e);null!==this.m_vertexAttributes.get(t)?this.m_vertexAttributes.get(t).resize(n*s):this.m_vertexAttributes.set(t,T(e,n))}this.reserveImplImpl(n,s),this.m_reservedPointCount=n}}reserveRounded(t){t<0&&e(),t=Math.ceil(t),this.reserveImpl(t,!0)}reserveImplImpl(t,e){}throwIfEmpty(){this.isEmptyImpl()&&o("")}}class Ce extends xe{constructor(t){super(t),t&&(t.points?this.addPoints2D(t.points,t.pointsSize,0,-1):t.point&&this.add(t.point))}assignCopy(t){return t.copyTo(this),this}assignMove(t){return t.copyTo(this),t.setEmpty(),this}insertPoint2D(t,s){t>this.getPointCount()&&e("invalid point index"),t<0&&(t=this.getPointCount());const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let e=0,i=this.m_description.getAttributeCount();e<i;e++){const i=this.m_description.getSemantics(e),r=I.getComponentCount(i);if(0===i)this.m_vertexAttributes.get(e).insert(r*t,s,r*n);else{const s=I.getDefaultValue(i);this.m_vertexAttributes.get(e).insertRange(r*t,s,r,r*n)}}this.notifyModifiedFlags(2001)}insertPoint(t,s){s.isEmpty()&&e(ye),t<0&&(t=this.getPointCount()),this.mergeVertexDescription(s.getDescription());const n=this.m_pointCount;this.resizeNoInit(this.m_pointCount+1);for(let e=0,i=this.m_description.getAttributeCount();e<i;e++){const i=this.m_description.getSemantics(e),r=I.getComponentCount(i);if(s.hasAttribute(i))this.m_vertexAttributes.get(e).insertAttributes(r*t,s,i,r*n);else{const s=I.getDefaultValue(i);this.m_vertexAttributes.get(e).insertRange(r*t,s,r,r*n)}}this.notifyModifiedFlags(2001)}insertPoints(t,e,s){if((t>this.getPointCount()||s<0)&&n(""),t<0&&(t=this.getPointCount()),0===s)return;const i=e[0].getDescription();this.mergeVertexDescription(i);const r=this.m_pointCount;this.resizeNoInit(this.m_pointCount+s);for(let n=0,o=this.m_description.getAttributeCount();n<o;n++){const o=this.m_description.getSemantics(n),a=I.getComponentCount(o);if(this.m_vertexAttributes.get(n))if(i.hasAttribute(o))this.m_vertexAttributes.get(n).insertAttributesFromPoints(t*a,e,s,o,r*a);else{const e=I.getDefaultValue(o);this.m_vertexAttributes.get(n).insertRange(a*t,e,a*s,a*r)}}this.notifyModifiedFlags(2001)}insertPoints2D(t,s,n){if((t>this.getPointCount()||n<0)&&e("invalid point index"),t<0&&(t=this.getPointCount()),0===n)return;const i=this.m_pointCount;this.resizeNoInit(this.m_pointCount+n);for(let e=0,r=this.m_description.getAttributeCount();e<r;e++){const r=this.m_description.getSemantics(e),o=I.getComponentCount(r);if(this.m_vertexAttributes.get(e))if(0===r)this.m_vertexAttributes.get(e).insertRangeFromPoints(o*t,s,0,n,!0,o*i);else{const s=I.getDefaultValue(r);this.m_vertexAttributes.get(e).insertRange(o*t,s,o,o*i)}}this.notifyModifiedFlags(2001)}removePoints(t,e){if((t<0||e<0||t+e>this.getPointCount())&&n("remove_points"),0!==e){for(let s=0,n=this.m_description.getAttributeCount();s<n;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),i=I.getComponentCount(n);this.m_vertexAttributes.get(s).eraseRange(i*t,i*e,i*this.m_pointCount)}this.m_pointCount-=e,this.m_reservedPointCount>0&&(this.m_reservedPointCount-=e),this.notifyModifiedFlags(2001)}}removePoint(t){for(let e=0,s=this.m_description.getAttributeCount();e<s;e++)if(this.m_vertexAttributes.get(e)){const s=this.m_description.getSemantics(e),n=I.getComponentCount(s);this.m_vertexAttributes.get(e).eraseRange(n*t,n,n*this.m_pointCount)}this.m_pointCount--,this.m_reservedPointCount>0&&this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}calculateEnvelope2D(){return this.updateXYImpl(!0)}resizeNoInit(t){this.resizeImpl(t)}resizeAndInitNonPositionAttributes(t){const e=this.m_pointCount;if(this.resizeImpl(t),this.m_pointCount>e)for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const t=this.m_description.getSemantics(s),n=I.getDefaultValue(t),i=I.getComponentCount(t);this.m_vertexAttributes.get(s).insertRange(i*e,n,i*(this.m_pointCount-e),i*e)}}queryCoordinates3D(t,s,n,i){let r=i<0?this.m_pointCount:i;if(r=Math.min(r,n+s),(n<0||r<n||this.m_pointCount>0&&n>=this.m_pointCount)&&e(""),0===this.m_pointCount)return r;const o=this.getAttributeStreamRef(0);let a=null;const h=I.getDefaultValue(1),m=this.m_description.hasAttribute(1);m&&(a=this.getAttributeStreamRef(1));let u=0;for(let e=n;e<r;e++,u++)t[u].x=o.read(2*e),t[u].y=o.read(2*e+1),t[u].z=m?a.read(e):h;return r}queryAttributeAsInt(t,e,n,i){s(0)}add(t){t.isEmpty()&&e(ye),this.resizeAndInitNonPositionAttributes(this.m_pointCount+1),this.setPointByVal(this.m_pointCount-1,t)}addXY(t,e){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const s=new J(t,e);this.setXY(this.m_pointCount-1,s)}addXYZ(t,e,s){this.resizeAndInitNonPositionAttributes(this.m_pointCount+1);const n=new Y;n.setCoords(t,e,s),this.setXYZ(this.m_pointCount-1,n)}addPoint2D(t){this.addXY(t.x,t.y)}addPoint3D(t){this.addXYZ(t.x,t.y,t.z)}addPoints(t,s,n){this===t&&e("Multi_point_impl.add");const i=n<0?t.getPointCount():n;if((s<0||s>t.getPointCount()||i<s)&&e(""),s===i)return;const r=t.getDescription();this.mergeVertexDescription(r);const o=i-s,a=this.m_pointCount;this.resizeNoInit(this.m_pointCount+o);for(let e=0,h=this.m_description.getAttributeCount();e<h;e++){const n=this.m_description.getSemantics(e),i=I.getComponentCount(n),h=this.getAttributeStreamRef(n);if(r.hasAttribute(n)){const e=t.getAttributeStreamRef(n);h.insertRangeFromStream(a*i,e,s*i,o*i,!0,1,a*i)}else{const t=I.getDefaultValue(n);h.insertRange(a*i,t,o*i,a*i)}}}addPoints2D(t,s,n,i){let r=s;const o=i<0?r:i;if((r<0||n<0||n>r||o<n)&&e(""),n===o)return;r=o-n;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0);for(let e=0;e<r;++e)h.writePoint2D(2*(a+e),t[n+e]);this.notifyModifiedFlags(2001)}addPoints3D(t,s,n,i){let r=s;const o=i<0?r:i;if((r<0||n<0||n>r||o<n)&&e(""),this.addAttribute(1),n===o)return;r=o-n;const a=this.m_pointCount;this.resizeAndInitNonPositionAttributes(this.m_pointCount+r);const h=this.getAttributeStreamRef(0),m=new J;for(let e=0;e<r;e++)m.x=t[n+e].x,m.y=t[n+e].y,h.writePoint2D(2*(a+e),m);const u=this.getAttributeStreamRef(1);for(let e=0;e<r;e++)u.write(a+e,t[n+e].z);this.notifyModifiedFlags(2001)}getGeometryType(){return i.enumMultiPoint}getDimension(){return 0}createInstance(){return new Ce({vd:this.getDescription()})}setEmpty(){this.setEmptyImpl()}applyTransformation(t){if(this.isEmpty())return;if(t.isIdentity())return;const e=this.m_vertexAttributes.get(0);1===t.m_TransformationType?e.applyTransformation(t,0,this.m_pointCount):a("3d xform not impl"),this.notifyModifiedFlags(2001)}calculateArea2D(){return 0}calculateLength2D(){return 0}calculateLength3D(t){return 0}equals(t,e){return t.getGeometryType()===i.enumMultiPoint&&this.equalsBase(t,e)}queryEnvelope(t){4===t.m_EnvelopeType?(this.updateAllDirtyIntervals(!0),this.m_envelopeData.copyTo(this.m_description,t)):2===t.m_EnvelopeType?this.updateEnvelope(t):a("")}getImpl(){return this}getBoundary(){return null}reserve(t){this.reserveImpl(t)}clone(){const t=this.createInstance();return this.copyTo(t),t}swap(t){s(0)}buildQuadTreeAccelerator(t){return!1}getHashCodeImpl(){return s(0),0}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}copyToImpl(t,e){}}Ce.type=i.enumMultiPoint;class ve{constructor(){this.m_EnvelopeType=5,this.envAabb=oe.constructEmpty(),this.envRot=oe.constructEmpty()}static constructEmpty(){return new ve}width(){return this.envAabb.width()}height(){return this.envAabb.height()}maxDim(){return Math.max(this.width(),this.height())}setEmpty(){this.envAabb.setEmpty(),this.envRot.setEmpty()}setCoords(t){this.envAabb.setCoords(t),this.envRot.setCoords({x:be(t),y:Ee(t)})}setFromPoints(t,e){this.setEmpty(),this.mergePoints(t,e)}mergeNe(t){this.envAabb.mergeNe(t),this.envRot.mergeNeCoords(be(t),Ee(t))}mergePoints(t,e){this.envAabb.mergePoints(t,e);for(let s=0;s<e;){if(!this.envRot.isEmpty()){for(let n=s;n<e;n++){const e=be(t[n]),s=Ee(t[n]);this.envRot.mergeNeCoords(e,s)}break}{const e=be(t[s]),n=Ee(t[s]);this.envRot.setCoords({x:e,y:n}),s++}}}isIntersectingPoint2D(t){return!(!this.envAabb.contains(t)||!this.envRot.containsCoords(be(t),Ee(t)))}isIntersectingW(t){return this.envAabb.isIntersecting(t.envAabb)&&this.envRot.isIntersecting(t.envRot)}containsW(t){return!(!this.envAabb.containsEnvelope(t.envAabb)||!this.envRot.containsEnvelope(t.envRot))}containsPoint2D(t){return this.isIntersectingPoint2D(t)}intersectW(t){const e=this.envAabb.intersect(t.envAabb),s=this.envRot.intersect(t.envRot);return e&&!s&&this.envAabb.setEmpty(),s&&!e&&this.envRot.setEmpty(),e&&s}inflate(t){this.envAabb.inflateCoords(t,t);const e=t*et();this.envRot.inflateCoords(e,e),e<0&&ve.st_reduceEmpty(this)}static st_reduceEmpty(t){const e=t.envAabb.isEmpty(),s=t.envRot.isEmpty();e&&!s?t.envRot.setEmpty():s&&!e&&t.envAabb.setEmpty()}}function be(t){return t.x-t.y}function Ee(t){return t.x+t.y}class Se{constructor(){this.x=st.getNAN(),this.y=st.getNAN()}static getNAN(){return new Se}static constructPoint2D(t){const e=new Se;return e.x.set(t.x),e.y.set(t.y),e}static constructCoords(t,e){const s=new Se;return s.x.set(t),s.y.set(e),s}static constructCoordsE(t,e){const s=new Se;return s.setCoordsE(t,e),s}get 0(){return this.x.clone()}set 0(t){this.x.setE(t)}get 1(){return this.y.clone()}set 1(t){this.y.setE(t)}clone(){return(new Se).setE(this)}scaleThis(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}setCoords(t,e){return this.x.set(t),this.y.set(e),this}setCoordsE(t,e){return this.x.setE(t),this.y.setE(e),this}set(t){return this.x.set(t.x),this.y.set(t.y),this}setE(t){return this.x.setE(t.x),this.y.setE(t.y),this}setWithEps(t,e){return this.x.setWithEps(t.x,e),this.y.setWithEps(t.y,e),this}getUnitVector(){const t=this.clone();return t.normalize(),t}sqrLength(){return this.x.sqr().addE(this.y.sqr())}length(){return this.sqrLength().sqrt()}mulE(t){const e=new Se;return e.setCoordsE(this.x.mulE(t),this.y.mulE(t)),e}mul(t){const e=new Se;return e.setCoordsE(this.x.mul(t),this.y.mul(t)),e}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mulThisE(t){return this.x.mulThisE(t),this.y.mulThisE(t),this}divE(t){return this.clone().divThisE(t)}divThisE(t){return this.x.divThisE(t),this.y.divThisE(t),this}normalize(){const t=this.length();0===t.value()?(this.x=nt.clone(),this.y=it.clone()):(this.x.divThisE(t),this.y.divThisE(t))}addE(t){return this.clone().addThisE(t)}addThisE(t){return this.x.addThisE(t.x),this.y.addThisE(t.y),this}subE(t){return this.clone().subThisE(t)}subThisE(t){return this.x.subThisE(t.x),this.y.subThisE(t.y),this}static distance(t,e){return t.subE(e).length()}negateThis(){return this.x.negateThis(),this.y.negateThis(),this}eq(t){return this.x.eq(t.x)&&this.y.eq(t.y)}isZero(){return this.x.isZero()&&this.y.isZero()}isTrueZero(){return!this.x.value()&&!this.y.value()}rotateDirect(t,e){const s=this.x.mulE(t).subThisE(this.y.mulE(e)),n=this.x.mulE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}rotateReverse(t,e){const s=this.x.mulE(t).addThisE(this.y.mulE(e)),n=this.x.negate().mulThisE(e).addThisE(this.y.mulE(t));return this.x.setE(s),this.y.setE(n),this}dotProduct(t){return this.x.mulE(t.x).addE(this.y.mulE(t.y))}crossProduct(t){return this.x.mulE(t.y).subE(this.y.mulE(t.x))}value(){return J.construct(this.x.value(),this.y.value())}}class De{constructor(){this.a11=new st(1),this.a12=new st(0),this.a21=new st(0),this.a22=new st(1)}clone(){const t=new De;return t.a11.setE(this.a11),t.a12.setE(this.a12),t.a21.setE(this.a21),t.a22.setE(this.a22),t}assign(t){return this.a11.setE(t.a11),this.a12.setE(t.a12),this.a21.setE(t.a21),this.a22.setE(t.a22),this}mulThis(t){const e=this.a11.mulE(t.a11).addThisE(this.a12.mulE(t.a21)),s=this.a11.mulE(t.a12).addThisE(this.a12.mulE(t.a22)),n=this.a21.mulE(t.a11).addThisE(this.a22.mulE(t.a21)),i=this.a21.mulE(t.a12).addThisE(this.a22.mulE(t.a22));return this.a11=e,this.a12=s,this.a21=n,this.a22=i,this}mulLeftThis(t){const e=t.clone();return this.assign(e.mulThis(this)),this}det(){return this.a11.mulE(this.a22).subThisE(this.a12.mulE(this.a21))}invertThis(){const t=this.det();if(0!==t.value()){const e=this.a22.divE(t),s=this.a12.negate().divThisE(t),n=this.a21.negate().divThisE(t),i=this.a11.divE(t);this.a11=e,this.a12=s,this.a21=n,this.a22=i}else this.setZero();return!t.isZero()}transposeThis(){return this.a21=tt(this.a12,this.a12=this.a21),this}eigenSymmetric(t,e){const s=this.a12.clone();s.addThisE(this.a21),s.mulThisByPower2(.5);let n=new st(1),i=new st(0);if(s.isZero())t[0].setE(this.a11),t[1].setE(this.a22);else{const e=new st(1);if(this.a11.ne(this.a22)){const r=this.a11.subE(this.a22).divE(s);r.mulThisByPower2(.5);const o=r.sqr();e.setE(r),e.absThis(),e.subThisE(o.add(1).sqrtThis()),r.gt(it)&&e.negateThis();const a=e.sqr().addThis(1).sqrtThis().invThis();i=e.mulE(a),n.setE(a);const h=e.mulE(s);t[0]=this.a11.addE(h),t[1]=this.a22.subE(h)}else n=new st(1/Math.sqrt(2)),i=n.clone(),t[0]=this.a11.addE(s),t[1]=this.a22.subE(s)}e[0].x=n.toDouble(),e[0].y=i.toDouble(),e[1].x=i.negate().toDouble(),e[1].y=n.toDouble(),Math.abs(t[0].toDouble())>Math.abs(t[1].toDouble())&&(t[1]=tt(t[0],t[0]=t[1]),e[1]=tt(e[0],e[0]=e[1]))}setZero(){this.a11.set(0),this.a21.set(0),this.a12.set(0),this.a22.set(0)}}var we=I;function Ae(t,e){const s=t.getStartXY();if(s.equals(e.getStartXY()))return!0;if(s.equals(e.getEndXY()))return!0;const n=t.getEndXY();return!!n.equals(e.getStartXY())||!!n.equals(e.getEndXY())}function Te(t,e){let s=t.calculateLowerLength2D();return!(s>e)&&(!!t.isLine()||(s=t.calculateUpperLength2D(),s<=e||0!==e&&t.calculateLength2D()<=e))}function Ie(t,e){const s=t.getEndXY().sub(t.getStartXY()).length(),n=t.calculateUpperLength2D()-s<=e[0];return e[0]*=.1,n}function Me(t,e,n,i,r,o,a,h){let m=t.calculateUpperLength2D(),u=e.calculateUpperLength2D(),l=t,c=e,g=!1;m>u&&(c=tt(l,l=c),i=tt(n,n=i),u=tt(m,m=u),g=!0);const d=0===n;{a[0]=d?1:0;const t=l.getCoord2D(a[0]);h[0]=c.getClosestCoordinate(t,!1);const e=c.getCoord2D(h[0]);if(J.distance(t,e)<=r){const e=[.5,.75,.25,.1,.9];let s=!0;for(let n=0;n<e.length;n++)if(t.assign(l.getCoord2D(e[n])),!c.isCloserThanDistance(t,new U(0,1),r)){s=!1;break}if(s)return g&&(h[0]=tt(a[0],a[0]=h[0])),1}}if(m<=3*r)return 0;let _=lt(Math.max(r/m,.1),0,.5),p=.01*r,f=0,P=0,y=_,x=-1,C=0,v=1/32;for(let b=0;;b++){s(b<4095);const t=d?_:1-_,e=l.getCoord2D(t),n=c.getClosestCoordinate(e,!1);if(n===i)return C;const m=c.getCoord2D(n),u=J.distance(e,m);if(0===b&&(x=u),u<=p?(v=.5,P=u,f=_):(y=_,x=u),Math.abs(P-x)>.1*p&&y-f>1e-16)_=ot(f,y,v);else{if(a[C]=t,h[C]=n,g&&(h[C]=tt(a[C],a[C]=h[C])),1===o||1===C)return 1===C&&a[0]>a[1]&&(a[1]=tt(a[0],a[0]=a[1]),h[1]=tt(h[0],h[0]=h[1])),C+1;C++,f=y,P=x,y=.8,x=-1,_=.8,v=1/32,p=10*r,b=0}}}function Ye(t,e,s,n,i,r,o,a,h){if(ht(s,0,1)&&ht(n,0,1)){if(0===J.distance(t.getCoord2D(s),e.getCoord2D(n))){const h=1e-12,m=new Se,u=ut();if(t.queryDerivative(new st(s,u),m),m.isTrueZero()){const e=1===s?-1e-12:h;t.queryDerivative(new st(s,u).add(e),m)}1===s&&m.negateThis();const l=new Se;if(e.queryDerivative(new st(n,u),l),l.isTrueZero()){const t=1===s?-1e-12:h;e.queryDerivative(new st(n,u).add(t),l)}1===n&&l.negateThis(),m.isZero()||m.normalize(),l.isZero()||l.normalize();const c=m.dotProduct(l),g=m.crossProduct(l);g.scaleError(3);const d=()=>{{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(c.ge(it)&&(g.isZero()||Math.abs(g.value())<d())){return Me(t,e,s,n,i,r,o,a)}}}return 0}function Xe(t,e,n){if(s(t.isCurve()||e.isCurve()),t.getStartXY().equals(e.getStartXY())){if(Ye(t,e,0,0,n,2,[0,0],[0,0]))return!0}if(t.getEndXY().equals(e.getEndXY())){if(Ye(t,e,1,1,n,2,[0,0],[0,0]))return!0}if(t.getStartXY().equals(e.getEndXY())){if(Ye(t,e,0,1,n,2,[0,0],[0,0]))return!0}if(t.getEndXY().equals(e.getStartXY())){if(Ye(t,e,1,0,n,2,[0,0],[0,0]))return!0}return!1}function Ne(t,e){t.m_XStart=e.x,t.m_YStart=e.y}function qe(t,e,s){t.m_XStart=e,t.m_YStart=s}function Fe(t,e){t.m_XEnd=e.x,t.m_YEnd=e.y}function Ve(t,e,s){t.m_XEnd=e,t.m_YEnd=s}function Le(t,e,s){e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified())}function Re(t,e){const s=new Y;return e?(s.x=t.m_XEnd,s.y=t.m_YEnd):(s.x=t.m_XStart,s.y=t.m_YStart),s.z=ze(t,e),s}function ze(t,e){return t.m_description.hasZ()?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)]:we.getDefaultValue(1)}function ke(t,e,s){t.m_description.hasZ()||t.addAttribute(1),e?t.m_XEnd===s.x&&t.m_YEnd===s.y||(t.m_XEnd=s.x,t.m_YEnd=s.y,t.endPointModified()):t.m_XStart===s.x&&t.m_YStart===s.y||(t.m_XStart=s.x,t.m_YStart=s.y,t.endPointModified()),t.m_attributes[(t.m_description.getTotalComponentCount()-2)*e]=s.z}function Be(t,e,s){s.assignVertexDescription(t.m_description);const n=0===e?t.m_XStart:t.m_XEnd,i=0===e?t.m_YStart:t.m_YEnd;s.setXYCoords(n,i);for(let r=1;r<t.m_description.getAttributeCount();r++){const n=t.m_description.getSemantics(r);for(let i=0,r=we.getComponentCount(n);i<r;i++){const r=We(t,e,n,i);s.setAttributeBasic(n,i,r)}}}function Ge(t,e,s){s.isEmpty()&&o(""),Le(t,e,s.getXY());const n=s.getDescription();n!==t.m_description&&t.mergeVertexDescription(n);for(let i=1,r=n.getAttributeCount();i<r;i++){const r=n.getSemantics(i),o=we.getComponentCount(r);for(let n=0;n<o;n++){je(t,e,r,n,s.getAttributeAsDbl(r,n))}}}function We(t,e,s,i){if((e<0||e>1)&&n(""),0===s)return(i<0||i>=2)&&n(""),0===e?0===i?t.m_XStart:t.m_YStart:0===i?t.m_XEnd:t.m_YEnd;const r=we.getComponentCount(s);(i<0||i>=r)&&n("");const o=t.m_description.getAttributeIndex(s);return o>=0?t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(o)-2+i]:we.getDefaultValue(s)}function je(t,e,s,i,r){if((e<0||e>1)&&n(""),0===s)return 0===e?0===i?t.m_XStart=r:1===i?t.m_YStart=r:n(""):1===e?0===i?t.m_XEnd=r:1===i?t.m_YEnd=r:n(""):n(""),void t.endPointModified();const o=we.getComponentCount(s);(i<0||i>=o)&&n("");let a=t.m_description.getAttributeIndex(s);a<0&&(t.addAttribute(s),a=t.m_description.getAttributeIndex(s)),t.m_attributes[e*(t.m_description.getTotalComponentCount()-2)+t.m_description.getPointAttributeOffset(a)-2+i]=r}function Ze(t,e){if(t===e)return;e.isEmpty()&&o("");const s=e.getDescription();s!==t.m_description&&t.mergeVertexDescription(s);for(let n=1,i=s.getAttributeCount();n<i;n++){const i=s.getSemantics(n),r=we.getComponentCount(i);for(let s=0;s<r;s++){let n=We(e,0,i,s);je(t,0,i,s,n),n=We(e,1,i,s),je(t,1,i,s,n)}}}function He(t,e){const s=S();D(e,t.m_description,s);let n=null;const i=e.getTotalComponentCount()-2,r=t.m_description?t.m_description.getTotalComponentCount()-2:0;if(i>0&&(n=O(2*i,Number.NaN),K(n,e.getDefaultPointAttributes(),0,2,i),K(n,e.getDefaultPointAttributes(),i,2,i),null!==t.m_description))for(let o=1;o<e.getAttributeCount();o++){const a=s[o];if(-1!==a){const s=t.m_description.getPointAttributeOffset(a)-2,h=e.getPointAttributeOffset(o)-2,m=we.getComponentCount(e.getSemantics(o));for(let e=0;e<m;++e)n[h]=t.m_attributes[s],n[i+h]=t.m_attributes[r+s]}}t.m_attributes=n,t.m_description=e}function Ue(t){return t.absNorm()*rt()}function Oe(t,e){return Math.max(t.absNorm(),e.absNorm())*rt()}function Qe(t,e,s){const n=new ve;t.queryEnvelopeW(U.unit(),n);const i=new ve;return e.queryEnvelopeW(U.unit(),i),i.inflate(s),!n.isIntersectingW(i)}function Je(t,e,s){const n=mt(t,s),i=mt(e,s);n.sort(((t,e)=>t.compare(e))),i.sort(((t,e)=>t.compare(e)));for(let r=0;r<3;r++){if(n[r].compare(i[r])<0)return-1;if(0!==n[r].compare(i[r]))return 1}return 0}var Ke=I;class $e{constructor(t){if(t.copy){if(this.m_XStart=t.copy.m_XStart,this.m_YStart=t.copy.m_YStart,this.m_XEnd=t.copy.m_XEnd,this.m_YEnd=t.copy.m_YEnd,this.m_description=t.copy.m_description,this.m_attributes=null,this.m_description){this.m_description.getTotalComponentCount()-2&&(this.m_attributes=t.copy.m_attributes.slice())}}else{if(t.move)return this.m_description=t.move.m_description,t.move.m_description=null,this.m_attributes=t.move.m_attributes,t.move.m_attributes=null,this.m_XStart=t.move.m_XStart,this.m_YStart=t.move.m_YStart,this.m_XEnd=t.move.m_XEnd,void(this.m_YEnd=t.move.m_YEnd);if(void 0!==t.XStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_attributes=null,this.m_description=t.vd?t.vd:f(),void(t.vd&&this.setDefaultAttributeValues());if(void 0!==t.ZStart)return this.m_XStart=t.XStart,this.m_YStart=t.YStart,this.m_XEnd=t.XEnd,this.m_YEnd=t.YEnd,this.m_description=t.vd?t.vd:X(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.ZStart,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.ZEnd):this.m_attributes=[t.ZStart,t.ZEnd]);if(t.start)return this.m_XStart=t.start.x,this.m_YStart=t.start.y,this.m_XEnd=t.end.x,this.m_YEnd=t.end.y,this.m_attributes=null,void(this.m_description=f());if(t.start3D)return this.m_XStart=t.start3D.x,this.m_YStart=t.start3D.y,this.m_XEnd=t.end3D.x,this.m_YEnd=t.end3D.y,this.m_description=t.vd?t.vd:X(),void(t.vd?(this.setDefaultAttributeValues(),this.addAttribute(1),this.m_attributes[0]=t.start3D.z,this.m_attributes[this.m_description.getTotalComponentCount()-2]=t.end3D.z):this.m_attributes=[t.start3D.z,t.end3D.z]);h("bad constructor params"),this.m_XStart=this.m_YStart=this.m_XEnd=this.m_YEnd=Number.NaN}}setDefaultAttributeValues(){const t=this.m_description.getTotalComponentCount()-2;t>0&&(null===this.m_attributes&&(this.m_attributes=O(2*t,Number.NaN)),K(this.m_attributes,this.m_description.getDefaultPointAttributes(),0,2,t),K(this.m_attributes,this.m_description.getDefaultPointAttributes(),t,2,t))}absNormXYZ(t){return a("not implemented"),0}snapControlPoints3D(){return a("not implemented"),!1}setCoordsForIntersector3D(t,e,s){a("not implemented")}transformAttribute(t,e,s,n,i){a("")}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=y(e,t);this.assignVertexDescription(s)}changeEndPoints(t,e){const s=t.getXY(),n=e.getXY();this.changeEndPoints2D(s,n);let i=t.getDescription();i!==this.getDescription()&&this.mergeVertexDescription(i),i=e.getDescription(),i!==this.getDescription()&&this.mergeVertexDescription(i);for(let r=1,o=i.getAttributeCount();r<o;r++){const s=i.getSemantics(r),n=Ke.getComponentCount(s);for(let i=0;i<n;i++){je(this,0,s,i,t.getAttributeAsDbl(s,i));je(this,1,s,i,e.getAttributeAsDbl(s,i))}}}getStartXY(){return new J(this.m_XStart,this.m_YStart)}setStartXY(t){this.m_XStart=t.x,this.m_YStart=t.y,this.endPointModified()}setStartXYCoords(t,e){this.m_XStart=t,this.m_YStart=e,this.endPointModified()}getStartXYZ(){return Re(this,0)}setStartXYZ(t){ke(this,0,t)}setStartXYZCoords(t,e,s){ke(this,0,Y.construct(t,e,s))}queryStart(t){Be(this,0,t)}setStart(t){Ge(this,0,t)}setStart2D(t){this.setStartXY(t)}getStartAttributeAsDbl(t,e){return We(this,0,t,e)}getStartAttributeAsInt(t,e){return s(0),0}setStartAttribute(t,e,s){je(this,0,t,e,s)}setStartAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=Ke.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setStartAttribute(e,s,n)}}}setEndAttributesFromPoint(t,e){const s=t.getDescription();for(let n=e&&s.hasZ()?2:1,i=s.getAttributeCount();n<i;++n){const e=s.getSemantics(n),i=Ke.getComponentCount(e);for(let s=0;s<i;++s){const n=t.getAttributeAsDbl(e,s);this.setEndAttribute(e,s,n)}}}getStartX(){return this.m_XStart}getStartY(){return this.m_YStart}getStartZ(){return s(0),0}getEndX(){return this.m_XEnd}getEndY(){return this.m_YEnd}getEndZ(){return s(0),0}getEndXY(){return new J(this.m_XEnd,this.m_YEnd)}setEndXY(t){this.m_XEnd=t.x,this.m_YEnd=t.y,this.endPointModified()}setEndXYCoords(t,e){this.m_XEnd=t,this.m_YEnd=e,this.endPointModified()}getEndXYZ(){return Re(this,1)}setEndXYZ(t){ke(this,1,t)}setEndXYZCoords(t,e,s){ke(this,1,Y.construct(t,e,s))}queryEnd(t){Be(this,1,t)}setEnd(t){Ge(this,1,t)}setEnd2D(t){this.setEndXY(t)}getEndAttributeAsDbl(t,e){return We(this,1,t,e)}getEndAttributeAsInt(t,e){return s(0),Math.trunc(0)}setEndAttribute(t,e,s){je(this,1,t,e,s)}getDimension(){return 1}copyTo(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&e("");const s=t;s.assignVertexDescription(this.m_description),s.m_attributes&&K(s.m_attributes,this.m_attributes,0,0,2*(this.m_description.getTotalComponentCount()-2)),s.m_XStart=this.m_XStart,s.m_YStart=this.m_YStart,s.m_XEnd=this.m_XEnd,s.m_YEnd=this.m_YEnd,this.copyToImpl(s)}isEmpty(){return this.isEmptyImpl()}isClosed(){return this.m_XStart===this.m_XEnd&&this.m_YStart===this.m_YEnd}setEmpty(){}calculateArea2D(){return 0}queryInterval(t,e){const s=U.constructEmpty();return s.vmin=We(this,0,t,e),s.vmax=s.vmin,s.mergeNeCoordinate(We(this,1,t,e)),s}calculateLength3D(t){return s(0),0}getCoord3D(t){return s(0),{}}getCoord2D(t){const e=J.getNAN();return this.queryCoord2D(t,e),e}queryCoord3D(t,e){s(0)}getCoordZ(t){return s(0),0}queryCoord(t,e){e.assignVertexDescription(this.m_description),e.setXY(this.getCoord2D(t));for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const n=this.m_description.getSemantics(s),i=Ke.getComponentCount(n);for(let s=0;s<i;s++){const i=this.getAttributeAsDbl(t,n,s);e.setAttributeBasic(n,s,i)}}}isCloserThanDistance(t,e,s){const n=oe.constructEmpty();this.queryLooseEnvelopeOnInterval(e,n);if(n.distance(t)>s)return!1;const i=this.getClosestCoordinateOnInterval(t,e,s);return!Number.isNaN(i)&&J.distance(t,this.getCoord2D(i))<=s}isMonotoneQuickAndDirty(){return!1}isTrue3D(){return!1}getReversed(){const t=this.clone();return t.reverse(),t}reverse(){this.m_XEnd=tt(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=tt(this.m_YStart,this.m_YStart=this.m_YEnd),this.reverseImpl();for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t);for(let t=0,s=Ke.getComponentCount(e);t<s;t++){const s=We(this,0,e,t);je(this,0,e,t,We(this,1,e,t)),je(this,1,e,t,s)}}return this.afterCompletedModification(),this}isEmptyImpl(){return!1}isCircular(){return!1}distance(t,e,n,i){if(!e&&this.isIntersecting(t,0,!1)){if(null!==n||null!==i){const e=O(9,Number.NaN),r=O(9,Number.NaN),o=this.intersect(t,null,e,r,0);s(o<=9),0===o&&h(""),null!==n&&(n[0]=e[0]),null!==i&&(i[0]=r[0])}return 0}let r,o=Number.MAX_VALUE,a=-1,m=o;return r=this.getStartXY(),a=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==i&&(i[0]=a),null!==n&&(n[0]=0)),r=this.getEndXY(),a=t.getClosestCoordinate(r,!1),r.subThis(t.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==i&&(i[0]=a),null!==n&&(n[0]=1)),r=t.getStartXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==n&&(n[0]=a),null!==i&&(i[0]=0)),r=t.getEndXY(),a=this.getClosestCoordinate(r,!1),r.subThis(this.getCoord2D(a)),m=r.length(),m<o&&(o=m,null!==n&&(n[0]=a),null!==i&&(i[0]=1)),o}calculateSubLengthFromStart(t){return this.tToLength(t)}calculateSubLength(t,e){return e===t?0:this.tToLength(e)-this.tToLength(t)}static recalculateParentT(t,e,s){return ot(t,e,s)}moveTo(t){const e=this.isClosed(),s=new ae;s.setShift(t.sub(this.getStartXY())),this.applyTransformation(s),e?this.changeEndPoints2D(t,t):this.changeEndPoints2D(t,this.getEndXY())}moveTo3D(t){s(0)}getDescription(){return this.m_description}assignVertexDescription(t){He(this,t)}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=x(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=C(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=f();t!==this.m_description&&this.assignVertexDescription(t)}swap(t){if(this===t)return;t.getGeometryType()!==this.getGeometryType()&&e("wrong geometry type");const s=t;s.m_description=tt(this.m_description,this.m_description=s.m_description),s.m_XStart=tt(this.m_XStart,this.m_XStart=s.m_XStart),s.m_YStart=tt(this.m_YStart,this.m_YStart=s.m_YStart),s.m_XEnd=tt(this.m_XEnd,this.m_XEnd=s.m_XEnd),s.m_YEnd=tt(this.m_YEnd,this.m_YEnd=s.m_YEnd),s.m_attributes=tt(this.m_attributes,this.m_attributes=s.m_attributes),this.swapImpl(s)}equals(t,e){if(this.getGeometryType()!==t.getGeometryType())return!1;const s=void 0===e;s&&(e=0);const n=t;if(this===n)return!0;if(this.m_description!==n.m_description)return!1;if(Math.abs(this.m_XStart-n.m_XStart)>e||Math.abs(this.m_XEnd-n.m_XEnd)>e||Math.abs(this.m_YStart-n.m_YStart)>e||Math.abs(this.m_YEnd-n.m_YEnd)>e)return!1;for(let i=0,r=2*(this.m_description.getTotalComponentCount()-2);i<r;i++)if(!at(this.m_attributes[i],n.m_attributes[i],e))return!1;return s?this.equalsImpl(n):this.equalsImplTol(n,e)}getImpl(){return this}setAttributeBasic(t,s,n){if(this.addAttribute(t),0===t&&this.isCurve()){(s<0||s>1)&&e("");const t=new ae,i=0===s?n:0,r=1===s?n:0;t.setShiftCoords(i,r),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else this.setStartAttribute(t,s,n),this.setEndAttribute(t,s,n)}replaceNaNs(t,e){if(this.addAttribute(t),this.isEmpty())return;const s=Ke.getComponentCount(t);for(let n=0;n<s;n++){const s=this.getStartAttributeAsDbl(t,n);Number.isNaN(s)&&this.setStartAttribute(t,n,e);const i=this.getEndAttributeAsDbl(t,n);Number.isNaN(i)&&this.setEndAttribute(t,n,e)}}}$e.s_maxMonotonicPartParams=8;class ts extends he{constructor(t,e){super(),this.m_index=-1,this.gc=t,this.dim=e}next(){for(;;){if(this.m_index>=this.gc.getGeometryCount())return null;if(this.m_index++,this.m_index===this.gc.getGeometryCount())return null;const t=this.gc.getGeometry(this.m_index);if(-1===this.dim||1<<t.getDimension()&this.dim)return t}return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}}class es{constructor(t){this.m_geoms=[],this.m_description=f(),t&&(t.vd?this.m_description=t.vd:t.copy?t.copy.copyTo(this):e("constructor argument not recognized"))}getGeometryCount(){return this.m_geoms.length}reserve(t){}addGeometry(t){if(t.getGeometryType()===i.enumGeometryCollection){const e=t;for(let t=0,s=e.getGeometryCount();t<s;t++)this.addGeometry(e.getGeometry(t))}else this.m_geoms.push(t.clone()),this.mergeVertexDescription(t.getDescription())}addCursor(t){for(let e=t.next();null!==e;e=t.next())this.addGeometry(e)}getGeometry(t){return(t<0||t>=this.m_geoms.length)&&e("Geometry_collection.get_geometry"),this.m_geoms[t]}modifiedElementIndex(t){this.mergeVertexDescription(this.getGeometry(t).getDescription())}modifiedElement(t){this.mergeVertexDescription(t.getDescription())}getGeometryType(){return i.enumGeometryCollection}getDimension(){let t=0;for(const e of this.m_geoms)t=Math.max(t,e.getDimension());return t}getDescription(){return this.m_description}assignVertexDescription(t){this.m_description!==t&&this.assignVertexDescriptionImpl(t)}assignVertexDescriptionImpl(t){for(const e of this.m_geoms)e.assignVertexDescription(t);this.m_description=t}mergeVertexDescription(t){this.m_description!==t&&(this.m_description.hasAttributesFrom(t)||this.mergeVertexDescriptionImpl(t))}hasAttribute(t){return this.m_description.hasAttribute(t)}addAttribute(t){if(this.m_description.hasAttribute(t))return;const e=x(this.m_description,t);this.assignVertexDescription(e)}dropAttribute(t){if(!this.m_description.hasAttribute(t))return;const e=C(this.m_description,t);this.assignVertexDescription(e)}dropAllAttributes(){const t=f();t!==this.m_description&&this.assignVertexDescription(t)}queryInterval(t,e){let s=new U;const n=new U;n.setEmpty();for(const i of this.m_geoms)s=i.queryInterval(t,e),n.merge(s);return n}queryEnvelope(t){if(4===t.m_EnvelopeType){const e=new A;t.setEmpty(),t.assignVertexDescription(this.m_description);for(const s of this.m_geoms)s.queryEnvelope(e),t.merge(e)}else if(2===t.m_EnvelopeType){const e=new oe;t.setEmpty();for(const s of this.m_geoms)s.queryEnvelope(e),t.mergeEnvelope2D(e)}a("3d envelope case not implemented")}queryLooseEnvelope(t){if(2===t.m_EnvelopeType){const e=new oe;t.setEmpty();for(const s of this.m_geoms)s.queryLooseEnvelope(e),t.mergeEnvelope2D(e)}a("3d not impl")}isEmpty(){return 0===this.m_geoms.length}setEmpty(){this.m_geoms.length=0}applyTransformation(t){if(1===t.m_TransformationType)for(const e of this.m_geoms)e.applyTransformation(t);a("3d xform not impl")}transformAttribute(t,e,s,n,i){for(const r of this.m_geoms)r.transformAttribute(t,e,s,n,i)}createInstance(){return new es({vd:this.getDescription()})}copyTo(t){t.getGeometryType()!==i.enumGeometryCollection&&e("");const s=t;if(s!==this){s.m_geoms.length=0,s.assignVertexDescription(this.m_description);for(const t of this.m_geoms)s.m_geoms.push(t.clone())}}calculateArea2D(){const t=new ct(0);for(const e of this.m_geoms)t.pe(e.calculateArea2D());return t.getResult()}calculateLength2D(){const t=new ct(0);for(const e of this.m_geoms)t.pe(e.calculateLength2D());return t.getResult()}calculateLength3D(t){return s(0),0}getBoundary(){const t=this.createInstance(),e=t;for(const s of this.m_geoms){const t=s.getBoundary();t&&e.m_geoms.push(t)}return t}clone(){return new es({copy:this})}equals(t,e){if(t===this)return!0;if(t.getGeometryType()!==i.enumGeometryCollection)return!1;const s=t;if(this.m_description!==s.m_description)return!1;if(this.m_geoms.length!==s.m_geoms.length)return!1;for(let n=0;n<this.m_geoms.length;++n)if(!this.m_geoms[n].equals(s.m_geoms[n],e))return!1;return!0}swap(t){t.getGeometryType()!==i.enumGeometryCollection&&e("");const s=t;s!==this&&(this.m_geoms=tt(s.m_geoms,s.m_geoms=this.m_geoms))}setAttributeBasic(t,e,s){for(const n of this.m_geoms)n.setAttributeBasic(t,e,s)}replaceNaNs(t,e){for(const s of this.m_geoms)s.replaceNaNs(t,e)}getImpl(){return this}mergeVertexDescriptionImpl(t){const e=this.getDescription(),s=y(e,t);this.assignVertexDescription(s)}}function ss(t,e=-1){return new ts(t,e)}es.type=i.enumGeometryCollection;class ns extends $e{constructor(t){super(t)}}class is extends ns{isTrue3D(){return!0}constructor(t){super(t)}}function rs(t,e,s){os(e,t.getStartXY(),t.getEndXY(),s)}function os(t,e,s,n){St(e,s,t,n)}function as(t,e){return ot(t.m_XStart,t.m_XEnd,e)}function hs(t,e){return ot(t.m_YStart,t.m_YEnd,e)}function ms(t,e){const s=t.getStartZ(),n=t.getEndZ();return ot(s,n,e)}function us(t,e,s){const n=Se.constructPoint2D(t.getStartXY()),i=Se.constructPoint2D(t.getEndXY());s.setCoordsE(i.x.subE(n.x),i.y.subE(n.y))}function ls(t,e,s){e.value()<=.5?It(2,Se.constructPoint2D(t.getStartXY()),Se.constructPoint2D(t.getEndXY()),e,s):Mt(2,Se.constructPoint2D(t.getStartXY()),Se.constructPoint2D(t.getEndXY()),e,s)}function cs(t,e,s){t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,t.afterCompletedModification()}function gs(t,e){const s=t.getStartXYZ();s.z*=e;const n=t.getEndXYZ();return n.z*=e,s.norm(1)+n.norm(1)}function ds(t){if(t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart){t.m_XEnd=tt(t.m_XStart,t.m_XStart=t.m_XEnd),t.m_YEnd=tt(t.m_YStart,t.m_YStart=t.m_YEnd);for(let e=0,s=t.m_description.getTotalComponentCount()-2;e<s;e++)t.m_attributes[e+s]=tt(t.m_attributes[e],t.m_attributes[e]=t.m_attributes[e+s])}}function _s(t,e,s,n){let i=0;if((t.m_XStart===e.m_XStart&&t.m_YStart===e.m_YStart||t.m_XStart===e.m_XEnd&&t.m_YStart===e.m_YEnd)&&(i++,!n))return 1;if(t.m_XEnd===e.m_XStart&&t.m_YEnd===e.m_YStart||t.m_XEnd===e.m_XEnd&&t.m_YEnd===e.m_YEnd){if(i++,2===i)return 2;if(!n)return 1}return e.isIntersectingPoint(t.getStartXY(),s,!0)||e.isIntersectingPoint(t.getEndXY(),s,!0)||t.isIntersectingPoint(e.getStartXY(),s,!0)||t.isIntersectingPoint(e.getEndXY(),s,!0)?4:n&&i?0:Ps(t,e)?4:0}function ps(t,e,s,n,i,r,o,a){null!==n&&Gt(n,2,Number.NaN),null!==i&&Gt(i,2,Number.NaN),null!==s&&Wt(s,J,2);const h=fs(t,e,2,s,n,i,r,o,a);return n&&(n.length=h),i&&(i.length=h),s&&(s.length=h),h}function fs(t,e,s,n,i,r,o,a,h){const m=xs(t,e.getStartXY(),o,!1),u=xs(t,e.getEndXY(),o,!1),l=xs(e,t.getStartXY(),o,!1),c=xs(e,t.getEndXY(),o,!1);let g=0,d=0;if(!Number.isNaN(m)){let s=!1;a&&ht(m,0,1)&&t.getCoord2D(m).isEqualPoint2D(e.getStartXY())&&(g++,s=!0),s||(i&&(i[d]=m),r&&(r[d]=0),n&&n[d].setCoords(e.m_XStart,e.m_YStart),d++)}if(!Number.isNaN(u)){let o=!1;a&&ht(u,0,1)&&t.getCoord2D(u).isEqualPoint2D(e.getEndXY())&&(g++,o=!0),o||(s>d&&(i&&(i[d]=u),r&&(r[d]=1),n&&n[d].setCoords(e.m_XEnd,e.m_YEnd)),d++)}if(2!==d&&!Number.isNaN(l)&&!(0===m&&0===l||0===u&&1===l)){let o=!1;a&&ht(l,0,1)&&e.getCoord2D(l).isEqualPoint2D(t.getStartXY())&&(g++,o=!0),o||(s>d&&(i&&(i[d]=0),r&&(r[d]=l),n&&n[d].setCoords(t.m_XStart,t.m_YStart)),d++)}if(2!==d&&!Number.isNaN(c)&&!(1===m&&0===c||1===u&&1===c)){let o=!1;a&&ht(c,0,1)&&e.getCoord2D(c).isEqualPoint2D(t.getEndXY())&&(g++,o=!0),o||(s>d&&(i&&(i[d]=1),r&&(r[d]=c),n&&n[d].setCoords(e.m_XEnd,e.m_YEnd)),d++)}if(d>0)return h&&(r=tt(i,i=r)),2===d&&s>=2&&i&&i[0]>i[1]&&(i[1]=tt(i[0],i[0]=i[1]),r&&(r[1]=tt(r[0],r[0]=r[1])),n&&(n[1]=tt(n[0],n[0]=n[1]))),d;if(g>0)return 0;const _=Ss(t,e,o);return Number.isNaN(_.x)?0:(n&&(n[0]=t.getCoord2D(_.x)),i&&(i[0]=_.x),r&&(r[0]=_.y),1)}function Ps(t,e){const s=Cs(t,e.m_XStart,e.m_YStart),n=Cs(t,e.m_XEnd,e.m_YEnd);if(s<0&&n<0||s>0&&n>0)return!1;const i=Cs(e,t.m_XStart,t.m_YStart),r=Cs(e,t.m_XEnd,t.m_YEnd);if(i<0&&r<0||i>0&&r>0)return!1;return Es(t)>Es(e)?bs(t,e):bs(e,t)}function ys(t,e){const s={bIntersect:!1,t1:Number.NaN,t2:Number.NaN},n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return s;const h=e.m_XStart-t.m_XStart,m=e.m_YStart-t.m_YStart,u=r*m-h*o,l=n*m-h*i,c=1/a;return s.t1=u*c,s.t2=l*c,s.bIntersect=!0,s}function xs(t,e,s,n){const i=J.getNAN(),r=J.getNAN();let o=!1;t.m_YEnd<t.m_YStart||t.m_YEnd===t.m_YStart&&t.m_XEnd<t.m_XStart?(i.setCoords(t.m_XEnd,t.m_YEnd),r.setCoords(t.m_XStart,t.m_YStart),o=!0):(i.setCoords(t.m_XStart,t.m_YStart),r.setCoords(t.m_XEnd,t.m_YEnd));const a=o?1:0,h=o?0:1,m=J.getNAN();m.setSub(e,i);let u=m.length(),l=3*u*ut();if(u<=Math.max(s,l))return n&&0===u?Number.NaN:a;if(m.setSub(e,r),u=m.length(),l=3*u*ut(),u<=Math.max(s,l))return n&&0===u?Number.NaN:h;m.setCoords(r.x-i.x,r.y-i.y);const c=m.length();if(c>0){const t=1/c;m.scale(t);const n=J.getNAN();n.setSub(e,i);const u=n.dotProduct(m),l=8*n.dotProductAbs(m)*ut();m.leftPerpendicularThis();const g=n.dotProduct(m),d=8*n.dotProductAbs(m)*ut(),_=Math.max(s,l);if(u<-_||u>c+_)return Number.NaN;const p=Math.max(s,d);if(Math.abs(g)<=p){let n=u*t;n=lt(n,0,1);const m=J.getNAN();if(os(n,i,r,m),J.distance(m,e)<=s){if(n<.5){if(J.distance(m,i)<=s&&J.distance(e,i)<=s)return a}else if(J.distance(m,r)<=s&&J.distance(e,r)<=s)return h;return o?1-n:n}}}return Number.NaN}function Cs(t,e,s){const n=J.getNAN();n.setCoords(e,s),n.subThis(t.getStartXY());const i=J.getNAN();i.setSub(t.getEndXY(),t.getStartXY());const r=i.crossProduct(n),o=4*ut()*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?-1:r<-o?1:0}function vs(t,e,s,n){const i=n?t.m_XStart:t.m_XEnd,r=n?t.m_YStart:t.m_YEnd,o=J.getNAN();o.x=e.getEndX()-i,o.y=e.getEndY()-r;if(s.dotProduct(o)>3*ut()*s.dotProductAbs(o)){o.x=e.getStartX()-i,o.y=e.getStartY()-r;return s.dotProduct(o)<=3*ut()*s.dotProductAbs(o)}return!0}function bs(t,e){const s=J.getNAN();return s.x=t.m_XEnd-t.m_XStart,s.y=t.m_YEnd-t.m_YStart,!!vs(t,e,s,!1)&&(s.negateThis(),!!vs(t,e,s,!0))}function Es(t){const e=t.m_XStart-t.m_XEnd,s=t.m_YStart-t.m_YEnd;return e*e+s*s}function Ss(t,e,s){const n=t.m_XEnd-t.m_XStart,i=t.m_YEnd-t.m_YStart,r=e.m_XEnd-e.m_XStart,o=e.m_YEnd-e.m_YStart,a=r*i-n*o;if(0===a)return J.getNAN();const h=4*ut()*(Math.abs(r*i)+Math.abs(n*o)),m=e.m_XStart-t.m_XStart,u=e.m_YStart-t.m_YStart,l=r*u-m*o,c=4*ut()*(Math.abs(r*u)+Math.abs(m*o)),g=l/a,d=Math.abs(a),_=(c*d+h*Math.abs(l))/(a*a)+ut()*Math.abs(g);if(g<-_||g>1+_)return J.getNAN();const p=n*u-m*i,f=p/a,P=(4*ut()*(Math.abs(n*u)+Math.abs(m*i))*d+h*Math.abs(p))/(a*a)+ut()*Math.abs(f);if(f<-P||f>1+P)return J.getNAN();let y=lt(g,0,1),x=lt(f,0,1);const C=J.getNAN();rs(t,y,C);const v=J.getNAN();if(rs(e,x,v),!s||J.distance(C,v)>s){const n=J.getNAN();St(C,v,.5,n),y=t.getClosestCoordinate(n,!1),x=e.getClosestCoordinate(n,!1);const i=J.getNAN();rs(t,y,i);const r=J.getNAN();rs(e,x,r),i.subThis(r);const o=i.length(),a=(t.absNorm()+e.absNorm())*rt();if(o>Math.max(s,a))return J.getNAN()}return new J(y,x)}class Ds{constructor(t){if(this.m_segFlagStream=null,this.m_xyStream=null,this.m_bCirculator=!1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_parent=t.parent,this.m_buffer=new this.m_parent.m_segmentBufferCTor,this.m_description=t.parent.getDescription(),this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),void 0!==t.pointIndex){(t.pointIndex<0||t.pointIndex>=t.parent.getPointCount())&&n("");const e=t.parent.getPathIndexFromPointIndex(t.pointIndex);this.m_currentPathIndex=e,this.m_nextPathIndex=e+1,this.m_nextSegmentIndex=t.pointIndex-t.parent.getPathStart(e),this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex)}else if(void 0!==t.pathIndex){(t.pathIndex<0||t.pathIndex>=t.parent.getPathCount()||t.segmentIndex<0)&&n("");const e=t.parent.isClosedPath(t.pathIndex)?0:1;t.segmentIndex>=t.parent.getPathSize(t.pathIndex)-e&&n(""),this.m_nextSegmentIndex=t.segmentIndex,this.m_currentPathIndex=t.pathIndex,this.m_nextPathIndex=this.m_nextSegmentIndex+1,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex)}this.prepare(),this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1,this.m_bStripAttributes=!1,this.m_prevPathIndex=-1,this.m_prevSegmentIndex=-1,this.m_bNeedsUpdate=!1,this.m_currentPathIndex>-1&&(this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex))}stripAttributes(){this.m_bStripAttributes=!0}prepare(){this.m_bCirculator=!1,this.m_parent.isEmptyImpl()?(this.m_segFlagStream=null,this.m_xyStream=null):(this.m_segFlagStream=this.m_parent.getSegmentFlagsStreamRef(),this.m_xyStream=this.m_parent.getAttributeStreamRef(0))}nextPath(){return this.m_currentPathIndex=this.m_nextPathIndex,!(this.m_currentPathIndex>=this.m_parent.getPathCount())&&(this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_currentPathIndex),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.m_nextPathIndex++,!0)}previousPath(){return 0!==this.m_nextPathIndex&&(this.m_nextPathIndex--,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0,this.m_segmentCount=this.getSegmentCount(this.m_nextPathIndex),this.m_currentPathIndex=this.m_nextPathIndex,this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex),this.resetToLastSegment(),!0)}getSegmentCount(t){return this.m_parent.isEmptyImpl()?0:this.m_parent.getSegmentCountPath(t)}resetToFirstPath(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_nextPathIndex=0,this.m_currentPathIndex=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}resetToLastPath(){this.m_nextPathIndex=this.m_parent.getPathCount(),this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1}resetToPath(t){(t<0||t>this.m_parent.getPathCount())&&n(""),this.m_nextPathIndex=t,this.m_currentPathIndex=-1,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=-1,this.m_segmentCount=-1,this.m_pathBegin=-1,this.m_bCurrentPathClosed=!1}isLastPath(){return this.m_currentPathIndex===this.m_parent.getPathCount()-1}isFirstSegmentInPath(){return 0===this.m_currentSegmentIndex}isLastSegmentInPath(){return this.m_currentSegmentIndex===this.m_segmentCount-1}resetToFirstSegment(){this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=0}resetToLastSegment(){this.m_nextSegmentIndex=this.m_segmentCount,this.m_currentSegmentIndex=-1}resetTo(t){this.m_parent!==t.m_parent&&d(""),this.m_currentSegmentIndex=t.m_currentSegmentIndex,this.m_nextSegmentIndex=t.m_nextSegmentIndex,this.m_currentPathIndex=t.m_currentPathIndex,this.m_nextPathIndex=t.m_nextPathIndex,this.m_segmentCount=t.m_segmentCount,this.m_bCirculator=t.m_bCirculator,this.m_pathBegin=t.m_pathBegin,this.m_bCurrentPathClosed=t.m_bCurrentPathClosed,this.m_bStripAttributes=t.m_bStripAttributes,this.m_description=t.m_description}resetToVertex(t,e){if(this.m_currentPathIndex>=0&&this.m_currentPathIndex<this.m_parent.getPathCount()){const e=this.getPathBegin();if(t>=e&&t<this.m_parent.getPathEnd(this.m_currentPathIndex))return this.m_currentSegmentIndex=-1,void(this.m_nextSegmentIndex=t-e)}let s;s=e>=0&&e<this.m_parent.getPathCount()&&t>=this.m_parent.getPathStart(e)&&t<this.m_parent.getPathEnd(e)?e:this.m_parent.getPathIndexFromPointIndex(t),this.m_nextPathIndex=s+1,this.m_currentPathIndex=s,this.m_currentSegmentIndex=-1,this.m_nextSegmentIndex=t-this.m_parent.getPathStart(s),this.m_segmentCount=this.getSegmentCount(s),this.m_pathBegin=this.m_parent.getPathStart(this.m_currentPathIndex),this.m_bCurrentPathClosed=this.m_parent.isClosedPath(this.m_currentPathIndex)}hasNextSegment(){return this.m_nextSegmentIndex<this.m_segmentCount}hasPreviousSegment(){return this.m_nextSegmentIndex>0}nextSegment(){return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&n("Segment_iterator_impl::next_segment"),this.m_nextSegmentIndex++),this.m_buffer.get()}previousSegment(){return this.m_bCirculator?this.m_nextSegmentIndex=(this.m_segmentCount+this.m_nextSegmentIndex-1)%this.m_segmentCount:(0===this.m_nextSegmentIndex&&n(""),this.m_nextSegmentIndex--),this.m_nextSegmentIndex!==this.m_currentSegmentIndex&&this.updateSegment(),this.m_buffer.get()}nextCurve(){if(!this.m_parent.hasNonLinearSegments())return this.resetToLastSegment(),null;let t=0;for(;;){if(this.m_nextSegmentIndex===this.m_segmentCount||t===this.m_segmentCount)return null;const e=this.getPathBegin()+this.m_nextSegmentIndex;if(1!==(31&this.m_segFlagStream.read(e))){this.updateSegment();break}this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:this.m_nextSegmentIndex++,t++}return this.m_currentSegmentIndex!==this.m_nextSegmentIndex&&this.updateSegment(),this.m_bCirculator?this.m_nextSegmentIndex=(this.m_nextSegmentIndex+1)%this.m_segmentCount:(this.m_nextSegmentIndex===this.m_segmentCount&&n(""),this.m_nextSegmentIndex++),this.m_buffer.get()}getPathBegin(){return this.m_pathBegin}getPathIndex(){return this.m_currentPathIndex}getStartPointIndex(){return this.getPathBegin()+this.m_currentSegmentIndex}getEndPointIndex(){return this.isClosingSegment()?this.getPathBegin():this.getStartPointIndex()+1}updateSegment(){(this.m_nextSegmentIndex<0||this.m_nextSegmentIndex>=this.m_segmentCount||this.m_currentPathIndex<0)&&n(""),this.m_currentSegmentIndex=this.m_nextSegmentIndex,this.m_parent.getSegmentFromPath(this.m_currentPathIndex,this.m_currentSegmentIndex,this.m_buffer,this.m_bStripAttributes)}isClosingSegment(){return this.m_bCurrentPathClosed&&this.m_currentSegmentIndex===this.m_segmentCount-1}isCurve(){if(null!==this.m_segFlagStream){return 1!==(31&this.m_segFlagStream.read(this.m_currentSegmentIndex))}return!1}isPathClosed(){return this.m_bCurrentPathClosed}setCirculator(t){this.m_bCirculator=t}getImpl(){return this}}class ws{constructor(t){this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null,this.m_refCount=1,t&&t.copyTo(this)}getRasterizedGeometry(){return this.m_rasterizedGeometry}copyTo(t){t!==this&&(s(t.uniqueUse()),t.m_quadTree=this.m_quadTree,t.m_quadTreeForPaths=this.m_quadTreeForPaths,t.m_rasterizedGeometry=this.m_rasterizedGeometry)}clone(){const t=new ws;return this.copyTo(t),t}uniqueUse(){return 1===this.m_refCount}addRef(){++this.m_refCount}release(){0==--this.m_refCount&&(this.m_rasterizedGeometry=null,this.m_quadTree=null,this.m_quadTreeForPaths=null)}setRasterizedGeometry(t){s(this.uniqueUse())}setQuadTree(t){s(this.uniqueUse()),this.m_quadTree=t}setQuadTreeForPaths(t){s(this.uniqueUse()),this.m_quadTreeForPaths=t}getQuadTree(){return this.m_quadTree}getQuadTreeForPaths(){return this.m_quadTreeForPaths}}function As(t){return!(t.isEmpty()||t.getGeometryType()!==i.enumPolyline&&t.getGeometryType()!==i.enumPolygon)&&!(t.getPointCount()<20)}function Ts(t){return!(t.isEmpty()||t.getGeometryType()!==i.enumPolyline&&t.getGeometryType()!==i.enumPolygon)&&!(t.getPointCount()<20)}function Is(t,e){return t.readPoint2D(e+4)}function Ms(t){const e=t.getGeometryType();return e===i.enumEllipticArc?10:e===i.enumBezier?4:e===i.enumRationalBezier2?5:e===i.enumBezier2?2:void h("")}function Ys(t){const e=31&t;return 4===e?10:2===e?4:8===e?5:16===e?2:0}function Xs(t,e,n,i){const r=4*ut()*(Math.abs(e.vmin)+Math.abs(e.vmax)),o=ut();if(1===t.getMaxDerivative()){s(n>0);const o=zs(t,0,e,ut(),r);return i[0]=o.root,o.cRoots}let a,h=[];const m=new U(e.vmin-r,e.vmax+r);h.push(new J(m.vmin,m.vmax));let u=0;for(let s=t.getMaxDerivative()-1;s>=0;s--){a=h,h=[];for(let m=0,l=a.length;m<l;m++){if(a[m][0]<a[m][1]){let l,c,g;if(s===t.getMaxDerivative()-1?({root:l,funcAtRoot:c,cRoots:g}=zs(t,s,U.construct(a[m][0],a[m][1]),o,.5*r)):({root:l,funcAtRoot:c,cRoots:g}=ks(t,s,U.construct(a[m][0],a[m][1]),o,.5*r)),1===g){if(0===s){if(u<n){if(a[m][0]<=e.vmin&&a[m][1]>=e.vmin&&l!==e.vmin){0===t.getValue(0,e.vmin)&&(l=e.vmin)}if(a[m][0]<=e.vmax&&a[m][1]>=e.vmax&&l!==e.vmax){0===t.getValue(0,e.vmax)&&(l=e.vmax)}i[u]=e.snapClip(l),u>0?i[u]-i[u-1]>r&&u++:u++}}else{const t=J.getNAN();t[0]=a[m][0],t[1]=l,h.push(t);const e=J.getNAN();e[0]=l,e[1]=a[m][1],h.push(e)}continue}}h.push(a[m])}}return u}function Ns(t,e,s,n){const i=new st,r=Ws(new st(t),new st(e),s,i);return n[0]=i.value(),r}function qs(t,e,s,n,i,r){const o=_t(st,2),a=js(new st(t),new st(e),new st(s),n,i,o);return r[0]=o[0].value(),r[1]=o[1].value(),a}function Fs(t,e,s,n,i,r,o){const a=_t(st,3),h=Zs(new st(t),new st(e),new st(s),new st(n),i,r,a);return o[0]=a[0].value(),o[1]=a[1].value(),o[2]=a[2].value(),h}function Vs(t,e,s,n,i,r,o,a){return Rs(t,e,s,n,i,r,o,a)}function Ls(t,e,s,n,i,r){return Gs(t,e,s,n,i,r)}function Rs(t,e,s,n,i,r,o,a){const h=O(s*s,Number.NaN);h.fill(0),K(a,n,0,0,s);const m=O(s,Number.NaN),u=O(s,Number.NaN),l=O(s,Number.NaN);let c=t(a,s,e);const g=100;let d=0;for(d=0;d<g;d++){const n=c;for(let t=0;t<s;++t)u[t]=a[t];if(d%s==0){h.fill(0);for(let t=0;t<s;t++)h[t*s+t]=1}let o=0,g=0;for(let u=0;u<s;++u){for(let t=0;t<s;++t)m[t]=h[u*s+t];const n=c;c=Bs(t,e,a,m,i,r,s);const l=n-c;l>o&&(g=u,o=l)}for(let t=0;t<s;t++)m[t]=a[t]-u[t],l[t]=a[t]+(a[t]-u[t]);const _=t(l,s,e);if(_<n){if(2*(n-2*c+_)*Tt(n-c-o)<Tt(n-_)*o){c=Bs(t,e,a,m,i,r,s);for(let t=0;t<s;++t)h[g*s+t]=h[(s-1)*s+t],h[(s-1)*s+t]=m[t]}}if(n<=c)return t(a,s,e)}return c}function zs(t,e,s,n,i){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=s.vmax,m=0,u=Number.MAX_VALUE,l=t.getValue(e,o),c=t.getValue(e,a),g=0,d=0,_=0;if(l>=0&&c>=0||l<=0&&c<=0)return Math.abs(l)<Math.abs(c)?(r.funcAtRoot=l,r.root=o,r.cRoots=0===l?1:0,r):(r.funcAtRoot=c,r.root=a,r.cRoots=0===c?1:0,r);Math.abs(l)<Math.abs(c)&&(a=tt(o,o=a),c=tt(l,l=c)),m=o,g=l;let p=!0,f=0;for(;0!==c&&Math.abs(o-a)>n*Math.abs(a)+i;f++){let s=f>64;if(!s){d=l!==g&&c!==g?o*c*g/((l-c)*(l-g))+a*l*g/((c-l)*(c-g))+m*l*c/((g-l)*(g-c)):a-c*(a-o)/(c-l);const t=(3*o+a)/4;if(s=!(d>t&&d<a||d>a&&d<t),!s){const t=n*Math.abs(a)+i;if(p){const e=Math.abs(a-m);s=Math.abs(d-a)>=.5*e||e<t}else{const e=Math.abs(m-u);s=Math.abs(d-a)>=.5*e||e<t}}}if(s?(d=(o+a)/2,p=!0):p=!1,_=t.getValue(e,d),0===_)return r.root=d,r.funcAtRoot=_,r.cRoots=1,r;if(!s){const s=o-d,n=d-a;if(Math.abs(s)>10*Math.abs(n)){let s=a+3*n;for(let n=0;n<2;n++){const n=t.getValue(e,s);Bt(l)*Bt(n)>0?(o=s,l=n):s=ot(o,a,.75)}}else if(Math.abs(n)>10*Math.abs(s)){let n=o-3*s;for(let s=0;s<2;++s){const s=t.getValue(e,n);Bt(c)*Bt(s)>0?(a=n,c=s):n=ot(o,a,.25)}}}u=m,m=a,g=c,Bt(l)*Bt(_)<0?(a=d,c=_):(o=d,l=_),Math.abs(l)<Math.abs(c)&&(a=tt(o,o=a),c=tt(l,l=c)),128===f&&h("Root_finder iterations exceeded")}return r.root=a,r.funcAtRoot=c,r.cRoots=1,r}function ks(t,e,s,n,i){const r={root:0,funcAtRoot:0,cRoots:0};let o=s.vmin,a=t.getValue(e,o),m=s.vmax,u=t.getValue(e,m);if(a>=0&&u>=0||a<=0&&u<=0)return Math.abs(a)<Math.abs(u)?(r.funcAtRoot=a,r.root=o,r.cRoots=0===a?1:0,r):(r.funcAtRoot=u,r.root=m,r.cRoots=0===u?1:0,r);u<0&&(u=tt(a,a=u),m=tt(o,o=m));let l=.5*(o+m),c=Math.abs(m-o),g=c,d=t.getValue(e,l),_=t.getValue(e+1,l);const p=1,f=4;let P=f;const y=2;let x=1,C=0,v=0,b=p;const E=32;let S=0;for(;++S<100;){let s;S>E||0===_||b===y&&C>1||b===p&&P<f?(b=p,x>1&&x--):(b=y,v>1&&Math.abs(2*d)>Math.abs(c*_)&&x++),c=g;let n=!1;if(b===p)do{if(v>2){const t=16*Math.abs(c);if(.5*Math.abs(o-m)>t){const e=Math.min(o,m),n=Math.max(o,m);if(l===e){s=l,l=e+t,g=l-s;break}if(l===n){s=l,l=n-t,g=l-s;break}}}g=.5*(m-o),s=l,l=o+g,n=o===l||m===l}while(0);else for(;;){g=x*d/_,s=l,l-=g,n=l===s;const t=Math.min(o,m),e=Math.max(o,m);if(l<t){if(x>1){l=s,x--;continue}g=s-t,l=t}else if(l>e){if(x>1){l=s,x--;continue}g=s-e,l=e}break}if(n||Math.abs(g)<i){s!==l&&(d=t.getValue(e,l));break}d=t.getValue(e,l),_=t.getValue(e+1,l);const r=o,h=m;d<0?(a=d,o=l):(u=d,m=l),b===y&&(o===r&&m===h||v>1&&Math.abs(g)>=.5001*Math.abs(c))?C++:C=0,b===p?(P++,v=0):(P=0,v++)}return 100===S&&h("Root_finder iterations exceeded"),r.root=l,r.funcAtRoot=d,r.cRoots=1,r}function Bs(t,e,s,n,i,r,o){const a=n.slice(0,o);let h=0;for(let f=0;f<o;f++)h+=n[f]*n[f];if(h=Math.sqrt(h),h>0)for(let f=0;f<o;f++)a[f]/=h;let m=Number.NEGATIVE_INFINITY,u=Number.POSITIVE_INFINITY;{const t=O(o,0);for(let e=0;e<o;e++)t[e]=e;t.sort(((t,e)=>{const s=Math.abs(a[t]),n=Math.abs(a[e]);return s<n?-1:s>n?1:0}));for(let e=0;e<o;e++){const n=t[e];if(0===a[n])continue;let o=(i[n]-s[n])/a[n],h=(r[n]-s[n])/a[n];h<o&&(h=tt(o,o=h)),o>m&&(m=o),h<u&&(u=h)}}let l=0;const c=(Math.abs(m)+Math.abs(u))*ut()*100,g=O(o,Number.NaN),d=a.slice();function _(n,i){for(let t=0,e=o;t<e;t++)g[t]=s[t]+n*d[t];return t(g,o,e)}c>0&&(l=Ls(_,null,m,0,u,c));const p=_(l);for(let f=0,P=o;f<P;f++)s[f]=lt(g[f],i[f],r[f]);return p}function Gs(t,e,s,n,i,r){const o=re();let a=n,h=t(a,e),m=s,u=i,l=t(m,e),c=t(u,e);h>l&&(h=l,a=m),h>c&&(h=c,a=u);let g=m,d=u,_=l,p=c;_>p&&(_=tt(p,p=_),d=tt(g,g=d));let f=a-g,P=g-d;const y=.5*Math.min(r,u-m),x=2*y,C=100;let v,b=0;for(v=0;v<C&&!(u-m<=x);++v){const s=m+.5*(u-m);let n=b>0;if(!n&&Math.abs(P)<=y&&(n=!0,b=3),!n){const t=a-g,e=a-d,s=t*(h-p);let i=e*(h-_),r=e*i-t*s;i=2*(i-s),i>0&&(r=-r),i=Math.abs(i),0===i||Math.abs(r)>=Math.abs(i*P/2)||r<=i*(m-a)||r>=i*(u-a)?(n=!0,b=3):(P=f,f=r/i)}n&&(P=a>=s?m-a:u-a,f=o*P,b--);let i=a+f;i<m+y?i=m+y:i>u-y&&(i=u-y);const r=t(i,e);r<h?(i>=a?(m=a,l=h):(u=a,c=h),d=g,g=a,a=i,p=_,_=h,h=r):(i<a?(m=i,l=r):(u=i,c=r),r<=_||g===a?(d=g,g=i,p=_,_=r):(r<=p||d===a||d===g)&&(d=i,p=r))}return a}function Ws(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setE(e.clone().negateThis().divThisE(t)),s.containsCoordinate(n.value())?1:0)}function js(t,e,s,n,i,r){if(0===t.value()){if(i)return r[0].set(1),n.containsCoordinate(r[0].value())?1:0;return Ws(e,s,n,r[0])}if(i){let e=2;return r[0].set(1),r[1].setE(s).divThisE(t),r[1].eq(r[0])&&(r[1].set(1),e=1),n.containsCoordinate(r[1].value())||(e=1),n.containsCoordinate(r[0].value())||(e--,r[0].setE(r[1])),2===e&&r[0].value()>r[1].value()&&(r[1]=tt(r[0],r[0]=r[1])),e}const o=e.clone().sqrThis().subThisE(t.clone().mulThisE(s).mulThisE(jt));if(o.lt(it))return 0;const a=new st(e.value()>=0?1:-1),h=o.clone().sqrtThis(),m=new st(-.5).mulThisE(e.clone().addThisE(a.clone().mulThisE(h)));let u=0;r[0].setE(m.divE(t));const l=new st(r[0].value()),c=new st(t.value()).mulE(l).addE(new st(e.value()).mulE(l).addE(new st(s.value())));return c.isZero()||$s(r[0],t,e,s,r[0]),n.containsCoordinate(r[0].value())&&u++,0!==h.value()&&0!==m.value()?(r[u].assign(s.divE(m)),l.set(r[u].value()),c.assign(new st(t.value()).mulE(l).addE(new st(e.value()).mulE(l).addE(new st(s.value())))),c.isZero()||$s(r[u],t,e,s,r[u]),n.containsCoordinate(r[u].value())&&u++,2===u&&r[0].value()>r[1].value()&&(r[1]=tt(r[0],r[0]=r[1])),u):u}function Zs(t,e,s,n,i,r,o){if(0===t.value()){return js(e,s,n,i,r,o)}if(r){let s=1;o[0].set(1);const r=o.slice(s),a=js(t,e.addE(t),n.negate(),i,!1,r);if(a>0){s+=a;for(let t=1;t<s;t++)o[t].eq(nt)&&(o[s-1]=tt(o[t],o[t]=o[s-1]),s--)}const h=o.slice(0,s);h.sort(((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));for(let t=0;t<s;++t)o[t]=h[t];return s}return tn(t,e,s,n,i,o)}function Hs(t,s,n,i,r,o){return(o<s||s<0)&&e("nth_degree_real_roots"),en(t,s,n,i,r)}function Us(t,e,s,n){return{coef0:t.clone(),coef1:e.clone(),coef2:s.clone(),coef3:n.clone(),calcF(t){return this.coef0.clone().mulThis(t).addThisE(this.coef1).mulThis(t).addThisE(this.coef2).mulThis(t).addThisE(this.coef3)},calcDF(t){return this.coef0.clone().mulThis(3).mulThis(t).addThisE(this.coef1.clone().mulThisByPower2(2)).mulThis(t).addThisE(this.coef2)},estimateError(t){const e=Math.abs(t),s=((this.coef0.eps()*e+this.coef1.eps())*e+this.coef2.eps())*e+this.coef3.eps()+this.calcF(t).eps(),n=this.coef0.clone().mulThis(t).mulThis(3).addThisE(this.coef1.clone().mulThis(2)).mulThis(t).addThisE(this.coef2);if(n.isZero()){const e=this.coef0.clone().mulThis(t).mulThis(6).addThisE(this.coef1.clone().mulThis(2));if(e.isZero()){const t=this.coef0.clone().mulThis(6);return Math.pow(6*s/Math.abs(t.value()),1/3)}return Math.sqrt(2*s/Math.abs(e.value()))}return s/Math.abs(n.value())}}}class Os{updateCoefs(t){if(this.lastDeriv1===t)return this.curCoefs=this.derivCoefs1,void(this.lastUsed=1);if(this.lastDeriv2===t)return this.curCoefs=this.derivCoefs2,void(this.lastUsed=2);let e;1===this.lastUsed?(e=this.derivCoefs2,this.lastDeriv2=t,this.lastUsed=2):(e=this.derivCoefs1,this.lastDeriv1=t,this.lastUsed=1),e.length=0;for(let s=0,n=this.truePower-t;s<=n;++s){e.push(this.coefs[s+t].clone());let n=s+t,i=n--;for(let e=1;e<t;e++)i*=n--;e[s].mulThis(i)}this.curCoefs=e}constructor(t,e,s,n){this.derivCoefs1=[],this.derivCoefs2=[],this.lastDeriv1=-1,this.lastDeriv2=-1,this.lastUsed=-1,this.curCoefs=null,this.coefs=t,this.power=e,this.truePower=0;for(let i=e;i>=1;i--)if(0!==this.coefs[i].value()){this.truePower=i;break}}getMaxDerivative(){return this.truePower+1}getValue(t,e){let s=this.coefs;0===t?s=this.coefs:(this.updateCoefs(t),s=this.curCoefs);const n=new ct(0);let i=1;for(let r=0,o=this.truePower-t;r<=o;++r)n.pe(i*s[r].value()),i*=e;return n.getResult()}getError(t){const e=Math.abs(t),s=new ct(0),n=new st(1),i=new st(0);for(let o=0,a=this.power;o<=a;++o)i.addThisE(this.coefs[o].mulE(n)),s.pe(n.value()*this.coefs[o].eps()),n.mulThis(e);s.pe(i.eps());let r=1;for(let o=1;o<=this.truePower;++o){r*=o,this.updateCoefs(o);const e=new st(1),n=new st(0);for(let s=0,i=this.truePower-o;s<=i;++s)n.addThisE(this.curCoefs[s].mulE(e)),e.mulThis(t);if(!n.isZero())return Math.pow(r*s.getResult()/Math.abs(n.value()),1/o)}return 0}}function Qs(t,e,s,n,i,r){let o=t,a=e,h=a-o;if(!r){let s=n.calcF(t).value(),i=n.calcF(e).value();if((s>0||s>i)&&(a=tt(o,o=a),i=tt(s,s=i)),s>=0||i<=0)return!1}let m,u=!1,l=s,c=0;for(;c<100;c++){const t=n.calcF(l);if(m=n.calcDF(l),m.isZero())return!1;if(!t.value()||c>3&&t.isZero()){u=!0;break}r||(t.value()<0?o=l:a=l);const e=t.value()/m.value(),s=l-e;r||(s>=o&&s<=a||s>=a&&s<=o)&&Math.abs(e)<=.5*h?(l=s,h=Math.abs(e)):(h=Math.abs(.5*(a-o)),l=.5*(o+a))}return!!u&&(i.set(l,n.estimateError(l)),!0)}function Js(t,e,s,n,i,r,o,a){return Qs(t,e,s.value(),Us(n,i,r,o),a,!1)}class Ks{constructor(t,e,s){this.coefs=_t(st,3),this.coefs[0].setE(t),this.coefs[1].setE(e),this.coefs[2].setE(s)}calcF(t){const e=new st(t);return this.coefs[0].mulE(e).addE(this.coefs[1]).mulE(e).addE(this.coefs[2])}calcDF(t){const e=new st(t);return st.st_mulByPower2(this.coefs[0],2).mulE(e).addE(this.coefs[1])}estimateError(t){const e=Math.abs(t),s=(this.coefs[0].eps()*e+this.coefs[1].eps())*e+this.coefs[2].eps()+this.calcF(t).eps(),n=new st(2).mulE(this.coefs[0]).mul(t).addE(this.coefs[1]);if(n.isZero()){const t=this.coefs[0].value();return Math.sqrt(s/Math.abs(t))}return s/Math.abs(n.value())}}function $s(t,e,s,n,i){return Qs(0,0,t.value(),new Ks(e,s,n),i,!0)}function tn(t,e,s,n,i,r){const o=_t(st,3);let a=0;const m=e.negate().divThisE(t.clone().mulThis(3));i.containsCoordinate(m.value())&&(o[0].setE(m),a=1);const u=_t(st,2),l=js(t.mul(3),e.mul(2),s,i,!1,u);if(l<0)return n.isZero()?-1:0;for(let h=0;h<l;h++)i.containsCoordinate(u[h].value())&&o[a++].setE(u[h]);$(o,0,a,((t,e)=>t.value()<e.value()?-1:t.value()>e.value()?1:0));const c=_t(st,5);c[0].set(i.vmin);for(let h=0;h<a;h++)c[1+h].setE(o[h]);c[1+a].set(i.vmax);const g=a+2;let d=1,_=0;{const i=c[0].clone();if(t.clone().mulThisE(i).addThisE(e).mulThisE(i).addThisE(s).mulThisE(i).addThisE(n).isZero()){const o=Us(t,e,s,n);i.setError(o.estimateError(i.value())),r[_]=i,_++,d++}}for(let p=d;p<g;p++){const o=c[p].clone(),a=t.clone().mulThisE(o).addThisE(e).mulThisE(o).addThisE(s).mulThisE(o).addThisE(n).isZero();if(a||!c[p].eq(c[p-1])){if(a||Js(c[p-1].value(),c[p].value(),c[p-1].clone().addThisE(c[p]).divThisByPower2(2),t,e,s,n,o)){if(_>0&&o.eq(r[_-1]))continue;if(_>=3&&h("cubic_polynomial_solver_too_many_roots"),a){const i=Us(t,e,s,n);o.setError(i.estimateError(o.value()))}r[_]=o,_++}if(c[p].value()===i.vmax)break;a&&p++}}return _}function en(t,e,s,n,i,r){const o=new Os(t,e,s,ut());let a=0;if(2===o.truePower)a=js(t[2],t[1],t[0],s,n,i);else if(1===o.truePower)a=Ws(t[1],t[0],s,i[0]);else{if(0===o.truePower)return t[0].value()?0:-1;{const t=[];t.length=e,a=Xs(o,s,e,t);for(let e=0;e<a;e++)i[e].set(t[e])}}for(let h=0;h<a;h++)i[h].setError(o.getError(i[h].value()));return a}var sn=I;class nn extends ns{constructor(t){void 0===t||dt(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new J(0,0)):t.from?(super({XStart:t.from.x,YStart:t.from.y,XEnd:t.to.x,YEnd:t.to.y,...t.vd}),this.m_cp=t.cp.clone()):t.points?(super({XStart:t.points[0].x,YStart:t.points[0].y,XEnd:t.points[2].x,YEnd:t.points[2].y,...t.vd}),this.m_cp=t.points[1].clone()):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone()):h("unexpected constructor args")}getBoundary(){return Va(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}construct(t,e,s){this.setStartXY(t),this.m_cp.assign(e),this.setEndXY(s),ur(this)}constructPoints(t){this.setStartXY(t[0]),this.m_cp.assign(t[1]),this.setEndXY(t[2]),ur(this)}getGeometryType(){return i.enumBezier2}queryEnvelope(t){if(2!==t.m_EnvelopeType)a("env type not impl");else{if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=Sr(this);if(null!==e){const s=new J;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[];gr(this,e);const s=new J;for(const n of e)this.queryCoord2D(n,s),t.mergeNe(s)}}}applyTransformation(t){if(1===t.m_TransformationType){const e=_t(J,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}s(0)}createInstance(){return new nn({vd:this.m_description})}calculateLength2D(){return dr(this,1,!1)}calculateLowerLength2D(){return J.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){return J.distance(this.getStartXY(),this.m_cp)+J.distance(this.getEndXY(),this.m_cp)}queryCoord2D(t,e){this.queryCoord2DExtended(t,e,!1)}queryCoord2DExtended(t,e,s){const n=_t(J,3);this.queryControlPoints(n),Jr(n,t,e,s)}queryCoord2DE(t,e){Kr(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new J;return this.queryCoord2DExtended(t,e,!0),e.x}if(t<=.5){const e=pt(this.getStartX(),this.m_cp.x,t),s=pt(this.m_cp.x,this.getEndX(),t);return pt(e,s,t)}{const e=ft(this.getStartX(),this.m_cp.x,t),s=ft(this.m_cp.x,this.getEndX(),t);return ft(e,s,t)}}getCoordY(t){if(t<0||t>1){const e=new J;return this.queryCoord2DExtended(t,e,!0),e.y}if(t<=.5){const e=pt(this.getStartX(),this.m_cp.x,t),s=pt(this.m_cp.x,this.getEndX(),t);return pt(e,s,t)}{const e=ft(this.getStartY(),this.m_cp.y,t),s=ft(this.m_cp.y,this.getEndY(),t);return ft(e,s,t)}}cut(t,e,s){const n=new nu;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=sn.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=sn.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){to(this,t,e)}cutBezierIgnoreAttributes(t,s,n){if((t<0||s>1||t>s)&&e("Quadratic_bezier.cut_bezier_ignore_attributes"),0===t&&1===s)return n.setStartXY(this.getStartXY()),n.m_cp.assign(this.m_cp),void n.setEndXY(this.getEndXY());const i=_t(J,3);this.queryControlPoints(i),Vr(i,t,s,i),n.constructPoints(i)}splitBezierIgnoreAttributes(t,e,n){s(0)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=sn.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Pt(r,o,a,i,sn.getDefaultValue(e))}getClosestCoordinate(t,e){return wr(this,t,U.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return wr(this,t,e,!1)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,n){t.length<2&&e("");const i=cr(this);let r=0;if(2===i.specialPointsCount())return 0;s(t.length>=i.specialPointsCount()-1);for(let e=1,s=i.specialPointsCount();e<s;++e)this.queryCut(i.specialPoints[e-1],i.specialPoints[e],t[r],n),r++;for(let e=0;e<r;++e){Xr(t[e].get())}return r}intersectionWithAxis2D(t,e,s,n){const i=_t(st,3),r=_t(st,2),o=new U(0,1);let a=0;if(t){if(i[0]=new st(this.getStartY()).sub(e),i[1]=new st(this.m_cp.y).subE(new st(this.getStartY())).mulThisByPower2(2),i[2]=new st(this.getStartY()).add(this.getEndY()).subE(new st(this.m_cp.y).mulThisByPower2(2)),a=js(i[2],i[1],i[0],o,!1,r),s)for(let h=0;h<a;h++)s[h]=this.getCoordX(r[h].value())}else if(i[0]=new st(this.getStartX()).sub(e),i[1]=new st(this.m_cp.x).subE(new st(this.getStartX())).mulThisByPower2(2),i[2]=new st(this.getStartX()).add(this.getEndX()).subE(new st(this.m_cp.x).mulThisByPower2(2)),a=js(i[2],i[1],i[0],o,!1,r),s)for(let h=0;h<a;h++)s[h]=this.getCoordY(r[h].value());if(n)for(let h=0;h<a;h++)n[h]=r[h].value();else s&&yt(s,a);return a}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[0,0],i=this.intersectionWithAxis2D(!0,t,n,null);return s(2!==i),-1===i?e:n[0]}isCurve(){return!0}isLine(){return!1}isDegenerate(t){return Te(this,t)}isDegenerate3D(t,e){return s(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords(this.getStartXY()),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY());s(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=new oe;this.queryEnvelope(t);const s=new U;return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=_t(J,4);this.queryControlPoints(s),Vr(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return dr(this,t,!0)}lengthToT(t){return Cr(this,t)}calculateWeightedAreaCentroid2D(t){const e=_t(J,3);Hr(this,e);const s=e[2],n=e[1],i=new J,r=s.y*n.x-s.x*n.y;i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60;const o=vr(this);return i.x+=(e[0].x-t.x)*o,i.y+=(e[0].y-t.y)*o,i}calculateWeightedCentroid2D(){const t=new J;return this.isDegenerate(0)?(t.setCoords(0,0),t):Er(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(qr(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPoints(t){for(let s=0;s<3;s++)t[s].isNAN()&&e("NaN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp.setCoordsPoint2D(t[1]),this.m_XEnd=t[2].x,this.m_YEnd=t[2].y,this.afterCompletedModification()}getTangent(t){const e=lt(t,0,1);let s=Pr(this,1,e);return s.isZero()&&(s=Pr(this,2,e),1===e&&s.negateThis()),s}getDerivative(t){return Pr(this,1,lt(t,0,1))}getCurvature(t){const e=Pr(this,1,t),s=Pr(this,2,t),n=e.sqrLength();if(0===n)return Number.NaN;e.divThis(Math.sqrt(n));return e.crossProduct(s)/n}isIntersecting(t,e,s){return 0!==jm(!1,this,t,e,s)}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;const n=new oe;if(this.queryLooseEnvelope(n),n.inflateCoords(e,e),!n.contains(t))return!1;const i=this.getClosestCoordinate(t,!1),r=new J;this.queryCoord2D(i,r);return J.distance(r,t)<=e}isIntersectingPoint3D(t,e,n,i,r=1){return s(0),!1}isMonotoneQuickAndDirty(){return!1}getMonotonicPartParams(t,s){const n=cr(this),i=n.specialPointsCount();if(!s)return n.specialPointsCount();t<i&&e("");for(let e=0;e<i;e++)s[e]=n.specialPoints[e];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){tt(this.m_XStart,this.m_XStart=this.m_XEnd),tt(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=tt(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isDegenerateToLineHelper(t){const e=[t];if(!Ie(this,e))return!1;const s=this.getEndXY().sub(this.getStartXY()),n=s.length(),i=this.getControlPoint1();i.sub(this.getStartXY());return!(Math.abs(i.crossProduct(s))/n>e[0])}copyIgnoreAttributes(t){const e=_t(J,3);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return vr(this)}absNorm(){return Rr(this)}queryEnvelopeW(t,e){const s=_t(J,3);this.queryControlPoints(s),Mr(s,t,e)}setSegmentFromCoords(t,e){this.construct(t[0],this.getControlPoint1(),t[e-1])}snapControlPoints(t){return ro(this,t)}writeInBufferStream(t,e){const s=new Float64Array(2);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(2);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_cachedValues=null}needsSnapControlPoints(t){return oo(this,t)}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Xr(this)}setCoordsForIntersector(t,e,s){Lr(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),Dr(e,Sr(this))}reverseImpl(){}equalsImplTol(t,e){const s=t;return!!this.m_cp.isEqualPoint2D(s.m_cp,e)}equalsImpl(t){const e=t;return!!this.m_cp.equals(e.m_cp)}swapImpl(t){const e=t;e.m_cp=tt(this.m_cp,this.m_cp=e.m_cp),lr(this,e)}afterCompletedModification(){ur(this)}intersect(t,e,s,n,i){return Om(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return Tr(this,t,e.length,e,s)}endPointModified(){ur(this)}clearEndPointModified(){}}nn.type=i.enumBezier2;var rn=I;class on extends ns{constructor(t){return void 0===t||dt(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=new J(0,0),void(this.m_weights=[1,0,1])):(t.fromPoint&&t.weight?t={fromPoint:t.fromPoint,controlPoint1:t.controlPoint1,toPoint:t.toPoint,weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weight?t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:1,weight1:t.weight,weight2:1}:t.points&&t.weights&&(t={fromPoint:t.points[0],controlPoint1:t.points[1],toPoint:t.points[2],weight0:t.weights[0],weight1:t.weights[1],weight2:t.weights[2]}),t.fromPoint&&t.weight0?(super({start:t.fromPoint,end:t.toPoint}),(t.weight0<=0||t.weight1<0||t.weight2<=0)&&e("weights"),this.m_cp=t.controlPoint1.clone(),void(this.m_weights=[t.weight0,t.weight1,t.weight2])):t.copy?(super(t),this.m_cp=t.copy.m_cp.clone(),void(this.m_weights=t.copy.m_weights.slice())):t.move?(super(t),this.m_cp=t.move.m_cp.clone(),void(this.m_weights=t.move.m_weights.slice())):void a("unexpected constructor param"))}getBoundary(){return Va(this)}assignMove(t){return this}assignCopy(t){return t.copyTo(this),this}construct(t,e,s,n){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,1,n,1),Un(this)}constructWeights(t,e,s,n,i,r){this.dropAllAttributes(),this.setCpsAndWeights(t,e,s,n,i,r),Un(this)}constructArray(t,e){this.construct(t[0],t[1],t[2],e)}constructArrayWeights(t,e){this.dropAllAttributes(),this.setCpsAndWeightsArray(t,e),Un(this)}convertToStandardForm(){}getStandardFormWeight(){return this.m_weights[1]/Math.sqrt(this.m_weights[0]*this.m_weights[2])}getGeometryType(){return i.enumRationalBezier2}queryEnvelope(t){if(t instanceof oe){if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp))return;const e=xi(this);if(null!==e){const s=new J;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s)}else{const e=[],s=_t(J,3);this.queryControlPoints(s),Jn(s,this.m_weights,e);const n=new J;for(const i of e)this.queryCoord2D(i,n),t.mergeNe(n)}}}applyTransformation(t){if(t instanceof ae){const e=_t(J,3);return this.queryControlPoints(e),t.transformPoints2D(e,3,e),this.setStartXY(e[0]),this.m_cp.assign(e[1]),this.setEndXY(e[2]),void this.afterCompletedModification()}}createInstance(){return new on({vd:this.m_description})}calculateLength2D(){return Kn(this,1,!1)}calculateLowerLength2D(){return J.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return this.calculateUpperLength2D_()}calculateUpperLength2D_(){if(this.m_weights[1]>0){return J.distance(this.getStartXY(),this.m_cp)+J.distance(this.getEndXY(),this.m_cp)}return J.distance(this.getStartXY(),this.getEndXY())}queryCoord2D(t,e){return this.queryCoord2DExtension(t,e,!0)}queryCoord2DE(t,e){Oi(this,t,e)}queryCoord2DExtension(t,e,s){if(s){if(t<0){return void rs(new su({start:this.getStartXY(),end:this.getStartXY().add(this.getTangent(0).getUnitVector())}),t,e)}if(t>1){return void rs(new su({start:this.getEndXY(),end:this.getEndXY().add(this.getTangent(1).getUnitVector())}),t-1,e)}}const n=_t(J,3);this.queryControlPoints(n),Ki(n,this.m_weights,t,e)}getCoordX(t){const e=new J;return this.queryCoord2DExtension(t,e,!0),e.x}getCoordY(t){const e=new J;return this.queryCoord2DExtension(t,e,!0),e.y}cut(t,e,s){const n=new nu;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createQuadraticRationalBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=rn.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=rn.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){hi(this,t,e)}cutBezierIgnoreAttributes(t,s,n){(t<0||s>1||t>s)&&e("Quadratic_rational_bezier.cut_bezier_ignore_attributes");const i=_t(J,3);this.queryControlPoints(i);const r=[0,0,0];Xi(i,this.m_weights,t,s,i,r),n.setControlPointsAndWeights(i,r)}splitBezierIgnoreAttributes(t,e,s){}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=rn.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Pt(r,o,a,i,rn.getDefaultValue(e))}getClosestCoordinate(t,e){return vi(this,t,U.unit(),e,-1)}getClosestCoordinateOnInterval(t,e,s=-1){return vi(this,t,e,!1,s)}getYMonotonicParts(t,e){return this.getMonotonicParts(t,e)}getMonotonicParts(t,n){t.length<2&&e("");const i=Qn(this);let r=0;if(2===i.specialPointsCount())return 0;s(t.length>=i.specialPointsCount()-1);for(let e=1,s=i.specialPointsCount();e<s;++e)this.queryCut(i.specialPoints[e-1],i.specialPoints[e],t[r],n),r++;for(let e=0;e<r;++e){Ti(t[e].get())}return r}intersectionWithAxis2D(t,e,s,n){s&&(s.length=9),n&&(n.length=9);const i=new Array(3),r=_t(st,2),o=new U(0,1);let a=0;const h=_t(J,3);if(this.queryControlPoints(h),t){if(i[0]=new st(h[0].y).sub(e).mul(this.m_weights[0]),i[1]=new st(h[1].y).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new st(h[2].y).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),a=js(i[2],i[1],i[0],o,!1,r),s)for(let m=0;m<a;m++)s[m]=this.getCoordX(r[m].value())}else if(i[0]=new st(h[0].x).sub(e).mul(this.m_weights[0]),i[1]=new st(h[1].x).sub(e).mul(this.m_weights[1]),i[2]=i[0].subE(i[1].mul(2)).addE(new st(h[2].x).sub(e).mul(this.m_weights[2])),i[1]=i[1].subE(i[0]).mulThisByPower2(2),a=js(i[2],i[1],i[0],o,!1,r),s)for(let m=0;m<a;m++)s[m]=this.getCoordY(r[m].value());if(n)for(let m=0;m<a;m++)n[m]=r[m].value();else s&&$(s,0,a,bt);return a}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[Number.NaN,Number.NaN],i=this.intersectionWithAxis2D(!0,t,n,null);return s(2!==i),-1===i?e:n[0]}isCurve(){return!0}isDegenerate(t){return Te(this,t)}isDegenerate3D(t,e){return!1}queryLooseEnvelope(t){if(t instanceof oe)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp),void t.mergeNe(this.getEndXY())}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=oe.constructEmpty();this.queryEnvelope(t);const s=U.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=_t(J,3);this.queryControlPoints(s);const n=[0,0,0];Xi(s,this.m_weights,t.vmin,t.vmax,s,n),e.setFromPoints(s,3)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp.isEqual(this.m_XStart,this.m_YStart),n=this.m_cp.isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp.setCoordsPoint2D(t):n&&this.m_cp.setCoordsPoint2D(e),this.normalizeAfterEndpointChange()}tToLength(t){return Kn(this,t,!0)}lengthToT(t){return ci(this,t)}calculateWeightedAreaCentroid2D(t){const e=pi(this),s=gi(this);return e.x+=(this.getStartX()-t.x)*s,e.y+=(this.getStartY()-t.y)*s,e}calculateWeightedCentroid2D(){const t=new J;return this.isDegenerate(0)?(t.setCoords(0,0),t):yi(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(Mi(this,1)),t)}getControlPoint1(){return this.m_cp.clone()}setControlPoint1(t){this.m_cp.setCoordsPoint2D(t),this.afterCompletedModification()}queryWeights(t){for(let e=0;e<3;++e)t[e]=this.m_weights[e]}setWeights(t){}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp),t[2].assign(this.getEndXY())}setControlPointsAndWeights(t,e){this.setCpsAndWeightsArray(t,e),this.afterCompletedModification()}getTangent(t){const e=_t(J,3);return this.queryControlPoints(e),ui(e,this.m_weights,t)}getDerivative(t){const e=lt(t,0,1),s=_t(J,4);return $n(this,1,e,s),s[1]}getCurvature(t){const e=_t(J,4);$n(this,2,t,e);const s=e[1].sqrLength();if(0===s)return Number.NaN;e[1].divThis(Math.sqrt(s));return e[1].crossProduct(e[2])/s}isIntersecting(t,e,s){return!1}isIntersectingPoint(t,e,s){return!1}isIntersectingPoint3D(t,e,s,n,i=1){return!1}isMonotoneQuickAndDirty(){const t=_t(J,3);return this.queryControlPoints(t),Ai(t)}getMonotonicPartParams(t,s){const n=Qn(this),i=n.specialPointsCount();if(!s)return n.specialPointsCount();t<i&&e("");for(let e=0;e<i;e++)s[e]=n.specialPoints[e];return i}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=tt(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=tt(this.m_YStart,this.m_YStart=this.m_YEnd),this.m_weights[2]=tt(this.m_weights[0],this.m_weights[0]=this.m_weights[2]);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=tt(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cachedValues=null}}isLine(){return!1}isDegenerateToLineHelper(t){const e=[t];return!!Ie(this,e)&&Li(this,e[0])}copyIgnoreAttributes(t){const e=_t(J,3);this.queryControlPoints(e);const s=[0,0,0];this.queryWeights(s),t.setControlPointsAndWeights(e,s)}calculateArea2DHelper(){return gi(this)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)+this.m_cp.norm(1)}absNormXYZ(t){return s(0),0}queryEnvelopeW(t,e){Di(this,t,e)}setSegmentFromCoords(t,e){const s=[0,0,0];this.queryWeights(s),this.constructWeights(t[0],this.getControlPoint1(),t[e-1],s[0],s[1],s[2])}writeInBufferStream(t,e){const s=new Float64Array(5);return s[0]=this.m_cp.x,s[1]=this.m_cp.y,s[2]=this.m_weights[0],s[3]=this.m_weights[1],s[4]=this.m_weights[2],t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(5);t.queryRange(e,s.length,s,!0,1),this.m_cp.x=s[0],this.m_cp.y=s[1],this.m_weights[0]=s[2],this.m_weights[1]=s[3],this.m_weights[2]=s[4],this.m_cachedValues=null}snapControlPoints(t){const e=_t(J,3);this.queryControlPoints(e);const s=J.sqrDistance(e[1],e[0]),n=J.sqrDistance(e[1],e[2]);let i=e[0].clone(),r=s;s>n&&(i=e[2].clone(),r=n);let o=!1;return r<=t&&0!==r&&(o=!0,this.setControlPoint1(i)),o}needsSnapControlPoints(t){if(!t)return!1;const e=_t(J,3);this.queryControlPoints(e);const s=J.sqrDistance(e[1],e[0]),n=J.sqrDistance(e[1],e[2]);e[0].clone();let i=s;return s>n&&(e[2].clone(),i=n),i<=t&&0!==i}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return Ti(this)}setCoordsForIntersector(t,e,s){qi(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp.setCoordsPoint2D(this.m_cp),e.m_weights[0]=this.m_weights[0],e.m_weights[1]=this.m_weights[1],e.m_weights[2]=this.m_weights[2],Ci(e,xi(this))}reverseImpl(){this.m_weights[2]=tt(this.m_weights[0],this.m_weights[0]=this.m_weights[2])}equalsImpl(t){const e=t;if(!this.m_cp.equals(e.m_cp))return!1;for(let s=0;s<3;s++)if(this.m_weights[s]!==e.m_weights[s])return!1;return!0}equalsImplTol(t,e){const s=t;if(!this.m_cp.isEqualPoint2D(s.m_cp,e))return!1;const n=_t(J,3);this.queryControlPoints(n);const i=_t(J,3);s.queryControlPoints(i);const r=[s.m_weights[0],s.m_weights[1],s.m_weights[2]];for(let o=0;o<3;o++){const t=new Y;t.setCoordsPoint2DZ(n[o].mul(this.m_weights[o]),this.m_weights[o]);const s=new Y;if(s.setCoordsPoint2DZ(i[o].mul(r[o]),r[o]),!t.isEqual(s,e))return!1}return!0}swapImpl(t){const e=t;e.m_cp=tt(this.m_cp,this.m_cp=e.m_cp),e.m_weights=tt(this.m_weights,this.m_weights=e.m_weights),On(this,e)}afterCompletedModification(){Un(this)}intersect(t,e,s,n,i){return Om(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return Si(this,t,e,s)}endPointModified(){Un(this)}clearEndPointModified(){}setCpsAndWeights(t,s,n,i,r,o){(i<=0||o<=0||r<0)&&e("weights"),(t.isNAN()||s.isNAN()||n.isNAN())&&e("NAN control points in bezier are not supported"),this.setStartXY(t),this.m_cp.assign(s),this.m_weights[0]=i,this.m_weights[1]=r,this.m_weights[2]=o,this.setEndXY(n)}setCpsAndWeightsArray(t,e){this.setCpsAndWeights(t[0],t[1],t[2],e[0],e[1],e[2])}}on.type=i.enumRationalBezier2;class an{static constructPoint2D(t){return new an(vt.constructDouble(t.x),vt.constructDouble(t.y))}constructor(t,e){if(void 0===t)return this.x=(new vt).setNAN(),void(this.y=(new vt).setNAN());this.x=t.clone(),this.y=e.clone()}assignPoint2D(t){return this.x.setDouble(t.x),this.y.setDouble(t.y),this}setCoords(t,e){return this.x.setThis(t),this.y.setThis(e),this}asPoint2D(){return new J(this.x.value(),this.y.value())}crossProduct(t){return this.x.mul(t.y).sub(this.y.mul(t.x))}leftPerpendicularThis(){const t=this.x.clone();this.x=this.y.clone().negate(),this.y=t}clone(){return new an(this.x,this.y)}dotProduct(t){return this.x.mul(t.x).add(this.y.mul(t.y))}add(t){return new an(this.x.add(t.x),this.y.add(t.y))}sub(t){return new an(this.x.sub(t.x),this.y.sub(t.y))}sqrLength(){return this.x.sqr().addThis(this.y.sqr())}mulThis(t){return this.x.mulThis(t),this.y.mulThis(t),this}mul(t){return this.clone().mulThis(t)}}class hn{constructor(t){return t.coefsT?(this.m_zeroCtor=t.zeroCtor,this.m_elements=t.coefsT.map((t=>t.clone())),s(this.m_elements.length===t.power+1),void this.updatePower()):t.coef0?(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[t.coef0.clone()])):t.copy?(this.m_zeroCtor=t.copy.m_zeroCtor,void(this.m_elements=t.copy.m_elements.map((t=>t.clone())))):(this.m_zeroCtor=t.zeroCtor,void(this.m_elements=[new this.m_zeroCtor]))}construct(t,e){return this.m_elements=t.map((t=>t.clone())),this.updatePower(),this}construct0(t){return this.m_elements.length=0,this.m_elements.push(t.clone()),this.updatePower(),this}assignCopy(t){return this.m_elements=t.m_elements.map((t=>t.clone())),this.updatePower(),this}assignMove(t){return this.m_elements=t.m_elements,t.m_elements=[],this.updatePower(),this}power(){return this.m_elements.length-1}addElement(t){this.m_elements.push(t.clone())}fmSubThis(t,e){return s(0),this}addThis(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].addThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n];return this.updatePower(),this}add0(t){return this.m_elements[0].addThis(t),this.updatePower(),this}addNumber0(t){return s(0),this}sub(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].subThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0(t){return s(0),this}subNumber0(t){return s(0),this}subShifted(t,e){const s=this.power(),n=t.power()+e,i=Math.min(this.power(),n);let r=0;for(let o=e;o<=i;++o)this.m_elements[o].subThis(t.m_elements[r]),r++;if(n<=s)return this.updatePower(),this;this.m_elements.length=n+1;for(let o=s+1;o<this.m_elements.length;++o)this.m_elements[o]=new this.m_zeroCtor;for(let o=i+1;o<=n;++o)this.m_elements[o].subThis(t.m_elements[r++]);return this.updatePower(),this}subShiftedWithCoef(t,e,s){const n=this.power(),i=t.power()+s,r=Math.min(this.power(),i);let o=0;for(let a=s;a<=r;++a)this.m_elements[a].fmSubThis(t.m_elements[o],e),o++;if(i<=n)return this.updatePower(),this;this.m_elements.length=i+1;for(let a=n+1;a<this.m_elements.length;++a)this.m_elements[a]=new this.m_zeroCtor;for(let a=r+1;a<=i;++a)this.m_elements[a].fmSubThis(t.m_elements[o++],e);return this.updatePower(),this}mulThis(t){if(this.constructor===t.constructor){const e=t,s=[];for(let t=0,n=this.power();t<=n;t++)for(let i=0,r=e.power();i<=r;i++){const n=this.m_elements[t].clone();n.mulThis(e.m_elements[i]),t+i<s.length?s[t+i].addThis(n):s.push(n)}this.m_elements=s}else for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulElementThis(t){for(let e=0,s=this.power();e<=s;e++)this.m_elements[e].mulThis(t);return this.updatePower(),this}mulNumber0(t){return s(0),this}mulBigint0(t){return s(0),this}mulBigIntThis(t){return s(0),this}mulInt320(t){return s(0),this}div0(t){return s(0),this}absThis(){return s(0),this}div(t,e,s){if(this.power()<t.power())return s.assignCopy(this),void e.setZero();s.setZero(),e.setZero();const n=t.getElement(t.power()),i=this.clone();let r=i.power();const o=i.power()-t.power();let a=o;for(e.m_elements=_t(e.m_zeroCtor,o+1);;){if(r<t.power()){s.assignMove(i);break}if(r===i.power()){const s=i.getElement(i.power());s.divThis(n),i.subShiftedWithCoef(t,s,i.power()-t.power()),e.m_elements[a]=s.clone()}a--,r--}s.updatePower(),e.updatePower()}divThis(t){return s(0),this}subThis(t){const e=Math.min(this.power(),t.power());for(let n=0;n<=e;++n)this.m_elements[n].subThis(t.m_elements[n]);const s=t.power();this.m_elements.length=Math.max(this.power(),t.power())+1;for(let n=e+1;n<=s;++n)this.m_elements[n]=t.m_elements[n].clone(),this.m_elements[n].negateThis();return this.updatePower(),this}sub0This(t){return this.m_elements[0].subThis(t),this.updatePower(),this}subFrom(t,e){s(0)}isZero(){return 0===this.power()&&this.m_elements[0].isZero()}negateThis(){for(let t=this.m_elements.length-1;t>=0;t--)this.m_elements[t].negateThis();return this}getElement(t){return this.m_elements[t].clone()}setElement(t,e){return this.m_elements[t]=e.clone(),this}evaluate(t){const e=this.power(),s=this.m_elements[e].clone();for(let n=e-1;n>=0;--n)s.mulThis(t),s.addThis(this.m_elements[n]);return s}equals(t){if(this===t)return!0;if(this.power()!==t.power())return!1;for(let e=this.m_elements.length-1;e>=0;e--)if(!this.m_elements[e].equals(t.m_elements[e]))return!1;return!0}updatePower(){for(let t=this.m_elements.length-1;t>0&&this.m_elements[t].isZero();t--)this.m_elements.pop();return this}setZero(){return this.m_elements.length=1,this.m_elements[0]=new this.m_zeroCtor,this.updatePower(),this}derivative(t){if(this.power()<t)return this.clone().setZero();if(0===t)return this.clone();const e=new this.constructor({coefsT:this.m_elements.slice(t),power:this.power()-t});for(let s=t,n=this.power();s<=n;s++){let n=BigInt(s);for(let e=s-1,i=s-t;e>i;--e)n*=BigInt(e);e.m_elements[s-t].mulBigIntThis(n)}return e.updatePower(),e}derivative1This(){if(this.m_elements.length>1){this.m_elements=this.m_elements.slice(1);for(let t=1,e=this.power();t<=e;t++)this.m_elements[t].mulThis(vt.constructInt32(t+1))}else this.m_elements.length=0,this.m_elements.push(new this.m_zeroCtor);return this}limitPrecisionThis(t){for(let e=this.power();e>=0;--e)this.m_elements[e].limitPrecisionThis(t);return this.updatePower(),this}hiBitIndex(){return this.m_elements.reduce(((t,e)=>{const s=e.hiBitIndex();return t<s?s:t}),0)}shiftRight(t){return this.m_elements.splice(0,t),this.updatePower(),this}static evaluateCoefs(t,e,s){const n=t.power();s.construct0(t.getElement(0).evaluate(e));for(let i=1;i<=n;++i)s.addElement(t.getElement(i).evaluate(e));s.updatePower()}}class mn extends hn{constructor(t){super(void 0===t?{zeroCtor:vt}:{...t,zeroCtor:vt})}clone(){return new mn({copy:this})}absEvaluate(t){const e=this.power(),s=this.m_elements[e].clone();s.absThis();const n=t.clone();n.absThis();for(let i=e-1;i>=0;--i)s.mulThis(n),s.addThis(this.m_elements[i].abs());return s}}class un extends hn{constructor(t){super(void 0===t?{zeroCtor:mn}:{...t,zeroCtor:mn})}clone(){return new un({copy:this})}constructFromMPValues(t,e){this.m_elements.length=0;for(let s=0;s<=e;++s)this.m_elements.push(new mn({coef0:t[s]}));return this.updatePower(),this}}function ln(){return{polypoly1:new un,polypoly2:new un,polyX2:new mn,polyY2:new mn,polyX2Deriv:new mn,polyY2Deriv:new mn,polypolyX1:new un,polypolyY1:new un,polypolyX1Deriv:new un,polypolyY1Deriv:new un,lazyPolypolyD1:new un,lazyPolypolyD1Deriv:new un,lazyPolyD2:new mn,lazyPolyD2Deriv:null,polypoly11:new un,polypoly12:new un,tempPp:new un,tempPp1:new un,tempPp2:new un,tempP:new mn,tempP1:new mn,tempP2:new mn}}function cn(t,e,n,i,r,o,a,m,u,l,c,g,d,_,p,f,P,y=!1){const x=ln();x.polyX2.construct(a,m),x.polyY2.construct(u,l),x.polypolyX1.constructFromMPValues(t,e),x.polypolyY1.constructFromMPValues(n,i),x.polypoly11.assignCopy(x.polypolyX1),x.polypoly12.assignCopy(x.polypolyY1),c&&(x.lazyPolyD2.construct(c,g),x.polypoly11.mulElementThis(x.lazyPolyD2),x.polypoly12.mulElementThis(x.lazyPolyD2)),r?(x.lazyPolypolyD1.constructFromMPValues(r,o),x.lazyPolypolyD1Deriv=new un({copy:x.lazyPolypolyD1}),x.lazyPolypolyD1Deriv.derivative1This(),x.tempPp.assignCopy(x.lazyPolypolyD1),x.tempPp.mulElementThis(x.polyX2),x.polypoly11.subThis(x.tempPp),x.tempPp.assignCopy(x.lazyPolypolyD1),x.tempPp.mulElementThis(x.polyY2),x.polypoly12.subThis(x.tempPp)):(x.polypoly11.sub0This(x.polyX2),x.polypoly12.sub0This(x.polyY2)),x.polypolyX1Deriv.assignCopy(x.polypolyX1),x.polypolyX1Deriv.derivative1This(),x.polypolyY1Deriv.assignCopy(x.polypolyY1),x.polypolyY1Deriv.derivative1This(),r&&(x.polypolyX1Deriv.mulThis(x.lazyPolypolyD1),x.tempPp2.assignCopy(x.lazyPolypolyD1Deriv),x.tempPp2.mulThis(x.polypolyX1),x.polypolyX1Deriv.subThis(x.tempPp2),x.polypolyY1Deriv.mulThis(x.lazyPolypolyD1),x.tempPp2.assignCopy(x.lazyPolypolyD1Deriv),x.tempPp2.mulThis(x.polypolyY1),x.polypolyY1Deriv.subThis(x.tempPp2)),x.polyX2Deriv.assignCopy(x.polyX2),x.polyX2Deriv.derivative1This(),x.polyY2Deriv.assignCopy(x.polyY2),x.polyY2Deriv.derivative1This(),c&&(s(null===x.lazyPolyD2Deriv),x.lazyPolyD2Deriv=new mn({copy:x.lazyPolyD2}),x.lazyPolyD2Deriv.derivative1This(),x.polyX2Deriv.mulThis(x.lazyPolyD2),x.tempP1.assignCopy(x.lazyPolyD2Deriv),x.tempP1.mulThis(x.polyX2),x.polyX2Deriv.subThis(x.tempP1),x.polyY2Deriv.mulThis(x.lazyPolyD2),x.tempP1.assignCopy(x.lazyPolyD2Deriv),x.tempP1.mulThis(x.polyY2),x.polyY2Deriv.subThis(x.tempP1)),x.polypoly1.assignCopy(x.polypoly11),x.polypoly1.mulElementThis(x.polyX2Deriv),x.tempPp.assignCopy(x.polypoly12),x.tempPp.mulElementThis(x.polyY2Deriv),x.polypoly1.addThis(x.tempPp),x.polypoly2.assignCopy(x.polypolyX1Deriv),x.polypoly2.mulElementThis(x.polyY2Deriv),x.tempPp.assignCopy(x.polypolyY1Deriv),x.tempPp.mulElementThis(x.polyX2Deriv),x.polypoly2.subThis(x.tempPp);let C=[];const v=[];P||(P=[]),f||(f=[]),vn(x.polypoly11,x.polypoly12,x.tempP);let b=57,E=.25*Number.EPSILON;const S=[];let D=bn(x.tempP,d,p,E,b,S);if(D<0)return-1;for(let s=0;s<D;s++){mn.evaluateCoefs(x.polypoly11,vt.constructDouble(S[s]),x.tempP1);const t=[];let e=bn(x.tempP1,d,_,E,b,t);if(0!==e)if(mn.evaluateCoefs(x.polypoly12,vt.constructDouble(S[s]),x.tempP2),e<0){e=bn(x.tempP2,d,_,E,b,t),e<0&&h("mp_curve_proximity");for(let n=0;n<e;n++)v.push(Ut(t[n],S[s]))}else{const n=x.tempP2.absEvaluate(Ht);n.mulThis(vt.constructDouble(1e-12));for(let i=0;i<e;i++){const e=x.tempP2.evaluate(vt.constructDouble(t[i]));e.absThis(),e.lt(n)&&v.push(Ut(t[i],S[s]))}}}D=v.length,vn(x.polypoly1,x.polypoly2,x.tempP),b=57,E=.25*Number.EPSILON;const w=[];let A=bn(x.tempP,d,p,E,b,w);A<0&&(A=0);for(let s=0;s<A;s++){mn.evaluateCoefs(x.polypoly1,vt.constructDouble(w[s]),x.tempP1);const t=[];let e=bn(x.tempP1,d,_,E,b,t);if(0!==e)if(mn.evaluateCoefs(x.polypoly2,vt.constructDouble(w[s]),x.tempP2),e<0){if(e=bn(x.tempP2,d,_,E,b,t),e<0)continue;for(let n=0;n<e;n++)C.push(Ut(t[n],w[s]))}else{const n=x.tempP2.absEvaluate(Ht);n.mulThis(vt.constructDouble(1e-12));for(let i=0;i<e;i++){const e=x.tempP2.evaluate(vt.constructDouble(t[i]));e.absThis(),e.lt(n)&&C.push(Ut(t[i],w[s]))}}}if(A=C.length,0===D&&0===A)return 0;C=C.concat(v),C.sort(((t,e)=>y?bt(t.second,e.second):bt(t.first,e.first)));const T=te(C,((t,e)=>t.first===e.first&&t.second===e.second));C=C.slice(0,T),f.length=0,P.length=0;for(const s of C)f.push(s.first),P.push(s.second);return s(f.length===P.length),P.length}function gn(t,e,s,n,i,r,o){if(0===t.power())return t.isZero()?-1:0;const a=t.evaluate(vt.constructInt32(1)).isZero();if(1===t.power()){const s=pn(t.getElement(1),t.getElement(0),e,r.at(0));return r[0].limitPrecisionThis(n),1!==s?0:(r[0].limitPrecisionThis(n),1)}if(2===t.power()){return fn(t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r)}if(3===t.power()){return Pn(t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r)}if(4===t.power()){return yn(t.getElement(4),t.getElement(3),t.getElement(2),t.getElement(1),t.getElement(0),n,e,a,r)}return An(t,e,s,n,a,i,r,o)}function dn(){return{polyIntersect:new mn,polyX1:new mn,polyY1:new mn,polyX1Deriv:new mn,polyY1Deriv:new mn,lazyPolyD1:new mn,lazyPolyD1Deriv:new mn,tempP:new mn,tempP1:new mn,tempP2:new mn,polypoly1Proximity:new un,polypoly2Proximity:new un}}function _n(t,e,s,n,i,r,o,a,h,m,u){const l=dn();l.polyX1.construct(t,e),l.polyY1.construct(s,n),l.polyX1Deriv.assignCopy(l.polyX1),l.polyX1Deriv.derivative1This(),l.polyY1Deriv.assignCopy(l.polyY1),l.polyY1Deriv.derivative1This(),l.polyIntersect.assignCopy(l.polyX1),l.polyIntersect.mulThis(l.polyX1),l.polyIntersect.mulElementThis(o[0]),l.tempP.assignCopy(l.polyY1),l.tempP.mulThis(l.polyY1),l.tempP.mulElementThis(o[1]),l.polyIntersect.addThis(l.tempP),i?(l.lazyPolyD1.construct(i,r),l.tempP.assignCopy(l.lazyPolyD1),l.tempP.mulThis(l.lazyPolyD1),l.tempP.mulElementThis(o[2]),l.polyIntersect.addThis(l.tempP)):l.polyIntersect.add0(o[2]);{const i=o[0].clone(),r=i.clone();r.sqrThis();const a=o[1].clone(),h=a.clone();h.sqrThis();const m=o[2].clone(),u=i.clone();u.subThis(a),l.polyX1.construct(t,e),l.polyX1Deriv.assignCopy(l.polyX1),l.polyX1Deriv.derivative1This(),l.polyY1.construct(s,n),l.polyY1Deriv.assignCopy(l.polyY1),l.polyY1Deriv.derivative1This(),l.tempP.assignCopy(l.polyX1),l.tempP.mulThis(l.polyX1),l.tempP.mulElementThis(h),l.tempP.mulElementThis(m),l.polypoly1Proximity.construct0(l.tempP),l.tempP.assignCopy(l.polyX1),l.tempP.mulThis(a.mul(u).mul(m).ldexpThis(1)),l.polypoly1Proximity.addElement(l.tempP),l.tempP.assignCopy(l.polyX1),l.tempP.mulThis(l.polyX1),l.tempP.mulElementThis(i.mul(h)),l.tempP1.assignCopy(l.polyY1),l.tempP1.mulThis(l.polyY1),l.tempP1.mulElementThis(r.mul(a)),l.tempP.addThis(l.tempP1),l.tempP.add0(u.mul(u).mul(m)),l.polypoly1Proximity.addElement(l.tempP),l.tempP.assignCopy(l.polyX1),l.tempP.mulElementThis(u.mul(i).mul(a).ldexpThis(1)),l.polypoly1Proximity.addElement(l.tempP),l.tempP.construct0(i.mul(u).mul(u)),l.polypoly1Proximity.addElement(l.tempP),l.polypoly1Proximity.updatePower(),l.tempP.construct0(Zt),l.polypoly2Proximity.construct0(l.tempP),l.tempP.assignCopy(l.polyX1),l.tempP.mulThis(l.polyX1Deriv),l.tempP1.assignCopy(l.polyY1),l.tempP1.mulThis(l.polyY1Deriv),l.tempP.addThis(l.tempP1),l.tempP.mulElementThis(i.mul(a)),l.polypoly2Proximity.addElement(l.tempP),l.tempP.assignCopy(l.polyX1Deriv),l.tempP.mulElementThis(u.mul(i)),l.polypoly2Proximity.addElement(l.tempP),l.polypoly2Proximity.updatePower()}const c=[],g=[];u||(u=[]);let d=2*l.polyIntersect.power()+58;const _=.5*Number.EPSILON,p=bn(l.polyIntersect,a,h,_,d,g);if(p<0)return-1;vn(l.polypoly1Proximity,l.polypoly2Proximity,l.tempP),d=2*l.tempP.power()+58;let f=bn(l.tempP,a,h,_,d,c);if(f<0&&(f=0),0===p&&0===f)return 0;const P=c.concat(g);u.length=P.length,K(u,P,0,0,P.length),kt(u);const y=te(u,((t,e)=>0===bt(t,e)));return u.length=y,u.length}function pn(t,e,s,n){return t.isZero()?e.isZero()?-1:0:(n.setThis(e),n.negateThis(),n.divThis(t),s.isEmpty()||s.containsCoordinate(n.value())?1:0)}function fn(t,e,s,n,i,r,o){if(t.isZero()){if(r)return o[0].setInt32(1),i.containsCoordinate(1)?1:0;return pn(e,s,i,o[0])}if(r){let e=2;return o[0].setInt32(1),s.equals(t)?(o[1].setInt32(1),e=1):o[1].setThis(s.div(t)),i.containsCoordinate(o[1].value())||(e=1),i.containsCoordinate(o[0].value())||(e--,o[0].setThis(o[1])),2===e&&o[0].value()>o[1].value()&&(o[1]=tt(o[0],o[0]=o[1])),e}const a=e.clone();a.sqrThis();const h=t.clone();if(h.mulThis(s).ldexpThis(2).negateThis().addThis(a),h.LZ())return 0;const m=n+2,u=vt.sqrt(h,m),l=u.clone();e.LZ()&&l.negateThis(),l.addThis(e).limitPrecisionThis(m).ldexpThis(-1).negateThis();let c=0;return o[0].setThis(l).divThis(vt.constructAssign(t,m)).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(o[0].value()))&&c++,u.isZero()||l.isZero()||(o[c].setThis(s).divThis(l).limitPrecisionThis(n),(i.isEmpty()||i.containsCoordinate(o[c].value()))&&c++,2===c&&o[0].gt(o[1])&&(o[1]=tt(o[0],o[0]=o[1]))),c}function Pn(t,e,n,i,r,o,a,h){if(t.isZero()){return fn(e,n,i,r,o,a,h)}const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=tt(h[t],h[t]=h[s-1]),s--);e=s}return $(h,0,e,((t,e)=>t.compare(e))),e};if(i.isZero()){let s=0;o.containsCoordinate(0)&&(h[0].setInt32(0),s=1);return m(fn(t,e,n,r,o,a,h.slice(1)),s)}if(a){let s=0;o.containsCoordinate(1)&&(h[0].setInt32(1),s=1);const n=e.add(t),a=i.negate(),u=t.add(n).add(a).isZero();return m(fn(t,n,a,r,o,u,h.slice(s)),s)}const u=new vt,l=new vt,c=new vt,g=e.clone();if(g.isZero())l.setThis(n),l.divThis(t),c.setThis(i),l.divThis(t);else{g.divThis(t).divDoubleThis(3).negateThis();const s=e.clone();s.sqrThis();const r=t.clone();r.sqrThis(),l.setThis(t),l.mulThis(n).mulDoubleThis(3).subThis(s).divThis(r).divDoubleThis(3),c.setThis(s),c.mulThis(e),c.ldexpThis(1),u.setThis(t),u.mulThis(e).mulThis(n).mulDoubleThis(9),c.subThis(u),u.setThis(r),u.mulThis(i).mulDoubleThis(27),c.addThis(u),c.divThis(r).divThis(t).divDoubleThis(27)}if(l.isZero()){const t=c.clone();return t.negateThis(),t.isZero()?(h[0].setThis(g),In(o,r,h,1)):(h[0].setThis(vt.cubicRoot(c,r).add(g)),In(o,r,h,1))}const d=c.clone();if(d.sqrThis().ldexpThis(-2),u.setThis(l.clone()),u.sqrThis().mulThis(l).divDoubleThis(27),d.addThis(u),d.isZero())return h[0].setThis(c),h[0].mulDoubleThis(3).divThis(l),h[1].setThis(h[0]),h[1].negateThis(),h[1].ldexpThis(-1),h[0].addThis(g),h[1].addThis(g),In(o,r,h,2);if(d.GZ())return d.setThis(vt.sqrt(d,r+8)),u.setThis(c),u.ldexpThis(-1).negateThis(),u.addThis(d),h[0].setThis(vt.cubicRoot(u,r+8)),u.setThis(c),u.ldexpThis(-1).negateThis(),u.subThis(d),h[0].addThis(vt.cubicRoot(u,r+8)),h[0].addThis(g),In(o,r,h,1);u.setThis(l),u.divDoubleThis(3).negateThis(),s(u.GEZ());const _=vt.sqrt(u,r+8),p=_.clone();p.negateThis(),p.addThis(g),_.addThis(g);const f=vt.constructDouble(o.isEmpty()?-Number.MAX_VALUE:o.vmin),P=vt.constructDouble(o.isEmpty()?Number.MAX_VALUE:o.vmax),y=new mn({zeroCtor:vt});y.construct0(i),y.addElement(n),y.addElement(e),y.addElement(t);const x=new mn({copy:y});x.derivative1This();let C=0;const v=_t(vt,4);v[C++].setThis(f),p.gt(f)&&p.lt(P)&&v[C++].setThis(p),_.gt(f)&&_.lt(P)&&v[C++].setThis(_),v[C++].setThis(P);const b=3*r;let E=52,S=Number.EPSILON;for(;E<b;)2*E<=b?(S*=S,E*=2):(S*=Number.EPSILON,E+=52);E+=2;let D=0,w=!1;for(let s=1;s<C;s++){if(Dn(y,x,v[s-1],v[s],S,E,h[0])){D=1,w=s+1<C;break}}if(!D)return 0;if(w){const t=new mn({zeroCtor:vt,coef0:h[0]});t.negateThis(),t.addElement(Ht);const e=new mn({zeroCtor:vt}),n=new mn({zeroCtor:vt});y.div(t,e,n),s(2===e.power()),s(0===n.power());const i=fn(e.getElement(2),e.getElement(1),e.getElement(0),r,o,!1,h.slice(1));s(i>=0&&i<=2),D+=i}return In(o,r,h,D)}function yn(t,e,s,n,i,r,o,a,h){if(t.isZero())return Pn(e,s,n,i,r,o,a,h);const m=(t,e)=>{if(t>0){let s=e+t;for(let t=1;t<s;t++)h[t].equals(h[0])&&(h[s-1]=tt(h[t],h[t]=h[s-1]),s--);e=s}return $(h,0,e,((t,e)=>t.compare(e))),e};if(i.isZero()){let i=0;o.containsCoordinate(0)&&(h[0].setInt32(0),i=1);return m(Pn(t,e,s,n,r,o,a,h.slice(i)),i)}const u=new mn({zeroCtor:vt,coef0:i});if(u.addElement(n),u.addElement(s),u.addElement(e),u.addElement(t),a){let t=0;o.containsCoordinate(1)&&(h[0].setInt32(1),t=1);const e=new mn({zeroCtor:vt,coef0:vt.constructInt32(-1)});e.addElement(vt.constructInt32(1));const s=new mn({zeroCtor:vt}),n=new mn({zeroCtor:vt});u.div(e,s,n);return m(Pn(3===s.power()?s.getElement(3):Zt.clone(),s.power()>=2?s.getElement(2):Zt.clone(),s.power()>=1?s.getElement(1):Zt.clone(),s.getElement(0),r,o,s.evaluate(Ht).isZero(),h.slice(t)),t)}if(u.getElement(0).isZero()){let t=0;for(o.containsCoordinate(0)&&(t=1,h[0].setDouble(0));u.getElement(0).isZero()&&u.power()>0;)u.shiftRight(1);const e=Pn(3===u.power()?u.getElement(3):Zt.clone(),u.power()>=2?u.getElement(2):Zt.clone(),u.power()>=1?u.getElement(1):Zt.clone(),u.getElement(0),r,o,!1,h.slice(t));return e>0&&(t+=e),$(h,0,t,((t,e)=>t.compare(e))),t}let l=52,c=Number.EPSILON;for(;l<r;)2*l<=r?(c*=c,l*=2):(c*=Number.EPSILON,l+=52);l+=2;const g=Tn(u),d=vt.constructDouble(Math.max(Math.abs(o.vmax),Math.abs(o.vmin)));return c=(g.lt(d)?g:d).mul(vt.constructDouble(c)).toDouble(),An(u,o,c,l,a,!1,h,4)}function xn(t,e){let s=t,n=e;n.power()>s.power()&&(n=tt(s,s=n));const i=s.power()-n.power(),r=new mn({copy:s.getElement(s.power())});s.mulThis(n.getElement(n.power()));for(let o=0,a=s.power();o<a;o++)if(o>=i){const t=new mn({copy:n.getElement(o-i)});t.mulThis(r);const e=s.getElement(o).sub(t);s.setElement(o,e)}s.setElement(s.power(),s.getElement(s.power()).setZero()),s.updatePower(),Cn(s)}function Cn(t){let e=0;for(;e<t.power()&&t.getElement(e).isZero();)e++;return e>0&&(t.shiftRight(e),!0)}function vn(t,e,s){const n=t.clone(),i=e.clone();for(Cn(n),Cn(i);0!==n.power()||0!==i.power();)xn(n,i);s.assignMove(n.getElement(0))}function bn(t,e,s,n,i,r){r.length=0;const o=t.power(),a=_t(vt,2*o+4),h=gn(t,s||U.unit(),n,i,!1,a,a.length);if(h>0){r.length=0;for(let t=0;t<h;t++){const e=a[t].value();t>0&&e<=r.at(-1)||r.push(e)}return r.length}return h}function En(t,e,n){if(s(n>=1),0===t.power())return t.isZero()?-1:0;const i=t.getElement(0);return i.negateThis(),i.divThis(t.getElement(1)),e[0].setThis(i),1}function Sn(t,e,n,i){if(t.power()<2)return En(t,n,i);s(i>=1);let r=t.getElement(1);r.mulThis(t.getElement(1));const o=t.getElement(0);if(o.mulThis(t.getElement(2)),o.ldexpThis(2),r.subThis(o),r.LZ())return 0;if(r.isZero()){const s=t.getElement(1);return s.negateThis(),s.divThis(t.getElement(2)),s.ldexpThis(-1),s.limitPrecisionThis(e),n[0].setThis(s),1}s(i>=2),r=vt.sqrt(r,e+8);const a=t.getElement(1);a.negateThis();const h=a.clone();h.subThis(r),h.divThis(t.getElement(2)),h.ldexpThis(-1),h.limitPrecisionThis(e);const m=a.clone();return m.addThis(r),m.divThis(t.getElement(2)),m.ldexpThis(-1),m.limitPrecisionThis(e),h.lt(m)?(n[0].setThis(h),n[1].setThis(m)):(n[1].setThis(h),n[0].setThis(m)),2}function Dn(t,e,s,n,i,r,o){let a=s.clone(),m=n.clone();a.limitPrecisionThis(r),m.limitPrecisionThis(r);let u=t.evaluate(a);u.limitPrecisionThis(r+2);let l=t.evaluate(m);if(l.limitPrecisionThis(r+2),u.GEZ()&&l.GEZ()||u.LEZ()&&l.LEZ())return u.absLessAbs(l)?(o=a,u.isZero()):(o=m,l.isZero());const c=l.LZ();c&&(l=tt(u,u=l),m=tt(a,a=m));const g=c?m:a,d=c?a:m,_=a.add(m).ldexpThis(-1);_.limitPrecisionThis(r);const p=m.sub(a);p.limitPrecisionThis(r),p.absThis();const f=p.clone();let P=t.evaluate(_),y=e.evaluate(_);const x=new mn({copy:t}),C=new mn({copy:e});{const s=Math.max(t.hiBitIndex(),e.hiBitIndex()),n=Ht.clone();n.ldexpThis(-(r+2));for(let i=64;i<s;){x.limitPrecisionThis(i),C.limitPrecisionThis(i);const r=x.evaluate(_),o=C.evaluate(_),a=r.sub(P),h=o.sub(y);if(a.divThis(P).absThis().lt(n)&&(y.isZero()||h.divThis(y).absThis().lt(n)))break;x.assignCopy(t),C.assignCopy(e),i=Math.min(i+64,s)}P.limitPrecisionThis(r+2),y.limitPrecisionThis(r+2)}const v=1,b=4;let E=b;const S=2;let D=1,w=0,A=0,T=v;const I=32,M=vt.constructDouble(.25*i),Y=vt.constructDouble(.5001);let X=0;const N=300;for(;++X<N;){if(X>I&&w>0||y.isZero()||T===S&&w>1||T===v&&E<b)T=v,D>1&&D--;else if(T=S,A>1){const t=p.mul(y);t.absThis(),t.ldexpThis(-3),t.absLessAbs(P)&&D++}p.setThis(f);const t=new vt;let e=!1;if(T===v)do{if(A>2){const e=p.clone();if(e.absThis(),e.ldexpThis(4),d.sub(g).ldexpThis(-1).gt(e)){if(_.equals(g)){t.setThis(_),_.setThis(g.add(e)),_.limitPrecisionThis(r),f.setThis(_.sub(t));break}if(_.equals(d)){t.setThis(_),_.setThis(d.sub(e)),_.limitPrecisionThis(r),f.setThis(_.sub(t));break}}}f.setThis(m.sub(a)),f.ldexpThis(-1),f.limitPrecisionThis(r),t.setThis(_),_.setThis(a.add(f)),_.limitPrecisionThis(r),_.lt(g)?_.setThis(g):_.gt(d)&&_.setThis(d),e=a.equals(_)||m.equals(_)}while(0);else for(;;){if(f.setThis(P.div(y)),f.limitPrecisionThis(r),1!==D&&f.mulDoubleThis(D),t.setThis(_),_.subThis(f),_.limitPrecisionThis(r),e=_.equals(t),_.lt(g)){if(D>1){_.setThis(t),D--;continue}f.setThis(t.sub(g)),_.setThis(g)}else if(_.gt(d)){if(D>1){_.setThis(t),D--;continue}f.setThis(t.sub(d)),_.setThis(d)}break}if(e||f.absLessAbs(M)){t.equals(_)||(P=x.evaluate(_),P.limitPrecisionThis(r+2));break}P=x.evaluate(_),P.limitPrecisionThis(r+2),y=C.evaluate(_),y.limitPrecisionThis(r+2);const s=a.clone(),n=m.clone();P.LZ()?(u.setThis(P),a.setThis(_)):(l.setThis(P),m.setThis(_)),T===S&&(a.equals(s)&&m.equals(n)||A>1&&!f.absLessAbs(Y.mul(p)))?w++:w=0,T===v?(E++,A=0):(E=0,A++)}return X>=N&&h("Root_finder iterations exceeded"),o.setThis(_),!0}function wn(t,e,s,n,i){const r=t.evaluate(s);if(r.isZero())return!0;const o=vt.constructDouble(.5*n),a=s.clone();a.subThis(o);const h=t.evaluate(a),m=s.clone();m.addThis(o);const u=t.evaluate(m);if(h.LZ()&&u.GZ()||h.GZ()&&u.LZ())return!0;if(r.GZ()?h.LEZ()||u.LEZ():h.GEZ()||u.GEZ())return!0;const l=h.LEZ()&&u.LEZ(),c=h.GEZ()&&u.GEZ();let g=!1;return l?r.gt(h)&&r.gt(u)&&(g=!0):c&&r.lt(h)&&r.lt(u)&&(g=!0),!!g&&r.absThis().lt(vt.constructDouble(1e-17))}function An(t,e,n,i,r,o,a,h){s(n>0),s(h>=t.power());const m=a,u=[];let l=[];const c=new mn({zeroCtor:t.m_zeroCtor}),g=new mn({zeroCtor:t.m_zeroCtor}),d=new mn({zeroCtor:t.m_zeroCtor}),_=vt.constructDouble(n),p=vt.constructDouble(e.vmin),f=vt.constructDouble(e.vmax),P=p.sub(_),y=f.add(_),x=Tn(t),C=x.clone();if(C.negateThis(),P.lt(C))P.setThis(C.sub(_));else if(P.gt(x))return 0;if(y.gt(x))y.setThis(x.add(_));else if(y.lt(C))return 0;let v=t,b=null;if(r){const e=new mn({coef0:vt.constructInt32(-1)});e.addElement(Ht),b=new mn,v=b;const s=new mn,n=new mn;for(t.div(e,s,n),b.assignCopy(s);v.evaluate(Ht).isZero();)v.div(e,s,n),b.assignCopy(s)}let E=!1;if(v.power()>0&&v.getElement(0).isZero())for(E=!0,b||(b=new mn({copy:v}),v=b);v.getElement(0).isZero();)b.shiftRight(1);let S=i+2*v.power()+2,D=n/Math.pow(2,v.power()+2),w=S;if(Zt.gt(P)&&Zt.lt(y))for(let s=0,Y=v.power();s<Y;s++)if(v.getElement(s).isZero()){u.push(Zt.clone());break}for(let Y=v.power()-1;Y>0;Y--)if(D*=2,S-=2,w-=2,v.power()-Y!=1)if(v.power()-Y!=2){g.assignMove(d),d.assignMove(v.derivative(Y-1));let t=[];for(let e=0,s=l.length;e<s;++e)if(l[e].first.lte(l[e].second)){const s=new vt;if(Dn(g,c,l[e].first,l[e].second,D,S,s)){u.push(s);let n=s.sub(_);n.limitPrecisionThis(w),t.push(Ut(l[e].first,n)),n=s.add(_),n.limitPrecisionThis(w),t.push(Ut(n,l[e].second))}else t.push(l[e])}l=t,t=[],c.assignMove(g)}else{g.assignMove(v.derivative(Y));const t=Sn(g,S,m,h);s(t>=0&&t<=2);for(let e=0;e<t;e++)m[e].gt(P)&&m[e].lt(y)&&!m[e].isZero()&&u.push(m[e].clone());if(u.length>1&&u.sort(((t,e)=>t.compare(e))),u.length>0){let t=u[0].sub(_);t.limitPrecisionThis(w),l.push(Ut(P.clone(),t));let e=1===u.length?y.clone():u[1].sub(_);t=u[0].add(_),t.limitPrecisionThis(w),e.limitPrecisionThis(w),l.push(Ut(t,e)),u.length>1&&(e=2===u.length?y.clone():u[2].sub(_),e.limitPrecisionThis(w),t=u[1].add(_),t.limitPrecisionThis(w),l.push(Ut(t,e)),u.length>2&&(t=u[2].add(_),t.limitPrecisionThis(w),l.push(Ut(t,y.clone()))))}else l.push(Ut(P.clone(),y.clone()));c.assignCopy(g),d.assignMove(v.derivative(Y-1))}else{g.assignMove(v.derivative(Y));1===En(g,m,h)&&(m[0].gt(P)&&m[0].lt(y)&&!m[0].isZero()&&u.push(m[0].clone()),c.assignMove(g),d.assignMove(v.derivative(Y-1)))}u.sort(((t,e)=>t.compare(e))),0===l.length&&(c.assignMove(v.derivative(v.power())),c.isZero()||l.push(Ut(P.clone(),y.clone())));let A=0,T=0,I=0;const M=new vt;for(;;){if(T<l.length){if(l[T].first.gt(l[T].second)){T++;continue}let t=!1;if(I<u.length&&u[I].lt(l[T].first)&&(t=!0),!t){Dn(v,c,l[T].first,l[T].second,n,i,M)&&(M.lt(p)?m[A++].setThis(p):M.gt(f)?m[A++].setThis(f):m[A++].setThis(M)),T++;continue}}if(!(I<u.length))break;0!==I&&u[I-1].equals(u[I])||wn(v,c,u[I],n)&&(M.setThis(u[I]),M.lt(p)?M.setThis(p):M.gt(f)&&M.setThis(f),0!==A&&m[A].equals(M)||m[A++].setThis(M)),I++}return E&&Zt.gt(P)&&Zt.lt(y)&&(m[A++].setThis(Zt),$(m,0,A,((t,e)=>t.compare(e)))),r&&Ht.gt(P)&&Ht.lt(y)&&(m[A++].setThis(Ht),$(m,0,A,((t,e)=>t.compare(e)))),A}function Tn(t){const e=t.getElement(t.power());e.limitPrecisionThis(53);const s=Zt.clone();for(let n=0,i=t.power();n<i;n++){const i=t.getElement(n);i.limitPrecisionThis(53),i.divThis(e).absThis(),i.gt(s)&&s.setThis(i)}return s.addThis(Ht),s.mulThis(vt.constructDouble(1+100*Number.EPSILON)),s}function In(t,e,s,n){let i=n;if(!t.isEmpty()){i=0;for(let e=0;e<n;++e)t.containsCoordinate(s[e].value())&&(i!==e&&s[i].setThis(s[e]),i++)}i>1&&(s[0].gt(s[1])&&(s[1]=tt(s[0],s[0]=s[1])),i>2&&(s[0].gt(s[2])&&(s[2]=tt(s[0],s[0]=s[2])),s[1].gt(s[2])&&(s[2]=tt(s[1],s[1]=s[2]))));for(let r=0;r<i;++r)s[r].limitPrecisionThis(e);return i}const Mn=[[.33998104358485626,.6521451548625461],[.8611363115940526,.34785484513745385]],Yn=[[.1834346424956498,.362683783378362],[.525532409916329,.31370664587788727],[.7966664774136267,.22238103445337448],[.9602898564975363,.10122853629037626]],Xn=[[.09501250983763744,.1894506104550685],[.2816035507792589,.18260341504492358],[.45801677765722737,.16915651939500254],[.6178762444026438,.14959598881657674],[.755404408355003,.12462897125553388],[.8656312023878318,.09515851168249279],[.9445750230732326,.062253523938647894],[.9894009349916499,.027152459411754096]],Nn=[[.04830766568773832,.0965400885147278],[.1444719615827965,.09563872007927486],[.23928736225213706,.09384439908080457],[.33186860228212767,.09117387869576389],[.42135127613063533,.08765209300440381],[.5068999089322294,.08331192422694675],[.5877157572407623,.07819389578707031],[.6630442669302152,.0723457941088485],[.7321821187402897,.06582222277636185],[.7944837959679424,.058684093478535544],[.84936761373257,.050998059262376175],[.8963211557660521,.04283589802222668],[.9349060759377397,.03427386291302143],[.9647622555875064,.02539206530926206],[.9856115115452684,.01627439473090567],[.9972638618494816,.007018610009470096]],qn=[[.024350292663424433,.048690957009139724],[.07299312178779904,.04857546744150343],[.12146281929612056,.048344762234802954],[.16964442042399283,.04799938859645831],[.21742364374000708,.04754016571483031],[.2646871622087674,.04696818281621002],[.31132287199021097,.046284796581314416],[.3572201583376681,.04549162792741814],[.4022701579639916,.044590558163756566],[.4463660172534641,.04358372452932345],[.48940314570705296,.04247351512365359],[.5312794640198946,.04126256324262353],[.571895646202634,.03995374113272034],[.6111553551723933,.038550153178615626],[.6489654712546573,.03705512854024005],[.6852363130542333,.035472213256882386],[.7198818501716109,.033805161837141606],[.7528199072605319,.03205792835485155],[.7839723589433414,.030234657072402478],[.8132653151227975,.028339672614259483],[.8406292962525803,.02637746971505466],[.8659993981540928,.024352702568710874],[.8893154459951141,.022270173808383253],[.9105221370785028,.02013482315353021],[.9295691721319396,.017951715775697343],[.9464113748584028,.015726030476024718],[.9610087996520538,.013463047896718643],[.973326827789911,.011168139460131128],[.983336253884626,.008846759826363947],[.9910133714767443,.006504457968978363],[.9963401167719553,.004147033260562468],[.9993050417357722,.001783280721696433]],Fn=[[.012223698960615764,.024446180196262518],[.03666379096873349,.024431569097850044],[.06108196960413957,.02440235563384958],[.08546364050451549,.024358557264690626],[.10979423112764375,.024300200167971867],[.13405919946118777,.02422731922281525],[.15824404271422493,.024139957989019287],[.18233430598533718,.024038168681024052],[.2063155909020792,.023922012136703457],[.23017356422666,.023791557781003402],[.2538939664226943,.023646883584447616],[.2774626201779044,.02348807601653591],[.3008654388776772,.02331522999406276],[.32408843502441337,.023128448824387027],[.3471177285976355,.022927844143686846],[.369939555349859,.02271353585023646],[.39254027503326744,.022485652032744968],[.414906379552275,.022244328893799764],[.43702450103710416,.02198971066846049],[.4588814198335522,.021721949538052076],[.48046407240417205,.02144120553920846],[.5017595591361445,.02114764646822135],[.5227551520511755,.02084144778075115],[.5434383024128103,.02052279248696007],[.5637966482266181,.020191871042130043],[.5838180216287631,.01984888123283086],[.6034904561585486,.019494028058706602],[.6228021939105849,.019127523609950944],[.6417416925623075,.01874958694054471],[.660297632272646,.01836044393733134],[.6784589224477192,.017960327185008687],[.6962147083695144,.017549475827117706],[.7135543776835874,.01712813542311138],[.7304675667419088,.016696557801589205],[.746944166797062,.016255000909785187],[.7629743300440948,.015803728659399347],[.7785484755064119,.015343010768865144],[.7936572947621933,.014873122602147314],[.8082917575079137,.014394345004166847],[.8224431169556439,.013906964132951985],[.8361029150609068,.013411271288616333],[.8492629875779689,.012907562739267348],[.8619154689395485,.012396139543950923],[.8740527969580318,.01187730737274028],[.8856677173453972,.011351376324080417],[.8967532880491582,.010818660739503076],[.9073028834017568,.010279479015832158],[.9173101980809605,.009734153415006806],[.9267692508789478,.009183009871660874],[.9356743882779164,.00862637779861675],[.9440202878302202,.008064589890486059],[.9518019613412644,.0074979819256347285],[.9590147578536999,.006926892566898814],[.9656543664319652,.006351663161707189],[.9717168187471366,.005772637542865698],[.9771984914639074,.00519016183267633],[.9820961084357185,.004604584256702955],[.9864067427245862,.004016254983738642],[.9901278184917344,.0034255260409102157],[.9932571129002129,.0028327514714579912],[.9957927585349812,.0022382884309626186],[.997733248625514,.0016425030186690294],[.9990774599773758,.0010458126793403489],[.9998248879471319,.00044938096029209035]];function Vn(t,e,s,n){const i=.5*(n-s),r=s+i,o=new ct(0);for(let a=0,h=Math.trunc(t/2);a<h;++a){let s,n;switch(t){case 4:s=Mn[a][0],n=Mn[a][1];break;case 8:s=Yn[a][0],n=Yn[a][1];break;case 16:s=Xn[a][0],n=Xn[a][1];break;case 32:s=Nn[a][0],n=Nn[a][1];break;case 64:s=qn[a][0],n=qn[a][1];break;case 128:s=Fn[a][0],n=Fn[a][1];break;default:throw new Error("Quadrature_integral: invalid n")}const h=ee(-.5,s,r),m=ee(i,s,r);o.pe(e(h)*n),o.pe(e(m)*n)}return o.getResult()*i}function Ln(t,e,s,n,i,r){return kn(t,e,s,r,n,i)}function Rn(t,e,s,n,i,r){let o=i;if(n)return r[0]=1,o=.5*(e-t)*(s(t)+s(e)),o;const a=r[0],h=(e-t)/a,m=t,u=new ct(0);for(let l=1;l<=r[0];++l){const t=(l-.5)*h;u.add(s(m+t))}return o=.5*(o+(e-t)*u.getResult()/a),r[0]*=2,o}function zn(t,e,s,n,i,r,o){let a=0,h=Math.abs(i-s[t]);const m=O(e,Number.NaN),u=O(e,Number.NaN);for(let d=0;d<e;++d){const e=Math.abs(i-s[t+d]);e<h&&(a=d,h=e),m[d]=n[t+d],u[d]=n[t+d]}let l=0,c=0,g=0;r[0]=n[t+a],a--;for(let d=1;d<e;d++){for(let n=0;n<e-d;n++){if(c=s[t+n]-i,g=s[t+n+d]-i,l=c-g,0===l)return!1;const e=(m[n+1]-u[n])/l;m[n]=c*e,u[n]=g*e}if(2*(a+1)<e-d){const t=a+1;o[0]=m[t]}else{const t=a;o[0]=u[t],a--}r[0]+=o[0]}return!0}function kn(t,s,n,i,r,o){if(n<s&&e("xTo < xFrom"),n===s)return 0;const a=[0];let m=Number.MAX_VALUE;const u=[Number.MAX_VALUE];let l=0;const c=32,g=O(c+1,Number.NaN),d=O(c+1,Number.NaN),_=[0];g[0]=1;let p=0,f=0;for(let e=0;e<c;e++){if(l=Rn(s,n,i,0===e,l,_),d[e]=l,e+1>=t){zn(e+1-t,t,g,d,0,a,u)||h("polynomial_interpolation");const s=r*Math.abs(a[0])+o,n=Math.abs(m-a[0]);if(n<=s&&Math.abs(u[0])<=s){if(p++,p>1&&(n<=.1*f||0===f||p>2))return a[0]}else p=0;f=n,m=a[0]}d[e+1]=d[e],g[e+1]=.25*g[e]}return a[0]}class Bn{constructor(){this.length=Number.NaN,this.area=Number.NaN,this.centroidX=Number.NaN,this.centroidY=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}function Gn(t,e,n,i,r,o,a,h){for(;;){const m=J.distance(e[0],e[2]),u=J.distance(e[0],e[1])+J.distance(e[1],e[2]);if(u-m<=r+i*u)return t+ot(m,u,.5);const l=_t(J,4),c=t=>{ti(e,n,1,t,l);return l[1].length()};if(0===a&&h<8){s(h<8);let m=c(0),l=c(1);o[0]+=2,m>l&&(l=tt(m,m=l),e[2]=tt(e[0],e[0]=e[2]),n[2]=tt(n[0],n[0]=n[2]));let g=m/(m+l),d=1,_=u;for(;g<1/32&&_>=r+i*_;){d/=4;const t=c(d);o[0]++,g=m/(t+m);const s=new J;if(Ki(e,n,.5*d,s),_=J.distance(s,e[0]),_<=r){const t=new J;Ki(e,n,d,t),_+=J.distance(t,s)}}if(1!==d){const s=_t(J,3),m=[0,0,0];Yi(e,n,d,e,n,s,m),t=Gn(t,s,m,i,r,o,0,h+1),a++,h++;continue}}let g=!1;const d=8;o[0]+=d;const _=Vn(d,c,0,1),p=16;o[0]+=p;const f=Vn(p,c,0,1);if(g=Math.abs(_-f)>r+i*u,!g)return t+f;if(a<8&&h<9){const s=_t(J,3),m=[0,0,0];Yi(e,n,.5,e,n,s,m),t=Gn(t,s,m,i,r,o,a+1,h+1),a++,h++;continue}const P=32;o[0]+=P;const y=Vn(P,c,0,1);if(g=Math.abs(f-y)>r+i*u,!g)return t+y;const x=64;o[0]+=x;const C=Vn(x,c,0,1);if(g=Math.abs(y-C)>r+i*u,!g)return t+C;const v=128;o[0]+=v;const b=Vn(v,c,0,1);return g=Math.abs(C-b)>r+i*u,t+b}}function Wn(t,e,s,n,i){if(s===e)return 0;const r=_t(J,3),o=[0,0,0];t.queryControlPoints(r),t.queryWeights(o);const a=[0,0,0],h=_t(J,3);Xi(r,o,e,s,h,a);return Gn(0,h,a,n,i,[0],0,0)}let jn=class{constructor(t,e,s){this.controlPoints=mt(t,3),this.weights=[0,0,0],K(this.weights,e,0,0,3),this.point=s.clone()}getMaxDerivative(){return 3}getValue(t,e){if(0===t){const t=new J;Ki(this.controlPoints,this.weights,e,t);const s=_t(J,4);ti(this.controlPoints,this.weights,1,e,s);return 2*t.sub(this.point).dotProduct(s[1])}if(1===t){const t=new J;Ki(this.controlPoints,this.weights,e,t);const s=_t(J,4);ti(this.controlPoints,this.weights,2,e,s);return 2*(t.sub(this.point).dotProduct(s[2])+s[1].dotProduct(s[1]))}if(2===t){const t=new J;Ki(this.controlPoints,this.weights,e,t);const s=_t(J,4);ti(this.controlPoints,this.weights,3,e,s);return 2*(t.sub(this.point).dotProduct(s[3])+3*s[1].dotProduct(s[2]))}return 0}getError(t){return s(0),0}};function Zn(t,e,s,n){const i=Ei(0,0,0,0,J.getNAN()),r=O(18,Number.NaN),o=_t(J,3);t.queryControlPoints(o),o[2].subThis(e),o[1].subThis(e),o[0].subThis(e);const a=[0,0,0];t.queryWeights(a);const h=[1,tr(a),1],m=sr(a,s),u=sr(a,n),l=Xs(new jn(o,h,new J(0,0)),U.construct(m,u),18,r);Ki(o,h,m,i.pt),i.t=m,i.d=J.distance(i.pt,new J(0,0));const c=new J;Ki(o,h,u,c);const g=J.distance(c,new J(0,0));g<i.d&&(i.d=g,i.t=u,i.pt.assign(c));for(let d=0;d<l;d++){Ki(o,h,r[d],c);const t=J.distance(c,new J(0,0));t<i.d&&(i.d=t,i.t=er(a,r[d]),i.pt.assign(c))}return i}function Hn(t,e,s,n,i){let r=!0;const o=_t(J,4),a=Ln(5,e,s,n,i,(e=>{$n(t,1,e,o);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()}));r=!1;const h=Ln(5,e,s,n,i,(e=>{$n(t,1,e,o);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*o[1].length()}));return new J(a,h)}function Un(t){t.m_cachedValues=null}function On(t,e){e.m_cachedValues=tt(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}function Qn(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new Bn,s=_t(J,3);t.queryControlPoints(s);const n=[0,0,0];return t.queryWeights(n),Jn(s,n,e.specialPoints),Ci(t,e),e}function Jn(t,e,s){if(0===e[1])return s.length=0,s.push(0),void s.push(1);const n=_t(st,8);n[0].set(0);let i=1;{const s=new st(t[1].x).subThis(t[0].x).mulThis(e[1]).mulThis(e[0]),r=new st(t[2].x).subThis(t[0].x).mulThis(e[2]).mulThis(e[0]),o=s.subE(r).addThisE(new st(t[2].x).subThis(t[1].x).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const a=_t(st,2);let h=js(o,r,s,new U(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)ht(a[t].value(),0,1)||(n[i]=a[t],i++)}{const s=new st(t[1].y).subThis(t[0].y).mulThis(e[1]).mulThis(e[0]),r=new st(t[2].y).subThis(t[0].y).mulThis(e[2]).mulThis(e[0]),o=s.subE(r).addThisE(new st(t[2].y).subThis(t[1].y).mulThis(e[2]).mulThis(e[1]));r.subThisE(s.mul(2));const a=_t(st,2);let h=js(o,r,s,new U(0,1),!1,a);h<0&&(h=0);for(let t=0;t<h;t++)ht(a[t].value(),0,1)||(n[i]=a[t],i++)}if(n[i].set(1),i++,i>2){$(n,0,i,((t,e)=>bt(t.value(),e.value())));let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),s.length=i;for(let r=0;r<i;r++)s[r]=n[r].value()}function Kn(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Kn(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=Qn(t);if(n&&!Number.isNaN(i.length))return i.length;const r=fi(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,u=i.specialPointsCount();m<u;m++){const s=i.specialPoints[m];if(a+=Wn(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return n&&(i.length=a),a}function $n(t,e,s,n){const i=_t(J,3);t.queryControlPoints(i);const r=[0,0,0];t.queryWeights(r),ti(i,r,e,s,n)}function ti(t,e,s,n,i){const r=[t[0],t[1],t[2]],o=[e[0],e[1],e[2]],a=_t(J,4);ei(r,o,s,n,a);for(let h=0;h<=s;h++)i[h].setCoords(a[h].x,a[h].y)}function ei(t,e,n,i,r){s(n>0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThis(o[0]);o[0].setCoords(0,0)}const a=si(o,e,0,i),m=ii(e,0,i),u=a.divide(m);if(r[0].assign(u),0===n)return;const l=[e[1]*e[0],e[2]*e[0]*.5,e[1]*e[2]],c=[t[1].sub(t[0]),t[2].sub(t[0]),t[2].sub(t[1])],g=m*m,d=si(c,l,0,i).mul(2).divide(g);if(r[1].assign(d),1===n)return;const _=ii(e,1,i),p=2*m*_,f=si(c,l,1,i).mul(2).sub(d.mul(p)).divide(g);if(r[2].assign(f),2===n)return;const P=si(c,l,2,i).mul(2),y=2*(_*_+m*ii(e,2,i)),x=P.sub(f.mul(p).mul(2)).sub(d.mul(y)).divide(g);r[3].assign(x),3!==n&&h("")}function si(t,e,s,n){if(0===s){if(n<=.5){const s=new J;xt(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new J;xt(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new J;return xt(2,s,i,n,r),r}{const s=new J;Ct(2,t[0].mul(e[0]),t[1].mul(e[1]),n,s);const i=new J;Ct(2,t[1].mul(e[1]),t[2].mul(e[2]),n,i);const r=new J;return Ct(2,s,i,n,r),r}}if(1===s){const s=t[1].mul(e[1]),i=s.sub(t[0].mul(e[0])).mul(1-n).add(t[2].mul(e[2]).sub(s).mul(n));return i.mulThis(2),i}if(2===s){const s=t[1].mul(e[1]),n=t[2].mul(e[2]).sub(s).sub(s.sub(t[0].mul(e[0])));return n.mulThis(2),n}h("")}function ni(t,e,s,n){if(n.toDouble()<=.5){const s=new Se;It(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new Se;It(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new Se;return It(2,s,i,n,r),r}{const s=new Se;Mt(2,t[0].mulE(e[0]),t[1].mulE(e[1]),n,s);const i=new Se;Mt(2,t[1].mulE(e[1]),t[2].mulE(e[2]),n,i);const r=new Se;return Mt(2,s,i,n,r),r}}function ii(t,e,s){if(0===e){const e=ot(t[0],t[1],s),n=ot(t[1],t[2],s);return ot(e,n,s)}if(1===e){return 2*((1-s)*(t[1]-t[0])+(t[2]-t[1])*s)}if(2===e){return 2*(t[2]-t[1]-(t[1]-t[0]))}h("")}function ri(t,e,s){if(s.toDouble()<=.5){const e=Dt(t[0],t[1],s),n=Dt(t[1],t[2],s);return Dt(e,n,s)}{const e=wt(t[0],t[1],s),n=wt(t[1],t[2],s);return wt(e,n,s)}}function oi(t,e,s,n,i){const r=[Se.constructPoint2D(t[0]),Se.constructPoint2D(t[1]),Se.constructPoint2D(t[2])];r[2].subThisE(r[0]),r[1].subThisE(r[0]),r[0].setCoords(0,0);ai(r,[new st(e[0]),new st(e[1]),new st(e[2])],s,n,i)}function ai(t,e,n,i,r){s(n>0);const o=[t[0].clone(),t[1].clone(),t[2].clone()];if(!o[0].isZero()){for(let t=1;t<3;++t)o[t].subThisE(o[0]);o[0]=Se.constructCoords(0,0)}const a=ni(o,e,0,i),h=ri(e,0,i),m=a.divE(h);r[0].setE(m);const u=[e[1].mulE(e[0]),e[2].mulE(e[0]).mul(.5),e[1].mulE(e[2])],l=ni([t[1].subE(t[0]),t[2].subE(t[0]),t[2].subE(t[1])],u,0,i).mul(2),c=h.sqr(),g=l.divE(c);r[1].setE(g)}function hi(t,e,s){const n=_t(J,3);t.queryControlPoints(n);const i=O(3,Number.NaN);t.queryWeights(i),mi(n,i,e,s)}function mi(t,e,s,n){s.value()<0&&s.set(0,s.eps()),s.value()>1&&s.set(1,s.eps());const i=_t(Se,4);oi(t,e,1,s,i),n.setE(i[1])}function ui(t,e,s){const n=lt(s,0,1),i=_t(J,4);if(ti(t,e,3,n,i),i[1].isZero()){if(i[2].isZero())return i[3];{const t=i[2].clone();return 1===n&&t.negateThis(),t}}return i[1]}let li=class{constructor(t,e){this.len=0,this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Kn(this.b,e,!1):0}getError(t){return s(0),0}};function ci(t,e,s){const n=Kn(t,1,!1);if(e<=0)return e;if(e>=n)return e-n+1;const i=[0];return 1!==Xs(new li(t,e),U.unit(),1,i)&&h(""),i[0]}function gi(t){const e=_t(J,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),di(e,s)}function di(t,e){const n=tr(e);if(1===n){return br(t)}if(0===n)return 0;const i=[new J(0,0),t[1].sub(t[0]),t[2].sub(t[0])],r=i[1].crossProduct(i[2]);if(n<1){s(n>0);const t=1-n;let e;if(t<.01)e=-1/3+t*(2/15+t*(3/35+t*(16/315+t*(20/693+t*(16/1001+t*(56/6435))))));else{const s=t*(1+n),i=Math.atan2(Math.sqrt(t),Math.sqrt(1+n));e=n*(.5*n-se(s)*i)/s}return r*e}{const t=(n-1)*(n+1);return.25*n/Math.pow(t,1.5)*(-2*n*Math.sqrt(t)*r-4*i[1].y*i[2].x*Math.atanh(Math.sqrt((n-1)/(n+1)))-i[1].x*i[2].y*Math.log(2*n*(n-Math.sqrt(t))-1))}}function _i(t,e){const n=tr(e);if(1===n){const e=_t(J,3);Zr(t,e);const s=e[2].clone(),n=e[1].clone(),i=new J,r=s.y*n.x-s.x*n.y;return i.x=-(4*s.x+5*n.x)*r/60,i.y=-(4*s.y+5*n.y)*r/60,i}if(0===n)return new J(0,0);s(n>0);const i=t[1].sub(t[0]),r=t[2].sub(t[0]);if(n<1){const t=Math.sqrt(1-n),e=Math.sqrt(1+n),s=(i.y*r.x-i.x*r.y)*n/Math.pow(t*e,5)/12,o=Math.atan2(t,e),a=n*t*e,h=n*n,m=i.mul(2*(2+h)),u=r.mul(2*h-5),l=m.add(u).mul(a),c=r.sub(i.mul(2*h)).mul(6*o);return l.add(c).mul(s)}{const t=Math.sqrt(n-1),e=Math.sqrt(n+1),s=(i.y*r.x-i.x*r.y)*n/Math.pow(t*e,5)/12,o=Math.atanh(t/e),a=n*t*e,h=n*n,m=i.mul(4).sub(r.mul(5)),u=i.add(r).mul(2*h),l=m.add(u).mul(a),c=r.sub(i.mul(2*h)).mul(6*o);return l.add(c).mul(s)}}function pi(t){const e=_t(J,3),s=[0,0,0];return t.queryControlPoints(e),t.queryWeights(s),_i(e,s)}function fi(t){return Pi(t.calculateUpperLength2D())}function Pi(t){return 256*ut()*t}function yi(t){if(0===t.m_weights[1])return!0;const e=J.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function xi(t){return t.m_cachedValues}function Ci(t,e){t.m_cachedValues=e}function vi(t,e,s,n,i){const r=_t(J,3);t.queryControlPoints(r);const o=[0,0,0];t.queryWeights(o);const a=[0];return 1===bi(r,o,e,U.unit(),n,i,1,a)?a[0]:Number.NaN}function bi(t,e,n,i,r,o,a,h){l(U.unit().contains(i)&&a>0,""),(o<0||Number.isNaN(o))&&(o=Number.MAX_VALUE);const m=new Array(3);for(let s=0;s<3;++s)m[s]=t[s].sub(n);const u=tr(e),c=an.constructPoint2D(m[0]),g=an.constructPoint2D(m[1]),d=an.constructPoint2D(m[2]),_=vt.constructDouble(u),p=_.clone();p.ldexpThis(1);const f=c.dotProduct(g.sub(c)).mul(_),P=_.mul(_.addDouble(2)),y=d.sub(g.mul(P.ldexp(1))),x=g.sqrLength().mul(_.mul(_).ldexp(1)).add(c.sqrLength().mul(_.ldexp(2).subDouble(1))).add(c.dotProduct(y)),C=d.sub(g.mul(p)).add(c.mul(p.subDouble(1))),v=g.mul(_).sub(c).dotProduct(C).mulDouble(3),b=g.dotProduct(d).mul(_.subDouble(3).mul(_)).ldexp(1),E=g.sqrLength().mul(_.mul(_).ldexp(2)),S=c.sqrLength().mul(_.ldexp(2).subDouble(3)),D=c.dotProduct(d.sub(g.mul(_.mulDouble(3).subDouble(1)).mul(_))).ldexp(1),w=d.sqrLength().addThis(b).addThis(E).addThis(S).addThis(D),A=c.add(d).sub(g.mul(p)),T=_.subDouble(1),I=d.sub(c).dotProduct(A).mul(T),M=new J(0,0),Y=[];let X=new J;Ki(m,e,i.vmin,X);let N=J.distance(X,M);if(N<=o&&Y.push(new J(i.vmin,N)),i.vmin!==i.vmax&&(Ki(m,e,i.vmax,X),N=J.distance(X,M),N<=o&&Y.push(new J(i.vmax,N))),i.width()>0){const t=m[2].isZero(),s=_t(vt,4),n=yn(I,w,v,x,f,58,i,t,s);for(let r=0;r<n;r++){if(!i.containsExclusiveCoordinate(s[r].toDouble()))continue;let t=s[r].toDouble();t=er(e,t);const n=new J;Ki(m,e,t,n),N=J.distance(n,M),N<=o&&Y.push(new J(t,N))}}if(r){s(i.equals(U.unit()));{Ki(m,e,-1,X,!0);const t=new J;Ki(m,e,0,t);const s=new su({start:X,end:t}),n=s.getClosestCoordinate(M,!0);n<1&&(X=s.getCoord2D(n),N=J.distance(X,M),N<=o&&Y.push(new J(n-1,N)))}{Ki(m,e,2,X,!0);const t=new J;Ki(m,e,i.vmax,t);const s=new su({start:t,end:X}),n=s.getClosestCoordinate(M,!0);n>0&&(X=s.getCoord2D(n),N=J.distance(X,M),N<=o&&Y.push(new J(1+n,N)))}}if(!Y.length)return 0;Y.sort(((t,e)=>t.compare(e)));let q=0;const F=Y[0].x;if(h[q++]=F,q<a){const t=V(m,4,!1).total(),e=Y[0].y;for(let s=1,n=Y.length;s<n;s++)if(Y[s].y>e+t){Y.length=s;break}Y.sort(((t,e)=>bt(t.x,e.x))),q=0,h[q++]=Y[0].x;for(let s=1,n=Y.length;s<n;s++)Y[s].x!==h[q-1]&&q<a&&(h[q++]=Y[s].x)}return q}function Ei(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}function Si(t,e,n,i,r){const o=new ve;if(Di(t,U.unit(),o),o.inflate(i),!o.isIntersectingPoint2D(e))return 0;const a=Qn(t);let h=0;const m=[];let u=a.specialPoints[0];for(let l=1,c=a.specialPoints.length;l<c;++l){const n=a.specialPoints[l],i=Zn(t,e,u,n);if(0===m.length)m.push(i);else if(i.t===i.tmin)s(m.at(-1).d<=i.d),m.at(-1).tmax=i.tmax;else if(m.at(-1).t===m.at(-1).tmax){s(m.at(-1).d>=i.d);const t=m.at(-1).tmin;m[m.length-1]=i,m.at(-1).tmin=t}else m.push(i);u=n}for(const s of m)if(s.d<=i){const t=s.t;n?(n[h]=t,h++):h++}return h}function Di(t,e,s){const n=_t(J,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i),wi(n,i,e,s)}function wi(t,e,s,n){if(s.equalsRange(0,1))return void n.setFromPoints(t,3);const i=_t(J,3),r=[0,0,0];Xi(t,e,s.vmin,s.vmax,i,r),n.setFromPoints(i,3)}function Ai(t){const e=Et(t[0].y,t[1].y),s=Et(t[1].y,t[2].y);if(e>=0&&s>=0||e<=0&&s<=0){const e=Et(t[0].x,t[1].x),s=Et(t[1].x,t[2].x);if(e>=0&&s>=0||e<=0&&s<=0)return!0}return!1}function Ti(t){const e=_t(J,3);t.queryControlPoints(e);const s=Ii(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function Ii(t){let e=!1;for(let s=0;s<2;s++){const n=Et(t[0][s],t[2][s]);n>0?(Et(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?(Et(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function Mi(t,s,n){void 0===n&&(n=s,s=0);const i=new J;if(s<0||n>1)return i.setNAN(),i;if(s>n&&e("calculate_sub_weighted_centroid"),s===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=Qn(t),o=fi(t),a=o/t.calculateUpperLength2D();let h=s,m=0;for(let e=1,u=r.specialPointsCount();e<u;e++)if(s<r.specialPoints[e]){m=e-1;break}i.setCoords(0,0);for(let e=m+1,u=r.specialPointsCount();e<u;e++){const s=Math.min(r.specialPoints[e],n),m=Hn(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}function Yi(t,e,n,i,r,o,a){s(n>=0&&n<=1&&i!==o&&r!==a),s(e[0]>0&&e[2]>0&&e[1]>=0);const h=[1,tr(e),1],m=sr(e,n),u=mt(t,3),l=_t(Y,3);Hi(u,h,l);const c=_t(Y,3),g=_t(Y,3);nr(l,m,i?c:null,o?g:null),ir(e,n,r,a);const d=Ai(u);if(i){for(let t=0;t<3;++t)Ji(c[t],i[t]);or(u,i),d&&Ii(i)}if(o){for(let t=0;t<3;++t)Ji(g[t],o[t]);or(u,o),d&&Ii(o)}}function Xi(t,e,n,i,r,o){if(s(n>=0&&i<=1&&n<=i),n===i){const s=new J,i=Ui(t,e,n,s);return rr(t,s),r[0].assign(s),r[1].assign(s),r[2].assign(s),o[0]=i,o[1]=i,void(o[2]=i)}if(0===n&&1===i)return r[0].assign(t[0]),r[1].assign(t[1]),r[2].assign(t[2]),o[0]=e[0],o[1]=e[1],void(o[2]=e[2]);const a=_t(Y,3);{const s=[1,tr(e),1],r=sr(e,n),o=sr(e,i);Hi(t,s,a),nr(a,o,a,null);nr(a,r>=o?1:r/o,null,a)}const h=[0,0,0];ir(e,i,h,null),ir(h,n/i,null,h);const m=Ai(t),u=_t(J,3);Ji(a[1],u[1]),Ki(t,e,n,u[0]),Ki(t,e,i,u[2]),or(t,u);for(let s=0;s<3;++s)r[s].assign(u[s]),o[s]=h[s];m&&Ii(r)}function Ni(t,e,s){const n=tr(e),i=[1,n,1],r=4*n/(3*(1+n));s[0].assign(t[0]),s[3].assign(t[2]),St(t[0],t[1],r,s[1]),St(t[2],t[1],r,s[2]),new mo({cp:s}),new on({points:t,weight:n});let o=0,a=.1,h=0;for(let m=0;m<9;m++,a+=.1){const e=new J;Ki(t,i,a,e);const n=new J;jo(s,a,n);const r=J.sqrDistance(e,n);r>o&&(o=r,h=a)}{const e=new J;Ki(t,i,h,e);const n=[0];la(s,e,U.unit(),!1,-1,1,n);const r=new J;return jo(s,n[0],r),o=J.sqrDistance(e,r),Math.sqrt(o)}}function qi(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new ae,o=_t(J,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new J;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=_t(J,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):St(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&Ti(t)}function Fi(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==ki(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function Vi(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==Bi(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function Li(t,e){const s=t.getEndXY().sub(t.getStartXY()),n=s.length(),i=t.getControlPoint1();i.subThis(t.getStartXY());return!(Math.abs(i.crossProduct(s))/n>e)}function Ri(t,e,s,n,i){if(i){const n=Hm(e,s);if(0!==n){if(t){if(1===n){if(e.m_weights[0]===s.m_weights[0]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[2])return 2}else if(e.m_weights[0]===s.m_weights[2]&&e.m_weights[1]===s.m_weights[1]&&e.m_weights[2]===s.m_weights[0])return 2;return 4}return 2}}else if(Ae(e,s))return 1;return 0!==Gi(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function zi(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==Wi(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function ki(t,e,n,i,r,o,a,h,m,u){if(null!==r&&(r.length=0),null!==o&&(o.length=0),null!==i&&(i.length=0),n.isDegenerate(0)){const t=[0,0],s=e.intersectPoint(n.getStartXY(),t,a);if(s>0){if(null!==r)for(let e=0;e<s;e++)r.push(t[e]);if(null!=o)for(let t=0;t<s;t++)o.push(0);if(null!=i)for(let n=0;n<s;n++){const s=new J;e.queryCoord2D(t[n],s),i.push(s)}}return s}const l=Oe(e,n);if(a=Math.max(a,l),e.isDegenerateToLineHelper(l)){const t=new su({start:e.getStartXY(),end:e.getEndXY()}),s=ps(t,n,i,r,o,a,h,u);if(r)for(let n=0;n<s;++n){const s=t.getCoord2D(r[n]);r[n]=e.getClosestCoordinate(s,!1)}return s}if(Qe(e,n,a))return 0;const c=_t(J,3);e.queryControlPoints(c);const g=[0,0,0];e.queryWeights(g);const d=[1,tr(g),1],_=n.getEndXY().sub(n.getStartXY()),p=_.clone();p.leftPerpendicularThis();const f=c[0].clone(),P=c[1].clone(),y=c[2].clone(),x=P.sub(f),C=y.sub(f),v=y.sub(P),b=d[0],E=d[1],S=d[2],D=b*E,w=b*S,A=E*S,T=x.dotProduct(p)*D,I=C.dotProduct(p)*w;let M=T,Y=I-2*T,X=v.dotProduct(p)*A+I-I;const N=O(13,Number.NaN),q=O(13,Number.NaN);let F=qs(X,Y,M,U.unit(),!1,N);F<0&&(N[0]=0,N[1]=1,F=2);let V=0;for(let s=0,B=V;s<F;++s){const t=new J;Ki(c,d,N[s+B],t),q[V]=n.getClosestCoordinate(t,!1);J.distance(t,n.getCoord2D(q[V]))<=a&&(N[V]=N[s+B],V++)}const L=_t(J,3),R=_t(J,3);if(e.queryControlPoints(R),R[0].subThis(n.getStartXY()),R[1].subThis(n.getStartXY()),R[2].subThis(n.getStartXY()),ji(R,d,L,!1),Math.abs(_.x)>=Math.abs(_.y)){const t=_.y/_.x;X=L[2].y-L[2].x*t,Y=L[1].y-L[1].x*t,M=L[0].y-L[0].x*t}else{const t=_.x/_.y;X=L[2].x-L[2].y*t,Y=L[1].x-L[1].y*t,M=L[0].x-L[0].y*t}const z=e.getEndXY().equals(n.getStartXY())||e.getEndXY().equals(n.getEndXY()),k=[0,0];F=qs(X,Y,M,U.unit(),z,k);for(let s=0,B=V;s<F;++s){N[s+B]=k[s];const t=new J;Ki(c,d,N[s+B],t),q[V]=n.getClosestCoordinate(t,!1);J.distance(t,n.getCoord2D(q[V]))<=a&&(N[V]=N[s+B],V++)}s(V<N.length+4);for(let s=0;s<V;s++)N[s]=er(g,N[s]);F=e.intersectPoint(n.getStartXY(),k,a);for(let s=0;s<F;s++)N[V]=k[s],q[V++]=0;F=e.intersectPoint(n.getEndXY(),k,a);for(let s=0;s<F;s++)N[V]=k[s],q[V++]=1;F=n.intersectPoint(e.getStartXY(),k,a);for(let s=0;s<F;s++)q[V]=k[s],N[V++]=0;F=n.intersectPoint(e.getEndXY(),k,a);for(let s=0;s<F;s++)q[V]=k[s],N[V++]=1;return 0===V?0:Km(t,e,n,N,q,V,i,r,o,a,h,m,u)}function Bi(t,e,s,n,i,r,o,a,h,m){if(zh(s)){return ki(t,e,new su({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,o,a,h,m)}const u=Oe(e,s);if(Qe(e,s,o=Math.max(o,u)))return 0;const l=[],c=[],g=_t(J,4);{e.queryControlPoints(g);const t=_t(J,4),n=new ae;s.canonicToWorldTransformation(n);const i=new ae;i.setInvert(n),i.transformPoints2D(g,4,t);const r=_t(vt,3),a=_t(vt,3),h=_t(vt,3),m=[0,0,0];e.queryWeights(m),Zi(t,m,r,a,h);const u=_t(vt,3);u[0].setDouble(s.getSemiMinorAxis()),u[0].sqrThis(),u[1].setDouble(s.getSemiMajorAxis()),u[1].sqrThis(),u[2].setThis(u[0]),u[2].mulThis(u[1]),u[2].negateThis();const d=_n(r,2,a,2,h,2,u,!0,U.unit(),U.unit(),l);if(d>0){let t=0;for(let n=0;n<d;n++){const i=new J;e.queryCoord2D(l[n],i);const r=s.getClosestCoordinate(i,!1),a=new J;s.queryCoord2D(r,a);J.distance(i,a)<=o&&(l[t]=l[n],c.push(r),t++)}l.length=t}}const d=[0,1];for(let _=0;_<2;_++){const t=0===_?s.getStartXY():s.getEndXY(),n=vi(e,t,U.unit(),!1,-1),i=new J;e.queryCoord2D(n,i);J.distance(t,i)<=o&&(l.push(n),c.push(d[_]))}for(let _=0;_<2;_++){const t=[0,3];{const e=s.getClosestCoordinate(g[t[_]],!1),n=new J;s.queryCoord2D(e,n);J.distance(g[t[_]],n)<=o&&(l.push(d[_]),c.push(e))}}return Km(t,e,s,l,c,l.length,n,i,r,o,a,h,m)}function Gi(t,e,n,i,r,o,a,h,m,u){const l=_t(J,3);e.queryControlPoints(l);const c=_t(J,3);if(n.queryControlPoints(c),Je(l,c,3)<0)return Gi(t,n,e,i,o,r,a,h,m,!u);const g=Oe(e,n);if(e.isDegenerateToLineHelper(g)){const s=new su({start:e.getStartXY(),end:e.getEndXY()}),l=ki(t,n,s,i,o,r,a,h,m,!u);if(r)for(let t=0;t<l;++t){const n=s.getCoord2D(r[t]);r[t]=e.getClosestCoordinate(n,!1)}return l}if(n.isDegenerateToLineHelper(g)){const s=new su({start:n.getStartXY(),end:n.getEndXY()}),l=ki(t,e,s,i,r,o,a,h,m,u);if(o)for(let t=0;t<l;++t){const e=s.getCoord2D(o[t]);o[t]=n.getClosestCoordinate(e,!1)}return l}if(Qe(e,n,a=Math.max(a,g)))return 0;const d=O(3,Number.NaN);e.queryWeights(d);const _=O(3,Number.NaN);n.queryWeights(_);const p=[1,tr(d),1],f=[1,tr(_),1],P=new U(0,1),y=new U(0,1);{const t=ve.constructEmpty();wi(l,p,new U(0,1),t);const e=ve.constructEmpty();wi(c,f,new U(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if($i(l,p,t,P),$i(c,f,t,y),P.isEmpty()||y.isEmpty())return 0;Xi(l,p,P.vmin,P.vmax,l,p),Xi(c,f,y.vmin,y.vmax,c,f)}}const x=tu(l,2,c,2,a);if(0===x)return 0;const C=[],v=[];if(-1===x){const t=_t(vt,3),e=_t(vt,3),s=_t(vt,3);Zi(l,p,t,e,s);const n=_t(vt,3),i=_t(vt,3),r=_t(vt,3);Zi(c,f,n,i,r);const o=[],h=[],m=cn(t,2,e,2,s,2,n,2,i,2,r,2,!0,U.unit(),U.unit(),o,h);if(m>0)for(let u=0;u<m;u++){const t=new J;Ki(c,f,h[u],t);const e=new J;Ki(l,p,o[u],e);J.distance(e,t)<=a&&(C.push(o[u]),v.push(h[u]))}}for(let b=0;b<2;b++){let t,e,n;0===b?(t=l,e=c,n=f):(t=c,e=l,n=p);for(let i=0;i<2;i++){const r=0===i?0:t.length-1,o=new J,h=[0],m=bi(e,n,t[r],U.unit(),!1,-1,1,h);s(1===m),Ki(e,n,h[0],o),J.distance(t[r],o)<=a&&(0===b?(C.push(0===r?0:1),v.push(h[0])):(v.push(0===r?0:1),C.push(h[0])))}}if(0===C.length)return 0;if(!P.equalsRange(0,1))for(let s=0;s<C.length;++s)C[s]=on.recalculateParentT(P.vmin,P.vmax,C[s]);if(!y.equalsRange(0,1))for(let s=0;s<v.length;++s)v[s]=on.recalculateParentT(y.vmin,y.vmax,v[s]);for(let s=0;s<C.length;++s)C[s]=er(d,C[s]);for(let s=0;s<v.length;++s)v[s]=er(_,v[s]);return Km(t,e,n,C,v,C.length,i,r,o,a,h,m,u)}function Wi(t,e,s,n,i,r,o,a,h,m){if(e.isLine()){return Gr(t,s,new su({start:e.getStartXY(),end:e.getEndXY()}),n,r,i,o,a,h,!m)}if(s.isLine()){return ki(t,e,new su({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,o,a,h,m)}const u=Oe(e,s);if(Qe(e,s,o=Math.max(o,u)))return 0;const l=_t(J,3);e.queryControlPoints(l);const c=_t(J,3);s.queryControlPoints(c);const g=tu(l,2,c,2,o);if(0===g)return 0;const d=[],_=[];if(-1===g){const t=_t(vt,3),n=_t(vt,3),i=_t(vt,3),r=[0,0,0];e.queryWeights(r),Zi(l,r,t,n,i);const a=_t(an,3);Qr(c,a);const h=cn(t,2,n,2,i,2,[a[0].x,a[1].x,a[2].x],2,[a[0].y,a[1].y,a[2].y],2,null,0,!0,U.unit(),U.unit(),d,_);if(h>0){let t=0;for(let n=0;n<h;n++){const i=new J;s.queryCoord2D(_[n],i);const r=new J;e.queryCoord2D(d[n],r),J.distance(r,i)<=o&&(d[t]=d[n],_[t]=_[n],t++)}d.length=t,_.length=t}}for(let p=0;p<2;p++){let t;t=0===p?l:c;for(let n=0;n<2;n++){const i=0===n?0:t.length-1;let r;const a=new J;0===p?(r=wr(s,t[i],U.unit(),!1),s.queryCoord2D(r,a)):(r=vi(e,t[i],U.unit(),!1,-1),e.queryCoord2D(r,a)),J.distance(t[i],a)<=o&&(0===p?(d.push(0===i?0:1),_.push(r)):(_.push(0===i?0:1),d.push(r)))}}return Km(t,e,s,d,_,d.length,n,i,r,o,a,h,m)}function ji(t,e,s,n=!1){const i=_t(J,3);n?(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[1].subThis(i[0]),i[2].setCoordsPoint2D(t[2]),i[2].subThis(i[0]),i[0].setCoords(0,0)):(i[0].setCoordsPoint2D(t[0]),i[1].setCoordsPoint2D(t[1]),i[2].setCoordsPoint2D(t[2])),i[0].mulThis(e[0]),i[1].mulThis(e[1]),i[2].mulThis(e[2]),s[1].setCoords(i[1].x-i[0].x,i[1].y-i[0].y),s[2].setCoordsPoint2D(i[2].sub(i[1])),s[2].subThis(s[1]),s[1].x*=2,s[1].y*=2,s[0].setCoordsPoint2D(i[0])}function Zi(t,e,s,n,i){const r=vt.constructDouble(e[0]),o=vt.constructDouble(e[1]),a=vt.constructDouble(e[2]);s[0].setDouble(t[0].x),s[0].mulThis(r),s[1].setDouble(t[1].x),s[1].mulThis(o),s[2].setDouble(t[2].x),s[2].mulThis(a),s[2].subThis(s[1]),s[1].subThis(s[0]),s[2].subThis(s[1]),s[1].ldexpThis(1),n[0].setDouble(t[0].y),n[0].mulThis(r),n[1].setDouble(t[1].y),n[1].mulThis(o),n[2].setDouble(t[2].y),n[2].mulThis(a),n[2].subThis(n[1]),n[1].subThis(n[0]),n[2].subThis(n[1]),n[1].ldexpThis(1),i[0].setDouble(e[0]),i[1].setDouble(e[1]),i[2].setThis(i[1]),i[2].ldexpThis(1),i[2].negateThis(),i[2].addThis(i[0]),i[2].addDoubleThis(e[2]),i[1].subThis(i[0]),i[1].ldexpThis(1)}function Hi(t,e,s){for(let n=0;n<3;++n)s[n].setCoordsPoint2DZ(t[n].mul(e[n]),e[n])}function Ui(t,e,s,n){if(0===s)return n.assign(t[0]),e[0];if(1===s)return n.assign(t[2]),e[2];const i=[t[0].x*e[0],t[1].x*e[1],t[2].x*e[2]],r=[t[0].y*e[0],t[1].y*e[1],t[2].y*e[2]],o=[e[0],e[1],e[2]],a=s;let h,m,u;if(s<=.5){const t=pt(i[0],i[1],a),e=pt(i[1],i[2],a);h=ot(t,e,a);const s=pt(r[0],r[1],a),n=pt(r[1],r[2],a);m=ot(s,n,a);const l=pt(o[0],o[1],a),c=pt(o[1],o[2],a);u=pt(l,c,a)}else{const t=ft(i[0],i[1],a),e=ft(i[1],i[2],a);h=ft(t,e,a);const s=ft(r[0],r[1],a),n=ft(r[1],r[2],a);m=ft(s,n,a);const l=ft(o[0],o[1],a),c=ft(o[1],o[2],a);u=ft(l,c,a)}return h/=u,m/=u,n.setCoords(h,m),rr(t,n),u}function Oi(t,e,s){const n=_t(J,3);t.queryControlPoints(n);const i=[0,0,0];t.queryWeights(i);Qi([Se.constructPoint2D(n[0]),Se.constructPoint2D(n[1]),Se.constructPoint2D(n[2])],[new st(i[0]),new st(i[1]),new st(i[2])],e,s)}function Qi(t,e,s,n){if(0===s.value())return void n.setE(t[0]);if(1===s.value())return void n.setE(t[2]);const i=[t[0].x.mulE(e[0]),t[1].x.mulE(e[1]),t[2].x.mulE(e[2])],r=[t[0].y.mulE(e[0]),t[1].y.mulE(e[1]),t[2].y.mulE(e[2])],o=[e[0].clone(),e[1].clone(),e[2].clone()],a=new st,h=new st,m=new st;if(s.value()<=.5){const t=Dt(i[0],i[1],s),e=Dt(i[1],i[2],s);a.setE(Dt(t,e,s));const n=Dt(r[0],r[1],s),u=Dt(r[1],r[2],s);h.setE(Dt(n,u,s));const l=Dt(o[0],o[1],s),c=Dt(o[1],o[2],s);m.setE(Dt(l,c,s))}else{const t=wt(i[0],i[1],s),e=wt(i[1],i[2],s);a.setE(wt(t,e,s));const n=wt(r[0],r[1],s),u=wt(r[1],r[2],s);h.setE(wt(n,u,s));const l=wt(o[0],o[1],s),c=wt(o[1],o[2],s);m.setE(wt(l,c,s))}a.divThisE(m),h.divThisE(m);const u=new J(a.value(),h.value());rr([t[0].value(),t[1].value(),t[2].value()],u),n.x.set(u.x,a.eps()),n.y.set(u.y,h.eps())}function Ji(t,e){return e.setCoords(t.x/t.z,t.y/t.z),t.z}function Ki(t,e,s,n,i){if(i){if(s<0){return void rs(new su({start:t[0],end:t[0].add(ui(t,e,0).getUnitVector())}),s,n)}if(s>1){return void rs(new su({start:t[2],end:t[2].add(ui(t,e,1).getUnitVector())}),s-1,n)}}Ui(t,e,s,n)}function $i(t,e,s,n){n.setEmpty();const i=[];i.push(new U(0,1));const r=.5*Math.max(s.width(),s.height());for(;i.length;){const o=i.at(-1);i.pop();const a=new ve;if(wi(t,e,o,a),a.isIntersectingW(s)){const t=Math.max(a.width(),a.height());if(s.containsW(a)||t<=r||o.width()<1e-12)n.merge(o);else{const t=o.getCenter();i.push(U.construct(o.vmin,t)),i.push(U.construct(t,o.vmax))}}}}function tr(t){return t[1]/Math.sqrt(t[0]*t[2])}function er(t,e){const s=Math.sqrt(t[2]/t[0]);return e/ot(s,1,e)}function sr(t,e){const s=Math.sqrt(t[0]/t[2]);return e/ot(s,1,e)}function nr(t,e,n,i){s(e>=0&&e<=1);(new Y).setCoordsPoint3D(t[0]);(new Y).setCoordsPoint3D(t[1]);(new Y).setCoordsPoint3D(t[2]);const r=new Y,o=new Y,a=new Y;At(3,t[0],t[1],e,r),At(3,t[1],t[2],e,o),At(3,r,o,e,a);const h=t[2].clone();n&&(n[0].assign(t[0]),n[1].assign(r),n[2].assign(a)),i&&(i[0].assign(a),i[1].assign(o),i[2].assign(h))}function ir(t,e,n,i){const r=[t[0],t[1],t[2]];s(e>=0&&e<=1&&n!==i);const o=ot(r[0],r[1],e),a=ot(r[1],r[2],e),h=ot(o,a,e);n&&(n[0]=r[0],n[1]=o,n[2]=h),i&&(i[0]=h,i[1]=a,i[2]=r[2])}function rr(t,e){const s=U.constructEmpty();s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e.x=lt(e.x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e.y=lt(e.y,s.vmin,s.vmax)}function or(t,e){const s=new U;s.vmin=s.vmax=t[0].x,s.mergeNeCoordinate(t[1].x),s.mergeNeCoordinate(t[2].x),e[0].x=lt(e[0].x,s.vmin,s.vmax),e[1].x=lt(e[1].x,s.vmin,s.vmax),e[2].x=lt(e[2].x,s.vmin,s.vmax),s.vmin=s.vmax=t[0].y,s.mergeNeCoordinate(t[1].y),s.mergeNeCoordinate(t[2].y),e[0].y=lt(e[0].y,s.vmin,s.vmax),e[1].y=lt(e[1].y,s.vmin,s.vmax),e[2].y=lt(e[2].y,s.vmin,s.vmax)}class ar{constructor(){this.area=Number.NaN,this.centroid_x=Number.NaN,this.centroid_y=0,this.specialPoints=[],this.specialPointsLength=[]}specialPointsCount(){return this.specialPoints.length}}class hr{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-dr(this.b,e,!1):0}getError(t){return s(0),0}}function mr(t,e,s,n,i){let r=!0;const o=_t(J,3);t.queryControlPoints(o);let a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const u=Ln(5,e,s,n,i,(t=>{let e;if(t<=.5){const s=pt(0,h,t),n=pt(h,m,t);e=pt(s,n,t)}else{const s=ft(0,h,t),n=ft(h,m,t);e=ft(s,n,t)}return e*yr(o,1,t).length()}));r=!1,a=r?0:1,h=o[1][a]-o[0][a],m=o[2][a]-o[0][a];const l=Ln(5,e,s,n,i,(t=>{let e;if(t<=.5){const s=pt(0,h,t),n=pt(h,m,t);e=pt(s,n,t)}else{const s=ft(0,h,t),n=ft(h,m,t);e=ft(s,n,t)}return e*yr(o,1,t).length()}));return new J(u,l)}function ur(t){t.m_cachedValues=null}function lr(t,e){e.m_cachedValues=tt(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}function cr(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new ar;return gr(t,e.specialPoints),Dr(t,e),e}function gr(t,e){const s=_t(J,3);t.queryControlPoints(s);const n=_t(st,8);n[0].set(0);let i=1;{const t=_t(st,3);Ur(s,t,!1);const e=_t(st,2),r=new U(0,1);let o=Ws(t[2].mul(2),t[1],r,e[0]);o<0&&(o=0);for(let s=0;s<o;s++)ht(e[s].value(),0,1)||(n[i]=e[s],i++)}{const t=_t(st,3);Or(s,t,!1);const e=_t(st,2),r=new U(0,1);let o=Ws(t[2].mul(2),t[1],r,e[0]);o<0&&(o=0);for(let s=0;s<o;s++)ht(e[s].value(),0,1)||(n[i]=e[s],i++)}if(n[i].set(1),i++,i>2){$(n,0,i,((t,e)=>t.value()-e.value()));let t=0,e=n[0].value(),s=1;for(let r=1;r<i;r++)n[r].eq(n[r-1])?(e+=n[r].value(),s++):(s>1&&(e/=s,n[t].set(e)),t++,n[t]=n[r],e=n[r].value(),s=1);t++,i=t}n[0].set(0),n[i-1].set(1),e.length=i;for(let r=0;r<i;r++)e[r]=n[r].value()}function dr(t,e,s){const n=_t(J,3);return t.queryControlPoints(n),_r(n,e,s)}function _r(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+_r(t,1,!1)}if(1===e)return pr(t);const n=_t(J,3);return Fr(t,e,n,null),pr(n)}function pr(t){if(t[0].equals(t[1]))return J.distance(t[2],t[0]);if(t[1].equals(t[2]))return J.distance(t[0],t[2]);const e=J.distance(t[0],t[1])+J.distance(t[2],t[1]),s=J.distance(t[0],t[2]);if(e-s<=e*Number.EPSILON)return s;const n=1,i=_t(J,3);Zr(t,i,!0);const r=4*(Tt(i[2].x)+Tt(i[2].y)),o=2*(i[2].x*i[1].x+i[2].y*i[1].y),a=Tt(i[1].x)+Tt(i[1].y);if(1e-14*(Math.abs(o)+Math.abs(a))>=Math.abs(r)){if(1e-14*Math.abs(a)>=Math.abs(o)){return Math.sqrt(a)*n}return 2/(3*o)*(Math.pow(o*n+a,1.5)-Math.pow(a,1.5))}const h=o/r,m=a/r,u=m-h*h,l=n+h;if(0===u){if(h>=0&&l>=0||h<=0&&l<=0){return Math.abs(.5*Math.sqrt(r)*(l*l-h*h))}return.5*Math.sqrt(r)*(l*l+h*h)}const c=Math.sqrt(u+l*l),g=Math.sqrt(m);return.5*Math.sqrt(r)*(l*c-h*g+u*Math.log(Math.abs((l+c)/(h+g))))}function fr(t,e){const s=lt(e,0,1);let n=yr(t,1,s);return n.isZero()&&(n=yr(t,2,s)),n}function Pr(t,e,s){const n=_t(J,3);return t.queryControlPoints(n),yr(n,e,s)}function yr(t,e,s){if(1===e){const e=t[1].sub(t[0]).mul(1-s).add(t[2].sub(t[1]).mul(s));return e.mulThis(2),e}return 2===e?t[2].sub(t[1]).sub(t[1].sub(t[0]).mul(2)):J.construct(0,0)}function xr(t,e,s){{const e=Se.constructPoint2D(t[1]).subE(Se.constructPoint2D(t[0])),n=new st(1).subE(s),i=Se.constructPoint2D(t[2]).subE(Se.constructPoint2D(t[1])),r=e.mulE(n).addE(i.mulE(s));return r.mulThisE(new st(2)),r}}function Cr(t,e,s){const n=dr(t,1,!1);if(e<=0)return e;if(e>=n)return e-n+1;const i=[0];return 1!==Xs(new hr(t,e),U.unit(),1,i)&&h(""),i[0]}function vr(t){const e=_t(J,3);return t.queryControlPoints(e),br(e)}function br(t){return-t[1].sub(t[0]).crossProduct(t[2].sub(t[0]))/3}function Er(t){const e=J.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function Sr(t){return t.m_cachedValues}function Dr(t,e){t.m_cachedValues=e}function wr(t,e,s,n,i){l(U.unit().contains(s),"QuadraticBezierHelper::getClosestCoordinateSegment");const r=_t(J,3);t.queryControlPoints(r);let o=Number.MAX_VALUE;const a=[0],h=Ar(r,e,a);if(s.containsCoordinate(a[0]))o=J.distance(e,h);else{a[0]=s.vmin,Jr(r,a[0],h),o=J.distance(h,e);const t=new J;Jr(r,s.vmax,t);const n=J.distance(t,e);o>n&&(h.setCoordsPoint2D(t),a[0]=s.vmax,o=n)}if(!n)return a[0];if(s.vmin<=0){const n=new J;t.queryCoord2DExtended(-1,n,!0);const i=new J;t.queryCoord2D(s.vmin,i);const r=new su({start:n,end:i}),m=r.getClosestCoordinate(e,!0);if(m<1){const t=r.getCoord2D(m),s=J.distance(t,e);s<o&&(o=s,a[0]=m-1,h.assign(t))}}if(s.vmin>=1){const n=new J;t.queryCoord2DExtended(2,n,!0);const i=new J;t.queryCoord2D(s.vmax,i);const r=new su({start:i,end:n}),m=r.getClosestCoordinate(e,!0);if(m>0){const t=r.getCoord2D(m),s=J.distance(t,e);s<o&&(o=s,a[0]=1+m,h.assign(t))}}return a[0]}function Ar(t,e,s){const n=t[2].sub(t[1]).sub(t[1].sub(t[0])),i=t[1].sub(t[0]),r=t[0].sub(e),o=r.dotProduct(i),a=r.dotProduct(n)+2*i.dotProduct(i),h=3*i.dotProduct(n),m=n.dotProduct(n),u=O(3,Number.NaN),l=Fs(m,h,a,o,U.unit(),!1,u),c=t[0].clone();let g=0,d=J.sqrDistance(t[0],e),_=J.sqrDistance(t[2],e);_<d&&(g=1,c.assign(t[2]),d=_);for(let p=0;p<l;p++){const s=new J;Jr(t,u[p],s),_=J.sqrDistance(s,e),_<d&&(d=_,c.assign(s),g=u[p])}return s&&(s[0]=g),c}function Tr(t,e,s,n,i,r){const o=new ve;if(Ir(t,U.unit(),o),o.inflate(i),!o.isIntersectingPoint2D(e))return 0;const a=new J,h=wr(t,e,U.unit(),!1);t.queryCoord2D(h,a);return J.distance(a,e)<=i?(n&&(n[0]=h),1):0}function Ir(t,e,s){const n=_t(J,3);t.queryControlPoints(n),Mr(n,e,s)}function Mr(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,3);const n=_t(J,3);Vr(t,e.vmin,e.vmax,n),s.setFromPoints(n,3)}function Yr(t,e,s){s.setEmpty();const n=[];n.push(new U(0,1));const i=.5*Math.max(e.width(),e.height());for(;n.length;){const r=n.at(-1);n.pop();const o=new ve;if(Mr(t,r,o),o.isIntersectingW(e)){const t=Math.max(o.width(),o.height());if(e.containsW(o)||t<=i||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();n.push(U.construct(r.vmin,t)),n.push(U.construct(t,r.vmax))}}}}function Xr(t){const e=_t(J,3);t.queryControlPoints(e);const s=Nr(e);return s&&(t.m_cp.setCoordsPoint2D(e[1]),t.afterCompletedModification()),s}function Nr(t){let e=!1;for(let s=0;s<2;s++){const n=Et(t[0][s],t[2][s]);n>0?(Et(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[2][s])<0&&(t[1][s]=t[2][s],e=!0)):n<0?(Et(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[2][s])>0&&(t[1][s]=t[2][s],e=!0)):t[1][s]!==t[0][s]&&(t[1][s]=t[0][s],e=!0)}return e}function qr(t,s,n){void 0===n&&(n=s,s=0);const i=new J;if(s<0||n>1)return i.setNAN(),i;if(s>n&&e("calculate_sub_weighted_centroid"),s===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=cr(t),o=Ue(t),a=Math.min(o/t.calculateUpperLength2D(),1e-7);let h=s,m=0;for(let e=1,u=r.specialPointsCount();e<u;e++)if(s<r.specialPoints[e]){m=e-1;break}i.setCoords(0,0);for(let e=m+1,u=r.specialPointsCount();e<u;e++){const s=Math.min(r.specialPoints[e],n),m=mr(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}function Fr(t,e,s,n){(new J).setCoordsPoint2D(t[0]);(new J).setCoordsPoint2D(t[1]);(new J).setCoordsPoint2D(t[2]);const i=new J,r=new J,o=new J;if(St(t[0],t[1],e,i),St(t[1],t[2],e,r),St(i,r,e,o),s&&(s[0].assign(t[0]),s[1].assign(i),s[2].assign(o)),n){const e=t[2];n[0].assign(o),n[1].assign(r),n[2].assign(e)}}function Vr(t,e,s,n){if(e===s){const s=new J;return Jr(t,e,s),n[0]=s,n[1]=s,void(n[2]=s)}const i=_t(J,3);Fr(t,s,i,null),Fr(i,e/s,null,i),Jr(t,e,i[0]),Jr(t,s,i[2]),n[0].setCoordsPoint2D(i[0]),n[1].setCoordsPoint2D(i[1]),n[2].setCoordsPoint2D(i[2])}function Lr(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new ae,o=_t(J,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new J;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=_t(J,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformInPlace(t.m_cp):St(e,s,.5,t.m_cp),t.changeEndPoints2D(e,s),i&&Xr(t)}function Rr(t){return t.getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp.norm(1)}function zr(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==Gr(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function kr(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==Wr(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function Br(t,e,s,n,i){if(i){if(0!==Hm(e,s))return 2}else if(Ae(e,s))return 1;return 0!==jr(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function Gr(t,e,n,i,r,o,a,h,m,u){if(null!=r&&(r.length=0),null!==o&&(o.length=0),null!==i&&(i.length=0),n.isDegenerate(0)){const t=[0,0],s=e.intersectPoint(n.getStartXY(),t,a);if(s>0){if(null!==r)for(let e=0;e<s;e++)r.push(t[e]);if(null!==o)for(let t=0;t<s;t++)o.push(0);if(null!==i)for(let n=0;n<s;n++){const s=new J;e.queryCoord2D(t[n],s),i.push(s)}}return s}const l=Oe(e,n);if(a=Math.max(a,l),e.isDegenerateToLineHelper(l)){const t=new su({start:e.getStartXY(),end:e.getEndXY()}),s=ps(t,n,i,r,o,a,h,u);if(r)for(let n=0;n<s;++n){const s=t.getCoord2D(r[n]);r[n]=e.getClosestCoordinate(s,!1)}return s}if(Qe(e,n,a))return 0;const c=an.constructPoint2D(n.getStartXY()),g=an.constructPoint2D(n.getEndXY()).sub(c),d=g.clone();d.leftPerpendicularThis();const _=an.constructPoint2D(e.m_cp).sub(an.constructPoint2D(e.getStartXY())),p=an.constructPoint2D(e.getEndXY()).sub(an.constructPoint2D(e.m_cp));let f=_.dotProduct(d).toDouble(),P=p.sub(_).dotProduct(d).toDouble();const y=O(12,Number.NaN),x=O(12,Number.NaN);let C=Ns(P,f,U.unit(),y);C<0&&(y[0]=0,y[1]=1,C=2);let v,b=0;for(let s=0,w=b;s<C;++s){const t=e.getCoord2D(y[s+w]);x[b]=n.getClosestCoordinate(t,!1),J.distance(t,n.getCoord2D(x[b]))<=a&&(y[b]=y[s+w],b++)}const E=_t(J,3);e.queryControlPoints(E);{const t=_t(an,3);if(Qr(E,t,!1),t[0]=t[0].sub(c),g.x.abs().gte(g.y.abs())){const e=g.y.div(g.x);P=t[2].y.sub(t[2].x.mul(e)).toDouble(),f=t[1].y.sub(t[1].x.mul(e)).toDouble(),v=t[0].y.sub(t[0].x.mul(e)).toDouble()}else{const e=g.x.div(g.y);P=t[2].x.sub(t[2].y.mul(e)).toDouble(),f=t[1].x.sub(t[1].y.mul(e)).toDouble(),v=t[0].x.sub(t[0].y.mul(e)).toDouble()}}const S=e.getEndXY().equals(n.getStartXY())||e.getEndXY().equals(n.getEndXY()),D=[0,0];C=qs(P,f,v,U.unit(),S,D);for(let s=0,w=b;s<C;++s){y[s+w]=D[s];const t=e.getCoord2D(y[s+w]);x[b]=n.getClosestCoordinate(t,!1),J.distance(t,n.getCoord2D(x[b]))<=a&&(y[b]=y[s+w],b++)}s(b<y.length+4),C=e.intersectPoint(n.getStartXY(),D,a);for(let s=0;s<C;s++)y[b]=D[s],x[b++]=0;C=e.intersectPoint(n.getEndXY(),D,a);for(let s=0;s<C;s++)y[b]=D[s],x[b++]=1;C=n.intersectPoint(e.getStartXY(),D,a);for(let s=0;s<C;s++)x[b]=D[s],y[b++]=0;C=n.intersectPoint(e.getEndXY(),D,a);for(let s=0;s<C;s++)x[b]=D[s],y[b++]=0;return 0===b?0:Km(t,e,n,y,x,b,i,r,o,a,h,m,u)}function Wr(t,e,s,n,i,r,o,a,h,m){if(zh(s)){return Gr(t,e,new su({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,o,a,h,m)}const u=Oe(e,s);if(Qe(e,s,o=Math.max(o,u)))return 0;const l=[],c=[],g=_t(J,3);{e.queryControlPoints(g);const t=_t(J,3),n=new ae;s.canonicToWorldTransformation(n);const i=new ae;i.setInvert(n),i.transformPoints2D(g,3,t);const r=_t(an,3);Qr(t,r);const a=[r[0].x,r[1].x,r[2].x],h=[r[0].y,r[1].y,r[2].y],m=_t(vt,3);m[0].setDouble(s.getSemiMinorAxis()),m[0].sqrThis(),m[1].setDouble(s.getSemiMajorAxis()),m[1].sqrThis(),m[2]=m[0],m[2].mul(m[1]),m[2].negate();const u=_n(a,2,h,2,null,0,m,!0,U.unit(),U.unit(),l);if(u>0){let t=0;for(let n=0;n<u;n++){const i=new J;e.queryCoord2D(l[n],i);const r=s.getClosestCoordinate(i,!1),a=new J;s.queryCoord2D(r,a),J.distance(i,a)<=o&&(l[t]=l[n],c.push(r),t++)}l.length=t}}const d=[0,1];for(let _=0;_<2;_++){const t=0===_?s.getStartXY():s.getEndXY(),e=[0];Ar(g,t,e);const n=new J;Jr(g,e[0],n),J.distance(t,n)<=o&&(l.push(e[0]),c.push(d[_]))}for(let _=0;_<2;_++){const t=[0,2];{const e=s.getClosestCoordinate(g[t[_]],!1),n=new J;s.queryCoord2D(e,n),J.distance(g[t[_]],n)<=o&&(l.push(d[_]),c.push(e))}}return Km(t,e,s,l,c,l.length,n,i,r,o,a,h,m)}function jr(t,e,s,n,i,r,o,a,h,m){const u=_t(J,3);e.queryControlPoints(u);const l=_t(J,3);if(s.queryControlPoints(l),Je(u,l,3)<0)return jr(t,s,e,n,r,i,o,a,h,!m);const c=Oe(e,s);if(Qe(e,s,o=Math.max(o,c)))return 0;if(ao(e,s,n,i,r,o,a,h,m))return 2;const g=new U(0,1),d=new U(0,1);{const t=new ve;Mr(u,U.unit(),t);const e=new ve;Mr(l,U.unit(),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*o),e.inflate(3*o),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(Yr(u,t,g),Yr(l,t,d),g.isEmpty()||d.isEmpty())return 0;Vr(u,g.vmin,g.vmax,u),Vr(l,d.vmin,d.vmax,l)}}const _=tu(u,2,l,2,o);if(0===_)return 0;const p=[],f=[];if(-1===_){const t=_t(an,3);Qr(u,t);const e=[t[0].x,t[1].x,t[2].x],s=[t[0].y,t[1].y,t[2].y],n=_t(an,3);Qr(l,n);const i=cn(e,2,s,2,null,0,[n[0].x,n[1].x,n[2].x],2,[n[0].y,n[1].y,n[2].y],2,null,0,!0,U.unit(),U.unit(),p,f,m);if(i>0){let t=0;for(let e=0;e<i;e++){const s=new J,n=new J;Jr(l,f[e],n),Jr(u,p[e],s),J.distance(s,n)<=o&&(p[t]=p[e],f[t]=f[e],t++)}p.length=t,f.length=t}}for(let P=0;P<2;P++){const t=0===P?u:l,e=0===P?l:u;for(let s=0;s<2;s++){const n=0===s?0:2,i=[0];Ar(e,t[n],i);const r=new J;Jr(e,i[0],r),J.distance(t[n],r)<=o&&(0===P?(p.push(0===n?0:1),f.push(i[0])):(f.push(0===n?0:1),p.push(i[0])))}}if(0===p.length)return 0;if(!g.equalsRange(0,1))for(let P=0;P<p.length;++P)p[P]=nn.recalculateParentT(g.vmin,g.vmax,p[P]);if(!d.equalsRange(0,1))for(let P=0;P<f.length;++P)f[P]=nn.recalculateParentT(d.vmin,d.vmax,f[P]);return Km(t,e,s,p,f,p.length,n,i,r,o,a,h,m)}function Zr(t,e,s=!1){const n=t[1].sub(t[0]);e[1].assign(n.mul(2)),e[2].assign(t[2].sub(t[1]).sub(n)),s?e[0].setCoords(0,0):e[0].assign(t[0])}function Hr(t,e,s=!1){const n=_t(J,3);t.queryControlPoints(n),Zr(n,e,s)}function Ur(t,e,s=!1){const n=0,i=new st(t[1][n]).subE(new st(t[0][n]));e[1]=i.mul(2),e[2]=new st(t[2][n]).subE(new st(t[1][n])).subE(i),s?e[0].set(0):e[0].set(t[0][n])}function Or(t,e,s=!1){const n=1,i=new st(t[1][n]).subE(new st(t[0][n]));e[1]=i.mul(2),e[2]=new st(t[2][n]).subE(new st(t[1][n])).subE(i),s?e[0].set(0):e[0].set(t[0][n])}function Qr(t,e,s=!1){const n=an.constructPoint2D(t[1]),i=n.sub(an.constructPoint2D(t[0]));e[1]=i.mul(vt.constructInt32(2)),e[2]=an.constructPoint2D(t[2]).sub(n).sub(i),e[0]=s?new an(Zt,Zt):an.constructPoint2D(t[0])}function Jr(t,e,s,n){if(n){if(e<0){return void rs(new su({start:t[0],end:t[0].add(fr(t,0).getUnitVector())}),e,s)}if(e>1){return void rs(new su({start:t[2],end:t[2].add(fr(t,1).getUnitVector())}),e-1,s)}}if(e<=.5){const n=t[1].clone(),i=new J;xt(2,t[0],n,e,i);const r=new J;xt(2,n,t[2],e,r);const o=new J;xt(2,i,r,e,o),s.assign(o)}else{const n=t[1].clone(),i=new J;Ct(2,t[0],n,e,i);const r=new J;Ct(2,n,t[2],e,r);const o=new J;Ct(2,i,r,e,o),s.assign(o)}}function Kr(t,e,s){const n=_t(J,3);t.queryControlPoints(n),$r(n,e,s)}function $r(t,e,s){if(e.value()<=.5){const n=Se.constructPoint2D(t[1]),i=new Se;It(2,Se.constructPoint2D(t[0]),n,e,i);const r=new Se;It(2,n,Se.constructPoint2D(t[2]),e,r);const o=new Se;It(2,i,r,e,o),s.setE(o)}else{const n=Se.constructPoint2D(t[1]),i=new Se;Mt(2,Se.constructPoint2D(t[0]),n,e,i);const r=new Se;Mt(2,n,Se.constructPoint2D(t[2]),e,r);const o=new Se;Mt(2,i,r,e,o),s.setE(o)}}function to(t,e,s){const n=_t(J,4);t.queryControlPoints(n),eo(n,e,s)}function eo(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(xr(t,1,e))}function so(t,e){let s=1;t[1].isEqualPoint2D(t[0])&&(s=2,t[2].isEqualPoint2D(t[0])&&(s=3));let n=2;t[2].isEqualPoint2D(t[3])&&(n=1,t[1].isEqualPoint2D(t[3])&&(n=0)),e[0].assign(t[0]),e[2].assign(t[3]);const i=J.intersectLinesAtOnePoint(t[0],t[s],t[n],t[3]),r=new J;St(t[0],t[3],.5,r);const o=new J;jo(t,.5,o);const a=new J;e[1].assign(i),Jr(e,.5,a);const h=new J;e[1].assign(r),Jr(e,.5,h);const m=J.sqrDistance(o,a),u=J.sqrDistance(o,h);return m<u?(e[1].setCoordsPoint2D(i),Math.sqrt(m)):(e[1].setCoordsPoint2D(r),Math.sqrt(u))}function no(t,e,s){s[0].assign(t[0]),s[1].assign(t[1]),s[2].assign(t[2]);const n=new J;Ki(t,e,.5,n);const i=new J;Jr(s,.5,i);const r=J.sqrDistance(n,i);return Math.sqrt(r)}function io(t,e){e[0].assign(t[0]),e[3].assign(t[2]),St(t[0],t[1],2/3,e[1]),St(t[1],t[2],1/3,e[2])}function ro(t,e){const s=_t(J,3);t.queryControlPoints(s);const n=J.sqrDistance(s[1],s[0]),i=J.sqrDistance(s[1],s[2]);let r=s[0].clone(),o=n;n>i&&(r=s[2].clone(),o=i);let a=!1;return o<=e&&0!==o&&(a=!0,t.setControlPoint1(r)),a}function oo(t,e){if(!e)return!1;const s=_t(J,3);t.queryControlPoints(s);const n=J.sqrDistance(s[1],s[0]),i=J.sqrDistance(s[1],s[2]);s[0].clone();let r=n;return n>i&&(s[2].clone(),r=i),r<=e&&0!==r}function ao(t,e,s,n,i,r,o,a,h){const m=_t(J,3);t.queryControlPoints(m);const u=_t(J,3);if(e.queryControlPoints(u),m[0].equals(u[0])){if(m[1].equals(u[1])&&m[2].equals(u[2]))return s&&(s.length=0,s.push(m[0]),s.push(m[2])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(u[2]))return!1}return!!(m[0].equals(u[2])&&m[1].equals(u[1])&&m[2].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),h&&(n[1]=tt(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=tt(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[2]),h&&(s[1]=tt(s[0],s[0]=s[1]))),!0)}var ho=I;class mo extends ns{constructor(t){t&&t.cp?(super({start:t.cp[0],end:t.cp[3],vd:t.vd}),this.m_cp=_t(J,2),this.m_cp[0].assign(t.cp[1]),this.m_cp[1].assign(t.cp[2])):void 0===t||dt(t,"vd")?(super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_cp=_t(J,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)):t.from?(super({start:t.from,end:t.to,vd:t.vd}),this.m_cp=_t(J,2),this.m_cp[0].assign(t.cp1),this.m_cp[1].assign(t.cp2)):(super({XStart:0,YStart:0,XEnd:0,YEnd:0,vd:t.vd}),h("unrecognized constructor params"),this.m_cp=_t(J,2),this.m_cp[0].setCoords(0,0),this.m_cp[1].setCoords(0,0)),this.m_cachedValues=0}getBoundary(){return Va(this)}construct(t,e,s,n){this.m_XStart=t.x,this.m_YStart=t.y,this.m_XEnd=n.x,this.m_YEnd=n.y,this.m_cp[0].assign(e),this.m_cp[1].assign(s),this.afterCompletedModification()}constructPoints(t){this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.m_cp[0].assign(t[1]),this.m_cp[1].assign(t[2]),this.afterCompletedModification()}constructFromQuadratic(t){const e=_t(J,4);io(t,e),this.constructPoints(e)}constructFromQuadraticSegment(t){this.dropAllAttributes(),this.assignVertexDescription(t.getDescription()),this.m_XStart=t.getStartX(),this.m_YStart=t.getStartY(),this.m_XEnd=t.getEndX(),this.m_YEnd=t.getEndY(),At(2,t.getStartXY(),t.getControlPoint1(),2/3,this.m_cp[0]),At(2,t.getControlPoint1(),t.getEndXY(),1/3,this.m_cp[1]),this.afterCompletedModification(),Ze(this,t)}getGeometryType(){return i.enumBezier}queryEnvelope(t){if(2!==t.m_EnvelopeType)return void s(0);if(t.setCoords(this.getStartXY()),t.mergeNe(this.getEndXY()),t.contains(this.m_cp[0])&&t.contains(this.m_cp[1]))return;const e=So(this);if(null!==e){const s=new J;for(const n of e.specialPoints)this.queryCoord2D(n,s),t.mergeNe(s);return}const n=_t(st,8),i=_t(J,4);this.queryControlPoints(i);const r=Pa(i,n),o=new J;for(let s=1;s<r-1;s++)this.queryCoord2D(n[s].value(),o),t.mergeNe(o)}applyTransformation(t){if(1===t.m_TransformationType){const e=_t(J,4);return this.queryControlPoints(e),t.transformPoints2D(e,4,e),this.setStartXY(e[0]),this.m_cp[0].assign(e[1]),this.m_cp[1].assign(e[2]),this.setEndXY(e[3]),void wo(this)}s(0)}createInstance(){return new mo({vd:this.m_description})}calculateLength2D(){return Co(this,1,!1)}calculateLowerLength2D(){return J.distance(this.getStartXY(),this.getEndXY())}calculateUpperLength2D(){return J.distance(this.getStartXY(),this.m_cp[0])+J.distance(this.m_cp[0],this.m_cp[1])+J.distance(this.getEndXY(),this.m_cp[1])}queryCoord2D(t,e){return this.queryCoord2DExtends(t,e,!0)}queryCoord2DExtends(t,e,s){const n=_t(J,4);this.queryControlPoints(n),jo(n,t,e,s)}queryCoord2DE(t,e){Ho(this,t,e)}getCoordX(t){if(t<0||t>1){const e=new J;return this.queryCoord2DExtends(t,e,!0),e.x}const e=ot(this.getStartX(),this.m_cp[0].x,t),s=ot(this.m_cp[0].x,this.m_cp[1].x,t),n=ot(this.m_cp[1].x,this.getEndX(),t),i=ot(e,s,t),r=ot(s,n,t);return ot(i,r,t)}getCoordY(t){if(t<0||t>1){const e=new J;return this.queryCoord2DExtends(t,e,!0),e.y}const e=ot(this.getStartY(),this.m_cp[0].y,t),s=ot(this.m_cp[0].y,this.m_cp[1].y,t),n=ot(this.m_cp[1].y,this.getEndY(),t),i=ot(e,s,t),r=ot(s,n,t);return ot(i,r,t)}cut(t,e,s){const n=new nu;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createCubicBezier();if(this.cutBezierIgnoreAttributes(t,e,i),n)return;i.assignVertexDescription(this.m_description);const r=this.m_description.getAttributeCount();if(r>1){for(let e=1;e<r;e++){const s=this.m_description.getSemantics(e),n=ho.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<r;t++){const s=this.m_description.getSemantics(t),n=ho.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}}queryDerivative(t,e){Oo(this,t,e)}cutBezierIgnoreAttributes(t,s,n){(t<0||s>1||t>s)&&e("Cubic_bezier.cut_bezier_ignore_attributes");const i=_t(J,4);this.queryControlPoints(i);const r=_t(J,4);Wo(i,t,s,r),n.setControlPoints(r)}splitBezierIgnoreAttributes(t,s,n){this===s&&this===n&&e("Cubic_bezier.split_bezier_ignore_attributes");const i=_t(J,4);this.queryControlPoints(i);const r=_t(J,4),o=_t(J,4);Go(i,t,r,o),s&&s.setControlPoints(r),n&&n.setControlPoints(o)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.getStartAttributeAsDbl(e,s),i=this.getEndAttributeAsDbl(e,s),r=this.calculateLength2D(),o=r>0?this.tToLength(t)/r:0,a=ho.getInterpolation(e);return Pt(a,n,i,o,ho.getDefaultValue(e))}getClosestCoordinate(t,e){const s=[Number.NaN];return ca(this,t,U.unit(),e,-1,1,s),s[0]}getClosestCoordinateOnInterval(t,e,s=-1){const n=[Number.NaN];return 0===ca(this,t,e,!1,s,1,n)?Number.NaN:n[0]}getYMonotonicParts(t,e=!1){return this.getMonotonicParts(t,e)}getMonotonicParts(t,n){t.length<2&&e("");const i=Eo(this);if(2===i.specialPointsCount()&&this.isMonotoneQuickAndDirty())return 0;let r=0;s(t.length>=i.specialPointsCount()-1);for(let e=1,s=i.specialPointsCount();e<s;++e)this.queryCut(i.specialPoints[e-1],i.specialPoints[e],t[r],n),r++;for(let e=0;e<r;++e){Ro(t[e].get())}return r}intersectionWithAxis2D(t,e,s,n){const i=_t(J,4);return this.queryControlPoints(i),ya(i,t,e,s,n)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const n=[0,0],i=this.intersectionWithAxis2D(!0,t,n,null);return s(2!==i),-1===i?e:n[0]}isCurve(){return!0}isDegenerate(t){return Te(this,t)}isDegenerate3D(t,e){return s(0),!1}queryLooseEnvelope(t){if(2===t.m_EnvelopeType)return t.setCoords({pt:this.getStartXY()}),t.mergeNe(this.m_cp[0]),t.mergeNe(this.m_cp[1]),void t.mergeNe(this.getEndXY());s(0)}clone(t){const e=this.createInstance();return this.copyTo(e),e}queryInterval(t,e){if(0===t){const t=oe.constructEmpty();this.queryEnvelope(t);const s=U.constructEmpty();return 0===e?t.queryIntervalX(s):t.queryIntervalY(s),s}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=_t(J,4);this.queryControlPoints(s),Wo(s,t.vmin,t.vmax,s),e.setFromPoints(s,4)}changeEndPoints2D(t,e){if(t.isEqual(this.m_XStart,this.m_YStart)&&e.isEqual(this.m_XEnd,this.m_YEnd))return;const s=this.m_cp[0].isEqual(this.m_XStart,this.m_YStart),n=this.m_cp[0].isEqual(this.m_XEnd,this.m_YEnd),i=this.m_cp[1].isEqual(this.m_XStart,this.m_YStart),r=this.m_cp[1].isEqual(this.m_XEnd,this.m_YEnd);this.setStartXY(t),this.setEndXY(e),s?this.m_cp[0].setCoordsPoint2D(t):n&&this.m_cp[0].setCoordsPoint2D(e),r?this.m_cp[1].setCoordsPoint2D(e):i&&this.m_cp[1].setCoordsPoint2D(t),this.normalizeAfterEndpointChange()}tToLength(t){return Co(this,t,!0)}lengthToT(t){return vo(this,t)}calculateWeightedAreaCentroid2D(t){const e=_t(J,4);_o(this,e);const s=e[3],n=e[2],i=e[1],r=new J;r.x=(5*s.x*s.x*(7*n.y+16*i.y)+s.x*(-35*s.y*n.x+40*n.x*n.y-80*s.y*i.x+140*n.x*i.y+112*i.x*i.y)-2*(s.y*(20*n.x*n.x+70*n.x*i.x+56*i.x*i.x)-7*(4*n.x+5*i.x)*(-n.y*i.x+n.x*i.y)))/840,r.y=(-5*s.y*s.y*(7*n.x+16*i.x)+s.y*(5*s.x*(7*n.y+16*i.y)-4*(10*n.x*n.y+35*n.y*i.x+28*i.x*i.y))+2*(-7*(4*n.y+5*i.y)*(n.y*i.x-n.x*i.y)+s.x*(20*n.y*n.y+70*n.y*i.y+56*i.y*i.y)))/840;const o=Lo(this);return r.x+=(e[0].x-t.x)*o,r.y+=(e[0].y-t.y)*o,r}calculateWeightedCentroid2D(){const t=new J;return this.isDegenerate(0)?(t.setCoords(0,0),t):go(this)?(t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t):(t.assign(bo(this,1)),t)}getControlPoint1(){return this.m_cp[0].clone()}setControlPoint1(t){this.m_cp[0].setCoordsPoint2D(t),this.afterCompletedModification()}getControlPoint2(){return this.m_cp[1].clone()}setControlPoint2(t){this.m_cp[1].setCoordsPoint2D(t),this.afterCompletedModification()}queryControlPoints(t){t[0].assign(this.getStartXY()),t[1].assign(this.m_cp[0]),t[2].assign(this.m_cp[1]),t[3].assign(this.getEndXY())}setControlPoints(t){for(let s=0;s<4;s++)t[s].isNAN()&&e("NAN control points in bezier are not supported");this.m_XStart=t[0].x,this.m_YStart=t[0].y,this.m_cp[0].setCoordsPoint2D(t[1]),this.m_cp[1].setCoordsPoint2D(t[2]),this.m_XEnd=t[3].x,this.m_YEnd=t[3].y,this.afterCompletedModification()}getTangent(t){const e=_t(J,4);return this.queryControlPoints(e),Uo(e,t)}getDerivative(t){const e=_t(J,4);return this.queryControlPoints(e),qo(e,1,t)}getCurvature(t){const e=Vo(this,1,t),s=Vo(this,2,t),n=e.sqrLength();if(0===n)return Number.NaN;e.divThis(Math.sqrt(n));return e.crossProduct(s)/n}isIntersectingPoint(t,e,s){if(s&&(t.equals(this.getStartXY())||t.equals(this.getEndXY())))return!1;const n=new oe;if(this.queryLooseEnvelope(n),n.inflateCoords(e,e),!n.contains(t))return!1;const i=this.getClosestCoordinate(t,!1),r=new J;this.queryCoord2D(i,r);return J.distance(r,t)<=e}isIntersectingPoint3D(t,e,n,i,r=1){return s(0),!1}isMonotoneQuickAndDirty(){const t=_t(J,4);return this.queryControlPoints(t),ko(t)}getMonotonicPartParams(t,n){const i=Eo(this),r=i.specialPointsCount();if(s($e.s_maxMonotonicPartParams>=r),!n)return i.specialPointsCount();t<r&&e("");for(let e=0;e<r;e++)n[e]=i.specialPoints[e];return r}normalizeAfterEndpointChange(){return!1}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=tt(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=tt(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=tt(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_cp[1]=tt(this.m_cp[0],this.m_cp[0]=this.m_cp[1]),this.m_cachedValues=null}}findMinDeriv(){const t=new st;return Yo(this,t),t.value()}isLine(){return!1}isDegenerateToLineHelper(t){const e=this.getEndXY().sub(this.getStartXY()),s=e.length(),n=.1*t;let i=this.getControlPoint1();i.subThis(this.getStartXY());let r=Math.abs(i.crossProduct(e))/s;return!(r>n)&&(i=this.getControlPoint2(),i.subThis(this.getStartXY()),r=Math.abs(i.crossProduct(e))/s,!(r>n))}copyIgnoreAttributes(t){const e=_t(J,4);this.queryControlPoints(e),t.setControlPoints(e)}calculateArea2DHelper(){return Lo(this)}absNorm(){return ga(this)}queryEnvelopeW(t,e){ha(this,t,e)}setSegmentFromCoords(t,e){_a(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(4);return this.writeInBuffer_(s),t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}writeInBuffer_(t){return t[0]=this.m_cp[0].x,t[1]=this.m_cp[0].y,t[2]=this.m_cp[1].x,t[3]=this.m_cp[1].y,4}readFromBufferStream(t,e){const s=new Float64Array(4);t.queryRange(e,s.length,s,!0,1),this.readFromBuffer_(s)}readFromBuffer_(t){this.m_cp=_t(J,2),this.m_cp[0].x=t[0],this.m_cp[0].y=t[1],this.m_cp[1].x=t[2],this.m_cp[1].y=t[3],this.m_cachedValues=null}snapControlPoints(t){const e=_t(J,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;if(J.sqrDistance(e,n)<=t){i=!e.equals(n),e.setCoordsPoint2D(n);J.sqrDistance(s,n)<=t&&(i||=!s.equals(n),s.setCoordsPoint2D(n))}return i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return(n||i)&&this.setControlPoints(e),n||i}needsSnapControlPoints(t){if(!t)return!1;const e=_t(J,4);this.queryControlPoints(e);const s=(e,s,n)=>{let i=!1;if(J.sqrDistance(e,n)<=t){i=!e.equals(n),e.setCoordsPoint2D(n);J.sqrDistance(s,n)<=t&&(i||=!s.equals(n),s.setCoordsPoint2D(n))}return i},n=s(e[1],e[2],e[0]),i=s(e[2],e[1],e[3]);return n||i}calculateSpecialPointsForCracking(t,e){return Ca(this,t,e)}ensureXYMonotone(){return Ro(this)}setCoordsForIntersector(t,e,s){To(this,t,e,s)}copyToImpl(t){const e=t;e.m_cp[0].assign(this.m_cp[0]),e.m_cp[1].assign(this.m_cp[1]),Do(e,So(this))}reverseImpl(){this.m_cp[1]=tt(this.m_cp[0],this.m_cp[0]=this.m_cp[1])}equalsImpl(t){const e=t,s=0,n=1;return!!this.m_cp[0].equals(e.m_cp[s])&&!!this.m_cp[1].equals(e.m_cp[n])}equalsImplTol(t,e){const s=t,n=0,i=1;return!!this.m_cp[0].isEqualPoint2D(s.m_cp[n],e)&&!!this.m_cp[1].isEqualPoint2D(s.m_cp[i],e)}swapImpl(t){const e=t;e.m_cp[0]=tt(this.m_cp[0],this.m_cp[0]=e.m_cp[0]),e.m_cp[1]=tt(this.m_cp[1],this.m_cp[1]=e.m_cp[1]),Ao(this,e)}afterCompletedModification(){wo(this)}isIntersecting(t,e,s){return 0!==jm(!1,this,t,e,s)}intersect(t,e,s,n,i){return Om(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){return aa(this,t,e,s)}endPointModified(){wo(this)}clearEndPointModified(){}}mo.type=i.enumBezier;class uo{constructor(){this.length=Number.NaN,this.specialPoints=[]}specialPointsCount(){return this.specialPoints.length}}function lo(t){return co(t.calculateUpperLength2D())}function co(t){return 256*ut()*t}function go(t){const e=J.distance(t.getStartXY(),t.getEndXY()),s=t.calculateUpperLength2D();return s-e<=8*Number.EPSILON*s}function _o(t,e,s=!1){e[1].setCoords(t.m_cp[0].x-t.getStartX(),t.m_cp[0].y-t.getStartY()),e[1].mulThis(3),e[2].setCoords(t.m_cp[1].x-t.m_cp[0].x,t.m_cp[1].y-t.m_cp[0].y),e[2].mulThis(3),e[3]=t.getEndXY().sub(t.getStartXY()),e[3].subThis(e[2]),e[2].subThis(e[1]),s?e[0].setCoords(0,0):e[0]=t.getStartXY()}function po(t,e,s){const n=_t(J,4);t.queryControlPoints(n),Po(n,e,s)}function fo(t,e,s){const n=_t(J,4);t.queryControlPoints(n),yo(n,e,s)}function Po(t,e,s){let n=t[1].x;n-=t[0].x,n*=3;let i=t[2].x;i-=t[1].x,i*=3;let r=t[3].x;r-=t[0].x,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].x)}function yo(t,e,s){let n=t[1].y;n-=t[0].y,n*=3;let i=t[2].y;i-=t[1].y,i*=3;let r=t[3].y;r-=t[0].y,r-=i,i-=n,e[3].setWithEps(r),e[2].setWithEps(i),e[1].setWithEps(n),s?e[0].set(0):e[0].set(t[0].y)}function xo(t,e,s=!1){const n=_t(an,4);n[0].assignPoint2D(t[0]),n[1].assignPoint2D(t[1]),n[2].assignPoint2D(t[2]),n[3].assignPoint2D(t[3]),e[1].setCoords(n[1].x.sub(n[0].x),n[1].y.sub(n[0].y)),e[1].mulThis(vt.constructInt32(3)),e[2].setCoords(n[2].x.sub(n[1].x),n[2].y.sub(n[1].y)),e[2].mulThis(vt.constructInt32(3)),e[3]=n[3].sub(n[0]),e[3]=e[3].sub(e[2]),e[2]=e[2].sub(e[1]),s?e[0].setCoords(Zt,Zt):e[0]=n[0].clone()}function Co(t,e,s){if(s){if(e<0)return e;if(e>1)return e-1+Co(t,1,!1)}if(t.isDegenerate(0))return 0;const n=1===e,i=Eo(t);if(n&&!Number.isNaN(i.length)&&!Number.isNaN(i.length))return i.length;const r=lo(t),o=r/t.calculateUpperLength2D();let a=0,h=0;for(let m=1,u=i.specialPointsCount();m<u;m++){const s=i.specialPoints[m];if(a+=Ea(t,h,Math.min(e,s),o,r),e<=s)break;h=s}return n&&(i.length=a),a}function vo(t,e,s){const n=Co(t,1,!1);if(e<=0)return e;if(e>=n)return e-n+1;const i=[0];return 1!==Xs(new va(t,e),U.unit(),1,i)&&h(""),i[0]}function bo(t,s,n){void 0===n&&(n=s,s=0);const i=new J;if(s<0||n>1)return i.setNAN(),i;if(s>n&&e("calculate_sub_weightedCentroid"),s===n||t.isDegenerate(0))return i.setCoords(0,0),i;const r=Eo(t),o=lo(t),a=o/t.calculateUpperLength2D();let h=s,m=0;for(let e=1,u=r.specialPointsCount();e<u;e++)if(s<r.specialPoints[e]){m=e-1;break}i.setCoords(0,0);for(let e=m+1,u=r.specialPointsCount();e<u;e++){const s=Math.min(r.specialPoints[e],n),m=Sa(t,h,s,a,o);if(i.addThis(m),h=s,n<=r.specialPoints[e])break}return i.add(t.getStartXY().mul(t.calculateLength2D()))}function Eo(t){if(t.m_cachedValues)return t.m_cachedValues;const e=new uo,s=_t(st,8),n=_t(J,4);t.queryControlPoints(n);const i=Pa(n,s);e.specialPoints=[];for(let r=0;r<i;r++)e.specialPoints.push(s[r].value());return Do(t,e),e}function So(t){let e=null;return e=t.m_cachedValues,e}function Do(t,e){t.m_cachedValues=e}function wo(t){t.m_cachedValues=null}function Ao(t,e){e.m_cachedValues=tt(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}function To(t,e,s,n){if(e.isEqual(t.m_XStart,t.m_YStart)&&s.isEqual(t.m_XEnd,t.m_YEnd))return;const i=!!n&&t.isMonotoneQuickAndDirty(),r=new ae,o=_t(J,3);o[0].setCoords(t.m_XStart,t.m_YStart),o[2].setCoords(t.m_XEnd,t.m_YEnd);const a=new J;a.setSub(o[2],o[0]),a.leftPerpendicularThis(),o[1].setAdd(o[0],a);const h=_t(J,3);h[0].setCoordsPoint2D(e),h[2].setCoordsPoint2D(s),a.setSub(h[2],h[0]),a.leftPerpendicularThis(),h[1].setAdd(h[0],a),r.setFromTwoTriangles(o,h)?r.transformPoints2D(t.m_cp,2,t.m_cp):(St(e,s,1/3,t.m_cp[0]),St(e,s,2/3,t.m_cp[1])),t.changeEndPoints2D(e,s),i&&Ro(t)}function Io(t,e,s,n,i){return{tmin:t,tmax:e,t:s,d:n,pt:i.clone()}}function Mo(t,e,s,n){const i=O(18,Number.NaN),r=_t(J,4);t.queryControlPoints(r);const o=Xs(new ua(r,e),U.construct(s,n),18,i),a=new J;t.queryCoord2D(s,a);let h=s,m=J.distance(a,e);const u=new J;t.queryCoord2D(n,u);const l=J.distance(u,e);l<m&&(m=l,h=n,a.assign(u));for(let c=0;c<o;c++){t.queryCoord2D(i[c],u);const s=J.distance(u,e);s<m&&(m=s,h=i[c],a.assign(u))}return Io(s,n,h,m,a)}function Yo(t,e){const n=_t(st,4);po(t,n,!0);const i=_t(st,4);fo(t,i,!0);const r=n[3].clone(),o=n[2].clone(),a=n[1].clone(),h=i[3].clone(),m=i[2].clone(),u=i[1].clone(),l=o.mulE(a).addE(m.mulE(u)).mul(4),c=o.mulE(o).mul(8).addE(r.mulE(a).mul(12)).addE(m.mulE(m).mul(8).addE(h.mulE(u).mul(12))),g=r.mulE(o).addE(h.mulE(m)).mul(36),d=r.mulE(r).addE(h.mulE(h)).mul(36),_=_t(st,3),p=Zs(d,g,c,l,new U(0,1),!1,_);if(s(p<=3),p>0){const s=Vo(t,1,0).sqrLength(),n=Vo(t,1,1).sqrLength();let i=s;e.set(0),i<n&&(i=n,e.set(1));for(let r=0;r<p;r++){const s=Vo(t,1,_[r].value()).sqrLength();s<i&&(i=s,e=_[r])}}}function Xo(t,e,s,n){if(1===e){const e=1-s,i=e*e,r=s*s,o=t[1].sub(t[0]),a=t[2].sub(t[1]),h=t[3].sub(t[2]),m=o.mul(i).add(a.mul(2*e*s)).add(h.mul(r));n.assign(m.mul(3))}else if(2===e){const e=1-s,i=t[2].sub(t[1]).sub(t[1].sub(t[0])),r=t[3].sub(t[2]).sub(t[2].sub(t[1])),o=i.mul(e).add(r.mul(s));n.assign(o.mul(6))}else if(3===e){const e=t[2].sub(t[1]),s=t[3].sub(e.mul(3)).sub(t[0]);n.assign(s.mul(6))}else n.setCoords(0,0)}function No(t,e,s,n){{const e=nt.subE(s),i=e.sqr(),r=s.sqr(),o=t[1].subE(t[0]).mulE(i).addE(t[2].subE(t[1]).mulE(new st(2).mulE(e).mulE(s))).addE(t[3].subE(t[2]).mulE(r));n.setE(o.mulE(new st(3)))}}function qo(t,e,s){const n=new J;return Xo(t,e,s,n),n}function Fo(t,e,s){const n=[Se.constructPoint2D(t[0]),Se.constructPoint2D(t[1]),Se.constructPoint2D(t[2]),Se.constructPoint2D(t[3])],i=new Se;return No(n,e,s,i),i}function Vo(t,e,s){const n=_t(J,4);return t.queryControlPoints(n),qo(n,e,s)}function Lo(t){const e=t.m_cp[0].sub(t.getStartXY()),s=t.m_cp[1].sub(t.m_cp[0]),n=t.getEndXY().sub(t.getStartXY());e.mulThis(3),s.mulThis(3),n.subThis(s),s.subThis(e);return(3*n.x*(2*s.y+5*e.y)-3*n.y*(2*s.x+5*e.x)+10*(s.x*e.y-s.y*e.x))/60}function Ro(t){const e=_t(J,4);t.queryControlPoints(e);const s=zo(e);return s&&(t.m_cp[0].setCoordsPoint2D(e[1]),t.m_cp[1].setCoordsPoint2D(e[2]),t.afterCompletedModification()),s}function zo(t){let e=!1;for(let s=0;s<2;s++){const n=Et(t[0][s],t[3][s]);n>0?(Et(t[0][s],t[1][s])<0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[3][s])<0&&(t[1][s]=t[3][s],e=!0),Et(t[0][s],t[2][s])<0&&(t[2][s]=t[0][s],e=!0),Et(t[2][s],t[3][s])<0&&(t[2][s]=t[3][s],e=!0),Et(t[1][s],t[2][s])<0&&(t[2][s]=t[1][s],e=!0)):n<0?(Et(t[0][s],t[1][s])>0&&(t[1][s]=t[0][s],e=!0),Et(t[1][s],t[3][s])>0&&(t[1][s]=t[3][s],e=!0),Et(t[0][s],t[2][s])>0&&(t[2][s]=t[0][s],e=!0),Et(t[2][s],t[3][s])>0&&(t[2][s]=t[3][s],e=!0),Et(t[1][s],t[2][s])>0&&(t[2][s]=t[1][s],e=!0)):t[1][s]===t[0][s]&&t[2][s]===t[0][s]||(t[1][s]=t[0][s],t[2][s]=t[0][s],e=!0)}return e}function ko(t){const e=Et(t[0].y,t[1].y),s=Et(t[1].y,t[2].y),n=Et(t[2].y,t[3].y);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0){const e=Et(t[0].x,t[1].x),s=Et(t[1].x,t[2].x),n=Et(t[2].x,t[3].x);if(e>=0&&s>=0&&n>=0||e<=0&&s<=0&&n<=0)return!0}return!1}function Bo(t,e,s){const n=new J,i=new J,r=new J,o=new J,a=new J;e<=.5?(xt(2,t[0],t[1],e,n),xt(2,t[1],t[2],e,i),xt(2,t[2],t[3],e,r),xt(2,n,i,e,o),xt(2,i,r,e,a),xt(2,o,a,e,s)):(Ct(2,t[0],t[1],e,n),Ct(2,t[1],t[2],e,i),Ct(2,t[2],t[3],e,r),Ct(2,n,i,e,o),Ct(2,i,r,e,a),Ct(2,o,a,e,s))}function Go(t,e,n,i){s(e>=0&&e<=1);const r=new J,o=new J,a=new J,h=new J,m=new J,u=new J;e<=.5?(xt(2,t[0],t[1],e,r),xt(2,t[1],t[2],e,o),xt(2,t[2],t[3],e,a),xt(2,r,o,e,h),xt(2,o,a,e,m),xt(2,h,m,e,u)):(Ct(2,t[0],t[1],e,r),Ct(2,t[1],t[2],e,o),Ct(2,t[2],t[3],e,a),Ct(2,r,o,e,h),Ct(2,o,a,e,m),Ct(2,h,m,e,u));const l=t[3].clone();n&&(n[0].assign(t[0]),n[1].assign(r),n[2].assign(h),n[3].assign(u)),i&&(i[0].assign(u),i[1].assign(m),i[2].assign(a),i[3].assign(l))}function Wo(t,e,n,i){if(s(e>=0&&n<=1&&e<=n),e===n){const s=new J;return jo(t,e,s),i[0].assign(s),i[1].assign(s),i[2].assign(s),void i[3].assign(s)}if(0===e&&1===n){for(let e=0;e<4;++e)i[e].assign(t[e]);return}const r=_t(J,4);Go(t,n,r,null),Go(r,n>0?e/n:0,null,r),jo(t,e,r[0]),jo(t,n,r[3]),i[0].setCoordsPoint2D(r[0]),i[1].setCoordsPoint2D(r[1]),i[2].setCoordsPoint2D(r[2]),i[3].setCoordsPoint2D(r[3])}function jo(t,e,s,n){if(n){if(e<0){return void rs(new su({start:t[0],end:t[0].add(Uo(t,0).getUnitVector())}),e,s)}if(e>1){return void rs(new su({start:t[3],end:t[3].add(Uo(t,1).getUnitVector())}),e-1,s)}}if(e<=.5){const n=new J;xt(2,t[0],t[1],e,n);const i=new J;xt(2,t[1],t[2],e,i);const r=new J;xt(2,t[2],t[3],e,r);const o=new J;xt(2,n,i,e,o);const a=new J;xt(2,i,r,e,a),xt(2,o,a,e,s)}else{const n=new J;Ct(2,t[0],t[1],e,n);const i=new J;Ct(2,t[1],t[2],e,i);const r=new J;Ct(2,t[2],t[3],e,r);const o=new J;Ct(2,n,i,e,o);const a=new J;Ct(2,i,r,e,a),Ct(2,o,a,e,s)}}function Zo(t,e,s){if(e.value()<=.5){const n=new Se;It(2,Se.constructPoint2D(t[0]),Se.constructPoint2D(t[1]),e,n);const i=new Se;It(2,Se.constructPoint2D(t[1]),Se.constructPoint2D(t[2]),e,i);const r=new Se;It(2,Se.constructPoint2D(t[2]),Se.constructPoint2D(t[3]),e,r);const o=new Se;It(2,n,i,e,o);const a=new Se;It(2,i,r,e,a),It(2,o,a,e,s)}else{const n=new Se;Mt(2,Se.constructPoint2D(t[0]),Se.constructPoint2D(t[1]),e,n);const i=new Se;Mt(2,Se.constructPoint2D(t[1]),Se.constructPoint2D(t[2]),e,i);const r=new Se;Mt(2,Se.constructPoint2D(t[2]),Se.constructPoint2D(t[3]),e,r);const o=new Se;Mt(2,n,i,e,o);const a=new Se;Mt(2,i,r,e,a),Mt(2,o,a,e,s)}}function Ho(t,e,s){const n=_t(J,4);t.queryControlPoints(n),Zo(n,e,s)}function Uo(t,e){const s=lt(e,0,1);let n=qo(t,1,s);return n.isZero()&&(n=qo(t,2,s),n.isZero()?n=qo(t,3,s):1===s&&n.negateThis()),n}function Oo(t,e,s){const n=_t(J,4);t.queryControlPoints(n),Qo(n,e,s)}function Qo(t,e,s){e.value()<0&&e.set(0,e.eps()),e.value()>1&&e.set(1,e.eps()),s.setE(Fo(t,1,e))}function Jo(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==sa(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function Ko(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==na(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function $o(t,e,s,n,i){if(i){if(0!==Hm(e,s))return 2}else if(Ae(e,s))return 1;return 0!==ia(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function ta(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==ra(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function ea(t,e,s,n,i){if(i){if(0!==Hm(e,s))return t?4:2}else if(Ae(e,s))return 1;return 0!==oa(t,e,s,null,null,null,n,i??!1,!0,!1)?4:0}function sa(t,e,s,n,i,r,o,a,h,m){if(null!==i&&(i.length=0),null!=r&&(r.length=0),null!==n&&(n.length=0),s.isDegenerate(0)){const t=[0,0,0],a=e.intersectPoint(s.getStartXY(),t,o);if(a>0){if(null!==i)for(let e=0;e<a;e++)i.push(t[e]);if(null!==r)for(let t=0;t<a;t++)r.push(0);if(null!=n)for(let s=0;s<a;s++){const i=new J;e.queryCoord2D(t[s],i),n.push(i)}}return a}const u=Oe(e,s);if(Qe(e,s,o=Math.max(o,u)))return 0;const l=_t(J,4);_o(e,l);const c=s.getEndXY();c.subThis(s.getStartXY());const g=c.clone();g.leftPerpendicularThis();let d=3*l[3].dotProduct(g),_=2*l[2].dotProduct(g),p=l[1].dotProduct(g);const f=O(15,Number.NaN),P=O(15,Number.NaN);let y=qs(d,_,p,U.unit(),!1,f);y<0&&(f[0]=0,f[1]=1,y=2);let x,C=0;for(let E=0,S=C;E<y;++E){const t=e.getCoord2D(f[E+S]);P[C]=s.getClosestCoordinate(t,!1),J.distance(t,s.getCoord2D(P[C]))<=o&&(f[C]=f[E+S],C++)}if(l[0].subThis(s.getStartXY()),Math.abs(c.x)>=Math.abs(c.y)){const t=c.y/c.x;d=l[3].y-l[3].x*t,_=l[2].y-l[2].x*t,p=l[1].y-l[1].x*t,x=l[0].y-l[0].x*t}else{const t=c.x/c.y;d=l[3].x-l[3].y*t,_=l[2].x-l[2].y*t,p=l[1].x-l[1].y*t,x=l[0].x-l[0].y*t}const v=e.getEndXY().equals(s.getStartXY())||e.getEndXY().equals(s.getEndXY()),b=[0,0,0];y=Fs(d,_,p,x,U.unit(),v,b);for(let E=0,S=C;E<y;++E){f[E+S]=b[E];const t=e.getCoord2D(f[E+S]);P[C]=s.getClosestCoordinate(t,!1);J.distance(t,s.getCoord2D(P[C]))<=o&&(f[C]=f[E+S],C++)}y=e.intersectPoint(s.getStartXY(),b,o);for(let E=0;E<y;E++)f[C]=b[E],P[C++]=0;y=e.intersectPoint(s.getEndXY(),b,o);for(let E=0;E<y;E++)f[C]=b[E],P[C++]=1;return 0!==s.intersectPoint(e.getStartXY(),b,o)&&(P[C]=b[0],f[C++]=0),0!==s.intersectPoint(e.getEndXY(),b,o)&&(P[C]=b[0],f[C++]=1),0===C?0:Km(t,e,s,f,P,C,n,i,r,o,a,h,m)}function na(t,e,s,n,i,r,o,a,h,m){if(zh(s)){return sa(t,e,new su({start:s.getStartXY(),end:s.getEndXY()}),n,i,r,o,a,h,m)}const u=Oe(e,s);if(Qe(e,s,o=Math.max(o,u)))return 0;const l=[],c=[],g=[],d=_t(J,4);{e.queryControlPoints(d);const t=_t(J,4),n=new ae;s.canonicToWorldTransformation(n);const i=new ae;i.setInvert(n),i.transformPoints2D(d,4,t);const r=_t(an,4);xo(t,r);const a=[r[0].x,r[1].x,r[2].x,r[3].x],h=[r[0].y,r[1].y,r[2].y,r[3].y],m=_t(vt,3);m[0].setDouble(s.getSemiMinorAxis()),m[0].sqrThis(),m[1].setDouble(s.getSemiMajorAxis()),m[1].sqrThis(),m[2].setThis(m[0]),m[2].mulThis(m[1]),m[2].negateThis();const u=_n(a,3,h,3,null,0,m,!0,U.unit(),U.unit(),c);if(u>0){let t=0;for(let n=0;n<u;n++){const i=new J;e.queryCoord2D(c[n],i);const r=s.getClosestCoordinate(i,!1),a=new J;s.queryCoord2D(r,a);J.distance(i,a)<=o&&(l.push(i.clone()),c[t]=c[n],g.push(r),t++)}c.length=t,l.length=t}}const _=[0,1];for(let p=0;p<2;p++){const t=0===p?s.getStartXY():s.getEndXY(),e=[0];la(d,t,U.unit(),!1,-1,1,e);const n=new J;jo(d,e[0],n);J.distance(t,n)<=o&&(c.push(e[0]),g.push(_[p]),l.push(n.clone()))}for(let p=0;p<2;p++){const t=[0,3];{const e=s.getClosestCoordinate(d[t[p]],!1),n=new J;s.queryCoord2D(e,n);J.distance(d[t[p]],n)<=o&&(c.push(_[p]),g.push(e),l.push(n.clone()))}}return Km(t,e,s,c,g,c.length,n,i,r,o,a,h,m)}function ia(t,e,n,i,r,o,a,h,m,u){const l=_t(J,4);e.queryControlPoints(l);const c=_t(J,4);if(n.queryControlPoints(c),Je(l,c,4)<0)return ia(t,n,e,i,o,r,a,h,m,!u);const g=Oe(e,n);if(Qe(e,n,a=Math.max(a,g)))return 0;if(Da(e,n,i,r,o,a,h,m,u))return 2;const d=new U(0,1),_=new U(0,1);{const t=new ve;ma(l,new U(0,1),t);const e=new ve;ma(c,new U(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(xa(l,t,d),xa(c,t,_),d.isEmpty()||_.isEmpty())return 0;Wo(l,d.vmin,d.vmax,l),Wo(c,_.vmin,_.vmax,c)}}const p=tu(l,3,c,3,a);if(0===p)return 0;const f=[],P=[],y=[];let x=!1;if(-1===p){const t=_t(an,4);xo(l,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=_t(an,4);xo(c,n);const i=[],r=[],o=cn(e,3,s,3,null,0,[n[0].x,n[1].x,n[2].x,n[3].x],3,[n[0].y,n[1].y,n[2].y,n[3].y],3,null,0,!0,U.unit(),U.unit(),i,r);if(o>0)for(let h=0;h<o;h++){const t=new J;jo(c,r[h],t);const e=new J;jo(l,i[h],e);J.distance(e,t)<=a&&(f.push(e.clone()),y.push(r[h]),P.push(i[h]))}else-1===o&&(x=!0)}for(let s=0;s<2;s++){const t=0===s?l:c,e=0===s?c:l;for(let n=0;n<2;n++){const i=0===n?0:3,r=[0];la(e,t[i],U.unit(),!1,-1,1,r);const o=new J;jo(e,r[0],o);J.distance(t[i],o)<=a&&(0===s?(P.push(0===i?0:1),y.push(r[0])):(y.push(0===i?0:1),P.push(r[0])),f.push(o.clone()))}}if(0===P.length&&x){const t=e.calculateUpperLength2D()>n.calculateUpperLength2D();{const i=[0,0];if(2===pa(t?e:n,i,!0)&&(s(U.unit().containsCoordinate(i[0])),!U.unit().containsCoordinate(i[1]))){const e=new J;jo(t?l:c,i[0],e);const s=[0,0];1===la(t?c:l,e,U.unit(),!1,-1,2,s)&&(f.push(e.clone()),P.push(t?i[0]:s[0]),y.push(t?s[0]:i[0]))}}}if(0===P.length)return 0;if(!d.equalsRange(0,1))for(let s=0;s<P.length;++s)P[s]=mo.recalculateParentT(d.vmin,d.vmax,P[s]);if(!_.equalsRange(0,1))for(let s=0;s<y.length;++s)y[s]=mo.recalculateParentT(_.vmin,_.vmax,y[s]);return Km(t,e,n,P,y,P.length,i,r,o,a,h,m,u)}function ra(t,e,n,i,r,o,a,h,m,u){const l=Oe(e,n);if(n.isDegenerateToLineHelper(l)){const s=new su({start:n.getStartXY(),end:n.getEndXY()}),l=sa(t,e,s,i,r,o,a,h,m,u);if(o)for(let t=0;t<l;++t){const e=s.getCoord2D(o[t]);o[t]=n.getClosestCoordinate(e,!1)}return l}if(Qe(e,n,a=Math.max(a,l)))return 0;const c=_t(J,4);e.queryControlPoints(c);const g=_t(J,3);n.queryControlPoints(g);const d=new U(0,1),_=new U(0,1),p=[0,0,0];n.queryWeights(p);const f=[1,tr(p),1];{const t=new ve;ma(c,new U(0,1),t);const e=new ve;wi(g,f,new U(0,1),e);const s=Math.max(t.maxDim(),e.maxDim());if(t.inflate(3*a),e.inflate(3*a),!t.intersectW(e))return 0;if(t.maxDim()<.1*s){if(xa(c,t,d),$i(g,f,t,_),d.isEmpty()||_.isEmpty())return 0;Wo(c,d.vmin,d.vmax,c),Xi(g,f,_.vmin,_.vmax,g,f)}}const P=tu(c,3,g,2,a);if(0===P)return 0;const y=[],x=[],C=[];if(-1===P){const t=_t(an,4);xo(c,t);const e=[t[0].x,t[1].x,t[2].x,t[3].x],s=[t[0].y,t[1].y,t[2].y,t[3].y],n=_t(vt,3),i=_t(vt,3),r=_t(vt,3);Zi(g,f,n,i,r);const o=[],h=[],m=cn(n,2,i,2,r,2,e,3,s,3,null,0,!0,U.unit(),U.unit(),h,o);if(m>0)for(let u=0;u<m;u++){const t=new J;jo(c,o[u],t);const e=new J;Ki(g,f,h[u],e);J.distance(t,e)<=a&&(y.push(t.clone()),x.push(o[u]),C.push(h[u]))}}for(let v=0;v<2;v++){let t,e;0===v?(t=c,e=g):(e=c,t=g);for(let n=0;n<2;n++){const i=0===n?0:t.length-1,r=[0],o=new J;if(0===v){const n=bi(e,f,t[i],U.unit(),!1,-1,1,r);s(1===n),Ki(e,f,r[0],o)}else{const n=la(e,t[i],U.unit(),!1,-1,1,r);s(1===n),jo(e,r[0],o)}J.distance(t[i],o)<=a&&(0===v?(x.push(0===i?0:1),C.push(r[0])):(C.push(0===i?0:1),x.push(r[0])),y.push(o.clone()))}}if(0===x.length)return 0;if(!d.equalsRange(0,1))for(let s=0;s<x.length;++s)x[s]=mo.recalculateParentT(d.vmin,d.vmax,x[s]);if(!_.equalsRange(0,1))for(let s=0;s<C.length;++s)C[s]=on.recalculateParentT(_.vmin,_.vmax,C[s]);for(let s=0;s<C.length;++s)C[s]=er(p,C[s]);return Km(t,e,n,x,C,x.length,i,r,o,a,h,m,u)}function oa(t,e,n,i,r,o,a,h,m,u){const l=Oe(e,n);if(Qe(e,n,a=Math.max(a,l)))return 0;const c=_t(J,4);e.queryControlPoints(c);const g=_t(J,3);n.queryControlPoints(g);const d=tu(c,3,g,2,a);if(0===d)return 0;const _=[],p=[],f=[];if(-1===d){const t=_t(an,4);xo(c,t);const s=[t[0].x,t[1].x,t[2].x,t[3].x],i=[t[0].y,t[1].y,t[2].y,t[3].y],r=_t(an,3);Qr(g,r);const o=cn([r[0].x,r[1].x,r[2].x],2,[r[0].y,r[1].y,r[2].y],2,null,0,s,3,i,3,null,0,!0,U.unit(),U.unit(),f,p);if(o>0){let t=0;for(let s=0;s<o;s++){const i=new J;e.queryCoord2D(p[s],i);const r=new J;n.queryCoord2D(f[s],r);J.distance(i,r)<=a&&(_.push(i.clone()),p[t]=p[s],f[t]=f[s],t++)}p.length=t,_.length=t}}for(let P=0;P<2;P++){let t,e;0===P?(t=c,e=g):(e=c,t=g);for(let n=0;n<2;n++){const i=0===n?0:t.length-1,r=[0],o=new J;if(0===P)Ar(e,t[i],r),Jr(e,r[0],o);else{const n=la(e,t[i],U.unit(),!1,-1,1,r);s(1===n),jo(e,r[0],o)}J.distance(t[i],o)<=a&&(0===P?(p.push(0===i?0:1),f.push(r[0])):(f.push(0===i?0:1),p.push(r[0])),_.push(o.clone()))}}return Km(t,e,n,p,f,p.length,i,r,o,a,h,m,u)}function aa(t,e,i,r,o){const a=new ve;if(ha(t,U.unit(),a),a.inflate(r),!a.isIntersectingPoint2D(e))return 0;const h=Eo(t);let m=0,u=h.specialPoints[0];const l=[];for(let n=1,c=h.specialPoints.length;n<c;++n){const i=h.specialPoints[n],r=Mo(t,e,u,i);if(0===l.length)l.push(r);else if(r.t===r.tmin)s(l.at(-1).d<=r.d),l.at(-1).tmax=r.tmax;else if(l.at(-1).t===l.at(-1).tmax){s(l.at(-1).d>=r.d);const t=l.at(-1).tmin;l[l.length-1]=r,l.at(-1).tmin=t}else l.push(r);u=i}for(const s of l)if(s.d<=r){const t=s.t;i?(m>=i.length&&n(""),i[m]=t,m++):m++}return m}function ha(t,e,s){const n=_t(J,4);t.queryControlPoints(n),ma(n,e,s)}function ma(t,e,s){if(e.equalsRange(0,1))return void s.setFromPoints(t,4);const n=_t(J,4);Wo(t,e.vmin,e.vmax,n),s.setFromPoints(n,4)}class ua{constructor(t,e){this.controlPoints=t,this.point=e.clone()}getMaxDerivative(){return 6}getValue(t,e){switch(t){case 0:{const t=new J;jo(this.controlPoints,e,t);const s=qo(this.controlPoints,1,e);return 2*t.sub(this.point).dotProduct(s)}case 1:{const t=new J;jo(this.controlPoints,e,t);const s=qo(this.controlPoints,1,e),n=qo(this.controlPoints,2,e);return 2*(t.sub(this.point).dotProduct(n)+s.dotProduct(s))}case 2:{const t=new J;jo(this.controlPoints,e,t);const s=qo(this.controlPoints,1,e),n=qo(this.controlPoints,2,e),i=qo(this.controlPoints,3,e);return 2*(t.sub(this.point).dotProduct(i)+3*s.dotProduct(n))}case 3:{const t=qo(this.controlPoints,1,e),s=qo(this.controlPoints,2,e),n=qo(this.controlPoints,3,e);return 2*(4*t.dotProduct(n)+3*s.sqrLength())}case 4:{const t=qo(this.controlPoints,2,e),s=qo(this.controlPoints,3,e);return 2*(10*t.dotProduct(s))}case 5:{const t=qo(this.controlPoints,3,e);return 2*(10*t.dotProduct(t))}default:return 0}}getError(t){return 0}}function la(t,e,n,i,r,o,a){l(U.unit().contains(n)&&o>0,"getClosestCoordinate"),(r<0||Number.isNaN(r))&&(r=Number.MAX_VALUE);const h=[],m=new J;jo(t,n.vmin,m);let u=J.distance(m,e);if(u<=r&&h.push(new J(n.vmin,u)),n.vmin!==n.vmax&&(jo(t,n.vmax,m),u=J.distance(m,e),u<=r&&h.push(new J(n.vmax,u))),n.width()>0){const s=O(18,Number.NaN),i=Xs(new ua(t,e),n,18,s);for(let n=0;n<i;n++)jo(t,s[n],m),u=J.distance(m,e),u>r||h.push(new J(s[n],u))}if(i){s(n.equals(U.unit()));{jo(t,-1,m,!0);const s=new J;jo(t,0,s);const n=new su({start:m,end:s}),i=n.getClosestCoordinate(e,!0);i<1&&(m.assign(n.getCoord2D(i)),u=J.distance(m,e),u<=r&&h.push(new J(i-1,u)))}{jo(t,2,m,!0);const s=new J;jo(t,n.vmax,s);const i=new su({start:s,end:m}),o=i.getClosestCoordinate(e,!0);o>0&&(m.assign(i.getCoord2D(o)),u=J.distance(m,e),u<=r&&h.push(new J(1+o,u)))}}if(!h.length)return 0;h.sort(((t,e)=>t.compare(e)));let c=0;const g=h[0].x;if(a[c++]=g,c<o){const e=V(t,4,!1).total(),s=h[0].y;for(let t=1,n=h.length;t<n;t++)if(h[t].y>s+e){h.length=t;break}h.sort(((t,e)=>bt(t.x,e.x))),c=0,a[c++]=h[0].x;for(let t=1,n=h.length;t<n;t++)h[t].x!==a[c-1]&&c<o&&(a[c++]=h[t].x)}return c}function ca(t,e,s,n,i,r,o){const a=_t(J,4);return t.queryControlPoints(a),la(a,e,s,n,i,r,o)}function ga(t){return t.getStartXY().norm(1)+t.getEndXY().norm(1)+t.m_cp[0].norm(1)+t.m_cp[1].norm(1)}function da(t){return t[0].norm(1)+t[1].norm(1)+t[2].norm(1)+t[3].norm(1)}function _a(t,e,n){if(s(n>=2),2===n){const s=new J;St(e[0],e[n-1],1/3,s);const i=new J;return St(e[0],e[n-1],2/3,i),void t.construct(e[0],s,i,e[n-1])}const i=e[0],r=e[n-1],o=[0,0],a=ca(t,i,U.unit(),!1,Number.NaN,2,o),h=[0,0],m=ca(t,r,U.unit(),!1,Number.NaN,2,h),u=[];for(let s=0;s<a;s++)for(let a=0;a<m;a++){const m=o[s],l=h[a],c=(s,o)=>{const a=O(n-2,Number.NaN),h=()=>{let t=0;for(let s=1,i=n-1;s<i;s++){t+=J.distance(e[s-1],e[s]);const n=t;a[s-1]=n}t+=J.distance(e[n-2],e[n-1]);for(let e=1,s=n-1;e<s;e++)a[e-1]/=t};let u=!1,c=!1;{const e=new nu;m<=l?(t.queryCut(m,l,e,!0),s.assign(e.get().getControlPoint1()),o.assign(e.get().getControlPoint2())):(t.queryCut(l,m,e,!0),s.assign(e.get().getControlPoint2()),o.assign(e.get().getControlPoint1())),i.equals(s)&&(u=!0),r.equals(o)&&(c=!0)}h();let g=Number.MAX_VALUE;const d=s.clone(),_=o.clone();for(let t=0;t<5;t++){g=wa(!0,!1,i,d,_,r,u,c,a,n-2,e,n)}for(let t=0;t<30;t++){const t=d.clone();_.clone();const s=wa(!0,!0,i,d,_,r,u,c,a,n-2,e,n);if(g<=s&&t.equals(d)&&t.equals(_))break;g=s}h();let p=!1,f=Number.EPSILON;const P=s.clone(),y=o.clone();for(let t=0;t<30;t++){const t=P.clone();y.clone();const s=wa(p,!0,i,P,y,r,u,c,a,n-2,e,n);if(f<=s&&t.equals(P)&&t.equals(y))break;p=!0,f=s}return f<g?(s.assign(P),o.assign(y)):(s.assign(d),o.assign(_),f=g),f},g=new J,d=new J,_=[c(g,d),J.distance(i,g)+J.distance(g,d)+J.distance(d,r),g.x,g.y,d.x,d.y];u.splice(u.length,0,..._)}let l=u[0],c=u[1],g=0;for(let s=6;s<u.length;s+=6)u[s]<l&&(l=u[s],c=u[s+1],g=s);let d=g;for(let s=0;s<u.length;s+=6)s!==g&&u[s+1]<c&&Math.abs(l-u[s])<10*l&&(c=u[s+1],d=s);t.construct(i,new J(u[d+2],u[d+3]),new J(u[d+4],u[d+5]),r)}function pa(t,e,s=!1){const n=_t(J,4);t.queryControlPoints(n);const i=_t(an,4);let r,o,a;xo(n,i,!0);const h=i[3].x.isZero(),m=i[3].y.isZero();if(h||m)if(h&&!m){if(i[2].x.isZero())return 0;r=i[1].x.div(i[2].x).negate(),o=i[2].y.div(i[3].y),a=i[1].y.div(i[3].y)}else{if(h||!m)return 0;if(i[2].y.isZero())return 0;r=i[1].y.div(i[2].y).negate(),o=i[2].x.div(i[3].x),a=i[1].x.div(i[3].x)}else{i[2].x.divThis(i[3].x),i[1].x.divThis(i[3].x),i[2].y.divThis(i[3].y),i[1].y.divThis(i[3].y);const t=i[2].x.sub(i[2].y);if(t.isZero())return 0;r=i[1].x.sub(i[1].y).div(t).negate(),o=i[2].x.clone(),a=i[1].x.clone()}if(!s&&r.abs().value()>2)return 0;const u=[0,0],l=t.getStartXY().equals(t.getEndXY()),c=qs(1,-r.toDouble(),r.add(o).mul(r).add(a).toDouble(),U.unit(),l,u);if(0===c)return 0;if(u[0]>=0&&u[0]<=1){const t=r.toDouble()-u[0];if(s||t>=0&&t<=1)return e[0]=u[0],e[1]=t,e[0]>e[1]&&(e[1]=tt(e[0],e[0]=e[1])),2}if(2===c&&u[1]>=0&&u[1]<=1){const t=r.toDouble()-u[1];if(s||t>=0&&t<=1)return e[0]=u[1],e[1]=t,e[0]>e[1]&&(e[1]=tt(e[0],e[0]=e[1])),2}return 0}function fa(t,e,s){const n=t[1].mulE(e[2]).subThisE(t[2].mulE(e[1])),i=t[1].mulE(e[3]).subThisE(t[3].mulE(e[1])).mulThis(3),r=t[2].mulE(e[3]).subThisE(t[3].mulE(e[2])).mulThis(3),o=_t(st,2);let a=js(r,i,n,new U(0,1),!1,o);a<0&&(a=0);let h=0;for(let m=0;m<a;m++)ht(o[m].value(),0,1)||(s[h].setE(o[m]),h++);return h}function Pa(t,e){e[0].set(0);let n=1;const i=_t(st,4);Po(t,i,!0);const r=_t(st,4);yo(t,r,!0);{const t=i[3].mul(3),s=i[2].mul(2),r=i[1].clone(),o=_t(st,2);let a=js(t,s,r,new U(0,1),!1,o);a<0&&(a=0);for(let i=0;i<a;i++)ht(o[i].value(),0,1)||(e[n]=o[i],n++)}{const t=r[3].mul(3),s=r[2].mul(2),i=r[1].clone(),o=_t(st,2);let a=js(t,s,i,new U(0,1),!1,o);a<0&&(a=0);for(let r=0;r<a;r++)ht(o[r].value(),0,1)||(e[n]=o[r],n++)}if(n+=fa(i,r,e.slice(n)),e[n].set(1),n++,n>2){$(e,0,n,((t,e)=>{const s=t.value(),n=e.value();return s<n?-1:s>n?1:0}));let s=0;const i=e[0].clone();let r=0;const o=da(t)*ut(),a=new J;Bo(t,e[0].value(),a);for(let h=1;h<n;h++){const n=new J;if(Bo(t,e[h].value(),n),e[h].eq(i)||n.isEqualPoint2D(a,o)){if(0!==s){if(0===e[h].eps())i.setE(e[h]),r=0;else if(0!==r){const t=Tt(1/e[h].eps()),s=1/r,n=t+s;i.set((e[h].value()*t+i.value()*s)/n),r=1/n,i.setError(Math.sqrt(r))}e[s].setE(i),Bo(t,i.value(),a)}}else s++,e[s].setE(e[h]),i.setE(e[h]),Bo(t,i.value(),a),r=Tt(e[h].eps())}s++,n=s}return 1===n&&(n=2,e[1].set(1)),s(0===e[0].value()),s(1===e[n-1].value()),n}function ya(t,e,s,n,i){const r=_t(st,4),o=_t(st,3),a=new U(0,1);let h=0;if(e){if(yo(t,r,!1),h=Zs(r[3],r[2],r[1],r[0].sub(s),a,!1,o),n)for(let m=0;m<h;m++){const e=new J;jo(t,o[m].value(),e),n[m]=e.x}}else if(Po(t,r,!1),h=Zs(r[3],r[2],r[1],r[0].sub(s),a,!1,o),n)for(let m=0;m<h;m++){const e=new J;jo(t,o[m].value(),e),n[m]=e.y}if(i)for(let m=0;m<h;m++)i[m]=o[m].value();else n&&$(n,0,h,bt);return h}function xa(t,e,s){s.setEmpty();const n=[];n.push(new U(0,1));const i=.5*Math.max(e.width(),e.height());for(;n.length;){const r=n.at(-1);n.pop();const o=new ve;if(ma(t,r,o),o.isIntersectingW(e)){const t=Math.max(o.width(),o.height());if(e.containsW(o)||t<=i||r.width()<1e-12)s.merge(r);else{const t=r.getCenter();n.push(U.construct(r.vmin,t)),n.push(U.construct(t,r.vmax))}}}}function Ca(t,e,s){s.length=0;{const e=new st;Yo(t,e);const n=new Se;if(Oo(t,e,n),n.isZero())return e.isZero()||e.eq(new st(1))?0:(s.push(e.value()),1)}const n=_t(st,4);po(t,n,!0);const i=_t(st,4);fo(t,i,!0);const r=_t(st,6),o=n[3].negate().mulE(i[1]).addE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),a=n[3].negate().mulE(i[1]).subE(n[2].mulE(i[2]).mul(2)).addE(n[1].mulE(i[3])),h=n[2].mulE(n[2]).subE(i[2].mulE(i[2]));r[0]=i[1].mulE(i[1]).mulE(o).addE(n[1].mulE(n[1]).mulE(a)).addE(n[1].mulE(i[1]).mulE(h).mul(2)).mul(6),r[1]=n[2].mulE(i[1]).subE(n[1].mulE(i[2])).mulE(n[2].mulE(n[2]).addE(n[1].mulE(n[3]).mul(2)).addE(i[2].mulE(i[2])).addE(i[1].mulE(i[3]).mul(2))).mul(24);const m=n[1].mulE(i[2]).mulE(i[2]).mulE(i[3]),u=n[2].mulE(n[2]).mulE(n[3]).mulE(i[1]).subE(m).mul(156),l=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),c=n[3].mulE(i[1]).subE(n[1].mulE(i[3])),g=n[1].mulE(n[3]).mulE(c).addE(i[1].mulE(i[3]).mulE(l)).mul(72),d=i[1].mulE(i[3]).subE(n[1].mulE(n[3])),_=n[2].mulE(i[2]).mulE(d).mul(120),p=n[1].mulE(n[2]).mulE(n[2]).mulE(i[3]),f=n[3].mulE(i[1]).mulE(i[2]).mulE(i[2]).subE(p).mul(36);r[2]=u.addE(g).addE(_).addE(f);const P=n[2].mulE(n[3]).mulE(n[3]).mulE(i[1]).subE(n[1].mulE(i[2]).mulE(i[3]).mulE(i[3])).mul(360),y=n[2].mulE(i[2]).mulE(n[2].mulE(n[3]).subE(i[2].mulE(i[3]))).addE(n[3].mulE(i[2]).mulE(i[2]).mulE(i[2])).subE(n[2].mulE(n[2]).mulE(n[2]).mulE(i[3])).mul(24),x=n[2].mulE(i[1]).mulE(i[3]).mulE(i[3]).subE(n[1].mulE(n[3]).mulE(n[3]).mulE(i[2])).mul(72),C=n[3].mulE(i[3]).mulE(i[1].mulE(i[2]).subE(n[1].mulE(n[2]))).mul(288);r[3]=P.addE(y).addE(x).addE(C),r[4]=i[3].mulE(i[3]).addE(n[3].mulE(n[3])).mulE(n[3].mulE(i[1]).subE(n[1].mulE(i[3]))).mul(270).addE(n[3].mulE(i[2]).subE(n[2].mulE(i[3]))).mulE(n[2].mulE(n[3]).addE(i[2].mulE(i[3]))).mul(180),r[5]=n[3].mulE(i[2]).subE(n[2].mulE(i[3])).mulE(n[3].mulE(n[3]).addE(i[3].mulE(i[3]))).mul(216);const v=_t(st,5),b=Hs(r,5,new U(0,1),!1,v,5);if(b>0){let n=Math.abs(t.getCurvature(0)),i=0;const r=Math.abs(t.getCurvature(1));(r>n||!Number.isFinite(r))&&(i=1);for(let e=0;e<b;e++){const s=Math.abs(t.getCurvature(v[e].value()));t.getCoord2D(v[e].value()),(s>n||!Number.isFinite(s))&&(n=s,i=v[e].value())}if((!Number.isFinite(n)||1/n<e)&&!ht(i,0,1)){const e=t.getCoord2D(i);if(!e.equals(t.getStartXY())&&!e.equals(t.getEndXY()))return s.push(i),1}}return 0}class va{constructor(t,e){this.b=t,this.len=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?this.len-Co(this.b,e,!1):0}getError(t){return 0}}function ba(t,e,n,i,r,o,a){for(;;){const h=J.distance(e[0],e[3]),m=J.distance(e[0],e[1])+J.distance(e[1],e[2])+J.distance(e[2],e[3]);if(m-h<=i+n*m)return t+ot(h,m,.5);const u=t=>qo(e,1,t).length();if(0===o){s(a<8);let h=u(0),l=u(1);r[0]+=2,h>l&&(l=tt(h,h=l),e[3]=tt(e[0],e[0]=e[3]),e[2]=tt(e[1],e[1]=e[2]));let c=h/(h+l),g=1,d=m;for(;c<1/32&&d>=32*(i+n*d);){g/=4;const t=u(g);r[0]++,c=h/(t+h);const s=new J;if(jo(e,.5*g,s),d=J.distance(s,e[0]),d<=i){const t=new J;jo(e,g,t),d+=J.distance(t,s)}}if(1!==g){const s=_t(J,4);Go(e,g,e,s),t=ba(t,s,n,i,r,0,a+1),o++,a++;continue}}const l=8;r[0]+=l;const c=Vn(l,u,0,1),g=16;r[0]+=g;const d=Vn(g,u,0,1);let _=Math.abs(c-d)>i+n*m;if(!_)return t+d;if(o<3){const s=_t(J,4);Go(e,.5,e,s),t=ba(t,s,n,i,r,o+1,a+1),o++,a++;continue}const p=32;r[0]+=p;const f=Vn(p,u,0,1);if(_=Math.abs(d-f)>i+n*m,!_)return t+f;const P=64;r[0]+=P;const y=Vn(P,u,0,1);if(_=Math.abs(f-y)>i+n*m,!_)return t+y;const x=128;r[0]+=x;const C=Vn(x,u,0,1);return _=Math.abs(y-C)>i+n*m,t+C}}function Ea(t,e,s,n,i){if(s===e)return 0;const r=_t(J,4);t.queryControlPoints(r);const o=_t(J,4);Wo(r,e,s,o);return ba(0,o,n,i,[0],0,0)}function Sa(t,e,s,n,i){let r=!0;const o=Ln(5,e,s,n,i,(e=>{const s=Vo(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));r=!1;const a=Ln(5,e,s,n,i,(e=>{const s=Vo(t,1,e);return(r?t.getCoordX(e)-t.getStartX():t.getCoordY(e)-t.getStartY())*s.length()}));return new J(o,a)}function Da(t,e,s,n,i,r,o,a,h){const m=_t(J,4);t.queryControlPoints(m);const u=_t(J,4);if(e.queryControlPoints(u),m[0].equals(u[0])){if(m[1].equals(u[1])&&m[2].equals(u[2])&&m[3].equals(u[3]))return s&&(s.length=0,s.push(m[0]),s.push(m[3])),n&&(n.length=0,n.push(0),n.push(1)),i&&(i.length=0,i.push(0),i.push(1)),!0;if(!m[0].equals(u[3]))return!1}return!!(m[0].equals(u[3])&&m[1].equals(u[2])&&m[2].equals(u[1])&&m[3].equals(u[0]))&&(n&&(n.length=0,n.push(0),n.push(1),h&&(n[1]=tt(n[0],n[0]=n[1]))),i&&(i.length=0,i.push(1),i.push(0),h&&(i[1]=tt(i[0],i[0]=i[1]))),s&&(s.length=0,s.push(m[0]),s.push(m[3]),h&&(s[1]=tt(s[0],s[0]=s[1]))),!0)}function wa(t,e,s,n,i,r,o,a,h,m,u,l){let c=0,g=0,d=0,_=0,p=0,f=0,P=0;for(let x=1,C=l-1;x<C;x++){let e,o,a,m,l,y,C=-1,v=h[x-1];t&&(x>2?(v=lt(2*h[x-2]-h[x-3],0,1),h[x-1]=v):2===x&&v<=h[0]&&(v=h[0]));for(let c=0;c<11&&(e=h[x-1],o=e*e,a=o*e,m=1-e,l=m*m,y=l*m,t)&&!(Math.abs(e-C)<1e-12)&&10!==c;c++){const t=s.x-2*n.x+i.x,a=s.x-3*n.x+3*i.x-r.x,m=s.y-2*n.y+i.y,c=s.y-3*n.y+3*i.y-r.y,g=s.x-n.x-2*t*e+a*o,d=-u[x].x+s.x*y+e*(3*n.x*l+e*(3*i.x-3*i.x*e+r.x*e)),_=s.y-n.y-2*m*e+c*o,p=-u[x].y+s.y*y+e*(3*n.y*l+e*(3*i.y-3*i.y*e+r.y*e));C=e;const f=e- -6*(g*d+_*p)/(6*(3*Tt(g)-(-2*t+2*a*e)*d)+6*(3*Tt(_)-(-2*m+2*c*e)*p));h[x-1]=lt(f,x>1?h[x-2]:0,1)}c+=3*o*l*l,g+=3*a*y,d+=3*o*o*l;const b=-(y*s.x+a*r.x-u[x].x);_+=b*e*l,p+=b*o*m;const E=-(y*s.y+a*r.y-u[x].y);f+=E*e*l,P+=E*o*m}if(e){const t=c*d-g*g;Math.abs(t)>=1e-12*(Math.abs(c*d)+Math.abs(g*g))+1e-10?(o||(n.x=(_*d-p*g)/t,n.y=(f*d-P*g)/t),a||(i.x=(c*p-g*_)/t,i.y=(c*P-g*f)/t)):(St(s,r,.3,n),St(s,r,.6,i))}let y=0;for(let x=1,C=l-1;x<C;x++){const t=h[x-1],e=1-t,o=s.mul(Ot(e)),a=n.mul(3*t*e*e),m=i.mul(3*t*t*e),l=r.mul(Ot(t));y+=o.add(a).add(m).add(l).sub(u[x]).sqrLength()}return y}function Aa(t,e,s,n){const i=t.getPathStart(e),r=t.getPathEnd(e);if(r-i<3)return;const o=2*i,a=J.getNAN();s.queryPoint2D(o,a);const h=a.x,m=a.y,u=J.getNAN();s.queryPoint2D(o+2,u);const l=J.getNAN();for(let c=o+4,g=2*r;c<g;c+=2)s.queryPoint2D(c,l),n.pe((l.x-a.x)*(u.y-m)),a.setCoordsPoint2D(u),u.setCoordsPoint2D(l);n.pe((h-a.x)*(u.y-m))}function Ta(t,e,s){for(;e.hasNextSegment();){const t=e.nextCurve();if(null===t)break;s.pe(2*t.calculateArea2DHelper())}}var Ia=I;class Ma{static toSegType(t){let e=0;switch(t){case i.enumLine:e=1;break;case i.enumBezier:e=2;break;case i.enumEllipticArc:e=4;break;case i.enumRationalBezier2:e=8;break;case i.enumBezier2:e=16;break;default:h("")}return e}constructor(){this.m_segmentFlags=null,this.m_segmentParamIndex=null,this.m_segmentParams=null,this.m_curveCount=0,this.m_bezierCount=0,this.m_arcCount=0,this.m_rbezier2Count=0,this.m_bezier2Count=0,this.m_curveParamWritePoint=0}assignCopy(t){return this.m_segmentFlags=t.m_segmentFlags,this.m_segmentParamIndex=t.m_segmentParamIndex,this.m_segmentParams=t.m_segmentParams,this.m_curveCount=t.m_curveCount,this.m_bezierCount=t.m_bezierCount,this.m_arcCount=t.m_arcCount,this.m_rbezier2Count=t.m_rbezier2Count,this.m_bezier2Count=t.m_bezier2Count,this.m_curveParamWritePoint=t.m_curveParamWritePoint,this}}class Ya extends xe{constructor(t){super(t),this.m_cachedRingAreas2D=null,this.m_paths=null,this.m_pathFlags=null,this.m_curveData=null,t.move?(this.m_bPolygon=t.move.m_bPolygon,this.m_cachedLength2D=t.move.m_cachedLength2D,this.m_cachedArea2D=t.move.m_cachedArea2D,this.m_currentPathIndex=t.move.m_currentPathIndex,this.m_cachedRingAreas2D=t.move.m_cachedRingAreas2D,this.m_paths=t.move.m_paths,this.m_pathFlags=t.move.m_pathFlags,this.m_curveData=t.move.m_curveData,t.move.m_curveData=null,t.move.setEmpty()):(this.m_bPolygon=t.bPolygon,this.m_cachedLength2D=0,this.m_cachedArea2D=0,this.m_currentPathIndex=0)}getGeometryType(){return this.m_bPolygon?i.enumPolygon:i.enumPolyline}getDimension(){return this.m_bPolygon?2:1}changeRingStartPoint(t){s(this.m_bPolygon);const n=this.getPathIndexFromPointIndex(t),i=this.getPathStart(n);if(i===t)return;const r=this.getPathEnd(n);(t>=r||t<i)&&e("change_ring_start_point");for(let e=0,s=this.m_description.getAttributeCount();e<s;e++){const s=this.m_description.getSemantics(e),n=Ia.getComponentCount(s);this.m_vertexAttributes.get(e).rotate(i*n,t*n,r*n)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.rotate(i,t,r),this.m_curveData.m_segmentParamIndex.rotate(i,t,r))}setFillRule(t){this.m_bFillRule=1===t}getFillRule(){return this.m_bFillRule?1:0}isExteriorRingOGC(t){return!!this.m_bPolygon&&(this.updateOGCFlagsProtected(),!!(8&this.m_pathFlags.read(t)))}isExteriorRing(t){return this.calculateRingArea2D(t)>0}calculateRingArea2D(t){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedRingAreas2D.read(t)):0}updateRingAreas2DProtected(){if(!this.hasDirtyFlag(1024))return;const t=this.getPathCount();if(0===t)return this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=0),void this.setDirtyFlagProtected(1024,!1);const e=new L(t),s=new ct(0),n=new ct(0);if(0!==this.m_pointCount){const i=this.getAttributeStreamRef(0);if(this.hasNonLinearSegments()){const t=new Ds({parent:this});for(t.stripAttributes();t.nextPath();){n.reset();const r=t.getPathIndex();Aa(this,r,i,n),Ta(this,t,n);const o=.5*n.getResult();s.add(o),e.write(r,o)}}else for(let r=0;r<t;r++){n.reset(),Aa(this,r,i,n);const t=.5*n.getResult();s.add(t),e.write(r,t)}}this.hasDirtyFlag(1024)&&(this.m_cachedArea2D=s.getResult(),this.m_cachedRingAreas2D=e,this.setDirtyFlagProtected(1024,!1))}getOGCPolygonCount(){if(!this.m_bPolygon)return 0;this.updateOGCFlagsProtected();let t=0;const e=this.getPathCount();for(let s=0;s<e;s++)8&this.m_pathFlags.read(s)&&t++;return t}getHashCodeImpl(){return s(0),0}equalsImpl(t){const e=t,s=this.getPathCount();if(s!==e.getPathCount())return!1;const n=this.hasNonLinearSegments();if(n!==e.hasNonLinearSegments())return!1;if(n){if(this.m_curveData.m_curveCount!==e.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==e.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(e.m_paths,0,s+1))return!1;if(this.m_bFillRule!==e.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(e.m_pathFlags,0,s))return!1;if(this.hasNonLinearSegments()){if(!this.m_curveData.m_segmentFlags.equals(e.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;for(let t=0,s=this.getPointCount();t<s;t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!Ya.isNonLinearSegmentFlag(s))continue;const n=this.m_curveData.m_segmentParamIndex.read(t),i=e.m_curveData.m_segmentParamIndex.read(t),r=Ys(s);for(let t=0;t<r;t++){const s=this.m_curveData.m_segmentParams.read(n+t),r=e.m_curveData.m_segmentParams.read(i+t);if(!Yt(s,r))return!1}}}return!0}equalsImplTol(t,e){const s=t,n=this.getPathCount();if(n!==s.getPathCount())return!1;const i=this.hasNonLinearSegments();if(i!==s.hasNonLinearSegments())return!1;if(i){if(this.m_curveData.m_curveCount!==s.m_curveData.m_curveCount)return!1;if(this.m_curveData.m_bezierCount!==s.m_curveData.m_bezierCount)return!1}if(this.m_paths&&!this.m_paths.equals(s.m_paths,0,n+1))return!1;if(this.m_bFillRule!==s.m_bFillRule)return!1;if(!this.m_bPolygon&&this.m_pathFlags&&!this.m_pathFlags.equals(s.m_pathFlags,0,n))return!1;if(!i)return!0;if(!this.m_curveData.m_segmentFlags.equals(s.m_curveData.m_segmentFlags,0,this.getPointCount()))return!1;const r=this.querySegmentIterator(),o=s.querySegmentIterator();for(;r.nextPath();){if(!o.nextPath())return!1;for(;r.hasNextSegment();){const t=r.nextCurve(),s=o.nextCurve();if(!(t&&s&&t.equals(s,e))){if(!t&&!s)break;return!1}}}return!0}reserveImplImpl(t,e){this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(t,1),this.m_curveData.m_segmentParamIndex.resize(t,-1),this.checkCompactSegmentParams())}verifyStreamsAfterSizeChangeExtraImpl(){this.m_paths||(this.m_paths=R(1,0),this.m_pathFlags=z(1,0)),this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.resize(this.m_reservedPointCount,1),this.m_curveData.m_segmentParamIndex.resize(this.m_reservedPointCount,-1),this.checkCompactSegmentParams())}copyToImpl(t,e){const s=t;s.m_bPathStarted=!1,s.m_bFillRule=this.m_bFillRule,this.m_paths?s.m_paths=e?this.m_paths:this.m_paths.clone():s.m_paths=null,this.m_pathFlags?s.m_pathFlags=e?this.m_pathFlags:this.m_pathFlags.clone():s.m_pathFlags=null,this.m_curveData&&(s.m_curveData||(s.m_curveData=new Ma),s.m_curveData.assignCopy(this.m_curveData),s.m_curveData.m_curveCount=0,s.updateCurveCounter(this.m_curveData.m_curveCount),e||(this.m_curveData.m_segmentParamIndex?s.m_curveData.m_segmentParamIndex=this.m_curveData.m_segmentParamIndex.clone():s.m_curveData.m_segmentParamIndex=null,this.m_curveData.m_segmentFlags?s.m_curveData.m_segmentFlags=this.m_curveData.m_segmentFlags.clone():s.m_curveData.m_segmentFlags=null,this.m_curveData.m_segmentParams?s.m_curveData.m_segmentParams=this.m_curveData.m_segmentParams.clone():s.m_curveData.m_segmentParams=null)),s.hasDirtyFlag(512)||(s.m_cachedLength2D=this.m_cachedLength2D),s.m_cachedRingAreas2D=null,s.hasDirtyFlag(1024)||(s.m_cachedArea2D=this.m_cachedArea2D,null!==this.m_cachedRingAreas2D&&(s.m_cachedRingAreas2D=e?this.m_cachedRingAreas2D:this.m_cachedRingAreas2D.clone()))}calculateArea2D(){return this.m_bPolygon?(this.updateRingAreas2DProtected(),this.m_cachedArea2D):0}calculateLength2D(){if(!this.hasDirtyFlag(512))return this.m_cachedLength2D;const t=this.querySegmentIterator(),e=new ct(0);for(;t.nextPath();)for(;t.hasNextSegment();)e.add(t.nextSegment().calculateLength2D());return this.hasDirtyFlag(512)&&(this.m_cachedLength2D=e.getResult()),this.setDirtyFlagProtected(512,!1),e.getResult()}calculatePathLength2D(t){const e=this.querySegmentIteratorAtVertex(this.getPathStart(t)),s=new ct(0);for(;e.hasNextSegment();)s.add(e.nextSegment().calculateLength2D());return s.getResult()}calculateLength3D(t){return s(0),0}calculatePathLength3D(t,e){return s(0),0}copyTo(t){c(t.getGeometryType())||e(""),this!==t&&super.copyTo(t)}swap(t){s(0)}hasNonLinearSegments(){return 0!==this.getCurveCount()}getSegmentCount(){let t=this.getPointCount();if(!this.m_bPolygon){t-=this.getPathCount();for(let e=0,s=this.getPathCount();e<s;e++)this.isClosedPath(e)&&t++}return t}getSegmentCountPath(t){let e=this.getPathSize(t);return!this.isClosedPath(t)&&e>0&&e--,e}add(t,s){this===t&&e("Multi_path_impl::add");for(let e=0,n=t.getPathCount();e<n;e++)this.addPath(t,e,!s)}addPath(t,e,s){this.insertPath(-1,t,e,s)}addPathPoint2D(t,e,s){this.insertPath2D(-1,t,0,e,s)}addPathMultiPoint(t,e,s,n){s<0&&(s=t.getPointCount()-e),this.insertPointsFromMultipoint(-1,0,t,e,s,n)}addSegmentsFromPath(t,s,i,r,o){if(this===t&&e("Multi_path_impl.add_segments_from_path"),o||0!==this.getPathCount()||(o=!0),s<0&&(s=t.getPathCount()-1),(s>=t.getPathCount()||i<0||r<0||i+r>t.getSegmentCountPath(s))&&n("add_segments_from_path"),0===r)return;const a=t.getPathStart(s),h=t.isClosedPath(s)&&i+r===t.getSegmentCountPath(s);this.m_bPathStarted=!1,this.mergeVertexDescription(t.getDescription());let m=r;const u=a+i;let l=u+1;o&&(m++,l--),!o&&t.hasNonLinearSegments()&&1!==t.m_curveData.m_segmentFlags.read(u)&&(t.getXY(u).equals(this.getXY(this.m_pointCount-1))||e("add_segments_from_path: start point mismatch"));const c=this.m_pointCount;if(this.resizeImpl(this.m_pointCount+m),this.verifyAllStreamsAfterSizeChange(),o){if(0===m)return;this.m_paths.add(this.m_pointCount);let e=t.m_pathFlags.read(s);this.m_bPolygon&&(e|=1),this.m_pathFlags.write(this.m_pathFlags.size()-1,e),this.m_pathFlags.add(0)}else this.m_paths.write(this.m_pathFlags.size()-1,this.m_pointCount);const g=h?m-1:m;for(let e=0,n=this.m_description.getAttributeCount();e<n;e++){const s=this.m_description.getSemantics(e),n=Ia.getComponentCount(s),i=t.m_description.getAttributeIndex(s);if(g>0){if(i<0||!t.m_vertexAttributes.get(i)){const t=Ia.getDefaultValue(s);this.m_vertexAttributes.get(e).insertRange(n*c,t,g*n,n*c),h&&this.m_vertexAttributes.get(e).insertRange(n*c+g*n,t,n,n*c);continue}this.m_vertexAttributes.get(e).insertRangeFromStream(n*c,t.m_vertexAttributes.get(i),n*l,g*n,!0,n,n*c)}h&&this.m_vertexAttributes.get(e).insertRangeFromStream(n*(c+g),t.m_vertexAttributes.get(i),n*a,n,!0,n,n*(c+g))}if(this.hasNonLinearSegments()&&this.initSegmentData(0),t.hasNonLinearSegments()){let e=0;for(let s=0,n=u;s<r;s++){e+=Ys(t.m_curveData.m_segmentFlags.read(n)),n++}if(e>0){this.initSegmentData(e);let s=u,n=c-(o?0:1),i=0;for(let e=0;e<r;e++){const e=t.m_curveData.m_segmentFlags.read(s);if(this.m_curveData.m_segmentFlags.write(n,e),Ya.isNonLinearSegmentFlag(e)){i++;let r=t.m_curveData.m_segmentParamIndex.read(s);const o=Ys(e);this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);for(let e=0;e<o;e++){const e=t.m_curveData.m_segmentParams.read(r);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,e),this.m_curveData.m_curveParamWritePoint++,r++}this.incCurveType(e,1)}else this.m_curveData.m_segmentParamIndex.write(n,-1);n++,s++}this.modifyCurveCounter(i)}}if(h){const t=this.getPathCount()-1,e=this.getPathStart(t),s=this.getPathEnd(t)-1,n=this.getXY(e),i=this.getXY(s);n.isEqualPoint2D(i)&&(--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount))}this.notifyModifiedFlags(2001)}reverseAllPaths(){for(let t=0,e=this.getPathCount();t<e;t++)this.reversePath(t)}reversePath(t){t>=this.getPathCount()&&e("");const s=this.getPathSize(t);if(0===s)return;const n=this.getPathStart(t),i=this.isClosedPath(t);if(this.hasNonLinearSegments()){let t=n;const e=new this.m_segmentBufferCTor;let r=!1;for(let n=0;n<s;n++,t++){const s=this.m_curveData.m_segmentFlags.read(t);if(!Ya.isNonLinearSegmentFlag(s))continue;r=!0,this.querySegment(t,e,!0),e.get().reverse();const n=this.m_curveData.m_segmentParamIndex.read(t);e.get().writeInBufferStream(this.m_curveData.m_segmentParams,n)}if(r){const t=i?0:1;this.m_curveData.m_segmentFlags.reverseRange(n,s-t,1),this.m_curveData.m_segmentParamIndex.reverseRange(n,s-t,1)}}const r=i?1:0;for(let e=0,a=this.m_description.getAttributeCount();e<a;e++)if(this.m_vertexAttributes.get(e)){const t=this.m_description.getSemantics(e),i=Ia.getComponentCount(t);this.m_vertexAttributes.get(e).reverseRange(i*(n+r),i*(s-r),i)}const o=6&this.m_pathFlags.read(t);if(o){let e=0;4&o&&(e|=2),2&o&&(e|=4),this.m_pathFlags.clearBits(t,6),this.m_pathFlags.setBits(t,e)}this.notifyModifiedFlags(1233)}removePath(t){const s=this.getPathCount();t<0&&(t=s-1),t>=s&&e("");const n=this.getPathStart(t),i=this.getPathSize(t);for(let e=0,r=this.m_description.getAttributeCount();e<r;e++)if(this.m_vertexAttributes.get(e)){const t=this.m_description.getSemantics(e),s=Ia.getComponentCount(t);this.m_vertexAttributes.get(e).eraseRange(s*n,s*i,s*this.m_pointCount)}if(this.hasNonLinearSegments()){let t=0;for(let e=n,s=n+i;e<s;e++){const s=this.m_curveData.m_segmentFlags.read(e);Ya.isNonLinearSegmentFlag(s)&&(this.incCurveType(s,-1),t++)}this.modifyCurveCounter(-t),this.m_curveData.m_segmentFlags.eraseRange(n,i,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(n,i,this.m_pointCount)}for(let e=t+1;e<=s;e++){const t=this.m_paths.read(e);this.m_paths.write(e-1,t-i)}if(this.m_pathFlags)for(let e=t+1;e<=s;e++){const t=this.m_pathFlags.read(e);this.m_pathFlags.write(e-1,t)}this.m_paths.resize(s),this.m_pathFlags.resize(s),this.m_pointCount-=i,this.m_reservedPointCount-=i,t===s-1&&(this.m_bPathStarted=!1),this.notifyModifiedFlags(2001),this.checkCompactSegmentParams(),this.dbgVerifyCurves()}dbgVerifyCurves(){}insertPath(t,s,n,i){this===s&&e("Multi_path_impl::insert_path");const r=this.getPathCount();if(!i&&s.hasNonLinearSegmentsPath(n))return t=this.insertPath(t,s,n,!0),this.reversePath(t),t;n>=s.getPathCount()&&e(""),t>r&&e(""),t<0&&(t=r),n<0&&(n=s.getPathCount()-1),this.m_bPathStarted=!1,this.mergeVertexDescription(s.getDescription());const o=s.getPathStart(n),a=s.getPathSize(n);if(0===a)return this.insertPath2D(t,null,0,0,!0);const h=this.m_pointCount,m=s.isClosedPath(n)&&!i?1:0;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const u=t<r?this.getPathStart(t):h;for(let e=0,g=this.m_description.getAttributeCount();e<g;e++){const t=this.m_description.getSemantics(e),n=s.getDescription().getAttributeIndex(t),r=Ia.getComponentCount(t);if(n>=0&&s.m_vertexAttributes.get(n))0!==m&&this.m_vertexAttributes.get(e).insertRangeFromStream(u*r,s.m_vertexAttributes.get(n),r*o,r,!0,r,r*h),this.m_vertexAttributes.get(e).insertRangeFromStream((u+m)*r,s.m_vertexAttributes.get(n),r*(o+m),r*(a-m),i,r,r*(h+m));else{const s=Ia.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(u*r,s,r*a,r*h)}}const l=h+a;this.m_paths.add(l);for(let e=r;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+a)}this.m_pathFlags.add(0);for(let e=r-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let c=s.getPathFlagsStreamRef().read(n);if(c&=-9,this.m_bPolygon&&(c|=1),this.m_pathFlags.write(t,c),s.hasNonLinearSegments()){this.initSegmentData(0);let t=o,e=0;for(let n=0;n<a;n++){e+=Ys(s.m_curveData.m_segmentFlags.read(t)),t++}if(e>0){null===this.m_curveData.m_segmentFlags?(this.m_curveData.m_segmentFlags=z(this.m_pointCount,1),this.m_curveData.m_segmentParamIndex=R(this.m_pointCount,-1)):(this.m_curveData.m_segmentFlags.insertRange(u,1,a,h),this.m_curveData.m_segmentParamIndex.insertRange(u,-1,a,h)),this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams.resize(this.m_curveData.m_curveParamWritePoint+e):this.m_curveData.m_segmentParams=k(e),t=o;let n=u,i=0;for(let e=0;e<a;e++){const e=s.m_curveData.m_segmentFlags.read(t);if(Ya.isNonLinearSegmentFlag(e)){this.m_curveData.m_segmentFlags.write(n,e),this.m_curveData.m_segmentParamIndex.write(n,this.m_curveData.m_curveParamWritePoint);const r=Ys(e);let o=s.m_curveData.m_segmentParamIndex.read(t);for(let t=0;t<r;t++){const t=s.m_curveData.m_segmentParams.read(o);this.m_curveData.m_segmentParams.write(this.m_curveData.m_curveParamWritePoint,t),this.m_curveData.m_curveParamWritePoint++,o++}i++,this.incCurveType(e,1)}t++,n++}this.modifyCurveCounter(i)}}return this.notifyModifiedFlags(2001),t}insertPath2D(t,s,n,i,r){const o=this.getPathCount();(t>o||n<0)&&e(""),t<0&&(t=o),this.m_bPathStarted=!1;const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+i),0===i&&this.notifyModifiedFlags(32),this.verifyAllStreamsAfterSizeChange();const h=t<o?this.getPathStart(t):a;if(s)this.m_vertexAttributes.get(0).insertRangeFromPoints(2*h,s,n,i,r,2*a);else{const t=Ia.getDefaultValue(0);this.m_vertexAttributes.get(0).insertRange(2*h,t,2*i,2*a)}for(let e=1,m=this.m_description.getAttributeCount();e<m;e++){const t=this.m_description.getSemantics(e),s=Ia.getComponentCount(t),n=Ia.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(h*s,n,s*i,s*a)}this.m_paths.add(this.m_pointCount);for(let e=o;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+i)}this.m_pathFlags.add(0);for(let e=o-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}return this.m_bPolygon&&this.m_pathFlags.write(t,1),this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h,1,i,a),this.m_curveData.m_segmentParamIndex.insertRange(h,-1,i,a)),this.notifyModifiedFlags(2001),t}insertPathFromMultipoint(t,s,n,i,r){const o=s.getImpl(),a=this.getPathCount();(t>a||n<0)&&e("");const h=i<0?o.getPointCount()-n:i;if(h>o.getPointCount()&&e(""),n>=o.getPointCount()&&e("pointsOffset"),t<0&&(t=a),this.m_bPathStarted=!1,this.mergeVertexDescription(o.getDescription()),0===h)return void this.insertPath2D(t,null,0,0,!0);const m=this.m_pointCount,u=n;this.resizeImpl(this.m_pointCount+h),this.verifyAllStreamsAfterSizeChange();const l=t<a?this.getPathStart(t):m;for(let e=0,d=this.m_description.getAttributeCount();e<d;e++){const t=this.m_description.getSemantics(e),s=o.getDescription().getAttributeIndex(t),n=Ia.getComponentCount(t);if(s>=0){const s=o.getAttributeStreamRef(t);this.m_vertexAttributes.get(e).insertRangeFromStream(l*n,s,n*u,n*h,r,n,n*m)}else{const s=Ia.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(l*n,s,n*h,n*m)}}const c=m+h;this.m_paths.add(c);for(let e=a;e>=t+1;e--){const t=this.m_paths.read(e-1);this.m_paths.write(e,t+h)}this.m_pathFlags.add(0);for(let e=a-1;e>=t+1;e--){let t=this.m_pathFlags.read(e);t&=-9,this.m_pathFlags.write(e+1,t)}let g=0;this.m_bPolygon&&(g|=1),this.m_pathFlags.write(t,g),this.notifyModifiedFlags(2001)}insertPoints(t,s,i,r,o,a,h){if(this===i&&e("Multi_path_impl.insert_points"),t<0&&(t=this.getPathCount()),r<0&&(r=i.getPathCount()-1),(t>this.getPathCount()||s>=0&&s>this.getPathSize(t)||r>=i.getPathCount()||a>i.getPathSize(r))&&n(""),!a)return;if(this.mergeVertexDescription(i.m_description),t===this.getPathCount()){this.m_paths.add(this.m_pointCount);let t=i.m_pathFlags.read(r);t&=-9,this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}s<0&&(s=this.getPathSize(t));const m=this.m_pointCount;this.resizeImpl(this.m_pointCount+a),this.verifyAllStreamsAfterSizeChange();const u=this.getPathStart(t),l=u+s;a<0&&(a=i.getPathSize(r));const c=i.getPathStart(r),g=c+a;for(let e=0,n=this.m_description.getAttributeCount();e<n;e++){const t=this.m_description.getSemantics(e),n=Ia.getComponentCount(t),r=i.m_description.getAttributeIndex(t);if(r<0||!i.m_vertexAttributes.get(r)){const s=Ia.getDefaultValue(t);this.m_vertexAttributes.get(e).insertRange(n*l,s,g*n,n*m)}else this.m_vertexAttributes.get(e)?.insertRangeFromStream(n*(u+s),i.m_vertexAttributes.get(r),n*(c+o),a*n,h,n,n*m)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(u+s,1,a,m),this.m_curveData.m_segmentParamIndex.insertRange(u+s,-1,a,m),s>0&&this.isNonLinearSegment(u+s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(u+s-1),-1),this.m_curveData.m_segmentFlags.write(u+s-1,1),this.m_curveData.m_segmentParamIndex.write(u+s-1,-1),this.modifyCurveCounter(-1)));for(let e=t+1,n=this.getPathCount();e<=n;e++){const t=this.m_paths.read(e);this.m_paths.write(e,t+a)}this.notifyModifiedFlags(2001)}insertPointsFromPoints(t,e,s,i,r,o){if(t<0&&(t=this.getPathCount()),(t>this.getPathCount()||e>this.getPathSize(t)||i<0)&&n(""),!r)return;t===this.getPathCount()&&(this.m_paths.add(this.m_pointCount),this.m_bPolygon?this.m_pathFlags.add(1):this.m_pathFlags.add(0)),e<0&&(e=this.getPathSize(t));const a=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const h=this.getPathStart(t);this.m_vertexAttributes.get(0).insertRangeFromPoints(2*(h+e),s,i,r,o,2*a);for(let n=1,m=this.m_description.getAttributeCount();n<m;n++){const t=this.m_description.getSemantics(n),s=Ia.getComponentCount(t),i=Ia.getDefaultValue(t);this.m_vertexAttributes.get(n).insertRange((h+e)*s,i,s*r,s*a)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(h+e,1,r,a),this.m_curveData.m_segmentParamIndex.insertRange(h+e,-1,r,a),e>0&&this.isNonLinearSegment(h+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(h+e-1),-1),this.m_curveData.m_segmentFlags.write(h+e-1,1),this.m_curveData.m_segmentParamIndex.write(h+e-1,-1),this.modifyCurveCounter(-1)));for(let n=t+1,m=this.getPathCount();n<=m;n++)this.m_paths.write(n,this.m_paths.read(n)+r);this.notifyModifiedFlags(2001)}insertPointsFromMultipoint(t,e,s,i,r,o){const a=s.getImpl(),h=this.getPathCount();t<0&&(t=this.getPathCount());const m=a.getPointCount();if((i<0||i>m)&&n(""),(r<0||i+r>m)&&(r=m-i),e<0&&(e=t<h?this.getPathSize(t):0),(t>h||t<h&&e>this.getPathSize(t)||t===h&&e>0||r<0)&&n(""),!r)return;if(this.mergeVertexDescription(a.getDescription()),t===h){this.m_paths.add(this.m_pointCount);const t=0;this.m_bPolygon?this.m_pathFlags.add(1|t):this.m_pathFlags.add(t)}e<0&&(e=this.getPathSize(t));const u=this.m_pointCount;this.resizeImpl(this.m_pointCount+r),this.verifyAllStreamsAfterSizeChange();const l=this.getPathStart(t),c=l+e,g=0,d=g+r;for(let n=0,_=this.m_description.getAttributeCount();n<_;n++){const t=this.m_description.getSemantics(n),s=Ia.getComponentCount(t);if(a.getDescription().getAttributeIndex(t)<0){const e=Ia.getDefaultValue(t);this.m_vertexAttributes.get(n).insertRange(s*c,e,d*s,s*u);continue}const h=a.getAttributeStreamRef(t);this.m_vertexAttributes.get(n).insertRangeFromStream(s*(l+e),h,s*(g+i),r*s,o,s,s*u)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(l+e,1,r,u),this.m_curveData.m_segmentParamIndex.insertRange(l+e,-1,r,u),e>0&&this.isNonLinearSegment(l+e-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(l+e-1),-1),this.m_curveData.m_segmentFlags.write(l+e-1,1),this.m_curveData.m_segmentParamIndex.write(l+e-1,-1),this.modifyCurveCounter(-1)));for(let n=t+1,_=this.getPathCount();n<=_;n++){const t=this.m_paths.read(n);this.m_paths.write(n,t+r)}this.notifyModifiedFlags(2001)}insertPoint2D(t,e,s){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&e>this.getPathSize(t))&&n(""),t===i&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o,h=this.m_vertexAttributes.get(0);if(a===r)this.m_paths.write(t+1,r+1),h.writePoint2D(2*a,s);else{h.insert(2*a,s,2*r);for(let t=1,e=this.m_description.getAttributeCount();t<e;t++){const e=this.m_description.getSemantics(t),s=Ia.getComponentCount(e),n=Ia.getDefaultValue(e);this.m_vertexAttributes.get(t).insertRange(s*a,n,s,s*r)}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let e=t+1,s=i;e<=s;e++)this.m_paths.write(e,this.m_paths.read(e)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}insertPoint(t,e,s){const i=this.getPathCount();t<0&&(t=i),(t>i||t<i&&e>this.getPathSize(t))&&n(""),t===i&&this.addPathPoint2D(null,0,!0);const r=this.m_pointCount;this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();const o=this.getPathStart(t),a=e<0?this.getPathSize(t)+o:e+o;if(a===r)this.m_paths.write(t+1,r+1),this.setPointByVal(a,s);else{const e=s.getDescription();this.m_description!==e&&this.mergeVertexDescription(e);for(let t=0,n=this.m_description.getAttributeCount();t<n;t++){const n=this.m_description.getSemantics(t),i=Ia.getComponentCount(n);if(e.hasAttribute(n))this.m_vertexAttributes.get(t).insertAttributes(i*a,s,n,i*r);else{const e=Ia.getDefaultValue(n);this.m_vertexAttributes.get(t).insertRange(i*a,e,i,i*r)}}this.m_curveData&&this.m_curveData.m_segmentFlags&&(this.m_curveData.m_segmentFlags.insertRange(a,1,1,r),this.m_curveData.m_segmentParamIndex.insertRange(a,-1,1,r));for(let s=t+1,n=i;s<=n;s++)this.m_paths.write(s,this.m_paths.read(s)+1)}this.m_curveData&&this.m_curveData.m_segmentFlags&&a>o&&this.isNonLinearSegment(a-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(a-1),-1),this.modifyCurveCounter(-1),this.m_curveData.m_segmentFlags.write(a-1,1),this.m_curveData.m_segmentParamIndex.write(a-1,-1)),this.notifyModifiedFlags(2001)}removePointFromPath(t,e){const s=this.getPathCount();t<0&&(t=s-1),(t>=s||e>=this.getPathSize(t))&&n("Multi_path.remove_point");const i=this.getPathStart(t),r=this.isClosedPath(t);e<0&&(e=this.getPathSize(t)-1),e<0&&n("Multi_path.remove_point");const o=i+e;for(let n=0,a=this.m_description.getAttributeCount();n<a;n++)if(this.m_vertexAttributes.get(n)){const t=this.m_description.getSemantics(n),e=Ia.getComponentCount(t);this.m_vertexAttributes.get(n).eraseRange(e*o,e,e*this.m_pointCount)}if(this.m_curveData&&this.m_curveData.m_segmentFlags){this.checkCompactSegmentParams();let e=0;if(o>i&&this.isNonLinearSegment(o-1))e+=1,this.incCurveType(this.m_curveData.m_segmentFlags.read(o-1),-1),this.m_curveData.m_segmentFlags.write(o-1,1),this.m_curveData.m_segmentParamIndex.write(o-1,-1);else{const s=this.getPathEnd(t);r&&i+1<s&&this.isNonLinearSegment(s-1)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(s-1),-1),this.m_curveData.m_segmentFlags.write(s-1,1),this.m_curveData.m_segmentParamIndex.write(s-1,-1),e+=1)}this.isNonLinearSegment(o)&&(this.incCurveType(this.m_curveData.m_segmentFlags.read(o),-1),e+=1),e>0&&this.modifyCurveCounter(-e),this.m_curveData.m_segmentFlags.eraseRange(o,1,this.m_pointCount),this.m_curveData.m_segmentParamIndex.eraseRange(o,1,this.m_pointCount)}for(let n=s;n>=t+1;n--){const t=this.m_paths.read(n);this.m_paths.write(n,t-1)}this.m_pointCount--,this.m_reservedPointCount--,this.notifyModifiedFlags(2001)}removePoint(t){let e;e=t<0?this.getPathCount()-1:this.getPathIndexFromPointIndex(t),this.removePointFromPath(e,t-this.getPathStart(e))}getNumberOfCurves(t){if(!this.hasNonLinearSegments())return 0;let e=0;for(let s=this.getPathStart(t),n=this.getPathEnd(t);s<n;s++)Ya.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(s))&&++e;return e}getPathCount(){return this.m_paths?this.m_paths.size()-1:0}getPathSize(t){return this.m_paths.read(t+1)-this.m_paths.read(t)}getPathStart(t){return this.m_paths.read(t)}getPathEnd(t){return this.m_paths.read(t+1)}getPathIndexFromPointIndex(t,e=-1){-1===e&&(e=this.m_currentPathIndex);const s=this.getPathCount(),n=Ya.getPathIndexFromPointIndexImpl(this.m_paths,s,t,e);return this.m_currentPathIndex=n,n}startPathCoords(t,e){this.startPathPoint(new N({x:t,y:e}))}startPath(t){this.startPathPoint(new N({pt:t}))}startPath3D(t){this.startPathPoint(new N({x:t.x,y:t.y,z:t.z}))}startPath3DCoords(t,e,s){this.startPathPoint(new N({x:t,y:e,z:s}))}startPathPoint(t){t.isEmpty()&&e("");const s=t.getDescription();let n;if(this.m_description!==s){this.mergeVertexDescription(s);const e=new N({vd:this.m_description});t.copyCommonAttributesTo(e),n=e}else n=t;this.m_bPathStarted?this.setPointByVal(this.m_pointCount-1,n):(this.insertPoint(-1,-1,n),this.m_bPathStarted=!0)}beforeNewSegmentHelper2(){this.m_paths=R(2),this.m_paths.write(0,0),this.m_pathFlags=z(2,0),this.m_bPolygon&&this.m_pathFlags.write(0,1)}beforeNewSegmentHelper1(){null!==this.m_paths?(this.m_paths.add(0),this.m_pathFlags.add(0),this.m_bPolygon&&this.m_pathFlags.write(this.m_pathFlags.size()-2,1)):this.beforeNewSegmentHelper2()}beforeNewSegment(t){0!==this.m_pointCount||this.m_bPathStarted||this.startPathCoords(0,0);const e=this.m_pointCount,s=this.m_paths.size()-1,n=e+t;this.m_paths.write(s,n),this.resizeImpl(n),this.m_bPathStarted&&(this.m_bPathStarted=!1)}finishLineTo(){if(this.hasNonLinearSegments()){const t=this.m_curveData.m_segmentFlags.read(this.m_pointCount-1);1!==t&&(this.m_curveData.m_segmentFlags.write(this.m_pointCount-1,1),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-1,-1),this.modifyCurveCounter(-1),this.incCurveType(t,-1))}}lineToCoords(t,e){if(this.beforeNewSegment(1),1===this.m_description.getAttributeCount())this.setXYCoords(this.m_pointCount-1,t,e);else{const s=b(),n=new N({vd:this.m_description,attribBuffer:s,initDefaultValues:!0});n.setXYCoords(t,e),this.setPointByVal(this.m_pointCount-1,n)}this.finishLineTo()}lineTo(t){this.lineToCoords(t.x,t.y)}lineTo3D(t){this.beforeNewSegment(1);const e=y(this.m_description,X()),s=b(),n=new N({vd:e,attribBuffer:s,initDefaultValues:!0});n.setXYZ(t),this.setPointByVal(this.m_pointCount-1,n),this.finishLineTo()}lineTo3DCoords(t,e,s){this.lineTo3D(new Y(t,e,s))}lineToPoint(t){if(this.beforeNewSegment(1),this.m_description===t.getDescription())this.setPointByVal(this.m_pointCount-1,t);else{this.mergeVertexDescription(t.getDescription());const e=b(),s=new N({vd:this.m_description,attribBuffer:e,initDefaultValues:!1});t.copyCommonAttributesTo(s),this.setPointByVal(this.m_pointCount-1,s)}this.finishLineTo()}openPathAndDuplicateStartVertex(t){this.m_bPolygon&&h("");const s=this.getPathCount();if(t>s&&e(""),!this.isClosedPath(t))return;this.m_pathFlags||h("");const n=this.m_pointCount,i=this.getPathStart(t),r=this.getPathEnd(t);if(r-i!=0){this.resizeImpl(this.m_pointCount+1),this.verifyAllStreamsAfterSizeChange();for(let t=0,e=this.m_description.getAttributeCount();t<e;t++)if(this.m_vertexAttributes.get(t)){const e=this.m_description.getSemantics(t),s=Ia.getComponentCount(e);this.m_vertexAttributes.get(t).insertRangeFromStream(s*r,this.m_vertexAttributes.get(t),s*i,s,!0,1,s*n)}for(let e=s;e>t;e--){const t=this.m_paths.read(e);this.m_paths.write(e,t+1)}this.hasNonLinearSegments()&&(this.m_curveData.m_segmentFlags.insertRange(r,1,1,n),this.m_curveData.m_segmentParamIndex.insertRange(r,-1,1,n)),this.m_pathFlags.clearBits(t,1)}}openPath(t){this.m_bPolygon&&h(""),t>this.getPathCount()&&e(""),this.m_pathFlags||h(""),this.m_pathFlags.clearBits(t,1)}isStrongPathStart(t){return!!(2&this.m_pathFlags.read(t))}setStrongPathStart(t,e){e?this.m_pathFlags.setBits(t,2):this.m_pathFlags.clearBits(t,2)}isStrongPathEnd(t){return!!(4&this.m_pathFlags.read(t))}setStrongPathEnd(t,e){e?this.m_pathFlags.setBits(t,4):this.m_pathFlags.clearBits(t,4)}clearStrongPathEnds(){for(let t=0,e=this.getPathCount();t<e;++t)this.m_pathFlags.clearBits(t,6)}openAllPathsAndDuplicateStartVertex(){if(this.m_bPolygon&&h(""),this.isEmpty())return;this.m_pathFlags||h("");let t=0;const e=this.getPathCount();for(let h=0;h<e;h++)this.isClosedPath(h)&&(this.getPathSize(h)>0?t++:this.m_pathFlags.clearBits(h,1));if(0===t)return;const s=this.hasNonLinearSegments();let n=0;const i=this.getPathCount(),r=this.m_description.getAttributeCount(),o=new Array(r);let a=null,m=null;for(let h=0;h<i;++h){const e=this.getPathStart(h),i=this.getPathSize(h),u=this.isClosedPath(h);if(i>0){const h=e+n;for(let s=0;s<r;s++)if(this.m_vertexAttributes.get(s)){const n=this.m_description.getSemantics(s),r=Ia.getComponentCount(n);if(!o[s]){const e=r*(this.m_pointCount+t),i=T(n,e);o[s]=i}o[s].writeRange(h*r,i*r,this.m_vertexAttributes.get(s),e*r,!0,1),u&&o[s].writeRange((h+i)*r,r,this.m_vertexAttributes.get(s),e*r,!0,1)}if(s){if(null===a){const e=this.m_pointCount+t;a=z(e),m=R(e)}a.writeRange(h,i,this.m_curveData.m_segmentFlags,e,!0,1),m.writeRange(h,i,this.m_curveData.m_segmentParamIndex,e,!0,1),u&&(a.write(h+i,1),m.write(h+i,-1))}}this.m_paths.write(h,e+n),u&&(this.m_pathFlags.clearBits(h,1),++n)}this.m_paths.write(i,this.m_pointCount+t),this.m_pathFlags.clearBits(i,1);for(let h=0;h<r;h++)this.m_vertexAttributes.get(h)&&this.m_vertexAttributes.set(h,o[h]);s&&(this.m_curveData.m_segmentFlags=a,this.m_curveData.m_segmentParamIndex=m),this.m_pointCount+=t,this.m_reservedPointCount>0&&(this.m_reservedPointCount=this.m_pointCount)}closePathWithLine(t){void 0===t&&(t=this.getPathCount()-1),this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e("close_path_with_line"),t===this.getPathCount()-1&&(this.m_bPathStarted=!1);const s=this.m_pathFlags.read(t);if(1&s||this.m_pathFlags.write(t,1|s),this.m_curveData&&this.m_curveData.m_segmentFlags){const e=this.getPathEnd(t)-1,s=this.m_curveData.m_segmentFlags.read(e);1!==s&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),1!==s&&(this.incCurveType(s,-1),this.modifyCurveCounter(-1)))}this.notifyModifiedFlags(2001)}closeLastPathWithSegment(t){this.closePathWithSegment(this.getPathCount()-1,t)}closePathWithSegment(t,s){if(this.throwIfEmpty(),(t<0||t>=this.getPathCount())&&e("close_path_with_line"),s.getEndXY().equals(this.getXY(this.getPathStart(t)))||e("close_path_with_segment: end point mismatch"),t===this.getPathCount()-1)this.m_bPathStarted=!1,this.addSegment(s,!1),--this.m_pointCount,this.m_paths.write(t+1,this.m_pointCount);else{this.mergeVertexDescription(s.getDescription());const n=s.getStartXY(),r=this.getPathEnd(t)-1;n.equals(this.getXY(r))||e("close_path_with_segment: start point mismatch");const o=s.getGeometryType();if(o===i.enumLine)return void this.closePathWithLine(t);{const t=Ms(s);this.initSegmentData(t);const e=Ma.toSegType(o),n=this.m_curveData.m_segmentFlags.read(r);if(n!==e)this.m_curveData.m_segmentParamIndex.write(r,this.m_curveData.m_curveParamWritePoint),s.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=t,this.incCurveType(e,1),1!==n?this.incCurveType(n,-1):this.modifyCurveCounter(1);else{const t=this.m_curveData.m_segmentParamIndex.read(r);s.writeInBufferStream(this.m_curveData.m_segmentParams,t)}this.m_curveData.m_segmentFlags.write(r,e)}}const n=this.m_pathFlags.read(t);1&n||this.m_pathFlags.write(t,1|n),this.notifyModifiedFlags(2001)}closeAllPaths(){if(this.m_bPolygon||this.isEmptyImpl())return;this.m_bPathStarted=!1;let t=!1;for(let e=0,s=this.m_paths.size()-1;e<s;e++){if(this.isClosedPath(e))continue;const s=this.m_pathFlags.read(e);this.m_pathFlags.write(e,1|s),t=!0}t&&this.notifyModifiedFlags(512)}isClosedPath(t){return!!(1&this.m_pathFlags.read(t))}isClosedPathInXYPlane(t){if(this.isClosedPath(t))return!0;const e=this.getPathStart(t),s=this.getPathEnd(t)-1;if(e>s)return!1;const n=this.getXY(e),i=this.getXY(s);return n.isEqualPoint2D(i)}isClosedPathIn3D(t){return s(0),!1}hasNonLinearSegmentsPath(t){if(!this.hasNonLinearSegments())return!1;for(let e=this.getPathStart(t),s=this.getPathEnd(t);e<s;e++)if(Ya.isNonLinearSegmentFlag(this.m_curveData.m_segmentFlags.read(e)))return!0;return!1}isNonLinearSegment(t){return!(1&this.getSegmentFlags(t))}addEnvelope(t,e){if(t.isEmpty())return;const s=0===this.m_pointCount;if(t instanceof oe)this.startPathCoords(t.xmin,t.ymin),e?(this.lineToCoords(t.xmax,t.ymin),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmin,t.ymax)):(this.lineToCoords(t.xmin,t.ymax),this.lineToCoords(t.xmax,t.ymax),this.lineToCoords(t.xmax,t.ymin));else{const s=t.getDescription(),n=b(),i=new N({vd:s,attribBuffer:n,initDefaultValues:!1});for(let r=0,o=4;r<o;r++){const s=e?o-r-1:r;t.queryCornerByVal(s,i),0===r?this.startPathPoint(i):this.lineToPoint(i)}}this.closePathWithLine(),this.m_bPathStarted=!1,s&&!e&&(this.setDirtyFlagProtected(256,!1),this.m_bPolygon&&Math.min(t.width(),t.height())>0&&this.setIsSimple(3,0))}addPathFromClosedSegment(t,s){if(t.isClosed()||e("add_path_from_closedSegment: segment must be closed"),s){const e=t.getReversed(),s=new N;e.queryStart(s),this.startPathPoint(s),this.closeLastPathWithSegment(e)}else{const e=new N;t.queryStart(e),this.startPathPoint(e),this.closeLastPathWithSegment(t)}}addSegment_(t,s){const n=t.getDescription();this.mergeVertexDescription(n);const r=b(),o=new N({vd:n,attribBuffer:r,initDefaultValues:!1}),a=t.getGeometryType();if(a===i.enumLine)(s||this.isEmptyImpl())&&(t.queryStart(o),this.startPathPoint(o)),t.queryEnd(o),this.lineToPoint(o);else{let n=!1;if((s||this.isEmptyImpl())&&(n=!0),!n){t.getStartXY().equals(this.getXY(this.m_pointCount-1))||e("add_segment: start point mismatch")}if(n&&(t.queryStart(o),this.startPathPoint(o)),this.beforeNewSegment(1),t.queryEnd(o),o.getDescription()===this.m_description)this.setPointByVal(this.m_pointCount-1,o);else{const t=b(),e=new N({vd:this.m_description,attribBuffer:t,initDefaultValues:!1});o.copyCommonAttributesTo(e),this.setPointByVal(this.m_pointCount-1,e)}const i=Ms(t);this.initSegmentData(i),this.m_curveData.m_segmentParamIndex.write(this.m_pointCount-2,this.m_curveData.m_curveParamWritePoint),t.writeInBufferStream(this.m_curveData.m_segmentParams,this.m_curveData.m_curveParamWritePoint),this.m_curveData.m_curveParamWritePoint+=i;const r=Ma.toSegType(a);this.incCurveType(r,1),this.modifyCurveCounter(1),this.m_curveData.m_segmentFlags.write(this.m_pointCount-2,r)}}addSegment(t,e,s){s?e?this.addPathFromClosedSegment(t,!1):this.closeLastPathWithSegment(t):this.addSegment_(t,e)}interpolateAttributesRange(t,s,n,i){for(let a=t;a<n-1;a++)this.isClosedPath(a)&&e("cannot interpolate across closed paths");const r=this.m_description.getAttributeCount();if(1===r)return;const o=this.calculateSubLength2D(t,s,n,i);if(0!==o)for(let e=1;e<r;e++){const r=this.m_description.getSemantics(e);this.interpolateAttributesSemanticsImpl(r,t,s,n,i,o)}}interpolateAttributesSemantics(t,s,n,i,r){if(0===t)return;this.hasAttribute(t)||e("does not have the given attribute");2===Ia.getInterpolation(t)&&e("angular interpolation");for(let a=s;a<i-1;a++)this.isClosedPath(a)&&e("cannot interpolate across closed paths");const o=this.calculateSubLength2D(s,n,i,r);0!==o&&this.interpolateAttributesSemanticsImpl(t,s,n,i,r,o)}interpolateAttributesPath(t,e,s){const n=this.m_description.getAttributeCount();if(1===n)return;if(e===s)return;const i=this.calculatePathSubLength2D(t,e,s);for(let r=1;r<n;r++){const n=this.m_description.getSemantics(r);this.interpolateAttributesSemanticsPathImpl(n,t,e,s,i)}}interpolateAttributesSemanticsPath(t,s,n,i){if(0===t)return;this.hasAttribute(t)||e("does not have the given attribute");2===Ia.getInterpolation(t)&&e("angular interpolation");const r=this.calculatePathSubLength2D(s,n,i);0!==r&&this.interpolateAttributesSemanticsPathImpl(t,s,n,i,r)}interpolateAttributesSemanticsImpl(t,e,s,n,i,r){const o=this.querySegmentIterator(),a=this.getPathStart(e)+s,h=this.getPathStart(n)+i,m=Ia.getComponentCount(t),u=O(Ia.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,a,u,m);const l=O(Ia.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,l,m);const c=O(Ia.maxComponentCount(),Number.NaN);K(c,u,0,0,m);let g=0;const d=Ia.getDefaultValue(t),_=Ia.getInterpolation(t);o.resetToVertex(a,e);do{if(o.hasNextSegment()){if(o.nextSegment(),o.getStartPointIndex()===h)return;this.setAttributeFromArray(t,o.getStartPointIndex(),c,m),o.previousSegment();do{const e=o.nextSegment();if(o.getEndPointIndex()===h)return;g+=e.calculateLength2D();Q(_,u,l,c,0,m,g/r,d),o.isClosingSegment()||this.setAttributeFromArray(t,o.getEndPointIndex(),c,m)}while(o.hasNextSegment())}}while(o.nextPath())}interpolateAttributesSemanticsPathImpl(t,e,s,n,i){const r=this.querySegmentIterator(),o=Ia.getInterpolation(t),a=this.getPathStart(e)+s,h=this.getPathStart(e)+n;if(h===a)return;const m=Ia.getComponentCount(t),u=O(Ia.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,a,u,m);const l=O(Ia.maxComponentCount(),Number.NaN);this.queryAttributeAsDbl(t,h,l,m);const c=new ct(0);r.resetToVertex(a,e),r.setCirculator(this.isClosedPath(e));const g=Ia.getDefaultValue(t),d=O(Ia.maxComponentCount(),Number.NaN);K(d,u,0,0,m);const _=0===i;let p=.5;do{const e=r.nextSegment();if(this.setAttributeFromArray(t,r.getStartPointIndex(),d,m),!_){const t=e.calculateLength2D();c.pe(t),p=c.getResult()/i}Q(o,u,l,d,0,m,p,g)}while(r.getEndPointIndex()!==h)}querySegment(t,s,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&e("get_segment"),this.getSegmentFromPath(i,r,s,n)}getSegment(t,e){const s=new this.m_segmentBufferCTor;return this.getSegmentBuffer(t,s,e),s.releaseSegment()}getSegmentType(t){const s=this.getPathIndexFromPointIndex(t),n=t-this.getPathStart(s);return n>=this.getSegmentCountPath(s)&&e("get_segment"),this.getSegmentTypeFromPath(s,n)}getSegmentFromPath(t,e,s,n){const i=this.getPathStart(t)+e,r=this.getSegmentFlagsStreamRef();let o=1;switch(r&&(o=31&r.read(i)),o){case 1:s.createLine();break;case 2:s.createCubicBezier();break;case 4:s.createEllipticArc();break;case 8:s.createQuadraticRationalBezier();break;case 16:s.createQuadraticBezier();break;default:h("")}const a=s.get();let m,u=null;n?(u=f(),a.assignVertexDescription(u)):a.assignVertexDescription(this.m_description),m=i===this.getPathEnd(t)-1&&this.isClosedPath(t)?this.getPathStart(t):i+1;Ne(a,this.getXY(i));if(Fe(a,this.getXY(m)),!n)for(let h=1,l=this.m_description.getAttributeCount();h<l;h++){const t=this.m_description.getSemantics(h),e=Ia.getComponentCount(t);for(let s=0;s<e;s++){const e=this.getAttributeAsDbl(t,i,s);a.setStartAttribute(t,s,e);const n=this.getAttributeAsDbl(t,m,s);a.setEndAttribute(t,s,n)}}if(Ya.isNonLinearSegmentFlag(o)){const t=this.m_curveData.m_segmentParamIndex.read(i);a.readFromBufferStream(this.m_curveData.m_segmentParams,t)}}replaceLinearEllipticalArcsWithTrueLines(){if(!this.hasNonLinearSegments())return!1;if(0===this.m_curveData.m_arcCount)return!1;let t=!1;for(let e=0,s=this.getPointCount();e<s;e++){if(4===this.m_curveData.m_segmentFlags.read(e)){const s=this.m_curveData.m_segmentParamIndex.read(e);Is(this.m_curveData.m_segmentParams,s).isNAN()&&(this.m_curveData.m_segmentFlags.write(e,1),this.m_curveData.m_segmentParamIndex.write(e,-1),this.incCurveType(4,-1),this.modifyCurveCounter(-1),t=!0)}}return t&&this.checkCompactSegmentParams(),t}queryPointAlongPath(t,s,n,i=!1){const r={iSegment:-1},o=i?r:{iSegment:-1,tSegment:0};if(n.setEmpty(),this.isEmpty())return r;if((t<0||t>=this.getPathCount())&&e("query_point_along_path"),s<0)return r;const a=this.getPathSize(t);if(0===a)return r;if(1===a)return this.getPointByVal(this.getPathStart(t),n),o.tSegment=0,r.iSegment=this.getPathStart(t),r;const h=this.querySegmentIteratorAtVertex(this.getPathStart(t)),m=new ct(0);for(;h.hasNextSegment();){const t=h.nextSegment(),e=t.calculateLength2D(),i=m.getResult();if(m.add(e),m.getResult()>=s){let a=s-i;a>e&&(a=e);const m=t.lengthToT(a);return t.queryCoord(m,n),o.tSegment=m,r.iSegment=h.getStartPointIndex(),r}}if(this.isClosedPath(t)){const e=this.getPathStart(t);return this.getPointByVal(e,n),o.tSegment=1,r.iSegment=this.getPathEnd(t)-1,r}{const e=this.getPathEnd(t)-1;return this.getPointByVal(e,n),this.getPathSize(t)>1?(o.tSegment=1,r.iSegment=this.getPathEnd(t)-2,r):(o.tSegment=0,r.iSegment=this.getPathStart(t),r)}}queryPointsAlongPath(t,s,n,i,r,o){{let t=0;for(let a=0;a<s;++a)i&&i[a].setEmpty(),r&&(r[a]=-1),o&&(o[a]=0),t>n[a]&&e("query_points_along"),t=n[a]}const a=this.getPathSize(t);if(0===s||0===a)return 0;if(1===a){const e=this.getPathStart(t);return i&&this.getPointByVal(e,i[0]),o&&(o[0]=0),r&&(r[0]=e),1}const h=this.getPathStart(t),m=new ct(0),u=this.querySegmentIteratorAtVertex(h);let l=0,c=0,g=n[l];for(;u.hasNextSegment();){const t=u.nextSegment(),e=t.calculateLength2D(),a=m.getResult();for(m.add(e);m.getResult()>=g;){let h=g-a;h>e&&(h=e);const m=t.lengthToT(h);if(i&&t.queryCoord(m,i[c]),o&&(o[c]=m),r&&(r[c]=u.getStartPointIndex()),c++,l++,g=n[l],l===s)return c}}if(this.isClosedPath(t)){const e=this.getPathStart(t),s=0;i&&this.getPointByVal(e,i[c]),o&&(o[c]=s),r&&(r[c]=e),c++}else if(this.getPathSize(t)>1){const e=this.getPathEnd(t)-2,s=1;i&&this.getPointByVal(e+1,i[c]),o&&(o[c]=s),r&&(r[c]=e),c++}return c}queryPointsAlong(t,s,n,i,r){{let o=0;for(let a=0;a<t;++a)n&&n[a].setEmpty(),i&&(i[a]=-1),r&&(r[a]=0),o>s[a]&&e("query_points_along"),o=s[a]}if(0===t)return 0;const o=new ct(0),a=this.querySegmentIterator();let h=-1,m=0,u=0,l=s[m];for(;a.nextPath();)for(;a.hasNextSegment();){h=a.getPathIndex();const e=a.nextSegment(),c=e.calculateLength2D(),g=o.getResult();for(o.add(c);o.getResult()>=l;){let o=l-g;o>c&&(o=c);const h=e.lengthToT(o);if(n&&e.queryCoord(h,n[u]),r&&(r[u]=h),i&&(i[u]=a.getStartPointIndex()),u++,m++,l=s[m],m===t)return u}}if(h<0)return 0;if(this.isClosedPath(h)){const t=this.getPathStart(h),e=0;n&&this.getPointByVal(t,n[u]),r&&(r[u]=e),i&&(i[u]=t),u++}else if(this.getPathSize(h)>1){const t=this.getPathEnd(h)-2,e=1;n&&this.getPointByVal(t+1,n[u]),r&&(r[u]=e),i&&(i[u]=t),u++}return u}querySegmentIterator(){return new Ds({parent:this})}querySegmentIteratorAtVertex(t){return new Ds({parent:this,pointIndex:t})}queryPathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!0)}queryLoosePathEnvelope(t,e){this.queryPathEnvelopeImpl(t,e,!1)}queryPathEnvelopeImpl(t,n,i){if(n instanceof A&&s(0,"not implemented for Envelope"),n instanceof v&&s(0,"not implemented for Envelope3D"),(t>=this.getPathCount()||t<0)&&e(""),this.isEmpty())return void n.setEmpty();const r=this.getAttributeStreamRef(0),o=oe.constructEmpty();o.setEmpty();for(let e=2*this.getPathStart(t),a=2*this.getPathEnd(t);e<a;){const t=a-e;s(!(1&t)),o.mergePointsInterleaved(r,e/2,t/2),e+=t}if(n.setCoords({env2D:o}),this.hasNonLinearSegmentsPath(t)){const e=this.querySegmentIterator();if(e.resetToPath(t),e.nextPath())for(;e.hasNextSegment();){const t=e.nextCurve();if(!t)break;{const e=oe.constructEmpty();i?t.queryEnvelope(e):t.queryLooseEnvelope(e),n.mergeEnvelope2D(e)}}else s(0)}}checkCompactSegmentParams(){if(!this.m_curveData||null===this.m_curveData.m_segmentParams)return!1;if(this.m_curveData.m_segmentParams.size()<=this.m_vertexAttributes.get(0).size())return!1;const t=10,e=Ys(4)*this.m_curveData.m_arcCount+Ys(2)*this.m_curveData.m_bezierCount+Ys(8)*this.m_curveData.m_rbezier2Count+Ys(16)*this.m_curveData.m_bezier2Count;return this.m_curveData.m_segmentParams.size()>Math.max(3*e>>1,t)?(this.forceCompactSegmentParams(),!0):(0===this.m_pointCount&&(this.m_curveData.m_curveParamWritePoint=0),!1)}forceCompactSegmentParams(){let t=0;for(let n=0,i=this.getPointCount();n<i;n++){const e=this.m_curveData.m_segmentFlags.read(n);if(Ya.isNonLinearSegmentFlag(e)){t+=Ys(e)}}const e=k(t);let s=0;for(let n=0,i=this.getPointCount();n<i;n++){const t=this.m_curveData.m_segmentFlags.read(n);if(Ya.isNonLinearSegmentFlag(t)){let i=this.m_curveData.m_segmentParamIndex.read(n);this.m_curveData.m_segmentParamIndex.write(n,s);const r=Ys(t);for(let t=0;t<r;t++)e.write(s,this.m_curveData.m_segmentParams.read(i)),s++,i++}}this.m_curveData.m_segmentParams=e,this.m_curveData.m_curveParamWritePoint=s}setEmpty(){this.m_curveData&&(this.removeAllCurvesFromGlobalCounter(),this.m_curveData=null),this.m_bPathStarted=!1,this.m_paths=null,this.m_pathFlags=null,this.setEmptyImpl()}applyTransformation(t){this.applyTransformationToPath(t,-1)}applyTransformation3D(t){s(0)}getImpl(){return this}reserve(t){this.reserveImpl(t),t>0&&!this.m_paths&&(this.m_paths=R(0),this.m_pathFlags=z(0),this.m_paths.reserve(2),this.m_pathFlags.reserve(2),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0))}reserveParts(t,e){this.reserveImpl(t),e>0&&(this.m_paths?(this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1)):(this.m_paths=R(0),this.m_pathFlags=z(0),this.m_paths.reserve(e+1),this.m_pathFlags.reserve(e+1),this.m_paths.resize(1,0),this.m_pathFlags.resize(1,this.m_bPolygon?1:0)))}clone(){const t=this.createInstance();return this.copyTo(t),t}queryLimitedSegmentIterator(t){return new Xa(this,t)}getPathStreamRef(){return this.throwIfEmpty(),this.m_paths}setPathStreamRef(t){this.m_paths=t}getSegmentFlagsStreamRef(){return this.throwIfEmpty(),null!=this.m_curveData?this.m_curveData.m_segmentFlags:null}getPathFlagsStreamRef(){return this.throwIfEmpty(),this.m_pathFlags}setPathFlagsStreamRef(t){this.m_pathFlags=t}getSegmentIndexStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParamIndex:null}getSegmentDataStreamRef(){return this.throwIfEmpty(),null!==this.m_curveData?this.m_curveData.m_segmentParams:null}setSegmentData(t,e,s,n){this.m_curveData||(this.m_curveData=new Ma),this.m_curveData.m_segmentFlags=s,this.m_curveData.m_segmentParams=e,this.m_curveData.m_segmentParamIndex=t,this.m_curveData.m_curveParamWritePoint=n}static getPathIndexFromPointIndexImpl(t,e,s,n){if(n>=0&&n<e){if(s>=t.read(n)){if(s<t.read(n+1))return n;n++}else n--;if(n>=0&&n<e&&s>=t.read(n)&&s<t.read(n+1))return n}if(e<5){for(let n=0;n<e;n++)if(s<t.read(n+1))return n;g("")}let i=0,r=e-1;for(;r>i;){const e=i+(r-i>>1);if(s<t.read(e))r=e-1;else{if(!(s>=t.read(e+1)))return e;i=e+1}}return i}getHighestPointIndex(t){s(t>=0&&t<this.getPathCount());const e=this.getAttributeStreamRef(0),n=this.getPathEnd(t),i=this.getPathStart(t);let r=-1;const o=new J;o.y=Number.NEGATIVE_INFINITY,o.x=Number.NEGATIVE_INFINITY;for(let s=i+0;s<n;s++){const t=e.readPoint2D(2*s);-1===o.compare(t)&&(r=s,o.setCoordsPoint2D(t))}return r}applyTransformationToPath(t,s){if(s>=this.getPathCount()&&e("apply_transformation"),this.isEmpty())return;if(t.isIdentity())return;const n=this.m_vertexAttributes.get(0);if(!(s<0?this.hasNonLinearSegments():this.hasNonLinearSegmentsPath(s))){let e,i;return s<0?(e=0,i=this.m_pointCount):(e=this.getPathStart(s),i=this.getPathEnd(s)),n.applyTransformation(t,2*e,i-e),void this.notifyModifiedFlags(2001)}const i=new this.m_segmentBufferCTor,r=this.getPathCount();let o=s<0?0:s;do{const e=this.getPathStart(o),r=this.getPathEnd(o),a=this.isClosedPath(o),h=n.readPoint2D(2*e);if(!this.hasNonLinearSegmentsPath(o)){n.applyTransformation(t,2*e,r-e);continue}const m=J.getNAN();for(let s=e;s<r;++s){if(1!==(31&this.m_curveData.m_segmentFlags.read(s))){const o=a&&s+1===r;o&&n.writePoint2D(2*e,h),this.getSegmentBuffer(s,i,!0),i.get().applyTransformation(t);const m=this.m_curveData.m_segmentParamIndex.read(s);i.get().writeInBufferStream(this.m_curveData.m_segmentParams,m),n.writePoint2D(2*s,i.get().getStartXY()),o&&n.writePoint2D(2*e,i.get().getEndXY());continue}const o=2*s;n.queryPoint2D(o,m),t.transformInPlace(m),n.writePoint2D(o,m)}if(o===s)break}while(++o<r);this.notifyModifiedFlags(2001)}calculateSubLength2D(t,e,s,n){const i=this.getPathStart(t)+e,r=this.getPathStart(s)+n;(r<i||i<0||r>this.getPointCount()-1)&&d("");const o=this.querySegmentIterator();let a=0;o.resetToVertex(i,t);do{for(;o.hasNextSegment();){const t=o.nextSegment();if(o.getStartPointIndex()===r)break;a+=t.calculateLength2D()}if(o.getStartPointIndex()===r)break}while(o.nextPath());return a}calculatePathSubLength2D(t,s,n){const i=this.getPathStart(t)+s,r=this.getPathStart(t)+n;(i<0||r>this.getPointCount()-1)&&d("");const o=this.querySegmentIterator();if(i>r&&(this.isClosedPath(t)||e("cannot iterate across an open path"),o.setCirculator(!0)),i===r)return 0;let a=0,h=0;o.resetToVertex(i,t);do{h+=a;a=o.nextSegment().calculateLength2D()}while(o.getStartPointIndex()!==r);return h}calculateEnvelope2D(t){return this.updateXYImpl(t)}updateXYImpl(t){const e=super.updateXYImpl(t);if(this.hasNonLinearSegments()){const s=oe.constructEmpty(),n=this.querySegmentIterator();for(;n.nextPath();)for(;n.hasNextSegment();){const i=n.nextCurve();if(!i)break;t?i.queryEnvelope(s):i.queryLooseEnvelope(s),e.mergeEnvelope2D(s)}}return e}notifyModifiedAllImpl(){null!==this.m_paths&&this.m_paths.size()?this.m_pointCount=this.m_paths.read(this.m_paths.size()-1):this.m_pointCount=0}setDirtyOGCFlags(t){this.setDirtyFlagProtected(16,t)}hasDirtyOGCStartFlags(){return this.hasDirtyFlag(16)}setDirtyRingAreas2D(t){this.setDirtyFlagProtected(1024,t)}hasDirtyRingAreas2D(){return this.hasDirtyFlag(1024)}static isNonLinearSegmentFlag(t){return!(1&t)}addAndExplicitlyOpenAllPaths(t,s){this===t&&e("Multi_path_impl::add");let n=this.getPathCount();for(let e=0,i=t.getPathCount();e<i;e++)this.addPath(t,e,!s),this.openPathAndDuplicateStartVertex(n),n++}getSegmentFlags(t){return null!==this.m_curveData&&null!==this.m_curveData.m_segmentFlags?this.m_curveData.m_segmentFlags.read(t):1}getSegmentBuffer(t,s,n){const i=this.getPathIndexFromPointIndex(t),r=t-this.getPathStart(i);r>=this.getSegmentCountPath(i)&&e("getSegmentBuffer"),this.getSegmentFromPath(i,r,s,n)}getSegmentTypeFromPath(t,e){const s=this.getPathStart(t)+e,n=this.getSegmentFlagsStreamRef();let r=1;switch(n&&(r=31&n.read(s)),r){case 1:return i.enumLine;case 2:return i.enumBezier;case 4:return i.enumEllipticArc;case 8:return i.enumRationalBezier2;case 16:return i.enumBezier2;default:h("")}}ensureXYMonotoneSegments(){if(!this.m_curveData)return!1;let t=!1;for(let e=0,s=this.getPathCount();e<s;e++){const s=this.getPathStart(e),n=this.getPathEnd(e),i=n-s;for(let e=s;e<n;e++){const n=31&this.m_curveData.m_segmentFlags.read(e);if(1===n)continue;2!==n&&a("ensure_xy_monotone_segments");const r=(e-s+1)%i+s,o=this.m_curveData.m_segmentParamIndex.read(e),h=_t(J,4);h[0]=this.getXY(e),h[3]=this.getXY(r),h[1].x=this.m_curveData.m_segmentParams.read(o),h[1].y=this.m_curveData.m_segmentParams.read(o+1),h[2].x=this.m_curveData.m_segmentParams.read(o+2),h[2].y=this.m_curveData.m_segmentParams.read(o+3),zo(h)&&(t=!0,this.m_curveData.m_segmentParams.write(o,h[1].x),this.m_curveData.m_segmentParams.write(o+1,h[1].y),this.m_curveData.m_segmentParams.write(o+2,h[2].x),this.m_curveData.m_segmentParams.write(o+3,h[2].y))}}return t&&this.notifyModifiedFlags(2001),t}buildRasterizedGeometryAccelerator(t,e){return!1}buildQuadTreeAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new ws),null!==this.m_accelerators.getQuadTree())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTree(null);const e=B(this);return this.m_accelerators.setQuadTree(e),!0}buildQuadTreeForPathsAccelerator(t){if(this.m_accelerators||(this.m_accelerators=new ws),null!==this.m_accelerators.getQuadTreeForPaths())return!0;this.ensureUniqueAccelerators(),this.m_accelerators.setQuadTreeForPaths(null);const e=G(this);return this.m_accelerators.setQuadTreeForPaths(e),!0}updateCurveCounter(t){this.modifyCurveCounter(t-this.getCurveCount())}removeAllCurvesFromGlobalCounter(){this.m_curveData&&(Ya.st_totalCurveCount-=this.m_curveData.m_curveCount,this.m_curveData.m_curveCount=0,this.m_curveData.m_bezierCount=0,this.m_curveData.m_arcCount=0,this.m_curveData.m_bezier2Count=0,this.m_curveData.m_rbezier2Count=0,this.m_curveData.m_curveParamWritePoint=0)}modifyCurveCounter(t){t&&(this.m_curveData||(this.m_curveData=new Ma),Ya.st_totalCurveCount+=t,this.m_curveData.m_curveCount+=t)}getCurveCount(){return this.m_curveData?this.m_curveData.m_curveCount:0}incCurveType(t,e){this.m_curveData||(this.m_curveData=new Ma),2&t?this.m_curveData.m_bezierCount+=e:4&t?this.m_curveData.m_arcCount+=e:8&t?this.m_curveData.m_rbezier2Count+=e:16&t&&(this.m_curveData.m_bezier2Count+=e)}getCurveWritePoint(){return null!==this.m_curveData?this.m_curveData.m_curveParamWritePoint:0}initSegmentData(t){null===this.m_curveData&&(this.m_curveData=new Ma);const e=this.m_reservedPointCount>0?this.m_reservedPointCount:this.m_pointCount;null===this.m_curveData.m_segmentParamIndex&&(this.m_curveData.m_segmentFlags=z(e,1),this.m_curveData.m_segmentParamIndex=R(e,-1));const s=this.m_curveData.m_curveParamWritePoint+t;null===this.m_curveData.m_segmentParams?this.m_curveData.m_segmentParams=k(s):s!==this.m_curveData.m_segmentParams.size()&&this.m_curveData.m_segmentParams.resize(s,0),this.m_curveData.m_segmentFlags.size()<e&&(this.m_curveData.m_segmentFlags.resize(e,1),this.m_curveData.m_segmentParamIndex.resize(e,-1))}updateCurveWritePoint(t){null===this.m_curveData&&(this.m_curveData=new Ma),this.m_curveData.m_curveParamWritePoint=t}updateOGCFlagsHelper(){const t=this.getPathCount();if(0===t)return;const e=this.m_pathFlags;let s=0;for(let n=0;n<t;n++){const t=this.m_cachedRingAreas2D.read(n);0===s&&(s=Bt(t)),t*s>0||0===s?e.setBits(n,8):e.clearBits(n,8)}}updateOGCFlagsProtected(){this.hasDirtyFlag(16)&&(this.updateRingAreas2DProtected(),this.updateOGCFlagsHelper(),this.setDirtyFlagProtected(16,!1))}replaceSegment(t,n,i){(t<0||t>=this.getPointCount())&&e("Multi_path_impl.replace_segment"),s(n.isCurve());const r=this.getPathIndexFromPointIndex(t),o=this.getPathStart(r),a=(t-o+1)%this.getPathSize(r)+o;{const e=this.getXY(t),i=this.getXY(a),r=!e.isEqualPoint2D(n.getStartXY())||!i.isEqualPoint2D(n.getEndXY());s(!r)}const h=n.getDescription();this.mergeVertexDescription(h);const m=O(32,Number.NaN),u=new N({vd:h,attribBuffer:m,initDefaultValues:!1}),l=null===this.m_curveData?1:31&this.m_curveData.m_segmentFlags.read(t),c=Ys(l),g=Ms(n);let d,_=!1;c>=g?(s(null!==this.m_curveData),_=!0,d=this.m_curveData.m_segmentParamIndex.read(t)):(this.initSegmentData(g),_=!1,d=this.m_curveData.m_curveParamWritePoint);const p=n.getGeometryType(),f=Ma.toSegType(p);i||(n.queryStart(u),this.setPointByVal(t,u),n.queryEnd(u),this.setPointByVal(a,u)),this.m_curveData.m_segmentParamIndex.write(t,1!==f?d:-1),this.m_curveData.m_segmentFlags.write(t,f),1!==f&&n.writeInBufferStream(this.m_curveData.m_segmentParams,d),_||(this.m_curveData.m_curveParamWritePoint+=g),l!==f&&(this.incCurveType(l,-1),this.incCurveType(f,1),this.modifyCurveCounter(1===l?1:-1))}setAttributeImpl(t,s,n){if(this.addAttribute(t),!this.isEmpty())if(this.hasNonLinearSegments()&&0===t){(s<0||s>1)&&e("");const t=new ae,i=0===s?n:0,r=0===s?0:1;t.setShiftCoords(i,r),0===s?t.xx=0:t.yy=0,this.applyTransformation(t)}else super.setAttributeImpl(t,s,n)}}Ya.st_totalCurveCount=0;class Xa{constructor(t,e){this.m_segIter=null,this.m_quadTree=null,this.m_qtIter=null,this.m_extentOfInterest=new oe(e),this.m_bfirst=!0,this.m_prevIndex=-100,this.m_parent=t}nextSegment(){return this.m_bfirst&&this.prepare_(),this.m_quadTree?this.nextSegmentQt():this.nextSegmentNoQt()}getPathIndex(){return this.m_segIter.getPathIndex()}getStartPointIndex(){return this.m_segIter.getStartPointIndex()}getEndPointIndex(){return this.m_segIter.getEndPointIndex()}isClosingSegment(){return this.m_segIter.isClosingSegment()}isPathClosed(){return this.m_segIter.isPathClosed()}prepare_(){const t=this.m_parent.getAccelerators();t&&(this.m_quadTree=t.getQuadTree(),this.m_quadTree&&(this.m_qtIter=this.m_quadTree.getSortedIterator(this.m_extentOfInterest,0))),this.m_segIter=this.m_parent.querySegmentIterator()}nextSegmentQt(){this.m_bfirst=!1;const t=this.m_qtIter.next();if(-1===t)return null;const e=this.m_quadTree.getElement(t);(e!==this.m_prevIndex+1||this.m_segIter.isLastSegmentInPath())&&(this.m_segIter.resetToVertex(e,this.m_segIter.getPathIndex()),this.m_prevIndex=e);return this.m_segIter.nextSegment()}nextSegmentNoQt(){for(;;){if(!this.m_bfirst&&this.m_segIter.hasNextSegment()){const t=this.m_segIter.nextSegment(),e=oe.constructEmpty();if(t.queryLooseEnvelope(e),!e.isIntersecting(this.m_extentOfInterest))continue;return t}if(this.m_bfirst=!1,!this.m_segIter.nextPath())return null}}}class Na extends Ya{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!1}),this.m_segmentBufferCTor=nu):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=nu,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=nu):t.start?(super({vd:t.start.getDescription(),bPolygon:!1}),this.m_segmentBufferCTor=nu,this.startPathPoint(t.start),this.lineToPoint(t.end)):t.path?(super({bPolygon:!1}),this.m_segmentBufferCTor=nu,this.addPathPoint2D(t.path,t.pointCount,t.bForward)):h("bad constructor arg"):(super({bPolygon:!1}),this.m_segmentBufferCTor=nu)}getBoundary(){return Va(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}assignMove(t){return t.copyTo(this),this}getGeometryType(){return Na.type}getDimension(){return 1}createInstance(){return new Na({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}Na.type=i.enumPolyline;var qa=i;function Fa(t,e){if(t.isEmpty())return!1;const s=t.getGeometryType();if(s===qa.enumPolygon)return 0!==t.calculateArea2D();if(s===qa.enumPolyline)return La(t.getImpl(),e,!0).bNotEmpty;if(s===qa.enumEnvelope)return!0;if(m(s))return!!t.isClosed();if(u(s))return!1;if(s===qa.enumGeometryCollection){const s=t;for(let t=0,n=s.getGeometryCount();t<n;t++)if(Fa(s.getGeometry(t),e))return!0;return!1}a("")}function Va(t,e){const s=t.getGeometryType();if(s===qa.enumPolygon){const e=new Na({vd:t.getDescription()});return t.isEmpty()||t.copyToUnchecked(e),e}if(s===qa.enumPolyline)return La(t.getImpl(),e,!1).boundary;if(s===qa.enumEnvelope){const e=new Na({vd:t.getDescription()});return t.isEmpty()||e.addEnvelope(t,!1),e}if(m(s)){const e=new Ce({vd:t.getDescription()});if(!t.isEmpty()&&!t.isClosed()){const s=new N;e.reserve(2),t.queryStart(s),e.add(s),t.queryEnd(s),e.add(s)}return e}if(s===qa.enumGeometryCollection){const s=t;let n=null;for(let i=0,r=s.getGeometryCount();i<r;i++){const r=Va(s.getGeometry(i),e);if(null!==r){null===n&&(n=t.createInstance());const e=r;n.addGeometry(e)}}return n}if(u(s))return new N({vd:t.getDescription()});a("")}function La(t,e,s){const n=!1,i=t;let r=null;if(s||(r=new Ce({vd:i.getDescription()})),!i.isEmpty()){const t=new q(0);for(let e=0,s=i.getPathCount();e<s;e++){if(i.getPathSize(e)>0&&!i.isClosedPathInXYPlane(e)){const s=i.getPathStart(e);t.add(s);const n=i.getPathEnd(e)-1;t.add(n)}}if(t.size()>0){const e=new F,n=i.getAttributeStreamRef(0),o={userSort(t,e,s){const i=J.getNAN(),r=J.getNAN();s.sort(t,e,((t,e)=>(n.queryPoint2D(2*t,i),n.queryPoint2D(2*e,r),i.compare(r))))},getValue:t=>n.read(2*t+1)};e.sort(t,0,t.size(),o);let a=n.readPoint2D(2*t.read(0)),h=0,m=1;const u=new N;for(let i=1,r=t.size();i<r;i++){const e=n.readPoint2D(2*t.read(i));if(e.isEqualPoint2D(a))t.read(h)>t.read(i)?(t.write(h,gt()),h=i):t.write(i,gt()),m++;else{if(1&m){if(s)return{bNotEmpty:!0,boundary:new Ce({})}}else t.write(h,gt());a=e,h=i,m=1}}if(1&m){if(s)return{bNotEmpty:!0,boundary:new Ce({})}}else t.write(h,gt());if(!s){t.sort(0,t.size());for(let e=0,s=t.size();e<s&&t.read(e)!==gt();e++)i.getPointByVal(t.read(e),u),r.add(u)}}}return s?{bNotEmpty:n,boundary:new Ce({})}:{bNotEmpty:n,boundary:r}}const Ra=Xt/180,za=180/Xt;function ka(t){let e=t;return e>=-360&&e<720?(e<0?e+=360:e>=360&&(e-=360),e):(e=Jt(e,360),e<0&&(e+=360),e)}function Ba(t){let e=t;return e=ka(e),e>180&&(e-=360),e}function Ga(t){return t*Ra}function Wa(t){return t*za}function ja(t){const e=Lt();let s=t;return s>=-e&&s<2*e?(s<0&&(s+=e),s>=e&&(s-=e),s):(s=Jt(s,e),s<0&&(s+=e),s)}function Za(t){const e=Nt();let s=t;return s>-e&&s<=e||(s=ja(s),s>e&&(s-=Lt())),s}function Ha(t,e){return Ba(e-t)}var Ua=I;class Oa extends ns{constructor(t){if(void 0===t||dt(t,"vd"))return super({vd:t?.vd,XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_semiMajorAxis=0,this.m_minorMajorRatio=1,this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,this.m_center=new J(0,0),this.m_sweepAngle=0,this.m_startAngle=0,this.m_interior=new J(0,0),void(this.m_bits=0);if(t.copy)return super(t),void(this!==t.copy&&(this.m_center=new J(0,0),this.m_interior=new J(0,0),t.copy.copyToImpl(this)));if(t.move)super(t),this.m_semiMajorAxis=t.move.m_semiMajorAxis,this.m_minorMajorRatio=t.move.m_minorMajorRatio,this.m_rotation=t.move.m_rotation,this.m_cosr=t.move.m_cosr,this.m_sinr=t.move.m_sinr,this.m_center=t.move.m_center.clone(),this.m_sweepAngle=t.move.m_sweepAngle,this.m_startAngle=t.move.m_startAngle,this.m_interior=t.move.m_interior.clone(),this.m_bits=t.move.m_bits,this.m_cachedValues=t.move.m_cachedValues,t.move.m_cachedValues=null;else{if(t.fromPoint)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new J(0,0),this.m_interior=new J(0,0),void this.constructCircularArcThreePoint(t.fromPoint,t.toPoint,t.interiorPoint);if(t.center)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),this.m_center=new J(0,0),this.m_interior=new J(0,0),void this.constructCircleRadius(t.radius,t.center,t.bIsCounterClockwise);if(t.semiMajorAxis)return super({XStart:0,YStart:0,XEnd:0,YEnd:0}),void this.constructEllipticArcEndPoints(t.fromPoint,t.toPoint,t.semiMajorAxis,t.minorMajorRatio,t.axisXRotationRad,t.bBigArc,t.bIsCounterClockwise)}}getBoundary(){return Va(this)}assignCopy(t){return this!==t&&t.copyTo(this),this}constructCircleRadius(t,e,s=!1){return this.constructEllipse(t,1,e,0,s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircleCenterAndPoint(t,e,s=!1){const n=J.distance(t,e);return this.constructEllipticArcEndPointsCenter(e,e,n,1,0,!0,s,t),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructTwoPointCircle(t,e,s=!1){const n=J.lerp(t,e,.5);return this.constructCircleCenterAndPoint(n,t,s),this}constructLineEllipticArc(t,e){return Rh(this,t,e,1),this}constructLineCircularArc(t,e){return Rh(this,t,e,0),this}constructEllipse(t,e,s,n,i=!1){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const r=new J(0,this.m_minorMajorRatio*this.m_semiMajorAxis),o=Math.cos(n),a=Math.sin(n);return r.rotateDirect(o,a),r.addThis(s),this.constructEllipticArcEndPointsCenter(r,r,this.m_semiMajorAxis,this.m_minorMajorRatio,n,!0,i,s),this}inflate(t){if(this.isDegenerateToLine())return;let e=this.getSemiMinorAxis()+t;if(e=e<=0?0:(this.getSemiMajorAxis()+t)/this.getSemiMajorAxis(),this.isCircular()){const t=new ae;t.setShiftCoords(-this.m_center.x,-this.m_center.y),t.scale(e,e),t.shiftCoords(this.m_center.x,this.m_center.y),this.applyTransformation(t)}else{const t=new ae;this.canonicToWorldTransformation(t);const s=t.clone();s.invertPreciseThis(),s.scale(e,e),s.multiply(t),this.applyTransformation(s)}}constructEnclosingCircle(t,e,s=!1){return am(this,t,e,s),this}constructThreePointCircle(t,e,s,n=!1){if(t.equals(e)||e.equals(s)||t.equals(s)){const i=t.clone(),r=e.clone(),o=s.clone();return i.equals(r)&&r.assign(o),this.constructTwoPointCircle(i,r,n)}{const i=J.calculateCircleCenterFromThreePoints(t,e,s);if(!i.isFinite()||!Number.isFinite(J.distance(t,i))){const n=J.distance(t,e),i=J.distance(t,s);this.constructLineCircularArc(t,n>=i?e:s)}return this.constructCircleCenterAndPoint(i,t,n)}}constructCircularArcThreePoint(t,e,s){const n=new st(t.x),i=new st(e.x),r=new st(s.x),o=new st(t.y),a=new st(e.y),h=new st(s.y),m=new st(.5),u=i.subE(n),l=a.subE(o),c=r.subE(n),g=h.subE(o),d=u.mulE(g).subThisE(l.mulE(c));if(d.scaleError(10),d.isZero()){if(!u.isZero()||!l.isZero())return Rh(this,t,e,0),this;{const n=t.clone().addThis(e).mulThis(.5).addThis(s).mulThis(.5),i=s.sub(n).length();this.constructEllipticArcEndPointsCenter(t,e,i,1,0,!0,!1,n),this.m_interior.assign(s)}return this.setProjectionBehavior(0),this}const _=u.sqr().addThisE(l.sqr()).mulThisE(m),p=c.sqr().addThisE(g.sqr()).mulThisE(m),f=_.mulE(g).subThisE(p.mulE(l)),P=u.mulE(p).subThisE(c.mulE(_));f.divThisE(d),P.divThisE(d);const y=f.sqr().addThisE(P.sqr());y.sqrtThis();const x=f.addE(n),C=P.addE(o);let v=t.x-x.value(),b=t.y-C.value();const E=Math.atan2(b,v);v=e.x-x.value(),b=e.y-C.value();const S=Math.atan2(b,v);v=s.x-x.value(),b=s.y-C.value();const D=Math.atan2(b,v);let w=D-2*Nt();for(;w<E;)w+=2*Nt();let A=S-2*Nt();for(;A<w;)A+=2*Nt();let T=D+2*Nt();for(;T>E;)T-=2*Nt();let I,M=S+2*Nt();for(;M>T;)M-=2*Nt();I=A-E<E-M?A-E:M-E;const Y=new J(x.value(),C.value());return this.constructEllipticArcEndPointsCenter(t,e,y.value(),1,0,Math.abs(I)>Nt(),I>0,Y),this.m_interior.assign(s),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructCircularArc(t,e,s,n){return this.constructEllipticArcGeneral(t,1,e,s,n,0),this.setProjectionBehavior(0),this.afterCompletedModification(),this}constructEllipticArcEndPoints(t,e,s,n,i,r,o){return Lh(this,t,e,s,n,i,r,o)}constructEllipticArcEndPointsCenter(t,e,s,n,i,r,o,a){return Lh(this,t,e,s,n,i,r,o,a)}constructEllipticArcGeneral(t,e,s,n,i,r){this.m_semiMajorAxis=Math.abs(t),this.m_minorMajorRatio=Math.abs(e),this.m_minorMajorRatio>1&&(this.m_semiMajorAxis*=this.m_minorMajorRatio,this.m_minorMajorRatio=1/this.m_minorMajorRatio);const o=Za(r),a=Math.cos(o),h=Math.sin(o),m=new J(this.m_semiMajorAxis,this.m_minorMajorRatio*this.m_semiMajorAxis),u=J.getNAN(),l=Za(n);u.x=m.x*Math.cos(l),u.y=m.y*Math.sin(l),u.rotateDirect(a,h),u.addThis(s);const c=Qt(i,Lt());let g=c;Math.abs(g)===Lt()&&(g=0);const d=J.getNAN();return d.x=m.x*Math.cos(l+g),d.y=m.y*Math.sin(l+g),d.rotateDirect(a,h),d.addThis(s),this.constructEllipticArcEndPointsCenter(u,d,this.m_semiMajorAxis,this.m_minorMajorRatio,o,Math.abs(c)>Nt(),c>0,s)}constructEllipticArcAsNURB(t,s,n,i){(i>=1||i<0)&&e("construct_elliptic_arc_as_NURB: weight"),s.isFinite()||e("construct_elliptic_arc_as_NURB: control_point");return im([t,s,n],i*i,null,!1,this),this}constructCanonic(t){return this.assignCopy(t),t.isDegenerateToLine()||t.m_center.isEqual(0,0)&&0===this.m_rotation||(this.m_XStart=t.getSemiMajorAxis()*Math.cos(t.m_startAngle),this.m_YStart=t.getSemiMinorAxis()*Math.sin(t.m_startAngle),this.m_XEnd=t.getSemiMajorAxis()*Math.cos(t.getEndAngle()),this.m_YEnd=t.getSemiMinorAxis()*Math.sin(t.getEndAngle()),this.m_center.setCoords(0,0),this.m_rotation=0,this.m_cosr=1,this.m_sinr=0,mm(this),this.afterCompletedModification(),t!==this&&Ze(this,t)),this}isCircular(){return 1===this.m_minorMajorRatio&&0===this.m_rotation&&!this.isDegenerateToLine()}isDegenerateToLineHelper(t){return!!Ie(this,[t])&&zh(this)}isDegenerateToLine(){return zh(this)}getCenter(){return this.m_center.clone()}setCenter(t){if(!this.m_center.isNAN()){const e=t.sub(this.m_center);this.m_XStart+=e.x,this.m_YStart+=e.y,this.m_XEnd+=e.x,this.m_YEnd+=e.y,this.m_interior.addThis(e),this.m_center.assign(t),this.endPointModified(),this.normalizeAfterEndpointChange()}}getAxisXRotation(){return this.m_rotation}getSemiAxes(){return J.construct(this.m_semiMajorAxis,this.m_semiMajorAxis*this.m_minorMajorRatio)}getSemiMajorAxis(){return this.m_semiMajorAxis}getSemiMinorAxis(){return this.m_semiMajorAxis*this.m_minorMajorRatio}getMinorMajorRatio(){return this.m_minorMajorRatio}isClockwise(){return!Qh(this)}isMajor(){return Kh(this)}getSweepAngle(){return this.m_sweepAngle}getStartAngle(){return this.m_startAngle}getEndAngle(){return this.m_startAngle+this.m_sweepAngle}getGeometryType(){return i.enumEllipticArc}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=oe.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const e=this.m_description.getSemantics(s);for(let n=0,i=Ua.getComponentCount(e);s<i;s++){const s=this.queryInterval(e,n);t.setIntervalEnvelope(e,n,s)}}}else 2===t.m_EnvelopeType?dm(this,U.unit(),t):a("3d not impl")}applyTransformation(t){Wh(this,t,!1)}createInstance(){return new Oa}calculateLength2D(){return Yh(this,0,1)}queryCoord2D(t,e){if(zh(this))os(t,this.getStartXY(),this.getEndXY(),e);else if(0===t)e.assign(J.construct(this.m_XStart,this.m_YStart));else if(1===t)e.assign(J.construct(this.m_XEnd,this.m_YEnd));else{const s=Ah(this,t),n=new J(this.m_semiMajorAxis*Math.cos(s),this.getSemiMinorAxis()*Math.sin(s));n.rotateDirect(this.m_cosr,this.m_sinr),n.addThis(this.m_center),e.assign(n)}}queryCoord2DE(t,e){yh(this,t,e)}getCoordX(t){const e=new J;return this.queryCoord2D(t,e),e.x}getCoordY(t){const e=new J;return this.queryCoord2D(t,e),e.y}cut(t,e,s){const n=new nu;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createEllipticArc();let r=0===t&&1===e;if(r&&!n)return void this.copyTo(i);const o=J.getNAN();this.queryCoord2D(t,o);const a=J.getNAN();if(this.queryCoord2D(e,a),!r)if(o.equals(a))e-t>.5&&this.isMajor()&&this.isClosed()?(r=!0,t=0,e=1):1===e?t=e:e=t;else if(t>0&&o.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&a.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),r=0===t&&1===e,r&&!n)return void this.copyTo(i);if(i.m_center.assign(this.m_center),i.m_semiMajorAxis=this.m_semiMajorAxis,i.m_minorMajorRatio=this.m_minorMajorRatio,i.m_interior.assign(this.m_interior),i.m_rotation=this.m_rotation,i.m_cosr=this.m_cosr,i.m_sinr=this.m_sinr,i.m_sweepAngle=this.m_sweepAngle,i.m_startAngle=this.m_startAngle,i.m_bits=this.m_bits,qe(i,o.x,o.y),Ve(i,a.x,a.y),r)return void Zh(i,Xh(this));i.m_startAngle=Ah(this,t),i.m_sweepAngle=Ah(this,e)-i.m_startAngle,i.m_startAngle=bh(i.m_startAngle),Jh(i,Math.abs(i.m_sweepAngle)>Nt()),i.assignVertexDescription(this.m_description),mm(i),Dh(i);const h=this.m_description.getAttributeCount();if(h>1){for(let e=1;e<h;e++){const s=this.m_description.getSemantics(e),n=Ua.getComponentCount(s);for(let e=0;e<n;e++){const n=this.getAttributeAsDbl(t,s,e);i.setStartAttribute(s,e,n)}}for(let t=1;t<h;t++){const s=this.m_description.getSemantics(t),n=Ua.getComponentCount(s);for(let t=0;t<n;t++){const n=this.getAttributeAsDbl(e,s,t);i.setEndAttribute(s,t,n)}}}i.afterCompletedModification()}queryDerivative(t,e){Pm(this,t,e)}cutArcIgnoreAttributes(t,e,s){let n=0===t&&1===e;const i=new J;this.queryCoord2D(t,i);const r=new J;this.queryCoord2D(e,r),n||(i.equals(r)?e-t>.5&&this.isMajor()&&this.isClosed()?(n=!0,t=0,e=1):1===e?t=e:e=t:(t>0&&i.isEqual(this.m_XStart,this.m_YStart)&&(t=0),e<1&&r.isEqual(this.m_XEnd,this.m_YEnd)&&(e=1),n=0===t&&1===e)),s.m_center.assign(this.m_center),s.m_semiMajorAxis=this.m_semiMajorAxis,s.m_minorMajorRatio=this.m_minorMajorRatio,s.m_interior.assign(this.m_interior),s.m_rotation=this.m_rotation,s.m_cosr=this.m_cosr,s.m_sinr=this.m_sinr,s.m_sweepAngle=this.m_sweepAngle,s.m_startAngle=this.m_startAngle,s.m_bits=this.m_bits,qe(s,i.x,i.y),Ve(s,r.x,r.y),n?Zh(s,Xh(this)):(s.m_startAngle=Ah(this,t),s.m_sweepAngle=Ah(this,e)-s.m_startAngle,s.m_startAngle=bh(s.m_startAngle),Jh(s,Math.abs(s.m_sweepAngle)>Math.PI),mm(s),s.afterCompletedModification())}changeEndPoints2D(t,e){qh(this,t,e,!1)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?this.getCoordX(t):this.getCoordY(t);if(0===t)return this.getStartAttributeAsDbl(e,s);if(1===t)return this.getEndAttributeAsDbl(e,s);const n=this.calculateLength2D(),i=n>0?this.tToLength(t)/n:0,r=Ua.getInterpolation(e),o=this.getStartAttributeAsDbl(e,s),a=this.getEndAttributeAsDbl(e,s);return Pt(r,o,a,i,Ua.getDefaultValue(e))}getClosestCoordinate(t,e){return _m(this,t,U.unit(),e)}getClosestCoordinateOnInterval(t,e,s=-1){return _m(this,t,e,!1)}getYMonotonicParts(t,n=!1){t.length<2&&e("");const i=this.getSemiAxes(),r=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),o=r+Nt(),a=O(3,Number.NaN);let h=0;if(a[0]=wh(this,r),a[0]>0&&a[0]<1&&h++,a[1]=wh(this,o),a[1]>0&&a[1]<1&&(a[h]=a[1],h++),0===h)return 0;a[h]=1,h++,s(t.length>=h);let m=0;for(let e=0;e<h;e++){const s=a[e];this.queryCut(m,s,t[e],n),m=s}return h}getMonotonicParts(t,n){if(t.length<4&&e(""),this.isDegenerateToLine())return t[0].createEllipticArc().assignCopy(this),n&&t[0].get().dropAllAttributes(),1;const i=this.getSemiAxes(),r=O(4,Number.NaN);r[0]=Math.atan2(i.y*this.m_cosr,i.x*this.m_sinr),r[1]=r[0]+Nt(),r[2]=Math.atan2(-i.y*this.m_sinr,i.x*this.m_cosr),r[3]=r[2]+Nt();const o=O(5,Number.NaN);let a=0;for(let e=0;e<4;e++)o[a]=wh(this,r[e]),o[a]>0&&o[a]<1&&a++;if(0===a)return 0;yt(o,a),o[a-1]<1&&(o[a]=1,a++),s(t.length>=a);let h=0;for(let e=0;e<a;e++){const s=o[e];this.queryCut(h,s,t[e],n),h=s}return a}intersectionWithAxis2D(t,e,s,n){if(zh(this)){return new su({start:this.getStartXY(),end:this.getEndXY()}).intersectionWithAxis2D(t,e,s,n)}let i,r;const o=new st(e),a=this.getSemiAxes();if(t){if(e>this.m_center.y+a.x||e<this.m_center.y-a.x)return 0;i=new st(a.x).mulThis(this.m_sinr),r=new st(a.y).mulThis(this.m_cosr),o.subThis(this.m_center.y)}else{if(e>this.m_center.x+a.x||e<this.m_center.x-a.x)return 0;i=new st(a.x).mulThis(this.m_cosr),r=new st(a.y).mulThis(-this.m_sinr),o.subThis(this.m_center.x)}const h=i.sqr(),m=r.sqr(),u=h.addE(m),l=r.mulE(o).mulThis(-2),c=o.sqr().subThisE(h),g=l.sqr().subThisE(u.mulE(c).mulThis(4)),d=i.mulE(o).mulThis(-2),_=o.sqr().subThisE(m),p=d.sqr().subThisE(u.mulE(_).mulThis(4));let f=g.eps()*Math.abs(p.value())<=p.eps()*Math.abs(g.value());f?i.isZero()&&(f=!1):r.isZero()&&(f=!0),f||(l.setE(d),c.setE(_));const P=_t(st,2);let y=js(u,l,c,U.construct(-1,1),!1,P);if(0===y)return 0;const x=[0,0];let C=0;for(let v=0;v<y;v++){const t=new st,e=new st;f?(t.setE(P[v]),e.setE(o.subE(r.mulE(P[v])).divThisE(i))):(e.setE(P[v]),t.setE(o.subE(i.mulE(P[v])).divThisE(r)));const s=wh(this,Math.atan2(t.value(),e.value()));s>=0&&s<=1&&(x[C]=s,C++)}return y=C,0===y?0:(2===y&&x[0]>x[1]&&(x[1]=tt(x[0],x[0]=x[1])),n&&K(n,x,0,0,y),s&&(s[0]=t?this.getCoordX(x[0]):this.getCoordY(x[0]),y>1&&(s[1]=t?this.getCoordX(x[1]):this.getCoordY(x[1]),!n&&s[0]>s[1]&&(s[1]=tt(s[0],s[0]=s[1])))),y)}intersectionOfYMonotonicWithAxisX(t,e){if(this.m_YStart===this.m_YEnd)return t===this.m_YStart?e:Number.NaN;if(t===this.m_YStart)return this.m_XStart;if(t===this.m_YEnd)return this.m_XEnd;const s=[0,0];return-1===this.intersectionWithAxis2D(!0,t,s,null)?e:s[0]}isCurve(){return!0}isDegenerate(t){return Te(this,t)}isDegenerate3D(t,e){return s(0),!1}queryLooseEnvelope(t){3!==t.m_EnvelopeType?this.queryLooseEnvelopeOnInterval(new U(0,1),t):a("3d not impl")}clone(t){const e=new Oa;return this.copyTo(e),e}queryInterval(t,e){if(0===t){if(zh(this))return 0===e?U.construct(this.getStartX(),this.getEndX()):U.construct(this.getStartY(),this.getEndY());let t;const s=this.getSemiAxes();t=0===e?Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr):Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr);const n=t+Math.PI,i=[0,0];i[0]=wh(this,t),i[1]=wh(this,n);const r=0===e?U.construct(this.getStartX(),this.getEndX()):U.construct(this.getStartY(),this.getEndY()),o=new J;for(let a=0;a<2;a++){const t=i[a];t>0&&t<1&&(this.queryCoord2D(t,o),r.mergeNeCoordinate(0===e?o.x:o.y))}return r}return super.queryInterval(t,e)}queryLooseEnvelopeOnInterval(t,e){const s=new U(0,1);if(s.intersect(t),s.isEmpty())return void e.setEmpty();if(zh(this))return e.setCoords(this.getCoord2D(s.vmin)),void e.mergeNe(this.getCoord2D(s.vmax));const n=this.getCoord2D(s.vmin),i=this.getCoord2D(s.vmax);if(1===this.m_minorMajorRatio&&Math.abs(this.m_sweepAngle)*s.width()<=qt){let t=J.lerp(n,i,.5);const s=t.sub(this.m_center);return s.normalize(),t=t.add(s.mul(.5*J.distance(n,i))),e.setCoords(n),e.mergeNe(i),void e.mergeNe(t)}dm(this,s,e)}tToLength(t){return zh(this)?t*J.distance(this.getStartXY(),this.getEndXY()):1===this.m_minorMajorRatio?Math.abs(this.getSweepAngle()*t)*this.m_semiMajorAxis:kh(this,t)}parametricAngleToT(t){return wh(this,t)}tToParametricAngle(t){return Ah(this,t)}lengthToT(t){if(zh(this)){const e=J.distance(this.getStartXY(),this.getEndXY());return 0===e?0:t/e}if(1===this.m_minorMajorRatio){const e=Math.abs(this.getSweepAngle())*this.m_semiMajorAxis;return 0===e?0:t/e}return Bh(this,t)}calculateWeightedAreaCentroid2D(t){if(zh(this)){const t=new J;return t.setCoords(0,0),t}const e=hm(this),s=this.getStartXY().sub(this.m_center),n=this.getEndXY().sub(this.m_center),i=this.m_semiMajorAxis,r=this.getSemiMinorAxis(),o=this.m_startAngle+this.m_sweepAngle,a=new J;a.x=i*r*(i*this.m_cosr*(-Math.sin(o)+Math.sin(this.m_startAngle))+r*(-Math.cos(o)+Math.cos(this.m_startAngle))*this.m_sinr)/3,a.y=i*r*(r*(Math.cos(o)-Math.cos(this.m_startAngle))*this.m_cosr+i*(-Math.sin(o)+Math.sin(this.m_startAngle))*this.m_sinr)/3;const h=n.add(s).mul(n.crossProduct(s)/6);return a.x-=h.x,a.y-=h.y,a.add(this.m_center.sub(t).mul(e))}calculateWeightedCentroid2D(){const t=new J;if(this.isDegenerate(0))return t.setCoords(0,0),t;if(zh(this))return t.assign(this.getCoord2D(.5).mul(this.calculateLength2D())),t;let e=this.m_startAngle,s=this.m_startAngle+this.m_sweepAngle;if(s<e){const t=e;e=s,s=t}const n=Math.sin(e),i=Math.sin(s),r=Math.cos(e),o=Math.cos(s);if(1===this.m_minorMajorRatio){const e=this.getSemiMajorAxis(),s=e*e,a=s*(i-n),h=s*(r-o);t.setCoords(a,h)}else{const e=this.getSemiMajorAxis(),s=this.getSemiMinorAxis(),a=e*e,h=s*s,m=e*s,u=a-h,l=u/h,c=u/a,g=Math.sqrt(l),d=Math.sqrt(c),_=.5*m*(Math.asinh(g*i)/g+i*Math.sqrt(1+l*i*i))-.5*m*(Math.asinh(g*n)/g+n*Math.sqrt(1+l*n*n)),p=-.5*m*(Math.asin(d*o)/d+o*Math.sqrt(1-c*o*o))- -.5*m*(Math.asin(d*r)/d+r*Math.sqrt(1-c*r*r));t.setCoords(_,p)}return t.rotateDirect(this.m_cosr,this.m_sinr),t.assign(t.add(this.m_center.mul(this.calculateLength2D()))),t}isIntersectingPoint(t,e,s){if(s&&(t.isEqualPoint2D(this.getStartXY())||t.isEqualPoint2D(this.getEndXY())))return!1;if(!zh(this)){const s=J.distance(t,this.m_center),n=this.getSemiAxes();if(s<n.x-e||s>n.y+e)return!1}const n=this.getClosestCoordinate(t,!1),i=new J;this.queryCoord2D(n,i);return J.distance(i,t)<=e}isIntersectingPoint3D(t,e,n,i,r=1){return s(0),!1}getTangent(t){if(zh(this))return this.getEndXY().sub(this.getStartXY());{const e=Ah(this,t),s=new J;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}getDerivative(t){if(zh(this))return this.getEndXY().sub(this.getStartXY());{const e=Ah(this,t),s=new J;return s.setCoords(-this.m_semiMajorAxis*Math.sin(e),this.getSemiMinorAxis()*Math.cos(e)),this.m_rotation&&s.rotateDirect(this.m_cosr,this.m_sinr),s.scale(this.getSweepAngle()),s}}normalizeAfterEndpointChange(){return!!tm(this)&&(zh(this)?(em(this),!1):sm(this,!1))}projectionBehavior(){return(4&this.m_bits)>>2}setProjectionBehavior(t){this.m_bits=-5&this.m_bits|t<<2}convertToCanonic(t){const e=new J(t.x,t.y);return e.subThis(this.m_center),e.rotateReverse(this.m_cosr,this.m_sinr),e}convertFromCanonic(t){const e=new J(t.x,t.y);return e.rotateDirect(this.m_cosr,this.m_sinr),e.addThis(this.m_center),e}canonicToWorldTransformation(t){t.setRotate(this.m_cosr,this.m_sinr),t.shiftCoords(this.m_center.x,this.m_center.y)}getCurvature(t){const e=Ah(this,t),s=new J,n=this.getSemiMinorAxis();s.setCoords(-this.m_semiMajorAxis*Math.sin(e),n*Math.cos(e));const i=new J;i.setCoords(-this.m_semiMajorAxis*Math.cos(e),-n*Math.sin(e)),this.m_rotation&&(s.rotateDirect(this.m_cosr,this.m_sinr),i.rotateDirect(this.m_cosr,this.m_sinr));const r=s.sqrLength();if(0===r)return Number.NaN;const o=Math.sqrt(r);s.divThis(o);return s.crossProduct(i)/r}getMonotonicPartParams(t,s){const n=O(6,Number.NaN);n[0]=0;let i=1;if(this.isDegenerateToLine())n[1]=1,i=2;else{const t=this.getSemiAxes(),e=O(4,Number.NaN);this.m_rotation?(e[0]=Math.atan2(t.y*this.m_cosr,t.x*this.m_sinr),e[1]=e[0]+Math.PI,e[2]=Math.atan2(-t.y*this.m_sinr,t.x*this.m_cosr),e[3]=e[2]+Math.PI):(e[0]=0,e[1]=Math.PI,e[2]=.5*Math.PI,e[3]=Ft());for(let s=0;s<4;s++){const t=wh(this,e[s]);t>0&&t<1&&(n[i]=t,i++)}i>2&&yt(n,i),n[i]=1,i++}if(s){t<i&&e("");for(let t=0;t<i;t++)s[t]=n[t]}return i}calculateLowerLength2D(){const t=J.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMinorAxis();return Math.max(e,t)}calculateUpperLength2D(){const t=J.distance(this.getStartXY(),this.getEndXY());if(this.isDegenerateToLine())return t;const e=Math.abs(this.m_sweepAngle)*this.getSemiMajorAxis();return Math.max(e,t)}orientBottomUp(){if(this.m_YEnd<this.m_YStart||this.m_YEnd===this.m_YStart&&this.m_XEnd<this.m_XStart){this.m_XEnd=tt(this.m_XStart,this.m_XStart=this.m_XEnd),this.m_YEnd=tt(this.m_YStart,this.m_YStart=this.m_YEnd);for(let t=0,e=this.m_description.getTotalComponentCount()-2;t<e;t++)this.m_attributes[t+e]=tt(this.m_attributes[t],this.m_attributes[t]=this.m_attributes[t+e]);this.m_startAngle=this.m_startAngle+this.m_sweepAngle,this.m_sweepAngle=-this.m_sweepAngle}}isLine(){return zh(this)}copyIgnoreAttributes(t){t.m_XStart=this.m_XStart,t.m_YStart=this.m_YStart,t.m_XEnd=this.m_XEnd,t.m_YEnd=this.m_YEnd,t.m_center.assign(this.m_center),t.m_semiMajorAxis=this.m_semiMajorAxis,t.m_minorMajorRatio=this.m_minorMajorRatio,t.m_interior.assign(this.m_interior),t.m_rotation=this.m_rotation,t.m_cosr=this.m_cosr,t.m_sinr=this.m_sinr,t.m_sweepAngle=this.m_sweepAngle,t.m_startAngle=this.m_startAngle,t.m_bits=this.m_bits,Hh(t)}calculateArea2DHelper(){return hm(this)}absNorm(){let t=this.getStartXY().norm(1)+this.getEndXY().norm(1);return this.isDegenerateToLine()||(t+=this.m_center.norm(1),t+=this.m_semiMajorAxis),t}queryEnvelopeW(t,e){if(e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax)),zh(this))return;const s=this.getSemiAxes(),n=O(8,Number.NaN);{const t=Math.atan2(-s.y*this.m_sinr,s.x*this.m_cosr),e=t+Math.PI,i=Math.atan2(s.y*this.m_cosr,s.x*this.m_sinr),r=i+Math.PI;n[0]=wh(this,t),n[1]=wh(this,e),n[2]=wh(this,i),n[3]=wh(this,r)}{const t=this.m_cosr+this.m_sinr,e=this.m_cosr-this.m_sinr,i=Math.atan2(-s.y*t,s.x*e),r=i+Math.PI,o=Math.atan2(s.y*e,s.x*t),a=o+Math.PI;n[4]=wh(this,i),n[5]=wh(this,r),n[6]=wh(this,o),n[7]=wh(this,a)}const i=J.getNAN();for(let r=0;r<8;r++){const s=n[r];t.containsExclusiveCoordinate(s)&&(this.queryCoord2D(s,i),e.mergeNe(i))}}setSegmentFromCoords(t,e){Fh(this,t,e)}writeInBufferStream(t,e){const s=new Float64Array(10);return s[0]=this.m_bits,s[1]=this.m_semiMajorAxis,s[2]=this.m_minorMajorRatio,s[3]=this.m_rotation,s[4]=this.m_center.x,s[5]=this.m_center.y,s[6]=this.m_sweepAngle,s[7]=this.m_startAngle,s[8]=this.m_interior.x,s[9]=this.m_interior.y,t.writeRangeFromArray(e,s.length,s,!0,1),e+s.length}readFromBufferStream(t,e){const s=new Float64Array(10);t.queryRange(e,s.length,s,!0,1),this.m_bits=s[0],this.m_semiMajorAxis=s[1],this.m_minorMajorRatio=s[2],this.m_rotation=s[3],this.m_center.x=s[4],this.m_center.y=s[5],this.m_sweepAngle=s[6],this.m_startAngle=s[7],this.m_interior.x=s[8],this.m_interior.y=s[9],this.m_cosr=Math.cos(this.m_rotation),this.m_sinr=Math.sin(this.m_rotation),this.m_cachedValues=null}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return h("should not1; be called"),0}ensureXYMonotone(){if(zh(this))return!1;if(this.getStartXY().equals(this.getEndXY()))return Rh(this,this.getStartXY(),this.getEndXY(),this.projectionBehavior()),!0;const t=_t(J,3);let e=nm(this,t);if(Ii(t)){let s=!1;if(0===this.projectionBehavior()){const n=new oe;n.setCoords({pt:t[0]}),n.mergeNe(t[2]);const i=new J;i.setSub(t[2],t[0]),i.leftPerpendicularThis(),i.normalize(),i.scale(J.distance(t[2],t[0]));const r=J.lerp(t[2],t[0],.5),o=r.sub(i),a=r.add(i);n.clipLine(o,a);const h=J.getClosestCoordinate(o,a,t[1],!1);t[1]=J.lerp(o,a,h);const m=t[2].sub(t[1]),u=t[0].sub(t[1]),l=m.crossProduct(u),c=m.dotProduct(u);e=Vt()-Math.abs(.5*Math.atan2(l,c)),s=!0}return im(t,e*e,null,s,this),!0}return!1}setCoordsForIntersector(t,e,s){qh(this,t,e,s)}getInteriorPoint(){return this.m_interior.clone()}copyToImpl(t){const e=t;e.m_center.assign(this.m_center),e.m_semiMajorAxis=this.m_semiMajorAxis,e.m_minorMajorRatio=this.m_minorMajorRatio,e.m_interior.assign(this.m_interior),e.m_rotation=this.m_rotation,e.m_cosr=this.m_cosr,e.m_sinr=this.m_sinr,e.m_sweepAngle=this.m_sweepAngle,e.m_startAngle=this.m_startAngle,e.m_bits=this.m_bits,Zh(e,Xh(this))}reverseImpl(){Oh(this,!Qh(this)),Dh(this),(0!==this.projectionBehavior()||this.getStartXY().equals(this.getEndXY()))&&mm(this)}equalsImpl(t){const e=t;if(this.m_bits!==e.m_bits)return!1;if(this.m_semiMajorAxis!==e.m_semiMajorAxis)return!1;if(this.m_minorMajorRatio!==e.m_minorMajorRatio)return!1;if(!(this.m_center.isEqualPoint2D(e.m_center)||this.m_center.isNAN()&&e.m_center.isNAN()))return!1;if(this.m_rotation!==e.m_rotation)return!1;if(!this.m_interior.equals(e.m_interior))return!1;const s=e.m_sweepAngle;if(this.m_sweepAngle!==s)return!1;const n=e.m_startAngle;return this.m_startAngle===n}equalsImplTol(t,e){const s=t;if(this.m_bits!==s.m_bits)return!1;if(this.m_center.isNAN()&&s.m_center.isNAN())return!0;if(this.m_center.isNAN()!==s.m_center.isNAN())return!1;if(!this.getSemiAxes().isEqualPoint2D(s.getSemiAxes(),e))return!1;if(!this.m_center.isEqualPoint2D(s.m_center,e))return!1;const n=Math.abs(Ga(Ba(Wa(this.m_rotation-s.m_rotation)))),i=Math.abs(Nt()-n),r=Math.min(n,i);if(this.m_semiMajorAxis*Math.abs(r)>e)return!1;const o=this.getCoord2D(.5),a=s.getCoord2D(.5);return!!o.isEqualPoint2D(a,e)}swapImpl(t){const e=t;this.m_center=tt(e.m_center,e.m_center=this.m_center),this.m_semiMajorAxis=tt(e.m_semiMajorAxis,e.m_semiMajorAxis=this.m_semiMajorAxis),this.m_minorMajorRatio=tt(e.m_minorMajorRatio,e.m_minorMajorRatio=this.m_minorMajorRatio),this.m_interior=tt(e.m_interior,e.m_interior=this.m_interior),this.m_rotation=tt(e.m_rotation,e.m_rotation=this.m_rotation),this.m_cosr=tt(e.m_cosr,e.m_cosr=this.m_cosr),this.m_sinr=tt(e.m_sinr,e.m_sinr=this.m_sinr),this.m_sweepAngle=tt(e.m_sweepAngle,e.m_sweepAngle=this.m_sweepAngle),this.m_startAngle=tt(e.m_startAngle,e.m_startAngle=this.m_startAngle),this.m_bits=tt(e.m_bits,e.m_bits=this.m_bits),Uh(this,e)}afterCompletedModification(){em(this),Hh(this)}intersect(t,e,s,n,i){return Om(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){if(e.length<2&&n(""),zh(this)){return new su({start:this.getStartXY(),end:this.getEndXY()}).intersectPoint(t,e,s)}{const e=J.distance(t,this.m_center);if(e>this.m_semiMajorAxis+s||e<this.getSemiMinorAxis()-s)return 0}const i=this.getClosestCoordinate(t,!1),r=J.getNAN();return this.queryCoord2D(i,r),J.distance(r,t)<=s?ht(i,0,1)&&(this.queryCoord2D(0===i?1:0,r),J.distance(r,t)<=s)?(e&&(e[0]=0,e[1]=1),2):(e&&(e[0]=i),1):0}isIntersecting(t,e,s){return 0!==jm(!1,this,t,e,s)}endPointModified(){this.m_bits|=8,Hh(this)}clearEndPointModified(){em(this)}}function Qa(t,e,s){t.isEmpty()&&o(""),p(t);const n=t.getImpl(),i=[];return $a(n.getPointCount(),i),th(Ka(n),i,n.getPointCount(),e)}function Ja(t,e,s,n){const i=[];return $a(e,i),th(t,i,e,s)}function Ka(t){return{at:e=>t.getXY(e)}}function $a(t,e){e.length=t;for(let s=0;s<e.length;++s)e[s]=s;t>3&&ce(t,e)}function th(t,e,s,n,i){let r=0;const o=[0,0,0];let a=0;const h=3;let m=0;for(let u=0;u<h;++u){let i=!1;for(;m<s;){const s=t.at(e[m]);let l=1;if(3===r?l=J.inCircleRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]),s):2===r?l=J.inCircleRobust3Point(t.at(n[0]),t.at(n[1]),s):1===r&&s.equals(t.at(n[0]))&&(l=0),l<=0){if(l<0&&u+1<h){e[a]=tt(e[m],e[m]=e[a]);for(let t=0;t<r;t++)if(n[t]===e[m]){o[t]=m;break}a++}m++;continue}i=!0;let c=0;for(let t=0;t<r;t++)o[t]>m&&(n[c]=n[t],o[c]=o[t],c++);r=c,n[r]=e[m],o[r]=m,r++,r<3?m=a:(1===J.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=tt(n[0],n[0]=n[2]),o[2]=tt(o[0],o[0]=o[2])),m++)}if(!i)break;if(u+1<h){a=0;let s=!1;for(let t=0;t<r;t++)for(let e=t+1;e<r;e++)o[t]>o[e]&&(o[e]=tt(o[t],o[t]=o[e]),n[e]=tt(n[t],n[t]=n[e]),s=!0);for(let t=0;t<r;t++)e[o[t]]=tt(e[t],e[t]=e[o[t]]),o[t]=t;s&&3===r&&1===J.orientationRobust(t.at(n[0]),t.at(n[1]),t.at(n[2]))&&(n[2]=tt(n[0],n[0]=n[2]),o[2]=tt(o[0],o[0]=o[2]))}m=r}return r}Oa.type=i.enumEllipticArc;class eh extends Ya{constructor(t){t?t.vd?(super({vd:t.vd,bPolygon:!0}),this.m_segmentBufferCTor=nu):t.copy?(super({vd:t.copy.getDescription(),bPolygon:!0}),this.m_segmentBufferCTor=nu,t.copy.copyTo(this)):t.move?(super({move:t.move}),this.m_segmentBufferCTor=nu):t.envelope?a("envelope constructor not impl"):h("bad arg to polygon constructor"):(super({bPolygon:!0}),this.m_segmentBufferCTor=nu)}assignMove(t){return t.copyTo(this),this}assignCopy(t){return t.copyTo(this),this}getBoundary(){return Va(this)}getExteriorRingCount(){return this.getOGCPolygonCount()}getGeometryType(){return eh.type}getDimension(){return 2}createInstance(){return new eh({vd:this.getDescription()})}equals(t,e){return this.equalsBase(t,e)}}function sh(t,e,s,n,i,r){return new ah(0,0,0,null,!1,Z()).densifyEx(t,e,s,n,!1,r)}function nh(t,s,n,r){return Number.isFinite(s)||e("replace_all_curves_with_beziers: maxDeviation"),lh(i.enumBezier,t,s,n)}function ih(t,e,n,r,o,h,m,u){h&&(h.length=0),m&&(m.length=0);const l=t.getGeometryType();if(l===i.enumLine)return h&&(h.push(t.getStartXY()),h.push(J.getNAN()),h.push(J.getNAN()),h.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(l===i.enumBezier){if(!r)return h&&(h.push(t.getStartXY()),h.push(t.getControlPoint1()),h.push(t.getControlPoint2()),h.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;const e=O(9,Number.NaN);let s=t.getMonotonicPartParams(e.length,e);if(e.length=s,s=hh(t,n,e),2===s&&o&&(e[1]=.5,e.push(1),s=3),m&&m.splice(0,0,...e.slice(0,s)),h){const n=new nu;for(let i=1;i<s;i++){const s=e[i-1],r=e[i];t.queryCut(s,r,n,!0);const o=n.get();Ro(o),1===i&&h.push(o.getStartXY()),h.push(o.getControlPoint1()),h.push(o.getControlPoint2()),h.push(o.getEndXY())}}return s-1}if(l===i.enumEllipticArc){const i=t;if(i.isDegenerateToLine()||i.isDegenerate(0))return h&&(h.push(t.getStartXY()),h.push(J.getNAN()),h.push(J.getNAN()),h.push(t.getEndXY())),m&&(m.push(0),m.push(1)),1;if(r&&(o||!i.isMonotoneQuickAndDirty())){const a=O(6,Number.NaN);let u=i.getMonotonicPartParams(a.length,a);a.length=u,u=hh(t,n,a),2===u&&o&&(a[1]=.5,a.push(1),u=3);let l=0;if(u>2){const t=new nu,o=m||[];let c=0;for(let g=1;g<u;g++){const d=a[c],_=a[g];if(i.queryCut(d,_,t,!0),t.get().isDegenerate(0))continue;const p=o.length,f=ch(1===g,t.get(),e,n,r,h,m);s(f>0),l+=f;const P=g===u-1,y=a[c],x=t.get().getSweepAngle()/i.getSweepAngle();for(let t=p,e=o.length;t<e;t++)if(o[t]=!P||t+1<e?y+o[t]*x:1,h){const e=3*t,s=i.getCoord2D(o[t]);if(h[e].setCoordsPoint2D(s),e>0){zo(h.slice(e-3))}}c=g}return l}}return ch(!0,i,e,n,r,h,m)}if(l===i.enumRationalBezier2){const s=t;if(r&&(o||!s.isMonotoneQuickAndDirty())){const i=O(6,Number.NaN);let r=s.getMonotonicPartParams(i.length,i);i.length=r,r=hh(t,n,i),2===r&&o&&(i[1]=.5,i.push(1),r=3);let a=0;if(r>2){const t=new nu,o=m||[];for(let u=1;u<r;u++){const l=i[u-1],c=i[u];s.queryCut(l,c,t,!0);const g=o.length;a+=dh(1===u,t.get(),e,n,!1,h,m);const d=u===r-1,_=i[u-1];for(let t=g,e=o.length;t<e;t++)if(o[t]=!d||t+1<e?_+o[t]:1,h){const e=3*t,n=s.getCoord2D(o[t]);if(h[e].setCoordsPoint2D(n),e>0){Nr(h.slice(e-3))}}}return a}}return dh(!0,s,e,n,r,h,m)}if(l===i.enumBezier2){const s=t,i=_t(J,3);s.queryControlPoints(i);const a=new mo;return a.constructFromQuadratic(i),ih(a,e,n,r,o,h,m)}a("")}function rh(t,e,s,n,r,o,h,m){o.length=0,h.length=0;const u=t.getGeometryType();if(u===i.enumLine)return o.push(t.getStartXY()),o.push(J.getNAN()),o.push(t.getEndXY()),h.push(0),h.push(1),1;if(u===i.enumBezier2){const e=O(9,Number.NaN);let n=t.getMonotonicPartParams(e.length,e);e.length=n,n=hh(t,s,e),h.splice(0,0,...e.slice(0,n));{const s=new nu;for(let i=1;i<n;i++){const n=e[i-1],r=e[i];t.queryCut(n,r,s,!0);const a=s.get();Xr(a),1===i&&o.push(a.getStartXY()),o.push(a.getControlPoint1()),o.push(a.getEndXY())}}return n-1}if(u===i.enumEllipticArc){const i=t;if(i.isDegenerateToLine()||i.isDegenerate(0))return o.push(t.getStartXY()),o.push(J.getNAN()),o.push(t.getEndXY()),h.push(0),h.push(1),1;if(!i.isMonotoneQuickAndDirty()){const n=O(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=hh(t,s,n);let a=0;if(r>2){const t=new nu,m=h;for(let u=1;u<r;u++){const l=n[u-1],c=n[u];i.queryCut(l,c,t,!0);const g=m.length;a+=_h(1===u,t.get(),e,s,!1,o,h);const d=u===r-1,_=n[u-1],p=t.get().getSweepAngle()/i.getSweepAngle();for(let t=g,e=m.length;t<e;t++){m[t]=!d||t+1<e?_+m[t]*p:1;{const e=2*t,s=i.getCoord2D(m[t]);if(o[e].setCoordsPoint2D(s),e>0){Nr(o.slice(e-2))}}}}return a}}return ch(!0,i,e,s,n,o,h)}if(u===i.enumBezier){const i=t;if(!i.isMonotoneQuickAndDirty()){const n=O(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=hh(t,s,n);let a=0;if(r>2){const t=new nu,m=h;for(let u=1;u<r;u++){const l=n[u-1],c=n[u];i.queryCut(l,c,t,!0);const g=m.length;a+=ph(1===u,t.get(),e,s,!1,o,h);const d=u===r-1,_=n[u-1];for(let t=g,e=m.length;t<e;t++){m[t]=!d||t+1<e?_+m[t]:1;{const e=2*t,s=i.getCoord2D(m[t]);if(o[e].setCoordsPoint2D(s),e>0){Nr(o.slice(e-2))}}}}return a}}return ph(!0,i,e,s,n,o,h)}if(u===i.enumRationalBezier2){const i=t;if(!i.isMonotoneQuickAndDirty()){const n=O(6,Number.NaN);let r=i.getMonotonicPartParams(n.length,n);n.length=r,r=hh(t,s,n);let a=0;if(r>2){const t=new nu,m=h;for(let u=1;u<r;u++){const l=n[u-1],c=n[u];i.queryCut(l,c,t,!0);const g=m.length;a+=gh(1===u,t.get(),e,s,!1,o,h);const d=u===r-1,_=n[u-1];for(let t=g,e=m.length;t<e;t++){m[t]=!d||t+1<e?_+m[t]:1;{const e=2*t,s=i.getCoord2D(m[t]);if(o[e].setCoordsPoint2D(s),e>0){Nr(o.slice(e-2))}}}}return a}}return gh(!0,i,e,s,n,o,h)}a("")}function oh(t,e,n,r,o,a,h,m,u){const l=t.getGeometryType();if(a&&(a.length=0,h.length=0),m&&(m.length=0),l===i.enumEllipticArc){const e=t;if(e.isDegenerateToLine()||e.isDegenerate(0))return a&&(a.push(t.getStartXY()),a.push(J.getNAN()),a.push(t.getEndXY()),h.push(Number.NaN),h.push(Number.NaN),h.push(Number.NaN)),m&&(m.push(0),m.push(1)),1}const c=O(9,Number.NaN);let g;if(o)g=t.getMonotonicPartParams(c.length,c),c.length=g,g=hh(t,n,c);else{if(g=2,c[0]=0,c[1]=1,l===Oa.type){const e=t.getSweepAngle();if(e>.9*Math.PI){const t=2*Math.PI/3;Math.min(3,Math.trunc(e/t+.5))>2?(c[0]=0,c[1]=1/3,c[2]=2/3,c[3]=1,g=4):(c[0]=0,c[1]=.5,c[2]=1,g=3)}}else s(l===on.type);c.length=g}if(2===g&&r&&(c[1]=.5,c.push(1),g=3),a){const e=new nu;let s=1;for(;s<g;){const n=c[s-1],r=c[s];t.queryCut(n,r,e,!0);const m=_t(J,3),u=[1,1,1];if(l===i.enumEllipticArc){const t=e.get();if(Math.abs(t.getSweepAngle())>.9*Math.PI){const t=(r-n)/3;c.splice(s,0,n+t),c.splice(s+1,0,n+2*t),g+=2;continue}u[1]=nm(t,m)}else{const t=e.get();t.queryControlPoints(m),t.queryWeights(u)}o&&Ii(m),1===s&&(a.push(m[0].clone()),h.push(u[0])),a.push(m[1].clone()),a.push(m[2].clone()),h.push(u[1]),h.push(u[2]),s++}}return m&&(m.length=g,K(m,c,0,0,g)),g-1}eh.type=i.enumPolygon;class ah{static constructDefault(t){return new ah(0,0,0,t,!1,Z())}constructor(t,e,s,n,i,r){this.m_segmentBuffer=null,this.m_dummyPoint=new N,this.m_progressCounter=0,this.m_progressTracker=n,this.m_bSetDensifyFlag=i,this.m_maxLength=t,this.m_maxDeviation=e,this.m_maxAngle=s>Vt()?Vt():s,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_maxSegmentsPerCurve=r,l(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve}densify(t){return this.densifyGeom(t)}densifySegment(t,e){this.densifySegmentEx(t,null,!0,!1,e)}densifyEx(t,e,s,n,i,r){return this.m_maxLength=e,this.m_maxDeviation=s,this.m_maxAngle=n>Vt()?Vt():n,this.m_cosMaxAngle=Math.cos(this.m_maxAngle),this.m_bOnlyCurveDensify=this.m_maxAngle>0||this.m_maxDeviation>0,this.m_bSetDensifyFlag=i,this.m_maxSegmentsPerCurve=r,l(this.m_maxSegmentsPerCurve>0,"this.m_maxSegmentsPerCurve > 0"),this.m_minStep=1/this.m_maxSegmentsPerCurve,this.densifyGeom(t)}densifyGeom(t){if(t.isEmpty()||t.getDimension()<1)return t;const e=t.getGeometryType();return _(e)?t:c(e)?this.densifyMultiPath(t):m(e)?this.densifySegmentImpl(t):e===i.enumEnvelope?this.densifyEnvelope(t):void h("")}densifySegmentEx(t,e,s,n,r){const o=t.getGeometryType();if(!(this.m_maxLength>0||this.m_bOnlyCurveDensify&&o!==i.enumLine)&&(!n||s))return void(e?o===i.enumLine?e.addSegment(t,s):(s&&(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)),t.queryEnd(this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint)):(s&&r.push(0),r.push(1)));if(o===i.enumBezier)return void this.densifyCubicBezier(t,e,s,n,r);if(o===i.enumRationalBezier2)return void this.densifyRationalBezier2(t,e,s,n,r);if(o===i.enumBezier2)return void this.densifyBezier2(t,e,s,n,r);if(o===i.enumEllipticArc&&!t.isLine()&&t.getMinorMajorRatio()<.25)return void this.densifyEllipticArc(t,e,s,n,r);let a=1;this.m_maxLength>0&&(a=this.calculateLengthSubdivisionStep(t,this.m_maxLength)),this.m_maxDeviation>0&&(a=Math.min(a,this.calculateDeviationSubdivisionStep(t,this.m_maxDeviation))),this.m_maxAngle>0&&(a=Math.min(a,this.calculateAngularSubdivisionStep(t,this.m_maxAngle))),this.densifySegmentByLength(t,a,e,s,n,r)}densifyMultiPath(t){if(!t.hasNonLinearSegments()){if(1===t.getDescription().getAttributeCount())return this.densifyMultiPathLinear(t);if(!(this.m_maxLength>0))return t}const e=t.createInstance();if(e.getGeometryType()===i.enumPolygon){e.setFillRule(t.getFillRule())}e.reserve(t.getPointCount());const s=t.getImpl().querySegmentIterator();for(;s.nextPath();){let t=!0;for(;s.hasNextSegment();){const n=s.nextSegment(),i=s.isClosingSegment();this.densifySegmentEx(n,e,t,i,null),i&&e.closePathWithLine(),t=!1}}return e}densifySegmentImpl(t){const e=new Na({vd:t.getDescription()}),s=[0];return this.densifySegmentEx(t,e,!0,!1,s),e}densifyEnvelope(t){const e=new eh({vd:t.getDescription()});e.addEnvelope(t,!1);const s=oe.constructEmpty();t.queryEnvelope(s);const n=s.width(),i=s.height();return!(this.m_maxLength>0)||n<=this.m_maxLength&&i<=this.m_maxLength?e:this.densifyMultiPath(e)}densifyMultiPathLinear(t){if(!(this.m_maxLength>0))return t;const e=t.createInstance();if(e.getGeometryType()===i.enumPolygon){e.setFillRule(t.getFillRule())}e.reserve(t.getPointCount());const s=e.getImpl(),n=t.getImpl(),r=n.getAttributeStreamRef(0),o=new su;for(let i=0,a=n.getPathCount();i<a;i++){const t=n.isClosedPath(i);if(0===n.getPathSize(i))continue;const a=n.getPathStart(i),h=r.readPoint2D(2*a),m=h.clone();s.startPath(h);for(let u=a+1,l=n.getPathEnd(i);u<l;u++){const t=r.readPoint2D(2*u),n=J.distance(m,t);if(n>this.m_maxLength){let e=Math.ceil(n/this.m_maxLength);e>Z()&&(e=Z());const i=1/e;let r,a,h;m.compare(t)<0?(o.setStartXY(m),o.setEndXY(t),r=0,a=1):(o.setStartXY(t),o.setEndXY(m),r=e-2,a=-1);for(let t=0,n=e-1;t<n;t++,r+=a){this.progress_(),h=i*(r+1);const t=new J;o.queryCoord2D(h,t),s.lineTo(t),this.m_bSetDensifyFlag&&s.setAttribute(10,s.getPointCount()-1,0,1)}}else this.progress_();e.lineTo(t),m.assign(t)}if(t){const t=J.distance(m,h);if(t>this.m_maxLength){const e=h;let n=Math.ceil(t/this.m_maxLength);n>Z()&&(n=Z());const i=1/n;let r,a;m.compare(e)<0?(o.setStartXY(m),o.setEndXY(e),r=0,a=1):(o.setStartXY(e),o.setEndXY(m),r=n-2,a=-1);const u=new J(0,0);let l;for(let t=0,h=n-1;t<h;t++,r+=a)this.progress_(),l=i*(r+1),o.queryCoord2D(l,u),s.lineTo(u),this.m_bSetDensifyFlag&&s.setAttribute(10,s.getPointCount()-1,0,1)}s.closePathWithLine()}}return e}densifySegmentByLength(t,e,n,r,o,h){s(t.getGeometryType()!==i.enumBezier);let m=t.getStartXY().compare(t.getEndXY());if(0===m&&e<1){t.getGeometryType()===i.enumEllipticArc?m=t.getSweepAngle()<0?1:-1:a("densify segment by length")}let u=0;if(r&&(n?(t.queryStart(this.m_dummyPoint),n.startPathPoint(this.m_dummyPoint)):h.push(0),++u),e*this.m_maxSegmentsPerCurve<1&&(e=1/this.m_maxSegmentsPerCurve),e<1){this.m_segmentBuffer||(this.m_segmentBuffer=new nu);let s=Math.ceil(1/e);s>Z()&&(s=Z()),e=1/s,this.m_segmentBuffer.create(t.getGeometryType());let i,r,o,a=t;m<0?(i=0,r=1):(t.copyTo(this.m_segmentBuffer.get()),this.m_segmentBuffer.get().reverse(),i=s-2,r=-1,a=this.m_segmentBuffer.get());const l=s-1;for(let t=0;t<l;t++,i+=r)o=e*(i+1),n?(a.queryCoord(o,this.m_dummyPoint),n.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==o&&0!==o&&n.setAttribute(10,n.getPointCount()-1,0,1)):h.push(m>0?1-o:o),this.progress_();o=1,u+=l}(!o||o&&r&&u<2)&&(n?(t.queryEnd(this.m_dummyPoint),n.lineToPoint(this.m_dummyPoint)):h.push(1))}densifyCubicBezier(t,e,s,n,i){const r=new mo;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());if(0===h&&a>0){const e=_t(J,4);t.queryControlPoints(e),h=e[1].compare(e[2]),0===h&&(h=e[1].compare(e[0]))}h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++m);const u=[],l=[],c=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve));let g=!0,d=0;if(h>0)for(u.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new J(0,1)]),l.push(0);u.length;){this.progress_();const t=u.at(-1),r=l.at(-1),a=t[4].x,h=t[4].y;if(r<c&&this.bezierNeedsSplit(t)){g&&(d=o.findMinDeriv(),g=!1);let e=.5*(a+h);Math.abs(d-e)<.4*(h-a)&&(e=d);const s=(e-a)/(h-a),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),c=n.mul(1-s).add(i.mul(s)),_=i.mul(1-s).add(m.mul(s)),p=c.mul(1-s).add(_.mul(s)),f=t[3];t[1]=n,t[2]=c,t[3]=p,t[4].setCoords(a,e);const P=[p,_,m,f,new J(e,h)];u.push(P),l[l.length-1]=r+1,l.push(r+1)}else u.pop(),l.pop(),(u.length>0||!n||n&&s&&m<2)&&(e?(o.queryCoord(a,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==a&&0!==a&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(1-a),++m)}else for(u.push([o.getStartXY(),o.getControlPoint1(),o.getControlPoint2(),o.getEndXY(),new J(0,1)]),l.push(0);u.length;){this.progress_();const t=u.at(-1),r=l.at(-1),a=t[4].x,h=t[4].y;if(r<c&&this.bezierNeedsSplit(t)){g&&(d=o.findMinDeriv(),g=!1);let e=.5*(a+h);Math.abs(d-e)<.4*(h-a)&&(e=d);const s=(e-a)/(h-a),n=t[0].mul(1-s).add(t[1].mul(s)),i=t[1].mul(1-s).add(t[2].mul(s)),m=t[2].mul(1-s).add(t[3].mul(s)),c=n.mul(1-s).add(i.mul(s)),_=i.mul(1-s).add(m.mul(s)),p=c.mul(1-s).add(_.mul(s)),f=t[0];t[0]=p,t[1]=_,t[2]=m,t[4].setCoords(e,h);const P=[f,n,c,p,new J(a,e)];u.push(P),l[l.length-1]=r+1,l.push(r+1)}else u.pop(),l.pop(),(u.length>0||!n||n&&s&&m<2)&&(e?(o.queryCoord(h,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==h&&0!==h&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(h),++m)}}densifyRationalBezier2(t,e,s,n,i){const r=new on;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=0),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++m);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),l=new on,c=[],g=[];for(c.push(new U(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<u&&this.rationalBezier2NeedsSplit(o,l,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new U(e,t.vmax))):(c.at(-1).vmin=e,c.push(new U(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!n||n&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(h>0?1-s:s),++m}}}densifyBezier2(t,e,s,n,i){const r=new nn;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=0),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++m);const u=Math.ceil(Math.log2(this.m_maxSegmentsPerCurve)),l=new nn,c=[],g=[];for(c.push(new U(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<u&&this.bezier2NeedsSplit(o,l,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new U(e,t.vmax))):(c.at(-1).vmin=e,c.push(new U(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!n||n&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(h>0?1-s:s),++m}}}densifyEllipticArc(t,e,s,n,i){const r=new Oa;let o=t;const a=t.calculateUpperLength2D();let h=t.getStartXY().compare(t.getEndXY());0===h&&a>0&&(h=t.isClockwise()?0:1),h>0&&(t.copyTo(r),r.reverse(),o=r);let m=0;s&&(e?(t.queryStart(this.m_dummyPoint),e.startPathPoint(this.m_dummyPoint)):i.push(0),++m);const u=Math.trunc(Math.log2(this.m_maxSegmentsPerCurve)),l=new Oa,c=[],g=[];for(c.push(new U(0,1)),g.push(0);c.length;){this.progress_();const t=c.at(-1).clone(),r=g.at(-1);if(r<u&&this.ellipticArcNeedsSplit(o,l,t.vmin,t.vmax)){const e=t.getCenter();h>0?(c.at(-1).vmax=e,c.push(new U(e,t.vmax))):(c.at(-1).vmin=e,c.push(new U(t.vmin,e))),g[g.length-1]=r+1,g.push(r+1)}else if(c.pop(),g.pop(),c.length>0||!n||n&&s&&m<2){const s=h>0?t.vmin:t.vmax;e?(o.queryCoord(s,this.m_dummyPoint),e.lineToPoint(this.m_dummyPoint),this.m_bSetDensifyFlag&&1!==s&&0!==s&&e.setAttribute(10,e.getPointCount()-1,0,1)):i.push(h>0?1-s:s),++m}}}calculateLengthSubdivisionStep(t,e){const s=t.calculateUpperLength2D();if(!t.isCurve())return s?e/s:1;if(t.getGeometryType()===i.enumEllipticArc){const n=t;if(n.isCircular()||n.isDegenerate(0)||n.isDegenerateToLine()){let t=e/s;return t<this.m_minStep&&(t=this.m_minStep),t}return e/s*n.getSemiAxes().y/n.getSemiAxes().x}t.getGeometryType()===i.enumBezier&&a(""),a("")}calculateDeviationSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===i.enumEllipticArc){const s=t;if(s.isDegenerate(0)||s.isDegenerateToLine())return 1;{const n=s.getSemiMajorAxis(),i=1-e/n;let r=Math.PI/2;if(i>0){const t=4*Math.sqrt(e/n*.5);r=Math.min(Math.PI/2,Math.abs(t))}r=Math.max(r,2*Math.PI/this.m_maxSegmentsPerCurve);const o=r*n;return this.calculateLengthSubdivisionStep(t,o)}}a("")}calculateAngularSubdivisionStep(t,e){if(!t.isCurve())return 1;if(t.getGeometryType()===i.enumEllipticArc){const s=t;return s.isDegenerate(0)||s.isDegenerateToLine()?1:this.calculateLengthSubdivisionStep(t,e*s.getSemiMinorAxis())}a("")}rationalBezier2NeedsSplit(t,e,s,n){t.cutBezierIgnoreAttributes(s,n,e);let i=!1;if(this.m_maxLength>0){if(e.calculateUpperLength2D()>this.m_maxLength)return i=!0,!0}const r=_t(J,3);e.queryControlPoints(r);const o=[0,0,0];return e.queryWeights(o),!i&&this.m_maxDeviation>0&&(i=!ah.checkRationalBezier2MaxDeviation(r,o,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!ah.checkRationalBezier2MaxAngle(r,o,this.m_cosMaxAngle)),i}bezier2NeedsSplit(t,e,s,n){t.cutBezierIgnoreAttributes(s,n,e);let i=!1;if(this.m_maxLength>0){if(e.calculateUpperLength2D()>this.m_maxLength)return i=!0,!0}const r=_t(J,3);return e.queryControlPoints(r),!i&&this.m_maxDeviation>0&&(i=!ah.checkBezier2MaxDeviation(r,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!ah.checkBezier2MaxAngle(r,this.m_cosMaxAngle)),i}ellipticArcNeedsSplit(t,e,s,n){t.cutArcIgnoreAttributes(s,n,e);let i=!1;if(this.m_maxLength>0){if(e.calculateUpperLength2D()>this.m_maxLength)return i=!0,!0}return!i&&this.m_maxDeviation>0&&(i=!ah.checkEllipticArcMaxDeviation(e,this.m_maxDeviation)),!i&&this.m_maxAngle>0&&(i=!ah.checkEllipticArcMaxAngle(e,this.m_cosMaxAngle)),i}bezierNeedsSplit(t){let e=!1;if(this.m_maxLength>0){if(J.distance(t[0],t[1])+J.distance(t[1],t[2])+J.distance(t[2],t[3])>this.m_maxLength)return e=!0,!0}return!e&&this.m_maxDeviation>0&&(e=!ah.checkBezierMaxDeviation(t,this.m_maxDeviation)),!e&&this.m_maxAngle>0&&(e=!ah.checkBezierMaxAngle(t,this.m_cosMaxAngle)),e}progress_(){}static checkBezierMaxDeviation(t,e){const s=t[3].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1])),r=n.dotProduct(t[0].sub(t[2]));if(Math.max(Math.abs(i),Math.abs(r))<=e){const e=new J;jo(t,.5,e,!1);const n=e.sub(t[0]).dotProduct(s);return n>=0&&n<=s.sqrLength()}return!1}return Math.max(t[0].sub(t[1]).sqrLength(),t[0].sub(t[2]).sqrLength())<=e*e}static checkBezierMaxAngle(t,e){if(t[0].equals(t[3]))return!(!t[0].equals(t[1])||!t[1].equals(t[2]));const s=t[3].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}{const n=t[2].sub(t[1]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkRationalBezier2MaxDeviation(t,e,s){if(0===e[1])return!1;const n=t[2].sub(t[0]);if(n.sqrLength()>0){const e=n.clone();e.leftPerpendicularThis(),e.normalize();const i=e.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=s){const e=t[1].sub(t[0]).dotProduct(n);return e>=0&&e<=n.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=s*s}static checkRationalBezier2MaxAngle(t,e,s){if(0===e[1])return!1;if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const n=t[2].sub(t[0]);n.normalize();{const e=t[1].sub(t[0]),i=e.dotProduct(n);if(i<0)return!1;if(e.length()*s>i)return!1}return!0}static checkBezier2MaxDeviation(t,e){const s=t[2].sub(t[0]);if(s.sqrLength()>0){const n=s.clone();n.leftPerpendicularThis(),n.normalize();const i=n.dotProduct(t[0].sub(t[1]));if(Math.abs(i)<=e){const e=t[1].sub(t[0]).dotProduct(s);return e>=0&&e<=s.sqrLength()}return!1}return t[0].sub(t[1]).sqrLength()<=e*e}static checkBezier2MaxAngle(t,e){if(t[0].equals(t[2]))return!!t[0].equals(t[1]);const s=t[2].sub(t[0]);s.normalize();{const n=t[1].sub(t[0]),i=n.dotProduct(s);if(i<0)return!1;if(n.length()*e>i)return!1}return!0}static checkEllipticArcMaxDeviation(t,e){if(Math.abs(t.getSweepAngle())<Math.PI){const s=t.getEndXY().sub(t.getStartXY()),n=[0,0];if(1===pm(t,s,n)){const s=t.getCoord2D(n[0]),i=J.getClosestCoordinate(t.getStartXY(),t.getEndXY(),s),r=new J;St(t.getStartXY(),t.getEndXY(),i,r);return J.distance(s,r)<=e}}const s=t.getCoord2D(.5),n=new J;St(t.getEndXY(),t.getStartXY(),.5,n);return J.distance(s,n)<=e}static checkEllipticArcMaxAngle(t,e){const s=t.getTangent(0),n=t.getTangent(1),i=s.dotProduct(n);return!(i<0)&&!(s.length()*n.length()*e>i)}static checkTypeForReplace(t,e){return t.getGeometryType()===e&&(e!==i.enumEllipticArc||t.isCircular())}}function hh(t,e,s){const n=s.length;if(e<=0||n<=2)return n;let i=0;const r=O(n-1,Number.NaN);for(let o=1,a=n;o<a;o++){const e=t.tToLength(s[o]);r[o-1]=e-i,i=e}for(;r.length>1;){const t=r.findIndex((t=>t<=2*e));if(-1===t)break;let n=t+1,i=t+1;if(t>0){const e=t-1;(i===r.length||r[e]>r[i])&&(i=e,n--)}r[i]+=r[t],r.splice(t,1),s.splice(n,1)}return s.length}function mh(t,e,s,n,i){const r=[],o=[],a=ih(e,s,0,n,!1,r,o),h=new mo;let m=i;const u=e.getDescription();h.assignVertexDescription(u);const l=u.getAttributeCount()>1,c=new N,g=new su;for(let d=0,_=0;d<a;d++){if(r[_+1].isNAN()){if(l){let t=o[d];e.queryCoord(t,c),g.setStart(c),t=o[d+1],e.queryCoord(t,c),g.setEnd(c)}g.setStartXY(r[_]),g.setEndXY(r[_+3]),t.addSegment(g,m)}else{if(l){let t=o[d];e.queryCoord(t,c),h.setStart(c),t=o[d+1],e.queryCoord(t,c),h.setEnd(c)}h.setStartXY(r[_]),h.setControlPoint1(r[_+1]),h.setControlPoint2(r[_+2]),h.setEndXY(r[_+3]),t.addSegment(h,m)}_+=3,m=!1}}function uh(t,e,s,n,i){const r=[],o=[],a=rh(e,s,0,n,!1,r,o),h=new nn;let m=i;const u=e.getDescription();h.assignVertexDescription(u);const l=u.getAttributeCount()>1,c=new N,g=new su;for(let d=0,_=0;d<a;d++){if(r[_+1].isNAN()){if(l){let t=o[d];e.queryCoord(t,c),g.setStart(c),t=o[d+1],e.queryCoord(t,c),g.setEnd(c)}g.setStartXY(r[_]),g.setEndXY(r[_+2]),t.addSegment(g,m)}else{if(l){let t=o[d];e.queryCoord(t,c),h.setStart(c),t=o[d+1],e.queryCoord(t,c),h.setEnd(c)}h.setStartXY(r[_]),h.setControlPoint1(r[_+1]),h.setEndXY(r[_+2]),t.addSegment(h,m)}_+=2,m=!1}}function lh(t,e,n,r,o){s(t===i.enumBezier||t===i.enumEllipticArc||t===i.enumBezier2);const a=e.createInstance();a.getGeometryType()===i.enumPolygon&&a.setFillRule(e.getFillRule());const m=e.querySegmentIterator();for(let u=0,l=e.getPathCount();u<l;++u){if(!e.hasNonLinearSegmentsPath(u)){a.addPath(e,u,!0);continue}const o=e.getPathStart(u);let l=!0,c=0;for(m.resetToPath(u),s(m.nextPath());m.hasNextSegment();){const s=m.nextCurve();if(!s)break;{const g=m.getStartPointIndex()-o,d=g-c;d>0&&(a.addSegmentsFromPath(e,u,c,d,l),l=!1),c=g+1,t===i.enumBezier?mh(a,s,n,r,l):t===i.enumBezier2?uh(a,s,n,r,l):h(""),l=!1}}const g=e.getSegmentCountPath(u);g-c!=0&&a.addSegmentsFromPath(e,u,c,g-c,l)}return a}function ch(t,e,s,n,i,r,o,a){const h=e.clone();h.dropAllAttributes();const m=(t,e,s,n)=>(e&&(t&&e.push(n.getStartXY()),e.push(J.getNAN()),e.push(J.getNAN()),e.push(n.getEndXY())),s&&(t&&s.push(0),s.push(1)),1);if(h.isDegenerateToLine()||h.isDegenerate(0))return m(t,r,o,e);const u=h.getStartXY(),l=h.getEndXY(),c=h.getSemiAxes(),g=new ae;if(h.isCircular())g.setIdentity();else{const t=h.getAxisXRotation();g.setScaleCoords(1,h.getMinorMajorRatio()),g.rotateAngle(t)}const d=h.getCenter();g.shift(d);const _=g.clone();_.invertThis(),h.applyTransformation(_);const p=h.getSweepAngle();if(0===p)return m(t,r,o,e);const f=oe.constructEmpty();f.setCoords({center:d,width:2*c.x,height:2*c.x});const P=.05*f.calculateToleranceFromEnvelope(),y=Math.max(s/c.x,P/c.x);let x=4*Math.pow(y/.0741,1/6);x=Math.min(x,Math.PI/2);const C=ja(h.getStartAngle());let v=p>0?Math.floor(C/x):Math.ceil(C/x);v*=x;const b=p>0?x:-x;v+b===C&&(v+=b);let E=4/3*Math.tan(Math.abs(x)/4);p>0&&(E=-E),o&&t&&o.push(0);const S=x/Math.abs(p);let D=(v-C)/p;const w=u.clone(),A=new J;h.queryCoord2D(0,A);const T=A.clone(),I=1-.01*S;let M=0,Y=0;for(;D<1;){let s;if(D+=S,Y>0&&D<I)s=E;else{D>=I&&(D=1);const t=(D-Y)*p;s=4/3*Math.tan(Math.abs(t)/4),p>0&&(s=-s)}h.queryCoord2D(D,A);const a=new J;g.queryTransform(A,a);const m=e.getClosestCoordinate(a,!1);if(e.queryCoord2D(m,a),1!==D&&(J.distance(w,a)<=2*n||J.distance(a,l)<=2*n))continue;w.setCoordsPoint2D(a);const c=_t(J,4);c[0].assign(T),c[3].assign(A),c[1].rightPerpendicularOther(T),c[1].scaleAddThis(s,T),c[2].leftPerpendicularOther(A),c[2].scaleAddThis(s,A),g.transformPoints2D(c,3,c),c[3].assign(a),0===Y&&c[0].setCoordsPoint2D(u),1===D&&c[3].setCoordsPoint2D(l),i&&zo(c);let d=!0;for(let t=1;t<4;t++)if(!c[t].isEqualPoint2D(c[0])){d=!1;break}d||(o&&o.push(m),r&&(0===Y&&t&&r.push(c[0].clone()),r.push(c[1].clone()),r.push(c[2].clone()),r.push(c[3].clone())),M++),Y=D,T.setCoordsPoint2D(A)}return M}function gh(t,e,s,n,i,r,o,a){e.clone().dropAllAttributes();const h=new oe;e.queryLooseEnvelope(h);const m=.05*h.calculateToleranceFromEnvelope(),u=Math.max(s,m);t&&o.push(0);let l=0;const c=_t(J,3);e.queryControlPoints(c);const g=[0,0,0];e.queryWeights(g);const d=[],_=O(9,Number.NaN);let p=e.getMonotonicPartParams(_.length,_);_.length=p,p=hh(e,n,_);let f=0,P=t;for(let y=1;y<p;y++){const t=_[y];for(d.push(f),d.push(t);d.length>1;){const t=d.at(-1);d.pop();const e=d.at(-1),s=_t(J,3);Xi(c,g,t,e,s,[0,0,0]);const n=_t(J,3),i=no(s,g,n),a=16,h=d.length>a;u>=i||h?(o.push(e),P&&(r.push(n[0]),P=!1),r.push(n[1]),r.push(n[2]),l++):(d.push(.5*(t+e)),d.push(t))}f=t}return l}function dh(t,e,s,n,i,r,o,a){e.clone().dropAllAttributes();const h=new oe;e.queryLooseEnvelope(h);const m=.05*h.calculateToleranceFromEnvelope(),u=Math.max(s,m);o&&t&&o.push(0);let l=0;const c=_t(J,3);e.queryControlPoints(c);const g=[0,0,0];e.queryWeights(g);const d=[],_=O(9,Number.NaN);let p=0;i?(p=e.getMonotonicPartParams(_.length,_),_.length=p,p=hh(e,n,_)):(_.length=2,p=2,_[0]=0,_[1]=1);let f=0,P=t;for(let y=1;y<p;y++){const t=_[y];for(d.length=0,d.push(t),d.push(f);d.length>1;){const t=d.at(-1);d.pop();const e=d.at(-1),s=_t(J,3),n=[0,0,0];Xi(c,g,t,e,s,n);const i=_t(J,4),a=Ni(s,n,i),h=16,m=d.length>h;u>=a||m?(o.push(e),r&&(P&&(r.push(i[0]),P=!1),r.push(i[1]),r.push(i[2]),r.push(i[3])),l++):(d.push(.5*(t+e)),d.push(t))}f=t}return l}function _h(t,e,s,n,i,r,o,a){const h=e.clone();if(h.dropAllAttributes(),h.isDegenerateToLine()||0===h.getSweepAngle())return t&&r.push(e.getStartXY()),r.push(J.getNAN()),r.push(e.getEndXY()),t&&o.push(0),o.push(1),1;const m=h.getStartXY(),u=h.getEndXY(),l=h.getSemiAxes(),c=new ae;if(h.isCircular())c.setIdentity();else{const t=h.getAxisXRotation();c.setScaleCoords(1,h.getMinorMajorRatio()),c.rotateAngle(t)}const g=h.getCenter();c.shift(g);const d=c.clone();d.invertThis(),h.applyTransformation(d);const _=oe.constructEmpty();_.setCoords({center:g,width:2*l.x,height:2*l.x});const p=.05*_.calculateToleranceFromEnvelope(),f=Math.max(s/l.x,p/l.x),P=Math.sqrt(2*f+f*f);let y=2*Math.sqrt(2*P*(1+f-P));y=Math.min(y,Math.PI/2);const x=h.getSweepAngle(),C=Math.ceil(Math.abs(x)/y),v=Math.max(C,1);y=x/v;const b=1/v;let E=Math.tan(Math.abs(y)/2);x>0&&(E=-E),t&&o.push(0);const S=new J;h.queryCoord2D(0,S);for(let D=0;D<v;D++){const e=S.clone(),s=(D+1)*b;o.push(s),h.queryCoord2D(s,S);const n=_t(J,3);n[0].assign(e),n[2].assign(S),n[1].rightPerpendicularOther(n[0]),n[1].mulThis(E),n[1].addThis(n[0]),c.transformPoints2D(n,3,n),0===D&&n[0].setCoordsPoint2D(m),D===v-1&&n[2].setCoordsPoint2D(u),0===D&&t&&r.push(n[0]),r.push(n[1]),r.push(n[2])}return v}function ph(t,e,s,n,i,r,o,a){e.clone().dropAllAttributes();const h=new oe;e.queryLooseEnvelope(h);const m=.05*h.calculateToleranceFromEnvelope(),u=Math.max(s,m);t&&o.push(0);let l=0;const c=_t(J,4);e.queryControlPoints(c);const g=[],d=O(9,Number.NaN);let _=e.getMonotonicPartParams(d.length,d);d.length=_,_=hh(e,n,d);let p=0,f=t;for(let P=1;P<_;P++){const t=d[P];for(g.push(p),g.push(t);g.length>1;){const t=g.at(-1);g.pop();const e=g.at(-1),s=_t(J,4);Wo(c,t,e,s);const n=_t(J,3),i=so(s,n),a=16,h=g.length>a;u>=i||h?(o.push(e),f&&(r.push(n[0]),f=!1),r.push(n[1]),r.push(n[2]),l++):(g.push(.5*(t+e)),g.push(t))}p=t}return l}function fh(){return{e2:0,completeE:0}}class Ph{constructor(t,e){this.m_arc=t,this.m_sqrChordLength=e}getMaxDerivative(){return 1}getValue(t,e){return 0===t?J.sqrDistance(this.m_arc.getCoord2D(e),this.m_arc.getCoord2D(1-e))-this.m_sqrChordLength:0}getError(t){return 0}}function yh(t,e,s){if(zh(t)){ls(new su({start:t.getStartXY(),end:t.getEndXY()}),e,s)}else if(0===e.value())s.set(t.getStartXY());else if(1===e.value())s.set(t.getEndXY());else{const n=new st;Th(t,e,n);const i=new st,r=new st;st.st_cosAndSin(n,i,r);const o=Se.constructCoordsE(new st(t.m_semiMajorAxis).mulThisE(i),new st(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio).mulThisE(r)),a=new st(t.m_rotation);st.st_cosAndSin(a,i,r),o.rotateDirect(i,r),o.addThisE(Se.constructPoint2D(t.m_center)),s.setE(o)}}function xh(t,e){return t.convertToCanonic(e)}function Ch(t,e){const s=new U(t.getStartAngle(),t.getEndAngle());s.normalize();const n=Lt(),i=Jt(e,n);if(i<s.vmin){let t=i+n;for(;t<s.vmin;)t+=n;return s.containsCoordinate(t)?t:s.vmin-i<t-s.vmax?i:t}if(i>s.vmax){let t=i-n;for(;t>s.vmax;)t-=n;return s.containsCoordinate(t)||s.vmin-t<i-s.vmax?t:i}return i}function vh(t,e,s,n){let i=t.m_startAngle,r=t.m_sweepAngle;const o=1e-12;for(;i>Nt();)i-=2*Nt();for(;i<=-Nt();)i+=2*Nt();if(!Number.isNaN(e)){for(;e>Nt();)e-=2*Nt();for(;e<=-Nt();)e+=2*Nt();!s&&e>i&&(e-=2*Nt()),s&&e<i&&(e+=2*Nt()),r=e-i,Math.abs(r)<o&&!n&&(r=s?2*Nt():-2*Nt()),Math.abs(r)>2*Nt()-o&&n&&(r=0)}Math.abs(r)>2*Nt()-o&&(r=r>=0?2*Nt():-2*Nt(),t.setEndXY(t.getStartXY())),Math.abs(r)<o&&(r=0,t.setEndXY(t.getStartXY())),n=Math.abs(r)<=Nt(),r&&(s=r>0),t.m_startAngle=bh(i),t.m_sweepAngle=r,Jh(t,!n),Oh(t,s)}function bh(t){let e=t,s=!1;return e<=-Nt()?(e+=Lt(),s=!0):e>Nt()&&(e-=Lt(),s=!0),e<=-Nt()?(e=Jt(e,Lt()),e<=-Nt()&&(e+=Lt()),s=!0):e>Nt()&&(e=Jt(e,Lt()),e>Nt()&&(e-=Lt()),s=!0),s&&(e>Nt()||e<=-Nt())&&(e=Nt()),e}function Eh(t,e,s){const n=s,i=n.getSemiAxes();let r=new J(i.x*Math.cos(t[0]),i.y*Math.sin(t[0]));return r=n.convertFromCanonic(r),J.sqrDistance(r,n.getStartXY())}function Sh(t,e,s){const n=s,i=n.getSemiAxes(),r=t[0]+n.getStartAngle();let o=new J(i.x*Math.cos(r),i.y*Math.sin(r));return o=n.convertFromCanonic(o),J.sqrDistance(o,n.getEndXY())}function Dh(t){if(t.m_center.isNAN())return t.m_startAngle=0,void(t.m_sweepAngle=0);const e=t.getStartXY(),s=t.getEndXY(),n=e.equals(s),i=Kh(t),r=Qh(t),o=t.projectionBehavior();if(n){const s=t.convertToCanonic(e),n=new J(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);s.x/=n.x,s.y/=n.y,t.m_startAngle=bh(Math.atan2(s.y,s.x)),t.m_sweepAngle=i?r?Lt():-Lt():0}else{const n=t.convertToCanonic(e),a=new J(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);n.x/=a.x,n.y/=a.y;const h=t.convertToCanonic(s);h.x/=a.x,h.y/=a.y,t.m_startAngle=Math.atan2(n.y,n.x),t.m_sweepAngle=J.calculateAngle(n,h),r?t.m_sweepAngle<0&&(t.m_sweepAngle+=Lt()):t.m_sweepAngle>0&&(t.m_sweepAngle-=Lt()),t.m_startAngle=bh(t.m_startAngle);let m=Eh([t.m_startAngle],1,t);if(m=Math.sqrt(m),m>.25*Ue(t)){const e=t.m_startAngle-1e-4,s=t.m_startAngle+1e-4,n=[0];Vs(Eh,t,1,[t.m_startAngle],[e],[s],1e-14,n),t.m_startAngle=bh(n[0])}if(m=Sh([t.m_sweepAngle],1,t),m=Math.sqrt(m),m>.25*Ue(t)){const e=t.m_sweepAngle-1e-4,s=t.m_sweepAngle+1e-4,n=[0];Vs(Sh,t,1,[t.m_sweepAngle],[e],[s],1e-14,n),t.m_sweepAngle=n[0]}const u=Math.abs(t.m_sweepAngle)>Nt();if(Jh(t,u),i!==u&&!i&&Math.abs(t.m_sweepAngle)>1.5*Nt())return void Rh(t,e,s,o);if(0===t.m_sweepAngle||r!==t.m_sweepAngle>0)return void Rh(t,e,s,o)}}function wh(t,e){return(Ch(t,e)-t.getStartAngle())/t.getSweepAngle()}function Ah(t,e){return t.m_startAngle+e*t.m_sweepAngle}function Th(t,e,s){s.assign(new st(t.m_startAngle).addE(e.mulE(new st(t.m_sweepAngle))))}function Ih(t,e){const s=new st(t.m_cosr).sqrThis(),n=new st(t.m_sinr).sqrThis(),i=new st(t.m_minorMajorRatio),r=new st(1/t.m_minorMajorRatio),o=i.mulE(s).addThisE(r.mulE(n)),a=i.subE(r).mulThis(2*t.m_cosr*t.m_sinr),h=i.mulE(n).addThisE(r.mulE(s));e[0]=o,e[1]=a,e[2]=h,e[3]=new st(-t.m_semiMajorAxis).mulThis(t.m_semiMajorAxis).mulThis(t.m_minorMajorRatio)}function Mh(t,e){const s=new De;s.a11.setE(t[0]),s.a12=st.st_mulByPower2(t[1],.5),s.a21.setE(s.a12),s.a22.setE(t[2]);const n=[J.getNAN(),J.getNAN()],i=[new st,new st];s.eigenSymmetric(i,n);const r=t[3].clone();r.negateThis(),r.invThis(),i[0].mulThisE(r),i[1].mulThisE(r),i[0].sqrtThis().invThis(),i[1].sqrtThis().invThis(),e.x=i[0].toDouble(),e.y=i[1].toDouble();return Math.atan2(n[0].y,n[0].x)}function Yh(t,e,s){if(zh(t))return(s-e)*J.distance(t.getStartXY(),t.getEndXY());if(1===t.m_minorMajorRatio)return Math.abs(t.getSweepAngle()*(e-s))*t.m_semiMajorAxis;const n=kh(t,e);return kh(t,s)-n}function Xh(t){return t.m_cachedValues}function Nh(t){if(t.m_cachedValues)return t.m_cachedValues;const e=fh();return e.e2=Vh(t),e.completeE=Kt(e.e2),t.m_cachedValues=e,e}function qh(t,e,s,n){if(!e.isEqual(t.m_XStart,t.m_YStart)||!s.isEqual(t.m_XEnd,t.m_YEnd)){if(zh(t))return t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,t.m_YEnd=s.y,mm(t),void t.afterCompletedModification();if(n&&Math.abs(t.getSweepAngle())<=1.01*Vt()){const n=_t(J,3),i=nm(t,n);if(Ai(n)){n[0].assign(e),n[2].assign(s),Ii(n);if(0===t.projectionBehavior()){let e=0,s=2;J.sqrDistance(n[1],n[0])<J.sqrDistance(n[1],n[2])&&(s=tt(e,e=s));const i=n[s].sub(n[e]),r=i.length();i.divThis(r);const o=n[1].sub(n[e]),a=o.length(),h=o.dotProduct(i)/a,m=o.crossProduct(i)/a,u=new J;St(n[e],n[s],.5,u);const l=.5*r/m*lt(1-h,0,1),c=n[1].side(n[e],n[s]),g=i.clone();c?g.leftPerpendicularThis():g.rightPerpendicularThis();const d=u.sub(g.mul(l));t.constructCircularArcThreePoint(n[0],n[2],d)}else im(n,i*i,null,!1,t);return}}0===t.projectionBehavior()?ym(t,e,s):xm(t,e,s)}}function Fh(t,e,s){const n=0===t.projectionBehavior();if(s<=2)return void Rh(t,e[0],e[s-1],n?0:1);if(n){t.constructCircularArcThreePoint(e[0],e[s-1],e[Math.trunc(s/2)]);const n=new J;return t.queryCoord2D(.5,n),void t.m_interior.setCoordsPoint2D(n)}const i=t.getSemiMajorAxis(),r=t.getMinorMajorRatio(),o=t.getAxisXRotation(),a=t.getCenter(),h=new Array(4);h[0]=t.isMajor(),h[1]=!h[0],h[2]=h[0],h[3]=!h[0];const m=new Array(4);m[0]=t.isClockwise(),m[1]=m[0],m[2]=!m[0],m[3]=!m[0];const u=Math.trunc(s<5?1:(s+4)/5),l=_t(Oa,4),c=O(4,Number.NaN);let g=0;for(let d=0;d<4;d++){l[d].constructEllipticArcEndPointsCenter(e[0],e[s-1],i,r,o,h[d],m[d],a),c[d]=0;let t=0;for(let n=u;n<s-1;n+=u){const s=l[d].getClosestCoordinate(e[n],!1);c[d]+=J.sqrDistance(l[d].getCoord2D(s),e[n]),t++}c[d]/=t,c[d]<c[g]&&(g=d)}t.assignCopy(l[g])}function Vh(t){return 1-Tt(t.m_minorMajorRatio)}function Lh(t,e,s,n,i,r,o,a,h){return t.m_bits=0,t.m_rotation=r,Ne(t,e),Fe(t,s),t.m_cosr=Math.cos(r),t.m_sinr=Math.sin(r),Jh(t,o),Oh(t,a),void 0!==h?t.m_center.assign(h):t.m_center.setNAN(),t.setProjectionBehavior(1),t.m_semiMajorAxis=n,t.m_minorMajorRatio=i,sm(t,void 0===h)}function Rh(t,e,s,n){t.m_bits=0,t.m_rotation=0,Ne(t,e),Fe(t,s),t.m_interior.assign(e.add(s).mul(.5)),t.m_startAngle=0,t.m_sweepAngle=0,t.m_cosr=1,t.m_sinr=0,Jh(t,!1),Oh(t,!1),t.m_center.setNAN(),t.m_semiMajorAxis=1,t.m_minorMajorRatio=0,t.setProjectionBehavior(n),t.afterCompletedModification()}function zh(t){return t.m_center.isNAN()}function kh(t,e){if(0===e)return 0;const s=Nh(t),n=Ah(t,e),i=Vt(),r=Gh(t),o=Rt(n+i,s.e2,s.completeE),a=t.m_semiMajorAxis*(o-r);return Math.abs(a)}function Bh(t,e){if(zh(t)){const s=J.distance(t.getStartXY(),t.getEndXY());return 0===s?0:e/s}if(1===t.m_minorMajorRatio){const s=Math.abs(t.getSweepAngle()*t.m_semiMajorAxis);return 0===s?0:e/s}if(0===e)return 0;const s=t.getSweepAngle();if(0===s)return.5;const n=Nh(t),i=Vt(),r=Gh(t);s<0&&(e=-e);const o=e/t.m_semiMajorAxis+r;let a=zt(o,n.e2,n.completeE);a-=i,a-=t.getStartAngle();return a/s}function Gh(t){const e=Nh(t);return Rt(t.getStartAngle()+Vt(),e.e2,e.completeE)}function Wh(t,e,n){if(2===e.m_TransformationType)return void s(0);if(s(!tm(t)),e.isIdentity())return;Hh(t);const i=J.getNAN();i.x=t.m_XStart,i.y=t.m_YStart,e.transformInPlace(i);const r=J.getNAN();if(r.x=t.m_XEnd,r.y=t.m_YEnd,e.transformInPlace(r),zh(t))return t.m_XStart=i.x,t.m_YStart=i.y,t.m_XEnd=r.x,void(t.m_YEnd=r.y);const o=t.m_center.clone();if(e.transformInPlace(o),n||e.isUniformNoRotation()){let s=Qh(t);e.isReflective()&&(s=!s);if(0===t.projectionBehavior()){if(!i.equals(r)){const s=t.m_interior.clone();return e.transformInPlace(s),void t.constructCircularArcThreePoint(i,r,s)}return void jh(t,i,r,o,s,!1)}const n=new J(t.m_cosr,t.m_sinr);e.transformWithoutTranslateInPlace(n);const a=Math.atan2(n.y,n.x),h=t.getSemiAxes();e.transformWithoutTranslateInPlace(h);const m=t.m_center.clone();return e.transformInPlace(m),void t.constructEllipticArcEndPointsCenter(i,r,h.x,h.y/h.x,a,t.isMajor(),s,m)}{{const s=new Array(4);Ih(t,s);const n=new De;n.a11.setE(s[0]),n.a12.setE(s[1]),n.a12.mulThisByPower2(.5),n.a21.setE(n.a12),n.a22.setE(s[2]);if(!n.det().isZero()){const a=new De;if(a.a11.set(e.xx),a.a12.set(e.xy),a.a21.set(e.yx),a.a22.set(e.yy),a.invertThis()){const h=a.clone();h.transposeThis();const m=n.clone();m.mulThis(a),m.mulLeftThis(h);if(!m.det().isZero()){const n=_t(st,4);n[0].setE(m.a11),n[1].setE(m.a12),n[1].mulThisByPower2(2),n[2].setE(m.a22),n[3].setE(s[3]);const a=J.getNAN(),h=Mh(n,a);let u=Qh(t);return e.isReflective()&&(u=!u),void t.constructEllipticArcEndPointsCenter(i,r,a.x,a.y/a.x,h,t.isMajor(),u,o)}}}}const s=[J.getNAN(),J.getNAN(),J.getNAN()];s[0].setCoords(t.getSemiMajorAxis(),0),s[0].rotateDirect(t.m_cosr,t.m_sinr),s[1].setCoords(t.getSemiMajorAxis(),t.getSemiMinorAxis()),s[1].rotateDirect(t.m_cosr,t.m_sinr),s[2].setCoords(0,t.getSemiMinorAxis()),s[2].rotateDirect(t.m_cosr,t.m_sinr);let n=t.isClockwise();n&&(s[2]=tt(s[0],s[0]=s[2]));const a=.5;e.transformWithoutTranslateArray(s,3,s),e.isReflective()&&(n=!n);const h=new J(0,0),m=t.createInstance();im(s,a,h,!1,m),t.constructEllipticArcEndPointsCenter(i,r,m.getSemiMajorAxis(),m.getMinorMajorRatio(),m.getAxisXRotation(),t.isMajor(),!n,o)}}function jh(t,e,s,n,i,r){const o=.5*(n.sub(e).length()+n.sub(s).length());t.m_center.assign(n),t.m_startAngle=Math.atan2(e.y-t.m_center.y,e.x-t.m_center.x);vh(t,Math.atan2(s.y-t.m_center.y,s.x-t.m_center.x),i,r);const a=t.constructEllipticArcEndPointsCenter(e,s,o,1,0,Math.abs(t.m_sweepAngle)>Math.PI,t.m_sweepAngle>0,n);return t.setProjectionBehavior(0),a}function Zh(t,e){t.m_cachedValues=e}function Hh(t){t.m_cachedValues=null}function Uh(t,e){e.m_cachedValues=tt(t.m_cachedValues,t.m_cachedValues=e.m_cachedValues)}function Oh(t,e){const s=e?1:0;t.m_bits=-2&t.m_bits|s}function Qh(t){return!!(1&t.m_bits)}function Jh(t,e){const s=e?1:0;t.m_bits=-3&t.m_bits|s<<1}function Kh(t){return!!(2&t.m_bits)}function $h(t){if(t.m_center.isNAN())return!1;const e=8,s=new Se;s.setWithEps(t.getStartXY(),e),s.subThisE((new Se).setWithEps(t.m_center,e));const n=new st;n.setWithEps(t.m_rotation,e);const i=new st,r=new st;st.st_cosAndSin(n,i,r),s.rotateReverse(i,r);const o=new Se;o.setWithEps(t.getEndXY()),o.subThisE(Se.constructPoint2D(t.m_center)),o.rotateReverse(i,r);const a=new st;a.setWithEps(t.m_semiMajorAxis,e);const h=a.clone(),m=new st;m.setWithEps(t.m_minorMajorRatio),h.mulThisE(m),s.x.divThisE(a),s.y.divThisE(h),o.x.divThisE(a),o.y.divThisE(h);const u=s.x.sqr().addThisE(s.y.sqr()).subThisE(nt),l=o.x.sqr().addThisE(o.y.sqr()).subThisE(nt);return!u.isZero()||!l.isZero()}function tm(t){return!!(8&t.m_bits)}function em(t){t.m_bits&=-9}function sm(t,e){em(t);const s=t.getStartXY(),n=t.getEndXY();let i=!1;const r=Kh(t),o=Qh(t),a=t.projectionBehavior(),h=s.equals(n);let m=0===t.m_minorMajorRatio||0===t.m_semiMajorAxis;if(Number.isNaN(t.m_minorMajorRatio)&&(0===t.m_semiMajorAxis?t.m_minorMajorRatio=1:g("NAN minor major ratio and non-zero major axis")),m||=e?h:t.m_center.isNAN(),m)return Rh(t,s,n,a),!0;t.m_semiMajorAxis=Math.abs(t.m_semiMajorAxis),t.m_minorMajorRatio=Math.abs(t.m_minorMajorRatio),t.m_minorMajorRatio>1&&(t.m_semiMajorAxis*=t.m_minorMajorRatio,t.m_minorMajorRatio=1/t.m_minorMajorRatio);const u=new J(t.m_semiMajorAxis,t.m_semiMajorAxis*t.m_minorMajorRatio);if(h){const e=t.convertToCanonic(s);e.x/=u.x,e.y/=u.y;const n=Math.sqrt(Tt(e.x)+Tt(e.y));if(i=1!==n,t.m_semiMajorAxis*=n,u.mulThis(n),t.m_startAngle=bh(Math.atan2(e.y,e.x)),!r)return t.m_interior.assign(s),t.m_sweepAngle=0,t.afterCompletedModification(),i;t.m_sweepAngle=o?Lt():-Lt()}else{let e=t.m_center.isNAN()||$h(t);if(!e){const i=t.convertToCanonic(s);i.x/=u.x,i.y/=u.y;const r=new J(1,0);t.m_startAngle=J.calculateAngle(r,i);const o=t.convertToCanonic(n);o.x/=u.x,o.y/=u.y,t.m_sweepAngle=J.calculateAngle(i,o),e=!om(t)}if(e){i=!0;const e=s.sub(n).mulThis(.5);e.rotateReverse(t.m_cosr,t.m_sinr);let a=Tt(e.x/u.x)+Tt(e.y/u.y);a>1&&(a=Math.sqrt(a),t.m_semiMajorAxis*=a,u.mulThis(a));const h=new J(0,0);{const t=u.x*u.x,s=u.y*u.y,n=t*e.y*e.y+s*e.x*e.x,i=t*s-n;if(i>0){const t=Math.sqrt(i/n);h.setCoords(u.x*e.y/u.y,-u.y*e.x/u.x),h.mulThis(t),r===o&&h.negateThis()}}{const e=new J(h.x,h.y);e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(s.add(n).mulThis(.5)),t.m_center.assign(e)}}if(Dh(t),!om(t))return Rh(t,s,n,a),!0}return mm(t),t.afterCompletedModification(),i}function nm(t,e){s(Math.abs(t.getSweepAngle())<15*Math.PI/16);const n=t.getSemiMajorAxis(),i=t.getSemiMinorAxis();let r;if(0===n)return e[0].setCoordsPoint2D(t.getStartXY()),e[1].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getStartXY()),r=1,r;if(0===i)return e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1]=J.lerp(e[0],e[2],.5),r=1,r;const o=t.getSweepAngle(),a=t.getStartAngle(),h=a+o,m=new J(-n*Math.sin(a),i*Math.cos(a)),u=new J(-n*Math.sin(h),i*Math.cos(h));m.normalize(),u.normalize(),m.rotateDirect(t.m_cosr,t.m_sinr),u.rotateDirect(t.m_cosr,t.m_sinr),e[0].setCoordsPoint2D(t.getStartXY()),e[2].setCoordsPoint2D(t.getEndXY()),e[1].setSub(e[2],e[0]);const l=m.crossProduct(u);e[1].assign(m.mul(e[1].crossProduct(u)/l)),e[1].addThis(e[0]);return r=Math.cos(.5*o),r}function im(t,e,n,i,r){if(i){const s=.5,n=Math.sqrt(e),i=Tt(1-s)+2*n*s*(1-s)+Tt(s),o=t[0].mul(Tt(1-s)).add(t[1].mul(2*n*s*(1-s))).add(t[2].mul(Tt(s))).divThis(i);return r.constructCircularArcThreePoint(t[0],t[2],o),!0}const o=t[0].sub(t[1]),a=t[2].sub(t[1]),h=o.crossProduct(a),m=o.dotProduct(a),u=e;s(u<=1),s(u>0);const l=.5/(1-u),c=o.sqrLength(),g=m,d=a.sqrLength(),_=Tt(h),p=o.sub(a).sqrLength();if(0===_)return Rh(r,t[0],t[2],1),!1;if(m<=-Math.sqrt(c)*Math.sqrt(d))return Rh(r,t[0],t[2],1),!1;const f=[0,0],P=new U;P.setInfinite();const y=qs(2*_,-(p/u+4*g),2*(1-u)/u,P,!1,f);if(0===y)return Rh(r,t[0],t[2],1),!1;1===y&&(f[1]=f[0]);const x=Math.sqrt(l/f[0]),C=Math.sqrt(l/f[1]),v=.5/u;let b=v-d*f[0],E=v-c*f[0];Math.abs(b)>Math.abs(E)?E=g*f[0]-v+1:b=g*f[0]-v+1;const S=o.mul(b).add(a.mul(E)),D=S.norm(1)<1e-15*x?0:Math.atan2(S.y,S.x)+Math.PI,w=o.add(a),A=n?n.clone():t[1].add(w.mul(l)),T=t[0].sub(A),I=t[2].sub(A),M=T.crossProduct(I)<0,Y=!1;new Oa;return r.constructEllipticArcEndPointsCenter(t[0],t[2],x,C/x,D,Y,!M,A)}function rm(t,e,s,n,i){return im(t,e,s,n,i)}function om(t){let e=!1;{const s=new J(t.m_semiMajorAxis*Math.cos(t.m_startAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle));s.rotateDirect(t.m_cosr,t.m_sinr),s.addThis(t.m_center);e=J.distance(t.getStartXY(),s)>Ue(t)}let s=!1;if(!e){const e=new J(t.m_semiMajorAxis*Math.cos(t.m_startAngle+t.m_sweepAngle),t.getSemiMinorAxis()*Math.sin(t.m_startAngle+t.m_sweepAngle));e.rotateDirect(t.m_cosr,t.m_sinr),e.addThis(t.m_center);s=J.distance(t.getEndXY(),e)>Ue(t)}return!e&&!s}function am(t,s,n,i){0===n&&e("construct_enclosing_circle");const r=[0,0,0],o=Ja(s,n,r);if(1===o)t.constructCircleRadius(0,s[r[0]],i);else if(2===o){const e=J.lerp(s[r[0]],s[r[1]],.5),n=J.distance(s[r[0]],e),o=J.distance(s[r[1]],e);t.constructCircleRadius(Math.max(n,o),e,i)}else if(3===o){const e=J.calculateCircleCenterFromThreePoints(s[r[0]],s[r[1]],s[r[2]]),n=J.distance(s[r[0]],e),o=J.distance(s[r[1]],e),a=J.distance(s[r[2]],e);t.constructCircleRadius(Math.max(n,o,a),e,i)}else h("unexpected")}function hm(t){if(zh(t))return 0;if(t.isDegenerate(0))return 0;const e=t.m_semiMajorAxis,s=t.getSemiMinorAxis(),n=e*e+s*s,i=t.getStartAngle(),r=t.getEndAngle(),o=t.m_center.y-t.m_YStart,a=t.m_cosr,h=t.m_sinr;let m=1,u=0;t.m_rotation&&(m=(a-h)*(a+h),u=2*a*h);const l=((-.5*(r-i)+.25*m*(2*Math.cos(r+i)*Math.sin(r-i)))*s+-2*Math.sin(.5*(r+i))*Math.sin(.5*(r-i))*a*o)*e/n;let c=0;if(t.m_rotation){c=.125*(-2*Math.sin(r+i)*Math.sin(r-i))*u-s*o/n*(2*Math.cos(.5*(r+i))*Math.sin(.5*(r-i)))*h}return n*(l+c)+-.5*(t.m_XEnd-t.m_XStart)*(t.m_YEnd-t.m_YStart)}function mm(t){t.queryCoord2D(.5,t.m_interior)}function um(t,e,s,n,i){if(i){if(0!==Hm(e,s))return 2}else if(Ae(e,s))return 1;return 0!==cm(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function lm(t,e,s,n,i){if(i){if(0!==Hm(e,s))return 2}else if(Ae(e,s))return 1;return 0!==gm(t,e,s,null,null,null,n,void 0!==i&&i,!0,!1)?4:0}function cm(t,e,n,i,r,o,a,h,m,u){if(zh(e)){return ps(new su({start:e.getStartXY(),end:e.getEndXY()}),n,i,r,o,a,h,u)}null!==r&&(r.length=0),null!==o&&(o.length=0),null!==i&&(i.length=0);const l=Oe(e,n);if(Qe(e,n,a=Math.max(l,a)))return 0;const c=n.getStartXY();c.subThis(e.m_center);const g=n.getEndXY();g.subThis(e.m_center),c.rotateReverse(e.m_cosr,e.m_sinr),g.rotateReverse(e.m_cosr,e.m_sinr);const d=g.clone();d.subThis(c);const _=e.m_semiMajorAxis,p=1/_,f=e.getSemiMinorAxis(),P=1/f,y=d.clone();y.leftPerpendicularThis();const x=Math.atan2(f*y.y,_*y.x),C=O(16,Number.NaN),v=O(16,Number.NaN);let b=0;const E=[x,x+Math.PI];for(let s=0;s<2;++s){const t=wh(e,E[s]);if(t>=0&&t<=1){C[b]=t;const s=e.getCoord2D(C[b]);v[b]=n.getClosestCoordinate(s,!1),J.distance(s,n.getCoord2D(v[b]))<=a&&b++}}const S=c.x*p,D=c.y*P,w=d.x*p,A=d.y*P;let T=qs(w*w+A*A,2*(S*w+D*A),S*S+D*D-1,U.unit(),!1,v);s(T>=0);for(let s=0;s<T;s++){const t=d.mul(v[s]).add(c);t.x*=p,t.y*=P;const i=wh(e,Math.atan2(t.y,t.x));if(i>=0&&i<=1){C[b]=i;const t=e.getCoord2D(i);v[b]=n.getClosestCoordinate(t,!1),J.distance(t,n.getCoord2D(v[b]))<=a&&b++}}s(b<C.length+4);const I=O(16,Number.NaN);T=e.intersectPoint(n.getStartXY(),I,a);for(let s=0;s<T;s++,b++)C[b]=I[s],v[b]=0;T=e.intersectPoint(n.getEndXY(),I,a);for(let s=0;s<T;s++,b++)C[b]=I[s],v[b]=1;T=n.intersectPoint(e.getStartXY(),I,a);for(let s=0;s<T;s++,b++)C[b]=0,v[b]=I[s];T=n.intersectPoint(e.getEndXY(),I,a);for(let s=0;s<T;s++,b++)C[b]=1,v[b]=I[s];return 0===b?0:Km(t,e,n,C,v,b,i,r,o,a,h,m,u)}function gm(t,e,n,i,r,o,a,h,m,u){if(zh(e)){const s=new su({start:e.getStartXY(),end:e.getEndXY()});return cm(t,n,s,i,o,r,a,h,m,!0)}if(zh(n)){const s=new su({start:n.getStartXY(),end:n.getEndXY()});return cm(t,e,s,i,r,o,a,h,m,u)}const l=Oe(e,n);a=Math.max(a,l);let c=!1;{const t=e.getSemiAxes(),i=e.getCenter(),u=n.getSemiAxes(),l=n.getCenter(),g=J.distance(l,i),d=t.x+u.x;if(g>d+a)return 0;if(t.y>u.x){if(g+u.x+a<t.y)return 0}else if(u.y>t.x&&g+t.x+a<u.y)return 0;if(m&&!h){const i=1===e.m_minorMajorRatio&&e.isClosed()&&e.isMajor(),a=1===n.m_minorMajorRatio&&n.isClosed()&&n.isMajor();if(i&&a&&(c=!0,g<=d)){if(Math.max(t.x,u.x)<=Math.min(t.x,u.x)+g)return s(!r&&!o),1}}}if(!c&&Qe(e,n,a))return 0;const g=[],d=[],_=!1,p=!1,f=oh(e,0,0,_,p,g,d,null),P=[],y=[],x=oh(n,0,0,_,p,P,y,null);if(1===f&&1===x){const t=new on({points:g,weights:d}),s=new on({points:P,weights:y}),l=[],c=[],_=Gi(!1,t,s,i,null===r?null:l,null===o?null:c,a,h,m,u);if(_>0&&null!==r||null!==o){r&&(r.length=0),o&&(o.length=0);for(let i=0;i<_;++i){if(r)if(ht(l[i],0,1))r.push(l[i]);else{const s=t.tToLength(l[i]),n=e.lengthToT(s);r.push(n)}if(o)if(ht(c[i],0,1))o.push(c[i]);else{const t=s.tToLength(c[i]),e=n.lengthToT(t);o.push(e)}}}return _}let C=[];const v=[];let b=0;const E=m&&!h;for(let s=0;s<f;s++){const t=new on({points:g.slice(2*s,2*s+3),weights:d.slice(2*s,2*s+3)});let i=0;for(let r=0;r<x;r++){v.length<=r&&v.push(new on({points:P.slice(2*r,2*r+3),weights:y.slice(2*r,2*r+3)}));const o=[],h=[],m=E?null:o,u=E?null:h,l=Gi(!1,t,v[r],null,m,u,a,!1,E,!1);if(l>0&&E)return 1;for(let a=0;a<l;++a){if(0===o[a]&&0===s)o[a]=0;else if(1===o[a]&&s===f-1)o[a]=1;else{const s=t.tToLength(o[a])+b,n=e.lengthToT(s);o[a]=n}if(0===h[a]&&0===r)h[a]=0;else if(1===h[a]&&r===x-1)h[a]=1;else{const t=v[r].tToLength(h[a])+i,e=n.lengthToT(t);h[a]=e}C.push(Ut(o[a],h[a]))}i+=v[r].calculateLength2D()}b+=t.calculateLength2D()}if(0===C.length)return 0;if(h&&(C=C.filter((t=>!ht(t.first,0,1)||!ht(t.second,0,1)||!e.getCoord2D(t.first).equals(n.getCoord2D(t.second))))),m)return C.length;const S=[],D=[];for(const s of C)S.push(s.first),D.push(s.second);return Km(t,e,n,S,D,S.length,i,r,o,a,h,m,u)}function dm(t,e,s){if(s.setCoords(t.getCoord2D(e.vmin)),s.mergeNe(t.getCoord2D(e.vmax)),zh(t))return;const n=t.getSemiAxes(),i=[0,0,0,0];{const e=Math.atan2(-n.y*t.m_sinr,n.x*t.m_cosr),s=e+Math.PI,r=Math.atan2(n.y*t.m_cosr,n.x*t.m_sinr),o=r+Math.PI;i[0]=wh(t,e),i[1]=wh(t,s),i[2]=wh(t,r),i[3]=wh(t,o)}const r=new J;for(let o=0;o<4;o++){const n=i[o];e.containsExclusiveCoordinate(n)&&(t.queryCoord2D(n,r),s.mergeNe(r))}}function _m(t,e,n,i,r){if(0===t.m_semiMajorAxis)return n.vmin;let o=J.getNAN();t.queryCoord2D(n.vmin,o);let a=J.getNAN();if(t.queryCoord2D(n.vmax,a),zh(t)){return new su({start:o,end:a}).getClosestCoordinate(e,i)}const h=xh(t,e);if(o=xh(t,o),a=xh(t,a),1===t.m_minorMajorRatio){if(h.isEqual(0,0))return n.vmin;const e=wh(t,Math.atan2(h.y,h.x));if(i||n.containsCoordinate(e))return e;return J.distance(h,o)<=J.distance(h,a)?n.vmin:n.vmax}const m=t.getSemiMajorAxis(),u=t.getSemiMinorAxis(),l=(m-u)*(m+u),c=Tt(l),g=h.x,d=h.y,_=Tt(u*d),p=u*l*d*2,f=[new st(_),new st(p),new st(c-Tt(m*g)-_),new st(-p),new st(-c)],P=_t(st,4),y=Hs(f,4,new U(-1,1),!1,P,4);let x=n.vmin,C=J.sqrDistance(h,o);{const t=J.sqrDistance(h,a);t<C&&(x=n.vmax,C=t)}s(!i);let v=O(8,Number.NaN);for(let s=0;s<y;++s){const e=P[s].value(),n=Math.sqrt(1-e*e),i=Math.atan2(e,n),r=Math.atan2(e,-n);v[2*s]=wh(t,i),v[2*s+1]=wh(t,r)}v=v.slice(0,2*y),kt(v);for(let s=0,b=2*y;s<b;++s)if(v[s]>n.vmin&&v[s]<n.vmax){const n=J.sqrDistance(e,t.getCoord2D(v[s]));C>n&&(C=n,x=v[s])}return x}function pm(t,e,n){s(!zh(t));const i=new ae;i.setRotateAngle(-t.getAxisXRotation());const r=new J;i.queryTransform(e,r);const o=Math.atan2(-r.x*t.getMinorMajorRatio(),r.y),a=o+Nt();let h=wh(t,o),m=wh(t,a);m<h&&(m=tt(h,h=m));let u=0;return h>=0&&h<=1&&(n[u++]=h),m>=0&&m<=1&&(n[u++]=m),u}function fm(t,e,s){return t.m_semiMajorAxis===e.m_semiMajorAxis&&(t.isMajor()!==e.isMajor()&&(!!t.m_center.equals(e.m_center)&&(t.m_sinr===e.m_sinr&&(t.m_cosr===e.m_cosr&&(t.m_minorMajorRatio===e.m_minorMajorRatio&&(s?t.isClockwise()!==e.isClockwise():t.isClockwise()===e.isClockwise()))))))}function Pm(t,e,s){if(zh(t))s.setE(Se.constructPoint2D(t.getEndXY()).subE(Se.constructPoint2D(t.getStartXY())));else{const n=new st;Th(t,e,n);const i=new Se;if(i.setCoordsE(new st(t.m_semiMajorAxis).negate().mulE((new st).setSin(n)),new st(t.getSemiMinorAxis()).mulE((new st).setCos(n))),t.m_rotation){const e=new st(t.m_rotation);i.rotateDirect((new st).setCos(e),(new st).setSin(e))}i.scaleThis(new st(t.getSweepAngle())),s.setE(i)}}function ym(t,e,s,n){const i=t.getStartXY(),r=t.getEndXY(),o=i.equals(r),a=e.equals(s);if(!o&&!a){const n=new ae;n.setShiftCoords(-t.m_XStart,-t.m_YStart);const o=J.distance(e,s),a=J.distance(i,r),h=o/a;n.scale(h,h);const m=r.sub(i);m.divThis(a);const u=s.sub(e);u.divThis(o);const l=m.crossProduct(u),c=u.dotProduct(m);return n.rotate(c,l),n.shiftCoords(e.x,e.y),Wh(t,n,!0),t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=s.x,void(t.m_YEnd=s.y)}const h=new J;if(t.queryCoord2D(.5,h),a){if(o){const n=t.m_center.add(e.sub(i));t.constructEllipticArcEndPointsCenter(e,s,t.getSemiMajorAxis(),1,0,!0,!t.isClockwise(),n),t.setProjectionBehavior(0)}else if(t.isMajor()){const n=h.sub(e).getUnitVector().mul(2*t.getSemiMajorAxis()).add(e);t.constructCircularArcThreePoint(e,s,n)}else t.constructCircularArcThreePoint(e,s,e);return}const m=e.add(s).mul(.5),u=s.sub(e);u.rightPerpendicularThis();const l=m.add(u),c=J.getClosestCoordinate(m,l,t.getCenter(),!0),g=new J;St(m,l,c,g);const d=J.distance(e,g);t.constructEllipticArcEndPointsCenter(e,s,d,1,0,!0,!t.isClockwise(),g),t.setProjectionBehavior(0)}function xm(t,e,n,i){const r=t.getStartXY(),o=t.getEndXY(),a=r.equals(o),h=e.equals(n);if(!a&&!h){const s=new ae;return s.initializeFromTwoPoints(r,o,e,n),Wh(t,s,!0),t.m_XStart=e.x,t.m_YStart=e.y,t.m_XEnd=n.x,t.m_YEnd=n.y,t.endPointModified(),void t.normalizeAfterEndpointChange()}if(!t.isMajor())return void Rh(t,e,n,1);if(a&&h){const s=t.m_center.add(e.sub(r));return void t.constructEllipticArcEndPointsCenter(e,n,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),s)}if(!a){const s=.5*(Lt()-Math.abs(t.getSweepAngle())),i=(t.getSweepAngle()+s*Bt(t.getSweepAngle()))/t.getSweepAngle(),r=new J;t.queryCoord2D(i,r),t.constructEllipticArcEndPointsCenter(r,r,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.getCenter());const o=t.getCenter().add(e.sub(r));return void t.constructEllipticArcEndPointsCenter(e,n,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),o)}const m=J.sqrDistance(e,n);let u=.25,l=.75;if(m<J.sqrDistance(t.getCoord2D(.25),t.getCoord2D(.75))){const e=[0],n=Xs(new Ph(t,m),U.construct(0,.25),1,e);n>0&&(s(1===n),u=e[0],l=1-e[0])}const c=t.getCoord2D(u),g=t.getCoord2D(l);s(!c.equals(g)),t.constructEllipticArcEndPointsCenter(c,g,t.getSemiMajorAxis(),t.getMinorMajorRatio(),t.getAxisXRotation(),!0,!t.isClockwise(),t.m_center),xm(t,e,n)}function Cm(t,s){let n,r=s,o=null;switch(r||(o=_(t)?X():f(),r=o),t){case i.enumPoint:n=new N({vd:r});break;case i.enumLine:n=new su({vd:r});break;case i.enumBezier:n=new mo({vd:r});break;case i.enumEllipticArc:n=new Oa({vd:r});break;case i.enumRationalBezier2:n=new on({vd:r});break;case i.enumBezier2:n=new nn({vd:r});break;case i.enumEnvelope:n=new A({vd:r});break;case i.enumMultiPoint:n=new Ce({vd:r});break;case i.enumPolyline:n=new Na({vd:r});break;case i.enumPolygon:n=new eh({vd:r});break;case i.enumMultipatch:a("multipatch not impl");break;case i.enumGeometryCollection:n=new es({vd:r});break;default:e("Geometry.create")}return n}var vm=I;const bm=-1,Em=1;class Sm{constructor(t){this.m_shape=t}userSort(t,e,s){this.m_shape.sortVerticesSimpleByYHelper(s,t,e)}getValue(t){return this.m_shape.getY(t)}}function Dm(t){return void 0!==t.parent}class wm{constructor(t){Dm(t)?(this.m_parent=t.parent,this.m_geometry=t.geometry,this.m_path=t.path,this.m_vertex=t.vertex,this.m_firstVertex=t.firstVertex,this.m_index=t.selection?0:t.index,this.m_bSkipMultiPoints=t.bSkipMultiPoints,this.m_selection=t.selection,this.m_bOneGeom=t.bOneGeom,this.m_bFirst=!0):(this.m_parent=t.copy.m_parent,this.m_geometry=t.copy.m_geometry,this.m_path=t.copy.m_path,this.m_vertex=t.copy.m_vertex,this.m_index=t.copy.m_index,this.m_bSkipMultiPoints=t.copy.m_bSkipMultiPoints,this.m_firstVertex=t.copy.m_firstVertex,this.m_bFirst=!0,this.m_selection=t.copy.m_selection,this.m_bOneGeom=t.copy.m_bOneGeom)}moveToNextHelper(){for(this.m_path=this.m_parent.getNextPath(this.m_path),this.m_index=0;this.m_geometry!==bm;){for(;this.m_path!==bm;this.m_path=this.m_parent.getNextPath(this.m_path))if(this.m_vertex=this.m_parent.getFirstVertex(this.m_path),this.m_firstVertex=this.m_vertex,this.m_vertex!==bm)return this.m_vertex;if(this.m_bOneGeom)return bm;if(this.m_geometry=this.m_parent.getNextGeometry(this.m_geometry),this.m_geometry===bm)break;this.m_bSkipMultiPoints&&!c(this.m_parent.getGeometryType(this.m_geometry))||(this.m_path=this.m_parent.getFirstPath(this.m_geometry))}return bm}nextSelection(){for(;this.m_index<this.m_parent.m_selectedVertices.length;){const t=this.m_parent.m_selectedVertices[this.m_index++];if(t!==bm&&(this.m_path=this.m_parent.getPathFromVertex(t),!this.m_bOneGeom||this.m_geometry===this.m_parent.getGeometryFromPath(this.m_path)))return this.m_geometry=this.m_parent.getGeometryFromPath(this.m_path),t}return bm}next(){return this.m_selection?this.nextSelection():this.m_bFirst?(this.m_bFirst=!1,this.m_vertex):this.m_vertex!==bm?(this.m_vertex=this.m_parent.getNextVertex(this.m_vertex),this.m_index++,this.m_vertex!==bm&&this.m_vertex!==this.m_firstVertex?this.m_vertex:this.moveToNextHelper()):bm}currentGeometry(){return this.m_geometry}currentPath(){return this.m_path}static create_(t,e,s,n,i,r,o,a,h){return new wm({parent:t,geometry:e,path:s,vertex:n,firstVertex:i,index:r,bSkipMultiPoints:o,selection:a,bOneGeom:h})}}class Am{constructor(t){this.parentage=t}equals(t){return this.parentage===t.parentage}}class Tm{setPrevPath(t,e){this.m_pathIndexList.setField(t,1,e)}setNextPath(t,e){this.m_pathIndexList.setField(t,2,e)}setPathFlags(t,e){this.m_pathIndexList.setField(t,6,e)}getPathFlags(t){return this.m_pathIndexList.getField(t,6)}setPathGeometry(t,e){this.m_pathIndexList.setField(t,7,e)}getPathIndex(t){return this.m_pathIndexList.getField(t,0)}setNextGeometry(t,e){this.m_geometryIndexList.setField(t,1,e)}setPrevGeometry(t,e){this.m_geometryIndexList.setField(t,0,e)}getGeometryIndex(t){return this.m_geometryIndexList.getField(t,7)}setFirstPath(t,e){this.m_geometryIndexList.setField(t,3,e)}setLastPath(t,e){this.m_geometryIndexList.setField(t,4,e)}newGeometry(t){const e=this.m_geometryIndexList.newElement();return this.m_geometryIndexList.setField(e,2,t),this.m_geometryIndexList.setField(e,5,0),this.m_geometryIndexList.setField(e,6,0),this.m_geometryIndexList.setField(e,7,this.m_geometryIndexList.elementToIndex(e)),e}freeGeometry(t){this.m_geometryIndexList.deleteElement(t)}newPath(t){const e=this.m_pathIndexList.newElement(),s=this.m_pathIndexList.elementToIndex(e);if(this.m_pathIndexList.setField(e,0,s),this.m_pathIndexList.setField(e,3,0),this.m_pathIndexList.setField(e,6,0),this.setPathGeometry(e,t),s>=this.m_pathAreas.length){const t=Math.trunc(s<16?16:3*s/2);this.m_pathAreas.length=t,this.m_pathLengths.length=t}return this.m_pathAreas[s]=0,this.m_pathLengths[s]=0,this.m_pathCount++,e}freePath(t){this.m_pathIndexList.deleteElement(t),this.m_pathCount--}newVertex(t){const e=this.m_vertexIndexList.newElement(),s=t>=0?t:this.m_vertexIndexList.elementToIndex(e);if(this.m_vertexIndexList.setField(e,0,s),t<0){if(s>=this.m_vertices.getPointCount()){const t=Math.trunc(s<16?16:3*s/2);this.m_vertices.reserveRounded(t),this.m_vertices.resizeNoInit(t),null!==this.m_segments&&(this.m_segments.length=t),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0)}this.m_segments&&(this.m_segments[s]=null)}return this.m_pointCount++,e}freeVertex(t){this.unselect(t);const e=this.getVertexIndex(t);this.m_vertexIndexList.deleteElement(t),this.m_pointCount--;for(let s=0,n=this.m_indices.length;s<n;s++){if(s===this.m_selectionIndex)continue;const t=this.m_indices[s];null!==t&&t.size()>e&&t.write(e,-1)}this.m_weights&&this.m_weights.size()>e&&this.m_weights.write(e,1),this.m_ranks&&this.m_ranks.size()>e&&this.m_ranks.write(e,Em),this.m_segmentWeights&&this.m_segmentWeights.size()>e&&this.m_segmentWeights.write(e,1),this.m_segmentRanks&&this.m_segmentRanks.size()>e&&this.m_segmentRanks.write(e,Em),this.m_segments&&this.setSegmentToIndex(e,null)}insertVertex_(t,e,s,n){this.m_hasForceSetEnvelope=0;const i=e!==bm?this.getPrevVertex(e):this.getLastVertex(t),r=i!==bm?this.getNextVertex(i):bm,o=this.newVertex(null===s?this.m_pointCount:-1),a=this.getVertexIndex(o);null!==s&&this.m_vertices.setPointByVal(a,s),this.setPathToVertex(o,t),this.setNextVertex(o,r),this.setPrevVertex(o,i),r!==bm&&this.setPrevVertex(r,o),i!==bm&&this.setNextVertex(i,o);const h=this.isClosedPath(t),m=this.getFirstVertex(t);e===bm&&this.setLastVertex(t,o),e===m&&(h&&n&&m!==bm||this.setFirstVertex(t,o)),h&&r===bm&&(this.setNextVertex(o,o),this.setPrevVertex(o,o)),this.setPathSize(t,this.getPathSize(t)+1);const u=this.getGeometryFromPath(t);return this.setGeometryVertexCount(u,this.getPointCount(u)+1),o}getHelperPoint(){return this.m_helperPoint||(this.m_helperPoint=new N({vd:this.m_vertices.getDescription()}),this.m_helperPoint.setXYCoords(0,0)),this.m_helperPoint}addMultiPoint(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return this.appendMultiPoint(s,t,e),s}addPoint_(t,e){const s=this.createGeometry(i.enumMultiPoint,t.getDescription());return this.appendPoint(s,t,e),s}appendMultiPath_(t,e){if(e.isEmpty())return;const s=e.getImpl();this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+s.getPointCount()),this.m_verticesMp.addPoints(e,0,s.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const n=null!==this.m_segments||null!==s.getSegmentFlagsStreamRef();this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+s.getPointCount()),this.m_pathIndexList.setCapacity(this.m_pathIndexList.size()+s.getPathCount());for(let i=0,r=s.getPathCount();i<r;i++){if(0===s.getPathSize(i))continue;const e=this.insertPath(t,bm);this.setClosedPath(e,s.isClosedPath(i));for(let t=s.getPathStart(i),r=s.getPathEnd(i);t<r;t++){const i=this.insertVertex_(e,bm,null,!1);if(n){const e=this.getVertexIndex(i);if(1&s.getSegmentFlags(t))this.setSegmentToIndex(e,null);else{const n=new nu;s.querySegment(t,n,!0),this.setSegmentToIndex(e,n.releaseSegment())}}}s.isStrongPathStart(i)&&this.setStrongPathStart(e,!0),s.isStrongPathEnd(i)&&this.setStrongPathEnd(e,!0)}}addMultiPath(t,e){const s=this.createGeometry(t.getGeometryType(),t.getDescription());return t.getGeometryType()===i.enumPolygon&&this.setFillRule(s,t.getFillRule()),this.appendMultiPath(s,t,e),s}appendMultiPathPolyline(t,e,s){const n=e.getImpl(),i=null!==this.m_segments||null!==n.getSegmentFlagsStreamRef(),r=new oe;e.queryEnvelope(r);{const r=s.clone();let o=n.getPointCount();const a=n.getAccelerators();if(a&&a.getQuadTree()){o=a.getQuadTree().getIntersectionCount(r,0,n.getPointCount()+1)}if(o<e.getPointCount()){if(0===o)return;const s=n.queryLimitedSegmentIterator(r);let a=-1,h=-100,m=-1,u=0,l=-1,c=bm,g=!1,d=s.nextSegment();if(null!==d)for(;;d=s.nextSegment()){let r=null===d;const o=null!==d?s.getPathIndex():a,_=null!==d?s.getStartPointIndex():h;if(r||(a===o&&h+1===_?u++:r=!0),r){if(-1!==l){let t=-1,s=-1;if(u===m){this.setClosedPath(c,g);const i=n.getPathEnd(a);this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i-l),this.m_verticesMp.addPoints(e,l,i),s=n.getPathSize(a),t=i-1}else if(!g||h+1<n.getPathEnd(a))this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h+2-l),this.m_verticesMp.addPoints(e,l,h+2),s=h-l+2,t=h;else{this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h+2-l),this.m_verticesMp?.addPoints(e,l,h+1),t=h,s=h-l+1;const i=n.getPathStart(a);this.m_verticesMp.addPoints(e,i,i+1),s+=1}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);for(let e=0,r=l;e<s;e++,r++){const e=this.insertVertex_(c,bm,null,!1);if(i){const s=this.getVertexIndex(e);if(1&n.getSegmentFlags(r)||r>t)this.setSegmentToIndex(s,null);else{const t=new nu;n.getSegmentBuffer(r,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(null===d)break;u=1,l=_,a!==o?(c=this.insertPath(t,bm),this.setClosedPath(c,!1),m=n.getSegmentCountPath(o),g=n.isClosedPath(o),a=o):c=this.insertPath(t,bm)}h=_}return}}this.appendMultiPath_(t,e)}appendMultiPathPolygon(t,e,n){const i=e.getImpl(),r=null!==this.m_segments||null!==i.getSegmentFlagsStreamRef(),o=oe.constructEmpty();e.queryEnvelope(o),s(n.isIntersecting(o)&&!n.containsEnvelope(o));let a=oe.construct(Number.NEGATIVE_INFINITY,n.ymin,Number.POSITIVE_INFINITY,n.ymax),h=oe.construct(n.xmin,Number.NEGATIVE_INFINITY,n.xmax,Number.POSITIVE_INFINITY);const m=i.getAccelerators();if(m&&m.getQuadTree()){const t=m.getQuadTree(),e=t.getIntersectionCount(a,0,0);e>t.getIntersectionCount(h,0,e+1)&&(h=tt(a,a=h))}else a.height()>h.width()&&(h=tt(a,a=h));const u=[],l=i.queryLimitedSegmentIterator(a);let c=-1,g=-100,d=-1,_=0,p=-1,f=-1,P=bm,y=!0,x=l.nextSegment();if(null!==x)for(;;x=l.nextSegment()){let n=null===x;const o=null!==x?l.getPathIndex():c,a=null!==x?l.getStartPointIndex():g;if(n||(o===c?g+1===a?_++:n=!0:(n=c>=0,c<0&&(c=o,d=i.getSegmentCountPath(c),p=a,P=bm,_=1))),n){if(!(0===u.length&&d===_)){0!==u.length&&u[0].first===p||(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,p,p+1),-1===f&&(f=p),P===bm&&(P=this.insertPath(t,bm),this.setClosedPath(P,!0)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.insertVertex_(P,bm,null,!1));for(const{first:n,second:o}of u){-1===f&&(f=n);let a=-1,h=-1;const m=n+o-1;if(o===d){const t=m+1;h=t-n,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(e,n,t),a=m,s(1===u.length)}else if(m+1<i.getPathEnd(c)){const t=m+2;h=t-n,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+h),this.m_verticesMp.addPoints(e,n,t),a=m}else{const t=i.getPathStart(c),s=t!==f?1:0,r=m+1;h=r-n+s,this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+(r-n)+s),this.m_verticesMp.addPoints(e,n,r),a=m,s>0&&this.m_verticesMp?.addPoints(e,t,t+1)}this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),P===bm&&(P=this.insertPath(t,bm),this.setClosedPath(P,!0));for(let t=0,e=n;t<h;t++,e++){const t=this.insertVertex_(P,bm,null,!1);if(r){const s=this.getVertexIndex(t);if(1&i.getSegmentFlags(e)||e>a)this.setSegmentToIndex(s,null);else{const t=new nu;i.getSegmentBuffer(e,t,!0),this.setSegmentToIndex(s,t.releaseSegment())}}}}if(0===u.length||u.at(-1).first+u.at(-1).second!==p+_){let t=p+_;t===e.getPathEnd(c)&&(t=e.getPathStart(c)),f!==t&&(this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.addPoints(e,t,t+1),this.insertVertex_(P,bm,null,!1))}}u.length=0,y=!0,o!==c&&(c=o,d=i.getSegmentCountPath(c),P=bm,f=-1),p=a,_=1}if(!x)break;{const t=oe.constructEmpty();x.queryLooseEnvelope(t),h.isIntersecting(t)?(y?u.push(Ut(a,1)):u.at(-1).second++,y=!1):y=!0}g=a}}appendMultiPath(t,e,s){if(void 0===s)return void this.appendMultiPath_(t,e);if(e.isEmpty())return;const n=e.getGeometryType()===i.enumPolygon,r=oe.constructEmpty();e.queryEnvelope(r),s.isIntersecting(r)&&(!s.containsEnvelope(r)&&e.getPointCount()>10?n?this.appendMultiPathPolygon(t,e,s):this.appendMultiPathPolyline(t,e,s):this.appendMultiPath_(t,e))}appendPoint(t,e,s){if(e.isEmpty())return;if(void 0!==s&&!s.contains(e.getXY()))return;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+1),this.m_verticesMp.add(e),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+1);const n=this.insertPath(t,bm);this.insertVertex_(n,bm,null,!1)}appendMultiPoint_(t,e){this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+e.getPointCount()),this.m_verticesMp.addPoints(e,0,e.getPointCount()),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+e.getPointCount());const s=this.insertPath(t,bm);for(let n=0,i=e.getPointCount();n<i;n++)this.insertVertex_(s,bm,null,!1)}appendMultiPoint(t,e,s){if(void 0===s)return void this.appendMultiPoint_(t,e);const n=e.getAttributeStreamRef(0);let i=0;for(let m=0,u=e.getPointCount();m<u;m++){const t=n.readPoint2D(2*m);s.contains(t)&&i++}this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+i);let r=-1,o=-1,a=0;for(let m=0,u=e.getPointCount();m<u;m++){const t=n.readPoint2D(2*m);s.contains(t)?(-1===r&&(r=m,o=m),o++):r>=0&&(this.m_verticesMp.addPoints(e,r,o-r),r=-1,a++)}if(r>0&&(this.m_verticesMp.addPoints(e,r,o-r),a++),!a)return;this.m_xyStream=this.m_vertices.getAttributeStreamRef(0),this.m_vertexIndexList.setCapacity(this.m_vertexIndexList.size()+i);const h=this.insertPath(t,bm);for(let m=0,u=e.getPointCount();m<u;m++){const t=n.readPoint2D(2*m);s.contains(t)&&this.insertVertex_(h,bm,null,!1)}}splitSegmentForward(t,s,n,r,o){const a=this.getNextVertex(t);a===bm&&e("Edit_shape.split_segment_forward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let u=t;const l=this.hasSegmentParentage();for(let e=0,c=s.getResultSegmentCount(n);e<c;e++){const t=this.getVertexIndex(u),r=this.getNextVertex(u),g=s.getResultSegment(n,e);let d=null;if(g.getGeometryType()!==i.enumLine&&(d=g.clone(),d.dropAllAttributes()),0===e&&(g.queryStart(h),this.setSegmentToIndex(t,null),this.setPointEx(u,h,s.getResultSegmentStartPointRank(n,e),s.getResultSegmentStartPointWeight(n,e),o)),this.setSegmentRank(u,s.getResultSegmentInteriorRank(n,e)),this.setSegmentWeight(u,s.getResultSegmentInteriorWeight(n,e)),l){const t=s.getResultSegmentSegmentParentage(n,e),i=s.getResultSegmentStartPointIsBreak(n,e);this.setSegmentParentageAndBreak(u,t,i)}if(g.queryEnd(h),e<c-1){this.setSegmentToIndex(t,d);const i=this.insertVertex(m,r,h);this.setWeight(i,s.getResultSegmentEndPointWeight(n,e)),this.setRank(i,s.getResultSegmentEndPointRank(n,e)),this.select(i),u=i}else{this.setPointEx(a,h,s.getResultSegmentEndPointRank(n,e),s.getResultSegmentEndPointWeight(n,e),o);const i=s.getResultSegmentEndPointIsBreak(n,e);this.setSegmentParentageBreakVertex(a,i),this.setSegmentToIndex(t,d)}}}splitSegmentBackward(t,s,n,r,o){const a=this.getNextVertex(t);a===bm&&e("Edit_shape.split_segment_backward_");const h=this.getHelperPoint(),m=this.getPathFromVertex(t);let u=t;const l=this.hasSegmentParentage();for(let e=0,c=s.getResultSegmentCount(n);e<c;e++){const t=c-e-1,r=this.getVertexIndex(u),g=this.getNextVertex(u),d=s.getResultSegment(n,t);let _=null;if(d.getGeometryType()!==i.enumLine&&(_=d.clone(),_.reverse(),_.dropAllAttributes()),0===e&&(d.queryEnd(h),this.setSegmentToIndex(r,null),this.setPointEx(u,h,s.getResultSegmentEndPointRank(n,t),s.getResultSegmentEndPointWeight(n,t),o),this.setSegmentParentageAndBreak(u,s.getResultSegmentSegmentParentage(n,t),s.getResultSegmentEndPointIsBreak(n,t))),d.getGeometryType()===i.enumLine?this.setSegmentToIndex(r,null):this.setSegmentToIndex(r,_),this.setSegmentRank(u,s.getResultSegmentInteriorRank(n,t)),this.setSegmentWeight(u,s.getResultSegmentInteriorWeight(n,t)),d.queryStart(h),e<c-1){const e=this.insertVertex(m,g,h);this.setWeight(e,s.getResultSegmentStartPointWeight(n,t)),this.setRank(e,s.getResultSegmentStartPointRank(n,t)),this.select(e),u=e,l&&this.setSegmentParentageAndBreak(e,s.getResultSegmentSegmentParentage(n,t),s.getResultSegmentEndPointIsBreak(n,t))}else this.setPointEx(a,h,s.getResultSegmentStartPointRank(n,t),s.getResultSegmentStartPointWeight(n,t),o)}}selected_(t){return this.getUserIndex(t,this.m_selectionIndex)>=0}allocateIndex(t=!0){if(this.m_deletedIndices.length){const e=this.m_deletedIndices.pop();return t&&e.setRange(-1,0,e.size()),e}return t?R(0,-1):R(0)}recycleUserIndex(t){this.m_deletedIndices.push(t)}allocatePathIndex(){if(this.m_deletedPathIndices.length){const t=this.m_deletedPathIndices.at(-1);return this.m_deletedPathIndices.pop(),t}return R(0)}recyclePathUserIndex(t){this.m_deletedPathIndices.push(t)}peelALoop_(t,e,s){const n=this.getNextVertex(t),i=this.getNextVertex(e),r=this.getVertexIndex(t),o=this.getVertexIndex(e);if(this.setNextVertex(t,i),this.setPrevVertex(i,t),this.setNextVertex(e,n),this.setPrevVertex(n,e),this.m_segments){const t=this.getSegmentFromIndex(r),e=this.getSegmentFromIndex(o);this.setSegmentToIndex(o,null),this.setSegmentToIndex(r,e),this.setSegmentToIndex(o,t)}if(this.hasSegmentParentage()){let s=this.getSegmentParentage(e),n=this.getSegmentParentage(t);-1===s&&-1===n||(n=tt(s,s=n),this.setSegmentParentageAndBreak(t,n),this.setSegmentParentageAndBreak(e,s))}if(s){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e),r=[!1],o=this.insertClosedPath(s,bm,n,this.getFirstVertex(e),r);r[0]&&this.setFirstVertex(e,i);let a=this.getPathSize(e);return a-=this.getPathSize(o),this.setPathSize(e,a),o}return bm}sortVerticesSimpleByYHelper(t,e,s){t.sort(e,s,((t,e)=>{let s=this.compareVerticesSimpleY(t,e);if(0===s){const n=this.getPathInternalIndexFromVertex(t),i=this.getPathInternalIndexFromVertex(e);s=n<i?-1:n>i?1:0}return s}))}sortVerticesSimpleByYHelper3D(t,e,n){s(0)}constructor(){this.m_verticesMp=null,this.m_vertices=null,this.m_xyStream=null,this.m_vertexDescription=null,this.m_segments=null,this.m_weights=null,this.m_ranks=null,this.m_segmentWeights=null,this.m_segmentRanks=null,this.m_indices=[],this.m_deletedIndices=[],this.m_pathAreas=[],this.m_pathLengths=[],this.m_pathindices=[],this.m_deletedPathIndices=[],this.m_geometryIndices=[],this.m_selectedVertices=[],this.m_helperPoint=null,this.m_forceSetEnvelope=v.constructEmpty(),this.m_hasForceSetEnvelope=0,this.m_workPoint2D=J.getNAN(),this.m_workPoint2_2D=J.getNAN(),this.m_curveStitcher=null,this.m_pathCount=0,this.m_pointCount=0,this.m_firstGeometry=bm,this.m_lastGeometry=bm,this.m_vertexIndexList=new W(5),this.m_pathIndexList=new W(8),this.m_geometryIndexList=new W(8),this.m_bHasAttributes=!1,this.m_selectedCount=0,this.m_selectionIndex=-1,this.m_selection=!1,this.m_bucketSort=new F,this.m_segmentParentageIndex=-1}getTotalPointCount(){return this.m_pointCount}getEnvelope2D(t){if(0!==this.m_hasForceSetEnvelope)return new oe(this.m_forceSetEnvelope.xmin,this.m_forceSetEnvelope.ymin,this.m_forceSetEnvelope.xmax,this.m_forceSetEnvelope.ymax);const e=this.hasCurves(),s=oe.constructEmpty(),n=this.queryVertexIterator();let i=!0;for(let r=n.next();r!==bm;r=n.next()){if(i?s.merge(this.getXY(r)):s.mergeNe(this.getXY(r)),e){const t=this.getSegment(r);if(null!==t){const e=oe.constructEmpty();t.queryLooseEnvelope(e),s.mergeEnvelope2D(e)}}i=!1}return s}getEnvelope3D(t){return s(0),v.constructEmpty()}forceSetEnvelope2D(t){this.m_hasForceSetEnvelope=1,this.m_forceSetEnvelope.setCoords(t.xmin,t.ymin,0,t.xmax,t.ymax,0)}forceSetEnvelope3D(t){s(0)}forgetForceSetEnvelope(){this.m_hasForceSetEnvelope=0}getGeometryCount(){return this.m_geometryIndexList.size()}addGeometry(t,s){const n=t.getGeometryType();if(c(n))return this.addMultiPath(t,s);if(n===i.enumMultiPoint)return this.addMultiPoint(t,s);if(n===i.enumPoint)return this.addPoint_(t,s);if(n===i.enumEnvelope){const e=new eh;return e.addEnvelope(t,!1),this.addMultiPath(e,s)}e("")}appendGeometry(t,s){this.mergeVertexDescription(s.getDescription());const n=s.getGeometryType();c(n)?this.appendMultiPath(t,s):n!==i.enumMultiPoint?e(""):this.appendMultiPoint(t,s)}assignRankToGeometryVertices(t,e){e<Em&&(e=Em);const s=this.queryVertexIterator();for(let n=s.next();n!==bm;n=s.next())this.setRank(n,e),this.setSegmentRank(n,e)}collapseAllGeometriesToFirst(){this.collapseGeometriesToFirst(i.enumUnknown)}collapseGeometriesToFirst(t){this.dbgVerifyVertexCounts();let e=bm,s=-1,n=-1;for(let r=this.getFirstGeometry();r!==bm;)if(t!==i.enumUnknown&&this.getGeometryType(r)!==t)r=this.getNextGeometry(r);else{if(e===bm){e=r,s=this.getPathCount(e),n=this.getPointCount(e),r=this.getNextGeometry(r);continue}for(let s=this.getFirstPath(r);s!==bm;s=this.getNextPath(s))this.setPathGeometry(s,e);s+=this.getPathCount(r),n+=this.getPointCount(r);const t=this.getLastPath(e),i=this.getFirstPath(r);t!==bm?this.setNextPath(t,i):this.setFirstPath(e,i),i!==bm&&(this.setPrevPath(i,t),this.setLastPath(e,this.getLastPath(r))),this.setFirstPath(r,bm),this.setLastPath(r,bm);const o=r;r=this.getNextGeometry(r),this.setGeometryVertexCount(o,0),this.removeGeometry(o)}return e!==bm&&(this.setGeometryVertexCount(e,n),this.setGeometryPathCount(e,s),this.dbgVerifyVertexCounts()),e}setFillRule(t,e){let s=this.m_geometryIndexList.getField(t,2);s&=-134217729,s|=1===e?134217728:0,this.m_geometryIndexList.setField(t,2,s)}getFillRule(t){return 134217728&this.m_geometryIndexList.getField(t,2)?1:0}setGeometryModified(t,e){let s=this.m_geometryIndexList.getField(t,2);!!(67108864&s)!==e&&(s&=-67108865,s|=e?67108864:0,this.m_geometryIndexList.setField(t,2,s))}getGeometryModified(t){return!!(67108864&this.m_geometryIndexList.getField(t,2))}setGeometryModifiedWithVertex(t,e){const s=this.getPathFromVertex(t),n=this.getGeometryFromPath(s);this.setGeometryModified(n,e)}getGeometryModifiedWithVertex(t){const e=this.getPathFromVertex(t),s=this.getGeometryFromPath(e);return this.getGeometryModified(s)}swapGeometry(t,e){const s=this.getFirstPath(t),n=this.getFirstPath(e),i=this.getLastPath(t),r=this.getLastPath(e);for(let c=this.getFirstPath(t);c!==bm;c=this.getNextPath(c))this.setPathGeometry(c,e);for(let c=this.getFirstPath(e);c!==bm;c=this.getNextPath(c))this.setPathGeometry(c,t);this.setFirstPath(t,n),this.setFirstPath(e,s),this.setLastPath(t,r),this.setLastPath(e,i);const o=this.getPointCount(t),a=this.getPathCount(t),h=this.getPointCount(e),m=this.getPathCount(e);this.setGeometryVertexCount(t,h),this.setGeometryVertexCount(e,o),this.setGeometryPathCount(t,m),this.setGeometryPathCount(e,a);const u=this.m_geometryIndexList.getField(t,2),l=this.m_geometryIndexList.getField(e,2);this.m_geometryIndexList.setField(t,2,l),this.m_geometryIndexList.setField(e,2,u)}addPathFromMultiPath(t,e,s){const n=this.createGeometry(s?i.enumPolygon:i.enumPolyline,t.getDescription()),r=t.getImpl();if(t.getPathSize(e)<2)return n;this.m_vertices.reserveRounded(this.m_vertices.getPointCount()+t.getPathSize(e)),this.m_verticesMp.addPoints(t,t.getPathStart(e),r.getPathEnd(e)),this.m_xyStream=this.m_vertices.getAttributeStreamRef(0);const o=this.insertPath(n,bm);this.setClosedPath(o,r.isClosedPath(e)||s);const a=null!==this.m_segments||null!==r.getSegmentFlagsStreamRef();for(let i=r.getPathStart(e),h=r.getPathEnd(e);i<h;i++){const t=this.insertVertex_(o,bm,null,!1);if(a){const e=this.getVertexIndex(t);if(1&r.getSegmentFlags(i))this.setSegmentToIndex(e,null);else{const t=new nu;r.querySegment(i,t,!0),this.setSegmentToIndex(e,t.releaseSegment())}}}return r.isStrongPathStart(e)&&this.setStrongPathStart(o,!0),r.isStrongPathEnd(e)&&this.setStrongPathEnd(o,!0),n}getGeometry(t){const e=this.getGeometryType(t),s=Cm(e,this.m_verticesMp.getDescription()),n=this.getPointCount(t);if(0===n)return s;if(c(e)){const e=s.getImpl(),i=this.getPathCount(t),r=R(i+1),o=z(i+1,0),a=s.getDescription(),h=this.hasCurves();for(let s=0,m=a.getAttributeCount();s<m;s++){const h=a.getSemantics(s),m=vm.getComponentCount(h),u=w(h,n),l=this.m_vertices.getAttributeStreamRef(h);let c=0,g=0,d=0;for(let e=this.getFirstPath(t);e!==bm;e=this.getNextPath(e)){let t=0;this.isClosedPath(e)&&(t|=1),this.isExterior(e)&&(t|=8),this.isStrongPathStart(e)&&(t|=2),this.isStrongPathEnd(e)&&(t|=4),t&&o.setBits(g,t);const s=this.getPathSize(e);if(r.write(g++,d),d+=s,0===h){const t=l,s=u;let n;for(let i=this.getFirstVertex(e);c<d;i=this.getNextVertex(i),c++){const e=this.getVertexIndex(i);n=t.readPoint2D(2*e),s.writePoint2D(2*c,n)}}else for(let n=this.getFirstVertex(e);c<d;n=this.getNextVertex(n),c++){const t=this.getVertexIndex(n);for(let e=0;e<m;e++){const s=l.readAsDbl(t*m+e);u.writeAsDbl(c*m+e,s)}}}e.setAttributeStreamRef(h,u),r.write(i,n)}if(e.setPathFlagsStreamRef(o),e.setPathStreamRef(r),e.notifyModifiedFlags(65535),h){let s=0,n=0;for(let i=this.getFirstPath(t);i!==bm;i=this.getNextPath(i)){s+=this.getPathSize(i);for(let t=this.getFirstVertex(i);n<s;t=this.getNextVertex(t)){const s=this.getSegment(t);null!==s&&s.isCurve()&&e.replaceSegment(n,s,!0),n++}}}}else if(e===i.enumMultiPoint){const e=s.getImpl(),i=s.getDescription();e.reserve(n),e.resizeNoInit(n);for(let s=0,n=i.getAttributeCount();s<n;s++){const n=i.getSemantics(s),r=vm.getComponentCount(n),o=e.getAttributeStreamRef(n),a=this.m_vertices.getAttributeStreamRef(n);let h=0;const m=this.getFirstPath(t),u=this.getPathSize(m);for(let t=this.getFirstVertex(m);h<u;t=this.getNextVertex(t),h++){const e=this.getVertexIndex(t);for(let t=0;t<r;t++){const s=a.readAsDbl(e*r+t);o.writeAsDbl(h*r+t,s)}}e.setAttributeStreamRef(n,o)}e.notifyModifiedFlags(65535)}else h("getGeometry");return s}queryPointGeometryOnly(t,s){this.getGeometryType(t)!==i.enumMultiPoint&&e("get_point_geometry_only");const n=this.getPointCount(t);if(n>1&&e("get_point_geometry_only"),0===n)return s.assignVertexDescription(this.m_vertexDescription),void s.setEmpty();const r=this.getFirstPath(t),o=this.getFirstVertex(r);this.queryPoint(o,s)}removeGeometry(t){for(let n=this.getFirstPath(t);n!==bm;n=this.removePath(n));const e=this.getPrevGeometry(t),s=this.getNextGeometry(t);return e!==bm?this.setNextGeometry(e,s):this.m_firstGeometry=s,s!==bm?this.setPrevGeometry(s,e):this.m_lastGeometry=e,this.freeGeometry(t),s}createGeometry(t,e){void 0===e&&(e=f());const s=this.newGeometry(t);return this.m_vertices||(this.m_verticesMp=new Ce({vd:e}),this.m_vertices=this.m_verticesMp.getImpl()),this.mergeVertexDescription(e),this.m_firstGeometry===bm?(this.m_firstGeometry=s,this.m_lastGeometry=s):(this.setPrevGeometry(s,this.m_lastGeometry),this.setNextGeometry(this.m_lastGeometry,s),this.m_lastGeometry=s),s}getFirstGeometry(){return this.m_firstGeometry}getLastGeometry(){return this.m_lastGeometry}getNextGeometry(t){return this.m_geometryIndexList.getField(t,1)}getPrevGeometry(t){return this.m_geometryIndexList.getField(t,0)}getGeometryType(t){return 16777215&this.m_geometryIndexList.getField(t,2)}setGeometryUserIndex(t,e,s){const n=this.m_geometryIndices[e],i=this.getGeometryIndex(t);i>=n.size()&&n.resize(Math.max(1.25*i,16),-1),n.write(i,s)}getGeometryUserIndex(t,e){const s=this.getGeometryIndex(t),n=this.m_geometryIndices[e];return s<n.size()?n.read(s):-1}createGeometryUserIndex(){for(let e=0;e<this.m_geometryIndices.length;e++)if(null===this.m_geometryIndices[e])return this.m_geometryIndices[e]=R(0),e;this.m_geometryIndices.push(R(0));const t=this.m_geometryIndices.length-1;return s(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}removeGeometryUserIndex(t){for(this.m_geometryIndices[t]=null;this.m_geometryIndices.length>0&&null===this.m_geometryIndices.at(-1);)this.m_geometryIndices.pop()}getFirstPath(t){return this.m_geometryIndexList.getField(t,3)}getLastPath(t){return this.m_geometryIndexList.getField(t,4)}hasPointFeatures(){for(let t=this.getFirstGeometry();t!==bm;t=this.getNextGeometry(t))if(!c(this.getGeometryType(t)))return!0;return!1}getPointCount(t){return this.m_geometryIndexList.getField(t,5)}getPathCount(t){return this.m_geometryIndexList.getField(t,6)}filterClosePoints(t,e,n,r,o){const a=t*t;let h=0;const m=this.hasCurves(),u=this.hasSegmentParentage();for(let l=o===bm?this.getFirstGeometry():o;l!==bm;l=o===bm?this.getNextGeometry(l):bm){const t=this.getGeometryType(l);if(!c(t))continue;if(n&&t!==i.enumPolygon)continue;const o=this.getGeometryType(l)===i.enumPolygon;let g=this.getGeometryModified(l);for(let n=this.getFirstPath(l);n!==bm;){let t=0;for(let e=this.getFirstVertex(n);t<Math.trunc(this.getPathSize(n)/2);){const i=this.getNextVertex(e);if(i===bm)break;const o=this.getXY(e),c=this.getXY(i);let d=J.sqrDistance(o,c),_=!0;do{if(d<=a){if(m){const t=this.getSegment(e);if(null!==t){const e=t.calculateLength2D();if(d=e*e,d>a)break}}if(0===d?0===h&&(h=-1):h=1,i!==this.getLastVertex(n)){const t=u&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(i));if(this.transferAllDataToTheVertex(i,e),this.removeVertex(i,!1),r&&!g&&(this.setGeometryModified(l,!0),g=!0),u&&e!==i){this.setSegmentParentageBreakVertex(e,t);const n=this.getNextVertex(e);s(n!==bm),this.isDiscontinuousSegmentParentage(n)&&this.setSegmentParentageBreakVertex(n,!0)}}_=!1}}while(0);_&&(e=this.getNextVertex(e)),t++}let i=this.getFirstVertex(n);for(let e=this.isClosedPath(n)?i:this.getLastVertex(n);this.getPathSize(n)>0;){const t=this.getPrevVertex(e);if(t===bm)break;{const s=this.getXY(t),o=this.getXY(e);let c=J.sqrDistance(s,o),d=!0;do{if(c<=a){if(m){const e=this.getSegment(t);if(null!==e){const t=e.calculateLength2D();if(c=t*t,c>a)break}}0===c?0===h&&(h=-1):h=1;const s=u&&(this.getSegmentParentageBreakVertex(e)||this.getSegmentParentageBreakVertex(t));this.removeVertex(t,!0),r&&!g&&(this.setGeometryModified(l,!0),g=!0),u&&t!==e&&(s||this.isDiscontinuousSegmentParentage(e))&&this.setSegmentParentageBreakVertex(e,!0),i===t&&(i=this.getFirstVertex(n)),d=!1}}while(0);if(d&&(e=this.getPrevVertex(e),e===i))break}}const c=this.getPathSize(n);let d=e&&c<(o?3:2);d&&o&&2===c&&m&&(d=!this.pathHasCurves(n)),d?(n=this.removePath(n),0===h&&(h=-1),r&&!g&&(this.setGeometryModified(l,!0),g=!0)):n=this.getNextPath(n)}}return h}filterClosePoints3D(t,e,n,i,r,o){return s(0),0}hasDegenerateSegments(t){for(let e=this.getFirstGeometry();e!==bm;e=this.getNextGeometry(e))if(c(this.getGeometryType(e)))for(let s=this.getFirstPath(e);s!==bm;){const e=this.getPathSize(s);if(0===e)return!0;let n=this.getFirstVertex(s);for(let s=0;s<e;s++){const e=this.getNextVertex(n);if(e===bm)break;const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);let r=0;if(null!==i){if(r=i.calculateLowerLength2D(),r<=t){if(r=i.calculateUpperLength2D(),r<=t)return!0;if(r=i.calculateLength2D(),r<=t)return!0}}else{const n=this.getVertexIndex(e);if(r=this.m_vertices.getShortestDistance(s,n),r<=t)return!0}n=e}s=this.getNextPath(s)}return!1}hasDegenerateSegments3D(t,e){return s(0),!1}transferAllDataToTheVertex(t,e){const s=this.getVertexIndex(t),n=this.getVertexIndex(e);if(this.m_weights){const t=this.getWeightWithIndex(s);this.setWeightWithIndex(n,t)}if(this.m_ranks){const t=this.getRankWithIndex(s);this.setRankWithIndex(n,t)}if(this.m_segmentWeights){const t=this.getSegmentWeightWithIndex(s);this.setSegmentWeightWithIndex(n,t)}if(this.m_segmentRanks){const t=this.getSegmentRankWithIndex(s);this.setSegmentRankWithIndex(n,t)}for(let r=0,o=this.m_indices.length;r<o;r++)if(r!==this.m_selectionIndex&&null!==this.m_indices[r]){const s=this.getUserIndex(t,r);-1!==s&&this.setUserIndex(e,r,s)}const i=this.selected(t);i!==this.selected(e)&&(i?this.select(e):this.unselect(e))}splitSegmentAxisAware(t,s,n,i,r){let o=0;const a=this.getNextVertex(t);a===bm&&e("");const h=this.getVertexIndex(t),m=this.getVertexIndex(a),u=this.getSegmentFromIndex(h);let l=this.m_vertices.getShortestDistance(h,m);const c=this.getPathFromVertex(t),g=this.m_bHasAttributes;g&&u&&(l=u.calculateLength2D());const d=this.getSegmentParentage(t),_=this.getHelperPoint();if(u){let t=0,e=0,r=bm;for(let p=0;p<n;p++){const n=s[p];if(t<n&&n<1){const s=u.cut(t,n);if(null!==i&&(p>0&&s.setStartXY(i[p-1]),s.setEndXY(i[p]),s.normalizeAfterEndpointChange(),e=p),g){const t=l>0?u.calculateSubLengthFromStart(n)/l:0;this.m_vertices.interpolateTwoVertices(h,m,t,_)}_.setXY(s.getEndXY()),r=this.insertVertex(c,a,_),o++;const f=this.getPrevVertex(r),P=this.getVertexIndex(f);this.setSegmentToIndex(P,s),-1!==d&&this.setSegmentParentageAndBreak(r,d,!1),t=n}}if(r!==bm){const s=u.cut(t,1);null!==i&&(s.setStartXY(i[e]),s.normalizeAfterEndpointChange());const n=this.getVertexIndex(r);this.setSegmentToIndex(n,s)}}else{let t=0;for(let e=0;e<n;e++){const n=s[e];if(t<n&&n<1){this.m_vertices.interpolateTwoVertices(h,m,n,_);const t=this.insertVertex(c,a,_);o++,-1!==d&&this.setSegmentParentageAndBreak(t,d,!1)}t=n}}return o}splitSegment(t,e,s,n=null){return this.splitSegmentAxisAware(t,e,s,n,-1)}snapControlPoints(t,s,n){this.getNextVertex(t)===bm&&e("");let i=t,r=!1;for(let e=0;e<s;++e){const t=this.getVertexIndex(i),e=this.getSegmentFromIndex(t);if(e){const t=e.snapControlPoints(n);r||=t}i=this.getNextVertex(i)}return r}snapControlPointsOnSelection(t){if(!this.hasCurves())return!1;let e=0;const s=this.queryVertexIteratorOnSelection();for(let n=s.next();n!==bm;n=s.next()){const s=this.getVertexIndex(n),i=this.getSegmentFromIndex(s);i&&(e|=i.snapControlPoints(t)?1:0)}return 0!==e}calculateSubLength2D(t,e,n){return s(0),0}setPoint(t,e,s){if(this.setPointOnly(t,e),null!==this.m_segments){const n=this.getVertexIndex(t),i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXY(e.getXY()),i.normalizeAfterEndpointChange(),s&&i.ensureXYMonotone());const r=this.getPrevVertex(t);if(r!==bm){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!==n&&(n.setEndXY(e.getXY()),n.normalizeAfterEndpointChange(),s&&n.ensureXYMonotone())}}}setPointEx(t,e,s,n,i){this.setPoint(t,e,i);const r=this.getVertexIndex(t);this.setWeightWithIndex(r,n),this.setRankWithIndex(r,s)}setPointOnly(t,e){const s=this.getVertexIndex(t);this.m_vertices.setPointByVal(s,e)}setPointOnlyEx(t,e,n,i){s(0)}queryPoint(t,e){const s=this.getVertexIndex(t);this.m_vertices.getPointByVal(s,e)}setXY(t,e){this.setXYCoords(t,e.x,e.y)}setXYCoords(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices?.setXYCoords(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);null!==i&&(i.setStartXYCoords(e,s),i.normalizeAfterEndpointChange());const r=this.getPrevVertex(t);if(r!==bm){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);null!=n&&(n.setEndXYCoords(e,s),n.normalizeAfterEndpointChange())}}}setXYMonotonic(t,e,s){const n=this.getVertexIndex(t);if(this.m_vertices.setXYCoords(n,e,s),null!==this.m_segments){const i=this.getSegmentFromIndex(n);if(null!==i){const t=i.getEndXY();i.setCoordsForIntersector(new J(e,s),t,!1),i.ensureXYMonotone()}const r=this.getPrevVertex(t);if(r!==bm){const t=this.getVertexIndex(r),n=this.getSegmentFromIndex(t);if(null!==n){const t=n.getStartXY();n.setCoordsForIntersector(t,new J(e,s),!1),n.ensureXYMonotone()}}}}setXYMonotonicPoint2D(t,e){this.setXYMonotonic(t,e.x,e.y)}queryXY(t,e){const s=this.getVertexIndex(t);return this.m_vertices.queryXY(s,e)}getXY(t){const e=this.getVertexIndex(t);return this.m_vertices.getXY(e)}getXYWithIndex(t){return this.m_xyStream.readPoint2D(2*t)}static setSegDefault(t,e,n){s(0)}setXYZ(t,e,n){s(0)}setXYZCoords(t,e,n,i){s(0)}queryXYZ(t,e){s(0)}getXYZ(t){return s(0),Y.getNAN()}getXYZWithIndex(t){return s(0),Y.getNAN()}mergeVertexDescription(t){this.m_verticesMp.mergeVertexDescription(t),this.m_vertexDescription=this.m_verticesMp.getDescription(),this.m_bHasAttributes=this.m_vertexDescription.getAttributeCount()>1}addAttribute(t){s(0)}getAttributeAsDbl(t,e,s){return this.m_vertices.getAttributeAsDbl(t,this.getVertexIndex(e),s)}queryAttributeAsDbl(t,e,n,i){s(0)}setAttribute(t,e,n,i){s(0)}setAttributeInt(t,e,n,i){s(0)}getVertexDescription(){return this.m_vertexDescription}getMinPathVertexY(t){return s(0),0}getVertexIndex(t){return this.m_vertexIndexList.getField(t,0)}getY(t){const e=this.getVertexIndex(t);return this.m_vertices.queryXY(e,this.m_workPoint2D),this.m_workPoint2D.y}getX(t){return this.getXY(t).x}isEqualXY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.isEqualPoint2D(this.m_workPoint2_2D)}isEqualXYPoint2D(t,e){return this.queryXY(t,this.m_workPoint2D),this.m_workPoint2D.isEqualPoint2D(e)}isEqualXYZPoint3D(t,e){return s(0),!1}setWeight(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_weights){if(s)return;this.m_weights=k(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_weights.size()){if(s)return;this.m_weights.resize(n+1,1)}this.m_weights.write(n,e)}setWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_weights){if(s)return;this.m_weights=k(this.m_vertices.getPointCount(),1)}if(t>=this.m_weights.size()){if(s)return;this.m_weights.resize(t+1,1)}this.m_weights.write(t,e)}getWeight(t){if(null===this.m_weights)return 1;const e=this.getVertexIndex(t);return e>=this.m_weights.size()?1:this.m_weights.read(e)}getWeightWithIndex(t){return null===this.m_weights||t>=this.m_weights.size()?1:this.m_weights.read(t)}getRank(t){if(null===this.m_ranks)return Em;const e=this.getVertexIndex(t);return e>=this.m_ranks.size()?Em:this.m_ranks.read(e)}getRankWithIndex(t){return null===this.m_ranks||t>=this.m_ranks.size()?Em:this.m_ranks.read(t)}setRank(t,e){e<Em&&(e=Em);const s=e===Em;if(null===this.m_ranks){if(s)return;this.m_ranks=R(this.m_vertices.getPointCount(),Em)}const n=this.getVertexIndex(t);if(n>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(n+1,Em)}this.m_ranks.write(n,e)}setRankWithIndex(t,e){e<Em&&(e=Em);const s=e===Em;if(null===this.m_ranks){if(s)return;this.m_ranks=R(this.m_vertices.getPointCount(),Em)}if(t>=this.m_ranks.size()){if(s)return;this.m_ranks.resize(t+1,Em)}this.m_ranks.write(t,e)}setSegmentWeight(t,e){e<1&&(e=1);const s=1===e;if(null===this.m_segmentWeights){if(s)return;this.m_segmentWeights=k(this.m_vertices.getPointCount(),1)}const n=this.getVertexIndex(t);if(n>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(n+1,1)}this.m_segmentWeights.write(n,e)}setSegmentWeightWithIndex(t,e){e<1&&(e=1);const s=1===e;if(null==this.m_segmentWeights){if(s)return;this.m_segmentWeights=k(this.m_vertices.getPointCount(),1)}if(t>=this.m_segmentWeights.size()){if(s)return;this.m_segmentWeights.resize(t+1,1)}this.m_segmentWeights.write(t,e)}getSegmentWeight(t){if(null===this.m_segmentWeights)return 1;const e=this.getVertexIndex(t);return e>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(e)}getSegmentWeightWithIndex(t){return null==this.m_segmentWeights||t>=this.m_segmentWeights.size()?1:this.m_segmentWeights.read(t)}getSegmentRank(t){if(null===this.m_segmentRanks)return Tm.st_defaultRank;const e=this.getVertexIndex(t);return e>=this.m_segmentRanks.size()?Tm.st_defaultRank:this.m_segmentRanks.read(e)}getSegmentRankWithIndex(t){return null===this.m_segmentRanks||t>=this.m_segmentRanks.size()?Em:this.m_segmentRanks.read(t)}setSegmentRank(t,e){e<Em&&(e=Em);const s=e===Em;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=R(this.m_vertices.getPointCount(),Em)}const n=this.getVertexIndex(t);if(n>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(n+1,Em)}this.m_segmentRanks.write(n,e)}setSegmentRankWithIndex(t,e){e<Em&&(e=Em);const s=e===Em;if(null===this.m_segmentRanks){if(s)return;this.m_segmentRanks=R(this.m_vertices.getPointCount(),Em)}if(t>=this.m_segmentRanks.size()){if(s)return;this.m_segmentRanks.resize(t+1,Em)}this.m_segmentRanks.write(t,e)}removeWeights(){this.m_weights=null,this.m_segmentWeights=null}removeRanks(){this.m_ranks=null,this.m_segmentRanks=null}setUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);if(n.size()<=i){if(-1===s)return;n.resize(this.m_vertices.getPointCount(),-1)}n.write(i,s)}getUserIndex(t,e){const s=this.getVertexIndex(t),n=this.m_indices[e];if(s<n.size()){return n.read(s)}return-1}addToUserIndex(t,e,s){const n=this.m_indices[e],i=this.getVertexIndex(t);n.size()<=i&&n.resize(this.m_vertices.getPointCount(),-1);const r=n.read(i);n.write(i,r+s)}createUserIndex(){for(let e=0;e<this.m_indices.length;e++)if(null===this.m_indices[e])return this.m_indices[e]=this.allocateIndex(),e;this.m_indices.push(this.allocateIndex());const t=this.m_indices.length-1;return s(t>=0&&t<=Z()),t}createUserIndexUninitialized(){for(let e=0;e<this.m_indices.length;e++)if(null===this.m_indices[e])return this.m_indices[e]=this.allocateIndex(!1),e;this.m_indices.push(this.allocateIndex(!1));const t=this.m_indices.length-1;return s(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillUserIndexForGeometry(t,e,s){const n=this.m_indices[e],i=n.size();for(let r=this.getFirstPath(t);r!==bm;r=this.getNextPath(r)){let t=this.getFirstVertex(r);for(let e=0,o=this.getPathSize(r);e<o;e++,t=this.getNextVertex(t)){const e=this.getVertexIndex(t);e<i&&n.write(e,s)}}}fillUserIndexForSelection(t,e){s(0)}removeUserIndex(t){for(this.recycleUserIndex(this.m_indices[t]),this.m_indices[t]=null;this.m_indices.length>0&&null===this.m_indices[this.m_indices.length-1];)this.m_indices.pop()}replaceCurveWithLine(t){if(null!==this.m_segments){const e=this.getVertexIndex(t);this.setSegmentToIndex(e,null)}}queryLineConnector(t,e,s=!1){const n=this.getNextVertex(t);if(n===bm)return!1;if(!this.m_bHasAttributes||s){const s=this.getXY(t);e.setStartXY(s);const i=this.getXY(n);e.setEndXY(i)}else{const s=new N({vd:this.getVertexDescription()});this.queryPoint(t,s),e.setStart(s),this.queryPoint(n,s),e.setEnd(s)}return!0}queryLineConnector3D(t,e,n=!1){return s(0),!1}hasCurves(){return null!==this.m_segments}geometryHasCurves(t){return s(0),!1}pathHasCurves(t){if(!this.hasCurves())return!1;const e=this.getFirstVertex(t);if(e===bm)return!1;const s=this.getPathSize(t);let n=e;for(let r=0;r<s;r++,n=this.getNextVertex(n)){const t=this.getSegment(n);if(null!==t&&t.getGeometryType()!==i.enumLine)return!0}return!1}insertPath(t,s){let n=bm;s!==bm?(t!==this.getGeometryFromPath(s)&&e(""),n=this.getPrevPath(s)):n=this.getLastPath(t);const i=this.newPath(t);return s!==bm&&this.setPrevPath(s,i),this.setNextPath(i,s),this.setPrevPath(i,n),n!==bm?this.setNextPath(n,i):this.setFirstPath(t,i),s===bm&&this.setLastPath(t,i),this.setGeometryPathCount(t,this.getPathCount(t)+1),i}removePath(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);return e!==bm?this.setNextPath(e,s):this.setFirstPath(n,s),s!==bm?this.setPrevPath(s,e):this.setLastPath(n,e),this.clearPath(t),this.setGeometryPathCount(n,this.getPathCount(n)-1),this.freePath(t),s}clearPath(t){const e=this.getFirstVertex(t);if(e!==bm){let s=e;for(let e=0,i=this.getPathSize(t);e<i;e++){const t=s;s=this.getNextVertex(s),this.freeVertex(t)}const n=this.getGeometryFromPath(t);this.setGeometryVertexCount(n,this.getPointCount(n)-this.getPathSize(t))}this.setPathSize(t,0)}getNextPath(t){return this.m_pathIndexList.getField(t,2)}getPrevPath(t){return this.m_pathIndexList.getField(t,1)}getPathSize(t){return this.m_pathIndexList.getField(t,3)}isClosedPath(t){return!!(1&this.getPathFlags(t))}setClosedPath(t,e){if(this.isClosedPath(t)===e)return;if(this.getPathSize(t)>0){const s=this.getFirstVertex(t),n=this.getLastVertex(t);if(e){this.setNextVertex(n,s),this.setPrevVertex(s,n);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}else{this.setNextVertex(n,bm),this.setPrevVertex(s,bm);const t=this.getVertexIndex(n);this.setSegmentToIndex(t,null)}}const s=(1|this.getPathFlags(t))-1;this.setPathFlags(t,s|(e?1:0))}closeAllPaths(t){s(0)}isStrongPathStart(t){return!!(8&this.getPathFlags(t))}isStrongPathEnd(t){return!!(16&this.getPathFlags(t))}setStrongPathStart(t,e){const s=(8|this.getPathFlags(t))-8;this.setPathFlags(t,s|(e?8:0))}setStrongPathEnd(t,e){const s=(16|this.getPathFlags(t))-16;this.setPathFlags(t,s|(e?16:0))}getGeometryFromPath(t){return this.m_pathIndexList.getField(t,7)}isExterior(t){return!!(2&this.getPathFlags(t))}setExterior(t,e){const s=(2|this.getPathFlags(t))-2;this.setPathFlags(t,s|(e?2:0))}getRingArea(t){if(this.isRingAreaValid(t))return this.m_pathAreas[this.getPathIndex(t)];const e=this.getFirstVertex(t);if(e===bm)return 0;const s=this.getXY(e),n=new ct(0),r=this.getPathSize(t);if(r>2){const t=s.clone(),i=t.x,o=t.y;let a=this.getNextVertex(e);const h=this.getXY(a);a=this.getNextVertex(a);const m=J.getNAN();for(let e=2;e<r;e++,a=this.getNextVertex(a))this.queryXY(a,m),n.pe((m.x-t.x)*(h.y-o)),t.setCoordsPoint2D(h),h.setCoordsPoint2D(m);n.pe((i-t.x)*(h.y-o))}if(this.hasCurves()){let t=e;for(let e=0;e<r;e++,t=this.getNextVertex(t)){const e=this.getSegment(t);if(null===e||e.getGeometryType()===i.enumLine)continue;const s=2*e.calculateArea2DHelper();n.pe(s)}}this.setRingAreaValid(t,!0);const o=.5*n.getResult();return this.m_pathAreas[this.getPathIndex(t)]=o,o}getPathIndexInternal(t){return this.getPathIndex(t)}getPathInternalIndexFromVertex(t){return this.getPathIndex(this.getPathFromVertex(t))}setPathUserIndex(t,e,s){const n=this.m_pathindices[e],i=this.getPathIndex(t);n.size()<this.m_pathAreas.length&&n.resize(this.m_pathAreas.length,-1),n.write(i,s)}getPathUserIndex(t,e){const s=this.getPathIndex(t),n=this.m_pathindices[e];return s<n.size()?n.read(s):-1}createPathUserIndex(){for(let e=0;e<this.m_pathindices.length;e++)if(null===this.m_pathindices[e])return this.m_pathindices[e]=this.allocatePathIndex(),e;this.m_pathindices.push(this.allocatePathIndex());const t=this.m_pathindices.length-1;return s(t>=0&&t<=Number.MAX_SAFE_INTEGER),t}fillPathUserIndexForGeometry(t,e,s){const n=this.m_pathindices[e],i=n.size();for(let r=this.getFirstPath(t);r!==bm;r=this.getNextPath(r)){const t=this.getPathIndex(r);t<i&&n.write(t,s)}}removePathUserIndex(t){for(this.recyclePathUserIndex(this.m_pathindices[t]),this.m_pathindices[t]=null;this.m_pathindices.length>0&&null===this.m_pathindices.at(-1);)this.m_pathindices.pop()}movePath(t,s,n){if(n===bm&&e(""),s===n)return;const i=this.getNextPath(n);let r=this.getPrevPath(n);const o=this.getGeometryFromPath(n);r===bm?this.setFirstPath(o,i):this.setNextPath(r,i),i===bm?this.setLastPath(o,r):this.setPrevPath(i,r),this.setGeometryVertexCount(o,this.getPointCount(o)-this.getPathSize(n)),this.setGeometryPathCount(o,this.getPathCount(o)-1),r=s===bm?this.getLastPath(t):this.getPrevPath(s),this.setPrevPath(n,r),this.setNextPath(n,s),s===bm?this.setLastPath(t,n):this.setPrevPath(s,n),r===bm?this.setFirstPath(t,n):this.setNextPath(r,n),this.setGeometryVertexCount(t,this.getPointCount(t)+this.getPathSize(n)),this.setGeometryPathCount(t,this.getPathCount(t)+1),this.setPathGeometry(n,t)}addVertex(t,e){this.m_vertices.getPointByVal(this.getVertexIndex(e),this.getHelperPoint());return this.insertVertex_(t,bm,this.getHelperPoint(),!1)}insertVertex(t,e,s){return this.insertVertex_(t,e,s,!0)}removeVertex(t,e){const s=this.getPathFromVertex(t),n=this.getPrevVertex(t),i=this.getNextVertex(t);n!==bm&&this.setNextVertex(n,i);const r=this.getPathSize(s);t===this.getFirstVertex(s)&&this.setFirstVertex(s,r>1?i:bm),i!==bm&&this.setPrevVertex(i,n),t===this.getLastVertex(s)&&this.setLastVertex(s,r>1?n:bm);if(this.hasCurves()&&n!==bm&&i!==bm){const s=this.getVertexIndex(t),r=this.getVertexIndex(n),o=this.getVertexIndex(i);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(s,null)}else{const t=this.getSegmentFromIndex(s);if(this.setSegmentToIndex(s,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}this.setPathSize(s,r-1);const o=this.getGeometryFromPath(s);return this.setGeometryVertexCount(o,this.getPointCount(o)-1),this.freeVertex(t),i}removeVertices(t,e){s(t!==e);const n=this.getPathFromVertex(t),i=this.getPrevVertex(t),r=this.getPrevVertex(e);i!==bm&&this.setNextVertex(i,e);let o=this.getPathSize(n);const a=this.getVertexIndex(t);this.setSegmentToIndex(a,null),this.setPrevVertex(e,i),this.setPrevVertex(t,bm),this.setNextVertex(r,bm);let h=0,m=t;const u=this.getFirstVertex(n);let l=!1;for(;;){const t=this.getNextVertex(m);if(l||=u===m,this.freeVertex(m),h++,m===r)break;m=t}o-=h,l&&this.setFirstVertex(n,o>0?e:bm),this.setPathSize(n,o);const c=this.getGeometryFromPath(n);this.setGeometryVertexCount(c,this.getPointCount(c)-h)}getFirstVertex(t){return this.m_pathIndexList.getField(t,4)}getLastVertex(t){return this.m_pathIndexList.getField(t,5)}getNextVertex(t){return this.m_vertexIndexList.getField(t,2)}getPrevVertex(t){return this.m_vertexIndexList.getField(t,1)}getNextVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,2):this.m_vertexIndexList.getField(t,1)}getPrevVertexEx(t,e){return e>0?this.m_vertexIndexList.getField(t,1):this.m_vertexIndexList.getField(t,2)}getPathFromVertex(t){return this.m_vertexIndexList.getField(t,3)}addPoint(t,e){return this.insertVertex_(t,bm,e,!1)}getGeometryFromVertex(t){return this.getGeometryFromPath(this.getPathFromVertex(t))}replaceNaNs(t,e){this.m_vertexDescription.hasAttribute(t)||h(""),this.m_vertices.replaceNaNs(t,e)}removeNaNVertices(){for(let t=this.getFirstGeometry();t!==bm;t=this.getNextGeometry(t))for(let e=this.getFirstPath(t);e!==bm;e=this.getNextPath(e)){let t=this.getFirstVertex(e);for(let s=0,n=this.getPathSize(e);s<n;s++)t=this.getXY(t).isFinite()?this.getNextVertex(t):this.removeVertex(t,!0)}}queryVertexIterator(t=bm){return this.queryVertexIteratorEx(!1,t)}queryVertexIteratorEx(t,e=bm){let s=bm,n=bm,i=bm,r=bm,o=0,a=!1;for(s=e!==bm?e:this.getFirstGeometry();s!==bm;s=this.getNextGeometry(s))if(!t||c(this.getGeometryType(s))){for(n=this.getFirstPath(s);n!==bm;n=this.getNextPath(n))if(i=this.getFirstVertex(n),r=i,o=0,i!==bm){a=!0;break}if(a||e!==bm)break}return a||(s=bm),wm.create_(this,s,n,i,r,o,t,!1,e!==bm)}queryVertexIteratorOnSelection(t=bm){return this.m_selection?wm.create_(this,t,bm,bm,bm,-1,!1,!0,t!==bm):this.queryVertexIteratorEx(!1,t)}hasSelection(){return this.m_selection}createEmptySelection(){s(0)}removeSelection(){this.m_selection&&(this.m_selectedVertices.length=0,this.removeUserIndex(this.m_selectionIndex),this.m_selectionIndex=-1,this.m_selection=!1,this.m_selectedCount=0)}select(t){return!!this.selected(t)||(this.setUserIndex(t,this.m_selectionIndex,this.m_selectedVertices.length),this.m_selectedVertices.push(t),this.m_selectedCount++,!1)}unselect(t){if(!this.m_selection)return;const e=this.getUserIndex(t,this.m_selectionIndex);e>=0&&(this.m_selectedVertices[e]=bm,this.setUserIndex(t,this.m_selectionIndex,-1),this.m_selectedCount--)}selected(t){return!this.m_selection||this.selected_(t)}getSelectedCount(){return this.m_selection?this.m_selectedCount:this.getTotalPointCount()}createSelectionForCrackingAndClustering(t,e){return s(0),!1}peelALoop(t,e){this.peelALoop_(t,e,!1)}peelALoopIntoAPath(t,e){return this.peelALoop_(t,e,!0)}applyTransformation(t){if(this.m_verticesMp.applyTransformation(t),null!==this.m_segments)for(let e=0,s=this.m_segments.length;e<s;e++)this.m_segments[e]&&this.m_segments[e].applyTransformation(t)}setGeometryType(t,e){this.m_geometryIndexList.setField(t,2,e)}splitSegmentWithIntersector(t,e,s,n,i){n?this.splitSegmentForward(t,e,s,!0,i):this.splitSegmentBackward(t,e,s,!0,i)}setPrevVertex(t,e){this.m_vertexIndexList.setField(t,1,e)}setNextVertex(t,e){this.m_vertexIndexList.setField(t,2,e)}setPathToVertex(t,e){this.m_vertexIndexList.setField(t,3,e)}setPathSize(t,e){this.m_pathIndexList.setField(t,3,e)}setFirstVertex(t,e){this.m_pathIndexList.setField(t,4,e)}setLastVertex(t,e){this.m_pathIndexList.setField(t,5,e)}getSegment(t){if(null!=this.m_segments){const e=this.getVertexIndex(t);return this.getSegmentFromIndex(e)}return null}isCurve(t){return s(0),!1}querySegment(t,e,s=!0,n=!1){const i=this.getNextVertex(t);if(i===bm)return!1;const r=this.getSegment(t);if(!r)return!s&&(this.queryLineConnector(t,e.createLine(),n),!0);if(e.copyFrom(r,!0),n)return!0;if(this.m_vertexDescription.getAttributeCount()>1){const s=this.getHelperPoint();this.queryPoint(t,s),e.get().setStart(s),this.queryPoint(i,s),e.get().setEnd(s)}return!0}getSegmentFromIndex(t){const e=null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null;return e||null}getAndClearSegmentFromIndex(t){const e=null!==this.m_segments&&this.m_segments.length>t?this.m_segments[t]:null;return e||null}setSegmentToIndex(t,e){if(this.m_hasForceSetEnvelope=0,null===this.m_segments){if(!e)return;this.m_segments=[],this.m_segments.length=this.m_vertices.getPointCount()}t>=this.m_segments.length&&(this.m_segments.length=t+1),this.m_segments[t]=e}setGeometryPathCount(t,e){this.m_geometryIndexList.setField(t,6,e)}setGeometryVertexCount(t,e){this.m_geometryIndexList.setField(t,5,e)}ringParentageCheckInternal(t,e){return s(0),!1}reverseRingInternal(t){const e=this.hasCurves(),s=this.hasSegmentParentage();let n=null,i=-1,r=t;if(e){const t=this.getVertexIndex(r);n=this.getAndClearSegmentFromIndex(t)}s&&(i=this.getSegmentParentage(r));do{const t=this.getPrevVertex(r),o=this.getNextVertex(r);if(this.setNextVertex(r,t),this.setPrevVertex(r,o),e){const t=this.getVertexIndex(o),e=this.getSegmentFromIndex(t);n&&n.reverse(),this.setSegmentToIndex(t,n),n=e}if(s){const t=this.getSegmentParentage(o);this.setSegmentParentagePreserveBreak(o,i),i=t}r=o}while(r!==t);this.dbgVerifyIntegrity(t)}setTotalPointCount(t){this.m_pointCount=t}removePathOnly(t){const e=this.getPrevPath(t),s=this.getNextPath(t),n=this.getGeometryFromPath(t);e!==bm?this.setNextPath(e,s):this.setFirstPath(n,s),s!==bm?this.setPrevPath(s,e):this.setLastPath(n,e),this.setFirstVertex(t,bm),this.setLastVertex(t,bm),this.freePath(t)}insertClosedPath(t,e,s,n,i){const r=this.insertPath(t,bm);let o=0,a=s;for(i[0]=!1;;){a===n&&(i[0]=!0),this.setPathToVertex(a,r),o++;const t=this.getNextVertex(a);if(t===s)break;a=t}return this.setClosedPath(r,!0),this.setPathSize(r,o),i[0]&&(s=n),this.setFirstVertex(r,s),this.setLastVertex(r,this.getPrevVertex(s)),this.setRingAreaValid(r,!1),r}findVertex2D(t,e){return s(0),0}findVertex3D(t,e,n){return s(0),0}dbgVerifyMonotone(){}dbgCheckSelection(){}dbgVerifySegment(t){}dbgVerifyIntegrity(t,e=!0){}dbgVerifyVertexCounts(){}dbgVerifyCurves(){}dbgDumpGeometry(t,e){}removeVertexInternal(t,e){const s=this.getPrevVertex(t),n=this.getNextVertex(t);s!==bm&&this.setNextVertex(s,n),n!==bm&&this.setPrevVertex(n,s);if(this.hasCurves()&&s!==bm&&n!==bm){const i=this.getVertexIndex(t),r=this.getVertexIndex(s),o=this.getVertexIndex(n);if(e){const t=this.getSegmentFromIndex(r);if(null!==t){const e=this.m_vertices.getXY(o);t.setEndXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(i,null)}else{const t=this.getSegmentFromIndex(i);if(this.setSegmentToIndex(i,null),null!==t){const e=this.m_vertices.getXY(r);t.setStartXY(e),t.normalizeAfterEndpointChange()}this.setSegmentToIndex(r,t)}}return this.freeVertex(t),n}isRingAreaValid(t){return!!(4&this.getPathFlags(t))}setRingAreaValid(t,e){const s=(4|this.getPathFlags(t))-4;this.setPathFlags(t,s|(e?4:0))}compareVerticesSimpleY(t,e){return this.queryXY(t,this.m_workPoint2D),this.queryXY(e,this.m_workPoint2_2D),this.m_workPoint2D.compare(this.m_workPoint2_2D)}compareVerticesSimpleY3D(t,e){return this.getXYZ(t).compare(this.getXYZ(e))}compareVerticesSimpleX(t,e){return this.getXY(t).compareX(this.getXY(e))}sortVerticesSimpleByYHeapMerge(t,e){s(0)}sortVerticesSimpleByY(t,e,s){this.m_bucketSort.sort(t,e,s,new Sm(this))}sortVerticesSimpleByX(t,e,n){s(0)}sortVerticesSimpleByY3D(t,e,n){s(0)}snapVertexForPoleClipping(t,e){const s=this.getPrevVertex(t);s!==bm&&this.replaceCurveWithLine(s);this.getNextVertex(t)!==bm&&this.replaceCurveWithLine(t);const n=new J;this.queryXY(t,n),n.y=e,this.setXY(t,n)}setSegmentParentageAndBreak(t,e,n=!0){if(-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}e>=0&&(s(e<=gt()>>1),e<<=1,e|=n?1:0),this.setUserIndex(t,this.m_segmentParentageIndex,e)}setSegmentParentagePreserveBreak(t,e){if(s(e>=-1),-1===this.m_segmentParentageIndex){if(-1===e)return;this.m_segmentParentageIndex=this.createUserIndex()}if(e>=0){s(e<=gt()>>1),e<<=1;e|=this.getSegmentParentageBreakVertex(t)?1:0}this.setUserIndex(t,this.m_segmentParentageIndex,e)}getSegmentParentage(t){if(-1===this.m_segmentParentageIndex)return-1;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0?e:e>>1}getOriginalSegmentInfo(t){if(-1!==this.m_segmentParentageIndex){const e=this.getSegmentParentage(t);return new Am(e)}return new Am(-1)}setSegmentParentageBreakVertex(t,e){if(-1===this.m_segmentParentageIndex)return;let s=this.getUserIndex(t,this.m_segmentParentageIndex);s<0||!!(1&s)!==e&&(e?s|=1:s&=gt()>>1<<1,this.setUserIndex(t,this.m_segmentParentageIndex,s))}getSegmentParentageBreakVertex(t){if(-1===this.m_segmentParentageIndex)return!0;const e=this.getUserIndex(t,this.m_segmentParentageIndex);return e<0||!!(1&e)}isDiscontinuousSegmentParentage(t){const e=this.getPrevVertex(t);if(e===bm)return!1;return this.getSegmentParentage(e)!==this.getSegmentParentage(t)}setCurveStitcherPointer(t){this.m_curveStitcher=t}hasSegmentParentage(){return-1!==this.m_segmentParentageIndex}deleteSegmentParentage(){-1!==this.m_segmentParentageIndex&&(this.removeUserIndex(this.m_segmentParentageIndex),this.m_segmentParentageIndex=-1),this.m_curveStitcher=null}clearSegments(){this.m_segments=null}}function Im(t){if(t.isEmpty())return new eh({vd:t.getDescription()});const e=t.getImpl(),s=e.getPointCount();if(s<=2){if(1===s||e.getXY(0).equals(e.getXY(1))){const t=new N({vd:e.getDescription()});return e.getPointByVal(0,t),t}{const t=new N,s=new Na({vd:e.getDescription()});return e.getPointByVal(0,t),s.startPathPoint(t),e.getPointByVal(1,t),s.lineToPoint(t),s}}const n=e.getAttributeStreamRef(0),i=new qm({stream:n,n:s});let r=0,o=1;const a=n.readPoint2D(r<<1),h=new J;for(;o<s&&n.queryPoint2D(o<<1,h).equals(a);)o++;if(i.m_treeHull.addElement(r),o<s){i.m_treeHull.addBiggestElement(o);const t=new J;for(let s=o+1;s<e.getPointCount();s++){n.queryPoint2D(s<<1,t);const e=i.treeHull(t);-1!==e&&i.m_treeHull.setElement(e,s)}}const m=e.getDescription(),u=m.getAttributeCount()>1,l=i.m_treeHull.size();let c=null;if(l>=2){c=l>=3?new eh({vd:m}):new Na({vd:m});const t=c.getImpl();t.reserve(i.m_treeHull.size()),t.addPathPoint2D(null,0,!0);const s=new J;for(let r=i.m_treeHull.getFirst();-1!==r;r=i.m_treeHull.getNext(r))if(u){const s=new N;e.getPointByVal(i.m_treeHull.getElement(r),s),t.insertPoint(0,-1,s)}else n.queryPoint2D(i.m_treeHull.getElement(r)<<1,s),t.insertPoint2D(0,-1,s)}else if(u){const t=new N({vd:m});e.getPointByVal(i.m_treeHull.getElement(i.m_treeHull.getFirst()),t),c=t}else{const t=n.readPoint2D(i.m_treeHull.getElement(i.m_treeHull.getFirst())<<1);c=new N(t)}return c}function Mm(t,e,n){if(e<=262144)return Lm(t,e,n);s(0);const i=new qm({points:t,n:e}),r=0;let o=1;const a=t[r].clone();for(;o<e&&t[o].equals(a);)o++;if(i.m_treeHull.addElement(r),o<e){i.m_treeHull.addBiggestElement(o);for(let s=o+1;s<e;s++){const e=t[s],n=i.treeHull(e);-1!==n&&i.m_treeHull.setElement(n,s)}}let h=0;for(let s=i.m_treeHull.getFirst();-1!==s;s=i.m_treeHull.getNext(s))n[h++]=i.m_treeHull.getElement(s);return h}function Ym(t,e,s){const n=t.getImpl(),i=n.getPathStart(e),r=n.getPathEnd(e),o=!n.isClosedPath(e)&&n.isClosedPathInXYPlane(e),a=n.getAttributeStreamRef(0),h=2*i;let m=2*r;if(o&&(m-=2),m-h<6)return!0;const u=a.readPoint2D(h),l=a.readPoint2D(h+2),c=a.readPoint2D(h+4);if(!Rm(J.orientationRobust(l,c,u)))return!1;const g=l.clone(),d=new J;for(let _=h+6;_<m;_+=2){d.assign(l),l.assign(c),a.queryPoint2D(_,c);if(!Rm(J.orientationRobust(l,c,u)))return!1;if(!Rm(J.orientationRobust(g,c,u)))return!1;if(!Rm(J.orientationRobust(l,c,d)))return!1}return!0}function Xm(t,e,s,n,r){if(s.setNAN(),n.setCoords(1,0),r.setCoords(0,0),t.isEmpty())return;if(t.getGeometryType()===i.enumPoint)return void s.assign(t.getXY());const o=t,a=o.getPointCount();if(2===a){const t=o.getXY(0),e=o.getXY(1);s.assign(t.add(e).mul(.5));const i=e.sub(t);n=Bm(i),r.setCoords(.5*i.length(),0)}else{let t=Number.MAX_VALUE;const i=[0,1,0,0],h=new $t(4,2);for(h.set(0,0,0),h.set(0,1,1),h.set(1,0,1),h.set(1,1,2);i[0]<a;++i[0],Gm(h,0,a)){i[1]===i[0]&&(++i[1],Gm(h,1,a));for(let t=1;;++t){for(;;){const e=Wm(o.getXY(h.get(0,0)),o.getXY(h.get(0,1)),o.getXY(h.get(t,0)),o.getXY(h.get(t,1)),2^t);if(e>0)break;if(++i[t],Gm(h,t,a),0===e)break}if(3===t)break;i[t+1]<i[t]&&(i[t+1]=i[t],h.set(t+1,0,h.get(t,0)),h.set(t+1,1,h.get(t,1)))}const m=o.getXY(h.get(0,0)).add(o.getXY(h.get(2,0))).mul(.5),u=Bm(o.getXY(h.get(0,1)).sub(o.getXY(h.get(0,0)))),l=new J;let c,g;if(l.x=Math.max(0,u.dotProduct(o.getXY(h.get(1,0)).sub(o.getXY(h.get(3,0))))),l.y=Math.max(0,u.crossProduct(o.getXY(h.get(0,0)).sub(o.getXY(h.get(2,0))))),e?(c=l.x*l.y,g=c<t):(c=l.y,g=c<t),g){t=c;const e=o.getXY(h.get(1,0)),i=o.getXY(h.get(3,0)),a=e.add(i).mul(.5).sub(m);s.assign(m.add(u.mul(u.dotProduct(a)))),n.assign(u),r.assign(l)}}r.mulThis(.5),r.x<r.y&&(r.y=tt(r.x,r.x=r.y),n.leftPerpendicularThis())}n.y<0?n.negateThis():0===n.y&&(n.x=1)}Tm.st_defaultRank=1;class Nm{constructor(t){this.m_handleP=-1,this.m_handleQ=-1,this.m_currentSupport=-1,this.m_area=0,this.m_bDone=!0,s(0),this.m_convexHull=t,this.m_function=this.done_}next(){return s(0),!1}get_vertex_handle_p(){return s(0),0}get_vertex_handle_q(){return s(0),0}get_current_support(){return s(0),0}getNext(t){return s(0),0}getPrev(t){return s(0),0}intialize_(){return s(0),!1}increment_(){return s(0),!1}increment_q_(){return s(0),!1}increment_p_(){return s(0),!1}parallel_edge_with_q_support_(){return s(0),!1}parallel_edge_with_p_support_(){return s(0),!1}done_(){return s(0),!1}}class qm{nullGetXY(t){return h("m_getXY is null"),{}}nullDeleteNode(t){h("m_deleteNode is null")}constructor(t){return this.m_treeHull=new j,this.m_shape=null,this.m_stream=null,this.m_points=null,this.m_geometryHandle=-1,this.m_pathHandle=-1,this.m_getXY=this.nullGetXY,this.m_deleteNode=this.nullDeleteNode,t?t.stream?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_stream=t.stream,this.m_getXY=this.getXYStream,this.m_deleteNode=this.deleteNodeStream,this.m_points=null,this.m_geometryHandle=bm,void(this.m_pathHandle=bm)):t.points?(this.m_treeHull.setCapacity(Math.min(20,t.n)),this.m_points=t.points,this.m_getXY=this.getXYPoints,this.m_deleteNode=this.deleteNodePoints,this.m_stream=null,this.m_geometryHandle=bm,void(this.m_pathHandle=bm)):void d("unrecognized constructor parameter"):(this.m_treeHull.setCapacity(20),this.m_shape=new Tm,this.m_geometryHandle=this.m_shape.createGeometry(i.enumMultiPoint),this.m_pathHandle=this.m_shape.insertPath(this.m_geometryHandle,bm),this.m_getXY=this.getXYShape,this.m_deleteNode=this.deleteNodeShape,this.m_stream=null,void(this.m_points=null))}getXYShape(t){return this.m_shape.getXY(t)}getXYStream(t){return this.m_stream.readPoint2D(t<<1)}getXYPoints(t){return s(0),new J}deleteNodeShape(t){const e=this.m_treeHull.getElement(t);this.m_treeHull.deleteNode(t),this.m_shape.removeVertex(e,!1)}deleteNodeStream(t){this.m_treeHull.deleteNode(t)}deleteNodePoints(t){s(0)}addGeometry(s){if(s.isEmpty())return;const n=s.getGeometryType();if(n===i.enumGeometryCollection){const t=s;for(let e=0,s=t.getGeometryCount();e<s;e++)this.addGeometry(t.getGeometry(e))}else t(n)?this.addMultiVertexGeometry(s):m(n)?this.addSegment(s):n===i.enumEnvelope?this.addEnvelope(s):n===i.enumPoint?this.addPoint(s):e("Convex_hull: geometry not supported")}getBoundingGeometry(){const t=new N,e=this.m_treeHull.getFirst(),s=new eh({vd:this.m_shape.getVertexDescription()});if(0===this.m_treeHull.size())return s;s.reserve(this.m_treeHull.size()),this.m_shape.queryPoint(this.m_treeHull.getElement(e),t),s.startPathPoint(t);for(let n=this.m_treeHull.getNext(e);-1!==n;n=this.m_treeHull.getNext(n))this.m_shape.queryPoint(this.m_treeHull.getElement(n),t),s.lineToPoint(t);return s}getAntipodalPairsIterator(){return s(0),new Nm(this)}getXY(t){return s(0),new J}getXYWithIndex(t){return s(0),new J}getFirst(){return s(0),0}getLast(){return s(0),0}getNext(t){return s(0),0}getPrev(t){return s(0),0}getVertexIndex(t){return s(0),0}getPointCount(){return s(0),0}addMultiVertexGeometry(t){const e=new N,s=t.getImpl(),n=new J;for(let i=0;i<t.getPointCount();i++){s.queryXY(i,n);const r=this.addPoint2D(n);if(-1!==r){t.getPointByVal(i,e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}}addEnvelope(t){const e=new N;for(let s=0;s<4;s++){const n=new J;t.queryCorner(s,n);const i=this.addPoint2D(n);if(-1!==i){t.queryCornerByVal(s,e);const n=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(i,n)}}}addSegment(t){const e=new N,s=t.getStartXY(),n=this.addPoint2D(s);if(-1!==n){t.queryStart(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(n,s)}const i=t.getEndXY(),r=this.addPoint2D(i);if(-1!==r){t.queryEnd(e);const s=this.m_shape.addPoint(this.m_pathHandle,e);this.m_treeHull.setElement(r,s)}}addPoint(t){const e=t.getXY(),s=this.addPoint2D(e);if(-1!==s){const e=this.m_shape.addPoint(this.m_pathHandle,t);this.m_treeHull.setElement(s,e)}}addPoint2D(t){let e=-1;if(0===this.m_treeHull.size())return e=this.m_treeHull.addElement(-4),e;if(1===this.m_treeHull.size()){const s=this.m_treeHull.getElement(this.m_treeHull.getFirst()),n=this.m_shape.getXY(s);return t.equals(n)||(e=this.m_treeHull.addBiggestElement(-5)),e}return e=this.treeHull(t),e}treeHull(t){let e=-1;do{const s=this.m_treeHull.getFirst(),n=this.m_treeHull.getLast(),i=this.m_treeHull.getElement(s),r=this.m_treeHull.getElement(n),o=this.m_getXY(i),a=this.m_getXY(r),h=J.orientationRobust(a,t,o);if(Rm(h)){e=this.m_treeHull.addBiggestElement(-1);const i=this.treeHullWalkBackward(t,n,s);i!==s&&this.treeHullWalkForward(t,s,this.m_treeHull.getPrev(i));break}if(zm(h)){let i=this.m_treeHull.getRoot(),r=this.m_treeHull.getFirst(),a=this.m_treeHull.getLast(),h=-1,m=-1,u=-1;for(;r!==this.m_treeHull.getPrev(a);){m=this.m_treeHull.getElement(i);const e=this.m_getXY(m);zm(J.orientationRobust(e,t,o))?(a=i,i=this.m_treeHull.getLeft(i)):(r=i,i=this.m_treeHull.getRight(i))}i=a,h=r,m=this.m_treeHull.getElement(i),u=this.m_treeHull.getElement(h);const l=this.m_getXY(m),c=this.m_getXY(u);if(h!==s){if(!Rm(J.orientationRobust(c,t,l)))break}e=this.m_treeHull.addElementAtPosition(h,i,-2,!0,!1),this.treeHullWalkForward(t,i,n),this.treeHullWalkBackward(t,h,s);break}{const i=km(t,a,o);if(-1===i){const i=this.m_treeHull.getPrev(n);this.m_treeHull.deleteNode(n),e=this.m_treeHull.addBiggestElement(-3),this.treeHullWalkBackward(t,i,s)}else if(1===i){const i=this.m_treeHull.getNext(s);this.m_treeHull.deleteNode(s),e=this.m_treeHull.addElementAtPosition(-1,i,-3,!0,!1),this.treeHullWalkForward(t,i,n)}break}}while(0);return e}treeHullWalkForward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getNext(n);const o=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(Rm(J.orientationRobust(s,t,o)))break;const a=n;n=r,i=e,o.assign(s),r=this.m_treeHull.getNext(n),this.m_deleteNode(a)}return n}treeHullWalkBackward(t,e,s){if(e===s)return s;let n=e,i=this.m_treeHull.getElement(n),r=this.m_treeHull.getPrev(n);const o=this.m_getXY(i);for(;n!==s&&this.m_treeHull.size()>2;){const e=this.m_treeHull.getElement(r),s=this.m_getXY(e);if(Rm(J.orientationRobust(o,t,s)))break;const a=n;n=r,i=e,o.assign(s),r=this.m_treeHull.getPrev(n),this.m_deleteNode(a)}return n}}function Fm(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x>0?-1:0;if(0===n.y)return i.y>0?1:i.y<0?-1:0;const r=n.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?1:r<-o?-1:J.orientationRobust(t,e,s)}function Vm(t,e,s){const n=e.sub(t),i=s.sub(e);if(0===n.x)return i.x<0?-1:0;if(0===n.y)return i.y>0?-1:i.y<0?1:0;const r=n.crossProduct(i),o=4*Number.EPSILON*(Math.abs(i.x*n.y)+Math.abs(i.y*n.x));return r>o?1:r<-o?-1:J.orientationRobust(t,e,s)}function Lm(t,e,s){const n=new q(0);for(let a=0;a<e;a++)n.add(a);const i={userSort(e,s,n){n.sort(e,s,((e,s)=>t[e].compareX(t[s])))},getValue:e=>t[e].x};F.sortEx(n,0,e,i);let r=0;t:for(let a=0;a<e;++a){const e=n.read(a);for(;r>=2;){const i=s[r-2],o=s[r-1];if(t[o].equals(t[e])){n.write(a,-1);continue t}if(!(Fm(t[i],t[o],t[e])>=0)){o===n.read(a-1)&&n.write(a-1,-1);break}r--}s[r++]=e,2===r&&t[e].equals(t[s[0]])&&(n.write(1,-1),r--)}const o=r+1;t:for(let a=e-2;a>=0;--a){const e=n.read(a);if(!(e<0)){for(;r>=o;){const n=s[r-2],i=s[r-1];if(t[i].equals(t[e]))continue t;if(!(Vm(t[n],t[i],t[e])>=0))break;r--}if(0!==a){const n=s[r-1];s[r++]=e,t[e].equals(t[n])&&r--}}}return r>1&&t[s[0]].equals(t[s[r-1]])&&r--,r}function Rm(t){return t<0}function zm(t){return t>0}function km(t,e,s){let n=-1;if(e.y===s.y)n=0;else if(e.x===s.x)n=1;else{n=Math.abs(e.x-s.x)>=Math.abs(e.y-s.y)?0:1}let i=-1;return i=e[n]<s[n]?t[n]<e[n]?-1:s[n]<t[n]?1:0:e[n]<t[n]?-1:t[n]<s[n]?1:0,i}function Bm(t){return(t=t.clone()).divThis(Math.max(Math.abs(t.x),Math.abs(t.y))),t.normalize(),t}function Gm(t,e,s){t.inc(e,0)===s&&t.set(e,0,0),t.inc(e,1)===s&&t.set(e,1,0)}function Wm(t,s,n,i,r){switch(r){case 0:break;case 1:s.rightPerpendicularThis(),t.rightPerpendicularThis();break;case 2:s.negateThis(),t.negateThis();break;case 3:s.leftPerpendicularThis(),t.leftPerpendicularThis();break;default:e("")}return J.orientationRobustEx(t,s,n,i)}function jm(t,e,s,n,i){return Zm(t,!1,e,s,n,i)}function Zm(t,e,s,n,r,o){const a=s.getGeometryType(),m=n.getGeometryType(),u=Math.max(r,Oe(s,n));if(a===i.enumLine&&m===i.enumLine)return _s(s,n,u,o);let l=s,c=n,g=s.getStartXY(),d=s.getEndXY();if(g.compare(d)>0&&(l=s.clone().reverse()),g=n.getStartXY(),d=n.getEndXY(),g.compare(d)>0&&(c=n.clone().reverse()),e){if(s.equals(n))return 2;if(Xe(s,n,u))return 4}switch(a){case i.enumLine:switch(m){case i.enumEllipticArc:return um(t,c,l,u,o);case i.enumBezier:return Jo(t,c,l,u,o);case i.enumRationalBezier2:return Fi(t,c,l,u,o);case i.enumBezier2:return zr(t,c,l,u,o);default:h("")}break;case i.enumEllipticArc:switch(m){case i.enumLine:return um(t,l,c,u,o);case i.enumEllipticArc:return lm(t,l,c,u,o);case i.enumBezier:return Ko(t,c,l,u,o);case i.enumRationalBezier2:return Vi(t,c,l,u,o);case i.enumBezier2:return kr(t,c,l,u,o);default:h("")}break;case i.enumBezier:switch(m){case i.enumLine:return Jo(t,l,c,u,o);case i.enumEllipticArc:return Ko(t,l,c,u,o);case i.enumBezier:return $o(t,l,c,u,o);case i.enumRationalBezier2:return ta(t,l,c,u,o);case i.enumBezier2:return ea(t,l,c,u,o);default:h("")}break;case i.enumRationalBezier2:switch(m){case i.enumLine:return Fi(t,l,c,u,o);case i.enumEllipticArc:return Vi(t,l,c,u,o);case i.enumBezier:return ta(t,c,l,u,o);case i.enumRationalBezier2:return Ri(t,l,c,u,o);case i.enumBezier2:return zi(t,l,c,u,o);default:h("")}break;case i.enumBezier2:switch(m){case i.enumLine:return zr(t,l,c,u,o);case i.enumEllipticArc:return kr(t,l,c,u,o);case i.enumBezier:return ea(t,c,l,u,o);case i.enumRationalBezier2:return zi(t,c,l,u,o);case i.enumBezier2:return Br(t,l,c,u,o);default:h("")}break;default:h("")}}function Hm(t,e,s=!0){if(!s&&!Um(t,e))return 0;const n=t.isLine()&&e.isLine();if(t.getStartXY().equals(e.getStartXY())&&t.getEndXY().equals(e.getEndXY())){const s=1;if(n)return s;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===i.enumBezier){const n=t,i=e;return n.getControlPoint1().equals(i.getControlPoint1())&&n.getControlPoint2().equals(i.getControlPoint2())?s:0}if(r===i.enumEllipticArc){return fm(t,e,!1)?s:0}if(r===i.enumRationalBezier2){const n=t,i=e;if(n.getControlPoint1().equals(i.getControlPoint1())&&n.getStandardFormWeight()===i.getStandardFormWeight())return s}else if(r===i.enumBezier2){const n=e;if(t.getControlPoint1().equals(n.getControlPoint1()))return s}return 0}if(t.getStartXY().equals(e.getEndXY())&&t.getEndXY().equals(e.getStartXY())){const s=-1;if(n)return s;const r=t.getGeometryType();if(r!==e.getGeometryType())return 0;if(r===i.enumBezier){const n=t,i=e;return n.getControlPoint1().equals(i.getControlPoint2())&&n.getControlPoint2().equals(i.getControlPoint1())?s:0}if(r===i.enumEllipticArc){return fm(t,e,!0)?s:-1}if(r===i.enumRationalBezier2){const n=t,i=e;if(n.getControlPoint1().equals(i.getControlPoint1())&&n.getStandardFormWeight()===i.getStandardFormWeight())return s}else if(r===i.enumBezier2){const n=e;if(t.getControlPoint1().equals(n.getControlPoint1()))return s}return 0}return 0}function Um(t,e){const s=t.getGeometryType();return s===e.getGeometryType()&&(s!==i.enumEllipticArc||t.projectionBehavior()===e.projectionBehavior())}function Om(t,s,n,r,o,a,m){!o&&a&&e("");const u=s.getGeometryType(),l=n.getGeometryType(),c=Math.max(m,Oe(s,n));if(r&&(r.length=0),o&&(o.length=0),a&&(a.length=0),u===i.enumLine&&l===i.enumLine)return ps(s,n,r,o,a,c,!1,!1);let g=s,d=n,_=s.getStartXY(),p=s.getEndXY(),f=!1,P=!1;_.compare(p)>0&&(g=s.clone(!0).reverse(),f=!0),_=n.getStartXY(),p=n.getEndXY(),_.compare(p)>0&&(d=n.clone(!0).reverse(),P=!0);let y=0;switch(u){case i.enumLine:switch(l){case i.enumEllipticArc:y=cm(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumBezier:y=sa(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumRationalBezier2:y=ki(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumBezier2:y=Gr(t,d,g,r,a,o,c,!1,!1,!0);break;default:h("")}break;case i.enumEllipticArc:switch(l){case i.enumLine:y=cm(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumEllipticArc:y=gm(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier:y=na(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumRationalBezier2:y=Bi(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumBezier2:y=Wr(t,d,g,r,a,o,c,!1,!1,!0);break;default:h("")}break;case i.enumRationalBezier2:switch(l){case i.enumLine:y=ki(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumEllipticArc:y=Bi(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier:y=ra(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumRationalBezier2:y=Gi(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier2:y=Wi(t,g,d,r,o,a,c,!1,!1,!1);break;default:h("")}break;case i.enumBezier2:switch(l){case i.enumLine:y=Gr(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumEllipticArc:y=Wr(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier:y=oa(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumRationalBezier2:y=Wi(t,d,g,r,a,o,c,!1,!1,!0);break;case i.enumBezier2:y=jr(t,g,d,r,o,a,c,!1,!1,!1);break;default:h("")}break;case i.enumBezier:switch(l){case i.enumLine:y=sa(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumEllipticArc:y=na(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier:y=ia(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumRationalBezier2:y=ra(t,g,d,r,o,a,c,!1,!1,!1);break;case i.enumBezier2:y=oa(t,g,d,r,o,a,c,!1,!1,!1);break;default:h("")}break;default:h("")}if(f){if(o){for(let t=0;t<y;t++)o[t]=1-o[t];o.reverse()}r&&r.reverse(),a&&a.reverse()}if(P&&a)for(let e=0;e<y;e++)a[e]=1-a[e];return y}function Qm(t,e,s){if(e===s)return 0;e>s&&(s=tt(e,e=s));return t.cut(e,s,!0).calculateUpperLength2D()}function Jm(t,e,s,n,i){const r=[],o=[],a=[];for(let m=0,u=i;m<u;m++)r.push(t.calculateSubLengthFromStart(s[m])),o.push(e.calculateSubLengthFromStart(n[m])),ht(s[m],0,1)&&ht(n[m],0,1)&&t.getCoord2D(s[m]).equals(e.getCoord2D(n[m]))&&a.push(m);if(0===a.length||a.length===i)return;a.sort(((t,e)=>s[t]<s[e]?-1:s[t]>s[e]?1:n[t]<n[e]?-1:n[t]>n[e]?1:0));let h=-1;for(const m of a){if(h>=0&&s[m]===s[h]&&s[m]===s[h]){h=m;continue}h=m;const a=[];a.length=i;for(let t=0;t<a.length;++t)a[t]=t;a.sort(((t,e)=>{const s=r[m],n=o[m],i=r[t]-s,a=o[t]-n,h=i*i+a*a,u=r[e]-s,l=o[e]-n,c=u*u+l*l;return h<c?-1:h>c?1:0}));for(let r=0;r<i;r++){const i=a[r];if(i===m||s[i]===s[m]&&n[i]===n[m]||ht(s[i],0,1)&&ht(n[i],0,1))continue;const o=(s,n,i,r)=>{const o=new Se,a=new st;a.setWithEps(1);const h=new st;h.set(n,a.eps()),t.queryCoord2DE(h,o);const m=new Se;t.queryCoord2DE(new st(s),m);let u=!1;return o.eq(m)&&(h.set(r,a.eps()),e.queryCoord2DE(h,o),e.queryCoord2DE(new st(i),m),u=o.eq(m)),!u},h=J.getNAN();t.queryCoord2D(s[i],h);const u=J.getNAN();e.queryCoord2D(n[i],u);if(0===J.distance(h,u)&&o(s[m],s[i],n[m],n[i]))break;const l=new U(n[i],n[m]);l.normalizeNoNAN();const c=new U(s[i],s[m]);c.normalizeNoNAN();let g=-1,d=Number.POSITIVE_INFINITY,_=Number.POSITIVE_INFINITY,p=s[i];h.assign(t.getCoord2D(p));for(let r=0;r<5;r++){const r=e.getClosestCoordinateOnInterval(h,l,-1);u.assign(e.getCoord2D(r));const a=J.distance(h,u);if(p=t.getClosestCoordinateOnInterval(u,c,-1),p===s[m]&&r===n[m]){g=1;break}h.assign(t.getCoord2D(p));const f=J.distance(u,h);if(!(f<_&&a<d)){g=0;break}if(0===f&&0===a){o(s[m],s[i],n[m],n[i])?(s[i]=p,n[i]=r,g=0):g=1;break}_=f,d=a}if(-1===g&&(g=ht(s[i],0,1)||ht(n[i],0,1)?0:1),1!==g)break;s[i]=s[m],n[i]=n[m]}}}function Km(t,e,s,n,i,r,o,a,h,m,u,l,c){if(!r)return 0;const g=(t,e)=>{for(let s=0;s<r;++s){let n=e[s];if(ht(n,0,1)){n=ne(n);continue}const i=t.getCoord2D(n);n<.5?i.equals(t.getStartXY())&&Qm(t,0,n)<=Ue(t)&&(e[s]=0):i.equals(t.getEndXY())&&Qm(t,n,1)<=Ue(t)&&(e[s]=1)}};g(e,n),g(s,i),Jm(e,s,n,i,r);const d=[];for(let f=0,P=r;f<P;f++)d.push(f);const _=(t,e)=>c?ie(i[t],n[t],i[e],n[e]):ie(n[t],i[t],n[e],i[e]);if(d.length>1){d.sort(_);const t=Math.max(Ue(e),Ue(s));let r=0;for(let o=1,a=d.length;o<a;o++){const a=n[d[r]],h=n[d[o]],m=i[d[r]],u=i[d[o]];if(a!==h||m!==u)if(!(Qm(e,a,h)<=t&&Qm(s,m,u)<=t)||ht(a,0,1)&&ht(m,0,1)||ht(h,0,1)&&ht(u,0,1))r++,d[r]=d[o];else{const t=J.distance(e.getCoord2D(a),s.getCoord2D(m)),n=J.distance(e.getCoord2D(h),s.getCoord2D(u));if(t<=n)continue;if(n<t){d[r]=d[o];continue}}}if(d.length=r+1,1===d.length&&0!==d[0]&&(n[0]=n[d[0]],i[0]=i[d[0]],d[0]=0),d.length>2){const t=U.constructEmpty(),r=U.constructEmpty();t.setCoords(n[d[0]],n[d.at(-1)]),r.setCoords(i[d[0]],i[d.at(-1)]);let o=!0;for(let e=1,s=d.length-1;e<s;e++)if(!t.containsCoordinate(n[d[e]])||!r.containsCoordinate(i[d[e]])){o=!1;break}if(o){const n=[.5,.2,.7,.1,.3,.4,.6,.8,.9];for(let i=0;i<n.length;i++){let a=ot(t.vmin,t.vmax,n[i]);const h=e.getCoord2D(a);if(!s.isCloserThanDistance(h,r,m)){o=!1;break}a=ot(r.vmin,r.vmax,n[i]);const u=s.getCoord2D(a);if(!e.isCloserThanDistance(u,t,m)){o=!1;break}}}o&&(d[1]=d.at(-1),d.length=2)}}if(1===d.length&&t){const t=0,r=0;Ye(e,s,n[0],i[0],m,1,[t],[r])&&(d.push(1),n[1]=t,i[1]=r,d.sort(_))}if(u&&1===d.length){let t=!0;for(let r=0,o=d.length;r<o;r++){if(ht(n[d[r]],0,1)&&ht(i[d[r]],0,1)){if(0===J.distance(e.getCoord2D(n[d[r]]),s.getCoord2D(i[d[r]])))continue}t=!1;break}if(t)return 0}let p=0;for(let f=0,P=d.length;f<P;f++){if(a&&a.push(n[d[f]]),h&&h.push(i[d[f]]),o){const t=J.getNAN();e.queryCoord2D(n[d[f]],t),o.push(t)}p++}return p}function $m(t,e,s,n,i,r,o,a,h){if(ht(s,0,1)&&ht(n,0,1)){if(0===J.distance(t.getCoord2D(s),e.getCoord2D(n))){const m=1e-12,u=new Se,l=Number.EPSILON;if(t.queryDerivative(new st(s,l),u),u.isTrueZero()){const e=1===s?-1e-12:m;t.queryDerivative(new st(s,l).add(e),u)}1===s&&u.negateThis();const c=new Se;if(e.queryDerivative(new st(n,l),c),c.isTrueZero()){const t=1===s?-1e-12:m;e.queryDerivative(new st(n,l).add(t),c)}1===n&&c.negateThis(),u.isZero()||u.normalize(),c.isZero()||c.normalize();const g=u.dotProduct(c),d=u.crossProduct(c);d.scaleError(3);const _=()=>{if(h)return.001;{const s=t.calculateUpperLength2D(),n=e.calculateUpperLength2D();return Math.min(.01*i/Math.min(s,n),1e-10)}};if(g.ge(it)&&(d.isZero()||Math.abs(d.value())<_())){return Me(t,e,s,n,i,r,o,a)}}}return 0}function tu(t,e,n,i,r){let o=-1,a=-1,h=-1,m=-1;{const s=[0,e],r=[e,0],u=[0,i],l=[i,0];for(let e=0;e<2&&-1===o;++e)for(let i=0;i<2;++i)if(t[s[e]].equals(n[u[i]])){o=s[e],a=r[e],h=u[i],m=l[i];break}}if(-1===o){const s=new ve;s.setFromPoints(t,e+1);const o=new ve;return o.setFromPoints(n,i+1),o.inflate(r),s.isIntersectingW(o)?-1:0}{const u=O(e+1,Number.NaN),l=Mm(t,e+1,u);s(l>1);let c=0,g=0;for(let t=0;t<l;++t)o===u[t]&&(g=t,c++),a===u[t]&&c++;if(2!==c)return-1;const d=O(i+1,Number.NaN),_=Mm(n,i+1,d);s(_>1),c=0;let p=0;for(let t=0;t<_;++t)h===d[t]&&(p=t,c++),m===d[t]&&c++;if(2!==c)return-1;const f=t[u[(g+l-1)%l]],P=t[u[(g+1)%l]],y=n[d[(p+_-1)%_]],x=n[d[(p+1)%_]],C=t[o],v=[f,P,y,x],b=[0,1,2,3];b.sort(((t,e)=>J.compareVectorsOrigin(C,v[t],v[e])));let E=b[0];for(let t=1;t<4;t++){if(b[t]!==(E+1)%4)return-1;E=b[t]}{const t=f.sub(C),e=x.sub(C),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}{const t=P.sub(C),e=y.sub(C),s=e.dotProduct(t);if(s>0){const n=e.crossProduct(t),i=Math.abs(Math.atan2(n,s)),o=i*t.length(),a=i*e.length();if(o<=r||a<=r)return-1}}return 1}}var eu=I;class su extends is{constructor(t){super(t||{XStart:0,YStart:0,XEnd:0,YEnd:0})}assignMove(t){return this!==t&&(this.m_description=t.m_description,t.m_description=null,this.m_attributes=t.m_attributes,t.m_attributes=null,this.m_XStart=t.m_XStart,t.m_XStart=Number.NaN,this.m_YStart=t.m_YStart,this.m_XEnd=t.m_XEnd,t.m_XEnd=Number.NaN,this.m_YEnd=t.m_YEnd),this}assignCopy(t){return this!==t&&t.copyTo(this),this}calculateLowerLength3D(){return s(0),0}calculateUpperLength3D(){return s(0),0}changeEndPoints3D(t,e){s(0)}getClosestCoordinate3D(t,e,n){return s(0),0}getBoundary(){return Va(this)}getAttributeAsDbl(t,e,s){if(0===e)return 0===s?as(this,t):hs(this,t);const n=eu.getInterpolation(e),i=this.getStartAttributeAsDbl(e,s),r=this.getEndAttributeAsDbl(e,s);return Pt(n,i,r,t,eu.getDefaultValue(e))}constructFromCoords(t,e,s,n){this.dropAllAttributes(),this.setStartXYCoords(t,e),this.setEndXYCoords(s,n)}construct(t,e){this.dropAllAttributes(),this.setStartXY(t),this.setEndXY(e)}construct3D(t,e){s(0)}constructPoint(t,e){this.assignVertexDescription(t.getDescription()),this.mergeVertexDescription(e.getDescription()),this.setStart(t),this.setEnd(e)}getGeometryType(){return su.type}queryEnvelope(t){if(4===t.m_EnvelopeType){t.setEmpty(),t.assignVertexDescription(this.m_description);const e=oe.constructEmpty();this.queryEnvelope(e),t.setEnvelope(e);for(let s=1,n=this.m_description.getAttributeCount();s<n;s++){const e=this.m_description.getSemantics(s);for(let n=0,i=eu.getComponentCount(e);s<i;s++){const s=this.queryInterval(e,n);t.setIntervalEnvelope(e,n,s)}}}else 2===t.m_EnvelopeType?t.setCoords({xmin:this.m_XStart,ymin:this.m_YStart,xmax:this.m_XEnd,ymax:this.m_YEnd}):3===t.m_EnvelopeType?(t.setEmpty(),t.mergeCoords(this.m_XStart,this.m_YStart,We(this,0,1,0)),t.mergeCoords(this.m_XEnd,this.m_YEnd,We(this,1,1,0))):a("env type not impl")}applyTransformation(t){s(t instanceof ae);const e=new J;e.x=this.m_XStart,e.y=this.m_YStart,t.transformInPlace(e),this.m_XStart=e.x,this.m_YStart=e.y,e.x=this.m_XEnd,e.y=this.m_YEnd,t.transformInPlace(e),this.m_XEnd=e.x,this.m_YEnd=e.y}createInstance(){return new su({vd:this.m_description})}calculateLength2D(){return Math.sqrt(Es(this))}calculateLength3D(t){return s(0),0}changeEndPoints2D(t,e){this.setStartXY(t),this.setEndXY(e),this.normalizeAfterEndpointChange()}queryCoord2D(t,e){return rs(this,t,e)}queryCoord3D(t,e){s(0)}getCoordZ(t){return ms(this,t)}queryCoord2DE(t,e){ls(this,t,e)}getCoordX(t){return as(this,t)}getCoordY(t){return hs(this,t)}cut(t,e,s){const n=new nu;return this.queryCut(t,e,n,s),n.releaseSegment()}queryCut(t,e,s,n){const i=s.createLine();n&&i.assignVertexDescription(this.m_description);const r=J.getNAN();if(rs(this,t,r),i.setStartXYCoords(r.x,r.y),rs(this,e,r),i.setEndXYCoords(r.x,r.y),!n)for(let o=1,a=this.m_description.getAttributeCount();o<a;o++){const s=this.m_description.getSemantics(o),n=eu.getComponentCount(s);for(let r=0;r<n;r++){const n=this.getAttributeAsDbl(t,s,r);i.setStartAttribute(s,r,n);const o=this.getAttributeAsDbl(e,s,r);i.setEndAttribute(s,r,o)}}}queryDerivative(t,e){us(this,t,e)}getClosestCoordinate(t,e){return J.getClosestCoordinate(this.getStartXY(),this.getEndXY(),t,e)}getClosestCoordinateOnInterval(t,e,s=-1){const n=new J;this.queryCoord2D(e.vmin,n);const i=new J;this.queryCoord2D(e.vmax,i);const r=J.getClosestCoordinate(n,i,t,!1);return $e.recalculateParentT(e.vmin,e.vmax,r)}intersectionOfYMonotonicWithAxisX(t,e){const s=this.m_YEnd-this.m_YStart;if(!s)return t===this.m_YEnd?e:Number.NaN;const n=(t-this.m_YStart)/s;let i=as(this,n);return 1===n&&(i=this.m_XEnd),i}isCurve(){return!1}isMonotoneQuickAndDirty(){return!0}isDegenerate(t){const e=this.m_XStart-this.m_XEnd,s=this.m_YStart-this.m_YEnd;return Math.sqrt(e*e+s*s)<=t}isDegenerate3D(t,e){return s(0),!1}queryLooseEnvelope(t){this.queryEnvelope(t)}clone(t){const e=new su;return this.copyTo(e),e}tToLength(t){return t*this.calculateLength2D()}lengthToT(t){const e=this.calculateLength2D();return 0!==e?t/e:0}calculateWeightedAreaCentroid2D(t){const e=new J;return e.setCoords(0,0),e}calculateWeightedCentroid2D(){return this.getCoord2D(.5).mul(this.calculateLength2D())}getTangent(t){const e=J.getNAN();return e.setSub(this.getEndXY(),this.getStartXY()),e}getDerivative(t){const e=new J;return e.setSub(this.getEndXY(),this.getStartXY()),e}getCurvature(t){return 0}isIntersectingPoint(t,e,s){return xs(this,t,e,s)>=0}isIntersectingPoint3D(t,e,n,i,r=1){return s(0),!1}getYMonotonicParts(t,e){return 0}getMonotonicParts(t,e){return 0}getMonotonicPartParams(t,s){return s&&(t<2&&e(""),s[0]=0,s[1]=1),2}intersectionWithAxis2D(t,e,s,n){if(t){const t=this.m_YEnd-this.m_YStart;if(!t)return e===this.m_YEnd?-1:0;const i=(e-this.m_YStart)/t;return i<0||i>1?0:(s&&(s[0]=as(this,i)),n&&(n[0]=i),1)}{const t=this.m_XEnd-this.m_XStart;if(!t)return e===this.m_XEnd?-1:0;const i=(e-this.m_XStart)/t;return i<0||i>1?0:(s&&(s[0]=hs(this,i)),n&&(n[0]=i),1)}}calculateUpperLength2D(){return this.calculateLength2D()}calculateLowerLength2D(){return this.calculateLength2D()}normalizeAfterEndpointChange(){return!1}queryLooseEnvelopeOnInterval(t,e){if(2===e.m_EnvelopeType){let s=lt(t.vmin,0,1);const n=new J;return this.queryCoord2D(s,n),e.setCoords({pt:n}),s=lt(t.vmax,0,1),this.queryCoord2D(s,n),void e.mergeNe(n)}a("3d dst not impl")}orientBottomUp(){ds(this)}isLine(){return!0}isDegenerateToLineHelper(t){return!0}copyIgnoreAttributes(t){t.setStartXY(this.getStartXY()),t.setEndXY(this.getEndXY()),t.normalizeAfterEndpointChange()}calculateArea2DHelper(){return 0}absNormXYZ(t){return gs(this,t)}absNorm(){return this.getStartXY().norm(1)+this.getEndXY().norm(1)}queryEnvelopeW(t,e){e.setCoords(this.getCoord2D(t.vmin)),e.mergeNe(this.getCoord2D(t.vmax))}setSegmentFromCoords(t,e){cs(this,t[0],t[e-1])}writeInBufferStream(t,e){return s(0),0}readFromBufferStream(t,e){s(0)}snapControlPoints(t){return!1}needsSnapControlPoints(t){return!1}calculateSpecialPointsForCracking(t,e){return 0}ensureXYMonotone(){return!1}setCoordsForIntersector(t,e,s){cs(this,t,e)}static isIntersectingLineLine(t,e,s,n){return _s(t,e,s,n)}static isIntersectingLineLine_(t,e,s,n){return _s(t,e,s,n)}copyToImpl(t){}reverseImpl(){}equalsImpl(t){return!0}equalsImplTol(t,e){return!0}swapImpl(t){}afterCompletedModification(){}endPointModified(){}clearEndPointModified(){}intersect(t,e,s,n,i){return Om(!1,this,t,e,s,n,i)}intersectPoint(t,e,s){e.length<1&&n("");const i=xs(this,t,s,!1);return i>=0?(e&&(e[0]=i),1):0}isIntersecting(t,e,s){return 0!==jm(!1,this,t,e,s)}}su.type=i.enumLine;class nu{constructor(t){this.m_seg=null,this.m_curves=null,this.m_lineBuffer=new su,this.m_mask=0,this.m_active=0,void 0!==t&&(t.copy?t.copy.copyTo(this,!1):t.move?this.assignMove(t.move):t.segment?this.copyFrom(t.segment,!!t.bIgnoreAttributes):h("bad constructor params"))}assignCopy(t){return t instanceof nu?this!==t&&t.copyTo(this,!1):this.copyFrom(t,!1),this}assignMove(t){if(t instanceof nu){if(this===t)return this;this.reset(),1&t.m_mask&&(this.m_lineBuffer=t.m_lineBuffer,t.m_lineBuffer=null,this.m_mask=1),this.m_curves=t.m_curves,this.m_mask=t.m_mask,this.m_active=t.m_active,t.reset(),this.m_seg=this.activeSegment(),t.m_seg=null}else{if(this.m_seg===t)return this;this.create(t.getGeometryType()),this.m_seg.swap(t)}return this}activeSegment(){switch(this.m_active){case 0:return null;case 1:return this.line();case 2:return this.arc();case 4:return this.bezier3();case 8:return this.bezier2();case 16:return this.rbezier2();default:h("")}}get(){return this.m_seg}reset(){1&this.m_mask&&(this.m_lineBuffer=null),this.m_mask>1&&(this.m_curves=null),this.m_mask=0,this.m_active=0}empty(){return null===this.m_seg}copyTo(t,e){this!==t&&(this.empty()?t.m_seg=null:t.copyFrom(this.m_seg,e))}copyToWithZ(t,e){s(0)}createImpl(t){switch(t){case i.enumLine:1&this.m_mask||(this.m_lineBuffer=new su,this.m_mask|=1,this.m_active=1);break;case i.enumEllipticArc:2&this.m_mask||(this.m_curves=new Oa,this.m_mask=1&this.m_mask|2,this.m_active=2);break;case i.enumBezier:4&this.m_mask||(this.m_curves=new mo,this.m_mask=1&this.m_mask|4,this.m_active=4);break;case i.enumBezier2:8&this.m_mask||(this.m_curves=new nn,this.m_mask=1&this.m_mask|8,this.m_active=8);break;case i.enumRationalBezier2:16&this.m_mask||(this.m_curves=new on,this.m_mask=1&this.m_mask|16,this.m_active=16);break;default:e("")}}create(t){t===i.enumLine?this.createLine():t===i.enumEllipticArc?this.createEllipticArc():t===i.enumBezier?this.createCubicBezier():t===i.enumRationalBezier2?this.createQuadraticRationalBezier():t===i.enumBezier2?this.createQuadraticBezier():e("Segment_buffer.create")}copyFrom(t,e){this.m_seg!==t&&(this.create(t.getGeometryType()),e?t.copyIgnoreAttributes(this.m_seg):t.copyTo(this.m_seg))}copyFromWithZ(t,e){s(0)}line(){return this.m_lineBuffer}arc(){return this.m_curves}bezier3(){return this.m_curves}bezier2(){return this.m_curves}rbezier2(){return this.m_curves}createLine(){return this.createImpl(i.enumLine),this.m_seg=this.line(),this.line()}createEllipticArc(){return this.createImpl(i.enumEllipticArc),this.m_seg=this.arc(),this.arc()}createCubicBezier(){return this.createImpl(i.enumBezier),this.m_seg=this.bezier3(),this.bezier3()}createQuadraticRationalBezier(){return this.createImpl(i.enumRationalBezier2),this.m_seg=this.rbezier2(),this.rbezier2()}createQuadraticBezier(){return this.createImpl(i.enumBezier2),this.m_seg=this.bezier2(),this.bezier2()}releaseSegment(){if(this.m_seg=null,0===this.m_active&&h("releaseSegment"),1&this.m_active){const t=this.line();return this.m_mask-=1,this.m_active=0,this.m_lineBuffer=null,t}let t;return 2&this.m_active?t=this.arc():4&this.m_active?t=this.bezier3():8&this.m_active?t=this.bezier2():16&this.m_active?t=this.rbezier2():h("releaseSegment"),this.m_mask-=this.m_active,this.m_active=0,this.m_curves=null,t}equals(t){return t instanceof nu?this===t||(this.empty()?t.empty():!t.empty()&&this.get().equals(t.get())):(a("seg comparison not yet impl"),!1)}}export{Ha as $,em as A,jh as B,qm as C,ah as D,Tm as E,vh as F,es as G,Ys as H,le as I,Fa as J,ih as K,su as L,Ce as M,oh as N,tr as O,Na as P,on as Q,rm as R,nu as S,$e as T,As as U,Ts as V,Se as W,Ue as X,an as Y,Ah as Z,jm as _,eh as a,Om as a0,wm as a1,Zm as a2,Wa as a3,ds as a4,Hm as a5,Um as a6,$m as a7,Am as a8,Ga as b,Va as c,sh as d,Xm as e,Im as f,ss as g,de as h,Ym as i,ys as j,Qa as k,Oa as l,Ja as m,bm as n,Em as o,nh as p,qs as q,pe as r,ce as s,Xs as t,Ro as u,ge as v,_o as w,Ln as x,mo as y,tm as z};
