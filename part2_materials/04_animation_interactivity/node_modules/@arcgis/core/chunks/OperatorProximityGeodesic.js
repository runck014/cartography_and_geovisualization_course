/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{b as e,c as t}from"./tslib.es6.js";import{t as n,G as s,h as o,b as r,c as i,g as a}from"./Geometry.js";import{m as c,a as m,c as l}from"./SideCalculator2D-BNwb5gvz.js";import{a as u,b as g,S as f,s as y}from"./QuadraticBezier.js";import{m as S,P as d,d as N,b as x}from"./Point2D.js";import{P as h,h as p}from"./Envelope.js";import{G as A}from"./SimpleGeometryCursor.js";import{v as C,O as P,V as w,Q as E,a0 as _,a1 as T,a2 as j,Y as G,a3 as I,G as D,E as b,F as v,a4 as R,a5 as U,a6 as q,a7 as B}from"./ProjectionTransformation.js";import{O as F}from"./OperatorShapePreservingDensify.js";class V{getOperatorType(){return 10501}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,y,S,N,x){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();if(Number.isNaN(S)&&(S=0),S>=0||n("maxDeviationMeters"),0===e.getDimension())return this.getNearestVertex(e,t,y);const A=e.getGeometryType();if(A===s.enumGeometryCollection){const n=e;let s=c();for(let e=0,o=n.getGeometryCount();e<o;++e){const o=n.getGeometry(e),r=this.getNearestCoordinate(o,t,y,S,N,x);if(!r.isEmpty()){if(0===r.m_distance)return r;r.m_distance>=s.m_distance||(s=r,s.m_geometryIndex=e)}}return s}if(A===s.enumEnvelope){const n=new u;return n.addEnvelope(e,!1),this.getNearestCoordinate(n,t,y,S,N,x)}o(A)||r("Operation is not implemented for this geometry type");const I=e;if((N||x)&&A===s.enumPolygon){const n=()=>{const e=m(t,-1,0);return e.m_bRightSide=!0,e};if(y.isPannable()){const s=(new C).foldInto360Range(new h(t),y);if(s.isEmpty())return c();const o=(new C).foldInto360Range(e,y);if(o.isEmpty())return c();if((new P).execute(o,s,y,null)&&N)return n()}else{const e=(new C).clipToSpatialReference(new h(t),y,null,1);if(e.isEmpty())return c();const s=w(I,y,0,null);if(s.isEmpty())return c();if((new P).execute(s,e,y,null)&&N)return n()}}const b=y!==y.getGCS()?y.getSRToGCSTransform():null,v=new d;if(b?(new C).transform(b,[t],1,[v],!1):v.assign(t),v.isNAN())return c();const R=O(I,t,y,1);let U=R.m_distance;if(0===U)return R;Number.isNaN(U)?U=Number.POSITIVE_INFINITY:U*=1+1e-7;const q=y.getGCS(),B=q.getUnit().getUnitToBaseFactor(),V=v.clone();V.scale(B);const Y=D();y.querySpheroidData(Y);const X=E(Y.majorSemiAxis,Y.e2,V),L=_(Y.majorSemiAxis,Y.e2),z=new M(I.querySegmentIterator());0===S&&(S=.01);const Q=Y.majorSemiAxis*g(45),H=(new F).executeMany(z,y,Q,S,0,null),J=[];let K=-1;const W=new p,Z=new f;for(let n=H.next();null!==n;n=H.next()){if(n.isEmpty())continue;const t=H.getGeometryID(),s=e.getPathIndexFromPointIndex(t);e.isClosedPath(s)&&I.getPathEnd(s);const o=n;for(let e=0,n=o.getPathCount();e<n;++e){J.length=0;for(let t=o.getPathStart(e),r=o.getPathEnd(e);t<r;++t)J.push(o.getXY(t));if(b&&(new C).transform(b,J,J.length,J,!1),J.length>3){const e=k(J,J.length,v,q,1);if(e.m_distance<U){U=e.m_distance,W.assign(E(Y.majorSemiAxis,Y.e2,e.m_coordinate.mul(B))),K=t;let n=e.m_vertexIndex;n+1===J.length&&(n-=1),o.getSegmentBuffer(n,Z,!0)}}J.forEach((e=>e.mulThis(B)));const n=E(Y.majorSemiAxis,Y.e2,J[0]),s=new p;for(let e=1,r=J.length;e<r;++e){const r=E(Y.majorSemiAxis,Y.e2,J[e]);if(T(L,X,n,r,s)<U){const{first:s,second:i}=j(Y.majorSemiAxis,Y.e2,X,n,r,2,null);if(i<=U){const s=new p,{first:i,second:a}=j(Y.majorSemiAxis,Y.e2,X,n,r,0,s);a<U&&(U=a,W.assign(s),K=t,o.getSegmentBuffer(e-1,Z,!0))}}n.assign(r)}}}if(!Number.isFinite(U))return c();-1===K&&n("");const $=G(Y.majorSemiAxis,Y.e2,W);$.divThis(B);const ee=$.clone(),te=y!==y.getGCS()?y.getGCSToSRTransform():null;te&&(new C).transform(te,[$],1,[ee],!1),ee.isNAN()&&i("closestPoint2DSr.isNAN()"),a(!Z.empty());const ne=Z.get().getClosestCoordinate(ee,!1);ee.assign(Z.get().getCoord2D(ne)),b?(new C).transform(b,[ee],1,[$],!1):$.assign(ee),a(!$.isNAN());const se=this.getNearestVertex(new h($),v,y.getGCS()),oe=m(ee,K,se.m_distance);if(x&&e.getDimension()>0){const n=l(e,t,-1,-1),s=0!==n&&3!==n;oe.m_bRightSide=s}return oe}getNearestVertex(e,t,o){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();switch(e.getGeometryType()){case s.enumPoint:return Y(e,t,o);case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return O(e,t,o);default:r("")}}getNearestVertexPoint2D(e,t,n,s){return k(e,t,n,s)}getNearestVertices(e,t,o,i,a){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case s.enumPoint:{const n=Y(e,t,o);if(!n.isEmpty()&&n.m_distance<i&&a>=1){const e=[];return e.push(n),e}return[]}case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return X(e,t,o,i,a);default:r("")}}}function Y(s,o,r){const i={stack:[],error:void 0,hasError:!1};try{if(0===r.getCoordinateSystemType()&&n("Cannot use local SR"),1!==r.getCoordinateSystemType()){const e=new Array(2);e[0]=s.getXY(),e[1]=o.clone();const t=S(d,2);2!==I(r,e,2,t)&&n("Point cannot be projected to GCS");const i=r.getGCS(),a=Y(new h(t[0]),t[1],i);return m(a.m_coordinate,0,a.m_distance)}const t=r.getUnit().getUnitToBaseFactor(),a=s.getXY();a.scale(t);const c=o.clone();c.scale(t);const l=D();r.querySpheroidData(l);const u=e(i,new b,!1);v.geodeticDistance(l.majorSemiAxis,l.e2,a.x,a.y,c.x,c.y,u,null,null,R.PE_LINETYPE_GEODESIC);const g=s.getXY();return m(g,0,u.val)}catch(a){i.error=a,i.hasError=!0}finally{t(i)}}function O(s,o,r,i=0){0===r.getCoordinateSystemType()&&n("Cannot use local SR");let a=s.getAttributeStreamRef(0),c=s.getPointCount();const l=r.getGCS(),u=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(U(e,[o],1,[u],null),u.isNAN())return m(d.getNAN(),-1,Number.NaN);const t=(new C).execute(s,e,null);a=t.getAttributeStreamRef(0),c=t.getPointCount()}const g=l.getUnit().getUnitToBaseFactor(),f=N(c,0);for(let e=0;e<c;++e)f[e]=e;y(c,f);const S=D();l.querySpheroidData(S);const h=u.clone();h.scale(g);const A=E(S.majorSemiAxis,S.e2,h);let P=-1,w=Number.MAX_VALUE;const _=q(S.majorSemiAxis,S.e2);let T=c;const j=new d,G=new d;for(let e=0;e<T;){if(a.queryPoint2D(2*f[e],j),j.isNAN())continue;G.assign(j),G.scale(g);const t=E(S.majorSemiAxis,S.e2,G);if(p.distance(t,A)>w){f[T-1]=x(f[e],f[e]=f[T-1]),T--;continue}const n=B(_,t,A);n<w&&(P=f[e],w=n),e++}if(0!==S.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new b,!1);for(let e=0;e<T;e++){if(a.queryPoint2D(2*f[e],j),j.isNAN())continue;G.assign(j),G.scale(g);const n=E(S.majorSemiAxis,S.e2,G);p.distance(n,A)>w||(v.geodeticDistance(S.majorSemiAxis,S.e2,h.x,h.y,G.x,G.y,t,null,null,i),t.val<w&&(P=f[e],w=t.val))}}catch(R){n.error=R,n.hasError=!0}finally{t(n)}}const I=new d;return-1!==P&&I.assign(s.getXY(P)),m(I,P,w)}function k(s,o,r,i,a=0){0===i.getCoordinateSystemType()&&n("Cannot use local SR");const l=i.getGCS(),u=r.clone();if(1!==i.getCoordinateSystemType()){const e=i.getSRToGCSTransform();if(U(e,[r],1,[u],null),u.isNAN())return c();const t=S(d,o);U(e,s,o,t,null);const n=k(t,o,r,l,a);return n.isEmpty()?n:m(s[n.m_vertexIndex],n.m_vertexIndex,n.m_distance)}const g=l.getUnit().getUnitToBaseFactor(),f=N(o,0);for(let e=0;e<o;++e)f[e]=e;y(o,f);const h=D();l.querySpheroidData(h);const A=u.clone();A.scale(g);const C=E(h.majorSemiAxis,h.e2,A);let P=-1,w=Number.MAX_VALUE;const _=q(h.majorSemiAxis,h.e2);let T=o;for(let e=0;e<T;){const t=s[f[e]];if(t.isNAN())continue;const n=t.clone();n.scale(g);const o=E(h.majorSemiAxis,h.e2,n);if(p.distance(o,C)>w){f[T-1]=x(f[e],f[e]=f[T-1]),T--;continue}const r=B(_,o,C);r<w&&(P=f[e],w=r),e++}if(0!==h.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new b,!1);for(let e=0;e<T;e++){const n=s[f[e]];if(n.isNAN())continue;const o=n.clone();o.scale(g);const r=E(h.majorSemiAxis,h.e2,o);p.distance(r,C)>w||(v.geodeticDistance(h.majorSemiAxis,h.e2,A.x,A.y,o.x,o.y,t,null,null,a),t.val<w&&(P=f[e],w=t.val))}}catch(G){n.error=G,n.hasError=!0}finally{t(n)}}const j=new d;return-1!==P&&j.assign(s[P]),m(j,P,w)}function X(s,o,r,i,a){const c={stack:[],error:void 0,hasError:!1};try{0===r.getCoordinateSystemType()&&n("Cannot use local SR");let t=s.getAttributeStreamRef(0),l=s.getPointCount();const u=r.getGCS(),g=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(U(e,[o],1,[g],null),g.isNAN())return[];const n=(new C).execute(s,e,null);t=n.getAttributeStreamRef(0),l=n.getPointCount()}const f=u.getUnit().getUnitToBaseFactor(),S=N(l,0);for(let e=0;e<l;++e)S[e]=e;y(l,S);const h=D();u.querySpheroidData(h);const A=g.clone();A.scale(f);const P=E(h.majorSemiAxis,h.e2,A),w=[];let _=l;const T=new d,j=new d;for(let e=0;e<_;){if(t.queryPoint2D(2*S[e],T),T.isNAN())continue;j.assign(T),j.scale(f);const n=E(h.majorSemiAxis,h.e2,j);p.distance(n,P)>i?(S[_-1]=x(S[e],S[e]=S[_-1]),_--):e++}const G=(e,t)=>e.m_distance-t.m_distance,I=e(c,new b,!1);for(let e=0;e<_;e++)t.queryPoint2D(2*S[e],T),T.isNAN()||(v.geodeticDistance(h.majorSemiAxis,h.e2,A.x,A.y,T.x*f,T.y*f,I,null,null,R.PE_LINETYPE_GEODESIC),I.val<i&&w.push(m(T,S[e],I.val)));return w.sort(G),w.slice(0,a)}catch(l){c.error=l,c.hasError=!0}finally{t(c)}}class M extends A{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{V as OperatorProximityGeodesic};
