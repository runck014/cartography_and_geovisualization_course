/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{ForwardLinearDepth as e,addNearFar as i}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{isColorOrColorEmission as a,ShaderOutput as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SliceDraw as r}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as n}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ObjectAndLayerIdColor as l}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/ObjectAndLayerIdColor.glsl.js";import{PathVertexPosition as s}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/PathVertexPosition.glsl.js";import{OutputDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as t}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{EvaluateAmbientOcclusion as c}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl.js";import{EvaluateSceneLighting as g,addAmbientBoostFactor as m,addLightingGlobalFactor as v}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as h}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{Normals as p}from"../views/3d/webgl-engine/core/shaderLibrary/shading/Normals.glsl.js";import{NormalUtils as u}from"../views/3d/webgl-engine/core/shaderLibrary/shading/NormalUtils.glsl.js";import{PhysicallyBasedRenderingParameters as b,PBRMode as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadShadowMapDraw as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{ColorConversion as j}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{addProjViewLocalOrigin as L,addViewNormal as P,addCameraPosition as S}from"../views/3d/webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Float3PassUniform as O}from"../views/3d/webgl-engine/core/shaderModules/Float3PassUniform.js";import{FloatPassUniform as C}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as A,If as D}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{outputColorHighlightOID as I}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as B}from"../views/webgl/ShaderBuilder.js";function F(F){const V=new B,{vertex:_,fragment:x}=V;L(_,F),V.varyings.add("vpos","vec3"),V.include(s,F);const{output:z,spherical:M,pbrMode:H,receiveShadows:N}=F,k=a(z);switch((k||z===o.ObjectAndLayerIdColor)&&(V.include(n,F),V.include(f,F),V.include(e,F),V.include(l,F),V.include(y,F),V.varyings.add("vnormal","vec3"),V.varyings.add("vcolor","vec4"),_.main.add(A`
      vpos = calculateVPos();
      vnormal = normalize(localNormal());
      forwardViewPosDepth((view * vec4(vpos, 1.0)).xyz);

      gl_Position = transformPosition(proj, view, vpos);

      ${k?"forwardLinearDepth();":""}
      forwardObjectAndLayerIdColor();

      vcolor = getColor();`)),z){case o.ColorEmission:case o.Color:V.include(b,F),V.include(g,F),V.include(c,F),V.include(f,F),V.include(p,F),V.fragment.include(r,F),V.include(I,F),S(x,F),m(x),v(x),x.uniforms.add(_.uniforms.get("localOrigin"),new O("ambient",(e=>e.ambient)),new O("diffuse",(e=>e.diffuse)),new O("specular",(e=>e.specular)),new C("opacity",(e=>e.opacity))),x.include(j),h(x),x.main.add(A`
        discardBySlice(vpos);
        discardByTerrainDepth();

        shadingParams.viewDirection = normalize(vpos - cameraPosition);
        shadingParams.normalView = vnormal;
        vec3 normal = shadingNormal(shadingParams);
        float ssao = evaluateAmbientOcclusionInverse();

        vec3 posWorld = vpos + localOrigin;
        vec3 normalGround = ${M?"normalize(posWorld);":"vec3(0.0, 0.0, 1.0);"}

        float additionalAmbientScale = additionalDirectedAmbientLight(posWorld);
        vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
        float shadow = ${N?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), readShadowMap(vpos, linearDepth));":M?"lightingGlobalFactor * (1.0 - additionalAmbientScale);":"0.0;"}
        vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
        float combinedOpacity = vcolor.a * opacity;
        albedo += 0.25 * specular; // don't completely ignore specular for now

        ${D(H===w.Schematic,"float additionalAmbientIrradiance = additionalAmbientIrradianceFactor * mainLightIntensity[2];\n           vec4 emission = getEmissions();")}

        vec3 shadedColor = ${H===w.Schematic?"evaluateSceneLightingPBR(normal, albedo, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, mrr, emission, additionalAmbientIrradiance);":"evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);"}
        vec4 finalColor = vec4(shadedColor, combinedOpacity);
        outputColorHighlightOID(finalColor, vpos);`);break;case o.Depth:V.include(n,F),_.main.add(A`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),V.fragment.include(r,F),x.main.add(A`discardBySlice(vpos);`);break;case o.Shadow:case o.ShadowHighlight:case o.ShadowExcludeHighlight:case o.ViewshedShadow:V.include(n,F),i(V),V.varyings.add("depth","float"),_.main.add(A`vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);`),V.fragment.include(r,F),V.include(d,F),x.main.add(A`discardBySlice(vpos);
outputDepth(depth);`);break;case o.ObjectAndLayerIdColor:V.fragment.include(r,F),x.main.add(A`discardBySlice(vpos);
outputObjectAndLayerIdColor();`);break;case o.Normal:V.include(n,F),V.include(u,F),P(_),V.varyings.add("vnormal","vec3"),_.main.add(A`vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);`),V.fragment.include(r,F),x.main.add(A`discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
fragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);`);break;case o.Highlight:V.include(n,F),V.include(u,F),V.varyings.add("vnormal","vec3"),_.main.add(A`vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);`),V.fragment.include(r,F),V.include(t,F),x.main.add(A`discardBySlice(vpos);
calculateOcclusionAndOutputHighlight();`)}return V}const V=Object.freeze(Object.defineProperty({__proto__:null,build:F},Symbol.toStringTag,{value:"Module"}));export{V as P,F as b};
