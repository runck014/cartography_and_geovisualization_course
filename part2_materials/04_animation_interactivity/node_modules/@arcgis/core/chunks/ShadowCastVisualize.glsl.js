/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{clone as e,fromValues as s}from"../core/libs/gl-matrix-2/factories/vec4f64.js";import{ScreenSpacePass as a}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSpacePass.glsl.js";import{CameraSpace as r}from"../views/3d/webgl-engine/core/shaderLibrary/util/CameraSpace.glsl.js";import{Float4PassUniform as o}from"../views/3d/webgl-engine/core/shaderModules/Float4PassUniform.js";import{FloatPassUniform as t}from"../views/3d/webgl-engine/core/shaderModules/FloatPassUniform.js";import{glsl as i}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DPassUniform as l}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{S as n}from"./ShadowCastAccumulate.glsl.js";import{ShadowCastVisualization as d}from"../views/3d/webgl-engine/shaders/ShadowCastVisualizeTechniqueConfiguration.js";import{NoParameters as m}from"../views/webgl/NoParameters.js";import{ShaderBuilder as c}from"../views/webgl/ShaderBuilder.js";class h extends m{constructor(s){super(),this._data=s,this.sampleScale=0,this.opacityFromElevation=1,this.color=e(u),this.bandSize=.1,this.threshold=.5}get shadowCastMap(){return this._data.shadowCastTexture}}const u=s(.01,0,.25,1);function p(e){const s=new c,m=s.fragment;s.include(r),s.include(a);const{visualization:h,bandsEnabled:u}=e;m.constants.add("inverseSampleValue","float",n),m.uniforms.add(new l("shadowCastMap",(e=>e.shadowCastMap)),new t("sampleScale",(e=>e.sampleScale)),new t("opacityFromElevation",(e=>e.opacityFromElevation)),new o("uColor",(e=>e.color)));const p=h===d.Gradient,g=h===d.Threshold;return p&&u?m.uniforms.add(new t("bandSize",(e=>e.bandSize))):g&&m.uniforms.add(new t("threshold",(e=>e.threshold))),m.main.add(i`
    float record = texture(shadowCastMap, uv).r;
    float pixelSamples = record * inverseSampleValue;

    fragColor = vec4(0.0);
    if (pixelSamples < 1.0) {
      return;
    }

    float strength = pixelSamples * sampleScale;
    ${g?i`if (strength <= threshold) return;`:""}
    ${p&&u?i`strength = ceil(strength / bandSize) * bandSize;`:""}
    fragColor = vec4(uColor.xyz, uColor.a * opacityFromElevation ${p?"* strength":""});
  `),s}const g=Object.freeze(Object.defineProperty({__proto__:null,ShadowCastVisualizePassParameters:h,build:p},Symbol.toStringTag,{value:"Module"}));export{h as S,g as a,p as b};
