/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{earth as e,mars as o,moon as r}from"../geometry/support/Ellipsoid.js";import{OverlayContent as a}from"../views/3d/terrain/OverlayContent.js";import{IntegratedMeshMode as i}from"../views/3d/webgl-engine/collections/Component/Material/ComponentTechniqueConfiguration.js";import{ComponentData as l,ComponentDataType as t}from"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js";import{VertexDiscardMode as n}from"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardMode.js";import{ForwardLinearDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as s,isColorOrColorEmission as g}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutput.js";import{SlicePass as m}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{TextureCoordinateAttribute as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as v}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as h}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VertexPosition as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js";import{OutputDepth as w}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as p}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{computeFragmentNormals as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeFragmentNormals.glsl.js";import{ComputeMaterialColor as C}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js";import{ComputeNormalTexture as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{EvaluateSceneLighting as y,addLightingGlobalFactor as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{addMainLightIntensity as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MainLighting.glsl.js";import{PBRMode as j,PhysicallyBasedRenderingParameters as O}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadBaseColorTexture as S}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js";import{ReadShadowMapPass as M}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{terrainDepthTest as N}from"../views/3d/webgl-engine/core/shaderLibrary/shading/TerrainDepthTest.glsl.js";import{OverlayIM as T,getIMColorTexture as $}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{DiscardOrAdjustAlphaDraw as A}from"../views/3d/webgl-engine/core/shaderLibrary/util/DiscardOrAdjustAlpha.glsl.js";import{EllipsoidMode as D}from"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js";import{If as W,glsl as P}from"../views/3d/webgl-engine/core/shaderModules/glsl.js";import{Texture2DBindUniform as B}from"../views/3d/webgl-engine/core/shaderModules/Texture2DBindUniform.js";import{Texture2DPassUniform as R}from"../views/3d/webgl-engine/core/shaderModules/Texture2DPassUniform.js";import{outputColorHighlightOID as z}from"../views/3d/webgl-engine/shaders/OutputColorHighlightOID.glsl.js";import{ShaderBuilder as E}from"../views/webgl/ShaderBuilder.js";import{alphaCutoff as H}from"../webscene/support/AlphaCutoff.js";function I(I){const V=new E,{vertex:F,fragment:_}=V;V.include(u,I),V.include(h,I),V.include(v,I),V.include(c,I),V.include(d,I),V.include(l,I),V.include(A,I),_.include(m,I),V.include(S,I),V.include(N,I);const{output:G,pbrMode:k,hasNormalTexture:q,snowCover:U,receiveShadows:J,spherical:K,ellipsoidMode:Q}=I,X=k===j.Normal||k===j.Schematic;X&&(V.include(O,I),q&&V.include(f,I));const Y=G===s.Shadow||G===s.ShadowHighlight||G===s.ShadowExcludeHighlight,Z=Y&&I.componentData===t.Varying,ee=I.integratedMeshMode===i.ColorOverlay||I.integratedMeshMode===i.ColorOverlayWithWater;if(ee){V.include(y,I),V.include(T,I);const a=Q===D.Earth,i=Q===D.Earth,l=a?e.radius:i?o.radius:r.radius;F.code.add(`\n      ${W(K,`const float invRadius = ${P.float(1/l)};`)}\n      vec2 projectOverlay(vec3 pos) { return pos.xy ${W(K,"/ (1.0 + invRadius * pos.z);")}; }`)}const oe=ee&&g(G)&&k===j.WaterOnIntegratedMesh;oe&&(V.varyings.add("tbnTangent","vec3"),V.varyings.add("tbnBiTangent","vec3"),V.varyings.add("groundNormal","vec3"));const re=I.vertexDiscardMode===n.None,ae=I.vertexDiscardMode===n.Opaque,ie=1-1/255;if(F.main.add(P`
    bool castShadows;
    vec4 externalColor = forwardExternalColor(castShadows);
    ${W(Z,"if(!castShadows) { gl_Position = vec4(vec3(1e38), 1.0); return; }")}

    ${W(!re,`{ if (externalColor.a ${ae?">":"<="} ${P.float(ie)}) { gl_Position = vec4(vec3(1e38), 1.0); return; } }`)}

    ${W(G===s.ObjectAndLayerIdColor,"externalColor.a = 1.0;")}

    forwardPosition(readElevationOffset());
    forwardViewPosDepth(vPosition_view);
    forwardNormal();
    forwardTextureCoordinates();
    forwardVertexColor();
    forwardLinearDepth();
    forwardObjectAndLayerIdColor();
    ${W(oe,K?P`
              groundNormal = normalize(positionWorld());
              tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
              tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:P`
              groundNormal = vec3(0.0, 0.0, 1.0);
              tbnTangent = vec3(1.0, 0.0, 0.0);
              tbnBiTangent = vec3(0.0, 1.0, 0.0);`)}
    ${W(ee,"setOverlayVTC(projectOverlay(position));")}

    if (externalColor.a < ${P.float(H)}) {
      // Discard this vertex
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    }
  `),g(G))return V.include(C,I),V.include(b,I),V.include(y,I),V.include(z,I),J&&V.include(M,I),_.code.add(P`
      float evaluateShadow() {
        return ${J?"readShadowMap(vPositionWorldCameraRelative, linearDepth)":"0.0"};
      }`),ee&&_.uniforms.add(new R("ovColorTex",((e,o)=>$(e,o)))),_.main.add(P`
      discardBySlice(vPositionWorldCameraRelative);
      discardByTerrainDepth();

      vec4 textureColor = readBaseColorTexture();
      discardOrAdjustAlpha(textureColor);

      vec4 externalColor;
      int externalColorMixMode;
      readExternalColor(externalColor, externalColorMixMode);

      vec4 materialColor = computeMaterialColor(textureColor, externalColor, externalColorMixMode);
      ${W(ee,P`vec4 overlayColor = getOverlayColor(ovColorTex, vtcOverlay);`)}
    `),X?(L(_),K&&x(_),_.main.add(P`
        applyPBRFactors();
        ${W(k===j.Normal,P`if (externalColorMixMode == 3) {
              mrr = vec3(0.0, 0.6, 0.2);
            }`)}
        float additionalIrradiance = 0.02 * mainLightIntensity[2];
        ${W(q,"mat3 tangentSpace = computeTangentSpace(fragmentShadingNormal, vPositionWorldCameraRelative, vuv0);")}
        vec3 shadingNormal = ${q?"computeTextureNormal(tangentSpace, vuv0)":"fragmentShadingNormal"};
        vec3 normalGround = ${K?P`normalize(positionWorld())`:P`vec3(0.0, 0.0, 1.0)`};

        vec3 viewDir = normalize(vPositionWorldCameraRelative);
        float ssao = 1.0 - occlusion * evaluateAmbientOcclusionInverse();
        ${W(U,P`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
                 materialColor.rgb = mix(materialColor.rgb, vec3(1.1), snow);
                 ssao = mix(ssao, 0.5 * ssao, snow);
                 shadingNormal = mix(shadingNormal, fragmentFaceNormal, snow);`)}
        ${W(ee,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
        vec4 emission = getEmissions();
        ${W(K,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        ${K?P`float shadow = max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow());`:"float shadow = evaluateShadow();"}
        vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, shadow, ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);
        `)):(K&&x(_),oe&&_.uniforms.add(new B("ovNormalTex",(e=>e.overlay?.getTexture(a.WaterNormal)))),_.main.add(P`
        ${W(K,"float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());")}
        float shadow = ${J?K?"max(lightingGlobalFactor * (1.0 - additionalAmbientScale), evaluateShadow())":"evaluateShadow()":K?"lightingGlobalFactor * (1.0 - additionalAmbientScale)":"0.0"};

        ${W(U,P`float snow = smoothstep(0.5, 0.55, dot(fragmentFaceNormal, normalize(positionWorld())));
               materialColor.rgb = mix(materialColor.rgb, vec3(1), snow);`)}

        // At global scale we create some additional ambient light based on the main light to simulate global illumination
        float ssao = evaluateAmbientOcclusion();
        vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());

        ${W(ee,"materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;")}

        vec4 shadedColor = vec4(evaluateSceneLighting(fragmentShadingNormal, materialColor.rgb, shadow, ssao, additionalLight), materialColor.a);
        ${W(oe,P`vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
                 float waterNormalLength = length(overlayWaterMask);
                 if (waterNormalLength > 0.95) {
                   mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
                   vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, overlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, vPosition_view, positionWorld());
                   vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
                   // un-gamma the ground color to mix in linear space
                   shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
                 }`)}
      `)),_.main.add("outputColorHighlightOID(shadedColor, vPositionWorldCameraRelative);"),V;const le=G===s.Normal,te=G===s.ObjectAndLayerIdColor,ne=G===s.Highlight,de=Y||G===s.ViewshedShadow;return de&&V.include(w,I),le&&V.include(b,I),V.include(p,I),_.main.add(P`
    discardBySlice(vPositionWorldCameraRelative);

    vec4 textureColor = readBaseColorTexture();
    discardOrAdjustAlpha(textureColor);

    ${W(de,"outputDepth(linearDepth);")}
    ${W(le,P`fragColor = vec4(vec3(0.5) + 0.5 * fragmentFaceNormalView, 1.0);`)}
    ${W(te,ee?"fragColor = getOverlayColorTexel();":"outputObjectAndLayerIdColor();")}
    ${W(ne,P`${W(ee,P`
           vec2 overlayHighlightTexel = getAllOverlayHighlightValuesEncoded();
           calculateOcclusionAndOutputHighlightOverlay(overlayHighlightTexel);`,P`calculateOcclusionAndOutputHighlight();`)}`)}`),V}const V=Object.freeze(Object.defineProperty({__proto__:null,build:I},Symbol.toStringTag,{value:"Module"}));export{V as C,I as b};
