/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{G as e,S as t}from"../../../chunks/SimpleGeometryCursor.js";import{d as n,t as r,G as o,g as s}from"../../../chunks/Geometry.js";import{P as a,a as i}from"../../../chunks/Envelope.js";import{a as l,L as u}from"../../../chunks/QuadraticBezier.js";import{Envelope2D as c}from"../../../chunks/Envelope2D.js";import{P as m,q as N,r as g,m as h}from"../../../chunks/Point2D.js";import{ah as y,i as P}from"../../../chunks/ProjectionTransformation.js";import{a as p}from"../../../chunks/Centroid-DZi-eb9F.js";import{O as f}from"../../../chunks/OperatorProximity.js";class d{getOperatorType(){return 10203}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}executeMany(e,t){return new x(e,t)}execute(e,t){return new x(null,t).labelPoint(e)}}class x extends e{progress_(){}tock(){return!0}getRank(){return 1}constructor(e,t){super(),this.m_index=-1,this.m_progressCounter=0,this.m_progressTracker=t,this.m_inputGeoms=e}next(){const e=this.m_inputGeoms.next();return e?(n(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.labelPoint(e)):null}getGeometryID(){return this.m_index}labelPoint(e){if(null===e&&r("null pointer is not allowed"),e.getGeometryType()===o.enumPoint)return e;if(e.isEmpty())return new a({vd:e.getDescription()});switch(e.getGeometryType()){case o.enumPolygon:return this.labelPointPolygon(e);case o.enumPolyline:return this.labelPointPolyline(e);case o.enumMultiPoint:return this.labelPointMultiPoint(e);case o.enumEnvelope:return this.labelPointEnvelope(e);default:r("geometry is not supported")}}labelPointPolygon(e){const t=new c;e.queryEnvelope(t);const n=i(null,t,!0).total();let r=null,o=e;if(e.hasNonLinearSegments()){const t=new l({copy:e}),a=y(t,.25*n,n);s(a!==e),r=a,o=r}let u=0,h=0;for(let s=0,a=o.getPathCount();s<a;++s){const e=Math.abs(o.calculateRingArea2D(s));e>h&&(h=e,u=s)}const d=new m;if(Math.abs(h)<=2*n*n?d.setNAN():d.assign(p(o,u)),Number.isNaN(d.x)){const e=new c;return o.queryPathEnvelope(u,e),new a({pt:e.getCenter()})}if(o.getPointCount()<4)return new a({x:d.x,y:d.y});const x=m.getNAN(),w=[x.clone(),x.clone(),x.clone(),x.clone()],b=[Number.NaN,Number.NaN,Number.NaN,Number.NaN],C=[Number.NaN,Number.NaN,Number.NaN,Number.NaN];let _=!1,D=(new f).getNearestCoordinate(o,d,!0,!1);if(0===D.m_distance&&(_=!0,w[0]=d,D=(new f).getNearestCoordinate(o,d,!1,!1),D.m_distance>.25*t.minDimension()*1.66666666))return new a({x:d.x,y:d.y});b[0]=D.m_distance,C[0]=0;const k=new m;let A=!1,E=.25,q=-1;const v=new c;o.queryPathEnvelope(u,v);do{let e=Number.NaN;if(w[1]=this.calculateParacentroid_(o,N(v.xmin,v.xmax,E),n),w[1].isNAN()||(D=(new f).getNearestCoordinate(o,w[1],!1,!1),e=D.m_distance),e>n&&1===P(o,w[1],n))A=!0,b[1]=e,C[1]=m.sqrDistance(w[1],d);else if(e>q&&(q=e,k.setCoordsPoint2D(w[1])),E-=.01,E<.1){if(!(q>=0))break;A=!0,b[1]=q,w[1]=k,C[1]=m.sqrDistance(w[1],d)}}while(!A);A=!1,E=.5,q=-1;let G=.01,M=1;do{let e=Number.NaN;if(w[2]=this.calculateParacentroid_(o,N(v.xmin,v.xmax,E),n),w[2].isNAN()||(D=(new f).getNearestCoordinate(o,w[2],!1,!1),e=D.m_distance),e>n&&1===P(o,w[2],n))A=!0,b[2]=e,C[2]=m.sqrDistance(w[2],d);else if(e>q&&(q=e,k.setCoordsPoint2D(w[2])),E=.5+G*M,G+=.01,M*=-1,E<.3||E>.7){if(!(q>=0))break;A=!0,b[2]=q,w[2]=k,C[2]=m.sqrDistance(w[2],d)}}while(!A);A=!1,E=.75,q=-1;do{let e=Number.NaN;if(w[3]=this.calculateParacentroid_(o,N(v.xmin,v.xmax,E),n),w[3].isNAN()||(D=(new f).getNearestCoordinate(o,w[3],!1,!1),e=D.m_distance),e>n&&1===P(o,w[3],n))A=!0,b[3]=e,C[3]=m.sqrDistance(w[3],d);else if(e>q&&(q=e,k.setCoordsPoint2D(w[3])),E+=.01,E>.9){if(!(q>=0))break;A=!0,b[3]=q,w[3]=k,C[3]=m.sqrDistance(w[3],d)}}while(!A);const S=[0,1,2,3],j=_?0:1;for(let s=j;s<4;s++)for(let e=j;e<3;e++){const t=C[e],n=C[e+1];if(g(t,n)>0){const r=S[e];S[e]=S[e+1],S[e+1]=r,C[e]=n,C[e+1]=t}}let X=j,L=0,T=0;for(let s=j;s<4;s++){switch(s){case 0:T=2*b[S[s]];break;case 1:T=1.66666666*b[S[s]];break;case 2:T=1.33333333*b[S[s]];break;case 3:T=b[S[s]]}T>L&&(L=T,X=S[s])}return s(!w[X].isNAN()),new a({x:w[X].x,y:w[X].y})}labelPointPolyline(e){const t=new m;if(e.getPointCount()>2*e.getPathCount()){let n=-1,r=-Number.MAX_VALUE;for(let t=0,i=e.getPathCount();t<i;t++)if(e.getPathSize(t)>2){const o=e.calculatePathLength2D(t);o>r&&(r=o,n=t)}const o=e.getPathStart(n),s=e.getPathEnd(n),a=Math.trunc((o+s)/2);t.assign(e.getXY(a))}else{let n=-Number.MAX_VALUE;const r=e.querySegmentIterator();for(;r.nextPath();)if(r.hasNextSegment()){const e=r.nextSegment(),o=e.calculateLength2D();o>n&&(n=o,t.assign(e.getCoord2D(e.lengthToT(.5*o))))}}return new a({x:t.x,y:t.y})}labelPointMultiPoint(e){const t=new c;e.queryEnvelope(t);const n=t.getCenter(),r=(new f).getNearestCoordinate(e,n,!1,!1).m_coordinate;return new a({x:r.x,y:r.y})}labelPointEnvelope(e){const t=e.getCenterXY();return new a({x:t.x,y:t.y})}calculateParacentroid_(e,t,n){const r=new c;e.queryEnvelope(r);const o=new m(t,0);let a=Number.MAX_VALUE,i=Number.MAX_VALUE,l=!1,N=!1;const g=new u;g.setStartXYCoords(o.x,r.ymin-1),g.setEndXYCoords(o.x,r.ymax+1);const y=new c,P=new m,p=new m,f=h(m,2),d=e.querySegmentIterator();for(;d.nextPath();)for(;d.hasNextSegment();){const e=d.nextSegment();if(e.queryEnvelope(y),s(e.isMonotoneQuickAndDirty()),P.setCoordsPoint2D(g.getStartXY()),p.setCoordsPoint2D(g.getEndXY()),0===y.clipLine(P,p))continue;if(1!==g.intersect(e,f,null,null,n))continue;const t=f[0].y;a>i?t<a&&(a=t,l=!0):t<i&&(i=t,N=!0)}return l&&N?o.y=(a+i)/2:o.setNAN(),o}}const w=new d;function b(e){return w.execute(e,null)}function C(e){const n=w.executeMany(new t(e),null);return Array.from(n)}function _(){return w.supportsCurves()}export{b as execute,C as executeMany,_ as supportsCurves};
