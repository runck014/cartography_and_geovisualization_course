/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as t}from"../chunks/tslib.es6.js";import{equals as e}from"../core/arrayUtils.js";import{clone as r}from"../core/lang.js";import{property as s}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/Logger.js";import{subclass as i}from"../core/accessorSupport/decorators/subclass.js";import{writer as n}from"../core/accessorSupport/decorators/writer.js";import o from"./Extent.js";import a from"./Geometry.js";import l from"./Point.js";import h from"./SpatialReference.js";import{polygonCentroid as p}from"./support/centroid.js";import{polygonContainsPoint as c}from"./support/contains.js";import{isClockwise as u}from"./support/coordsUtils.js";import{getPolygonExtent as m}from"./support/extentUtils.js";import{isSelfIntersecting as f}from"./support/intersectsBase.js";import{project as g}from"./support/webMercatorUtils.js";import{updateSupportFromPoint as y}from"./support/zmUtils.js";var R;function d(t){return!Array.isArray(t[0])}function w(t){return"number"==typeof t[0]?.[0]}function v(t){if(!t)return;let{rings:e,hasM:r,hasZ:s,spatialReference:i}=t;switch(e??=[],w(e)&&(e=[e]),e[0]?.[0]?.length){case 4:s??=!0,r??=!0;break;case 3:s??=!0!==r,r??=!s;break;default:s??=!1,r??=!1}return i??=h.WGS84,{...t,hasM:r,hasZ:s,rings:e,spatialReference:i}}let x=R=class extends a{static fromExtent(t){const e=t.clone().normalize(),{spatialReference:r}=t;let s=!1,i=!1;for(const o of e)o.hasZ&&(s=!0),o.hasM&&(i=!0);const n={rings:e.map((t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(s&&t.hasZ){const r=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(r)}if(i&&t.hasM){const r=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(r)}return e})),spatialReference:r};return s&&(n.hasZ=!0),i&&(n.hasM=!0),new R(n)}constructor(t){super(v(t)),this.curveRings=void 0,this.rings=[],this.type="polygon"}get cache(){return this.commitProperty("curveRings"),this.commitProperty("hasM"),this.commitProperty("hasZ"),this.commitProperty("rings"),this.commitProperty("spatialReference"),{}}get centroid(){const t=p(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const e=new l;return e.x=t[0],e.y=t[1],e.spatialReference=this.spatialReference,this.hasZ&&(e.z=t[2]),e}writeCurveRings(t,e){e.curveRings=r(t)}get extent(){const t=m(this),{spatialReference:e}=this;return t?new o({...t,spatialReference:e}):null}get isSelfIntersecting(){return f(this.rings)}writeRings(t,e){e.rings=r(this.rings)}addRing(t){if(!t)return;const e=this.rings,r=e.length;if(d(t)){const s=[];for(let e=0,r=t.length;e<r;e++)s[e]=t[e].toArray();e[r]=s}else e[r]=t.slice();return this.notifyChange("rings"),this}clone(){const t=new R;return t.spatialReference=this.spatialReference,t.rings=r(this.rings),t.curveRings=r(this.curveRings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const r=this.spatialReference,s=t.spatialReference;if(null!=r!=(null!=s))return!1;if(null!=r&&null!=s&&!r.equals(s))return!1;if(this.rings.length!==t.rings.length)return!1;const i=([t,e,r,s],[i,n,o,a])=>t===i&&e===n&&(null==r&&null==o||r===o)&&(null==s&&null==a||s===a);for(let n=0;n<this.rings.length;n++){const r=this.rings[n],s=t.rings[n];if(!e(r,s,i))return!1}return!0}contains(t){if(!t)return!1;const e=g(t,this.spatialReference);return c(this,null!=e?e:t)}isClockwise(t){const e=d(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t;return u(e)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const r=this.rings[t][e],s=this.hasZ,i=this.hasM;return s&&!i?new l(r[0],r[1],r[2],void 0,this.spatialReference):i&&!s?new l(r[0],r[1],void 0,r[2],this.spatialReference):s&&i?new l(r[0],r[1],r[2],r[3],this.spatialReference):new l(r[0],r[1],this.spatialReference)}insertPoint(t,e,r){return this._validateInputs(t,e,!0)?(y(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t].splice(e,0,r),this.notifyChange("rings"),this):this}removePoint(t,e){if(!this._validateInputs(t,e))return null;const r=new l(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),r}removeRing(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],r=this.spatialReference,s=e.map((t=>new l(t,r)));return this.notifyChange("rings"),s}setPoint(t,e,r){return this._validateInputs(t,e)?(y(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t][e]=r,this.notifyChange("rings"),this):this}_validateInputs(t,e,r=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const s=this.rings[t];if(r&&(e<0||e>s.length))return!1;if(!r&&(e<0||e>=s.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([s({readOnly:!0})],x.prototype,"cache",null),t([s({readOnly:!0})],x.prototype,"centroid",null),t([s({json:{write:!0,origins:{"portal-item":{write:!1},"web-map":{write:!1},"web-scene":{write:!1}}}})],x.prototype,"curveRings",void 0),t([n("curveRings")],x.prototype,"writeCurveRings",null),t([s({readOnly:!0})],x.prototype,"extent",null),t([s({readOnly:!0})],x.prototype,"isSelfIntersecting",null),t([s({type:[[[Number]]],json:{write:{isRequired:!0}}})],x.prototype,"rings",void 0),t([n("rings")],x.prototype,"writeRings",null),x=R=t([i("esri.geometry.Polygon")],x);const j=x;x.prototype.toJSON.isDefaultToJSON=!0;export{j as default};
