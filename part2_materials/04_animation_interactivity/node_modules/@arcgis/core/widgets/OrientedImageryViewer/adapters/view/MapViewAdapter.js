/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import i from"../../../../core/Logger.js";import{waitTick as o,throwIfAborted as r,isAbortError as a}from"../../../../core/promiseUtils.js";import s from"../../../../geometry/Polygon.js";import{convertOrientationToPixelLocation as n}from"../../../../layers/orientedImagery/transformations/utils.js";import{activePolygonSymbol as l,polygonSymbol as c}from"../../symbols.js";class m{constructor(m){this.viewModel=m,this.createFootprints=async t=>{await o(t);const{coveragePolygons:i,currentBestFeature:r,isAdditionalCoverageVisible:a}=this.viewModel;for(const o of i)o?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:o?.imageID},geometry:o,symbol:l,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:o?.imageID},geometry:o,symbol:c.clone(),visible:a}))},this.updateFootprint=async(o,n)=>{const{activeViewer:c,currentBestFeature:m,currentCoverageVisible:u,footprintExtent:g}=this.viewModel,p=c?.imageSize;if(m&&p&&g)try{const i=await this.viewModel.getMapPoint(o,{feature:m,mode:"default",imageSize:p});r(n);const a=i.filter(t);if(!a.length)return;const c=[a.map((({x:e,y:t})=>[e,t,1]))];c[0].push(c[0][0]);const g=new s({rings:c,spatialReference:a[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:g,attributes:{imageID:m.attributes.objectId},symbol:l,visible:u}))}catch(d){a(d)||i.getLogger(this.viewModel).error("update-footprint",d)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,i)=>{const{horizontalFieldOfView:o,pitch:a,verticalFieldOfView:c,yaw:m}=t,{activeViewer:u,currentBestFeature:g,currentCoverageVisible:p,footprintExtent:d}=this.viewModel,f=u?.imageSize;if(!g||!f||!d)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:v,objectId:h}=g.attributes;if(a+v-c/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);let w=[];if(a+v+c/2<180){w=[[-o/2,c/2],[o/2,c/2],...a-c/2<0?[[-o/2,-c/2],[o/2,-c/2]]:[[o/2,-c/2],[-o/2,-c/2]]]}else if(a+v-c/2<180&&a+v+c/2>180){w=[[-o/2,-c/2]];const e=Math.floor(o/6),t=o/e;for(let i=0;i<=e;i++)w.push([i*t-o/2,90-a]);w.push([o/2,-c/2]);a-c/2<0&&([w[0],w[w.length-1]]=[w[w.length-1],w[0]])}const y=w.map((([e,t])=>n(m+e,a+t,f[0],f[1]))),b=await this.viewModel.getMapPoint(y,{feature:g,mode:"panorama",imageSize:f});r(i);const M=[b.map((({x:e,y:t})=>[e,t,1]))];M[0].push(M[0][0]);const C=new s({rings:M,spatialReference:b[0].spatialReference});this.viewModel.updateCurrentCoveragePolygon(new e({geometry:C,attributes:{imageID:h},symbol:l.clone(),visible:p}))}}}export{m as default};
