/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{createTask as t}from"../../../../core/asyncUtils.js";import a from"../../../../core/Promise.js";import{throwIfAborted as s}from"../../../../core/promiseUtils.js";import{property as i}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as r}from"../../../../core/accessorSupport/decorators/subclass.js";import{load as o}from"../../../../geometry/projection.js";import{convertSphereVertexToPixelLocation as n}from"../../../../layers/orientedImagery/transformations/utils.js";import{SketchHandlerMixin as c}from"../../mixins/SketchHandlerMixin.js";let l=[],u=[],h=0,m=class extends(c(a)){constructor(e){super(e),this.type="measurement",this.measurementArray=[],this.pixelMeasurement=0,this.pixelAreaMeasurement=0,this.polygonVertices=[],this._calculationTask=null,this._distanceCalculation=0,this._areaCalculation=null}initialize(){this.addResolvingPromise(o())}async handleCreate(e){const t=e.toolEventInfo;switch(e.tool){case"polyline":this.handlePolylineEvents(e,t);break;case"polygon":this.handlePolygonEvents(e,t)}}handleDelete(e){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}handleDestroy(){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}cursorUpdatePolylineHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;if("default"===t)this.measurementArray.push(e.coordinates);else{const t={x:e.coordinates[0],y:e.coordinates[1],z:e.coordinates[2]},s=n(t,a.imageSize[0],a.imageSize[1]);this.measurementArray.push([s.x,s.y])}const s=u.reduce(((e,t)=>e+t),0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=s}async cursorUpdatePolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;const s=e.coordinates;if(l=[...this.polygonVertices],"default"===t)l.push(s);else{const e={x:s[0],y:s[1],z:s[2]},t=n(e,a?.imageSize[0],a?.imageSize[1]);l.push([t.x,t.y])}if(l.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const i=l[0];l=l.filter(((e,t)=>0===t||t===l.length-1||JSON.stringify(e)!==JSON.stringify(i)));const r=await this._getAreaFromTask(l);r?.area&&r?.perimeter&&(h=r.area)}async handlePolylineEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetDistanceMeasurements(),this.viewModel.distanceMeasurementResult=0,this.viewModel.distanceAccuracyArray=[],void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic)return this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.measurementGraphic=e.graphic,void this.resetDistanceMeasurements();switch(t?.type){case"cursor-update":this.cursorUpdatePolylineHandler(t);break;case"vertex-add":if(this.measurementArray.length&&a){const e=await this._getAccuracyFromTask();e&&this.viewModel.distanceAccuracyArray.push(e)}this.vertexUpdatePolylineHandler()}const s=await this._getDistanceFromTask();this.pixelMeasurement=s??this.pixelMeasurement}async handlePolygonEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetAreaMeasurements(),this.viewModel.areaMeasurementResult=0,this.viewModel.areaMeasurementAccuracy=0,void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic)return this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.measurementGraphic=e.graphic,void this.resetAreaMeasurements();switch(t?.type){case"vertex-add":await this.vertexAddPolygonHandler(t,a);break;case"cursor-update":await this.cursorUpdatePolygonHandler(t)}this.viewModel.areaMeasurementResult=h>0?h:this.pixelAreaMeasurement}async vertexAddPolygonHandler(e,t){const{mode:a,activeViewer:s}=this.viewModel,i=e.added,r=i[i.length-1];if(!Array.isArray(r)||"none"===a||!s?.imageSize)return;if("default"===a)this.polygonVertices.push(r);else{const e={x:r[0],y:r[1],z:r[2]},t=n(e,s?.imageSize[0],s?.imageSize[1]);this.polygonVertices.push([t.x,t.y])}if(this.polygonVertices.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;if(t){const e=await this._getAreaAccuracyFromTask(this.polygonVertices);this.viewModel.areaMeasurementAccuracy=e&&e>this.viewModel.areaMeasurementAccuracy?e:this.viewModel.areaMeasurementAccuracy}const o=this.polygonVertices[0];this.polygonVertices=this.polygonVertices.filter(((e,t)=>0===t||t===this.polygonVertices.length-1||JSON.stringify(e)!==JSON.stringify(o)));const c=await this._getAreaFromTask(this.polygonVertices);if(!c?.area||!c?.perimeter)return;const{area:l}=c;this.pixelAreaMeasurement=l}vertexUpdatePolylineHandler(){this.measurementArray=this.measurementArray.slice(-1);const e=u.reduce(((e,t)=>e+t),0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=e,this.pixelMeasurement>0&&u.push(this.pixelMeasurement)}resetDistanceMeasurements(){this.measurementArray=[],this.pixelMeasurement=0,u=[]}resetAreaMeasurements(){this.polygonVertices=[],this.pixelAreaMeasurement=0,h=0}async _getAreaFromTask(e){const{mode:a}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=t((async t=>{this._areaCalculation=null;const i=await this.viewModel.calculateAreaMeasurement(e,a,t);s(t),this._areaCalculation=i})),await this._calculationTask.promise,this._areaCalculation}async _getDistanceFromTask(){const{mode:e}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=t((async t=>{this._distanceCalculation=0;const a=await this.viewModel.calculateDistanceMeasurement(this.measurementArray,e,t);s(t),this._distanceCalculation=a})),await this._calculationTask.promise,this._distanceCalculation}async _getAccuracyFromTask(){const{mode:e}=this.viewModel;return"none"===e?null:(this._calculationTask?.abort(),this._calculationTask=t((async t=>{this._distanceCalculation=0;const a="default"===e?await this.viewModel.calculateAccuracy(this.measurementArray,"distance",t):await this.viewModel.calculateAccuracyPanoramic(this.measurementArray,"distance",t);s(t),this._distanceCalculation=a})),await this._calculationTask.promise,this._distanceCalculation)}async _getAreaAccuracyFromTask(e){const{mode:a}=this.viewModel;return"none"===a?null:(this._calculationTask?.abort(),this._calculationTask=t((async t=>{this._distanceCalculation=0;const i="default"===a?await this.viewModel.calculateAccuracy(e,"area",t):await this.viewModel.calculateAccuracyPanoramic(e,"area",t);s(t),this._distanceCalculation=i})),await this._calculationTask.promise,this._distanceCalculation)}};e([i()],m.prototype,"type",void 0),e([i()],m.prototype,"measurementArray",void 0),e([i()],m.prototype,"pixelMeasurement",void 0),e([i()],m.prototype,"pixelAreaMeasurement",void 0),e([i()],m.prototype,"polygonVertices",void 0),m=e([r("esri.widgets.OrientedImageryViewer.adapters.sketch.MeasurementAdapter")],m);const d=m;export{d as default};
