/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{parse as t}from"../../layers/support/arcgisLayerUrl.js";import{fetchFeatureService as r}from"../../layers/support/fetchService.js";import{LayerLoadContext as a}from"../../layers/support/LayerLoadContext.js";import o from"../Portal.js";import{createForItemRead as n}from"./jsonContext.js";import{getFirstLayerOrTable as s,preprocessFSItemData as l,populateSceneServiceItemData as i,getNumLayersAndTables as u,createSublayerData as p,instanceTypeToLayerTypes as c,getSublayersByLayerType as y,layerTypeToLayerModuleType as m}from"./loadUtils.js";import{hasTypeKeyword as d}from"./portalItemUtils.js";import{loadStyleRenderer as f}from"../../renderers/support/styleUtils.js";import{fetchArcGISServiceJSON as w}from"../../support/requestPresets.js";async function h(e,t){const r=e.instance.portalItem;if(r?.id)return await r.load(t),g(e),e.validateItem&&e.validateItem(r),I(e,t)}function g(t){const r=t.instance.portalItem;if(!r?.type||!t.supportedTypes.includes(r.type))throw new e("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:r?.type,expectedType:t.supportedTypes.join(", ")})}async function I(e,t){const r=e.instance,o=r.portalItem;if(!o)return;const{url:s,title:l}=o,i=n(o,"portal-item");if("group"===r.type)return b(r,i,e);s&&"media"!==r.type&&r.read({url:s},i);const u=new a,p=await F(e,u,t);return p&&r.read(p,i),r.resourceReferences={portalItem:o,paths:i.readResourcePaths??[]},"subtype-group"!==r.type&&r.read({title:l},i),f(r,i)}async function b(t,r,a){const o=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:n,type:s}=o;if("Group Layer"===s){if(!d(o,"Map"))throw new e("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return L(t,a)}return t.read({title:n},r),S(t,a)}async function L(t,r){const a=t.portalItem,o=await a.fetchData("json");if(!o)return;if(!r.populateGroupLayer)throw new e("portal:missing-populate-group-layer","Missing populate group layer");const s=n(a,"web-map");t.read(o,s),await r.populateGroupLayer(t,o,{context:s}),t.resourceReferences={portalItem:a,paths:s.readResourcePaths??[]}}async function S(t,r){let o;const{portalItem:n}=t;if(!n)return;const p=n.type,c=r.layerModuleTypeMap;if(!c)throw new e("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(p){case"Feature Service":case"Feature Collection":o=c.FeatureLayer;break;case"Stream Service":o=c.StreamLayer;break;case"Scene Service":o=c.SceneLayer;break;default:throw new e("portal:unsupported-item-type-as-group",`The item type '${p}' is not supported as a 'IGroupLayer'`)}const y=new a;let[m,d]=await Promise.all([o(),F(r,y)]),f=()=>m;if("Feature Service"===p){const e=s(d)?.customParameters;d=n.url?await l(d,n.url,y):{},f=await D(d,c)||f;const r=await C(n.url,{customParameters:e,loadContext:y});return await v(t,f,f,d,c,r)}return"Scene Service"===p&&n.url&&(d=await i(n,d,y)),u(d)>0?await v(t,f,null,d,c):await T(t,f,c)}async function T(e,t,r){const{portalItem:a}=e;if(!a?.url)return;const o=await w(a.url);o&&v(e,t,null,{layers:o.layers?.map(p),tables:o.tables?.map(p)},r)}async function v(e,t,r,a,o,n){let s=a.layers||[];const l=a.tables||[];if("Feature Collection"===e.portalItem?.type?(s.forEach(((e,t)=>{e.id=t,"Table"===e?.layerDefinition?.type&&l.push(e)})),s=s.filter((e=>"Table"!==e?.layerDefinition?.type))):(s.reverse(),l.reverse()),s.forEach((r=>{const o=n?.(r);if(o||!n){const n=j(e,t(r),a,r,o);e.add(n)}})),l.length){const t=r?null:await o.FeatureLayer();l.forEach((o=>{const s=n?.(o);if(s||!n){const n=j(e,r?r(o):t,a,o,s);e.tables.add(n)}}))}}function j(e,t,r,a,n){const s=e.portalItem,l={portalItem:s.clone(),layerId:a.id};null!=a.url&&(l.url=a.url);const i=new t(l);if("sourceJSON"in i&&(i.sourceJSON=n),"subtype-group"!==i.type&&"catalog"!==i.type&&(i.sublayerTitleMode="service-name"),"Feature Collection"===s.type){const e={origin:"portal-item",portal:s.portal||o.getDefault()};i.read(a,e);const t=r.showLegend;null!=t&&i.read({showLegend:t},e)}return i}async function F(e,t,r){if(!1===e.supportsData)return;const a=e.instance,o=a.portalItem;if(!o)return;let n=null;try{n=await o.fetchData("json",r)}catch(l){}if(x(a)){let e=null;const r=await M(o,n,t);if((n?.layers||n?.tables)&&r>0){if(null==a.layerId){const e=c(a.type),t=e?.length?y(n,e)[0]:s(n);t&&(a.layerId=t.id)}e=P(n,a),"OrientedImageryLayer"===e?.layerType&&"oriented-imagery"===a.type&&a.supportedSourceTypes.add("Feature Layer"),e&&null!=n.showLegend&&(e.showLegend=n.showLegend)}return r>1&&"sublayerTitleMode"in a&&"service-name"!==a.sublayerTitleMode&&(a.sublayerTitleMode="item-title-and-service-name"),e}return n}async function M(e,r,a){if(r?.layers&&r?.tables)return u(r);const o=t(e.url);if(!o)return 1;const n=await a.fetchServiceMetadata(o.url.path,{customParameters:s(r)?.customParameters}).catch((()=>null));return(r?.layers?.length??n?.layers?.length??0)+(r?.tables?.length??n?.tables?.length??0)}function P(e,t){const{layerId:r}=t,a=e.layers?.find((e=>e.id===r))||e.tables?.find((e=>e.id===r));return a&&G(a,t)?a:null}function x(e){return"stream"!==e.type&&"layerId"in e}function G(e,t){const r="layerType"in e&&e.layerType,{type:a}=t;return!("feature"===a&&r&&"ArcGISFeatureLayer"!==e.layerType||"catalog"===a&&!r||"oriented-imagery"===a&&!r||"subtype-group"===a&&!r)}async function C(e,t){const{layersJSON:a}=await r(e,t);if(!a)return null;const o=[...a.layers,...a.tables];return e=>o.find((t=>t.id===e.id))}async function D(e,t){const{layers:r,tables:a}=e,o=[...r??[],...a??[]];if(!o.length)return;const n=new Set,s=[];for(const{layerType:u}of o){const e=u??"ArcGISFeatureLayer";if(n.has(e))continue;n.add(e);const r=t[m(e)];s.push(r())}const l=await Promise.all(s),i=new Map;return Array.from(n).forEach(((e,t)=>{i.set(e,l[t])})),({layerType:e})=>{const t=e??"ArcGISFeatureLayer";return i.get(t)}}export{h as load};
