/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{throwIfAborted as e}from"../../../core/promiseUtils.js";import{create as t}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{zeros as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{transpose as n}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{a,g as o}from"../../../chunks/vec32.js";import i from"../../../geometry/Circle.js";import c from"../../../geometry/Mesh.js";import s from"../../../geometry/Multipoint.js";import f from"../../../geometry/Polygon.js";import{projectWithZConversion as l}from"../../../geometry/projection.js";import m from"../../../geometry/SpatialReference.js";import{earth as u}from"../../../geometry/support/Ellipsoid.js";import h from"../../../geometry/support/MeshComponent.js";import{MeshVertexAttributes as p}from"../../../geometry/support/MeshVertexAttributes.js";import{intersectRay as y,create as g,fromArray as x}from"../../../geometry/support/plane.js";import{isWebMercator as d}from"../../../geometry/support/spatialReferenceUtils.js";import{getWebMercatorScalingFactor as w,createRotationMatrixFromHPR as M,transformMat3 as R,scaleAndAddWithFactor as j,scaleWithFactor as v,computeHFOVAndVFOV as P,projectiveTransform as D}from"../transformations/utils.js";const b=Math.PI/180;function A(e){return e.isSpherical?H(e):I(e)}function I(e){const{horizontalFieldOfView:t,verticalFieldOfView:r,geometry:n,cameraHeading:a}=e,o=w(n.y,n.spatialReference);let i=e.cameraPitch,c=e.cameraRoll??0,s=150;t>150&&(i=90,c=0,s=5);const l=Math.ceil(t/s),m=z(l,a,t);let u=e.farDistance?e.farDistance*o:e.cameraHeight*o/Math.cos(i*b);e.cameraPitch+r/2>=90&&(u=(e.farDistance||20)*o);const h=new f({spatialReference:n?.spatialReference});h.imageID=e.objectId;let p=null;for(const f of m)p=V(f,i,e.cameraHeight,n,u,o,r,t,l,h,c,e.nearDistance);return p.imageID=e.objectId,{polygon:h,frustum:p}}function z(e,t,r){const n=[];if(e%2==0)for(let a=0;a<e/2;a++)n.push(t-r/e*(a+.5),t+r/e*(a+.5));else{n.push(t);for(let a=1;a<e/2;a++)n.push(t-r/e*a,t+r/e*a)}return n.sort(),n}function V(e,i,c,s,f,l,m,u,h,p,y=0,g=0){const x=n(t(),M([e,i,y??0])),d=q({cameraHeight:c,cameraPitch:i,farDistance:f,location:s,horizontalFieldOfView:u,nearDistance:g,verticalFieldOfView:m},x),w=R([0,0,-1],x),{x:P,y:D}=s,A=j([P,D,c],w,f,l),I=2*Math.tan(m*b/2)*f,z=2*Math.tan(u/h*b/2)*f,V=R([0,1,0],x),H=R([1,0,0],x),O=v(V,I/2,l),S=v(H,z/2,l),C=a(r(),O,S),U=o(r(),O,S),E=F([o(r(),A,C),o(r(),A,U),a(r(),A,C),a(r(),A,U)],c,s,l);return E.push(E[0]),p.addRing(E),d}function F(e,t,r,n){return e.map((e=>C(e,t,r,n)))}function H(e){const{geometry:t,farDistance:r,objectId:n,nearDistance:a,cameraHeight:o}=e,s=w(t.y,t.spatialReference),f=new i({center:t.clone(),radius:r*s});if(f.imageID=n,a){const e=new i({center:t.clone(),radius:a*s});f.addRing(e.rings[0])}const l=t.clone();l.z=o-r*s;const m=c.createSphere(l,{size:2*r*s});return m.imageID=n,{polygon:f,frustum:m}}function O(e,t){return e.contains(t)}function S(e,t){return Math.sign(e)!==Math.sign(t)}function q(e,t,n){const{cameraHeight:i,cameraPitch:s,farDistance:f,location:l,horizontalFieldOfView:m,nearDistance:u,verticalFieldOfView:h}=e,y=E(l),g=s+h/2>=90==!1,x=2*Math.tan(h*b/2)*u,d=2*Math.tan(m*b/2)*u,w=2*Math.tan(h*b/2)*f,M=2*Math.tan(m*b/2)*f;let P,D;D=[0,0,-1],D=R(D,t),P=j([l.x,l.y,i],D,f,y),g&&(P[2]=0);const A=j([l.x,l.y,i],D,u,y);let I=[0,1,0];I=R(I,t);let z=[1,0,0];z=R(z,t);let V=[],F=[];u?(F=[{faces:[4,0,3,4,7,3]},{faces:[5,1,2,5,6,2]},{faces:[4,0,1,4,5,1]},{faces:[6,2,3,6,7,3]}],V=V.concat(o(r(),A,a(r(),v(I,x/2,y),v(z,d/2,y)))),V=V.concat(o(r(),A,o(r(),v(I,x/2,y),v(z,d/2,y)))),V=V.concat(a(r(),A,a(r(),v(I,x/2,y),v(z,d/2,y)))),V=V.concat(a(r(),A,o(r(),v(I,x/2,y),v(z,d/2,y))))):(V=[l.x,l.y,i],F=[{faces:[0,1,2,0,2,3,0,3,4,0,4,1]}]),V=V.concat(o(r(),P,a(r(),v(I,w/2,y),v(z,M/2,y)))),V=V.concat(o(r(),P,o(r(),v(I,w/2,y),v(z,M/2,y)))),V=V.concat(a(r(),P,a(r(),v(I,w/2,y),v(z,M/2,y)))),V=V.concat(a(r(),P,o(r(),v(I,w/2,y),v(z,M/2,y))));const H=new p({position:Float64Array.from(V)});return new c({vertexAttributes:H,components:F,spatialReference:l.spatialReference})}function C(e,t,n,o){{const i=Math.sqrt((e[2]-t)**2+(Math.sqrt((e[0]-n.x)**2+(e[1]-n.y)**2)/o)**2)*o,c=v(a(r(),[e[0],e[1],e[2]],[n.x,n.y,t]),1/i,1/o),s=t/(t-e[2]),f={x:(1-s)*n.x+s*e[0],y:(1-s)*n.y+s*e[1],z:(1-s)*t+s*e[2]},l=Math.sqrt((f.z-t)**2+(Math.sqrt((f.x-n.x)**2+(f.y-n.y)**2)/o)**2)*o,m=v(a(r(),[f.x,f.y,f.z],[n.x,n.y,t]),1/l,1/o);return S(c[0],m[0])&&S(c[1],m[1])&&S(c[2],m[2])||e[2]>=0?[e[0],e[1],0]:[f.x,f.y,f.z]}}function U(e){const{spatialReference:t,x:r,y:n}=e.geometry,{cameraHeading:a,cameraPitch:o,farDistance:i,nearDistance:c}=e,s=E(e.geometry),l=new f({spatialReference:t}),m=Math.abs(1.44*i*s);let u=Math.abs(1.44*c*s);(o<20||null==a)&&(u=m);const h=[];return h[0]={x:r+m*Math.sin((a-45)*b),y:n+m*Math.cos((a-45)*b)},h[1]={x:r+m*Math.sin((a+45)*b),y:n+m*Math.cos((a+45)*b)},h[2]={x:r+u*Math.sin((a+135)*b),y:n+u*Math.cos((a+135)*b)},h[3]={x:r+u*Math.sin((a+225)*b),y:n+u*Math.cos((a+225)*b)},l.addRing([[h[0].x,h[0].y,0],[h[1].x,h[1].y,0],[h[2].x,h[2].y,0],[h[3].x,h[3].y,0],[h[0].x,h[0].y,0]]),l}function E(e){return e&&d(e?.spatialReference)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*e.y/u.radius))):1}function k(e,t){const n=1+t/100;if("esri.geometry.Circle"===e.declaredClass){const{radius:t,center:r}=e,a=new i({radius:t*n,center:r});return e.rings.length>1&&a.addRing(e.rings[1]),a}if("esri.geometry.Polygon"===e.declaredClass){const t=new f({spatialReference:e.spatialReference}),o=e.centroid;if(o){const i=[];for(let t=0;t<e.rings[0].length;t++){const c=Math.sqrt((o.x-e.rings[0][t][0])**2+(o.y-e.rings[0][t][1])**2),s=v(a(r(),[e.rings[0][t][0],e.rings[0][t][1],0],[o.x,o.y,0]),1/c,1),f=j([o.x,o.y,0],s,c*n,1);i.push({x:f[0],y:f[1]})}t.addRing([[i[0].x,i[0].y,0],[i[1].x,i[1].y,0],[i[2].x,i[2].y,0],[i[3].x,i[3].y,0],[i[0].x,i[0].y,0]])}return t}return e}async function L(e,t,r){const{cameraHeight:n,cameraLocation:a,cameraPitch:o,frustumVertices:i,horizontalFieldOfView:c,imageHeight:s,imageWidth:f,inSRS:l,outSRS:u,verticalFieldOfView:h,cameraRoll:p,options:y}=r,g=new m(l),x=new m(u),d=P(c,h,p??0),w=i.length>15;return o+d.vfov/2>=90?await K(i,e,f,s,g,x,w,y):await W(i,e,t,a,n,w,g,x,y)}async function W(e,t,r,n,a,o,i,s,f){const l=B(e,t,r,n,a);if(!l)return;const{farPlane:m,nearPlane:u}=l,h=await N([...u?.vertexPositions??e.slice(0,3),...m.vertexPositions],i,s,f),y=Z(h);return new c({vertexAttributes:new p({position:h}),components:Y(o?T(y,!0):X(y,!0)),spatialReference:s})}function B(e,t,r,n,a){const o=Q(e),i=Q(e,"near");if(!o)return;const c=t.length;for(let s=0;s<c;s++){const e=Array.from(r[s]),t=[e[0]-n[0],e[1]-n[1],e[2]-(n[2]??a)];J(n,t,s,i),G(n,t,s,o)}return{farPlane:o,nearPlane:i}}function G(e,t,n,a){const{coefficients:o,vertexPositions:i}=a,c=r();y(o,{origin:e,direction:t},c)&&i.splice(3*n,3,...c)}function J(e,t,n,a){if(!a)return;const o=r();y(a.coefficients,{origin:e,direction:t},o)&&a.vertexPositions.splice(3*n,3,...o)}async function K(e,t,r,n,a,o,i,s){let f,l=i?new Array:[e[0],e[1],e[2]],m=new Array;for(const c of t)i?(f=D([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[0],e[1],e[2]],[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]]]),l=l.concat(...f),f=D([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[12],e[13],e[14]],[e[15],e[16],e[17]],[e[18],e[19],e[20]],[e[21],e[22],e[23]]]),m=m.concat(...f)):(f=D([c[0],c[1],1],[[0,0,1],[r,0,1],[r,n,1],[0,n,1]],[[e[3],e[4],e[5]],[e[6],e[7],e[8]],[e[9],e[10],e[11]],[e[12],e[13],e[14]]]),l=l.concat(...f));l=l.concat(m);const u=await N(l,a,o,s),h=Z(u);return new c({vertexAttributes:new p({position:u}),components:Y(i?T(h,!0):X(h,!0)),spatialReference:o})}async function N(t,r,n,a){if(r.equals(n))return t;const o=t.reduce(((e,t,r)=>{const n=Math.floor(r/3);return e[n]||(e[n]=new Array),e[n].push(t),e}),new Array),{points:i}=await l(new s(o,r),n,a);return e(a),i.flat()}function Q(e,t="far"){const r=g();let n;switch(t){case"far":if(n=Array.from(15===e.length?e.slice(3):e.slice(12)),x(r,n,!1))return{coefficients:r,vertexPositions:n};break;case"near":if(n=Array.from(e.slice(0,12)),15===e.length||!x(r,n,!1))return;return{coefficients:r,vertexPositions:n}}}const T=(e,t=!1)=>{if(t&&e-2<=4||e<=4||e%2!=0)throw new Error("Invalid number of vertices");const r=[],n=e/2,a=Math.round((t?e-2:e)/2);for(let o=0;o<a;o++){const a=o+n,i=t?a+1:a,c=i%e,s=(t?a:i+1)%e;r.push({faces:new Uint32Array([o,s,c,o,o+1,c])})}return r};function X(e,t=!1){if(e<3||t&&e-1<3)throw new Error("Invalid number of vertices");const r=[],n=t?e-2:e-1;for(let a=0;a<n;a++)r.push({faces:new Uint32Array([0,a+1,a+2])});return r}const Y=e=>e.map((e=>new h(e))),Z=e=>e.length/3;export{O as checkIfPolygonContainsSelectedPoint,U as computePolygonForInspection,A as createCoveragePolygon,F as limitZToGround,N as projectVertices,k as resizePolygon,L as updateFrustum};
