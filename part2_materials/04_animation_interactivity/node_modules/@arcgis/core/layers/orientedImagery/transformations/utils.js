/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import t from"../../../core/Error.js";import n from"../../../core/JSONSupport.js";import{deg2rad as a,rad2deg as i}from"../../../core/mathUtils.js";import{create as e}from"../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{create as o,fromValues as r}from"../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{fromArray as c}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{zeros as s}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{multiply as l,transpose as f}from"../../../core/libs/gl-matrix-2/math/mat3.js";import{invertOrIdentity as h,mul as u}from"../../../core/libs/gl-matrix-2/math/mat4.js";import{a as m,g as p}from"../../../chunks/vec32.js";import M from"../../../geometry/Point.js";import{projectWithZConversion as g}from"../../../geometry/projection.js";import{earth as v}from"../../../geometry/support/Ellipsoid.js";import{isWebMercator as d}from"../../../geometry/support/spatialReferenceUtils.js";import{a as x}from"../../../chunks/vec3.js";import{isElevationSource as w,isConstantElevation as y,ConstantElevation as O}from"../core/ElevationSourceDefinitions.js";import{getElevationSampler as b}from"./updateElevationUtils.js";import{isNumber as j}from"../../../support/guards.js";import{defaultImageSphereSize as E}from"../../../widgets/PanoramicViewer/constants.js";function S(t,n,a){const[i,e,r,c]=n,[s,l,f,m]=a;z(i,e,r,c);const p=z(s,l,f,m),M=V(i,e,r,c),g=V(s,l,f,m),v=h(o(),M),d=u(o(),v,g),[x,w,y,O]=P(t,d);return[x/O,w/O,p?0:y/O]}function z(t,n,a,i){return 0===t[2]&&0===n[2]&&0===a[2]&&0===i[2]&&(t[2]=n[2]=a[2]=i[2]=1,!0)}function F(t){return 0===t?1:t}function P(t,n){const[a,i,e]=t,o=[0,0,0,0];return o[0]=a*n[0]+i*n[1]+e*n[2]+n[3],o[1]=a*n[4]+i*n[5]+e*n[6]+n[7],o[2]=a*n[8]+i*n[9]+e*n[10]+n[11],o[3]=F(a*n[12]+i*n[13]+e*n[14]+n[15]),o}function V(t,n,a,i){const e=D(c([...i,1]),h(new Array(16),r(t[0],n[0],a[0],0,t[1],n[1],a[1],0,t[2],n[2],a[2],0,1,1,1,1))),s=e[0],l=e[1],f=e[2],u=o();return u[0]=s*t[0],u[1]=l*n[0],u[2]=f*a[0],u[3]=0,u[4]=s*t[1],u[5]=l*n[1],u[6]=f*a[1],u[7]=0,u[8]=s*t[2],u[9]=l*n[2],u[10]=f*a[2],u[11]=0,u[12]=s,u[13]=l,u[14]=f,u[15]=1,u}function C(t,n,a,i,e=s()){return e[0]=t[0]+n[0]*a,e[1]=t[1]+n[1]*a,e[2]=t[2]+n[2]*(a/i),e}function R(t,n,a){const i=s();return i[0]=t[0]*n,i[1]=t[1]*n,i[2]=t[2]*(n/a),i}function L(t,n){const[a,i,e]=t,o=s();return o[0]=a*n[0]+i*n[3]+e*n[6],o[1]=a*n[1]+i*n[4]+e*n[7],o[2]=a*n[2]+i*n[5]+e*n[8],o}function D(t,n){const[a,i,e,o]=t,r=new Array(4);return r[0]=a*n[0]+i*n[1]+e*n[2]+o*n[3],r[1]=a*n[4]+i*n[5]+e*n[6]+o*n[7],r[2]=a*n[8]+i*n[9]+e*n[10]+o*n[11],r[3]=a*n[12]+i*n[13]+e*n[14]+o*n[15],r}function I(n,i,o,r=!0){if(!Number.isFinite(n))throw new t("InvalidRotationAngle","Please specify a valid angle for rotation");const c=o*(r?a(n):n),s=Math.cos(c),l=Math.sin(c),f=e();switch(i){case 0:f[4]=s,f[5]=-l,f[7]=l,f[8]=s;break;case 1:f[0]=s,f[2]=l,f[6]=-l,f[8]=s;break;case 2:f[0]=s,f[1]=-l,f[3]=l,f[4]=s;break;default:throw new t("InvalidRotationAxis","Please specify either 0, 1 or 2 for X, Y or Z axis respectively")}return f}const N={HPR:[[2,-1],[0,1],[2,-1]],OPK:[[0,1],[1,1],[2,1]]};function H(n,a,i=!0){if(3!==n?.length||3!==a?.length)throw new t("InvalidRotationAngles","Please specify three angles with config for rotation");const o=e();for(let t=0;t<3;t++){const[e,r]=a[t],c=I(n[t],e,r,i);l(o,c,o)}return o}function q(t,n=!0){return H(t,N.OPK,n)}function k(t,n=!0){return H(t,N.HPR,n)}function A(t,n,i){const e=Math.sin(a(i)),o=Math.cos(a(i)),r=[[t,0],[t,n],[0,n]];r.forEach(((t,n)=>{r[n]=[o*t[0]-e*t[1],e*t[0]+o*t[1]]}));const c={xmin:Math.min(0,r[0][0],r[1][0],r[2][0]),xmax:Math.max(0,r[0][0],r[1][0],r[2][0]),ymin:Math.min(0,r[0][1],r[1][1],r[2][1]),ymax:Math.max(0,r[0][1],r[1][1],r[2][1])};return{hfov:Math.abs(c.xmax-c.xmin),vfov:Math.abs(c.ymax-c.ymin)}}function K(t,n){const i=a(t[1]),e=a(t[0]),o=t[2],[r,c,s,l]=n,f=a(r),h=a(c),u=s/Math.sqrt(1-l*Math.sin(f)**2),m=e-h,p=s/Math.sqrt(1-l*Math.sin(f)**2),M=l*(u*Math.sin(f)-p*Math.sin(i));return[(p+o)*Math.cos(i)*Math.sin(m),(p+o)*(Math.sin(i)*Math.cos(f)-Math.sin(f)*Math.cos(f)*Math.cos(m))+M*Math.cos(f),(p+o)*(Math.sin(i)*Math.sin(f)+Math.cos(f)*Math.cos(i)*Math.cos(m))-u+M*Math.sin(f)]}function W(t,n){const e=Number(t[0]),o=Number(t[1]),r=Number(t[2]),[c,s,l,f]=n,h=a(c),u=a(s),m=l/Math.sqrt(1-f*Math.sin(h)**2),p=e/m,M=o/m,g=r/m,v=Math.cos(h)-Math.sin(h)*M+Math.cos(h)*g,d=Math.sin(h)+Math.cos(h)*M+Math.sin(h)*g,x=Math.sqrt(v**2+p**2),w=f*m*Math.sin(h),y=(t,n=5)=>{if(0===n)return t;const a=y(t,n-1);return Math.atan(d/x-(w-f*(l/Math.sqrt(1-f*Math.sin(a)**2))*Math.sin(a))/(m*x))},O=y(h),b=Math.atan(e/(m*v))+u,j=i(O);return[i(b),j,e/(Math.cos(O)*Math.sin(b-u))-l/Math.sqrt(1-f*Math.sin(O)**2)]}function U(t,n,a){const i=360/n,e=180/a;return{heading:(t.x-n/2)*i,pitch:90-(t.y-a/2)*e}}function T(t,n,a,i=E/2){const{heading:e,pitch:o}=X(t,i);return J(e,o,n,a)}function J(t,n,a,i){return{x:a/2+t/(360/a),y:i-n/(180/i),heading:t,pitch:n}}function X(t,n){const a=i(Math.acos(-t.z/n));return{heading:i(Math.atan2(t.x,t.y)),pitch:a}}function Y(t,n,i=E/2){return[i*(Math.sin(a(t))*Math.sin(a(n))),i*(Math.cos(a(t))*Math.sin(a(n))),i*Math.cos(a(180-n))]}async function Z(t,n,a){const e=await g(n,t.spatialReference,a);let o=i(Math.atan2(e.y-t.y,e.x-t.x));return o=o>=0&&o<=90?90-o:o>90&&o<=180?360-o+90:90+Math.abs(o),o}function $(t,n,a){const i=Math.cos(a),e=Math.sin(a),o=[1,0,0,1,0,0],r=o[0]*i+o[2]*e,c=o[1]*i+o[3]*e,s=-o[0]*e+o[2]*i,l=-o[1]*e+o[3]*i;o[0]=r,o[1]=c,o[2]=s,o[3]=l;return[t*o[0]+n*o[2]+o[4],t*o[1]+n*o[3]+o[5]]}const B=t=>t.toArray(),G=(...t)=>t.some((t=>t));function Q(t,n){if(G(0===t.length,t.some((({x:t,y:n})=>G(null==t,null==n))),!n.hasZ))throw new Error("Input pixels must have x, y and camera location must have z value")}function _(t,n){if(t.some((t=>null==t.z))||null==n.z)throw new Error("Input points and camera location must have z value")}function tt(t){if(9!==t?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix")}function nt(t,n){return d(n)?1/Math.cos(Math.PI/2-2*Math.atan(Math.exp(-1*t/v.radius))):1}const at=t=>n=>new M(n,t),it=t=>null!=t&&"queryExtent"in t;function et(t,n,a,i){return[[-n,-n],[+n,-n],[+n,+n],[-n,+n]].map((([n,e])=>S(x(s(),a,[n,e,0]),i,t)))}function ot({a0:t,a1:n,a2:a,b0:i,b1:e,b2:o},r,c,s){const l=[t??r/2-.5,n,a??0,i??c/2-.5,e??0,o].map(rt);return null!=s&&ct(l)?{affines:l,focalLength:s}:{affines:[r/2-.5,1,0,c/2-.5,0,-1]}}function rt(t,n){if(null==t)return null;const a=parseFloat(`${t}`);return isNaN(a)?null:a}function ct(t){return null!=t[1]&&null!=t[5]}function st(t,n,a){const{cameraHeight:i,cameraPitch:e,cameraRoll:o,elevation:r,farDistance:c,horizontalFieldOfView:s,location:l,verticalFieldOfView:f}=t,h=r??(l.z??0)-i;return{...ht(t,n,a),averageElevation:h,cameraPitch:e,cameraRoll:o??0,farDistance:c,horizontalFieldOfView:s,verticalFieldOfView:f}}function lt(t,n,a,i){return xt(i)?q([i.omega,i.phi,i.kappa]):wt(i)?k([i.heading,i.pitch,i.roll]):k([t,n,a??0])}function ft(t,n,a){const{cameraHeading:i,cameraHeight:e,elevation:o,farDistance:r,horizontalFieldOfView:c,location:s,verticalFieldOfView:l}=t;return{averageElevation:o??(s.z??0)-e,cameraLocation:s,cameraHeading:i,farDistance:r,horizontalFieldOfView:c,imageHeight:a,imageWidth:n,verticalFieldOfView:l}}function ht(t,n,a){const{a0:i,a1:e,a2:o,b0:r,b1:c,b2:s,cameraHeading:l,cameraOrientation:f,cameraPitch:h,cameraRoll:u,focalLength:m,horizontalFieldOfView:p,location:M,matrix:g,principalX:v,principalY:d,radial:x,tangential:w,verticalFieldOfView:y}=t,{affines:O,focalLength:b}=ot({a0:i,a1:e,a2:o,b0:r,b1:c,b2:s},n,a,m),j=g??lt(l,h,u,f),E=null!=v&&null!=d?[v,d]:void 0;return{affineTransformations:f?.affineTransformations??O,cameraLocation:M.clone(),focalLength:f?.focalLength??b,horizontalFieldOfView:p,imageHeight:a,imageWidth:n,principalOffsetPoint:f?.principalOffsetPoint??E,radialDistortionCoefficients:f?.radialDistortionCoefficients??x,rotationMatrix:j,tangentialDistortionCoefficients:f?.tangentialDistortionCoefficients??w,verticalFieldOfView:y}}const ut=t=>null!=t&&"elevationSample"in t&&null!=t.elevationSample,mt=t=>w(t?.elevationSource)&&null!=t?.extent,pt=t=>y(t?.elevationSource),Mt=async(t,a)=>null!=a&&(ut(a)||pt(a))?a:mt(a)?{elevationSample:await b({...n.isSerializable(a.elevationSource)?a.elevationSource.toJSON():a.elevationSource,extent:a.extent}),elevationSource:new O({constantElevation:t})}:{elevationSource:new O({constantElevation:t})},gt=t=>j(t?.heading)&&j(t?.pitch),vt=(t,n)=>[[-t,-n],[t,-n],[t,n],[-t,n]];function dt(t){const{cameraLocation:n,farDistance:i,horizontalFieldOfView:o,rotationMatrix:r,scalingFactor:c,verticalFieldOfView:l}=t,h=e();f(h,r);const u=2*Math.tan(a(l)/2)*i*c,M=2*Math.tan(a(o)/2)*i*c,g=L([0,0,-1],h),v=C([n.x,n.y,n.z],g,t.farDistance*c,c),d=L([0,1,0],h),x=L([1,0,0],h),w=R(d,u/2,c),y=R(x,M/2,c),O=m(s(),w,y),b=p(s(),w,y);return[p(s(),v,O),p(s(),v,b),m(s(),v,O),m(s(),v,b)]}const xt=t=>2===t?.type,wt=t=>1===t?.type;function yt(t){const n=t%360;return n<-180?n+360:n}function Ot(t,n,a){if("panoramic"===t){const[t,i]=a;return T({x:n.x,y:n.y,z:n.z},t,i)}return{x:n.x+.5,y:.5-n.y}}var bt;!function(t){t[t.CLOCKWISE=-1]="CLOCKWISE",t[t.COUNTERCLOCKWISE=1]="COUNTERCLOCKWISE"}(bt||(bt={}));export{dt as computeFarplaneVertices,A as computeHFOVAndVFOV,et as computeNewReferenceCoordinates,Y as convertHeadingPitchToSphereVertex,J as convertOrientationToPixelLocation,U as convertPixelToHeadingPitch,X as convertSphereVertexToOrientation,T as convertSphereVertexToPixelLocation,H as createRotationMatrix,k as createRotationMatrixFromHPR,q as createRotationMatrixFromOPK,K as geographicToLTP,ot as getAffinesAndFocalLength,ft as getImageToWorldPanoramicProperties,st as getImageToWorldProperties,Z as getInitialAngle,Mt as getUpdateElevationProps,nt as getWebMercatorScalingFactor,ht as getWorldToImageProperties,gt as hasAngles,wt as hasHeadingPitchRoll,xt as hasOmegaPhiKappa,it as isElevationSampler,ut as isUpdateElevationWithElevationSampler,mt as isUpdateElevationWithElevationSource,pt as isUpdateUsingConstantElevation,ct as isValidAffines,V as linearEquationSolve,W as ltpToGeographic,yt as normalizeHeading,G as or,B as pointToArray,S as projectiveTransform,vt as reducerFn,$ as rotatePixel,C as scaleAndAddWithFactor,R as scaleWithFactor,Ot as transformGraphicCoordinatesToPixel,L as transformMat3,D as transformMat4,Q as validatePixelsToTransform,_ as validatePointsToTransform,tt as validateRotationMatrix,at as vecToPoint};
