/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{deepClone as e}from"../../../arcade/deepClone.js";import"../../../core/Error.js";import"../../../core/has.js";import"../../../core/Logger.js";import{create as t}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import r from"../../../geometry/Point.js";import a from"../../../geometry/Polygon.js";import{fromPoints as n,intersectLine as o}from"../../../geometry/support/plane.js";import i from"./updateElevation.js";import{pointToArray as c,or as s}from"./utils.js";import{worldToImage as p,worldToImagePanoramic as f}from"./worldToImage.js";async function m(e,a,i,p=h){const{cameraLocation:f,farPlaneVertices:m}=i,l=c(f),w=new Array;await u(m,i,w);let b=n(w[0],w[1],w[2]),j=e.clone();for(let h=0;h<p;h++){const p=t();if(!o(b,l,c(e),p))break;let m=0,h=null;if(({error:m,imagePoint:h,pointWithZ:j}=await y(a,new r(p,f.spatialReference),i)),m<=1)break;const[u,d]=g(f.spatialReference,w);if(s(u<=1,d<=1))break;w.splice(0,w.length,...await x(u,d,new r(p,f.spatialReference),i)),b=n(w[0],w[1],w[2])}return c(j)}async function l(e,a,i,p=h){const{cameraLocation:f,farPlaneVertices:m}=i,l=c(f),w=new Array;await u(m,i,w);let y=n(w[0],w[1],w[2]),j=e.clone();for(let h=0;h<p;h++){const p=t();if(!o(y,l,c(e),p))break;let m,h=0;if(({error:h,imagePoint:m,pointWithZ:j}=await b(a,new r(p,f.spatialReference),i)),h<=1)break;const[u,d]=g(f.spatialReference,w);if(s(u<=1,d<=1))break;w.splice(0,w.length,...await x(u,d,new r(p,f.spatialReference),i)),y=n(w[0],w[1],w[2])}return c(j)}const h=10,w=10;function g(e,t){const r=new a({spatialReference:e});r.addRing(t);return[r.extent?.width?r.extent.width/w:1,r.extent?.height?r.extent.height/w:1]}async function u(t,r,a){const n=e(t),o=await i(n,r);a.push(...o.map(c))}async function y(e,t,r){const a=await i(t,r),n=p(a,r);return{error:j(n,e),imagePoint:n,pointWithZ:a}}async function b(e,t,r){const a=await i(t,r),n=f(a,r);return{error:d(n,e),imagePoint:n,pointWithZ:a}}const j=(e,t)=>Math.abs(e.x-t.x)+Math.abs(e.y-t.y),d=(e,t)=>Math.abs(e.heading-t.heading)+Math.abs(e.pitch-t.pitch);async function x(e,t,a,n){const o=[[-e,-t],[e,-t],[e,t],[-e,t]].map((([e,t])=>new r([a.x+e,a.y+t],a.spatialReference)));return i(o,n).then((e=>e.map((e=>e.toArray()))))}export{m as rectifyMapPoint,l as rectifyMapPointPanoramic};
