/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{rad2deg as t,deg2rad as a}from"../../../core/mathUtils.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{a as o,j as n}from"../../../chunks/vec32.js";import{webMercatorToGeographic as e}from"../../../geometry/support/webMercatorUtils.js";import{normalizeHeading as i,convertOrientationToPixelLocation as c,validatePointsToTransform as s,validateRotationMatrix as f,getWebMercatorScalingFactor as m}from"./utils.js";function l(t,a){const{cameraLocation:r,pointsToTransform:o,scalingFactor:n}=g(t,a.cameraLocation,a.rotationMatrix),e=new Array;return p(o,e,{...a,cameraLocation:r,scalingFactor:n,...T(a)}),Array.isArray(t)?e:e[0]}function u(t,a,r){return l(t?a.map((t=>e(t))):a,r).map((t=>({...t,z:1})))}function p(t,a,n){const{affineTransformations:e,cameraLocation:i,focalLengthX:c,focalLengthY:s,principalOffsetPoint:f,radialDistortionCoefficients:m,rotationMatrix:l,scalingFactor:u,tangentialDistortionCoefficients:p}=n;for(const h of t){const t=r();o(t,h,i),t[0]=t[0]/u,t[1]=t[1]/u;const n=-c*((l[0]*t[0]+l[3]*t[1]+l[6]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),g=-s*((l[1]*t[0]+l[4]*t[1]+l[7]*t[2])/(l[2]*t[0]+l[5]*t[1]+l[8]*t[2])),y=n*n+g*g;let L=0,A=0,T=0,b=0,d=0,w=0,M=0;m&&(L=m[0]??0,A=m[1]??0,T=m[2]??0),p&&(b=p[0],d=p[1]),f&&(w=f[0]??0,M=f[1]??0);const j=1+L*y+A*y*y+T*y*y*y;let F=n*j+b*(y+2*n**2)+2*d*n*g,N=g*j+d*(y+2*g**2)+2*b*n*g;F+=w,N+=M;const x=Number(e[0])+Number(e[1])*F+Number(e[2])*N,v=Number(e[3])+Number(e[4])*F+Number(e[5])*N;a.push({x,y:v})}}function h(a,r){const{cameraHeading:o,imageHeight:e,imageWidth:s}=r,{cameraLocation:f,pointsToTransform:m}=y(a,r.cameraLocation),l=new Array;for(const u of m){const a=n(f,u),r=i(t(Math.atan2(u[0]-f[0],u[1]-f[1]))-o),m=t(Math.acos((f[2]-u[2])/a));l.push(c(r,m,s,e))}return Array.isArray(a)?l:l[0]}function g(t,a,r){const o=Array.isArray(t)||"items"in t?t:[t];s(o,a),L(o,a),f(r);const n=m(a.y,a.spatialReference);return{pointsToTransform:o.map((t=>t.toArray())),scalingFactor:n,cameraLocation:a.toArray()}}function y(t,a){const r=Array.isArray(t)||"items"in t?t:[t];return s(r,a),L(r,a),{pointsToTransform:r.map((t=>t.toArray())),cameraLocation:a.toArray()}}function L(t,a){if(t.some((t=>!t.spatialReference.equals(a.spatialReference))))throw new Error("Input points and camera location must have the same spatial reference")}function A(t){return null!=t?.focalLength}function T(t){if(A(t))return{focalLengthX:t.focalLength,focalLengthY:t.focalLength};const{imageWidth:r,imageHeight:o,horizontalFieldOfView:n,verticalFieldOfView:e}=t;return{focalLengthX:r/(2*Math.tan(a(n)/2)),focalLengthY:o/(2*Math.tan(a(e)/2))}}export{l as worldToImage,h as worldToImagePanoramic,u as worldToImageWithLTPFlag};
