/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../geometry/Point.js";import t from"./EphemeralBlockCache.js";import{projectExtent as n,projectResolution as o,snapPyramid as l}from"../rasterFunctions/rasterProjectionHelper.js";const r=new Map,c=new t;function i(e,t){return null==t?e:`${e}?sliceId=${t}`}function u(e,t){const n={extent:null,rasterInfo:t,cache:new Map},o=r.get(e);return o?(o.push(n),o.length-1):(r.set(e,[n]),0)}function a(e,t){const n=r.get(e);n&&(n[t]=null,n.some((e=>null!=e))||r.delete(e))}function f(e){r.delete(e)}function s(e,t,n){const o=r.get(e);if(!o)return null==t?c.decreaseRefCount(e,n):0;if(null==t||null==o[t])return c.decreaseRefCount(e,n);const l=o[t]?.cache,i=l?.get(n);if(l&&i){if(i.refCount--,0===i.refCount){l.delete(n);for(let e=0;e<o.length;e++)o[e]?.cache.delete(n);i.controller&&i.controller.abort()}return i.refCount}return 0}function m(e,t,n){const o=r.get(e);if(!o)return null==t?c.getBlock(e,n):null;if(null==t||null==o[t]){for(let e=0;e<o.length;e++){const t=o[e]?.cache.get(n);if(t)return t.refCount++,t.block}return c.getBlock(e,n)}const l=o[t]?.cache.get(n);if(l)return l.refCount++,l.block;for(let r=0;r<o.length;r++){if(r===t||!o[r])continue;const e=o[r]?.cache,l=e?.get(n);if(e&&l)return l.refCount++,e.set(n,l),l.block}return null}function h(e,t,n,o,l=null){const i=r.get(e);if(!i)return void(null==t&&c.putBlock(e,n,o,l));if(null==t||null==i[t])return void c.putBlock(e,n,o,l);const u={refCount:1,block:o,isResolved:!1,isRejected:!1,controller:l};o.then((()=>u.isResolved=!0)).catch((()=>u.isRejected=!0)),i[t]?.cache.set(n,u)}function x(e,t,n){const o=r.get(e);o?null!=t&&null!=o[t]?o[t]?.cache.delete(n):c.deleteBlock(e,n):null==t&&c.deleteBlock(e,n)}function d(e,t){const n=r.get(e);return n?n[t]??null:null}function g(t,r,c,i,u,a,f=null){const s=d(t,r);if(!s)return;const m=s.extent,{cache:h,rasterInfo:x}=s;if(m&&m.xmin===c.xmin&&m.xmax===c.xmax&&m.ymin===c.ymin&&m.ymax===c.ymax)return;i=i??0;const g=c.clone().normalize(),{spatialReference:y,transform:p}=x,k=new Set;for(let d=0;d<g.length;d++){const t=g[d];if(t.xmax-t.xmin<=i||t.ymax-t.ymin<=i)continue;let r=n(t,y,f);null!=p&&(r=p.inverseTransform(r));const c=new e({x:i,y:i,spatialReference:t.spatialReference});if(null==u&&!(u=o(c,y,t,f)))return;const{pyramidLevel:s,pyramidResolution:m,excessiveReading:h}=l(u,x,a||"closest");if(h)return;const{storageInfo:M}=x,{origin:R}=M,{x:C,y:B}=m,b=Math.max(0,Math.floor((r.xmin-R.x)/C)),v=Math.max(0,Math.floor((R.y-r.ymax)/B)),w=Math.ceil(r.width/C-.1),j=Math.ceil(r.height/B-.1),$=s>0?M.pyramidBlockWidth:M.blockWidth,I=s>0?M.pyramidBlockHeight:M.blockHeight,H=M.blockBoundary[s];if(!H)continue;const E=1,P=Math.max(H.minCol,Math.floor(b/$)-E),W=Math.max(H.minRow,Math.floor(v/I)-E),z=Math.min(H.maxCol,Math.floor((b+w-1)/$)+E),F=Math.min(H.maxRow,Math.floor((v+j-1)/I)+E);for(let e=W;e<=F;e++)for(let t=P;t<=z;t++)k.add(`${s}/${e}/${t}`)}h.forEach(((e,t)=>{if(!k.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),s.extent={xmin:c.xmin,ymin:c.ymin,xmax:c.xmax,ymax:c.ymax}}export{s as decreaseRefCount,x as deleteBlock,f as deleteRaster,m as getBlock,i as getRasterId,h as putBlock,u as register,a as unregister,g as update};
