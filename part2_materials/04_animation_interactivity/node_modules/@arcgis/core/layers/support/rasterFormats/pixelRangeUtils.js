/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
const t=9999999e31,n=2e-7,e={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function s(t){return e[t]??[-34028234663852886e22,34028234663852886e22]}function l(t,n){return null==t||null==n?"s32":t<0?t>=-128&&n<128?"s8":t>=-32768&&n<32768?"s16":"s32":n<256?"u8":n<65536?"u16":"u32"}function o(t){return(t?.startsWith("s")||t?.startsWith("u"))??!1}function u(t,n,e,l){let[u,i]=s(e);const a=o(e);return a&&(u-=1e-5,i+=1e-5),a?e.startsWith("u")?r(t,n,l,[u,i]):c(t,n,l,[u,i]):f(t,n,l,[u,i])}function i(t,n){for(let e=0;e<n.length;e++)n[e]&&isNaN(t[e])&&(n[e]=0,t[e]=0)}function r(t,n,e,s){const[l,o]=s;for(let u=0;u<n.length;u++)if(n[u]){const s=t[u];s<l||s>o?n[u]=0:e[u]=s+.5|0}}function c(t,n,e,s){const[l,o]=s;for(let u=0;u<n.length;u++)if(n[u]){const s=t[u];s<l||s>o?n[u]=0:e[u]=s+(s>0?.5:-.5)|0}}function f(t,n,e,s){const[l,o]=s;for(let u=0;u<n.length;u++)if(n[u]){const s=t[u];s<l||s>o?n[u]=0:e[u]=s}}function a(e,l,o){if(e.depthCount&&e.depthCount>1)return;const{pixels:u,statistics:i,pixelType:r}=e,c=u[0].length,f=e.bandMasks??[],a=e.mask??new Uint8Array(c).fill(255),h="f32"===r||"f64"===r,g=s(r);let m=!1;for(let s=0;s<u.length;s++){const e="number"==typeof l?l:l[s];if(null==e)continue;const c=i?.[s]?.minValue??g[0],b=i?.[s]?.maxValue??g[1];if(c>e+Number.EPSILON||b<e-Number.EPSILON)continue;const N=f[s]||a.slice(),d=u[s],p=o?.customFloatTolerance;if(h&&0!==p){let s=p;s||(s=Math.abs(e)>=t?n*Math.abs(e):"f32"===r?2**-23:Number.EPSILON);for(let t=0;t<d.length;t++)N[t]&&Math.abs(d[t]-e)<s&&(d[t]=0,N[t]=0,a[t]=0,m=!0)}else for(let t=0;t<d.length;t++)N[t]&&d[t]===e&&(d[t]=0,N[t]=0,a[t]=0,m=!0);f[s]=N}if(m){const t=e.bandMasks||e.pixels.length>1?f:null;o?.matchAllNoData?e.mask=t&&t.length>1?b(t):a:(e.bandMasks=t,e.mask=a)}function b(t){if(t.length<2)return t[0];const n=t[0].length,e=new Uint8Array(n).fill(0);for(let s=0;s<t.length;s++){const l=t[s];for(let t=0;t<n;t++)l[t]&&(e[t]=255)}return e}m&&"updateStatistics"in e&&e.updateStatistics()}export{u as clipBandToPixelTypeRange,a as convertNoDataToMask,i as fixNaN,l as getIntegerPixelType,s as getPixelValueRange,o as isIntegerPixelType};
