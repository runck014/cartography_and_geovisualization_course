/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{clone as e}from"../../../core/lang.js";import{millisecondsPerTimeUnit as t}from"../../../core/timeUtils.js";import{polygonCentroid as i,extentCentroid as s}from"../../../geometry/support/centroid.js";import{getPolygonExtent as a,getGeometryExtent as r}from"../../../geometry/support/extentUtils.js";import{toQuantizationTransform as n}from"../../../geometry/support/quantizationUtils.js";import{isValid as o,equals as l}from"../../../geometry/support/spatialReferenceUtils.js";import u from"./AttributesBuilder.js";import{cleanFromGeometryEngine as c,getGeometry as m,transformCentroid as d}from"./geometryUtils.js";import{project as h}from"./projectionSupport.js";import{getDateInNumber as p}from"./queryUtils.js";import{makeEdgeCandidate as f,makeVertexCandidate as y}from"./SnappingCandidate.js";import{isDateField as g,isDateOnlyField as x,isTimestampOffsetField as I,isStringField as T,isTimeOnlyField as F}from"../../support/fieldUtils.js";import _ from"../../../rest/support/AutoIntervalBinParameters.js";import V from"../../../rest/support/DateBinParameters.js";import v from"../../../rest/support/FixedBoundariesBinParameters.js";import b from"../../../rest/support/FixedIntervalBinParameters.js";import{isNullCountSupported as S,calculateStringStatistics as R,calculateStatistics as B,processSummaryStatisticsResult as z,calculateUniqueValuesCount as A,createUVResult as w,calculateClassBreaks as M,resolveCBResult as D,calculateHistogram as P,getAttributeComparator as q,calculatePercentile as N,binIndex as Z,getBinParams as j}from"../../../statistics/utils.js";const G="bin";class C{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new u(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!!!a)return 1;const r=new Map,n=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,a="exceedslimit"!==s?l.onStatisticField:void 0;if(!n.has(a)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,this.items,r);i.push(t)}n.set(a,this._calculateUniqueValues(i,this.items,e.returnDistinctValues))}const u=n.get(a);for(const t in u){const{data:s,items:a}=u[t],r=s.join(",");i&&!e.validateItems(a,i)||o.add(r)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items)}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;o(this.query.outSR)&&!l(t.spatialReference,this.query.outSR)?e.queryGeometry=c({spatialReference:this.query.outSR,...h(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=c({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t){const i=this.featureAdapter,s=O(this.hasZ,this.hasM),{point:a,mode:r}=e,n="number"==typeof e.distance?e.distance:e.distance.x,o="number"==typeof e.distance?e.distance:e.distance.y,l={candidates:[]},u="esriGeometryPolygon"===this.geometryType,c="esriGeometryPolyline"===this.geometryType,m=this._getPointCreator(r,this.spatialReference,t),d=new H(null,0),h=new H(null,0),p={x:0,y:0,z:0};for(const g of this.items){const t=i.getGeometry(g);if(null==t)continue;const{coords:r}=t,x=t.isPoint?Q:t.lengths;if(d.coords=r,h.coords=r,e.returnEdge){let e=0;for(let t=0;t<x.length;t++){const r=x[t],c=e;for(let t=0;t<r;t++,e+=s){if(!u&&t===r-1)continue;const y=d;y.coordsIndex=e;const x=h;x.coordsIndex=t===r-1?c:e+s;const I=p;if(!E(p,a,y,x))continue;const T=(a.x-I.x)/n,F=(a.y-I.y)/o,_=T*T+F*F;_<=1&&l.candidates.push(f(i.getObjectId(g),m(I),Math.sqrt(_),m(y),m(x)))}}}if("all"===e.vertexMode){let e=0;for(let t=0;t<x.length;t++){const r=x[t],c=e,p=h;p.coordsIndex=c;for(let t=0;t<r;t++,e+=s){const s=d;if(s.coordsIndex=e,u&&t===r-1&&s.x===p.x&&s.y===p.y)continue;const c=(a.x-s.x)/n,h=(a.y-s.y)/o,f=c*c+h*h;f<=1&&l.candidates.push(y(i.getObjectId(g),m(s),Math.sqrt(f)))}}}else if(c&&"ends"===e.vertexMode){let e=0;const t=[];for(let i=0;i<x.length;i++){t.push(e);const a=x[i];e+=a*s,!u&&a>1&&t.push(e-s)}for(const s of t){const e=d;e.coordsIndex=s;const t=(a.x-e.x)/n,r=(a.y-e.y)/o,u=t*t+r*r;u<=1&&l.candidates.push(y(i.getObjectId(g),m(e),Math.sqrt(u)))}}}return l.candidates.sort(((e,t)=>e.distance-t.distance)),l}_getPointCreator(e,t,i){const s=null==i||l(t,i)?e=>e:e=>h(e,t,i),{hasZ:a}=this,r=0;return"3d"===e?a?({x:e,y:t,z:i})=>s({x:e,y:t,z:i}):({x:e,y:t})=>s({x:e,y:t,z:r}):({x:e,y:t})=>s({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l,timeZone:u,outStatisticTypes:c}=e,m=this.fieldsIndex.get(t),d=g(m)||x(m)||I(m),h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l,timeZone:u},this.items),p=S({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),f={value:.5,fieldType:m?.type},y=T(m)?R({values:h,supportsNullCount:p,percentileParams:f,outStatisticTypes:c}):B({values:h,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:p,percentileParams:f,outStatisticTypes:c});return z(y,c,d)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:n}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:n},this.items,!1),l=A(o);return w(l,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m,timeZone:d},this.items),p=M(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return D(p,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m,timeZone:d},this.items);return P(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=!!t[1]&&"desc"===t[1].toLowerCase(),o=q(r?.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}))}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:m,resultRecordCount:d,resultOffset:h,returnZ:p,returnM:f}=e,y=null!=d&&t.length>(h||0)+d,g=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:g,geometryType:i,hasM:s&&f,hasZ:a&&p,objectIdFieldName:r,spatialReference:c(u||o),transform:m&&n(m)||null}}_createFeatures(e,t){const i=new u(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:c,maxAllowableOffset:h,resultOffset:p,resultRecordCount:f,returnZ:y=!1,returnM:g=!1}=e,x=a&&y,I=s&&g;let T=[],F=0;const _=[...t];if(this._sortFeatures(_,r,((e,t,s)=>i.getFieldValue(e,t,s))),this.geometryType&&(l||c)){const e=n(o)??void 0,t="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(l&&!c)for(const s of _){const a=this.featureAdapter.getGeometry(s),r={attributes:i.getAttributes(s),geometry:m(this.geometryType,this.hasZ,this.hasM,a,h,e,x,I)};t&&a&&!r.geometry&&(r.centroid=d(this,this.featureAdapter.getCentroid(s,this),e)),T[F++]=r}else if(!l&&c)for(const s of _)T[F++]={attributes:i.getAttributes(s),centroid:d(this,this.featureAdapter.getCentroid(s,this),e)};else for(const s of _)T[F++]={attributes:i.getAttributes(s),centroid:d(this,this.featureAdapter.getCentroid(s,this),e),geometry:m(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(s),h,e,x,I)}}else for(const n of _){const e=i.getAttributes(n);e&&(T[F++]={attributes:e})}const V=p||0;if(null!=f){const e=V+f;T=T.slice(V,Math.min(T.length,e))}return T}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if("exceedslimit"===a.statisticType){t=null!=a.maxPointCount?a.maxPointCount:Number.POSITIVE_INFINITY,i=null!=a.maxRecordCount?a.maxRecordCount:Number.POSITIVE_INFINITY,s=null!=a.maxVertexCount?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)e=this.items.length>t;else if(this.items.length>i)e=!0;else{const t=O(this.hasZ,this.hasM),i=this.featureAdapter;e=this.items.reduce(((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)}),0)/t>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],a=new Map,r=new Map,n=new Map,o=new Map,l=new u(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:m,having:d,orderByFields:h,resultRecordCount:p}=e,f=m?.length,y=!!f,g=y?m[0]:null,x=y&&!this.fieldsIndex.get(g);for(const u of c??[]){const{outStatisticFieldName:e,statisticType:c}=u,h=u,p="exceedslimit"!==c?u.onStatisticField:void 0,I="percentile_disc"===c||"percentile_cont"===c,F="EnvelopeAggregate"===c||"CentroidAggregate"===c||"ConvexHullAggregate"===c,_=y&&1===f&&(p===g||x)&&"count"===c;if(y){if(!n.has(p)){const e=[];for(const i of m){const s=this._getAttributeValues(l,i,t,a);e.push(s)}n.set(p,this._calculateUniqueValues(e,t,!F&&l.returnDistinctValues))}const i=n.get(p);if(!i)continue;const s=Object.keys(i);for(const r of s){const{count:s,data:n,items:u,itemPositions:c}=i[r],f=n.join(",");if(!d||l.validateItems(u,d)){const i=o.get(f)||{attributes:{}};if(F){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:t}=await this._getAggregateGeometry(h,u);i.aggregateGeometries[t]=e}else{let r=null;if(_)r=s;else{const e=this._getAttributeValues(l,p,t,a),i=c.map((t=>e[t]));r=I&&"statisticParameters"in h?this._getPercentileValue(h,i):this._getStatisticValue(h,i,null,l.returnDistinctValues)}i.attributes[e]=r}let r=0;m.forEach(((e,t)=>i.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++r]=n[t])),o.set(f,i)}}}else if(F){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(h,t);i.aggregateGeometries[s]=e}else{const s=this._getAttributeValues(l,p,t,a);i.attributes[e]=I&&"statisticParameters"in h?this._getPercentileValue(h,s):this._getStatisticValue(h,s,r,l.returnDistinctValues)}const V="min"!==c&&"max"!==c||!T(this.fieldsIndex.get(p))&&!this._isAnyDateField(p)?null:this.fieldsIndex.get(p)?.type;s.push({name:e,alias:e,type:V||"esriFieldTypeDouble"})}const I=y?Array.from(o.values()):[i];return this._sortFeatures(I,h,((e,t)=>e.attributes[t])),p&&(I.length=Math.min(p,I.length)),{fields:s,features:I}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return g(t)||x(t)||I(t)||F(t)}async _getAggregateGeometry(e,t){const{convexHull:n,union:o}=await import("../../../geometry/geometryEngineJSON.js"),{statisticType:l,outStatisticFieldName:u}=e,{featureAdapter:c,spatialReference:d,geometryType:h,hasZ:p,hasM:f}=this,y=t.map((e=>m(h,p,f,c.getGeometry(e)))),g=n(d,y,!0)[0],x={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===l){const e=g?a(g):r(o(d,y));x.aggregateGeometries={...e,spatialReference:d},x.outStatisticFieldName=u||"extent"}else if("CentroidAggregate"===l){const e=g?i(g):s(r(o(d,y)));x.aggregateGeometries={x:e[0],y:e[1],spatialReference:d},x.outStatisticFieldName=u||"centroid"}else"ConvexHullAggregate"===l&&(x.aggregateGeometries=g,x.outStatisticFieldName=u||"convexHull");return x}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=i?.has(a)?i.get(a):T(this.fieldsIndex.get(a))||this._isAnyDateField(a)?R({values:t,returnDistinct:s}):B({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return N(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),r=i.map((i=>e.getFieldValue(i,t,a)));return s.set(t,r),r}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let r=0;r<a;r++){const a=t[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");null==s[o]?s[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i||s[o].count++,s[o].items.push(a),s[o].itemPositions.push(r))}return s}async _getDataValues(t,i,s=!0){const a=new u(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:r,scale:n,timeZone:o}=t;return r?a.getExpressionValues(i,r,{viewingMode:"map",scale:n,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},o):a.getDataValues(i,e(t),s)}async _calculateHistogramBins(e,t,i){if(null==t.min&&null==t.max)return[];const s=t.intervals,a=t.min??0,r=t.max??0,n=s.map((([e,t])=>({minValue:e,maxValue:t,count:0,items:[]})));for(let o=0;o<e.length;o++){const t=e[o],l=i[o];if(null!=t&&t>=a&&t<=r){const e=Z(s,t);e>-1&&(n[e].count++,n[e].items.push(l))}}return n}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,r=[],n=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:G,alias:G,type:"esriFieldTypeInteger"}],o=new u(e,this.featureAdapter,this.fieldsIndex),l=new Map,c=[...this.items];this._sortFeatures(c,[i],((e,t,i)=>o.getFieldValue(e,t,i)));const m=this._getAttributeValues(o,i,c,l),d=this._calculateUniqueValues([m],c,o.returnDistinctValues);for(const u in d){const{items:t}=d[u],a=await this._createBinsResponse(e,t);if(r.push(...a.features.map((e=>({...e,attributes:{...e.attributes,[s??i]:u}})))),a.fields)for(const e of a.fields)n.some((t=>t.name===e.name))||n.push(e)}return{fields:n,features:r}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(_.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(V.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(v.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(b.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:a,numBins:r,normalizationType:n,normalizationTotal:o,start:l,end:u}=e,c=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),m=j(c,{field:s,normalizationField:a,normalizationType:n,normalizationTotal:o,numBins:r,minValue:p(l,!1),maxValue:p(u,!1)}),d=await this._calculateHistogramBins(c,m,i);return this._createFeaturesFromHistogramBins(d,t)}async _createDateBinsResponse(e,i,s){const{field:a,interval:r,start:n,end:o}=e,l=r.unit,u="quarters"===l?3*t.months:t[l],c=r.value*u/t.milliseconds,m=await this._getDataValues({field:e.field,timeZone:i.outTimeReference?.ianaTimeZone},s),d=F(this.fieldsIndex.get(a)),h=j(m,{field:a,classificationMethod:"defined-interval",definedInterval:c,minValue:p(n,d),maxValue:p(o,d)},!0),f=await this._calculateHistogramBins(m,h,s);return this._createFeaturesFromHistogramBins(f,i)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),r=F(this.fieldsIndex.get(s)),n=e.boundaries.map((e=>p(e,r))).sort(((e,t)=>e-t)),o=[];for(let c=0;c<n.length-1;c++)o.push([n[c],n[c+1]]);const l={intervals:o,min:n.at(0),max:n.at(-1)},u=await this._calculateHistogramBins(a,l,i);return this._createFeaturesFromHistogramBins(u,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:n}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),l=F(this.fieldsIndex.get(s)),u=j(o,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:p(r,l),maxValue:p(n,l)},!0),c=await this._calculateHistogramBins(o,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",n=[],o=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],l=t.bin?.stackBy?.value,u=t.bin?.stackBy?.outAlias;l&&o.push({name:G,alias:G,type:"esriFieldTypeInteger"},{name:u??l,alias:u??l,type:"esriFieldTypeString"});let c=0;for(const m of e){const{minValue:e,maxValue:i,items:s}=m,d={attributes:{}};let h;if(d.attributes[a]=e,d.attributes[r]=i,l?(h=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[l],orderByFields:[l]},s),d.attributes[G]=++c,"flat"===t.bin.jsonStyle?n.push(...h.features.map((({attributes:{EXPR_1:e,...t},...i})=>({...i,attributes:u??e?{...t,[u??e]:e,...d.attributes}:{...t,...d.attributes}})))):(d.stackedAttributes=h.features.map((({attributes:{EXPR_1:e,...t}})=>u??e?{...t,[u??e]:e}:t)),n.push(d))):(t.bin?.splitBy&&(d.attributes[G]=++c),h=await this._createStatisticsQueryResponse(t,s,d),n.push(d)),h.fields)for(const t of h.fields)o.some((e=>e.name===t.name))||o.push(t)}return"desc"===t.binOrder&&n.reverse(),{fields:o,features:n}}}function E(e,t,i,s){const a=s.x-i.x,r=s.y-i.y,n=t.x-i.x,o=t.y-i.y,l=a*a+r*r;if(0===l)return!1;const u=n*a+o*r,c=Math.min(1,Math.max(0,u/l));return e.x=i.x+a*c,e.y=i.y+r*c,!0}function O(e,t){return e?t?4:3:t?3:2}class H{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const Q=[1];export{C as QueryEngineResult};
