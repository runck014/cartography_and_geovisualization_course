/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{numericFieldTypes as t,allDateAndTimeFieldTypes as i,validateFields as s,validateWhere as r,validateHaving as n}from"./attributeSupport.js";import{checkProjectionSupport as o}from"./projectionSupport.js";import{checkSpatialQuerySupport as a}from"./spatialQuerySupport.js";import{loadArcade as l}from"../../../support/arcadeOnDemand.js";const u="unsupported-query";async function p(t,i){const s=t.bin;if(!s.onField&&!s.onExpression?.value||"autoIntervalBin"===s.type&&null==s.parameters.numberOfBins||"dateBin"===s.type&&(null==s.parameters.number||null==s.parameters.unit)||"fixedBoundariesBin"===s.type&&null==s.parameters.boundaries||"fixedIntervalBin"===s.type&&null==s.parameters.interval)throw new e(u,"Unsupported query options",{query:t});return c(t,i)}async function c(t,{fieldsIndex:i,geometryType:s,spatialReference:r,availableFields:n}){if(null!=t.geometryPrecision||t.multipatchOption&&"xyFootprint"!==t.multipatchOption||t.pixelSize||t.relationParam||t.text)throw new e(u,"Unsupported query options",{query:t});return d(i,n,t),m(i,n,t),Promise.all([a(t,s,r),o(r,t.outSR)]).then((()=>t))}function d(t,i,n){const{outFields:o,orderByFields:a,returnDistinctValues:l,outStatistics:p}=n,c=p?p.map((e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase())).filter(Boolean):[];if(a&&a.length>0){const e=" asc",r=" desc",o=a.map((t=>{const i=t.toLowerCase();return i.includes(e)?i.split(e)[0]:i.includes(r)?i.split(r)[0]:t})).filter((e=>!c.includes(e)));s(t,i,o,{expressionName:"orderByFields",query:n})}if(o&&o.length>0)s(t,i,o,{expressionName:"outFields",query:n,allowedFieldTypes:"all"});else if(l)throw new e(u,"outFields should be specified for returnDistinctValues",{query:n});r(t,i,n.where,n)}const f=new Set([...t,...i]);function m(t,i,r){const{outStatistics:o,groupByFieldsForStatistics:a,having:l}=r,p=a?.length,c=o?.length;if(l){if(!p||!c)throw new e(u,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:r});n(t,i,l,o,r)}if(c){if(!F(o))return;const n=o.map((e=>e.onStatisticField)).filter(Boolean);s(t,i,n,{expressionName:"onStatisticFields",query:r}),p&&s(t,i,a,{expressionName:"groupByFieldsForStatistics",query:r});for(const a of o){const{onStatisticField:n,statisticType:o}=a;if(("percentile_disc"===o||"percentile_cont"===o)&&"statisticParameters"in a){const{statisticParameters:t}=a;if(!t)throw new e(u,"statisticParameters should be set for percentile type",{definition:a,query:r})}else t.get(n)&&"count"!==o&&"min"!==o&&"max"!==o&&s(t,i,[n],{expressionName:`outStatistics with '${o}' statistic type`,allowedFieldTypes:f,query:r})}}}async function y(t,i,{fieldsIndex:s,geometryType:r,spatialReference:n,availableFields:l}){if(null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text||t.outStatistics||t.groupByFieldsForStatistics||t.having||t.orderByFields)throw new e(u,"Unsupported query options",{query:t});return d(s,l,t),Promise.all([h(s,l,i,t),a(t,r,n),o(n,t.outSR)]).then((()=>t))}async function h(t,i,r,n){let o=[];if(r.valueExpression){const{arcadeUtils:e}=await l();o=e.extractFieldNames(r.valueExpression)}if(r.field&&o.push(r.field),r.field2&&o.push(r.field2),r.field3&&o.push(r.field3),r.normalizationField&&o.push(r.normalizationField),!o.length&&!r.valueExpression)throw new e(u,"field or valueExpression is required",{params:r});s(t,i,o,{expressionName:"statistics",query:n})}function F(e){return null!=e&&e.every((e=>"exceedslimit"!==e.statisticType))}export{p as validateAttributeBinsQuery,c as validateQuery,y as validateStatisticsQuery};
