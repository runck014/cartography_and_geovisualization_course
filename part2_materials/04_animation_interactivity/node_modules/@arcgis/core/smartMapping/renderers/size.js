/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{toPt as a}from"../../core/screenUtils.js";import{ensureClass as r}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import s from"../../renderers/ClassBreaksRenderer.js";import l from"../../renderers/support/AuthoringInfo.js";import t from"../../renderers/support/AuthoringInfoSizeStop.js";import o from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as u}from"../../renderers/support/utils.js";import m from"../../renderers/visualVariables/SizeVariable.js";import{castSizeFromStringOrNumber as d}from"../../renderers/visualVariables/support/castSizeVariable.js";import p from"../../renderers/visualVariables/support/SizeVariableLegendOptions.js";import{TransformationType as c}from"../../renderers/visualVariables/support/sizeVariableUtils.js";import f from"../heuristics/ageUnit.js";import y from"../heuristics/outline.js";import v from"../heuristics/referenceSize.js";import z from"../heuristics/sizeRange.js";import{getReferenceSizeStops as w,createPrimitiveOverrides as b,updateReferenceSizeSymbol as h,createReferenceSizeSymbol as g}from"./support/referenceSizeUtils.js";import{isSizeVV as S,getAuthoringInfoVisualVariable as x,spliceVisualVariables as E,findSizeVVIndex as T,findOutlineVVIndex as V,updateAuthoringInfoVisualVariable as I,processRegenerateParams as O,getRendererToUpdate as k,getStyleType as B,hasScaleDependentSizeVV as F,hasOutlineVV as j}from"./support/regenerateUtils.js";import{getSummaryStatistics as q,errorCallback as R,getClassBreaks as D,getTitleAndExpressionForAgeRenderer as U,updateAgeRendererAuthoringInfoVV as G,verifyBasicFieldValidity as P,getDataRange as M,getSizeRangeForAxis as $,createSymbol as C,getSymbolOutlineFromScheme as A,getSymbolSizeFromScheme as L,getBasemapInfo as W}from"./support/utils.js";import{verifyDates as H,supportedAgeUnits as J}from"../statistics/support/ageUtils.js";import{verifyBinningParams as K}from"../support/binningUtils.js";import{getFieldsList as N,getNormalizationType as Q,isAnyDateField as X}from"../support/utils.js";import{binningCapableLayerTypes as Y,featureCapableLayerTypes as Z,createLayerAdapter as _,getLayerTypeLabels as ee}from"../support/adapters/support/layerUtils.js";import{cloneScheme as ie,getSchemes as ae}from"../symbology/size.js";import{getColorFromSymbol as re}from"../../symbols/support/utils.js";const ne=2**53-1;async function se(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");if("reference-size"===e.theme&&!e.view&&!e.field)throw new i("size-visual-variable:missing-parameters","'view' and 'field' are required when 'theme' is 'reference-size'");if("reference-size"===e.theme&&e.valueExpression)throw new i("size-visual-variable:missing-parameters","'valueExpression' is not supported when 'theme' is 'reference-size'");e.forBinning&&K(e,"size-visual-variable");const a={...e},r=e.forBinning?Y:Z,n=_(a.layer,r,e.forBinning);if(!n)throw new i("size-visual-variable:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));"height"===a.axis&&(a.sizeOptimizationEnabled=!1);const s=null!=a.signal?{signal:a.signal}:null;await n.load(s);const l=n.geometryType;if("mesh"===l)throw new i("size-visual-variable:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(a.worldScale){if("polyline"===l||"polygon"===l)throw new i("size-visual-variable:not-supported","'worldScale' sizing is not supported for polyline and polygon layers");if(!a.view||"3d"!==a.view.type)throw new i("size-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true")}if("reference-size"===a.theme&&!e.forBinning&&"polygon"!==l)throw new i("size-visual-variable:invalid-parameters","Reference size is only supported for polygon layers");const t=await N({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),o=P(n,t,"size-visual-variable:invalid-parameters");if(o)throw o;return await te(a),{...a,layer:n}}async function le(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("size-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("size-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"size-continuous-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=e.forBinning?Y:Z,n=_(a.layer,r,e.forBinning);if(!n)throw new i("size-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const s=null!=a.signal?{signal:a.signal}:null;await n.load(s);const l=n.geometryType,t=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="reference-size"!==a.theme&&"polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)throw new i("size-continuous-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-continuous-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");if("reference-size"===a.theme&&!e.forBinning&&"polygon"!==l)throw new i("size-continuous-renderer:invalid-parameters","Reference size is only supported for polygon layers");const o=await N({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),u=P(n,o,"size-continuous-renderer:invalid-parameters");if(u)throw u;return await te(a),{...a,layer:n}}async function te(e){const i=e.layer;if(("polygon"===i.geometryType||e.forBinning)&&e.view&&e.field&&!e.valueExpression&&(!e.theme||"reference-size"===e.theme)){try{e.referenceSizeResult=e.referenceSizeResult??await v({layer:i,view:e.view,filter:e.filter,forBinning:e.forBinning,signal:e.signal})}catch{}!e.theme&&e.referenceSizeResult?.isGrid&&(e.theme="reference-size"),e.referenceSizeOptions?.symbolStyle||(e.referenceSizeOptions?e.referenceSizeOptions.symbolStyle="circle":e.referenceSizeOptions={symbolStyle:"circle"})}}async function oe(e){if(!e||!(e.layer&&e.view&&e.sizeStops))throw new i("update-renderer-with-reference-size:missing-parameters","'layer', 'view and 'sizeStops' parameters are required");const{view:a,forBinning:r}=e,n=e.forBinning?Y:Z,s=_(e.layer,n,e.forBinning);if(!s)throw new i("update-renderer-with-reference-size:invalid-parameters","'layer' must be one of these types: "+ee(n).join(", "));const l=s.layer;let t=e.renderer;if(!t)if(e.forBinning){if(!("featureReduction"in l&&l.featureReduction&&"renderer"in l.featureReduction&&l.featureReduction.renderer)||"class-breaks"!==l.featureReduction.renderer.type&&"unique-value"!==l.featureReduction.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Feature reduction renderer is not supported");t=l.featureReduction.renderer}else{if(!("renderer"in l)||!l.renderer||"class-breaks"!==l.renderer.type&&"unique-value"!==l.renderer.type)throw new i("update-renderer-with-reference-size:invalid-parameters","Renderer is not supported");t=l.renderer}const o=t.authoringInfo;if(!o||!o?.visualVariables?.some((e=>"reference-size"===e.theme)))throw new i("update-renderer-with-reference-size:invalid-parameters","'renderer.authoringInfo.visualVariables' should have an authoringInfoVisualVariable with 'theme' set to 'reference-size'");const u=e.isGrid??(await v({view:a,layer:l,forBinning:r}))?.isGrid;return{...e,isGrid:u,renderer:t,layer:s}}async function ue(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("size-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("size-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"size-class-breaks-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="equal-interval",a.normalizationType=Q(a);const r=e.forBinning?Y:Z,n=_(a.layer,r,e.forBinning);if(!n)throw new i("size-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(!(null!=a.minValue&&null!=a.maxValue)&&(null!=a.minValue||null!=a.maxValue))throw new i("size-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const s=null!=a.signal?{signal:a.signal}:null;await n.load(s);const l=n.geometryType,t=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)throw new i("size-class-breaks-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(t&&("polyline"===l||"polygon"===l))throw new i("size-class-breaks-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const o=await N({field:a.field,normalizationField:a.normalizationField}),u=P(n,o,"size-class-breaks-renderer:invalid-parameters");if(u)throw u;return{...a,layer:n}}function me(e){const i={...e};delete i.basemap,delete i.sizeScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}function de(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric"),r=i;return r.worldScale=a,a&&(r.axis="3d-volumetric-uniform"===i.symbolType?"all":"height"),delete i.symbolType,delete i.defaultSymbolEnabled,r}async function pe(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("size-age-renderer:missing-parameters","'layer', 'view', 'startTime', 'endTime' parameters are required");const a={...e};a.symbolType??="2d",a.defaultSymbolEnabled??=!0;const r=_(a.layer,Z);if(!r)throw new i("size-age-renderer:invalid-parameters","'layer' must be one of these types: "+ee(Z).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await r.load(n);const s=r.geometryType,l=a.symbolType.includes("3d");if(a.outlineOptimizationEnabled="polygon"===s&&a.outlineOptimizationEnabled,"mesh"===s)throw new i("size-age-renderer:invalid-parameters","Size visualization is not applicable to layers with 'mesh' geometry type");if(l&&("polyline"===s||"polygon"===s))throw new i("size-age-renderer:not-supported","3d symbols are not supported for polyline and polygon layers");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("size-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or 3d-volumetric-uniform");const t=H(r,a.startTime,a.endTime,"size-age-renderer:invalid-parameters");if(t)throw t;if(a.unit&&!J.includes(a.unit))throw new i("size-age-renderer:invalid-unit",`Supported units are: ${J.join(", ")}`);return{...a,layer:r}}async function ce(e){const a="regenerate-size-visual-variables";O(e,a);const r=await k(e),n=B(r);if(!n||!["size-continuous","univariate-color-size","color-size","relationship-size","type-size"].includes(n))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const s=x(r,"size");if(!s)throw new i(`${a}:invalid-parameters`,"Renderer does not have a size visual variable authoringInfo");const l=s.theme,t="reference-size"===l,o=r.visualVariables?.find(S);if(!o&&!t)throw new i(`${a}:invalid-parameters`,"Renderer does not have a size visual variable");let u=s.field,m=s.normalizationField,d=null,p=null;u||(o?.field?(u=o.field,m=o.normalizationField):r.field?(u=r.field,m=r.normalizationField):(d=o?.valueExpression??r.valueExpression,p=o?.valueExpressionTitle??r.valueExpressionTitle));const{layer:c,forBinning:f,filter:y,view:v,signal:z}=e,w=F(r),b=await se({layer:c,field:u,valueExpression:d,valueExpressionTitle:p,normalizationField:m,theme:l,sizeOptimizationEnabled:w,forBinning:f,filter:y,view:v,signal:z});return{...e,creatorParameters:b,renderer:r}}async function fe(e){const a="regenerate-size-continuous-renderer";O(e,a);const r=await k(e),n=B(r);if(!n||!["size-continuous","univariate-color-size"].includes(n))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:s,field:l,normalizationField:t,valueExpression:o,valueExpressionTitle:u}=r,m=s?.visualVariables.find((e=>"size"===e.type)),d=m.theme,{layer:p,forBinning:c,filter:f,view:y,signal:v}=e,z=j(r),w=F(r),b=await le({layer:p,field:l,valueExpression:o,valueExpressionTitle:u,normalizationField:t,theme:d,outlineOptimizationEnabled:z,sizeOptimizationEnabled:w,forBinning:c,filter:f,view:y,signal:v});return{...e,creatorParameters:b,renderer:r}}async function ye(e){const a="regenerate-size-class-breaks-renderer";await O(e,a);const r=await k(e);if("size-class-breaks"!==B(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n,field:s,normalizationField:l,normalizationType:t,normalizationTotal:o,valueExpression:u,valueExpressionTitle:m}=r,{classificationMethod:d,standardDeviationInterval:p}=n,c=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:z,signal:w}=e,b=j(r),h=await ue({layer:f,field:s,valueExpression:u,valueExpressionTitle:m,normalizationType:t,normalizationField:l,normalizationTotal:o,classificationMethod:d,standardDeviationInterval:p,numClasses:c,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:z,signal:w});return{...e,creatorParameters:h,renderer:r}}async function ve(e){const a="regenerate-size-age-renderer";await O(e,a);const r=await k(e);if("size-age"!==B(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:n}=r,s=n?.visualVariables.find((e=>"size"===e.type)),l=s.startTime,t=s.endTime,o=s.units,u=s.theme,{layer:m,filter:d,view:p,signal:c}=e,f=j(r),y=F(r),v=await pe({layer:m,startTime:l,endTime:t,unit:o,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:d,view:p,signal:c});return{...e,creatorParameters:v,renderer:r}}async function ze(e){let i=e.sizeScheme,a=null,r=null;const n=await W(e.basemap,e.view);if(a=null!=n.basemapId?n.basemapId:null,r=null!=n.basemapTheme?n.basemapTheme:null,i)return{scheme:ie(i),basemapId:a,basemapTheme:r};const s=ae({basemapTheme:r,geometryType:e.geometryType,worldScale:e.worldScale,view:e.view});return s&&(i=s.primaryScheme,a=s.basemapId,r=s.basemapTheme),{scheme:i,basemapId:a,basemapTheme:r}}function we(e,i){switch(i){case"point":case"multipoint":{const i=e;return[d(i.minSize),d(i.maxSize)]}case"polyline":{const i=e;return[d(i.minWidth),d(i.maxWidth)]}case"polygon":{const i=e;return[d(i.marker.minSize),d(i.marker.maxSize)]}}}function be(e,i){e.transformationType===c.ClampedLinear&&"below"===i&&e.flipSizes()}async function he(e,i,a,r,n){return"reference-size"===a&&i?[1,i.size]:e?[e.minSize,e.maxSize]:we(r,n)}function ge(e,i,a){return"reference-size"===a&&i?[1,i.size]:e?[e.minSize,e.maxSize]:null}function Se(e,i){if("reference-size"===i.theme&&null!=e.min&&null!=e.max&&null!=e.avg&&null!=e.stddev){const i=100,a=0,r=0,n=1,s=e.avg,l=e.min,t=e.max,o=e.stddev,u=0!==s?o/s:0,m=l>r&&l<n&&t<2*n&&u<.5,d=l>a&&l<i&&t<2*i&&u<.5;return{minDataValue:m?r:d?a:l,maxDataValue:m?n:d?i:s+2*o,defaultValuesUsed:!1}}const{theme:a,field:r}=i,n=i.layer,s=r&&!("function"==typeof r)?n.getField(r):null,l=X(s);return M(e,a,l,"above"===a||"below"===a)}async function xe(e,a,n,s){const{theme:u,field:d,normalizationField:c,minValue:f,maxValue:y,axis:v}=e,z=e.layer.geometryType,b=await ze({basemap:e.basemap,geometryType:z,sizeScheme:e.sizeScheme,worldScale:e.worldScale,view:e.view}),h=b.scheme;if(!h)throw new i("size-visual-variable:insufficient-info","Unable to find size scheme");const g=await he(n,s,u,h,z),{minDataValue:S,maxDataValue:x,defaultValuesUsed:E}=Se(a,e),T=[],V="height"===v,I=V?v:void 0,O=g[0];let k=g[1];if(V&&"number"==typeof O&&"number"==typeof k){const e=$({minSize:O,maxSize:k},I);T.push(new m({axis:"width-and-depth",minSize:e.minSize})),k=e.maxSize}const B=new m({field:d??void 0,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,valueUnit:"unknown",normalizationField:c,axis:I,minSize:O,maxSize:k,minDataValue:S,maxDataValue:x,legendOptions:r(p,e.legendOptions)});be(B,u),T.unshift(B);const F=new o("reference-size"===u?{type:"size",field:e.field,normalizationField:e.normalizationField,sizeStops:w(B).map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),theme:u,referenceSizeScale:s?.isGrid||e.sizeOptimizationEnabled?e?.view?.scale:void 0,referenceSizeSymbolStyle:e.referenceSizeOptions?.symbolStyle,minSliderValue:null!=f?f:a.min,maxSliderValue:null!=y?y:a.max}:{type:"size",theme:u,minSliderValue:null!=f?f:a.min,maxSliderValue:null!=y?y:a.max}),j=new l({visualVariables:[F]});return{basemapId:b.basemapId,basemapTheme:b.basemapTheme,visualVariables:T,statistics:a,isGrid:s?.isGrid,defaultValuesUsed:E,sizeScheme:ie(h),authoringInfo:j}}async function Ee(e,i,a,r,l){const t=await n("esri/smartMapping/t9n/smartMapping"),o=l.layer,u=l.field,m=o.geometryType,d=l.defaultSymbolEnabled,p=ie(e.sizeScheme),c="polygon"===m,f=c?p.marker:p,y=c?p.background:null,v=c?"point":m,z=i?.opacity,h=e.isGrid,S="reference-size"===l.theme,x=S?[]:e.visualVariables.map((e=>e.clone()));i?.visualVariables?.length&&x.push(...i.visualVariables.map((e=>e.clone())));const E=S?b({view:l.view,field:u,normalizationField:r,sizeStops:w(e.visualVariables[0]),sizeByScaleEnabled:h||!!l.sizeOptimizationEnabled}):null;return{renderer:new s({backgroundFillSymbol:!h&&y?C(m,{type:l.symbolType,color:y.color,outline:A(y,m,z)}):null,classBreakInfos:[{minValue:-9007199254740991,maxValue:ne,symbol:E?g({type:l.referenceSizeOptions?.symbolStyle||"circle",color:f.color,primitiveOverrides:E}):C(v,{type:l.symbolType,color:f.color,size:L(f,v),outline:A(f,v,z)})}],defaultLabel:d?t.other:null,defaultSymbol:d&&!S?C(v,{type:l.symbolType,color:f.noDataColor,size:L(f,v,!0),outline:A(f,v,z)}):null,field:u,normalizationField:r,normalizationType:a,valueExpression:l.valueExpression,valueExpressionTitle:l.valueExpressionTitle,visualVariables:x,authoringInfo:e.authoringInfo?.clone()}),visualVariables:e.visualVariables.map((e=>e.clone())),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,isGrid:h,sizeScheme:ie(e.sizeScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}function Te(e,i){const r=a(e.minSize),n=(a(e.maxSize)-r)/(i>=4?i-1:i),s=[];for(let a=0;a<i;a++)s.push(r+n*a);return s}async function Ve(e,i){const a=await n("esri/smartMapping/t9n/smartMapping"),r=e.layer,t=e.defaultSymbolEnabled,o=r.geometryType,m="polygon"===o,d=e.symbolType?.includes("3d-volumetric"),p=await ze({basemap:e.basemap,geometryType:o,sizeScheme:e.sizeScheme,worldScale:d,view:e.view}),c=p.scheme,{result:f,outlineResult:y}=i,v=f?.classBreakInfos??[],z=e.classificationMethod,w=e.normalizationType,b=m?c.marker:c,h=m?c.background:null,g=m?"point":o,S=we(b,g),x=d?$({minSize:S[0],maxSize:S[1]},"height"):null,E=Te({minSize:S[0],maxSize:x?x.maxSize:S[1]},v.length),T=y?.opacity,V=new s({backgroundFillSymbol:h&&C(o,{type:e.symbolType,color:h.color,outline:A(h,o,T)}),classBreakInfos:v.map(((i,a)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:C(g,{type:e.symbolType,color:b.color,size:E[a],widthAndDepth:x?.minSize,outline:A(b,g,T)}),label:i.label}))),defaultLabel:t?a.other:null,defaultSymbol:t?C(g,{type:e.symbolType,color:b.noDataColor,size:L(b,g,!0),widthAndDepth:x?.minSize,outline:A(b,g,T)}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?f?.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new l({type:"class-breaks-size",classificationMethod:z,standardDeviationInterval:e.standardDeviationInterval})});return"standard-deviation"!==z&&u({classBreakInfos:V.classBreakInfos,classificationMethod:z,normalizationType:w,round:!0}),y?.visualVariables?.length&&(V.visualVariables=y.visualVariables.map((e=>e.clone()))),{renderer:V,sizeScheme:ie(c),classBreaksResult:f,defaultValuesUsed:!!i.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function Ie(e){const i=await se(e),{view:a,field:r,valueExpression:n,minValue:s,maxValue:l,layer:t,normalizationField:o,signal:u,statistics:m,filter:d}=i,p=o?"field":void 0,[c,f]=await Promise.all([m??q({layer:t,field:r,valueExpression:n,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:p,normalizationField:o,filter:d,minValue:s,maxValue:l,view:a,signal:u}),i.sizeOptimizationEnabled?z({view:a,layer:t,signal:u,filter:d}).catch(R):null]);return xe(i,c,f,i.referenceSizeResult)}async function Oe(e){const{view:i,filter:a,renderer:r,signal:n,creatorParameters:s}=await ce(e),{field:l,normalizationField:o,valueExpression:u,theme:d,layer:p,sizeOptimizationEnabled:c,referenceSizeResult:f,valueExpressionTitle:y}=s,v=o?"field":void 0,[b,h]=await Promise.all([q({layer:p,field:l,valueExpression:u,normalizationField:o,normalizationType:v,filter:a,view:i,signal:n}),c?z({view:i,layer:p,signal:n,filter:a}).catch(R):null]),g=ge(h,f,d),{minDataValue:E,maxDataValue:T}=Se(b,{theme:d,layer:p,field:l}),V=r.visualVariables?.find(S),I=(V?.stops?null:V)??new m({field:l??void 0,valueExpression:u,valueExpressionTitle:y,valueUnit:"unknown",normalizationField:o});g&&(I.minSize=g[0],I.maxSize=g[1]),I.minDataValue=E,I.maxDataValue=T,be(I,d);const O=x(r,"size");return O.minSliderValue=b.min,O.maxSliderValue=b.max,"reference-size"===d&&(O.sizeStops=w(I).map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),O.referenceSizeScale=f?.isGrid||c?i?.scale:void 0),{visualVariables:"reference-size"===d?[]:[I],isGrid:!!f?.isGrid,authoringInfo:r.authoringInfo?.clone(),statistics:b}}async function ke(e){const i=await le(e),a={layer:i.layer,view:i.view,filter:i.filter,signal:i.signal},[r,n]=await Promise.all([Ie(de(i)),i.outlineOptimizationEnabled?y(a).catch(R):null]),s=i.normalizationField;return Ee(r,n,s?"field":void 0,s,i)}async function Be(e){const{renderer:i,view:a,signal:r,filter:n,creatorParameters:s,forBinning:l}=await fe(e),{layer:t,outlineOptimizationEnabled:o,theme:u,referenceSizeResult:m}=s,[d,p]=await Promise.all([Oe({...e,referenceSizeResult:m}),o?y({layer:t,view:a,filter:n,signal:r}).catch(R):null]),c=d.isGrid,f="reference-size"===u;E(i,d.visualVariables,T),E(i,p?.visualVariables,V),I(i,d.authoringInfo,"size");const v=d.statistics;if(!f)return{renderer:i,statistics:v};return{renderer:await Fe({layer:t,renderer:i,view:a,forBinning:l,sizeStops:x(i,"size","reference-size")?.sizeStops,isGrid:c}),isGrid:c,statistics:v}}async function Fe(a){const{layer:r,referenceSizeOptions:n,renderer:s,sizeScheme:o,sizeStops:u,typeScheme:m,view:d,isGrid:p}=await oe(a),c=s.clone();c.authoringInfo??=new l;const f=c.authoringInfo.visualVariables.find((e=>"reference-size"===e.theme)),y=a.field??f?.field,v=a.normalizationField??f?.normalizationField;if(!y)throw new i("update-renderer-with-reference-size:invalid-parameters","'field' parameter or authoring info with 'field' is required.");const z=b({view:d,field:y,normalizationField:v,sizeStops:u,sizeByScaleEnabled:p||!!a.sizeOptimizationEnabled}),w=n?.symbolStyle||f?.referenceSizeSymbolStyle||"circle";if("class-breaks"===c.type){const e="polygon"===("geometryType"in r?r.geometryType:null)&&o&&"marker"in o?o.marker:null;c.classBreakInfos.forEach((i=>{const a=e?.color??re(i.symbol,1);"cim"===i.symbol.type?h(i.symbol,{type:w,color:a,primitiveOverrides:z}):a&&(i.symbol=g({type:w,color:a,primitiveOverrides:z}))}))}else if("unique-value"===c.type){const i=c.uniqueValueGroups,a="polygon"===("geometryType"in r?r.geometryType:null)&&m&&"colors"in m?m.colors:null,n=a?e(a,c.uniqueValueInfos?.length??0):null;let s=0;if(i){for(const e of i)for(const i of e.classes??[]){const e=n?n[s]:re(i.symbol,1);"cim"===i.symbol?.type?h(i.symbol,{type:w,color:e,primitiveOverrides:z}):e&&(i.symbol=g({type:w,color:e,primitiveOverrides:z})),s++}c.uniqueValueGroups=i}}return f&&(f.field=y,f.normalizationField=v,f.sizeStops=u.map((({label:e,size:i,value:a})=>new t({label:e,size:i,value:a}))),f.referenceSizeScale=p||a.sizeOptimizationEnabled?d.scale:void 0,f.referenceSizeSymbolStyle=w),c}async function je(e){const i=await ue(e);return Ve(i,await D(me(i),i.outlineOptimizationEnabled))}async function qe(e){const{renderer:a,creatorParameters:r}=await ye(e),{outlineOptimizationEnabled:n,normalizationType:s,classificationMethod:l}=r,{result:t,outlineResult:o}=await D(me(r),n),m=t.classBreakInfos;if(r.numClasses!==m.length)throw new i("regenerate-class-breaks-renderer:invalid-parameters","The number of class breaks generated does not match the number of class breaks in the renderer.");return a.classBreakInfos.forEach(((e,i)=>{e.minValue=m[i].minValue,e.maxValue=m[i].maxValue,e.label=m[i].label})),a.normalizationTotal="percent-of-total"===s?t.normalizationTotal:void 0,"standard-deviation"!==l&&u({classBreakInfos:a.classBreakInfos,classificationMethod:l,normalizationType:s,round:!0}),E(a,o?.visualVariables,V),{renderer:a}}async function Re(e){const i=await pe(e),{defaultSymbolEnabled:a,view:r,startTime:n,endTime:s,symbolType:l,minValue:t,maxValue:o,signal:u,filter:m,layer:d}=i,[p,c]=await Promise.all([i.unit?{unit:i.unit,statistics:null,valueExpression:null}:await f({view:r,layer:d,startTime:n,endTime:s,minValue:t,maxValue:o,signal:u,filter:m}),i.outlineOptimizationEnabled?y({layer:d,view:r,filter:m,signal:u}).catch(R):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await U(i,v),h=await Ie(de({layer:d,basemap:i.basemap,valueExpression:w,symbolType:l,statistics:z,legendOptions:{title:b},theme:i.theme,sizeScheme:i.sizeScheme,sizeOptimizationEnabled:i.sizeOptimizationEnabled,view:i.view,minValue:t,maxValue:o,filter:m,signal:u})),g={layer:d,valueExpression:w,defaultSymbolEnabled:a,symbolType:l},S=await Ee(h,c,null,null,g),x=S.renderer.authoringInfo?.visualVariables;return x?.forEach((e=>G(e,n,s,v))),{...S,unit:v}}async function De(e){const{renderer:i,creatorParameters:a}=await ve(e),{layer:r,outlineOptimizationEnabled:n,sizeOptimizationEnabled:s,startTime:l,endTime:t,theme:o,view:u,signal:m,filter:d}=a,[p,c]=await Promise.all([f({view:u,layer:r,startTime:l,endTime:t,signal:m,filter:d}),n?y({layer:r,view:u,filter:d,signal:m}).catch(R):null]),{unit:v,statistics:z}=p,{valueExpression:w,title:b}=await U(a,v),h=await Ie(de({layer:r,valueExpression:w,statistics:z,legendOptions:{title:b},sizeOptimizationEnabled:s,theme:o,view:u,filter:d,signal:m}));E(i,h.visualVariables,T),E(i,c?.visualVariables,V),i.authoringInfo=h.authoringInfo.clone();const g=i.authoringInfo?.visualVariables;return g?.forEach((e=>G(e,l,t,v))),{renderer:i}}export{Re as createAgeRenderer,je as createClassBreaksRenderer,ke as createContinuousRenderer,Ie as createVisualVariables,De as regenerateAgeRenderer,qe as regenerateClassBreaksRenderer,Be as regenerateContinuousRenderer,Oe as regenerateVisualVariables,Fe as updateRendererWithReferenceSize};
