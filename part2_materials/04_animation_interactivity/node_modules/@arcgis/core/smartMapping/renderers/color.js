/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{clone as a}from"../../core/lang.js";import{ensureClass as r}from"../../core/accessorSupport/ensureType.js";import{fetchMessageBundle as o}from"../../intl/messages.js";import n from"../../renderers/ClassBreaksRenderer.js";import l from"../../renderers/PointCloudRGBRenderer.js";import s from"../../renderers/PointCloudStretchRenderer.js";import t from"../../renderers/support/AuthoringInfo.js";import u from"../../renderers/support/AuthoringInfoVisualVariable.js";import{setLabelsForClassBreaks as m,createColorStops as d}from"../../renderers/support/utils.js";import c from"../../renderers/visualVariables/ColorVariable.js";import p from"../../renderers/visualVariables/support/ColorStop.js";import f from"../../renderers/visualVariables/support/VisualVariableLegendOptions.js";import y from"../heuristics/ageUnit.js";import v from"../heuristics/outline.js";import h from"../heuristics/sizeRange.js";import{spliceVisualVariables as w,findColorVVIndex as b,findOutlineVVIndex as g,findScaleDependentSizeVVIndex as T,updateAuthoringInfoVisualVariable as x,processRegenerateParams as z,getRendererToUpdate as E,getStyleType as V,hasOutlineVV as I,hasScaleDependentSizeVV as S}from"./support/regenerateUtils.js";import{getSummaryStatistics as M,errorCallback as O,getClassBreaks as B,getPointSizeAlgorithm as j,getTitleAndExpressionForAgeRenderer as k,updateAgeRendererAuthoringInfoVV as F,verifyBasicFieldValidity as q,isValidPointSize as C,getDefaultDataRange as U,createDefaultStopValues as P,createStopValues as R,getDataRange as D,createDataValues as L,createSymbol as $,getSymbolSizeFromScheme as A,getSymbolOutlineFromScheme as G,getBasemapInfo as W}from"./support/utils.js";import{verifyDates as H,supportedAgeUnits as J}from"../statistics/support/ageUtils.js";import{verifyBinningParams as K}from"../support/binningUtils.js";import{isAnyDateField as N,getFieldsList as Q,getNormalizationType as X}from"../support/utils.js";import{binningCapableLayerTypes as Y,featureCapableLayerTypes as Z,createLayerAdapter as _,getLayerTypeLabels as ee,LayerType as ie}from"../support/adapters/support/layerUtils.js";import{cloneScheme as ae,getSchemes as re,getSchemeById as oe}from"../symbology/color.js";const ne="high-to-low",le=2**53-1,se=5;async function te(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-visual-variable:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-visual-variable:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-visual-variable");const a={...e},r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-visual-variable:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);if("mesh"!==o.geometryType&&a.worldScale&&(!a.view||"3d"!==a.view.type))throw new i("color-visual-variable:invalid-parameters","'view' parameter should be an instance of SceneView when 'worldScale' parameter is true");const l=await Q({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),s=q(o,l,"color-visual-variable:invalid-parameters");if(s)throw s;return{...a,layer:o}}async function ue(e){if(!(e&&e.layer&&(e.field||e.valueExpression||e.sqlExpression)))throw new i("color-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(e.valueExpression&&!e.sqlExpression&&!e.view)throw new i("color-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-continuous-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);const l=o.geometryType;if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===l||"multipoint"===l||"polyline"===l)&&a.sizeOptimizationEnabled,"mesh"===l)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==l)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-continuous-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await Q({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),t=q(o,s,"color-continuous-renderer:invalid-parameters");if(t)throw t;return{...a,layer:o}}async function me(e){if(!e||!e.layer||!e.field&&!e.valueExpression)throw new i("color-class-breaks-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("color-class-breaks-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&K(e,"color-class-breaks-renderer");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0,a.classificationMethod??="equal-interval",a.normalizationType=X(a);const r=e.forBinning?Y:Z,o=_(a.layer,r,e.forBinning);if(!o)throw new i("color-class-breaks-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(!(null!=a.minValue&&null!=a.maxValue)&&(null!=a.minValue||null!=a.maxValue))throw new i("color-class-breaks-renderer:missing-parameters","Both 'minValue' and 'maxValue' are required when specifying custom data range");const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);const l=o.geometryType;if(a.outlineOptimizationEnabled="polygon"===l&&a.outlineOptimizationEnabled,"mesh"===l)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else{if("3d-volumetric-uniform"===a.symbolType&&"point"!==l)throw new i("color-class-breaks-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-class-breaks-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const s=await Q({field:a.field,normalizationField:a.normalizationField}),t=q(o,s,"color-class-breaks-renderer:invalid-parameters");if(t)throw t;return{...a,layer:o}}function de(e){const i={...e};delete i.basemap,delete i.colorScheme,delete i.legendOptions,delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const a=i;return a.analyzeData=!(null!=i.minValue&&null!=i.maxValue),a}async function ce(e){if(!e?.layer)throw new i("color-point-cloud-true-color-renderer:missing-parameters","'layer' parameter is required");const a={...e,layer:e.layer},r=[ie.PointCloudLayer],o=_(a.layer,r);if(!o)throw new i("color-point-cloud-true-color-renderer:invalid-parameters","'layer' must be one of these types: "+ee(r).join(", "));if(a.layer=o,a.density=a.density||25,a.size=a.size||"100%",!C(a.size))throw new i("color-point-cloud-true-color-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const n=null!=a.signal?{signal:a.signal}:null;return await o.load(n),a}async function pe(e){if(!e?.layer||!e.field)throw new i("color-point-cloud-continuous-renderer:missing-parameters","'layer' and 'field' parameters are required");const a=e.field.toLowerCase();if("intensity"!==a&&"elevation"!==a)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'field' should be either 'intensity' or 'elevation'");const r={...e,layer:e.layer,field:e.field},o=[ie.PointCloudLayer],n=_(r.layer,o);if(!n)throw new i("color-point-cloud-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+ee(o).join(", "));if(r.layer=n,r.density=r.density||25,r.size=r.size||"100%",!C(r.size))throw new i("color-point-cloud-continuous-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const l=null!=r.signal?{signal:r.signal}:null;return await n.load(l),r}function fe(e){const i={...e},a=!!i.symbolType?.includes("3d-volumetric");delete i.symbolType,delete i.defaultSymbolEnabled,delete i.colorMixMode,delete i.edgesType;const r=i;return r.worldScale=a,r}async function ye(e){if(!(e&&e.layer&&e.view&&e.startTime&&e.endTime))throw new i("color-age-renderer:missing-parameters","'layer', 'view', startTime', 'endTime' parameters are required");const a={...e};a.symbolType=a.symbolType||"2d",a.defaultSymbolEnabled??=!0;const r=_(a.layer,Z);if(!r)throw new i("color-age-renderer:invalid-parameters","'layer' must be one of these types: "+ee(Z).join(", "));const o=null!=a.signal?{signal:a.signal}:null;await r.load(o);const n=r.geometryType;if(a.outlineOptimizationEnabled="polygon"===n&&a.outlineOptimizationEnabled,a.sizeOptimizationEnabled=("point"===n||"multipoint"===n||"polyline"===n)&&a.sizeOptimizationEnabled,"mesh"===n)a.symbolType="3d-volumetric",a.colorMixMode=a.colorMixMode||"replace",a.edgesType=a.edgesType||"none";else if("3d-volumetric-uniform"===a.symbolType&&"point"!==n)throw new i("color-continuous-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(a.symbolType.includes("3d-volumetric")&&(!a.view||"3d"!==a.view.type))throw new i("color-age-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'");const l=H(r,a.startTime,a.endTime,"color-age-renderer:invalid-parameters");if(l)throw l;if(a.unit&&!J.includes(a.unit))throw new i("color-age-renderer:invalid-unit",`Supported units are: ${J.join(", ")}`);return{...a,layer:r}}async function ve(e){const a="regenerate-color-visual-variable";await z(e,a);const r=await E(e);if("class-breaks"!==r?.type)throw new i(`${a}:invalid-parameters`,"Renderer must be a ClassBreaksRenderer to regenerate a color visual variable");const o=r.authoringInfo,n=o?.visualVariables.find((e=>"color"===e.type)),l=r.visualVariables?.find((e=>"color"===e.type));if(!l)throw new i(`${a}:invalid-parameters`,"Renderer does not have a color visual variable");const{field:s,normalizationField:t,valueExpression:u,valueExpressionTitle:m}=l,d="univariate-color-size"===o?.type?o?.univariateTheme:n?.theme,{layer:c,forBinning:p,filter:f,view:y,signal:v}=e,h=await te({layer:c,field:s,valueExpression:u,valueExpressionTitle:m,normalizationField:t,theme:d,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:h,renderer:r}}async function he(e){const a="regenerate-color-continuous-renderer";await z(e,a);const r=await E(e),o=V(r);if(!o||!["color-continuous","color-size"].includes(o))throw new i(`${a}:invalid-renderer`,"Renderer is invalid");const{authoringInfo:n,field:l,normalizationField:s,valueExpression:t,valueExpressionTitle:u}=r,m=n?.visualVariables.find((e=>"color"===e.type)),d=m?.theme,{layer:c,forBinning:p,filter:f,view:y,signal:v}=e,h=I(r),w=S(r),b=await ue({layer:c,field:l,valueExpression:t,valueExpressionTitle:u,normalizationField:s,theme:d,outlineOptimizationEnabled:h,sizeOptimizationEnabled:w,forBinning:p,filter:f,view:y,signal:v});return{...e,creatorParameters:b,renderer:r}}async function we(e){const a="regenerate-color-class-breaks-renderer";await z(e,a);const r=await E(e);if("color-class-breaks"!==V(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:o,field:n,normalizationField:l,normalizationType:s,normalizationTotal:t,valueExpression:u,valueExpressionTitle:m}=r,{classificationMethod:d,standardDeviationInterval:c}=o,p=r.classBreakInfos.length,{layer:f,forBinning:y,filter:v,view:h,signal:w}=e,b=I(r),g=await me({layer:f,field:n,valueExpression:u,valueExpressionTitle:m,normalizationType:s,normalizationField:l,normalizationTotal:t,classificationMethod:d,standardDeviationInterval:c,numClasses:p,outlineOptimizationEnabled:b,forBinning:y,filter:v,view:h,signal:w});return{...e,creatorParameters:g,renderer:r}}async function be(e){const a="regenerate-color-age-renderer";await z(e,a);const r=await E(e);if("color-age"!==V(r))throw new i(`${a}:invalid-parameters`,"Renderer is invalid");const{authoringInfo:o}=r,n=o?.visualVariables.find((e=>"color"===e.type)),l=n.startTime,s=n.endTime,t=n.units,u=n.theme,{layer:m,filter:d,view:c,signal:p}=e,f=I(r),y=S(r),v=await ye({layer:m,startTime:l,endTime:s,unit:t,theme:u,outlineOptimizationEnabled:f,sizeOptimizationEnabled:y,filter:d,view:c,signal:p});return{...e,creatorParameters:v,renderer:r}}async function ge(e,i){let a=e.colorScheme,r=null,o=null;const{view:n}=e,l=await W(e.basemap,n);if(r=null!=l.basemapId?l.basemapId:null,o=null!=l.basemapTheme?l.basemapTheme:null,a)return{scheme:ae(a),basemapId:r,basemapTheme:o};const s=e.theme||ne,t=re({theme:s,basemapTheme:o,geometryType:e.geometryType,worldScale:e.worldScale,view:n});if(t)if(r=t.basemapId,o=t.basemapTheme,e.schemeId){const i=s+"/"+r+"/"+e.schemeId;a=oe({id:i,geometryType:e.geometryType})}else a=t.primaryScheme;return{scheme:a,basemapId:r,basemapTheme:o}}async function Te(a,r){const o=r.layer,n=await ge({basemap:r.basemap,colorScheme:r.colorScheme,geometryType:o.geometryType,schemeId:"elevation"===r.field.toLowerCase()?"point-cloud-elevation-scheme":"point-cloud-intensity-scheme"}),l=n.scheme;if(!l)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Unable to find color scheme");const s=e(l.colors,se);if(s.length<se)throw new i("color-point-cloud-continuous-renderer:insufficient-info","Color scheme does not have enough colors");const t=U(a,!1,!0),u=t?P(t[0],t[1],5):R(a);return{stops:d({values:u,isDate:!1,colors:s,labelIndexes:[0,2,4]}),basemapId:n.basemapId,basemapTheme:n.basemapTheme,statistics:a,defaultValuesUsed:!!t,colorScheme:ae(l)}}function xe(e,i,a,r){const o=D(e,i,a,!0);return{values:L(o,e,i,r),defaultValuesUsed:o.defaultValuesUsed}}async function ze(a,o,n,l){const{field:s,theme:m}=a,d=await ge({basemap:a.basemap,theme:a.theme,geometryType:n,colorScheme:a.colorScheme,worldScale:a.worldScale,view:a.view}),y=d.scheme;if(!y)throw new i("color-visual-variable:insufficient-info","Unable to find color scheme");const v=e(y.colors,se);if(v.length<se)throw new i("color-visual-variable:insufficient-info","Color scheme does not have enough colors");const h=y.id.includes("seq-"),{values:w,defaultValuesUsed:b}=xe(o,m,l,h),g=e(v,se),T=new c({field:s??void 0,valueExpression:a.valueExpression,valueExpressionTitle:a.valueExpressionTitle,normalizationField:a.normalizationField,stops:w.map(((e,i)=>new p({value:e,color:g[i]}))),legendOptions:r(f,a.legendOptions)}),x=new u({type:"color",minSliderValue:null!=a.minValue?a.minValue:o.min,maxSliderValue:null!=a.maxValue?a.maxValue:o.max,theme:y.theme}),z=new t({visualVariables:[x]});return{basemapId:d.basemapId,basemapTheme:d.basemapTheme,visualVariable:T,statistics:o,defaultValuesUsed:b,colorScheme:ae(y),authoringInfo:z}}async function Ee(e,i,a,r,l,s,t){const u=await o("esri/smartMapping/t9n/smartMapping"),{field:m,defaultSymbolEnabled:d}=t,c=ae(e.colorScheme),p=i?.opacity,f=[e.visualVariable.clone()];i?.visualVariables?.length&&f.push(...i.visualVariables.map((e=>e.clone()))),a?.minSize&&f.push(a.minSize);return{renderer:new n({classBreakInfos:[{minValue:-9007199254740991,maxValue:le,symbol:$(s,{type:t.symbolType,color:c.noDataColor,size:A(c,s),outline:G(c,s,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}})}],defaultLabel:d?u.other:null,defaultSymbol:d?$(s,{type:t.symbolType,color:c.noDataColor,size:A(c,s),outline:G(c,s,p),meshInfo:{colorMixMode:t.colorMixMode,edgesType:t.edgesType}}):null,field:m,normalizationType:r,normalizationField:l,valueExpression:t.valueExpression,valueExpressionTitle:t.valueExpressionTitle,visualVariables:f,authoringInfo:e.authoringInfo&&e.authoringInfo.clone()}),visualVariable:e.visualVariable.clone(),statistics:e.statistics,defaultValuesUsed:e.defaultValuesUsed,colorScheme:ae(e.colorScheme),basemapId:e.basemapId,basemapTheme:e.basemapTheme}}async function Ve(e){const i=await te(e),{view:a,field:r,valueExpression:o,minValue:n,maxValue:l,layer:s,normalizationField:t,signal:u,filter:m,statistics:d}=i,c=t?"field":void 0,p=await(d??M({layer:s,field:r,valueExpression:o,sqlExpression:i.sqlExpression,sqlWhere:i.sqlWhere,normalizationType:c,normalizationField:t,minValue:n,maxValue:l,filter:m,view:a,signal:u})),f=s,y=r&&"function"!=typeof r?f.getField(r):null;return ze(i,p,f.geometryType,N(y))}async function Ie(e){const{view:a,filter:r,creatorParameters:o,renderer:n,signal:l}=await ve(e),s=n.authoringInfo?.clone(),t=s?.visualVariables.find((e=>"color"===e.type)),u=n.visualVariables?.find((e=>"color"===e.type)),{field:m,normalizationField:d,valueExpression:c,theme:p,layer:f}=o,y=await M({layer:f,field:m,valueExpression:c,normalizationField:d,filter:r,view:a,signal:l}),v=m&&"function"!=typeof m?f.getField(m):null,{values:h}=xe(y,p,N(v),"high-to-low"===p);if(h.length!==u.stops.length)throw new i("regenerate-color-visual-variable:invalid-parameters","Visual variable is invalid");return u.stops.forEach(((e,i)=>e.value=h[i])),t&&(t.minSliderValue=y.min,t.maxSliderValue=y.max),{visualVariable:u,authoringInfo:s,statistics:y}}function Se(i,r){const o=i.colorsForClassBreaks;if(o?.length)for(const e of o)if(e.numClasses===r)return a(e.colors);return e(i.colors,r)}async function Me(e,a){const r=await o("esri/smartMapping/t9n/smartMapping"),l=e.layer,s=e.defaultSymbolEnabled,u=l.geometryType,d=e.classificationMethod,c="standard-deviation"===d,p=await ge({basemap:e.basemap,geometryType:u,theme:c?"above-and-below":null,colorScheme:e.colorScheme,worldScale:!!e.symbolType?.includes("3d-volumetric"),view:e.view}),f=p.scheme,{result:y,outlineResult:v}=a,h=y.classBreakInfos,w=e.normalizationType;if(!f)throw new i("color-class-breaks-renderer:insufficient-info","Unable to find color scheme");const b=Se(f,h.length);if(!b||b.length!==h.length)throw new i("color-class-breaks-renderer:insufficient-info","Color scheme does not have enough colors");const g=v?.opacity,T=new n({classBreakInfos:h.map(((i,a)=>({minValue:i.minValue,maxValue:i.maxValue,symbol:$(u,{type:e.symbolType,color:b[a],size:A(f,u),outline:G(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}),label:i.label}))),defaultLabel:s?r.other:null,defaultSymbol:s?$(u,{type:e.symbolType,color:f.noDataColor,size:A(f,u),outline:G(f,u,g),meshInfo:{colorMixMode:e.colorMixMode,edgesType:e.edgesType}}):null,field:e.field,valueExpression:e.valueExpression,valueExpressionTitle:e.valueExpressionTitle,normalizationType:w,normalizationField:e.normalizationField,normalizationTotal:"percent-of-total"===w?y.normalizationTotal:void 0,legendOptions:e.legendOptions,authoringInfo:new t({type:"class-breaks-color",classificationMethod:d,standardDeviationInterval:e.standardDeviationInterval})});return c||m({classBreakInfos:T.classBreakInfos,classificationMethod:d,normalizationType:w,round:!0}),v?.visualVariables?.length&&(T.visualVariables=v.visualVariables.map((e=>e.clone()))),{renderer:T,colorScheme:ae(f),classBreaksResult:y,defaultValuesUsed:a.defaultValuesUsed,basemapId:p.basemapId,basemapTheme:p.basemapTheme}}async function Oe(e){const i=await ue(e),{layer:a,view:r,signal:o,filter:n}=i,[l,s,t]=await Promise.all([Ve(fe(i)),i.outlineOptimizationEnabled?v({layer:a,view:r,signal:o,filter:n}).catch(O):null,i.sizeOptimizationEnabled?h({layer:a,view:r,signal:o,filter:n}).catch(O):null]),u=i.normalizationField;return Ee(l,s,t,u?"field":void 0,u,a.geometryType,i)}async function Be(e){const{renderer:i,view:a,signal:r,filter:o,creatorParameters:n}=await he(e),{layer:l,outlineOptimizationEnabled:s,sizeOptimizationEnabled:t}=n,[u,m,d]=await Promise.all([Ie(e),s?v({layer:l,view:a,signal:r,filter:o}).catch(O):null,t?h({layer:l,view:a,signal:r,filter:o}).catch(O):null]);return w(i,u.visualVariable,b),w(i,m?.visualVariables,g),w(i,d?.minSize,T),x(i,u.authoringInfo,"color"),{renderer:i}}async function je(e){const i=await me(e);return Me(i,await B(de(i),i.outlineOptimizationEnabled))}async function ke(e){const{renderer:a,creatorParameters:r}=await we(e),{normalizationType:o,outlineOptimizationEnabled:n,classificationMethod:l}=r,{result:s,outlineResult:t}=await B(de(r),n),u=s.classBreakInfos;if(r.numClasses!==u.length)throw new i("regenerate-color-class-breaks-renderer:insufficient-info","The number of class breaks generated does not match the number of class breaks in the renderer.");return a.classBreakInfos.forEach(((e,i)=>{e.minValue=u[i].minValue,e.maxValue=u[i].maxValue,e.label=u[i].label})),a.normalizationTotal="percent-of-total"===o?s.normalizationTotal:void 0,"standard-deviation"!==l&&m({classBreakInfos:a.classBreakInfos,classificationMethod:l,normalizationType:o,round:!0}),w(a,t?.visualVariables,g),{renderer:a}}function Fe(e){return ce(e).then((e=>({renderer:new l({field:"RGB",pointsPerInch:e.density??void 0,pointSizeAlgorithm:j(e.size)})})))}async function qe(e){const i=await pe(e),a=i.statistics??await M({layer:i.layer,field:i.field,signal:i.signal}),r=await Te(a,i);return{renderer:new s({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:j(i.size),stops:r.stops}),basemapId:r.basemapId,basemapTheme:r.basemapTheme,statistics:r.statistics,defaultValuesUsed:r.defaultValuesUsed,colorScheme:r.colorScheme}}async function Ce(e){const i=await ye(e),{defaultSymbolEnabled:a,view:r,startTime:o,endTime:n,symbolType:l,colorMixMode:s,edgesType:t,minValue:u,maxValue:m,signal:d,filter:c}=i,p=i.layer,[f,w,b]=await Promise.all([i.unit?{unit:i.unit,statistics:null}:y({view:r,layer:p,startTime:o,endTime:n,minValue:u,maxValue:m,signal:d,filter:c}),i.outlineOptimizationEnabled?v({layer:p,view:r,signal:d,filter:c}).catch(O):null,i.sizeOptimizationEnabled?h({layer:p,view:r,signal:d,filter:c}).catch(O):null]),{unit:g,statistics:T}=f,{valueExpression:x,title:z}=await k(i,g),E=await Ve(fe({layer:p,basemap:i.basemap,valueExpression:x,symbolType:l,statistics:T,legendOptions:{title:z},colorScheme:i.colorScheme,theme:i.theme,view:r,minValue:i.minValue,maxValue:i.maxValue,filter:c,signal:d})),V={layer:p,valueExpression:x,defaultSymbolEnabled:a,symbolType:l,colorMixMode:s,edgesType:t},I=await Ee(E,w,b,null,null,p.geometryType,V),S=I.renderer.authoringInfo?.visualVariables;return S?.forEach((e=>F(e,o,n,g))),{...I,unit:g}}async function Ue(e){const{renderer:i,creatorParameters:a}=await be(e),{layer:r,outlineOptimizationEnabled:o,sizeOptimizationEnabled:n,startTime:l,endTime:s,theme:t,view:u,signal:m,filter:d}=a,[c,p,f]=await Promise.all([y({view:u,layer:r,startTime:l,endTime:s,signal:m,filter:d}),o?v({layer:r,view:u,signal:m,filter:d}).catch(O):null,n?h({layer:r,view:u,signal:m,filter:d}).catch(O):null]),{unit:x,statistics:z}=c,{valueExpression:E,title:V}=await k(a,x),I=await Ve(fe({layer:r,valueExpression:E,statistics:z,legendOptions:{title:V},theme:t,view:u,filter:d,signal:m}));w(i,I.visualVariable,b),w(i,p?.visualVariables,g),w(i,f?.minSize,T),i.authoringInfo=I.authoringInfo.clone();const S=i.authoringInfo?.visualVariables;return S?.forEach((e=>F(e,l,s,x))),{renderer:i}}export{Ce as createAgeRenderer,je as createClassBreaksRenderer,Oe as createContinuousRenderer,qe as createPCContinuousRenderer,Fe as createPCTrueColorRenderer,Ve as createVisualVariable,Ue as regenerateAgeRenderer,ke as regenerateClassBreaksRenderer,Be as regenerateContinuousRenderer,Ie as regenerateVisualVariable};
