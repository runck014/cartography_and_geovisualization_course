/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../Color.js";import{createUniqueColors as a}from"../../core/colorUtils.js";import r from"../../core/Error.js";import t from"../../renderers/HeatmapRenderer.js";import o from"../../renderers/support/AuthoringInfo.js";import s from"../../renderers/support/HeatmapColorStop.js";import{gaussianBlurRadiusPxToKernelDensityRadiusPt as i}from"../../renderers/support/heatmapUtils.js";import{verifyBasicFieldValidity as n,getBasemapInfo as m}from"./support/utils.js";import l from"../statistics/heatmapStatistics.js";import{getFieldsList as p}from"../support/utils.js";import{LayerType as u,createLayerAdapter as c,getLayerTypeLabels as f}from"../support/adapters/support/layerUtils.js";import{cloneScheme as d,getSchemes as h}from"../symbology/heatmap.js";const w=.01;async function y(e){if(!e?.layer||!e.view)throw new r("heatmap-renderer:missing-parameters","'layer' and 'view' parameters are required");const a={...e,layer:e.layer,view:e.view};a.radius??=null==a.blurRadius?18:i(a.blurRadius),a.minRatio??=.01,a.maxRatio??=1,a.fadeRatio??=.2,a.fadeToTransparent??=!0;const t=[u.CSVLayer,u.FeatureLayer,u.GeoJSONLayer,u.KnowledgeGraphSublayer,u.OGCFeatureLayer,u.OrientedImageryLayer,u.ParquetLayer,u.StreamLayer,u.WFSLayer],o=c(a.layer,t);if(!o)throw new r("heatmap-renderer:invalid-parameters","'layer' must be one of these types: "+f(t).join(", "));a.layer=o;const s=null!=a.signal?{signal:a.signal}:null;await o.load(s);const m=await p({field:a.field}),l=n(o,m,"heatmap-renderer:invalid-parameters");if(l)throw l;return a}async function b(e){let a=e.scheme,r=null,t=null;const o=await m(e.basemap,e.view);if(r=null!=o.basemapId?o.basemapId:null,t=null!=o.basemapTheme?o.basemapTheme:null,a)return{scheme:d(a),basemapId:r,basemapTheme:t};const s=h({basemapTheme:t});return s&&(a=s.primaryScheme,r=s.basemapId,t=s.basemapTheme),{scheme:a,basemapId:r,basemapTheme:t}}async function g(r,i){const{field:n,basemap:m,radius:l,fadeToTransparent:p,heatmapScheme:u,view:c}=i,{scheme:f,basemapId:h,basemapTheme:y}=await b({basemap:m,scheme:u,view:c}),g=f.colors,R=g.length,j=null==r.min,T=j?[0,.04]:[r.min,r.max];let v;const S=i.fadeRatio??0,L=i.maxRatio??0,x=i.minRatio??0,C=(L-x)/(R-1),U=g[0],E=p?x:w,F=[new s({ratio:0,color:new e([U.r,U.g,U.b,0])}),new s({ratio:w,color:new e([U.r,U.g,U.b,0])}),new s({ratio:E,color:new e([U.r,U.g,U.b,E])})];a(g,R).forEach(((e,a)=>{const r=x+C*a;F.push(new s({ratio:r,color:e}))})),p&&(I(F,S),v=new o({fadeRatio:S}));return{renderer:new t({authoringInfo:v,radius:l,colorStops:F,field:n,minDensity:T[0],maxDensity:T[1]}),statistics:r,defaultValuesUsed:j,scheme:d(f),basemapId:h,basemapTheme:y}}function I(e,a){const r=10*(1-a)+1,t=e.length-3,o=e[2].color.a;e.forEach(((e,s)=>{if(s<=2)return;const{color:i}=e,n=(s-3)/t;i.a=0===a?1:Math.min(Math.max(n*r+n+o,o),1)}))}async function R(e){const a=await y(e);return g(a.statistics??await l({layer:a.layer,field:a.field,radius:a.radius,view:a.view,filter:a.filter,signal:a.signal}),a)}function j(e){const{fadeRatio:a,renderer:r}=e,t=r.clone(),s=a??(t?.authoringInfo?.fadeRatio||0);return I(t.colorStops,s),t.authoringInfo?t.authoringInfo.fadeRatio=s:t.authoringInfo=new o({fadeRatio:s}),t}export{R as createRenderer,j as updateRenderer};
