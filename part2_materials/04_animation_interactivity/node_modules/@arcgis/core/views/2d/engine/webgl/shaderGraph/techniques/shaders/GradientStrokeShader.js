/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import has from"../../../../../../../core/has.js";import{location as i,uniform as o,UniformGroup as s,input as r}from"../../GraphShaderModule.js";import{ifElse as n,greaterThan as a,Float as d,dot as l,mix as p,Vec2 as m,clamp as c,texture2D as h,step as u,length as y,Vec4 as g}from"../../graph/glsl.js";import{bitset as v}from"../line/gradientStrokeConstants.js";import{BaseHittestVertexInput as f}from"./AFeatureShader.js";import{LineVertexInput as w,LineFragmentInput as b,LineShader as x,getLineVertexData as S,getLineAntialiasing as j}from"./LineShader.js";import{MosaicInfo as L}from"./MosaicInfo.js";import{getBit as A,getBitBool as D,oneMinus as z}from"./utils.js";class F extends w{}t([i(9,d)],F.prototype,"accumulatedDistance",void 0),t([i(10,d)],F.prototype,"totalLength",void 0),t([i(11,d)],F.prototype,"gradientSize",void 0),t([i(12,m)],F.prototype,"segmentDirection",void 0),t([i(13,g)],F.prototype,"tlbr",void 0);class C extends b{}class G extends s{}t([o(d)],G.prototype,"isColorPass",void 0);class I extends x{constructor(){super(...arguments),this.type="GradientStrokeShader"}vertex(t,e){const{totalLength:i,gradientSize:o,segmentDirection:s,tlbr:r}=t,p=S(this,t),m=A(t.bitset,v.isAlongLine),c=i.divide(this.view.displayZoomFactor),h=n(D(t.bitset,v.isAbsoluteSize),(()=>{const t=n(a(m,new d(.5)),c,p.halfWidth);return o.divide(t)}),o),u=t.accumulatedDistance.divide(this.view.displayZoomFactor).add(l(s,p.scaledOffset)).divide(c),y=r.divide(this.mosaicInfo.size.xyxy);return{...p,tlbr:y,relativePositionAlongLine:u,relativeGradientSize:h,isAlongLine:A(t.bitset,v.isAlongLine),isDiscrete:A(t.bitset,v.isDiscrete),...this.maybeRunHittest(t,e,p.halfWidth)}}fragment(t){const{isAlongLine:e,isDiscrete:i,relativePositionAlongLine:o,relativeGradientSize:s,normal:r,tlbr:l}=t,g=j(t,this.antialiasingControls.blur),v=new d(.5).multiply(r.y).add(new d(.5)),f=n(a(e,new d(.5)),o,v),w=n(a(i,new d(.5)),s.subtract(1),new d(0)),b=z(f.add(w).divide(s)),x=p(l.xy,l.zw,new m(c(b,new d(0),new d(1)),.5)),S=h(this.mosaicInfo.texture,x),L=t.opacity.multiply(g),A=this.getFragmentOutput(S.multiply(L),t),D=u(new d(.5),this.technique.isColorPass).multiply(has("gradient-depth-epsilon")),F=u(new d(0),r.y).multiply(new d(has("gradient-depth-bias")).subtract(D));return A.glFragDepth=c(y(r).add(F),new d(0),new d(1)),A}}t([o(L)],I.prototype,"mosaicInfo",void 0),t([o(G)],I.prototype,"technique",void 0),t([e(0,r(F)),e(1,r(f))],I.prototype,"vertex",null);export{C as GradientStrokeFragmentInput,I as GradientStrokeShader,F as GradientStrokeVertexInput};
