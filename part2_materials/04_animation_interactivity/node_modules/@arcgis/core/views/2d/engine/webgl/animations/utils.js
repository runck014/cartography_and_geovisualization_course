/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../../../Color.js";import{getStartGroup as o,getRandomValue as t}from"../grouping.js";import{hydrate as i}from"./infos.js";import{instructions as n}from"./instructions.js";function r(e){return a(e.map((e=>f(e))).map((e=>i(e).simplify())))}function s(e){const o=[];return o.push(e.transform),o.push(e.fromColor),o.push(e.toColor),o.push(e.colorMix),o.push(e.toOpacity),o.push(e.opacityMix),o}function a(e){const o=[],t=[];let i=0;for(const r of e){const s=[...r.encode(),...n.ret.encode()];o.push([i+e.length,0,0,0]),t.push(...s),i+=s.length}return[...o,...t]}async function c(e,o){const t=e;let i;if("number"==typeof t||"string"==typeof t||"boolean"==typeof t)i=t;else if(Array.isArray(t))i=await Promise.all(t.map((e=>c(e,o))));else if("object"==typeof t)if("valueExpressionInfo"in t){const{valueExpressionInfo:e}=t,{expression:n}=e;i={...t,computed:await o.createComputedField({expression:n})}}else{i={};for(const e in t)i[e]=await c(t[e],o)}return i}function f(i,n,r){function s(o){if(!("computed"in o))return o;let t=o.computed.readWithDefault(n,r,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if("string"==typeof t){const o=e.fromString(t);o&&(t=[o.r,o.g,o.b,o.a])}return t}const a=i;let c;if("number"==typeof a||"string"==typeof a||"boolean"==typeof a)c=a;else if(Array.isArray(a))c=a.map((e=>f(e,n,r)));else if("object"==typeof a)if("type"in a&&null!=a.type&&"Process"===a.type)switch(a.op){case"ArcadeColor":{const e=f(a.value,n,r);p(Array.isArray(e)&&4===e.length);c=[e[0]/255,e[1]/255,e[2]/255,e[3]]}break;case"Transparency":{const e=f(a.value,n,r);p("number"==typeof e),c=1-e/100}break;case"Divide":case"Add":{const e=f(a.left,n,r);p("number"==typeof e);const o=f(a.right,n,r);switch(p("number"==typeof o),a.op){case"Divide":c=e/o;break;case"Add":c=e+o}}break;case"Random":{const e=f(a.seed,n,r),i=f(a.min,n,r),s=f(a.max,n,r),l=n.getObjectId(),p=o(l||0);c=i+t(p,e)*(s-i)}break;case"Cond":{const e=f(a.condition,n,r),o=f(a.ifTrue,n,r),t=f(a.ifFalse,n,r);c=e?o:t}break;case"MatchWinding":{const e=f(a.sign,n,r);let o=f(a.angle,n,r);if(e>0)for(;o<0;)o+=2*Math.PI;else for(;o>0;)o-=2*Math.PI;c=o}}else if("computed"in a)c=s(a);else{c={};for(const e in a)c[e]=f(a[e],n,r)}return c}function*l(e){const o=e;if(Array.isArray(o))for(const t of o)yield*l(t);else if("object"==typeof o)if("type"in o&&null!=o.type&&"Process"===o.type)switch(o.op){case"ArcadeColor":case"Transparency":yield*l(o.value);break;case"Divide":case"Add":yield*l(o.left),yield*l(o.right);break;case"Random":yield*l(o.seed),yield*l(o.min),yield*l(o.max);break;case"Cond":yield*l(o.condition),yield*l(o.ifTrue),yield*l(o.ifFalse);break;case"MatchWinding":yield*l(o.sign),yield*l(o.angle)}else if("computed"in o)yield o.computed;else for(const t in o)yield*l(o[t])}function p(e){if(!e)throw new Error("Assertion failed.")}export{p as assert,c as compileAnimationParam,s as createParamList,a as encodeParamList,r as fromJSON,l as getAnimationExpressions,f as resolveToAnimationInfo};
