/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{VertexInput as o,location as s,FragmentInput as r,UniformGroup as i,uniform as n,GraphShaderModule as a,define as p,FragmentOutput as l,input as u}from"../../GraphShaderModule.js";import{Vec4 as d,texture2D as m,Float as c,Vec2 as y,Sampler2D as v}from"../../graph/glsl.js";import{getHeatmapCompressionFactor as x}from"./heatmapUtils.js";class g extends o{}t([s(0,y)],g.prototype,"position",void 0);class f extends r{}class h extends i{}t([n(v)],h.prototype,"texture",void 0),t([n(y)],h.prototype,"minAndInvRange",void 0),t([n(c)],h.prototype,"normalization",void 0);class w extends i{}t([n(v)],w.prototype,"texture",void 0);class b extends a{constructor(){super(...arguments),this.type="HeatmapResolveShader",this.usesHalfFloatPrecision=!1}vertex(t){return{glPosition:new d(t.position.multiply(2).subtract(1),1,1),uv:t.position}}fragment(t){const{accumulatedDensity:e,gradient:o}=this;let s=m(e.texture,t.uv).r.divide(new c(x(this.usesHalfFloatPrecision)));s=s.multiply(e.normalization),s=s.subtract(e.minAndInvRange.x).multiply(e.minAndInvRange.y);const r=m(o.texture,new y(s,.5)),i=new l;return i.fragColor=new d(r.rgb.multiply(r.a),r.a),i}}t([p],b.prototype,"usesHalfFloatPrecision",void 0),t([n(h)],b.prototype,"accumulatedDensity",void 0),t([n(w)],b.prototype,"gradient",void 0),t([e(0,u(g))],b.prototype,"vertex",null),t([e(0,u(f))],b.prototype,"fragment",null);export{h as AccumulatedDensity,w as Gradient,f as HeatmapResolveFragmentInput,b as HeatmapResolveShader,g as HeatmapResolveVertexInput};
