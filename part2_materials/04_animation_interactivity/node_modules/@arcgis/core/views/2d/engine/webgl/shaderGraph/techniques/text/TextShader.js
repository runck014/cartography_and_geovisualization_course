/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{minMaxZoomPrecisionFactor as i,labelPlacementOffsetPadding as o}from"../../../definitions.js";import{location as s,option as l,uniform as a,define as r,ComputeVertexInput as n,input as p}from"../../GraphShaderModule.js";import{abs as d,min as u,Float as y,floor as m,step as c,Vec3 as h,Mat3 as f,Vec2 as v,ifElse as w,equal as b,or as x,lessThanEqual as V,greaterThan as S,Bool as g,Vec4 as z,texture2D as j,smoothstep as R,Int as C,bitRShift as O,bitAnd as M}from"../../graph/glsl.js";import{FeatureVertexInput as L,FeatureFragmentInput as A,AFeatureShader as H}from"../shaders/AFeatureShader.js";import{bitsetTextIsBackground as P,sdfFontSize as N,bitsetTextIsMapAligned as U,maxSdfDistance as T}from"../shaders/constants.js";import{distPointTriangle as _,failHittest as k}from"../shaders/hittestUtils.js";import{MosaicInfo as I}from"../shaders/MosaicInfo.js";import{getBit as D}from"../shaders/utils.js";import{VisualVariableColor as B}from"../shaders/VisualVariableColor.js";import{VisualVariableOpacity as q}from"../shaders/VisualVariableOpacity.js";import{VisualVariableRotation as E}from"../shaders/VisualVariableRotation.js";import{VisualVariableSizeMinMaxValue as F}from"../shaders/VisualVariableSizeMinMaxValue.js";import{VisualVariableSizeScaleStops as W}from"../shaders/VisualVariableSizeScaleStops.js";import{VisualVariableSizeStops as G}from"../shaders/VisualVariableSizeStops.js";import{VisualVariableSizeUnitValue as Z}from"../shaders/VisualVariableSizeUnitValue.js";import{getVisualVariableSize as J,getVisualVariableRotation as K}from"../shaders/vvUtils.js";const Q=360/254;var X;!function(t){t[t.Color=0]="Color",t[t.Outline=1]="Outline",t[t.Halo=2]="Halo"}(X||(X={}));class Y extends L{}t([s(3,z)],Y.prototype,"color",void 0),t([s(4,v)],Y.prototype,"offset",void 0),t([s(5,v)],Y.prototype,"textureUV",void 0),t([s(6,y)],Y.prototype,"fontSize",void 0),t([s(7,y)],Y.prototype,"referenceSize",void 0),t([s(8,z)],Y.prototype,"outlineColor",void 0),t([s(9,z)],Y.prototype,"haloColor",void 0),t([s(10,v)],Y.prototype,"outlineAndHaloSize",void 0),t([s(11,v)],Y.prototype,"zoomRange",void 0),t([s(12,y)],Y.prototype,"clipAngle",void 0),t([s(13,z)],Y.prototype,"referenceSymbol",void 0);class $ extends n{}t([s(14,v)],$.prototype,"offsetNextVertex1",void 0),t([s(15,v)],$.prototype,"offsetNextVertex2",void 0);class tt extends A{}class et extends H{constructor(){super(...arguments),this.type="TextShader",this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"]},this.textRenderPassType=X.Color,this.isBackgroundPass=!1,this.isLabel=!1}clipLabel(t,e,o){const s=e.multiply(Q),l=d(this.view.rotation.subtract(s)),a=u(new y(360).subtract(l),l);let r=new y(0);const n=m(this.view.currentZoom.multiply(i)).divide(i),p=t.x,h=t.y,f=new y(1).subtract(c(p,n)).multiply(2),v=c(new y(90),a).multiply(2),w=new y(2).multiply(new y(1).subtract(c(n,h)));return r=r.add(o.multiply(f)),r=r.add(o.multiply(v)),r=r.add(w),r}vertex(t,e){const i=D(t.bitset,P),s=new y(1).subtract(i);let l=t.fontSize,a=l.divide(N);const r=this.textRenderPassType===X.Outline?t.outlineColor:this.textRenderPassType===X.Halo?t.haloColor:this._getVertexColor(t),n=this.isLabel?this.storage.getLabelVisibility(t.id):new y(1),p=this.isLabel?r.multiply(n):r,d=this.view.displayViewScreenMat3.multiply(new h(t.pos,1));let u=t.offset,m=new y(1),c=f.identity(),j=new v(0);if(this.isLabel){if(!t.referenceSymbol)throw new Error("InternalError: Optional attribute 'referenceSymbol' expected for labels");const e=t.referenceSymbol,i=e.xy,s=e.z,l=this._unpackDirection(e.w),a=J(this,t.id,s).divide(2),r=l.multiply(a.add(o));j=i.add(r),u=u.add(j)}else{m=J(this,t.id,t.referenceSize).divide(t.referenceSize),l=l.multiply(m),a=a.multiply(m),u=u.multiply(m),c=K(this,t.id),u=c.multiply(new h(u,0)).xy}const R=D(t.bitset,U),C=this._getViewRotationMatrix(R).multiply(new h(u,0));let O=this.isLabel?this.clipLabel(t.zoomRange,t.clipAngle,R):this.clip(t.id,t.zoomRange);O=this.isBackgroundPass?O.add(s.multiply(2)):O.add(i.multiply(2));let M=new y(0);if(this.textRenderPassType===X.Outline){O=O.add(w(b(t.outlineAndHaloSize.x,new y(0)),new y(2),new y(0)));M=new y(t.outlineAndHaloSize.x).divide(a).divide(T)}if(this.textRenderPassType===X.Halo){const e=t.outlineAndHaloSize.x,i=new y(t.outlineAndHaloSize.y);O=O.add(w(b(i,new y(0)),new y(2),new y(0)));M=i.add(e).divide(a).divide(T)}const L=this.isLabel?x(S(O,new y(1)),V(n,new y(0))):new g(!1);return{glPosition:new z(d.xy.add(C.xy),O,1),color:p,size:a,textureUV:t.textureUV.divide(this.mosaicInfo.size),antialiasingWidth:new y(.105*N).divide(l).divide(this.view.pixelRatio),outlineDistanceOffset:M,...this.maybeRunHittest(t,e,{vvSizeAdjustment:m,vvRotation:c,labelOffset:j,labelClipped:L})}}_getViewRotationMatrix(t){const e=this.view.displayViewMat3,i=this.view.displayMat3,o=new y(1).subtract(t);return e.multiply(t).add(i.multiply(o))}fragment(t){const e=new y(2/8),i=new y(1).subtract(e),o=j(this.mosaicInfo.texture,t.textureUV).a;let s=i.subtract(t.outlineDistanceOffset);this.highlight&&(s=s.divide(2));const l=t.antialiasingWidth,a=R(s.subtract(l),s.add(l),o);return this.getFragmentOutput(t.color.multiply(a),t)}hittest(t,e,{vvSizeAdjustment:i,vvRotation:o,labelOffset:s,labelClipped:l}){let a,r,n;this.isLabel?(a=new h(t.offset.add(s),0),r=new h(e.offsetNextVertex1.add(s),0),n=new h(e.offsetNextVertex2.add(s),0)):(a=o.multiply(new h(t.offset.multiply(i),0)),r=o.multiply(new h(e.offsetNextVertex1.multiply(i),0)),n=o.multiply(new h(e.offsetNextVertex2.multiply(i),0)));const{viewMat3:p,tileMat3:d}=this.view,u=p.multiply(d).multiply(new h(t.pos,1)),y=u.add(d.multiply(a)).xy,m=u.add(d.multiply(r)).xy,c=u.add(d.multiply(n)).xy,f=_(this.hittestRequest.position,y.xy,m.xy,c.xy);return this.isLabel?w(l,k(this.hittestRequest),f):f}_unpackDirection(t){const e=new C(t),i=O(e,new C(2)),o=M(e,new C(3));return new v(new y(i).subtract(1),new y(o).subtract(1))}_getVertexColor(t){let e=t.color;if(this.visualVariableColor){const i=this.storage.getColorValue(t.id);e=this.visualVariableColor.getColor(i,t.color,new g(!1))}if(this.visualVariableOpacity){const i=this.storage.getOpacityValue(t.id),o=this.visualVariableOpacity.getOpacity(i);e=e.multiply(o)}return e}}t([l(B)],et.prototype,"visualVariableColor",void 0),t([l(q)],et.prototype,"visualVariableOpacity",void 0),t([l(E)],et.prototype,"visualVariableRotation",void 0),t([l(F)],et.prototype,"visualVariableSizeMinMaxValue",void 0),t([l(W)],et.prototype,"visualVariableSizeScaleStops",void 0),t([l(G)],et.prototype,"visualVariableSizeStops",void 0),t([l(Z)],et.prototype,"visualVariableSizeUnitValue",void 0),t([a(I)],et.prototype,"mosaicInfo",void 0),t([r],et.prototype,"textRenderPassType",void 0),t([r],et.prototype,"isBackgroundPass",void 0),t([r],et.prototype,"isLabel",void 0),t([e(0,p(Y)),e(1,p($))],et.prototype,"vertex",null),t([e(0,p(tt))],et.prototype,"fragment",null);export{tt as TextFragmentInput,X as TextRenderPassType,et as TextShader,Y as TextVertexInput};
