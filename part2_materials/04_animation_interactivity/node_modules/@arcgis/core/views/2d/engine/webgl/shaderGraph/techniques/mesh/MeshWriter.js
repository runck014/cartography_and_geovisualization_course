/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{GeometryCursor as e}from"../../../../../../../geometry/GeometryCursor.js";import{CIMEffectHelper as t}from"../../../../../../../symbols/cim/effects/CIMEffectHelper.js";import{loadGeometryEngine as r,getGeometryEngine as a}from"./loadGeometryEngine.js";import{MeshWriterVertexPack as s}from"./MeshWriterVertexPack.js";function i(e){if(!e)return!1;for(const t of e)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}class c{constructor(e,t,r,a){this._instanceId=e,this._evaluator=t,this._enabledOptionalAttributes=r,this._viewParams=a,this._evaluator.evaluator=e=>this.vertexSpec.createComputedParams(e)}get _vertexPack(){if(!this._cachedVertexPack){const e=s.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||e.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=e}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(e){this._references=e}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){i(this._evaluator.inputMeshParams.effects?.effectInfos)&&await r()}enqueueRequest(e,t,r){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(e,t,r)}write(r,s,i,c,n){this.ensurePacked(s,i,c);const o=this.evaluatedMeshParams.effects;if(!o||0===o.length)return void this._write(r,i,void 0,n);const u=i.readGeometryForDisplay()?.clone();if(!u)return;const h=e.fromOptimizedCIM(u,i.geometryType),f=a();h.invertY();const l=r.id||"",m=t.executeEffects(o,h,l,f,this._preventEffectClipping);let v;for(;v=m.next();)v.invertY(),this._write(r,i,v,n)}ensurePacked(e,t,r){if(!this._evaluator.hasDynamicProperties)return;const a=this._evaluator.evaluateMeshParams(e,t,r);this._vertexPack.pack(a,this._viewParams)}hasArcadeDependency(e){return this._evaluator.hasArcadeDependency(e)}_writeVertex(e,t,r,a,s){const i=this.evaluatedMeshParams;this._vertexPack.writeVertex(e,t,r,a,i,s)}}export{c as MeshWriter};
