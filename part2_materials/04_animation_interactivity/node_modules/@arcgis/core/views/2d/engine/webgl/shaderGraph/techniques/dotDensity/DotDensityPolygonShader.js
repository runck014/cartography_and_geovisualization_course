/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{tileSize as o}from"../../../definitions.js";import{uniform as s,location as i,UniformGroup as r,define as l,FragmentOutput as d,input as n}from"../../GraphShaderModule.js";import{FixedArray as a,Vec4 as p,Mat3 as h,Vec3 as c,texture2D as u,Mat4 as m,step as y,Float as v,dot as w,max as x,Sampler2D as f}from"../../graph/glsl.js";import{FeatureVertexInput as g,FeatureFragmentInput as A,AFeatureShader as D}from"../shaders/AFeatureShader.js";import{failHittest as T}from"../shaders/hittestUtils.js";import{max4 as b}from"../shaders/utils.js";class j extends g{}t([i(3,v)],j.prototype,"inverseArea",void 0);class C extends A{}class V extends r{}t([s(a.ofType(p,2))],V.prototype,"isActive",void 0),t([s(a.ofType(p,8))],V.prototype,"colors",void 0),t([s(v)],V.prototype,"dotValue",void 0);class _ extends r{}t([s(f)],_.prototype,"dotTexture0",void 0),t([s(f)],_.prototype,"dotTexture1",void 0),t([s(v)],_.prototype,"tileZoomFactor",void 0),t([s(v)],_.prototype,"pixelRatio",void 0),t([s(v)],_.prototype,"tileDotsOverArea",void 0);class F extends D{constructor(){super(...arguments),this.type="DotDensityPolygonShader"}_dotThreshold(t,e,o){return t.divide(e).divide(o)}vertex(t){const e=new h(2/o,0,0,0,-2/o,0,-1,1,1).multiply(new c(t.pos,1)),s=this.clip(t.id),i=new p(e.xy,s,1),r=this.storage.getVVData(t.id).multiply(this.instance.isActive.get(0)).multiply(t.inverseArea),l=this.storage.getDataDrivenData0(t.id).multiply(this.instance.isActive.get(1)).multiply(t.inverseArea),d=this.draw.tileZoomFactor.multiply(o).divide(this.draw.pixelRatio),n=this._dotThreshold(r,this.instance.dotValue,this.draw.tileDotsOverArea),a=this._dotThreshold(l,this.instance.dotValue,this.draw.tileDotsOverArea),u=t.pos.add(.5).divide(d);return{glPosition:i,color:new p(0,0,0,0),textureCoords:u,thresholds0:n,thresholds1:a}}fragment(t){const e=new d,o=u(this.draw.dotTexture0,t.textureCoords),s=u(this.draw.dotTexture1,t.textureCoords),i=t.thresholds0.subtract(o),r=t.thresholds1.subtract(s);let l;const n=m.fromColumns(this.instance.colors[0],this.instance.colors[1],this.instance.colors[2],this.instance.colors[3]),a=m.fromColumns(this.instance.colors[4],this.instance.colors[5],this.instance.colors[6],this.instance.colors[7]);if(this.blending){const t=y(new v(0),i),e=y(new v(0),r),o=w(t,i).add(w(e,r)),s=y(o,new v(0)),d=new v(1).subtract(s),p=o.add(s),h=i.multiply(t).divide(p),c=r.multiply(e).divide(p),u=n.multiply(h).add(a.multiply(c));l=d.multiply(u)}else{const t=x(b(i),b(r)),e=y(t,new v(0)),o=new v(1).subtract(e),s=y(t,i),d=y(t,r),p=n.multiply(s).add(a.multiply(d));l=o.multiply(p)}return e.fragColor=l,e}hittest(t){return T(this.hittestRequest)}}t([l],F.prototype,"blending",void 0),t([s(V)],F.prototype,"instance",void 0),t([s(_)],F.prototype,"draw",void 0),t([e(0,n(j))],F.prototype,"vertex",null),t([e(0,n(A))],F.prototype,"fragment",null);export{_ as DotDensityPolygonDrawUniforms,C as DotDensityPolygonFragmentInput,V as DotDensityPolygonInstanceUniforms,F as DotDensityPolygonShader,j as DotDensityPolygonVertexInput};
