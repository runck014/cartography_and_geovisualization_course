/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{destroyMaybe as e}from"../../../../core/maybe.js";import{notDeepEqual as t}from"../../../../core/object.js";import{throwIfNotAbortError as s,throwIfAborted as r}from"../../../../core/promiseUtils.js";import{diff as i}from"../../../../core/accessorSupport/diffUtils.js";import{ignoreConnectionErrors as a}from"../../../../core/workers/utils.js";import o from"../../../../geometry/SpatialReference.js";import{MultiTileMeshData as n}from"../../engine/webgl/mesh/MultiTileMeshData.js";import{FeatureMeshFactory as c}from"../../engine/webgl/mesh/factories/FeatureMeshFactory.js";import{ResourceProxy as h}from"../../engine/webgl/mesh/factories/ResourceProxy.js";import{MeshWriterRegistry as u}from"../../engine/webgl/shaderGraph/techniques/mesh/MeshWriterRegistry.js";import{MatcherContext as p}from"../../engine/webgl/util/MatcherContext.js";import{ProcessorTileMessageQueue as g}from"./ProcessorTileMessageQueue.js";import{BinningStrategy as y}from"./processor/BinningStrategy.js";import{ClusterStrategy as d}from"./processor/ClusterStrategy.js";import{FeatureUpdateStrategy as _}from"./processor/FeatureUpdateStrategy.js";import{TrackStrategy as l}from"./processor/TrackStrategy.js";import{AttributeStore as m}from"./support/AttributeStore.js";import{ComputedAttributeStorage as f}from"./support/ComputedAttributeStorage.js";class b{constructor(e,t){this._connection=e,this._source=t,this._version=1,this._registry=new u,this._proxy=new h({fetch:(e,t)=>this._connection.layerView.fetch(e,t),fetchDictionary:(e,t)=>this._connection.layerView.fetchDictionary(e,t)}),this._attributeStore=new m({isLocal:!1,update:e=>a(this._connection.container.updateAttributeView(e))})}destroy(){this._proxy.destroy(),this._strategy?.destroy(),this._attributeStore.destroy()}get aggregateQueryEngine(){return this._strategy?.aggregateQueryEngine}get version(){return this._version}getDisplayFeatures(e){return this._strategy?this._strategy.getDisplayFeatures(e):{features:[],aggregates:[],tracks:[]}}getDisplayIds(e){const t={};return this._strategy?(this._strategy.displayMap(e,(e=>e),((e,s,r)=>{t[r]=e})),t):t}getFeatureObjectIdsForAggregate(e){return this._strategy?this._strategy.getFeatureObjectIdsForAggregate(e):[]}onSubscribe(e){this._strategy?.onSubscribe(e)}onUnsubscribe(e){this._strategy?.onUnsubscribe(e)}async update(e,s,r,a,n){const h=e.processor,u=t(this._schema?.storage,h.storage),g=t(this._schema?.mesh.properties,h.mesh.properties),y=t(this._schema?.mesh.factory,h.mesh.factory),d=t(this._schema?.mesh.strategy,h.mesh.strategy),_=w(this._schema?.expressionProperties,h.expressionProperties),l=_.some((e=>this._attributeStore.hasArcadeDependency(e))),m=_.some((e=>this._factory?.hasArcadeDependency(e)??!1)),b=_.some((e=>this._strategy?.hasArcadeDependency(e)))||this._strategy?.isAggregate&&l,j=m||b,I=g||y||d;if(!(u||I||(m||l||b))&&!a)return!1;has("esri-2d-update-debug")&&console.debug(`Version[${this._version}] SymbolProcessor.update`,{changes:i(this._schema,h),schema:h}),this._schema=h;const x=o.fromJSON(this._source.service.outSpatialReference),v=new f({fields:this._source.metadata.fieldsIndex,spatialReference:x}),k={currentUser:h.mesh.properties.currentUser};if((u||I||l)&&(await this._attributeStore.update(h.storage,v,this._source.metadata,s),this._strategy?.invalidateAttributeData(S(h))),!a&&!I&&!j)return!1;(d||g||j)&&await this._updateStrategy(h.mesh.strategy,x,n,S(h),k),this._updateSortKey(v,"sortKey"in h.mesh.properties?h.mesh.properties.sortKey:null);const M=new p(v,this._proxy,r,this._registry);return(y||"dictionary"===h.mesh.factory.symbology.type)&&(this._factory=await c.create(M,h.mesh.factory)),this._version=s,!0}async applyOverrideUpdate(e){if(!this._strategy)return;const t=this._strategy.applyOverrideUpdate(e);for await(const r of t)try{await this._process(r)}catch(s){}}async updateChunks(){await this._doUpdateChunks(),this._strategy?.afterUpdateChunks()}async removeChunks(e){this._strategy?.removeChunks(e),this._attributeStore.incrementDisplayIdGeneration()}updateHighlight({highlights:e}){if(!this._strategy)return void this._attributeStore.setHighlight(e.map((({objectId:e,highlightFlags:t})=>({objectId:e,highlightFlags:t,displayId:-1}))),e);const t=this._strategy.displayMap(e,(({objectId:e})=>e),((e,{highlightFlags:t},s)=>({objectId:s,displayId:e,highlightFlags:t})));this._attributeStore.setHighlight(t,e)}invalidate(){this._strategy&&this._strategy.invalidate()}async _doUpdateChunks(){if(!this._strategy)return;const e=this._strategy.updateChunks(),t=[],r=new Map;for await(const a of e){let e=r.get(a.id);null==e&&(e=new g({concurrency:16,process:e=>this._process(e)}),r.set(a.id,e));const i=e.push(a).catch((e=>s(e)));t.push(i)}try{await Promise.all(t)}catch(i){}has("esri-2d-update-debug")&&console.log("SendUpdates"),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")&&console.log("SendUpdates.await")}async _updateStrategy(e,t,s,r,i){switch(this._strategy?.destroy(),e.type){case"feature":this._strategy=new _(this._source,this._attributeStore,r,i);break;case"binning":this._strategy=await y.create(e,t,this._source,this._attributeStore,r,i);break;case"cluster":this._strategy=await d.create(this._connection,e,t,this._source,this._attributeStore,r,i);break;case"track":this._strategy=await l.create(e,t,this._source,this._attributeStore,r,i)}for(const a of s)this._strategy.onSubscribe(a)}async _updateSortKey(t,s){if(this._sortInfo=e(this._sortInfo?.computed),null!=s){const e=s.byRenderer?null:await t.createComputedField(s);this._sortInfo={...s,computed:e}}}async _process(e){const t=e.subscription;if(has("esri-2d-update-debug")){const s=t.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${e.end}] Processor._process`)}const s={currentUser:this._schema?.mesh.properties.currentUser};await this._fetchResources(e,s),r(t.signal);const i=await this._write(e,t.tile.createArcadeEvaluationOptions(S(this._schema)),s),a=t.tile.tileInfoView.getLODInfoAt(t.tile.key),{message:o,transferList:n}=i.serialize(a),c={objectIdMap:null,inner:e.createMessage(o,this._version,this._attributeStore.epoch)};if(this._schema?.mesh.properties.returnMeshObjectId){c.objectIdMap={};const t=e.reader?.getCursor();if(t)for(;t.next();)c.objectIdMap[t.getDisplayId()]=t.getObjectId()}if(r(t.signal),await this._connection.container.onMessage(c,{signal:t.signal,transferList:n}),this._attributeStore.sendUpdates(),has("esri-2d-update-debug")){const s=t.tile;console.debug(`Version[${this._version}] Tile[${s.key.id}, end=${e.end}] Processor._process.await`)}}async _fetchResources(e,t){await this._fetchMatcherResources(e),await this._fetchWriterResources(e,t)}async _fetchMatcherResources(e){if(e.reader)return this._factory.enqueueMatcherRequests(this._proxy,e.reader)}async _fetchWriterResources(e,t){if(!e.reader)return;const s=e.reader.getCursor(),r=e.subscription.tile.createArcadeEvaluationOptions(S(this._schema));for(;s.next();)this._factory.enqueueWriterRequests(this._proxy,s,r,t);await this._proxy.fetchEnqueuedResources()}async _write(e,t,s){const r=e.subscription.tile,i=e.reader?.getCursor(),a=i?.getSize()??0,o=r.tileInfoView.tileInfo.isWrappable,c=r.tileInfoView.tileInfo.spatialReference.isWGS84,h=new n(r.key,this._strategy.enablePixelBuffering,o,c,a);if(!i)return h;const u=r.createArcadeEvaluationOptions(S(this._schema));for(;i.next();){const e=this._getSortKeyValue(i,t);h.entityStart(i.getDisplayId(),e),this._factory.write(h,this._proxy,i,u,s,r.level),h.entityEnd()}return h}_getSortKeyValue(e,t){if(!this._sortInfo)return 0;const{computed:s,order:r,byRenderer:i}=this._sortInfo,a=i?this._factory.getSortKey(e,t):s?.read(e,t);return null==a||isNaN(a)?0:a*("asc"===r?-1:1)}}function w(e,t){const s=[];return e?.timeExtent?.start===t.timeExtent?.start&&e?.timeExtent?.end===t.timeExtent?.end||s.push("timeProperties"),s}function S(e){const{timeZone:t}=e?.mesh.properties??{},{timeExtent:s}=e?.expressionProperties??{};return{timeZone:t,timeExtent:s}}export{b as default};
