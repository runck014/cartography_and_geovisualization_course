/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{validateColorAndOpacity as e,validateColor as o}from"../../../../core/colorUtils.js";import has from"../../../../core/has.js";import{clamp as r}from"../../../../core/mathUtils.js";import{TextureEncoding as a,TextureUsage as s}from"./enums.js";import{RenderTexture as t}from"../../webgl-engine/core/material/RenderTexture.js";import{getEllipsoidMode as l}from"../../webgl-engine/core/shaderLibrary/util/EllipsoidMode.js";import{TextureEncodingMimeType as n,CullFaceOptions as i,AlphaDiscardMode as u}from"../../webgl-engine/lib/basicInterfaces.js";import{Texture as c}from"../../webgl-engine/lib/Texture.js";import{useSchematicPBRI3S as m,useSchematicPBR as d,schematicMRRFactors as p,advancedMRRFactors as g}from"../../webgl-engine/materials/pbrUtils.js";import{TextureWrapMode as h}from"../../../webgl/enums.js";import{alphaCutoff as f}from"../../../../webscene/support/AlphaCutoff.js";function T(o,r,a){const t=new Map,l=(e,o)=>{if(null==e)return-1;const r=t.get(e.id);if(r)return r.usage|=o,r.id;const a=t.size;return t.set(e.id,{id:a,usage:o}),a},n=r.pbrMetallicRoughness,u=n?.baseColorFactor?e(n.baseColorFactor):null,c=r.emissiveFactor,h=has("disable-feature:diffuse-rendering-i3s")||a?m({normalTexture:r.normalTexture,emissiveTexture:r.emissiveTexture,emissiveFactor:r.emissiveFactor,occlusionTexture:r.occlusionTexture,metallicRoughnessTexture:n?.metallicRoughnessTexture,metallicFactor:n?.metallicFactor,roughnessFactor:n?.roughnessFactor}):d({normalTexture:r.normalTexture,emissiveTexture:r.emissiveTexture,emissiveFactor:r.emissiveFactor,occlusionTexture:r.occlusionTexture,metallicRoughnessTexture:n?.metallicRoughnessTexture,metallicFactor:n?.metallicFactor,roughnessFactor:n?.roughnessFactor}),f=h?p[0]:n?.metallicFactor??g[0],T=h?p[1]:n?.roughnessFactor??g[1],b="mask"===r.alphaMode?s.Color|s.AlphaMask:s.Color,C={baseColorFactor:u?[u[0],u[1],u[2],u[3]]:[1,1,1,1],baseColorTextureId:l(n?.baseColorTexture,b),metallicRoughnessTextureId:l(n?.metallicRoughnessTexture,s.MetallicRoughness),metallicFactor:f,roughnessFactor:T},P={alphaMode:r.alphaMode,alphaCutoff:r.alphaCutoff,doubleSided:r.doubleSided,cullFace:"none"===r.cullFace?i.None:"back"===r.cullFace?i.Back:"front"===r.cullFace?i.Front:i.None,normalTextureId:l(r.normalTexture,s.Normal),emissiveTextureId:l(r.emissiveTexture,s.Emissive),occlusionTextureId:l(r.occlusionTexture,s.Occlusion),emissiveFactor:c?[c[0],c[1],c[2]]:[0,0,0],metallicRoughness:C,wrapTextures:!1,hasParametersFromSource:h},S=[];return t.forEach((({usage:e},r)=>{const a=null!=o&&o[r]&&o[r].formats,s=a?x(a.map((({name:e,format:o})=>({name:e,encoding:F[o]})))):[];S.push({id:r,usage:e,encodings:s})})),{material:P,textures:S}}function x(e){return e.sort(((e,o)=>e.encoding-o.encoding))}const F={ktx2:a.KTX2,basis:a.Basis,dds:a.DDS_S3TC,png:a.PNG,jpg:a.JPG,"ktx-etc2":a.KTX_ETC2},b={[n.KTX2_ENCODING]:a.Basis,[n.BASIS_ENCODING]:a.Basis,[n.DDS_ENCODING]:a.DDS_S3TC,"image/png":a.PNG,"image/jpg":a.JPG,"image/jpeg":a.JPG,"image/ktx":a.KTX_ETC2};function C(e){const a=e?.materialDefinitions?Object.keys(e.materialDefinitions)[0]:null,t=e?.textureDefinitions?Object.keys(e.textureDefinitions)[0]:null,l=a?e.materialDefinitions?.[a]:null,n=t?e.textureDefinitions?.[t]:null,u=P();if(null!=l){const e=l.params;e.diffuse&&(o(e.diffuse),u.metallicRoughness.baseColorFactor=[e.diffuse[0],e.diffuse[1],e.diffuse[2],1]),null!=e.doubleSided&&(u.doubleSided=e.doubleSided,u.cullFace=e.doubleSided?i.None:i.Back),"none"!==e.cullFace&&"front"!==e.cullFace&&"back"!==e.cullFace||(u.cullFace="none"===e.cullFace?i.None:"back"===e.cullFace?i.Back:i.Front),e.transparency&&(u.metallicRoughness.baseColorFactor[3]=r(1-e.transparency,0,1)),(e.useVertexColorAlpha||u.metallicRoughness.baseColorFactor[3]<1)&&(u.alphaMode="blend")}const c=[];if(null!=n){const e=0;!n.wrap||"repeat"!==n.wrap[0]&&"repeat"!==n.wrap[1]||(u.wrapTextures=!0);let o=s.Color;"rgba"===n.channels&&(u.alphaMode="blend",o|=s.AlphaMask);const r=n.images.length-1,a=n.images[r],t=e=>e?.split("/").pop(),l=Array.isArray(n.encoding)?x(n.encoding.map(((e,o)=>({name:t(a.href[o]),encoding:b[e]||0})))):[{name:t(a.href),encoding:b[n.encoding]||0}];c.push({id:e,usage:o,encodings:l}),u.metallicRoughness.baseColorTextureId=e}return{material:u,textures:c}}const P=()=>({alphaMode:"opaque",alphaCutoff:f,doubleSided:!0,cullFace:i.None,normalTextureId:-1,emissiveTextureId:-1,occlusionTextureId:-1,emissiveFactor:[0,0,0],metallicRoughness:{baseColorFactor:[.8,.8,.8,1],baseColorTextureId:-1,metallicRoughnessTextureId:-1,metallicFactor:0,roughnessFactor:.6},wrapTextures:!1,hasParametersFromSource:!0});function S(e,o,r,a){if(null==e?.data)return null;const t=e.data,l=a.renderingContext.parameters.maxMaxAnisotropy,n=l>1,i=r||!o.wrapTextures?M:D,u=I(e.encoding),m=e.usage&s.Color?"opaque"===o.alphaMode?3:4:3;return new c(t,{mipmap:n,maxAnisotropy:l,encoding:u,wrap:i,components:m,noUnpackFlip:!0})}const M={s:h.CLAMP_TO_EDGE,t:h.CLAMP_TO_EDGE},D={s:h.REPEAT,t:h.REPEAT};function R(o,r,a,n,i,c){const m=c.rendererTextureUsage,d=e=>E(n,a,e&m),h=e(r.metallicRoughness.baseColorFactor);o.baseColor=[h[0],h[1],h[2],h[3]],o.hasParametersFromSource=!!r.hasParametersFromSource,o.usePBR=c.usePBR,o.mrrFactors=[r.metallicRoughness.metallicFactor,r.metallicRoughness.roughnessFactor,r.hasParametersFromSource?p[2]:g[2]],o.emissiveFactor=r.emissiveFactor,o.isIntegratedMesh=c.isIntegratedMesh,o.textureAlphaCutoff="mask"===r.alphaMode?r.alphaCutoff:f,o.alphaDiscardMode="opaque"===r.alphaMode?u.Opaque:"mask"===r.alphaMode?u.Mask:u.MaskBlend;const T=[],x=d(s.Color|s.AlphaMask);null!=x&&(o.baseColorTexture=new t(i,x),T.push(o.baseColorTexture.loadPromise));const F=d(s.MetallicRoughness);null!=F&&(o.metallicRoughnessTexture=new t(i,F),T.push(o.metallicRoughnessTexture.loadPromise));const b=d(s.Emissive);null!=b&&(o.emissionTexture=new t(i,b),T.push(o.emissionTexture.loadPromise));const C=d(s.Occlusion);null!=C&&(o.occlusionTexture=new t(i,C),T.push(o.occlusionTexture.loadPromise));const P=d(s.Normal);return null!=P&&(o.normalTexture=new t(i,P),T.push(o.normalTexture.loadPromise)),o.commonMaterialParameters.hasSlicePlane=c.slicePlaneEnabled,o.commonMaterialParameters.doubleSided=r.doubleSided,o.commonMaterialParameters.cullFace=r.cullFace,o.ellipsoidMode=l(c.viewSpatialReference),Promise.all(T)}function w(e){const o=!!e.compressedTextureS3TC,r=!!e.compressedTextureETC,s=has("disable-feature:i3s-basis")?0:a.Basis|a.KTX2,t=a.JPG|a.PNG,l=s|a.DDS_S3TC;return t|(o?l:0)|(r?s:0)}function N(e,o){if(null!=o)return e.find((e=>!!(e.encoding&o)))}function E(e,o,r){if(null==e||r===s.None)return null;for(let a=0;a<e.length;a++){const s=e[a];if(null!=s&&s.usage&r){const e=o[a];return null!=e?e.id:null}}return null}function I(e){switch(e){case a.KTX2:return n.KTX2_ENCODING;case a.Basis:return n.BASIS_ENCODING;case a.DDS_S3TC:return n.DDS_ENCODING;case a.PNG:return"image/png";case a.JPG:return"image/jpeg";case a.KTX_ETC2:return"image/ktx";default:return""}}export{R as configureMaterial,S as createTexture,P as defaultMaterial,T as getMaterialAndTextures,C as getMaterialAndTexturesFromShared,w as getSupportedEncodings,N as selectEncoding};
