/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{baseArrayMemory as e,estimateNumberArrayMemory as t,baseObjectMemory as s,estimateNumberMemory as n}from"../../../../../core/memoryEstimations.js";class r{constructor(r,i,d=a(i)){this.descriptor=r,this._pages=i,this._addressTable=d;const o=e+i.reduce(((e,{usedMemory:t})=>e+t),0),g=3*n,u=t(d);this.usedMemory=s+o+g+u,this.featureCount=Math.floor(this._addressTable.length/2),this.isComplete=this.featureCount===i.reduce(((e,t)=>e+t.featureCount),0)}get id(){return this.descriptor.id}getObjectId(e){const{pageIndex:t,featurePageIndex:s}=this._translateIndex(e);return this._pages[t].getObjectId(s)}getAttribute(e,t){const{pageIndex:s,featurePageIndex:n}=this._translateIndex(e);return this._pages[s].getAttribute(n,t)}getAttributeAsTimestamp(e,t){const{pageIndex:s,featurePageIndex:n}=this._translateIndex(e);return this._pages[s].getAttributeAsTimestamp(n,t)}getAttributes(e){const{pageIndex:t,featurePageIndex:s}=this._translateIndex(e);return this._pages[t].getAttributes(s)}getCoordinates(e,t,s){const{pageIndex:n,featurePageIndex:r}=this._translateIndex(e);this._pages[n].getCoordinates(r,t,s)}getOptimizedGeometry(e){const{pageIndex:t,featurePageIndex:s}=this._translateIndex(e);return this._pages[t].getOptimizedGeometry(s)}getCentroid(e,t){const{pageIndex:s,featurePageIndex:n}=this._translateIndex(e);return this._pages[s].getCentroid(n,t)}getBounds(e){const{pageIndex:t,featurePageIndex:s}=this._translateIndex(e);return this._pages[t].getBounds(s)}getBoundingBox(e){const{pageIndex:t,featurePageIndex:s}=this._translateIndex(e);return this._pages[t].getBoundingBox(s)}readObjectIds(e,t=this._allFeatureIndices(),s=0){let n=s;for(const{page:r,indices:a}of this._batchPageIndices(t))n=r.readObjectIds(e,a,n);return n}readCoordinates(e,t=this._allFeatureIndices(),s=0){let n=s;for(const{page:r,indices:a}of this._batchPageIndices(t))n=r.readCoordinates(e,a,n);return n}*objectIds(e=this._allFeatureIndices()){for(const{page:t,indices:s}of this._batchPageIndices(e))for(const e of t.objectIds(s))yield e}exclude(e){if(0===e.size)return this;const{_addressTable:t,featureCount:s}=this,n=new Array;for(let r=0;r<s;++r){const s=this.getObjectId(r);e.has(s)||(n.push(t[2*r]),n.push(t[2*r+1]))}return new r(this.descriptor,this._pages,n)}reset(){const{isComplete:e,_pages:t}=this;return e?this:new r(this.descriptor,t)}*_allFeatureIndices(){const{featureCount:e}=this;for(let t=0;t<e;++t)yield t}_translateIndex(e){const{_addressTable:t}=this;return{pageIndex:t[2*e],featurePageIndex:t[2*e+1]}}*_batchPageIndices(e){const t=new Array;{let s=0,n=new Array;for(const r of e){const{pageIndex:e,featurePageIndex:a}=this._translateIndex(r);s!==e&&(0!==n.length&&t.push({pageIndex:s,indices:n}),s=e,n=[]),n.push(a)}0!==n.length&&t.push({pageIndex:s,indices:n})}const{_pages:s}=this;for(const{pageIndex:n,indices:r}of t)yield{page:s[n],indices:r}}}function a(e){const t=e.reduce(((e,{featureCount:t})=>e+t),0),s=new Array;if(0===t)return s;const n=e[0].featureCount;for(let r=0;r<t;++r)s[2*r]=Math.floor(r/n),s[2*r+1]=r%n;return s}export{r as Tile};
