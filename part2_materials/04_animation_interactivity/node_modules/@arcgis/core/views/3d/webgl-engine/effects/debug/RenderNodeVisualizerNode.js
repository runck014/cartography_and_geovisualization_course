/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{property as r}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import{ZEROS as t}from"../../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{RenderCategory as n}from"../../../webgl.js";import{ColorFormat as i}from"../../../webgl/formats.js";import s from"../../../webgl/RenderNode.js";import{If as c,glsl as a}from"../../core/shaderModules/glsl.js";import{Default3D as l}from"../../lib/DefaultVertexAttributeLocations.js";import{FramebufferBit as u,ColorAttachment as h,BlendFactor as p,SizedPixelFormat as d,PixelFormat as f,DataType as m}from"../../../../webgl/enums.js";import{alphaCutoff as v}from"../../../../../webscene/support/AlphaCutoff.js";let x=class extends s{constructor(e){super(e),this.destroyedCB=null,this.produces=n.FINAL,this.consumes={required:[n.FINAL]},this.clearColor=t,this._focusedFBOType=0,this._program=new Map}destroy(){this._program.forEach((e=>e.dispose())),this._program.clear(),this.destroyedCB()}render(e){const r=e.find((({name:e})=>e===n.FINAL));if(!this._focusedFBO)return r;const o=this.renderingContext;o.bindFramebuffer(r.fbo),o.setClearColor(0,0,0,0),o.clear(u.COLOR);const t=this._ensureShader(o,!1,0);return o.useProgram(t),o.bindTexture(this._focusedFBO.getTexture(),0),t.setUniform1i("colorTex",0),t.setUniform1i("inputType",this._focusedFBOType),3===this._focusedFBOType&&t.setUniform2fv("nearFar",this.camera.nearFar),o.screen.draw(),r}getDownscaledFBO(e,r,o,t,n,s){o===g.ON&&(n=e.width,s=e.height);const c=this.renderingContext,{colorTexture:a,depthStencilTexture:l}=e,f=a?.descriptor,m=this._ensureShader(c,null!=l,r),v=this.fboCache.acquire(n,s,"fbo visualizer"),x=!f?.hasMipmap&&!f?.isImmutable;x&&a?.generateMipmap(),c.useProgram(m),c.bindFramebuffer(v.fbo);let T=0;const F=[h.COLOR_ATTACHMENT0],C=null!=l;if(c.bindTexture(a,T),m.setUniform1i("colorTex",T),l){T++,c.bindTexture(l,T),m.setUniform1i("depthTex",T);const e=h.COLOR_ATTACHMENT0+T;v.acquireColor(e,i.RGBA,"depth to color"),F.push(e)}for(let u=0;u<r;u++){T++;const r=h.COLOR_ATTACHMENT0+T,o=C?1:0;c.bindTexture(e.getColorTexture(r-o),T),m.setUniform1i("colorTex"+(T-o-1),T),v.acquireColor(r,i.RGBA),F.push(r)}c.gl.drawBuffers(F);const b=c.getViewport();c.setViewport(0,0,n,s),c.setClearColor(0,0,0,0),c.clear(u.COLOR),c.setBlendingEnabled(!0),c.setBlendFunction(p.ONE,p.ONE_MINUS_SRC_ALPHA);const O="linear-depth"===t||t.includes("shadow"),_="overlay highlight"===t||"highlights"===t||"highlight mix"===t,y="highlight coverage"===t,A=f?.internalFormat,w=O?3:_?5:y?6:A===d.R16F||A===d.R32F||A===d.R8?1:A===d.RG8?2:A===d.RGBA16F?4:0;return m.setUniform1i("inputType",w),O&&m.setUniform2fv("nearFar",this.camera.nearFar),c.screen.draw(),c.bindFramebuffer(null),c.setViewport(b.x,b.y,b.width,b.height),o===g.ON&&(this._focusedFBO=v,this._focusedFBOType=w),x&&e.colorTexture?.clearMipmap(),v}clearFocusedFBO(){this._focusedFBO=null}getPreviewContent(e,r,o,t){if(!o)return null;const n=this.renderingContext,i=this.fboCache.acquire(e,r,"fbo visualizer");n.bindFramebuffer(i?.fbo),n.setClearColor(this.clearColor[0],this.clearColor[1],this.clearColor[2],this.clearColor[3]),n.clear(u.COLOR),n.setBlendingEnabled(!0),n.setBlendFunction(p.ONE,p.ONE_MINUS_SRC_ALPHA),n.setViewport(0,0,e,r);const s=this._ensureShader(n,!1,0);n.useProgram(s),n.bindTexture(o.getColorTexture(t),0),s.setUniform1i("colorTex",0),s.setUniform1i("inputType",0),n.screen.draw();const c=new ImageData(new Uint8ClampedArray(e*r*4),e,r);return n.gl.readPixels(0,0,e,r,f.RGBA,m.UNSIGNED_BYTE,new Uint8Array(c.data.buffer)),n.bindFramebuffer(null),i?.release(),c}_ensureShader(e,r,o){const t={hasDepth:r,attachments:o},n=this._program.get(t);if(n)return n;const i="#version 300 es\n      in vec2 position;\n      out vec2 uv;\n\n      void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n        uv = position * 0.5 + vec2(0.5);\n      }",s=(e,r)=>{let o="";const t=e?2:1;for(let n=0;n<r;n++)o+=`layout(location = ${a.int(t+n)}) out vec4 fragColor${a.int(n)};\n                uniform sampler2D colorTex${a.int(n)};`;return o},u=e=>{let r="";for(let o=0;o<e;o++)r+=`fragColor${a.int(o)} = texture(colorTex${a.int(o)}, uv);`;return r},h=`#version 300 es\n      precision highp float;\n\n      in vec2 uv;\n      uniform sampler2D colorTex;\n      layout(location = 0) out vec4 fragColor;\n      ${c(r,"layout(location = 1) out vec4 fragDepth;\n         uniform sampler2D depthTex;")}\n      ${s(r,o)}\n      uniform int inputType;\n      uniform vec2 nearFar;\n\n      // Factors to convert rgba back to float\n      const vec4 RGBA_2_FLOAT_FACTORS = vec4(\n        255.0 / (256.0),\n        255.0 / (256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0),\n        255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n      );\n\n\n      float rgbaTofloat(vec4 rgba) {\n        // Convert components from 0->1 back to 0->255 and then add the components together with their corresponding\n        // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n        return dot(rgba, RGBA_2_FLOAT_FACTORS);\n      }\n\n      float linearDepthFromFloat(float depth) {\n        depth = pow(depth, 0.2);\n        return -(depth * (nearFar[1] - nearFar[0]) + nearFar[0]);\n      }\n\n      float linearDepthFromRGBA(vec4 depth) {\n        return linearDepthFromFloat(rgbaTofloat(depth));\n      }\n\n      float linearDepthFromTexture(sampler2D depthTex, vec2 uv) {\n        ivec2 iuv = ivec2(uv * vec2(textureSize(depthTex, 0)));\n        return linearDepthFromRGBA(texelFetch(depthTex, iuv, 0));\n      }\n\n      void main() {\n        vec4 color;\n        if(inputType == 1) {\n          color = vec4(vec3(texture(colorTex, uv).r), 1.0);\n        } else if(inputType == 2) {\n          color = vec4(texture(colorTex, uv).rg, 0.0, 1.0);\n        } else if(inputType == 3) {\n          float depth = 1.0 - ((-linearDepthFromTexture(colorTex, uv) - nearFar[0]) / (nearFar[1] - nearFar[0]));\n          color = vec4(vec3(depth), depth >= 0.999 ? 0.0 : 1.0);\n        } else if(inputType == 4) {\n          color = texture(colorTex, uv);\n          color = vec4(color.rgb / color.a, color.a);\n        } else if(inputType == 5) {\n          vec2 texDim =  vec2(textureSize(colorTex, 0));\n          ivec2 iuv = ivec2(uv*texDim);\n          vec2 hh = texelFetch(colorTex,iuv,0).rg;\n          uvec2 uhh = uvec2(vec2(hh) * 255.0);\n          color = vec4(\n             ((uhh.x & 0x3u) != 0u) ? 1.0 : 0.0,\n             ((uhh.x & 0xcu) != 0u) ? 1.0 : 0.0,\n             ((uhh.y & 0xfu) != 0u) ? 1.0 : 0.0,\n             1.0);\n        } else if(inputType == 6) {\n          vec2 texDim =  vec2(textureSize(colorTex, 0));\n          ivec2 iuv = ivec2(uv*texDim);\n          uvec2 hh = uvec2(texelFetch(colorTex,iuv,0).rg * 255.0);\n          color = vec4(\n             ((hh & uvec2(0x55u)) != uvec2(0u)) ? 1.0 : 0.0,\n             ((hh & uvec2(0xaau)) != uvec2(0u)) ? 1.0 : 0.0,\n             0.0,\n             1.0);\n        } else {\n          color = texture(colorTex, uv);\n        }\n\n\n        if(color.a < ${a.float(v)})\n          discard;\n        else {\n          fragColor = color;\n          ${c(r,"float depth = 1.0 - pow(texture(depthTex, uv).r, 10.0);\n             fragDepth = vec4(vec3(depth), depth < 0.000001 ? 0.0 : 1.0);")}\n          ${c(o>0,u(o))}\n        }\n      }`;return this._program.set(t,e.programCache.acquire(i,h,l)),this._program.get(t)}};var g;e([r()],x.prototype,"destroyedCB",void 0),e([r()],x.prototype,"produces",void 0),e([r()],x.prototype,"consumes",void 0),e([r()],x.prototype,"clearColor",void 0),x=e([o("esri.views.3d.webgl-engine.effects.debug.RenderNodeVisualizerNode")],x),function(e){e[e.ON=0]="ON",e[e.OFF=1]="OFF"}(g||(g={}));export{g as FocusState,x as RenderNodeVisualizerNode};
