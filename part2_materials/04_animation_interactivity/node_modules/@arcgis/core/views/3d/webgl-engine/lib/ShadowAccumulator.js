/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import{equals as r}from"../../../../core/arrayUtils.js";import"../../../../core/has.js";import{smoothstep as s}from"../../../../core/mathUtils.js";import{disposeMaybe as i}from"../../../../core/maybe.js";import{watch as o,syncAndInitial as a,sync as n}from"../../../../core/reactiveUtils.js";import{property as h}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/Logger.js";import{subclass as c}from"../../../../core/accessorSupport/decorators/subclass.js";import{I as _,c as l}from"../../../../chunks/vec32.js";import{create as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{ReadShadowMapPassParameters as u}from"../core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{BindParameters as p}from"./BindParameters.js";import{DepthRange as d}from"./DepthRange.js";import{createQuadVAO as g}from"./glUtil3D.js";import{ShadowCastRenderer as f,shadowCastDisabledElevationThreshold as b,shadowCastDisableElevationMax as w,shadowCastDisableElevationMin as v}from"./ShadowCastRenderer.js";import{ShadowMap as y}from"./ShadowMap.js";import{S as R}from"../../../../chunks/ShadowCastAccumulate.glsl.js";import{ShadowCastAccumulateTechnique as A}from"../shaders/ShadowCastAccumulateTechnique.js";import{TaskPriority as j}from"../../../support/Scheduler.js";import{PixelFormat as S,PixelType as F,SizedPixelFormat as C,TextureWrapMode as x,FramebufferBit as P}from"../../../webgl/enums.js";import{FramebufferObject as D}from"../../../webgl/FramebufferObject.js";import{TextureDescriptor as E}from"../../../webgl/TextureDescriptor.js";import{vertexCount as q}from"../../../webgl/Util.js";let M=class extends t{constructor(e,t,r,s,i,h){super({}),this.fbos=e,this._techniques=t,this._stage=r,this._prepareForShadowMapPass=s,this._renderToShadowMap=i,this._requestRender=h,this._progress=0,this._sampleCount=0,this._passParameters=new u,this._cachedLightDirections=[],this._depthRange=d.zero,this._previewing=!1,this._cameraForcedForScreenshot=!1,this._shadowAccumulatorKey="shadowAccumulator",this._rctx=e.rctx,this._bindParameters=new p(new y(e,r.viewingMode)),this._bindParameters.shadowMap.enabled=!0,this._vao=g(this._rctx),this._accumulationRenderer=new f(t,this._rctx,this,h);const c=this._stage.view.resourceController.scheduler;this.addHandles([c.registerTask(j.SHADOW_ACCUMULATOR,this),o((()=>r.renderView),(e=>{this.removeHandles(L),null!=e&&this.addHandles(e.events.on("force-camera-for-screenshot",(()=>this._cameraForcedForScreenshot=!0)),L)}),a),o((()=>this._previewing),(()=>this._requestRenderIfEnabled()),n)],this._shadowAccumulatorKey),t.precompile(A)}normalizeCtorArgs(){return{}}dispose(){this._disable(),this.removeHandles(this._shadowAccumulatorKey),this._accumulationRenderer=i(this._accumulationRenderer),this._bindParameters.shadowMap.dispose(),this._fbo=i(this._fbo),this._vao=i(this._vao),this._cachedLightDirections.length=0,this._sampleCount=0}get computedSamples(){return this._progress}get shadowCastTexture(){return this._fbo?.colorTexture}get accumulating(){return this._active&&this._previewing||this._refining}get _refining(){return this._active&&!this._doneAccumulating&&!this._previewing}get _active(){return null!=this._fbo&&this._sampleCount>0}get canAccumulate(){return null!=this._bindParameters.depth&&this._depthRange!==d.zero&&this._opacityFromElevation>b}get _doneAccumulating(){return this._progress>=this._sampleCount}get _lightDirections(){return this._cachedLightDirections}set _lightDirections(e){const t=this._cachedLightDirections;if(r(t,e,_))return;const s=Math.min(R,e.length);t.length=s,this._sampleCount=s;for(let r=0;r<s;++r)t[r]=l(t[r]??m(),e[r]);this._invalidate()}get _opacityFromElevation(){return this._accumulationRenderer.opacityFromElevation}set _opacityFromElevation(e){this._accumulationRenderer.opacityFromElevation=e}get running(){return this._refining&&this.canAccumulate&&this._progress>0}runTask(e){for(this._prepareForShadowMapPass(this._bindParameters);!e.done&&!this._doneAccumulating;)this._accumulateShadow(),e.madeProgress();this._requestRender()}renderAccumulation(e,t,r,s){if(this._depthRange=t,this._updateCamera(r),this._bindParameters.contentCamera=s,this._bindParameters.depth=e,this._passParameters.origin=this._bindParameters.camera.center,this.notifyChange("canAccumulate"),!this.accumulating||!this.canAccumulate)return!1;(this._previewing||0===this._progress||this._cameraForcedForScreenshot)&&this._clear();let i=this._cameraForcedForScreenshot?this._sampleCount:Math.min(T,this._sampleCount);i-=this._progress;for(let o=0;o<i;++o)this._accumulateShadow(),this._requestRender();return this._cameraForcedForScreenshot=!1,i>0}precompile(){this._accumulationRenderer.precompile()}render(e){this._accumulationRenderer.render(e)}setOptions(e){if(void 0!==e.enabled){const t=null!=this._fbo;e.enabled!==t&&(e.enabled?this._enable():this._disable())}void 0!==e.previewing&&(this._previewing=e.previewing),void 0!==e.lightDirections&&(this._lightDirections=e.lightDirections),this._accumulationRenderer.setOptions(e)}readAccumulatedShadow(e,t){return!this._active||!this._fbo||this._progress<1||e<0||e>=this._fbo.width||t<0||t>=this._fbo.height?0:(this._fbo.readPixels(e,t,1,1,S.RGBA,F.UNSIGNED_BYTE,O),O[0]/this._progress)}_enable(){this._progress=0;const e=new E;e.pixelFormat=S.RED,e.internalFormat=C.R8,e.wrapMode=x.CLAMP_TO_EDGE,this._fbo=new D(this._rctx,e),this._requestRender()}_disable(){this._fbo=i(this._fbo),this._requestRender()}_invalidate(){this._progress=0,this._requestRenderIfEnabled()}_clear(){this._rctx.bindFramebuffer(this._fbo),this._rctx.setClearColor(0,0,0,0),this._rctx.clear(P.COLOR),this._progress=0}_accumulateShadow(){this._renderToShadowMap(this._bindParameters,this._lightDirections[this._progress++],this._depthRange);const e=this._techniques.get(A);this._rctx.bindFramebuffer(this._fbo),this._rctx.bindTechnique(e,this._bindParameters,this._passParameters),this._rctx.bindVAO(this._vao),this._rctx.drawArrays(e.primitiveType,0,q(this._vao,"geometry"))}_updateCamera(e){const t=this._fbo;if(null==t)return;const r=this._bindParameters.camera;e.equals(r)||r.copyFrom(e),t.resize(e.fullWidth,e.fullHeight),this._opacityFromElevation=1-s(v,w,e.relativeElevation)}_requestRenderIfEnabled(){this._fbo&&this._requestRender()}get test(){}};e([h()],M.prototype,"_progress",void 0),e([h()],M.prototype,"_sampleCount",void 0),e([h()],M.prototype,"_fbo",void 0),e([h()],M.prototype,"_depthRange",void 0),e([h()],M.prototype,"_previewing",void 0),e([h()],M.prototype,"_accumulationRenderer",void 0),e([h()],M.prototype,"_refining",null),e([h()],M.prototype,"_active",null),e([h()],M.prototype,"canAccumulate",null),e([h()],M.prototype,"_doneAccumulating",null),e([h()],M.prototype,"_opacityFromElevation",null),e([h()],M.prototype,"running",null),M=e([c("esri.views.3d.webgl-engine.lib.ShadowAccumulator")],M);const T=6,L="renderView",O=new Uint8Array(4);export{M as ShadowAccumulator};
