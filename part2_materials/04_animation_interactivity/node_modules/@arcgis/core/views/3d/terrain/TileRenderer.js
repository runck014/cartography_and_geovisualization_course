/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import"../../../core/has.js";import{disposeMaybe as r,releaseMaybe as s}from"../../../core/maybe.js";import{watch as o,sync as i}from"../../../core/reactiveUtils.js";import{property as a}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as n}from"../../../core/accessorSupport/decorators/subclass.js";import{set as c,copy as u}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{ZEROS as p}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{fromValues as l}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isBaseLayer as d,isGroupLayer as m}from"../../../layers/support/layerUtils.js";import{BlendLayersPassParameters as h}from"./BlendLayersTechnique.js";import{TextureUpdate as f}from"./interfaces.js";import{LayerClass as _}from"./LayerClass.js";import{NeighborIndex as T}from"./NeighborIndex.js";import{isImageWithType as y}from"./TerrainData.js";import{isBlendableLayerView as g,isVectorTileLayerView as b,isVectorTileRenderInfo as x,isImageryTileRenderInfo as I,isImageSourceRenderInfo as w,isTextureTileRenderInfo as A,isVectorTilePerLayerInfo as j}from"./terrainUtils.js";import{ActivationTime as P}from"./TextureFader.js";import{TextureReference as C}from"./TextureReference.js";import{TileCompositor as O}from"./TileCompositor.js";import{TileRenderInfo as k}from"./TileRenderInfo.js";import E from"./TileTexture.js";import{TileUpdate as L}from"./TileUpdate.js";import{fallsWithinLayerView as R}from"./tileUtils.js";import{blendModeFromString as M}from"../webgl-engine/core/shaderLibrary/output/BlendOptions.js";import{BlendLayersOutput as D}from"../webgl-engine/core/shaderLibrary/terrain/BlendLayersOutput.js";import{createEmptyTexture as N}from"../webgl-engine/lib/glUtil3D.js";import{isCompressible as B}from"../webgl-engine/lib/TextureCompressionWorkerHandle.js";import{TextureSamplingMode as S,TextureWrapMode as U,PixelFormat as G}from"../../webgl/enums.js";import{Texture as v}from"../../webgl/Texture.js";import{TextureDescriptor as F}from"../../webgl/TextureDescriptor.js";class H{constructor(e,t,r,s,o,i){this.start=e,this.end=t,this.blendMode=r,this.opacity=s,this.output=o,this.baseOpacity=i}}let q=class extends t{constructor(e){super(e),this._passParameters=new h,this._backgroundTexture=null,this._backgroundColor=null,this._backgroundDirty=!1}initialize(){this._maxAnisotropy=this.rctx.parameters.maxMaxAnisotropy,this._compositor=new O(this.rctx,this.techniques),this._ensureBackgroundTexture(this.tileSize),this.texturesBeingCompressed=0}dispose(){this._compositor=r(this._compositor),this._backgroundTexture=s(this._backgroundTexture)}get backgroundIsGrid(){return null==this._backgroundColor}get backgroundColor(){return this._backgroundColor}updateHeading(e){this._compositor?.updateHeading(e)}updateTileTexture(e,t){if(!e.renderData)return;const r=e.surface,s=r.baseOpacity;let o=0,i=0,a=this.tileSize,n=!1,c=!1;const u=r.view.state.contentPixelRatio;let p=!1;J.clear(),K.length=0;const l=e.layerInfo[_.MAP];let h=0,T=null;for(;h<l.length;h++){const t=r.layerViewByIndex(h,_.MAP),f=t.layer,y=!R(e,t),x=f.opacity,I=t.fullOpacity;if(c=c||d(f),g(t)){let e="normal"!==t.layer.blendMode;if(m(f.parent)){const t=f.parent.uid;null!=t&&""!==t&&(e=X(f.parent)||e)}e&&(p=e,n=!1)}if((y||0===x)&&!p){l[h].pendingUpdates&=~(L.TEXTURE_NOFADING&L.TEXTURE_FADING);continue}++i;const w=b(t),A=z(e,h,w);if(A){if(l[h].pendingUpdates&=~(L.TEXTURE_NOFADING&L.TEXTURE_FADING),m(f.parent)){const e=f.parent.uid;null!=e&&""!==e&&W(f.parent,h)}w?a=Math.max(a,this.tileSize*u):1===s&&1===I&&(t.isOpaque||this._dataToTexture(A)&&A.sourceLayerInfo.data.descriptor.isOpaque)&&(n=!0),++o,null===T&&(T=h)}}const y=a/this.tileSize,x=this._ensureBackgroundTexture(this.tileSize);0!==o&&null!==T?1===o&&!p&&this._useLayerTexture(e,T)||this._composeLayers(e,t,h-1,c,a,y,!n||p,J,p):$(e,i,x,t!==f.FADING)}_ensureBackgroundTexture(e){return null==this._backgroundTexture&&(this._backgroundTexture=this._buildTexture(e,!1),this._backgroundDirty=!0),this._backgroundDirty&&(this._compositor.bind(e),this._passParameters.offset=p,this._passParameters.scale=1,this._passParameters.opacity=1,this.backgroundColor&&(this._passParameters.backgroundColor=this.backgroundColor),this._compositor.drawBackground(this._passParameters,null!=this.backgroundColor),this._compositor.copyFBOToTexture(this._backgroundTexture),this._compositor.unbind(),this._backgroundDirty=!1),this._backgroundTexture}_useLayerTexture(e,t){const r=e.surface.layerViewByIndex(t,_.MAP),s=d(r.layer),o=s?e.surface.baseOpacity:1,i=s?1:e.surface.baseOpacity,a=r.fullOpacity,n=z(e,t,!1);return!!this._dataToTexture(n)&&(e.renderData.setTextureReference(new C(n.sourceLayerInfo.data,f.FADING,l(n.offset[0],n.offset[1],n.scale,n.scale),o,i,a)),!0)}_composeLayers(e,t,r,s,o,i,a,n,c){this._compositor.ensureBuffer(o);const u=e.surface.baseOpacity;let l=!1,m=S.LINEAR_MIPMAP_LINEAR,h=!1,f=0;for(let A=r;A>=0;A--){const t=e.surface.layerViewByIndex(A,_.MAP),r=t.layer,T=b(t),y=z(e,A,T),w=r.opacity,j=!R(e,t);if(!y||(0===w||j)&&!c)continue;const P=!d(r)&&!l;P&&(l=!0);let C=!1;n.forEach((e=>{e.start===A&&(e.output=s?D.Composite:a&&P?this.backgroundIsGrid?D.GridComposite:D.ColorComposite:D.Composite,e.baseOpacity=P?u:1,K.push(e),this._compositor.openGroup(o),C=!0)}));const O=0===f,k=C?D.GroupBackgroundComposite:a&&O?this.backgroundIsGrid?D.GridComposite:D.ColorComposite:D.Composite,E=M[g(t)?t.layer.blendMode:"normal"];for(this._passParameters.baseOpacity=P&&!C&&u<1?u:1,this._passParameters.opacity=w,x(y)?h=this._compositor.drawVectorData(this._passParameters,k,o,E,y,i,this.tileSize,h):I(y)?(this._compositor.drawRasterData(this._passParameters,k,o,E,y),V(y)&&(m=S.NEAREST)):this._dataToTexture(y)&&(this._passParameters.texture=y.sourceLayerInfo.data.texture,this._passParameters.offset=y.offset,this._passParameters.scale=y.scale,this._compositor.drawImageData(this._passParameters,k,o,E));K.length>0&&K[K.length-1].end===A;){const e=K.pop();this._passParameters.baseOpacity=e.baseOpacity,this._passParameters.opacity=e.opacity,this._passParameters.offset=p,this._passParameters.scale=1,this._compositor.drawGroup(this._passParameters,e.output,o,M[e.blendMode])}f++}const T=e.renderData,y=c||l&&u<1,w=T.ensureTexture(o,y,t,(()=>this._buildTexture(o,y,m)));this._compositor.copyFBOToTexture(w),this._compositor.unbind(),T.setTextureReference(new C(w,t,Y,l?1:u,0,1))}_dataToTexture(e){if(w(e)){const t=e.sourceLayerInfo,r=1===e.scale;t.data=this._buildTexture(t.data,!0,r),e.tile.setMemoryDirty()}return A(e)}setBackground(e){this._backgroundColor!==e&&(this._backgroundColor=e,this._backgroundDirty=!0)}_buildTexture(e,t,r=S.LINEAR_MIPMAP_LINEAR){if(null==e)return null;const s=new F;s.wrapMode=U.CLAMP_TO_EDGE,s.samplingMode="boolean"==typeof r?S.LINEAR_MIPMAP_LINEAR:r,s.maxAnisotropy=this._maxAnisotropy,s.preMultiplyAlpha=!0,s.flipped=!0,s.hasMipmap=!0,t||(s.pixelFormat=G.RGB);const o=this.rctx,i="boolean"==typeof r&&r;let a;if("number"==typeof e)s.width=s.height=e,a=this._buildTileTexture(s,e);else if(y(e))s.isOpaque=e.isOpaque,s.isOpaque&&(s.pixelFormat=G.RGB),a=this._buildTileTexture(s,e.element.width,i,e.element);else try{s.width=e.width,s.height=e.height,a=this._buildTileTexture(s,e.width,i,e)}catch(c){a=new E(N(o)),console.warn("TileRenderer: failed to execute 'texImage2D', cross-origin image may not be loaded.")}const n=o.bindTexture(a.texture,v.TEXTURE_UNIT_FOR_UPDATES);return a.generateMipmap(),o.bindTexture(n,v.TEXTURE_UNIT_FOR_UPDATES),a}_buildTileTexture(e,t,r=!1,s){const a=`${t} ${e.pixelFormat}`,n=this.cache.pop(a)??this.cache.pop(a+"compressed");if(r&&=B(s),n)return n.retain(),r&&n.texture.enableCompression(!0),n.texture.setData(s),n;e.shouldCompress=r;const c=new v(this.rctx,e,s);return c.isCompressing&&(this.texturesBeingCompressed++,this.addHandles([o((()=>c.isCompressing),(e=>{e?this.texturesBeingCompressed++:this.texturesBeingCompressed--}),i)])),new E(c,this.cache)}get test(){}};function z(e,t,r){Q.layerIndex=t,Q.vtlNeighborInfos.clear();const s=e.layerInfo[_.MAP][t];if(c(Q.offset,0,0),Q.tile=e,Q.scale=1,Q.sourceLod=e.lij,Q.sourceLayerInfo=s,Q.isVTLBackground=r,s.data)return r&&e.forEachLoadedNeighbor(((r,o)=>{if(r.level!==e.level)return;const i=r.layerInfo[_.MAP][t];if(!j(i)||s.data===i.data)return;const a=Q.vtlNeighborInfos.pushNew();a.offset=Z[o],a.sourceLod=r.lij,a.sourceLayerInfo=i})),Q;const o=s.upsampleInfo,i=o?.tile?.layerInfo[_.MAP][t];return i&&o.tile?(Q.tile=o.tile,u(Q.offset,o.offset),Q.scale=o.scale,Q.sourceLod=o.tile.lij,Q.sourceLayerInfo=i,Q):r?Q:null}function V(e){const t=e.sourceLayerInfo.data;return!!t.source&&"nearest"===t.interpolation}function X(e){let t="normal"!==e.blendMode;return m(e.parent)&&(t=X(e.parent)||t),t}function W(e,t){m(e.parent)&&W(e.parent,t);const r=e.uid;if(null!=r&&""!==r){const s=J.get(r);s?s.start=t:J.set(r,new H(t,t,e.blendMode,e.opacity,D.Composite,1))}}function $(e,t,r,s){const o=e.renderData,i=!s&&null!=o.textureReference&&(e.surface.view.layerViewManager.updating||t>0)?P.Delayed:P.Immediate;o.setTextureReference(new C(r,f.FADING,Y,e.surface.baseOpacity,0,1),i)}e([a({constructOnly:!0})],q.prototype,"rctx",void 0),e([a({constructOnly:!0})],q.prototype,"techniques",void 0),e([a({constructOnly:!0})],q.prototype,"cache",void 0),e([a()],q.prototype,"tileSize",void 0),e([a()],q.prototype,"texturesBeingCompressed",void 0),q=e([n("esri.views.3d.terrain.TileRenderer")],q);const J=new Map,K=new Array,Q=new k,Y=l(0,0,1,1),Z=new Array;Z[T.NORTH]=[0,-1],Z[T.NORTH_EAST]=[-1,-1],Z[T.EAST]=[-1,0],Z[T.SOUTH_EAST]=[-1,1],Z[T.SOUTH]=[0,1],Z[T.SOUTH_WEST]=[1,1],Z[T.WEST]=[1,0],Z[T.NORTH_WEST]=[1,-1];export{H as GroupInfo,q as TileRenderer};
