/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import{Cyclical as t}from"../../../core/Cyclical.js";import n from"../../../core/Logger.js";import{deg2rad as r,rad2deg as i,asinClamped as o}from"../../../core/mathUtils.js";import{throwIfAborted as a}from"../../../core/promiseUtils.js";import{h as c,g as l,j as s,l as u,G as f,c as m}from"../../../chunks/vec32.js";import{clone as p,create as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as h}from"../../../geometry/ellipsoidUtils.js";import y from"../../../geometry/Point.js";import{projectWithZConversion as g,project as v}from"../../../geometry/projection.js";import w from"../../../geometry/SpatialReference.js";import{projectPointToVector as R,projectPointToVectorAsync as T}from"../../../geometry/projection/projectPointToVector.js";import{projectVectorToPoint as x,projectVectorToPointAsync as S}from"../../../geometry/projection/projectVectorToPoint.js";import{projectVectorToVector as M}from"../../../geometry/projection/projectVectorToVector.js";import{ViewingMode as j}from"../../ViewingMode.js";import{cameraOnContentAlongViewDirection as z}from"../camera/intersectionUtils.js";import{c as C}from"../../../chunks/cameraUtilsPlanar.js";import{c as A}from"../../../chunks/cameraUtilsSpherical.js";import{getGreatCircleSpanAt as b}from"./earthUtils.js";import{getElevationAtPoint as U}from"./ElevationProvider.js";import{isSpatialReferenceSupported as D}from"../../support/spatialReferenceSupport.js";const L=()=>n.getLogger("esri.views.3d.support.cameraUtils"),P=96*39.37,G=1,E=8,H=5,J=1,O={heading:0,tilt:0},q=d(),F=new t(-20037508.342788905,20037508.342788905),I=new t(-180,180);var k;function V(e){return e.spatialReference??w.WGS84}function X({state:e}){return e.isGlobal?A:C}function K(e,t,n,r,i){return X(e).headingTiltToDirectionUp(t,n,r,i)}function W(e,t){if(null==t)return null;const n=e.renderSpatialReference,i=X(e).headingTiltToDirectionUp,o=d();if(!R(t.position,o,n))return null;const a=i(o,t.heading,t.tilt);c(a.direction,a.direction,e.state.camera.distance),l(a.direction,a.direction,o);const s=z(e,o,a.direction,a.up);return s.fov=r(t.fov),s.row=t.layout.row,s.rows=t.layout.rows,s.column=t.layout.column,s.columns=t.layout.columns,s}!function(e){e[e.LOCKED=0]="LOCKED",e[e.ADJUST=1]="ADJUST"}(k||(k={}));const Y=d();function N(t,n,r){const o=t.renderSpatialReference,a=le(t,n.eye,n.viewForward,n.up,O);let c=V(t);return M(n.eye,o,Y,c)||(c=w.WGS84,M(n.eye,o,Y,c)),null==r?r=new e(new y(Y,c),a.heading,a.tilt,i(n.fov)):(r.position.x=Y[0],r.position.y=Y[1],r.position.z=Y[2],r.position.spatialReference=c,r.heading=a.heading,r.tilt=a.tilt,r.fov=i(n.fov)),r.layout.row=n.row,r.layout.rows=n.rows,r.layout.column=n.column,r.layout.columns=n.columns,r}function Z(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper;t/=r;return n.width/2/n.pixelRatio/(P/t)/Math.tan(n.fovX/2)}function B(e,t){const{camera:n}=e.state,{unitInMeters:r}=e.renderCoordsHelper,i=t*Math.tan(n.fovX/2),o=n.width/2/n.pixelRatio;return P/(o/i)*r}function Q(e,t,n,r){const i=r.levelAtScale(t),o=_(le(e,n.eye,n.viewForward,n.up).tilt),a=Math.max(i-o,0);return r.scaleAtLevel(a)}function $(e,t,n){const r=n.levelAtScale(e),i=_(t);return n.scaleAtLevel(r+i)}function _(e){return 2*((e>90?180-e:e)/90)**2}function ee(e,t,n=0){const r=e.basemapTerrain?.tilingScheme;if(!r)return 0;const i=h(e.spatialReference).radius,o=e.state.viewingMode===j.Local?t.eye[2]:u(t.eye)-i;return Q(e,B(e,Math.abs(o-n)),t,r)}function te(e,t,n=0){const r=W(e,t);return r?ee(e,r,n):0}const ne=1,re=100;function ie(e,t,n,a,c){if(0===t)return 0;const l=s(n.eye,a),f=e.basemapTerrain?.tilingScheme;if(!f)return L().error("#scaleToTargetDistance()","Cannot compute distance from scale without a tiling scheme"),l;let m=l;const p=le(e,n.eye,n.viewForward,n.up),d=p.tilt>90;if(e.state.isLocal){const i=(Z(e,$(t,p.tilt,f))-Math.abs(n.eye[2]-c[2]))/Math.cos(r(p.tilt));return m=d?m-i:m+i,m}let y=1/0,g=0,v=pe(e,p.heading,p.tilt,a,l,k.ADJUST);if(!v)return m;const w=u(c);for(;y>ne&&g<re;){const c=u(v.eye),l=d?180-v.tilt:v.tilt,R=r(l),T=Math.sin(R)*c,x=Math.cos(R)*c,S=Z(e,$(t,v.tilt,f)),M=d?w-S:w+S,j=o(T/M),z=Math.cos(j)*M-x,C=s(v.eye,a);m=d?C-z:C+z,v=pe(e,p.heading,p.tilt,a,m,k.ADJUST);const A=Ge(e,v,i(n.fov));if(!v||!A)return m;const b=te(e,A,w-h(e.spatialReference).radius);y=Math.abs(t-b),++g}return m}async function oe(e,t,n,r,i,o){return ce(e,t,Z(e,n),r,i,o)}function ae(e,t,n,r,i,o){return Ge(e,pe(e,r.heading,r.tilt,t,n,i),r.fov,o)}async function ce(e,t,n,r,i,o){const c=await de(e,r.heading,r.tilt,t,n,i,o);return a(o),Ee(e,c,r.fov,o)}function le(e,t,n,r,i){return X(e).directionToHeadingTilt(t,n,r,i)}function se(e,t){return!!(e.basemapTerrain&&e.renderCoordsHelper.fromRenderCoords(t,q,e.spatialReference)&&e.elevationProvider&&(U(e.elevationProvider,q)??0)>q[2]-J)}async function ue(e,t,n){if(se(e,t))return!0;const{elevationProvider:r,spatialReference:i,renderCoordsHelper:o}=e;if(null==r||!o.fromRenderCoords(t,q,i))return!1;const[c,l,s]=q,u=await r.queryElevation(c,l,s,i,"ground",n)??0;return a(n),u>s-J}async function fe(e,t,n){const r=d();if(null==t)return m(r,e.state.camera.center);if(t instanceof y){const{renderSpatialReference:i,basemapTerrain:o,elevationProvider:c}=e,l=t.spatialReference;if(await T(t,r,i,0,{signal:n}),a(n),null==t.z&&null!=o&&null!=c){const i=await c.queryElevation(t.x,t.y,t.z??0,l,"ground",n);a(n),null!=i&&e.renderCoordsHelper.setAltitude(r,i)}return r}return m(r,t)}function me(e,t){const n=d();if(null==t)return m(n,e.state.camera.center);if(t instanceof y){if(!R(t,n,e.renderSpatialReference))return null;const{basemapTerrain:r,elevationProvider:i}=e;if(null==t.z&&null!=r&&null!=i){const r=U(i,t);null!=r&&e.renderCoordsHelper.setAltitude(n,r)}return n}return m(n,t)}function pe(e,t,n,r,i,o){return he(e,t,n,r instanceof y?r:null,me(e,r),i,o)}async function de(e,t,n,r,i,o,c){const l=r instanceof y?r:null,s=await fe(e,r,c);return a(c),ye(e,t,n,l,s,i,o,c)}function he(e,t,n,r,i,o,a){if(null==i)return null;if(!r&&(r=new y({spatialReference:V(e)}),!x(i,e.renderSpatialReference,r)))return null;const c=ge(e,t,n,i,o,a);if(ve(e,n,a)&&se(e,c.eye)){const{tilt:a,mode:c}=we(e,n,i,o);return he(e,t,a,r,i,o,c)}return Re(c,i)}async function ye(e,t,n,r,i,o,c,l){r||(r=new y({spatialReference:V(e)}),await S(i,e.renderSpatialReference,r,{signal:l})||(r=null)),a(l);const s=ge(e,t,n,i,o,c);if(ve(e,n,c)&&await ue(e,s.eye,l)){a(l);const{tilt:c,mode:s}=we(e,n,i,o);return ye(e,t,c,r,i,o,s,l)}return Re(s,i)}function ge(e,t,n,r,i,o){const a=Ae(e,t,n,r,i=Math.max(i,e.state.constraints.minimumPoiDistance),o);return(0,X(e).eyeForCenterWithHeadingTilt)(r,i,a.heading,a.tilt)}function ve(e,t,n){const r=e.map.ground.navigationConstraint;return n===k.ADJUST&&e.state.isGlobal&&t>0&&(null==r||"stay-above"===r.type)}function we(e,t,n,r){const i=Le(e,n,r,De(e,r,t,n));return{tilt:i,mode:t-i<1?k.LOCKED:k.ADJUST}}function Re(e,t){return{...e,center:p(t)}}function Te(e,t){const{state:n,spatialReference:r}=e,i=t.spatialReference;return n.isGlobal&&D(i,j.Global)||n.isLocal&&r.equals(i)}function xe(e,t){let n,r,i;if(e.state.isGlobal){const e=new y(t.xmin,t.ymin,t.spatialReference),o=new y(t.xmax,t.ymax,t.spatialReference),a=t.spatialReference.isGeographic?I:F;n=new y({x:a.center(e.x,o.x),y:(o.y+e.y)/2,z:null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0,spatialReference:t.spatialReference});const c=h(t.spatialReference),l=b(n,e,o);r=l.lon,i=l.lat,a.diff(e.x,o.x)>a.range/2&&(r+=c.halfCircumference),r=Math.min(r,c.halfCircumference),i=Math.min(i,c.halfCircumference)}else{const o=e.renderSpatialReference??t.spatialReference;o.equals(t.spatialReference)||(t=v(t,o)),r=t.xmax-t.xmin,i=t.ymax-t.ymin;const a=null!=t.zmax&&null!=t.zmin?(t.zmax+t.zmin)/2:void 0;n=new y({x:t.xmin+.5*r,y:t.ymin+.5*i,z:a,spatialReference:o})}const o=null!=t.zmax&&null!=t.zmin?t.zmax-t.zmin:0,a=e.state.camera,c=1/Math.tan(a.fovX/2),l=1/Math.tan(a.fovY/2),s=1/Math.tan(a.fov/2);return{center:n,distance:Math.max(.5*r*c,.5*i*l,.5*o*s)/G}}async function Se(e,t,n,r,i,o){const c=Te(e,t)?t:await g(t,e.spatialReference,{signal:o});a(o);const{center:l,distance:s}=xe(e,c),u=await de(e,n,r,l,s,i,o);return a(o),Ee(e,u,e.camera.fov,o)}function Me(e,t,n,r,i,o){let a;try{a=Te(e,t)?t:v(t,e.spatialReference)}catch(u){return null}const{center:c,distance:l}=xe(e,a),s=pe(e,n,r,c,l,i);return null==s?null:Ge(e,s,e.camera.fov,o)}function je(e,t,n){const r=e.renderSpatialReference,i=new y({spatialReference:V(e)});if(!x(n,r,i))return null;const o=Math.tan(t.fovX/2),a=Math.tan(t.fovY/2),c=f(t.eye,n),l=2*c*o*G,s=2*c*a*G;return X(e).toExtent(e,i,l,s)}function ze(e,t){return X(e).toArea(e,t)}function Ce(e,t,n){const r=e.pointsOfInterest.centerOnSurfaceFrequent.distance;if(Math.log(n/r)/Math.LN2>E)return!0;const i=t,o=e.pointsOfInterest.centerOnSurfaceFrequent.renderLocation;return s(i,o)/(Math.tan(.5*e.state.camera.fov)*r)>H}function Ae(e,t,n,r,i,o){let a=0;return o===k.ADJUST&&Ce(e,r,i)?(t=0,a=Ue(e,i,n,r)):a=Pe(e,r,i,n),a=e.state.constraints.clampTilt(i,a),{heading:t,tilt:n=Le(e,r,i,a)}}const be=.7;function Ue(e,t,n,r){const i=Pe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);o.max=Math.min(o.max,.5*Math.PI);const a=o.min*(1-be)+o.max*be;return Math.min(i,a)}function De(e,t,n,r){let i=Pe(e,r,t,n);if(!e.state.constraints.tilt)return i;const o=e.state.constraints.tilt(t);return i=Math.min(i,.5*Math.PI),o.min*(1-be)+i*be}function Le(e,t,n,r){return X(e).lookAtTiltToEyeTilt(r,t,n)}function Pe(e,t,n,r){return X(e).eyeTiltToLookAtTilt(r,t,n)}function Ge(t,n,r,i){if(null==n)return null;const o=t.renderSpatialReference,a=new y({spatialReference:V(t)});return x(n.eye,o,a)?(i??=new e,i.position=a,i.heading=n.heading,i.tilt=n.tilt,i.fov=r,i):null}async function Ee(t,n,r,i){const o=t.renderSpatialReference,c=new y({spatialReference:V(t)});return await S(n.eye,o,c,{signal:i}),a(i),new e(c,n.heading,n.tilt,r)}function He(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.levelAtScale(t);L().error("#scaleToZoom()","Cannot compute zoom from scale without a tiling scheme")}function Je(e,t){const n=e.basemapTerrain?.tilingScheme;if(n)return n.scaleAtLevel(t);L().error("#zoomToScale()","Cannot compute scale from zoom without a tiling scheme")}export{k as OrientationMode,Q as applyTiltAdjustToScale,le as directionToHeadingTilt,B as distanceToScale,W as externalToInternal,ce as fromCenterDistanceAsync,ae as fromCenterDistanceSync,oe as fromCenterScale,Se as fromExtentAsync,Me as fromExtentSync,de as getObserverForPointAtDistanceAsync,pe as getObserverForPointAtDistanceSync,V as getViewSR,K as headingTiltToDirectionUp,N as internalToExternal,$ as removeTiltAdjustFromScale,ne as scaleErrorThreshold,Z as scaleToDistance,He as scaleToZoom,ze as toArea,je as toExtent,ie as viewScaleToCameraDistance,Je as zoomToScale};
