/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{screenPointObjectToArray as e,castScreenPointArray as n,createScreenPointArray as r}from"../../../../core/screenUtils.js";import{create as t}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{l as o,c as l,e as s,d as c,f as a,h as i,g as u}from"../../../../chunks/vec32.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import m from"../../../../geometry/Point.js";import{projectPoint as d}from"../../../../geometry/projection.js";import{intersectRay as f,create as g,getNormal as E,fromPositionAndNormal as S}from"../../../../geometry/support/plane.js";import{create as y,closestPoints as j}from"../../../../geometry/support/ray.js";import{projectPoint as v}from"../../../../geometry/support/vector.js";import{sv2d as R}from"../../../../geometry/support/vectorStacks.js";import{getZForElevationMode as x}from"../../../../support/elevationInfoUtils.js";import{fromScreen as b}from"../../support/geometryUtils/ray.js";import{newIntersector as w}from"../../webgl-engine/lib/Intersector.js";import{StoreResults as I,IntersectorType as H}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{terrainId as U}from"../../webgl-engine/lib/verticalOffsetUtils.js";import{EventPipeline as O}from"../../../interactive/dragEventPipeline.js";function C(e,n){return T(e,(()=>n))}function P(e){return T(e,(e=>e.plane))}function T(r,t){const o=p(),l=p();let s=!1;return c=>{const a=t(c);if("start"===c.action){const t=e(c.screenStart,n(R.get())),l=b(r.state.camera,t,Q);null!=l&&(s=f(a,l,o))}if(!s)return null;const i=e(c.screenEnd,n(R.get())),u=b(r.state.camera,i,Q);return null==u?null:f(a,u,l)?{...c,renderStart:o,renderEnd:l,plane:a,ray:u}:null}}function D(e,n,t=0,o=null,l=null){let s=null;return c=>{if("start"===c.action&&(s=e.sceneIntersectionHelper.intersectElevationFromScreen(r(c.screenStart.x,c.screenStart.y),n,t,l),null!=s&&null!=o&&!d(s,s,o)))return null;if(null==s)return null;const a=e.sceneIntersectionHelper.intersectElevationFromScreen(r(c.screenEnd.x,c.screenEnd.y),n,t,l);return null!=a&&(null==o||d(a,a,o))?{...c,mapStart:s,mapEnd:a}:null}}function M(e,n,r,t=null,o=null){return D(e,r,x(n,e,r),t,o)}function N(e,n,r,t){const o=r.toMap(e.screenStart);return null!=o?M(n,o,r.elevationInfo,t):null}function h(e,n){const r=K,t=L,o=g();e.renderCoordsHelper.worldUpAtPosition(n,r);const l=s(E(o),r,c(t,n,e.state.camera.eye));return s(l,l,r),S(n,l,o)}function G(e,n,r){let t=null;const o=new O;return o.next(C(e,h(e,n))).next(k(e,n)).next(F(e,r)).next((e=>{e.mapEnd.x=e.mapStart.x,e.mapEnd.y=e.mapStart.y,t=e})),e=>(t=null,o.execute(e),t)}function k(e,n){const r=p(),t=o(n);e.renderCoordsHelper.worldUpAtPosition(n,r);const s=p(),m=p(),d=l=>{if(c(l,l,n),v(r,l,l),"global"===e.viewingMode){o(l)*Math.sign(a(r,l))<.001-t&&c(l,i(l,r,.001),n)}return u(l,l,n),l};return e=>(e.renderStart=d(l(s,e.renderStart)),e.renderEnd=d(l(m,e.renderEnd)),e)}function A(r,t){const o=o=>{const l=e(o,n(J)),s=b(r.state.camera,l,Q);if(null==s)return null;const c=j(t,s,K,L);return c?.[0]};return e=>{const n=o(e.screenStart);if(null==n)return null;const r=o(e.screenEnd);return null==r?null:{...e,renderStart:n,renderEnd:r}}}function F(e,n){const r=e.renderCoordsHelper;return e=>{const t=r.fromRenderCoords(e.renderStart,new m({spatialReference:n})),o=r.fromRenderCoords(e.renderEnd,new m({spatialReference:n}));return null!=t&&null!=o?{...e,mapStart:t,mapEnd:o}:null}}var q;function z(e){let n=null;return r=>{switch(r.action){case"start":n=e.disableDisplay();break;case"end":case"cancel":null!=n&&(n.remove(),n=null)}return r}}function B(n,t=null){const o=w(n.state.viewingMode);o.options.selectionMode=!0,o.options.store=I.MIN,o.options.hud=!1;const l=r(),s={requiresGroundFeedback:!0,enableDraped:!0,exclude:new Set},c=p(),a=t??n.spatialReference,i=r=>{n.map.ground&&n.map.ground.opacity<1?s.exclude.add(U):s.exclude.delete(U),n.sceneIntersectionHelper.intersectIntersectorScreen(e(r,l),o,s);const t=o.results.min;let i;if(t.getIntersectionPoint(c))i=t.intersector===H.TERRAIN?q.GROUND:q.OTHER;else{if(!o.results.ground.getIntersectionPoint(c))return null;i=q.GROUND}return{location:n.renderCoordsHelper.fromRenderCoords(c,new m({spatialReference:a})),surfaceType:i}};let u;return e=>{if("start"===e.action){const n=i(e.screenStart);u=null!=n?n.location:null}if(null==u)return null;const n=i(e.screenEnd);return null!=n?.location?{...e,mapStart:u,mapEnd:n.location,surfaceType:n.surfaceType}:null}}!function(e){e[e.GROUND=0]="GROUND",e[e.OTHER=1]="OTHER"}(q||(q={}));const J=t(),K=p(),L=p(),Q=y();export{q as SurfaceType,F as convertToMapCoordinates,z as hideManipulatorWhileDragging,k as projectToWorldUp,B as screenToMap3D,M as screenToMapXYAtLocation,N as screenToMapXYForManipulatedObject,C as screenToRenderPlane,P as screenToRenderPlaneFromEvent,A as screenToRenderRay,G as screenToZConstrained};
