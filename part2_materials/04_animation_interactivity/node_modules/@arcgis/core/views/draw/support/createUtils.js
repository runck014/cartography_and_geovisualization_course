/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.32/esri/copyright.txt for details.
*/
import{equals as t,isSome as e}from"../../../core/arrayUtils.js";import{clone as o}from"../../../core/lang.js";import{getMetersPerUnitForSR as n}from"../../../core/unitUtils.js";import{m as r}from"../../../chunks/vec32.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import l from"../../../geometry/Circle.js";import{simplify as s,distance as i}from"../../../geometry/geometryEngine.js";import c from"../../../geometry/Multipoint.js";import y from"../../../geometry/Point.js";import p from"../../../geometry/Polygon.js";import u from"../../../geometry/Polyline.js";import{unnormalizeGeometryOnDatelineCrossing as m,isClockwise as f,unnormalizeVerticesOnDatelineCrossing as x}from"../../../geometry/support/coordsUtils.js";import{isValid as h}from"../../../geometry/support/spatialReferenceUtils.js";import{makeSurfacePoint as M}from"./surfaceCoordinateSystems.js";function g(t,e){const o=new y({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(o.z=t[2]),o}function d(t,e){return new c({points:t,spatialReference:e})}function R(t,e,o){const n=new u({paths:t,spatialReference:e});return o&&m(n),n}function j(e,n,r,a=!0){const l=o(e);l.forEach((e=>{const o=e[0],n=e[e.length-1];t(o,n)&&1!==e.length||e.push(e[0])}));let i=new p({rings:l,spatialReference:n});return i.rings.forEach((t=>{f(t)||t.reverse()})),r&&m(i),a&&i.isSelfIntersecting&&h(n)&&(i=s(i)),i}function T(t,o,n){const r=o.mapToLocalMultiple(t),a=[],l={x:r[0].x,y:r[0].y},s={x:r[1].x,y:r[1].y},i=Math.round(s.x-l.x),c=Math.round(s.y-l.y),y=Math.max(Math.abs(i),Math.abs(c));if(n){const t={x:l.x+y,y:l.y+y},e={x:l.x-y,y:l.y-y};a.push(M(t.x,e.y),M(e.x,e.y),M(e.x,t.y),M(t.x,t.y))}else{const t={x:i>0?l.x+y:l.x-y,y:c>0?l.y+y:l.y-y};a.push(M(l.x,l.y),M(t.x,l.y),M(t.x,t.y),M(l.x,t.y))}return U(j([a.map((t=>o.localToMap(t))).filter(e)],o.spatialReference,o.doUnnormalization,!0),a,o)}function b(t,o,n){let r=o.mapToLocalMultiple(t);if(1===r.length){const t=48,e=r[0];r=[M(e.x-t,e.y+t),M(e.x+t,e.y-t),M(e.x+t,e.y-t),M(e.x-t,e.y+t)]}const a=[],l={x:r[0].x,y:r[0].y},s={x:r[1].x,y:r[1].y};if(n){const t=Math.round(s.x-l.x),e=Math.round(s.y-l.y);a.push(M(l.x-t,l.y-e),M(s.x,l.y-e),M(s.x,s.y),M(l.x-t,s.y))}else a.push(M(l.x,l.y),M(s.x,l.y),M(s.x,s.y),M(l.x,s.y));return U(j([a.map((t=>o.localToMap(t))).filter(e)],o.spatialReference,o.doUnnormalization,!0),a,o)}function U(t,e,o){const n=P(e[3],e[2],o),r=P(e[1],e[2],o),a=P(e[0],e[1],o),l=P(e[0],e[3],o);return{geometry:t,midpoints:null!=n&&null!=r&&null!=a&&null!=l?{top:n,right:r,bottom:a,left:l}:null}}function P(t,e,o){w[0]=t.x,w[1]=t.y,w[2]=0,I[0]=e.x,I[1]=e.y,I[2]=0,r(w,w,I,.5),z.x=w[0],z.y=I[1],z.z=I[2];const n=o.localToMap(z);return null!=n?g(n,o.spatialReference):null}const z=M(0,0,0),w=a(),I=a();function L(t,e,o,r){const a=e.mapToLocalMultiple(t);let s=null,c=null;if(o)s=a[0],c=a[1];else{const t=a[0],e=a[1],o=Math.round(e.x-t.x),n=Math.round(e.y-t.y),r=Math.max(Math.abs(o),Math.abs(n));s=M(o>0?t.x+r/2:t.x-r/2,n>0?t.y+r/2:t.y-r/2),c=M(Math.abs(o)>Math.abs(n)?s.x-r/2:s.x,Math.abs(o)>Math.abs(n)?s.y:s.y-r/2)}const y=e.localToMap(s),p=e.localToMap(c);if(null==y||null==p)return null;e.doUnnormalization&&x([[y,p]],e.spatialReference);const u=g(y,e.spatialReference),m=g(p,e.spatialReference),f=n(e.spatialReference);let d=0;if(h(e.spatialReference))d=f*i(u,m,null);else{const t=s.x-c.x,e=s.y-c.y;d=f*Math.sqrt(t*t+e*e)*(r||1)}const R=new l({center:u,radius:d,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:j(R.rings,R.spatialReference,!1),center:u,edge:m}}function v(t,o,n){const r=o.mapToLocalMultiple(t),a=r[0],l=r[1],s=Math.round(l.x-a.x),i=Math.round(l.y-a.y),c=M(n?a.x:a.x+s/2,n?a.y:a.y+i/2),y=n?s:s/2,p=n?i:i/2,u=60,m=[],f=2*Math.PI/u;function x(t){const e=Math.cos(t),o=Math.sin(t);return M(y*e+c.x,p*o+c.y)}for(let e=0;e<u;e++)m.push(x(e*f));m.push(m[0]);const{spatialReference:h,doUnnormalization:d}=o,R=j([m.map((t=>o.localToMap(t))).filter(e)],h,d,!1),T=o.localToMap(x(Math.PI/2)),b=o.localToMap(x(0)),U=o.localToMap(x(-Math.PI/2)),P=o.localToMap(x(Math.PI));return{geometry:R,midpoints:null!=T&&null!=b&&null!=U&&null!=P?{top:g(T,h),right:g(b,h),bottom:g(U,h),left:g(P,h)}:null}}export{L as createCircle,v as createEllipse,d as createMultipoint,g as createPoint,j as createPolygon,R as createPolyline,b as createRectangle,T as createSquare};
